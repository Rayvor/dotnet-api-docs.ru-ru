<Type Name="InvalidOperationException" FullName="System.InvalidOperationException">
  <Metadata><Meta Name="ms.openlocfilehash" Value="810fe50283e801c3e7dde603475dc30ccd6ad1c8" /><Meta Name="ms.sourcegitcommit" Value="7845f124909a0999a19cc65f40feab5e75cd9b8d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="05/06/2019" /><Meta Name="ms.locfileid" Value="65064621" /></Metadata><TypeSignature Language="C#" Value="public class InvalidOperationException : SystemException" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit InvalidOperationException extends System.SystemException" />
  <TypeSignature Language="DocId" Value="T:System.InvalidOperationException" />
  <TypeSignature Language="VB.NET" Value="Public Class InvalidOperationException&#xA;Inherits SystemException" />
  <TypeSignature Language="C++ CLI" Value="public ref class InvalidOperationException : SystemException" />
  <TypeSignature Language="F#" Value="type InvalidOperationException = class&#xA;    inherit SystemException" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Exception</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.SystemException</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Исключение, которое выдается при вызове метода, недопустимого для текущего состояния объекта.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.InvalidOperationException> используется в случаях, когда возникает ошибка вызова метода по причинам, отличным от недопустимые аргументы. Как правило она возникает, когда состояние объекта не поддерживает вызов метода. Например <xref:System.InvalidOperationException> исключение генерируется методами, такими как:  
  
-   <xref:System.Collections.IEnumerator.MoveNext%2A?displayProperty=nameWithType> Если объекты коллекции изменяются после создания перечислителя. Дополнительные сведения см. в разделе [изменения коллекции во время итерации его](#Iterating).  
  
-   <xref:System.Resources.ResourceSet.GetString%2A?displayProperty=nameWithType> Если набор ресурсов был закрыт до вызов метода.  
  
-   <xref:System.Xml.Linq.XContainer.Add%2A?displayProperty=nameWithType>, если объект или объекты для добавления приведет к неправильно структурированных XML-документа.  
  
-   Метод, который пытается обработать пользовательский Интерфейс из потока, не являющегося главным или потока пользовательского интерфейса.  
  
> [!IMPORTANT]
>  Так как <xref:System.InvalidOperationException> исключение может выдаваться в самых разнообразных ситуациях, очень важно прочитать сообщение об исключении, возвращенный <xref:System.Exception.Message%2A> свойство.  
  
 Содержание  
  
 [Наиболее распространенные причины исключения InvalidOperationException](#Causes)   
 [Обновление потока пользовательского интерфейса из потока без пользовательского интерфейса](#UI)  
 [Изменение коллекции при последовательном переходе его](#Iterating)  
 [Сортировка массива или коллекции нельзя сравнивать, объекты](#Sorting)  
 [Приведение Nullable&lt;T&gt; , значение равно null, если к его базовому типу](#Nullable)   
 [Вызов метода System.Linq.Enumerable для пустой коллекции](#Empty)  
 [Вызов Enumerable.Single или Enumerable.SingleOrDefault на последовательность без одного элемента](#Single)  
 [Доступ к полям динамического между доменами приложений](#Emit)  
[Исключение InvalidOperationException](#Throwing)  
[Прочие сведения](#Misc)  
  
<a name="Causes"></a>   
## <a name="some-common-causes-of-invalidoperationexception-exceptions"></a>Наиболее распространенные причины исключения InvalidOperationException  
 В следующих разделах показано, как некоторые наиболее распространенные случаи, в котором в <xref:System.InvalidOperationException> исключения в приложении. Способ решения проблемы зависит от конкретной ситуации. Наиболее часто, однако исключение приводит к после ошибки разработчика и <xref:System.InvalidOperationException> исключение может быть ожидали и избегать.  
  
<a name="UI"></a>   
### <a name="updating-a-ui-thread-from-a-non-ui-thread"></a>Обновление потока пользовательского интерфейса из потока без пользовательского интерфейса  
 Часто рабочие потоки используются для выполнения некоторых фоновой работы, который включает в себя сбор данных для отображения в пользовательском интерфейсе приложения. Тем не менее. Большинство платформ приложений GUI (графический интерфейс пользователя) для .NET Framework, такие как Windows Forms и Windows Presentation Foundation (WPF) разрешают доступ к объектам графического интерфейса пользователя только из потока, который создает и управляет пользовательским Интерфейсом (поток Main или пользовательского интерфейса). <xref:System.InvalidOperationException> Возникает исключение при попытке получить доступ к элементу пользовательского интерфейса из потока, отличного от потока пользовательского интерфейса.  В следующей таблице показан текст сообщений об исключениях.  
  
|Тип приложения|Сообщение|  
|----------------------|-------------|  
|Приложения WPF|**Вызывающий поток не может доступе к этому объекту, так как им владеет другой поток.**|  
|Приложения универсальной платформы Windows|**Приложение вызвало интерфейс, который был маршалирован для другого потока.**|  
|Приложение Windows Forms|**Недопустимая операция в нескольких потоках: Элемент управления 'TextBox1' доступ из потока, отличного от потока, он был создан на.**|  
  
 Платформы пользовательского интерфейса для платформы .NET Framework реализуют *dispatcher* шаблон, который содержит метод для проверки, выполняется ли вызов члена элемента пользовательского интерфейса в потоке пользовательского интерфейса, а также другие методы для планирования вызова в потоке пользовательского интерфейса:  
  
-   В приложениях WPF, вызовите <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A?displayProperty=nameWithType> метод, чтобы определить, выполняется ли метод в потоке без пользовательского интерфейса. Он возвращает `true` Если метод выполняется в потоке пользовательского интерфейса и `false` в противном случае. Вызовите одну из перегрузок <xref:System.Windows.Threading.Dispatcher.Invoke%2A?displayProperty=nameWithType> метод для планирования вызова в потоке пользовательского интерфейса.  
  
-   В приложениях UWP, вызовите [CoreDispatcher.HasThreadAccess](https://msdn.microsoft.com/library/windows/apps/windows.ui.core.coredispatcher.hasthreadaccess.aspx) метод, чтобы определить, выполняется ли метод в потоке без пользовательского интерфейса. Вызовите [CoreDispatcher.RunAsync](https://msdn.microsoft.com/library/windows/apps/windows.ui.core.coredispatcher.runasync.aspx) методом для выполнения делегата, который обновляет поток пользовательского интерфейса. Используйте команду  
  
-   В приложениях Windows Forms, использовать <xref:System.Windows.Forms.Control.InvokeRequired%2A?displayProperty=nameWithType> свойства, чтобы определить, выполняется ли метод в потоке без пользовательского интерфейса. Вызовите одну из перегрузок <xref:System.Windows.Forms.Control.Invoke%2A?displayProperty=nameWithType> методом для выполнения делегата, который обновляет поток пользовательского интерфейса.  
  
 В следующих примерах показаны <xref:System.InvalidOperationException> исключение, возникающее при попытке обновить элемент пользовательского интерфейса из потока, в потоке, создавшем его.  Каждый пример необходимо создать два элемента управления:  
  
-   Элемент управления текстовым полем с именем `textBox1`.  В приложении Windows Forms, необходимо задать его <xref:System.Windows.Forms.TextBox.Multiline%2A> свойства `true`.  
  
-   Элемент управления кнопки с именем `threadExampleBtn`. Пример содержит обработчик, `ThreadsExampleBtn_Click`, на кнопке `Click` событий.  
  
 В каждом случае `threadExampleBtn_Click` вызовов обработчика событий `DoSomeWork` метод дважды. Первый вызов выполняется синхронно и завершается успешно. Но второй вызов, так как она выполняется асинхронно в потоке пула потоков, пытается обновить интерфейс пользователя из потока без пользовательского интерфейса. В результате <xref:System.InvalidOperationException> исключение.  
  
 Приложения WPF и UWP  
 [!code-csharp[System.InvalidOperationException.Threading.WPF1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf1/cs/MainWindow.xaml.cs#1)]
 [!code-vb[System.InvalidOperationException.Threading.WPF1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf1/vb/MainWindow.xaml.vb#1)]  
  
 В следующей версии `DoSomeWork` метод позволяет избежать исключения в приложении WPF.  
  
 [!code-csharp[System.InvalidOperationException.Threading.WPF2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf2/cs/MainWindowDispatcher.xaml.cs#3)]
 [!code-vb[System.InvalidOperationException.Threading.WPF2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf2/vb/MainWindowDispatcher.xaml.vb#3)]  
  
 В следующей версии `DoSomeWork` метод позволяет избежать исключения в приложении UWP.  
  
 [!code-csharp[System.InvalidOperationException.Threading.UWP#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception.threading.uwp/cs/MainPage.xaml.cs#4)]
 [!code-vb[System.InvalidOperationException.Threading.UWP#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception.threading.uwp/vb/MainPage.xaml.vb#4)]  
  
 Приложения Windows Forms  
 [!code-csharp[System.InvalidOperationException.Threading.WF#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf/cs/Form1.cs#2)]
 [!code-vb[System.InvalidOperationException.Threading.WF#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf/vb/Form1.vb#2)]  
  
 В следующей версии `DoSomeWork` метод позволяет избежать исключения в приложении Windows Forms.  
  
 [!code-csharp[System.InvalidOperationException.Threading.WF2#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf2/cs/Form1.cs#5)]
 [!code-vb[System.InvalidOperationException.Threading.WF2#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf2/vb/Form1.vb#5)]  
  
<a name="Iterating"></a>   
### <a name="changing-a-collection-while-iterating-it"></a>Изменение коллекции при последовательном переходе его  
 `foreach` Инструкции на языке C# или `For Each` в Visual Basic используется для итерации элементов коллекции, а также считывать или изменять его отдельные элементы. Тем не менее он не может использоваться для добавления или удаления элементов из коллекции. В этом случае создается это <xref:System.InvalidOperationException> исключение с сообщением об ошибке, "**коллекция была изменена; Невозможно выполнить операцию перечисления.** "  
  
 Приведенный ниже пример проходит попыток коллекцию целых чисел, добавляемый в коллекцию квадрат каждого целого числа. В примере создается исключение <xref:System.InvalidOperationException> с первого вызова <xref:System.Collections.Generic.List%601.Add%2A?displayProperty=nameWithType> метод.  
  
 [!code-csharp[System.InvalidOperationException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Iterating1.cs#1)]
 [!code-vb[System.InvalidOperationException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Iterating1.vb#1)]  
  
 В зависимости от логики приложения, то можно исключить исключение в одном из двух способов:  
  
-   Элементы должны быть добавлены в коллекцию при последовательном переходе его, вы можете переключаться с помощью индекса `for` инструкции, а не `foreach` или `For Each`. В следующем примере используется оператор добавить квадрат чисел из коллекции в коллекцию.  
  
     [!code-csharp[System.InvalidOperationException#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Iterating2.cs#2)]
     [!code-vb[System.InvalidOperationException#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Iterating2.vb#2)]  
  
     Обратите внимание, что число итераций, которые необходимо установить до начала итерации коллекции, либо с помощью счетчика в цикле для выхода из цикла соответствующим образом, путем итерации назад, из `Count` - 1 к 0, или, как пример, назначив номер элементов в массиве переменной и его использованию для установления верхняя граница цикла. В противном случае если элемент добавляется в коллекцию для каждой итерации, результаты бесконечного цикла.  
  
-   Если нет необходимости добавлять элементы в коллекцию при последовательном переходе его, вы можете хранить элементов для добавления в временную коллекцию, можно добавить после завершения итерации коллекции.  В следующем примере используется этот подход для добавления квадрат чисел из в коллекции временную коллекцию, а затем объединить коллекций в один объект массива.  
  
     [!code-csharp[System.InvalidOperationException#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Iterating3.cs#3)]
     [!code-vb[System.InvalidOperationException#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Iterating3.vb#3)]  
  
<a name="Sorting"></a>   
### <a name="sorting-an-array-or-collection-whose-objects-cannot-be-compared"></a>Сортировка массива или коллекции нельзя сравнивать, объекты  
 Общего назначения, методы, такие как сортировки <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> метод или <xref:System.Collections.Generic.List%601.Sort?displayProperty=nameWithType> метод, обычно требуется реализовать, по крайней мере один из объектов должны быть отсортированы <xref:System.IComparable%601> или <xref:System.IComparable> интерфейс. Если нет, коллекции или массива нельзя отсортировать, и метод вызывает <xref:System.InvalidOperationException> исключение. В следующем примере определяется `Person` класса хранилищ двумя `Person` объекты в универсальной <xref:System.Collections.Generic.List%601> объекта и пытается их сортировки. Как видно в результатах показано в примере, вызов <xref:System.Collections.Generic.List%601.Sort?displayProperty=nameWithType> вызывает метод <xref:System.InvalidOperationException>.  
  
 [!code-csharp[System.InvalidOperationException#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort1.cs#12)]
 [!code-vb[System.InvalidOperationException#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort1.vb#12)]  
  
 Можно устранить исключение в любом из трех способов:  
  
-   Если у вас может есть тип, который вы пытаетесь сортировки (то есть, если вы его исходный код для элементов управления), можно изменить его, чтобы реализовать <xref:System.IComparable%601> или <xref:System.IComparable> интерфейс. Для этого требуется реализуют либо <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> или <xref:System.IComparable.CompareTo%2A> метод. Добавление в существующий тип в реализации интерфейса не является критическим изменением.  
  
     В следующем примере используется этот подход для предоставления <xref:System.IComparable%601> внедрению `Person` класса. Можно по-прежнему вызывать коллекции или массива общий способ сортировки, и, как видно из примера, коллекции сортирует успешно.  
  
     [!code-csharp[System.InvalidOperationException#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort2.cs#13)]
     [!code-vb[System.InvalidOperationException#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort2.vb#13)]  
  
-   Если не удается изменить исходный код для типа, который вы пытаетесь сортировки, можно определить специальные сортировки класс, реализующий <xref:System.Collections.Generic.IComparer%601> интерфейс.  Можно вызвать перегрузку `Sort` метод, который включает в себя <xref:System.Collections.Generic.IComparer%601> параметра. Этот подход особенно полезен в тех случаях, если вы хотите разрабатывать специализированный класс сортировки, можно сортировать объекты, на основе нескольких критериев.  
  
     В следующем примере используется метод путем разработки пользовательского `PersonComparer` класс, используемый для сортировки `Person` коллекций.  Затем он передает экземпляр этого класса <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29?displayProperty=nameWithType> метод.  
  
     [!code-csharp[System.InvalidOperationException#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort3.cs#14)]
     [!code-vb[System.InvalidOperationException#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort3.vb#14)]  
  
-   Если не удается изменить исходный код для типа необходимо отсортировать, можно создать <xref:System.Comparison%601> делегат для выполнения сортировки. Сигнатура делегата  
  
    ```vb  
    Function Comparison(Of T)(x As T, y As T) As Integer  
    ```  
  
    ```csharp  
    int Comparison<T>(T x, T y)  
    ```  
  
     В следующем примере используется подход, определив `PersonComparison` метод, который соответствует <xref:System.Comparison%601> сигнатуре делегата.  Затем он передает этот делегат для <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29?displayProperty=nameWithType> метод.  
  
     [!code-csharp[System.InvalidOperationException#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort4.cs#15)]
     [!code-vb[System.InvalidOperationException#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort4.vb#15)]  
  
<a name="Nullable"></a>   
### <a name="casting-a-nullablet-that-is-null-to-its-underlying-type"></a>Приведение Nullable\<T >, значение равно null, если к его базовому типу  
 Попытка приведения <xref:System.Nullable%601> значение, которое является `null` к его базовому типу вызывает <xref:System.InvalidOperationException> исключения и отображает сообщение об ошибке "**объектов со значениями NULL должен иметь значение.**  
  
 В следующем примере возникает исключение <xref:System.InvalidOperationException> исключение при попытке итерация массива, которая включает `Nullable(Of Integer)` значение.  
  
 [!code-csharp[System.InvalidOperationException#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Nullable1.cs#4)]
 [!code-vb[System.InvalidOperationException#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Nullable1.vb#4)]  
  
 Чтобы предотвратить это исключение:  
  
-   Используйте <xref:System.Nullable%601.HasValue%2A?displayProperty=nameWithType> свойство, чтобы выбрать только те элементы, которые не являются `null`.  
  
-   Вызовите один из <xref:System.Nullable%601.GetValueOrDefault%2A?displayProperty=nameWithType> перегрузок, чтобы предоставить значение по умолчанию для `null` значение.  
  
 В следующем примере выполняются оба во избежание <xref:System.InvalidOperationException> исключение.  
  
 [!code-csharp[System.InvalidOperationException#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Nullable2.cs#5)]
 [!code-vb[System.InvalidOperationException#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Nullable2.vb#5)]  
  
<a name="Empty"></a>   
### <a name="calling-a-systemlinqenumerable-method-on-an-empty-collection"></a>Вызов метода System.Linq.Enumerable для пустой коллекции  
 <xref:System.Linq.Enumerable.Aggregate%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Average%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Last%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Max%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Min%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType>, И <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> методы выполняют операции над последовательностью и возвращают один результат.   Некоторые перегрузки этих методов throw <xref:System.InvalidOperationException> исключение, если последовательность пуста, пока другие перегрузки возвращают `null`. <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> Метод также выдает <xref:System.InvalidOperationException> исключение, если последовательность содержит более одного элемента.  
  
> [!NOTE]
>  Большинство методов, которые выдают <xref:System.InvalidOperationException> исключения являются перегрузками. Убедитесь, что вы понимаете поведение выбираемой перегрузки.  
  
 В следующей таблице перечислены сообщения об исключениях из <xref:System.InvalidOperationException> объектов исключений, вызванных вызовы некоторых <xref:System.Linq.Enumerable?displayProperty=nameWithType> методы.  
  
|Метод|Сообщение|  
|------------|-------------|  
|`Aggregate` <br /> `Average` <br /> `Last` <br /> `Max` <br /> `Min`|**Последовательность не содержит элементов**|  
|`First`|**Последовательность не содержит соответствующий элемент**|  
|`Single` <br /> `SingleOrDefault`|**Последовательность содержит более одного соответствующего элемента**|  
  
 Как исключить или обработать исключение зависит от приложения предположения и конкретного метода, который вы вызываете.  
  
-   Когда вы намеренно вызовите один из этих методов без проверки для пустой последовательности, предполагается, что последовательность не пуста, и что пустая последовательностью не ожидается. В этом случае подходит перехват или повторное создание исключения.  
  
-   В случае непреднамеренного невыполнение проверяемый для пустой последовательности вы можете вызвать один из перегруженных версий <xref:System.Linq.Enumerable.Any%2A?displayProperty=nameWithType> перегрузки, чтобы определить, содержит ли последовательность какие-либо элементы.  
  
    > [!TIP]
    >  Вызов <xref:System.Linq.Enumerable.Any%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType> метод перед созданием последовательности может повысить производительность, если данные для обработки может содержать большое количество элементов или если операция, создающая последовательность дорого.  
  
-   Если вызван метод, такие как <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Last%2A?displayProperty=nameWithType>, или <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType>, можно заменить альтернативного метода, такие как <xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.LastOrDefault%2A?displayProperty=nameWithType>, или <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType>, возвращает значение по умолчанию, а не членом последовательности.  
  
 Примеры приведены дополнительные сведения.  
  
 В следующем примере используется <xref:System.Linq.Enumerable.Average%2A?displayProperty=nameWithType> метод, чтобы подсчитывать среднее для последовательности, значения которых больше 4. Так как значения из исходного массива не должна превышать 4, значения не включаются в последовательности и вызывает метод <xref:System.InvalidOperationException> исключение.  
  
 [!code-csharp[System.InvalidOperationException#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable1.cs#6)]
 [!code-vb[System.InvalidOperationException#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable1.vb#6)]  
  
 Исключение, можно устранить путем вызова <xref:System.Linq.Enumerable.Any%2A> метод, чтобы определить, содержит ли последовательность какие-либо элементы, до вызова метода, который обрабатывает последовательности, как показано в следующем примере.  
  
 [!code-csharp[System.InvalidOperationException#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable2.cs#7)]
 [!code-vb[System.InvalidOperationException#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable2.vb#7)]  
  
 <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType> Метод возвращает первый элемент в последовательности или первый элемент в последовательности, удовлетворяющий указанному условию. Если последовательность пуста и не имеющая первым элементом, он выдает <xref:System.InvalidOperationException> исключение.  
  
 В следующем примере <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType> вызывает метод <xref:System.InvalidOperationException> исключения так, как dbQueryResults массив не содержит ни одного элемента больше 4.  
  
 [!code-csharp[System.InvalidOperationException#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable3.cs#8)]
 [!code-vb[System.InvalidOperationException#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable3.vb#8)]  
  
 Можно вызвать <xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType> вместо метода <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType> для возвращения заданного значения или значение по умолчанию. Если метод не находит первый элемент в последовательности, возвращается значение по умолчанию для этого типа данных.  Значение по умолчанию — `null` для ссылочного типа, нуль для числовой тип данных, и <xref:System.DateTime.MinValue?displayProperty=nameWithType> для <xref:System.DateTime> типа.  
  
> [!NOTE]
>  Интерпретация значения, возвращенного <xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType> метод часто усложняется тем фактом, что значение по умолчанию типа может быть допустимое значение в последовательности. В этом случае вы вызов <xref:System.Linq.Enumerable.Any%2A?displayProperty=nameWithType> метод, чтобы определить, имеет ли последовательность допустимых членов, перед вызовом <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType> метод.  
  
 В следующем примере вызывается <xref:System.Linq.Enumerable.FirstOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType> метод, чтобы запретить <xref:System.InvalidOperationException> исключение, возникшее в предыдущем примере.  
  
 [!code-csharp[System.InvalidOperationException#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable4.cs#9)]
 [!code-vb[System.InvalidOperationException#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable4.vb#9)]  
  
<a name="Single"></a>   
### <a name="calling-enumerablesingle-or-enumerablesingleordefault-on-a-sequence-without-one-element"></a>Вызов Enumerable.Single или Enumerable.SingleOrDefault на последовательность без одного элемента  
 <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> Метод возвращает единственный элемент последовательности или единственный элемент последовательности, который удовлетворяет заданному условию.    Если в последовательности нет элементов, или если имеется более одного элемента, метод вызывает <xref:System.InvalidOperationException> исключение.  
  
 Можно использовать <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> метод вернет значение по умолчанию, а не вызывает исключение, если последовательность не содержит элементов. Тем не менее <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> метод по-прежнему вызывает <xref:System.InvalidOperationException> исключение, если последовательность содержит более одного элемента.  
  
 В следующей таблице перечислены сообщения об исключениях из <xref:System.InvalidOperationException> объектов исключений, вызванных вызовы <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> и <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> методы.  
  
|Метод|Сообщение|  
|------------|-------------|  
|`Single`|**Последовательность не содержит соответствующий элемент**|  
|`Single` <br /> `SingleOrDefault`|**Последовательность содержит более одного соответствующего элемента**|  
  
 В следующем примере вызов <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> вызывает метод <xref:System.InvalidOperationException> исключение поскольку последовательность не имеет элемент больше 4.  
  
 [!code-csharp[System.InvalidOperationException#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable5.cs#10)]
 [!code-vb[System.InvalidOperationException#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable5.vb#10)]  
  
 В следующем примере предпринимается во избежание <xref:System.InvalidOperationException> исключение, возникающее, когда последовательность пуста, вместо вызова <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> метод. Тем не менее, поскольку эта последовательность возвращает несколько элементов, значение которого больше 2, он также создает исключение <xref:System.InvalidOperationException> исключение.  
  
 [!code-csharp[System.InvalidOperationException#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable6.cs#11)]
 [!code-vb[System.InvalidOperationException#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable6.vb#11)]  
  
 Вызов <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> метод предполагает, что последовательности или последовательности, которая отвечает указанным критериям содержит только один элемент.  <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> предполагается, что последовательность с помощью ноль или один результат, но не более. Если это предположение является намеренным со стороны пользователя, и эти условия не выполняются, повторное создание или перехват итоговый <xref:System.InvalidOperationException> подходит. В противном случае или если предполагается, что недопустимые условия будут происходить с некоторой частотой, можно использовать другой <xref:System.Linq.Enumerable> метод, такой как <xref:System.Linq.Enumerable.FirstOrDefault%2A> или <xref:System.Linq.Enumerable.Where%2A>.  
  
<a name="Emit"></a>   
### <a name="dynamic-cross-application-domain-field-access"></a>Доступ к полям динамического между доменами приложений  
 <xref:System.Reflection.Emit.OpCodes.Ldflda?displayProperty=nameWithType> Microsoft, выдает инструкции промежуточного языка (MSIL) <xref:System.InvalidOperationException> исключение, если объект, содержащий поле, адрес которого вы пытаетесь получить находится за пределами домена приложения, в котором выполняется код. Адрес поля может осуществляться только из домена приложения, в котором он находится.  
  
<a name="Throwing"></a>   
## <a name="throwing-an-invalidoperationexception-exception"></a>Исключение InvalidOperationException  
 Необходимо вызвать исключение <xref:System.InvalidOperationException> только в том случае, если состояние объекта для какой-либо причине не поддерживает вызов конкретного метода. То есть вызов метода является допустимым в некоторых обстоятельствах или контекстов, но является недопустимым в других.  
  
 В случае сбоя вызова метода из-за недопустимых аргументов, затем <xref:System.ArgumentException> или одного из его производных классов <xref:System.ArgumentNullException> или <xref:System.ArgumentOutOfRangeException>, должны быть выданы.  
  
<a name="Misc"></a>   
## <a name="miscellaneous-information"></a>Прочие сведения  
 <xref:System.InvalidOperationException> использует значением COR_E_INVALIDOPERATION HRESULT, которое имеет значение 0x80131509.  
  
 Список начальных значений свойств для экземпляра <xref:System.InvalidOperationException>, см. в разделе <xref:System.InvalidOperationException.%23ctor%2A> конструкторы.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Exception" />
    <altmember cref="T:System.Collections.IEnumerator" />
    <altmember cref="T:System.Resources.ResourceSet" />
    <related type="Article" href="~/docs/standard/exceptions/index.md">Обработка и создание исключений</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.InvalidOperationException" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InvalidOperationException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InvalidOperationException();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.InvalidOperationException" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор инициализирует <xref:System.Exception.Message%2A> свойства нового экземпляра системное сообщение с описанием ошибки, такие как «не может выполнить запрошенную операцию.» Это сообщение учитывает текущую культуру системы.  
  
 В следующей таблице представлены исходные значения свойств экземпляра класса <xref:System.InvalidOperationException>.  
  
|Свойство.|Значение|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Пустая ссылка (`Nothing` в Visual Basic).|  
|<xref:System.Exception.Message%2A>|Строка локализованного сообщения об ошибке.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InvalidOperationException (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InvalidOperationException(System::String ^ message);" />
      <MemberSignature Language="F#" Value="new InvalidOperationException : string -&gt; InvalidOperationException" Usage="new System.InvalidOperationException message" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Сообщение, описывающее ошибку.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.InvalidOperationException" /> с указанным сообщением об ошибке.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор инициализирует <xref:System.Exception.Message%2A?displayProperty=nameWithType> нового исключения, используя свойство `message` параметр. Содержимое `message` должно быть понятно пользователю. Код, вызывающий этот конструктор, должен обеспечить локализацию данной строки в соответствии с текущим языком и региональными параметрами системы.  
  
 В следующей таблице представлены исходные значения свойств экземпляра класса <xref:System.InvalidOperationException>.  
  
|Свойство.|Значение|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Пустая ссылка (`Nothing` в Visual Basic).|  
|<xref:System.Exception.Message%2A>|Строка сообщения об ошибке.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected InvalidOperationException (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; InvalidOperationException(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new InvalidOperationException : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; InvalidOperationException" Usage="new System.InvalidOperationException (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info">Объект, содержащий сериализованные данные объекта.</param>
        <param name="context">Контекстные сведения об источнике или назначении.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.InvalidOperationException" /> с сериализованными данными.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный конструктор вызывается в процессе десериализации для воссоздания объекта исключения, переданного в потоке. Дополнительные сведения см. в разделе [сериализация XML и SOAP](~/docs/standard/serialization/xml-and-soap-serialization.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/serialization/xml-and-soap-serialization.md">Сериализация XML и SOAP</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InvalidOperationException (string message, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor(System.String,System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String, innerException As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InvalidOperationException(System::String ^ message, Exception ^ innerException);" />
      <MemberSignature Language="F#" Value="new InvalidOperationException : string * Exception -&gt; InvalidOperationException" Usage="new System.InvalidOperationException (message, innerException)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">Сообщение об ошибке, указывающее причину создания исключения.</param>
        <param name="innerException">Исключение, которое является причиной текущего исключения. Если параметр <paramref name="innerException" /> не является указателем null (<see langword="Nothing" /> в Visual Basic), то текущее исключение создается в блоке <see langword="catch" />, обрабатывающем внутреннее исключение.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.InvalidOperationException" /> указанным сообщением об ошибке и ссылкой на внутреннее исключение, вызвавшее данное исключение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Исключение, созданное как прямой результат предыдущего исключения, должно содержать в свойстве <xref:System.Exception.InnerException%2A> ссылку на предыдущее исключение. Свойство <xref:System.Exception.InnerException%2A> возвращает то же значение, которое передается конструктору, или пустую ссылку (`Nothing` в Visual Basic), если свойство <xref:System.Exception.InnerException%2A> не предоставляет конструктору значение внутреннего исключения.  
  
 В следующей таблице представлены исходные значения свойств экземпляра класса <xref:System.InvalidOperationException>.  
  
|Свойство.|Значение|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Ссылка на внутреннее исключение.|  
|<xref:System.Exception.Message%2A>|Строка сообщения об ошибке.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Exception" />
        <related type="Article" href="~/docs/standard/exceptions/index.md">Обработка и создание исключений</related>
      </Docs>
    </Member>
  </Members>
</Type>