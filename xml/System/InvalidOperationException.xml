<Type Name="InvalidOperationException" FullName="System.InvalidOperationException">
  <Metadata><Meta Name="ms.openlocfilehash" Value="810fe50283e801c3e7dde603475dc30ccd6ad1c8" /><Meta Name="ms.sourcegitcommit" Value="7845f124909a0999a19cc65f40feab5e75cd9b8d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="05/06/2019" /><Meta Name="ms.locfileid" Value="65064621" /></Metadata><TypeSignature Language="C#" Value="public class InvalidOperationException : SystemException" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit InvalidOperationException extends System.SystemException" />
  <TypeSignature Language="DocId" Value="T:System.InvalidOperationException" />
  <TypeSignature Language="VB.NET" Value="Public Class InvalidOperationException&#xA;Inherits SystemException" />
  <TypeSignature Language="C++ CLI" Value="public ref class InvalidOperationException : SystemException" />
  <TypeSignature Language="F#" Value="type InvalidOperationException = class&#xA;    inherit SystemException" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Exception</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.SystemException</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Исключение, которое выдается при вызове метода, недопустимого для текущего состояния объекта.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.InvalidOperationException>используется в случаях, когда сбой вызова метода вызван по причинам, отличным от недопустимых аргументов. Как правило, он вызывается, когда состояние объекта не поддерживает вызов метода. Например, <xref:System.InvalidOperationException> исключение вызывается такими методами, как:  
  
-   <xref:System.Collections.IEnumerator.MoveNext%2A?displayProperty=nameWithType>значение, если объекты коллекции изменяются после создания перечислителя. Дополнительные сведения см. [в разделе изменение коллекции во время итерации](#Iterating).  
  
-   <xref:System.Resources.ResourceSet.GetString%2A?displayProperty=nameWithType>значение, если набор ресурсов закрывается до вызова метода.  
  
-   <xref:System.Xml.Linq.XContainer.Add%2A?displayProperty=nameWithType>, если добавляемый объект или объекты приведут к неправильному структурированному XML-документу.  
  
-   Метод, который пытается управлять пользовательским интерфейсом из потока, который не является основным потоком или потоком пользовательского интерфейса.  
  
> [!IMPORTANT]
>  Поскольку исключение может быть создано в самых разных обстоятельствах, важно прочитать сообщение об исключении, возвращаемое <xref:System.Exception.Message%2A> свойством. <xref:System.InvalidOperationException>  
  
 Содержание  
  
 [Некоторые распространенные причины исключений InvalidOperationException](#Causes)   
 [Обновление потока пользовательского интерфейса из потока, не относящегося к пользовательскому интерфейсу](#UI)  
 [Изменение коллекции во время ее итерации](#Iterating)  
 [Сортировка массива или коллекции, объекты которой невозможно сравнить](#Sorting)  
 [Приведение значения&lt;NULL&gt; T, равного null, к базовому типу](#Nullable)   
 [Вызов метода System. LINQ. Enumerable для пустой коллекции](#Empty)  
 [Вызов Enumerable. Single или Enumerable. SingleOrDefault для последовательности без одного элемента](#Single)  
 [Динамическое обращение к полю домена между приложениями](#Emit)  
[Создание исключения InvalidOperationException](#Throwing)  
[Прочие сведения](#Misc)  
  
<a name="Causes"></a>   
## <a name="some-common-causes-of-invalidoperationexception-exceptions"></a>Некоторые распространенные причины исключений InvalidOperationException  
 В следующих разделах показано, как часто возникают ситуации, в <xref:System.InvalidOperationException> которых исключение возникает в приложении. Способ решения проблемы зависит от конкретной ситуации. Однако чаще всего исключение возникает из ошибки разработчика, и это <xref:System.InvalidOperationException> исключение можно ожидать и избежать.  
  
<a name="UI"></a>   
### <a name="updating-a-ui-thread-from-a-non-ui-thread"></a>Обновление потока пользовательского интерфейса из потока, не относящегося к пользовательскому интерфейсу  
 Часто рабочие потоки используются для выполнения некоторой фоновой работы, включающей сбор данных, отображаемых в пользовательском интерфейсе приложения. Несмотря. Большинство платформ приложений графического пользовательского интерфейса (графический интерфейс пользователя) для .NET Framework, таких как Windows Forms и Windows Presentation Foundation (WPF), позволяют получать доступ к объектам графического пользовательского интерфейса только из потока, который создает пользовательский интерфейс и управляет им (основным потоком или потоком пользовательского интерфейса). <xref:System.InvalidOperationException> Исключение возникает при попытке доступа к элементу пользовательского интерфейса из потока, отличного от потока пользовательского интерфейса.  Текст сообщения об исключении показан в следующей таблице.  
  
|Тип приложения|Сообщение|  
|----------------------|-------------|  
|Приложение WPF|**Вызывающий поток не может получить доступ к этому объекту, так как он принадлежит другому потоку.**|  
|Приложение UWP|**Приложение называется интерфейсом, который был маршалирован для другого потока.**|  
|Приложение Windows Forms|**Недопустимая операция между потоками: Доступ к элементу "TextBox1" осуществляется из потока, отличного от потока, в котором он был создан.**|  
  
 Платформы пользовательского интерфейса для .NET Framework реализуют шаблон *Dispatcher* , который включает метод для проверки того, выполняется ли вызов элемента пользовательского интерфейса в ПОТОКЕ пользовательского интерфейса, а также другие методы для планирования вызова в ПОТОКЕ пользовательского интерфейса:  
  
-   В приложениях WPF вызовите <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A?displayProperty=nameWithType> метод, чтобы определить, выполняется ли метод в потоке без пользовательского интерфейса. Он возвращает `true` значение, если метод работает в потоке пользовательского интерфейса `false` и в противном случае. Вызовите одну из перегрузок <xref:System.Windows.Threading.Dispatcher.Invoke%2A?displayProperty=nameWithType> метода, чтобы запланировать вызов в потоке пользовательского интерфейса.  
  
-   В приложениях UWP вызовите метод [CoreDispatcher. хассреадакцесс](https://msdn.microsoft.com/library/windows/apps/windows.ui.core.coredispatcher.hasthreadaccess.aspx) , чтобы определить, выполняется ли метод в потоке без пользовательского интерфейса. Вызовите метод [CoreDispatcher. RunAsync](https://msdn.microsoft.com/library/windows/apps/windows.ui.core.coredispatcher.runasync.aspx) для выполнения делегата, который обновляет поток пользовательского интерфейса. Используйте команду  
  
-   В Windows Forms приложениях используйте <xref:System.Windows.Forms.Control.InvokeRequired%2A?displayProperty=nameWithType> свойство, чтобы определить, выполняется ли метод в потоке без пользовательского интерфейса. Вызовите одну из перегрузок <xref:System.Windows.Forms.Control.Invoke%2A?displayProperty=nameWithType> метода, чтобы выполнить делегат, который обновляет поток пользовательского интерфейса.  
  
 В следующих примерах показано <xref:System.InvalidOperationException> исключение, возникающее при попытке обновить элемент пользовательского интерфейса из потока, отличного от создавшего его потока.  Для каждого примера необходимо создать два элемента управления:  
  
-   Элемент управления "текстовое поле `textBox1`" с именем.  В Windows Forms приложении следует задать для <xref:System.Windows.Forms.TextBox.Multiline%2A> `true`его свойства значение.  
  
-   Элемент управления Button с `threadExampleBtn`именем. В примере показан обработчик `ThreadsExampleBtn_Click`для `Click` события кнопки.  
  
 В каждом случае `threadExampleBtn_Click` обработчик событий `DoSomeWork` вызывает метод дважды. Первый вызов выполняется синхронно и завершился. Но второй вызов, поскольку он выполняется асинхронно в потоке пула потоков, пытается обновить пользовательский интерфейс из потока, не относящегося к пользовательскому интерфейсу. Это приводит к <xref:System.InvalidOperationException> исключению.  
  
 Приложения WPF и UWP  
 [!code-csharp[System.InvalidOperationException.Threading.WPF1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf1/cs/MainWindow.xaml.cs#1)]
 [!code-vb[System.InvalidOperationException.Threading.WPF1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf1/vb/MainWindow.xaml.vb#1)]  
  
 Следующая версия `DoSomeWork` метода устраняет исключение в приложении WPF.  
  
 [!code-csharp[System.InvalidOperationException.Threading.WPF2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf2/cs/MainWindowDispatcher.xaml.cs#3)]
 [!code-vb[System.InvalidOperationException.Threading.WPF2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf2/vb/MainWindowDispatcher.xaml.vb#3)]  
  
 Следующая версия `DoSomeWork` метода устраняет исключение в приложении UWP.  
  
 [!code-csharp[System.InvalidOperationException.Threading.UWP#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception.threading.uwp/cs/MainPage.xaml.cs#4)]
 [!code-vb[System.InvalidOperationException.Threading.UWP#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception.threading.uwp/vb/MainPage.xaml.vb#4)]  
  
 Приложения Windows Forms  
 [!code-csharp[System.InvalidOperationException.Threading.WF#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf/cs/Form1.cs#2)]
 [!code-vb[System.InvalidOperationException.Threading.WF#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf/vb/Form1.vb#2)]  
  
 Следующая версия `DoSomeWork` метода устраняет исключение в Windows Forms приложении.  
  
 [!code-csharp[System.InvalidOperationException.Threading.WF2#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf2/cs/Form1.cs#5)]
 [!code-vb[System.InvalidOperationException.Threading.WF2#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf2/vb/Form1.vb#5)]  
  
<a name="Iterating"></a>   
### <a name="changing-a-collection-while-iterating-it"></a>Изменение коллекции во время ее итерации  
 Инструкция в C# операторе `For Each` или в Visual Basic используется для итерации элементов коллекции и чтения или изменения отдельных элементов. `foreach` Однако его нельзя использовать для добавления или удаления элементов из коллекции. При этом создается <xref:System.InvalidOperationException> исключение с сообщением, похожее на "**коллекция была изменена; Операция перечисления не может быть выполнена ".**  
  
 В следующем примере выполняется итерация коллекции целых чисел, которая пытается добавить квадрат каждого целого числа в коллекцию. В примере создается <xref:System.InvalidOperationException> исключение с первым вызовом <xref:System.Collections.Generic.List%601.Add%2A?displayProperty=nameWithType> метода.  
  
 [!code-csharp[System.InvalidOperationException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Iterating1.cs#1)]
 [!code-vb[System.InvalidOperationException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Iterating1.vb#1)]  
  
 Исключение можно устранить одним из двух способов, в зависимости от логики приложения:  
  
-   Если во время итерации в коллекцию необходимо добавить элементы, можно выполнить итерацию по индексу, используя `for` инструкцию, `foreach` а `For Each`не или. В следующем примере оператор for используется для добавления квадрата чисел из коллекции в коллекцию.  
  
     [!code-csharp[System.InvalidOperationException#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Iterating2.cs#2)]
     [!code-vb[System.InvalidOperationException#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Iterating2.vb#2)]  
  
     Обратите внимание, что перед перебором коллекции необходимо установить число итераций с помощью счетчика внутри цикла, который выполнит цикл соответствующим образом, выполнив итерацию назад, от `Count` -1 до 0 или, как в примере, назначив номер элементов массива в переменную и его использование для установления верхней границы цикла. В противном случае, если элемент добавляется в коллекцию при каждой итерации, будет получен бесконечный цикл.  
  
-   Если нет необходимости добавлять элементы в коллекцию во время итерации, можно сохранить элементы, добавляемые во временную коллекцию, добавленную при итерации коллекции.  В следующем примере этот подход используется для добавления квадрата чисел из коллекции в временную коллекцию, а затем для объединения коллекций в один объект массива.  
  
     [!code-csharp[System.InvalidOperationException#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Iterating3.cs#3)]
     [!code-vb[System.InvalidOperationException#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Iterating3.vb#3)]  
  
<a name="Sorting"></a>   
### <a name="sorting-an-array-or-collection-whose-objects-cannot-be-compared"></a>Сортировка массива или коллекции, объекты которой невозможно сравнить  
 Для методов сортировки общего назначения, таких <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> как метод <xref:System.Collections.Generic.List%601.Sort?displayProperty=nameWithType> или метод, обычно требуется, чтобы хотя бы один из объектов был <xref:System.IComparable> отсортирован, реализуя интерфейс или.<xref:System.IComparable%601> В противном случае коллекция или массив не могут быть отсортированы, а метод создает <xref:System.InvalidOperationException> исключение. В следующем примере определяется `Person` класс, хранится два `Person` объекта в универсальном <xref:System.Collections.Generic.List%601> объекте и выполняется попытка их сортировки. Как видно из выходных данных в примере, вызов <xref:System.Collections.Generic.List%601.Sort?displayProperty=nameWithType> метода <xref:System.InvalidOperationException>создает исключение.  
  
 [!code-csharp[System.InvalidOperationException#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort1.cs#12)]
 [!code-vb[System.InvalidOperationException#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort1.vb#12)]  
  
 Исключение можно устранить одним из трех способов:  
  
-   Если тип, который вы пытаетесь отсортировать, можно использовать (то есть если вы управляете его исходным кодом), его можно изменить, чтобы реализовать <xref:System.IComparable%601> <xref:System.IComparable> интерфейс или. Для этого необходимо реализовать <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> <xref:System.IComparable.CompareTo%2A> метод или. Добавление реализации интерфейса в существующий тип не является критическим изменением.  
  
     В следующем примере этот подход используется для предоставления <xref:System.IComparable%601> реализации `Person` класса. По-прежнему можно вызвать общий метод сортировки коллекции или массива и, как показано в выходных данных примера, коллекция сортируется успешно.  
  
     [!code-csharp[System.InvalidOperationException#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort2.cs#13)]
     [!code-vb[System.InvalidOperationException#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort2.vb#13)]  
  
-   Если не удается изменить исходный код для типа, который вы пытаетесь отсортировать, можно определить специализированный класс сортировки, реализующий <xref:System.Collections.Generic.IComparer%601> интерфейс.  Можно вызвать перегрузку `Sort` метода, который <xref:System.Collections.Generic.IComparer%601> включает параметр. Этот подход особенно удобен, если требуется разработать специализированный класс сортировки, который может сортировать объекты на основе нескольких критериев.  
  
     В следующем примере используется подход путем разработки пользовательского `PersonComparer` класса, который используется для сортировки `Person` коллекций.  Затем он передает экземпляр этого класса в <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29?displayProperty=nameWithType> метод.  
  
     [!code-csharp[System.InvalidOperationException#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort3.cs#14)]
     [!code-vb[System.InvalidOperationException#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort3.vb#14)]  
  
-   Если не удается изменить исходный код для типа, который вы пытаетесь отсортировать, можно создать <xref:System.Comparison%601> делегат для выполнения сортировки. Сигнатура делегата —  
  
    ```vb  
    Function Comparison(Of T)(x As T, y As T) As Integer  
    ```  
  
    ```csharp  
    int Comparison<T>(T x, T y)  
    ```  
  
     В следующем примере используется подход путем определения `PersonComparison` метода, который <xref:System.Comparison%601> соответствует сигнатуре делегата.  Затем он передает этот делегат <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29?displayProperty=nameWithType> методу.  
  
     [!code-csharp[System.InvalidOperationException#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort4.cs#15)]
     [!code-vb[System.InvalidOperationException#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort4.vb#15)]  
  
<a name="Nullable"></a>   
### <a name="casting-a-nullablet-that-is-null-to-its-underlying-type"></a>Приведение значения\<NULL T >, равного null, соответствующему типу  
 Попытка приведения <xref:System.Nullable%601> значения `null` к базовому типу вызывает <xref:System.InvalidOperationException> исключение и отображает сообщение об ошибке "объект, допускающий значение null,**должен иметь значение.**  
  
 В следующем примере создается <xref:System.InvalidOperationException> исключение при попытке выполнить итерацию массива, `Nullable(Of Integer)` содержащего значение.  
  
 [!code-csharp[System.InvalidOperationException#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Nullable1.cs#4)]
 [!code-vb[System.InvalidOperationException#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Nullable1.vb#4)]  
  
 Чтобы предотвратить исключение, сделайте следующее:  
  
-   Используйте свойство, чтобы выбрать только те элементы, которые не `null`являются. <xref:System.Nullable%601.HasValue%2A?displayProperty=nameWithType>  
  
-   Вызовите одну из <xref:System.Nullable%601.GetValueOrDefault%2A?displayProperty=nameWithType> перегрузок, чтобы предоставить значение по умолчанию `null` для значения.  
  
 В следующем примере оба варианта позволяют избежать <xref:System.InvalidOperationException> исключения.  
  
 [!code-csharp[System.InvalidOperationException#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Nullable2.cs#5)]
 [!code-vb[System.InvalidOperationException#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Nullable2.vb#5)]  
  
<a name="Empty"></a>   
### <a name="calling-a-systemlinqenumerable-method-on-an-empty-collection"></a>Вызов метода System. LINQ. Enumerable для пустой коллекции  
 <xref:System.Linq.Enumerable.Aggregate%2A?displayProperty=nameWithType>Методы, <xref:System.Linq.Enumerable.Average%2A?displayProperty=nameWithType>, ,,<xref:System.Linq.Enumerable.Last%2A?displayProperty=nameWithType>,, и<xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType>выполняют операциинадпоследовательностьюи<xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> возвращают один результат. <xref:System.Linq.Enumerable.Min%2A?displayProperty=nameWithType> <xref:System.Linq.Enumerable.Max%2A?displayProperty=nameWithType> <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType>   Некоторые перегрузки этих методов вызывают <xref:System.InvalidOperationException> исключение, если последовательность пуста, а другие перегрузки возвращают. `null` Метод также вызывает исключение, <xref:System.InvalidOperationException> если последовательность содержит более одного элемента. <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType>  
  
> [!NOTE]
>  Большинство методов, которые вызывают <xref:System.InvalidOperationException> исключение, являются перегрузками. Убедитесь, что вы понимаете поведение выбранной перегрузки.  
  
 В следующей таблице перечислены сообщения об исключениях из <xref:System.InvalidOperationException> объектов исключений, создаваемых вызовами <xref:System.Linq.Enumerable?displayProperty=nameWithType> некоторых методов.  
  
|Метод|Сообщение|  
|------------|-------------|  
|`Aggregate` <br /> `Average` <br /> `Last` <br /> `Max` <br /> `Min`|**Последовательность не содержит элементов**|  
|`First`|**Sequence не содержит соответствующего элемента**|  
|`Single` <br /> `SingleOrDefault`|**Последовательность содержит более одного соответствующего элемента**|  
  
 Способ исключения или обойти исключение зависит от допущений приложения и от конкретного метода, который вы вызываете.  
  
-   При намеренном вызове одного из этих методов без проверки пустой последовательности предполагается, что последовательность не пуста и что пустая последовательность является непредвиденным событием. В этом случае подходит перехват или повторный вызов исключения.  
  
-   Если ошибка проверки пустой последовательности была непреднамеренной, можно вызвать одну из <xref:System.Linq.Enumerable.Any%2A?displayProperty=nameWithType> перегрузок перегрузки, чтобы определить, содержит ли последовательность какие-либо элементы.  
  
    > [!TIP]
    >  <xref:System.Linq.Enumerable.Any%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType> Вызов метода до создания последовательности может повысить производительность, если обрабатываемые данные могут содержать большое количество элементов или операция, создающая последовательность, является дорогостоящей.  
  
-   Если вы вызвали метод <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Last%2A?displayProperty=nameWithType>например, или <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType>можно заменить альтернативный метод, например, <xref:System.Linq.Enumerable.LastOrDefault%2A?displayProperty=nameWithType>или <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType>, который возвращает значение по умолчанию вместо элемента последовательности.  
  
 В примерах содержатся дополнительные сведения.  
  
 В следующем примере <xref:System.Linq.Enumerable.Average%2A?displayProperty=nameWithType> метод используется для вычисления среднего значения последовательности, значение которой больше 4. Поскольку значения из исходного массива не превышают 4, в последовательность не включаются значения, а метод создает <xref:System.InvalidOperationException> исключение.  
  
 [!code-csharp[System.InvalidOperationException#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable1.cs#6)]
 [!code-vb[System.InvalidOperationException#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable1.vb#6)]  
  
 Исключение можно устранить, вызвав <xref:System.Linq.Enumerable.Any%2A> метод, чтобы определить, содержит ли последовательность какие бы то ни было элементы перед вызовом метода, обрабатывающего последовательность, как показано в следующем примере.  
  
 [!code-csharp[System.InvalidOperationException#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable2.cs#7)]
 [!code-vb[System.InvalidOperationException#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable2.vb#7)]  
  
 <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType> Метод возвращает первый элемент последовательности или первый элемент последовательности, удовлетворяющий заданному условию. Если последовательность пуста и поэтому не имеет первого элемента, то создается <xref:System.InvalidOperationException> исключение.  
  
 В следующем примере <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType> метод <xref:System.InvalidOperationException> создает исключение, так как массив дбкуериресултс не содержит элемент больше 4.  
  
 [!code-csharp[System.InvalidOperationException#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable3.cs#8)]
 [!code-vb[System.InvalidOperationException#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable3.vb#8)]  
  
 Вы можете вызвать <xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType> метод <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType> вместо того, чтобы возвращать указанное или значение по умолчанию. Если метод не находит первый элемент в последовательности, он возвращает значение по умолчанию для этого типа данных.  Значение по умолчанию `null` — для ссылочного типа, ноль для типа данных numeric и <xref:System.DateTime.MinValue?displayProperty=nameWithType> для <xref:System.DateTime> типа.  
  
> [!NOTE]
>  Анализ значения, возвращаемого <xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType> методом, часто осложняется тем, что значение по умолчанию типа может быть допустимым значением в последовательности. В этом случае вы вызываете <xref:System.Linq.Enumerable.Any%2A?displayProperty=nameWithType> метод, чтобы определить, содержит ли последовательность допустимые члены перед <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType> вызовом метода.  
  
 В следующем примере вызывается <xref:System.Linq.Enumerable.FirstOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType> метод для предотвращения исключения <xref:System.InvalidOperationException> , вызываемого в предыдущем примере.  
  
 [!code-csharp[System.InvalidOperationException#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable4.cs#9)]
 [!code-vb[System.InvalidOperationException#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable4.vb#9)]  
  
<a name="Single"></a>   
### <a name="calling-enumerablesingle-or-enumerablesingleordefault-on-a-sequence-without-one-element"></a>Вызов Enumerable. Single или Enumerable. SingleOrDefault для последовательности без одного элемента  
 <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> Метод возвращает единственный элемент последовательности или единственный элемент последовательности, соответствующий заданному условию.    Если в последовательности нет элементов или имеется более одного элемента, метод создает <xref:System.InvalidOperationException> исключение.  
  
 <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> Метод можно использовать для возврата значения по умолчанию вместо создания исключения, если последовательность не содержит элементов. Однако метод все равно вызывает исключение, если последовательность содержит более одного элемента. <xref:System.InvalidOperationException> <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType>  
  
 В следующей таблице перечислены сообщения об исключениях из <xref:System.InvalidOperationException> объектов исключений, создаваемых вызовами <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> методов <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> и.  
  
|Метод|Сообщение|  
|------------|-------------|  
|`Single`|**Sequence не содержит соответствующего элемента**|  
|`Single` <br /> `SingleOrDefault`|**Последовательность содержит более одного соответствующего элемента**|  
  
 В следующем примере вызов <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> метода <xref:System.InvalidOperationException> вызывает исключение, так как последовательность не содержит элемент больше 4.  
  
 [!code-csharp[System.InvalidOperationException#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable5.cs#10)]
 [!code-vb[System.InvalidOperationException#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable5.vb#10)]  
  
 В следующем примере предпринимается попытка предотвратить исключение, <xref:System.InvalidOperationException> возникающее, если последовательность пуста, вместо этого <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> вызывается метод. Однако, поскольку эта последовательность возвращает несколько элементов, значение которых больше 2, оно также вызывает <xref:System.InvalidOperationException> исключение.  
  
 [!code-csharp[System.InvalidOperationException#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable6.cs#11)]
 [!code-vb[System.InvalidOperationException#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable6.vb#11)]  
  
 При вызове <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> метода предполагается, что либо последовательность, либо последовательность, отвечающая указанным критериям, содержат только один элемент.  <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType>Предполагается, что последовательность имеет ноль или один результат, но больше нет. Если это предположение является предопределенной на вашей части и эти условия не выполняются, то подходящее исключение или перехват полученного результата <xref:System.InvalidOperationException> . В противном случае или, если предполагается, что при некоторой частоте возникнут недопустимые условия, <xref:System.Linq.Enumerable> следует рассмотреть возможность использования <xref:System.Linq.Enumerable.FirstOrDefault%2A> другого <xref:System.Linq.Enumerable.Where%2A>метода, например или.  
  
<a name="Emit"></a>   
### <a name="dynamic-cross-application-domain-field-access"></a>Динамическое обращение к полю домена между приложениями  
 Инструкция MSIL выдает исключение, <xref:System.InvalidOperationException> если объект, содержащий поле, адрес которого вы пытаетесь извлечь, не находится в домене приложения, в котором выполняется код. <xref:System.Reflection.Emit.OpCodes.Ldflda?displayProperty=nameWithType> Доступ к адресу поля возможен только из домена приложения, в котором оно находится.  
  
<a name="Throwing"></a>   
## <a name="throwing-an-invalidoperationexception-exception"></a>Создание исключения InvalidOperationException  
 <xref:System.InvalidOperationException> Исключение следует вызывать только в том случае, если состояние объекта по какой-либо причине не поддерживает определенный вызов метода. Это значит, что вызов метода допустим в некоторых обстоятельствах или контекстах, но является недопустимым в других.  
  
 Если ошибка вызова метода вызвана недопустимыми аргументами, то <xref:System.ArgumentException> вместо этого следует вызывать исключение или один <xref:System.ArgumentNullException> из <xref:System.ArgumentOutOfRangeException>его производных классов.  
  
<a name="Misc"></a>   
## <a name="miscellaneous-information"></a>Прочие сведения  
 <xref:System.InvalidOperationException>использует HRESULT COR_E_INVALIDOPERATION, имеющий значение 0x80131509.  
  
 Список начальных значений свойств для экземпляра <xref:System.InvalidOperationException>, см. в разделе <xref:System.InvalidOperationException.%23ctor%2A> конструкторы.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Exception" />
    <altmember cref="T:System.Collections.IEnumerator" />
    <altmember cref="T:System.Resources.ResourceSet" />
    <related type="Article" href="~/docs/standard/exceptions/index.md">Обработка и создание исключений</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.InvalidOperationException" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InvalidOperationException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InvalidOperationException();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.InvalidOperationException" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор инициализирует <xref:System.Exception.Message%2A> свойство нового экземпляра, сопоставляя с ним системное сообщение, описывающее ошибку, например "не удается выполнить запрошенную операцию". Это сообщение учитывает текущую культуру системы.  
  
 В следующей таблице представлены исходные значения свойств экземпляра класса <xref:System.InvalidOperationException>.  
  
|Свойство.|Значение|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Пустая ссылка (`Nothing` в Visual Basic).|  
|<xref:System.Exception.Message%2A>|Строка локализованного сообщения об ошибке.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InvalidOperationException (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InvalidOperationException(System::String ^ message);" />
      <MemberSignature Language="F#" Value="new InvalidOperationException : string -&gt; InvalidOperationException" Usage="new System.InvalidOperationException message" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Сообщение, описывающее ошибку.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.InvalidOperationException" /> с указанным сообщением об ошибке.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор инициализирует <xref:System.Exception.Message%2A?displayProperty=nameWithType> свойство нового исключения `message` с помощью параметра. Содержимое параметра `message` должно быть понятным пользователю. Код, вызывающий этот конструктор, должен обеспечить локализацию данной строки в соответствии с текущим языком и региональными параметрами системы.  
  
 В следующей таблице представлены исходные значения свойств экземпляра класса <xref:System.InvalidOperationException>.  
  
|Свойство.|Значение|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Пустая ссылка (`Nothing` в Visual Basic).|  
|<xref:System.Exception.Message%2A>|Строка сообщения об ошибке.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected InvalidOperationException (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; InvalidOperationException(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new InvalidOperationException : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; InvalidOperationException" Usage="new System.InvalidOperationException (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info">Объект, содержащий сериализованные данные объекта.</param>
        <param name="context">Контекстные сведения об источнике или назначении.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.InvalidOperationException" /> с сериализованными данными.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный конструктор вызывается в процессе десериализации для воссоздания объекта исключения, переданного в потоке. Дополнительные сведения см. в разделе [сериализация XML и SOAP](~/docs/standard/serialization/xml-and-soap-serialization.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/serialization/xml-and-soap-serialization.md">Сериализация XML и SOAP</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InvalidOperationException (string message, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor(System.String,System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String, innerException As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InvalidOperationException(System::String ^ message, Exception ^ innerException);" />
      <MemberSignature Language="F#" Value="new InvalidOperationException : string * Exception -&gt; InvalidOperationException" Usage="new System.InvalidOperationException (message, innerException)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">Сообщение об ошибке, указывающее причину создания исключения.</param>
        <param name="innerException">Исключение, которое вызвало текущее исключение. Если параметр <paramref name="innerException" /> не является указателем null (<see langword="Nothing" /> в Visual Basic), то текущее исключение создается в блоке <see langword="catch" />, обрабатывающем внутреннее исключение.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.InvalidOperationException" /> указанным сообщением об ошибке и ссылкой на внутреннее исключение, вызвавшее данное исключение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Исключение, созданное как прямой результат предыдущего исключения, должно содержать в свойстве <xref:System.Exception.InnerException%2A> ссылку на предыдущее исключение. Свойство <xref:System.Exception.InnerException%2A> возвращает то же значение, которое передается конструктору, или пустую ссылку (`Nothing` в Visual Basic), если свойство <xref:System.Exception.InnerException%2A> не предоставляет конструктору значение внутреннего исключения.  
  
 В следующей таблице представлены исходные значения свойств экземпляра класса <xref:System.InvalidOperationException>.  
  
|Свойство.|Значение|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Ссылка на внутреннее исключение.|  
|<xref:System.Exception.Message%2A>|Строка сообщения об ошибке.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Exception" />
        <related type="Article" href="~/docs/standard/exceptions/index.md">Обработка и создание исключений</related>
      </Docs>
    </Member>
  </Members>
</Type>