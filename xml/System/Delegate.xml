<Type Name="Delegate" FullName="System.Delegate">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a4f3eb27d87d09b654e11e796111a6930ec60349" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75042834" /></Metadata><TypeSignature Language="C#" Value="public abstract class Delegate : ICloneable, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Delegate extends System.Object implements class System.ICloneable, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Delegate" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Delegate&#xA;Implements ICloneable, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Delegate abstract : ICloneable, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Delegate = class&#xA;    interface ICloneable&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="3f057-101">Представляет делегат — структуру данных, указывающую на статический метод или на экземпляр класса и метод экземпляра этого класса.</span><span class="sxs-lookup"><span data-stu-id="3f057-101">Represents a delegate, which is a data structure that refers to a static method or to a class instance and an instance method of that class.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f057-102">Класс <xref:System.Delegate> является базовым классом для типов делегатов.</span><span class="sxs-lookup"><span data-stu-id="3f057-102">The <xref:System.Delegate> class is the base class for delegate types.</span></span> <span data-ttu-id="3f057-103">Однако только система и компиляторы могут явно наследоваться от класса <xref:System.Delegate> или класса <xref:System.MulticastDelegate>.</span><span class="sxs-lookup"><span data-stu-id="3f057-103">However, only the system and compilers can derive explicitly from the <xref:System.Delegate> class or from the <xref:System.MulticastDelegate> class.</span></span> <span data-ttu-id="3f057-104">Также не допускается получение нового типа из типа делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-104">It is also not permissible to derive a new type from a delegate type.</span></span> <span data-ttu-id="3f057-105">Класс <xref:System.Delegate> не считается типом делегата; Это класс, используемый для получения типов делегатов.</span><span class="sxs-lookup"><span data-stu-id="3f057-105">The <xref:System.Delegate> class is not considered a delegate type; it is a class used to derive delegate types.</span></span>  
  
 <span data-ttu-id="3f057-106">Большинство языков реализуют ключевое слово `delegate`, и компиляторы для этих языков могут быть производными от класса <xref:System.MulticastDelegate>. Таким образом, пользователям следует использовать ключевое слово `delegate`, предоставляемое языком.</span><span class="sxs-lookup"><span data-stu-id="3f057-106">Most languages implement a `delegate` keyword, and compilers for those languages are able to derive from the <xref:System.MulticastDelegate> class; therefore, users should use the `delegate` keyword provided by the language.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f057-107">Среда CLR предоставляет `Invoke` метод для каждого типа делегата с той же сигнатурой, что и делегат.</span><span class="sxs-lookup"><span data-stu-id="3f057-107">The common language runtime provides an `Invoke` method for each delegate type, with the same signature as the delegate.</span></span> <span data-ttu-id="3f057-108">Нет необходимости вызывать этот метод явно из C#, Visual Basic или Visual C++, так как компиляторы вызывают его автоматически.</span><span class="sxs-lookup"><span data-stu-id="3f057-108">You do not have to call this method explicitly from C#, Visual Basic, or Visual C++, because the compilers call it automatically.</span></span> <span data-ttu-id="3f057-109">Метод `Invoke` полезен в [отражении](~/docs/framework/reflection-and-codedom/reflection.md) , если требуется найти сигнатуру типа делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-109">The `Invoke` method is useful in [reflection](~/docs/framework/reflection-and-codedom/reflection.md) when you want to find the signature of the delegate type.</span></span>  
  
 <span data-ttu-id="3f057-110">Среда CLR предоставляет каждому типу делегата методы `BeginInvoke` и `EndInvoke`, чтобы обеспечить асинхронный вызов делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-110">The common language runtime provides each delegate type with `BeginInvoke` and `EndInvoke` methods, to enable asynchronous invocation of the delegate.</span></span> <span data-ttu-id="3f057-111">Дополнительные сведения об этих методах см. в разделе [асинхронный вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span><span class="sxs-lookup"><span data-stu-id="3f057-111">For more information about these methods, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
 <span data-ttu-id="3f057-112">Объявление типа делегата устанавливает контракт, указывающий сигнатуру одного или нескольких методов.</span><span class="sxs-lookup"><span data-stu-id="3f057-112">The declaration of a delegate type establishes a contract that specifies the signature of one or more methods.</span></span> <span data-ttu-id="3f057-113">Делегат — это экземпляр типа делегата, который имеет ссылки на:</span><span class="sxs-lookup"><span data-stu-id="3f057-113">A delegate is an instance of a delegate type that has references to:</span></span>  
  
-   <span data-ttu-id="3f057-114">Метод экземпляра типа и целевой объект, назначаемый этому типу.</span><span class="sxs-lookup"><span data-stu-id="3f057-114">An instance method of a type and a target object assignable to that type.</span></span>  
  
-   <span data-ttu-id="3f057-115">Метод экземпляра типа с параметром Hidden `this`, предоставленным в списке формальных параметров.</span><span class="sxs-lookup"><span data-stu-id="3f057-115">An instance method of a type, with the hidden `this` parameter exposed in the formal parameter list.</span></span> <span data-ttu-id="3f057-116">Говорят, что делегат является открытым делегатом экземпляра.</span><span class="sxs-lookup"><span data-stu-id="3f057-116">The delegate is said to be an open instance delegate.</span></span>  
  
-   <span data-ttu-id="3f057-117">Статический метод.</span><span class="sxs-lookup"><span data-stu-id="3f057-117">A static method.</span></span>  
  
-   <span data-ttu-id="3f057-118">Статический метод и целевой объект, назначаемые первому параметру метода.</span><span class="sxs-lookup"><span data-stu-id="3f057-118">A static method and a target object assignable to the first parameter of the method.</span></span> <span data-ttu-id="3f057-119">Говорят, что делегат закрыт по первому аргументу.</span><span class="sxs-lookup"><span data-stu-id="3f057-119">The delegate is said to be closed over its first argument.</span></span>  
  
 <span data-ttu-id="3f057-120">Дополнительные сведения о привязке делегата см. в описании перегрузки метода <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29>.</span><span class="sxs-lookup"><span data-stu-id="3f057-120">For more information on delegate binding, see the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f057-121">В .NET Framework версиях 1,0 и 1,1 делегат может представлять метод только в том случае, если сигнатура метода точно соответствует сигнатуре, заданной типом делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-121">In the .NET Framework versions 1.0 and 1.1, a delegate can represent a method only if the signature of the method exactly matches the signature specified by the delegate type.</span></span> <span data-ttu-id="3f057-122">Поэтому поддерживаются только первый и третий маркеры в приведенном выше списке, и первый маркер требует точного совпадения типа.</span><span class="sxs-lookup"><span data-stu-id="3f057-122">Thus, only the first and third bullets in the preceding list are supported, and the first bullet requires an exact type match.</span></span>  
  
 <span data-ttu-id="3f057-123">Когда делегат представляет метод экземпляра, закрытый для первого аргумента (наиболее распространенный случай), делегат сохраняет ссылку на точку входа метода и ссылку на объект, называемый целевым объектом, который имеет тип, который можно присвоить типу, который определил Method.</span><span class="sxs-lookup"><span data-stu-id="3f057-123">When a delegate represents an instance method closed over its first argument (the most common case), the delegate stores a reference to the method's entry point and a reference to an object, called the target, which is of a type assignable to the type that defined the method.</span></span> <span data-ttu-id="3f057-124">Когда делегат представляет открытый метод экземпляра, он сохраняет ссылку на точку входа метода.</span><span class="sxs-lookup"><span data-stu-id="3f057-124">When a delegate represents an open instance method, it stores a reference to the method's entry point.</span></span> <span data-ttu-id="3f057-125">Сигнатура делегата должна включать скрытый параметр `this` в свой список формальных параметров; в этом случае делегат не имеет ссылки на целевой объект, и при вызове делегата должен быть предоставлен целевой объект.</span><span class="sxs-lookup"><span data-stu-id="3f057-125">The delegate signature must include the hidden `this` parameter in its formal parameter list; in this case, the delegate does not have a reference to a target object, and a target object must be supplied when the delegate is invoked.</span></span>  
  
 <span data-ttu-id="3f057-126">Когда делегат представляет статический метод, делегат сохраняет ссылку на точку входа метода.</span><span class="sxs-lookup"><span data-stu-id="3f057-126">When a delegate represents a static method, the delegate stores a reference to the method's entry point.</span></span> <span data-ttu-id="3f057-127">Когда делегат представляет статический метод, закрытый для своего первого аргумента, делегат сохраняет ссылку на точку входа метода и ссылку на целевой объект, назначаемый типу первого аргумента метода.</span><span class="sxs-lookup"><span data-stu-id="3f057-127">When a delegate represents a static method closed over its first argument, the delegate stores a reference to the method's entry point and a reference to a target object assignable to the type of the method's first argument.</span></span> <span data-ttu-id="3f057-128">При вызове делегата первый аргумент статического метода получает целевой объект.</span><span class="sxs-lookup"><span data-stu-id="3f057-128">When the delegate is invoked, the first argument of the static method receives the target object.</span></span>  
  
 <span data-ttu-id="3f057-129">Список вызовов делегата — это упорядоченный набор делегатов, в которых каждый элемент списка вызывает только один из методов, представленных делегатом.</span><span class="sxs-lookup"><span data-stu-id="3f057-129">The invocation list of a delegate is an ordered set of delegates in which each element of the list invokes exactly one of the methods represented by the delegate.</span></span> <span data-ttu-id="3f057-130">Список вызовов может содержать дублирующиеся методы.</span><span class="sxs-lookup"><span data-stu-id="3f057-130">An invocation list can contain duplicate methods.</span></span> <span data-ttu-id="3f057-131">Во время вызова методы вызываются в том порядке, в котором они указаны в списке вызовов.</span><span class="sxs-lookup"><span data-stu-id="3f057-131">During an invocation, methods are invoked in the order in which they appear in the invocation list.</span></span> <span data-ttu-id="3f057-132">Делегат пытается вызвать каждый метод в своем списке вызовов; дубликаты вызываются один раз для каждого, когда они появляются в списке вызовов.</span><span class="sxs-lookup"><span data-stu-id="3f057-132">A delegate attempts to invoke every method in its invocation list; duplicates are invoked once for each time they appear in the invocation list.</span></span> <span data-ttu-id="3f057-133">Делегаты являются неизменяемыми; После создания список вызовов делегата не изменяется.</span><span class="sxs-lookup"><span data-stu-id="3f057-133">Delegates are immutable; once created, the invocation list of a delegate does not change.</span></span>  
  
 <span data-ttu-id="3f057-134">Делегаты называются многоадресностью или комбинированными, так как делегат может вызывать один или несколько методов и может использоваться в операциях объединения.</span><span class="sxs-lookup"><span data-stu-id="3f057-134">Delegates are referred to as multicast, or combinable, because a delegate can invoke one or more methods and can be used in combining operations.</span></span>  
  
 <span data-ttu-id="3f057-135">Объединение операций, таких как <xref:System.Delegate.Combine%2A> и <xref:System.Delegate.Remove%2A>, не приводит к изменению существующих делегатов.</span><span class="sxs-lookup"><span data-stu-id="3f057-135">Combining operations, such as <xref:System.Delegate.Combine%2A> and <xref:System.Delegate.Remove%2A>, do not alter existing delegates.</span></span> <span data-ttu-id="3f057-136">Вместо этого такая операция возвращает новый делегат, который содержит результаты операции, неизмененный делегат или `null`.</span><span class="sxs-lookup"><span data-stu-id="3f057-136">Instead, such an operation returns a new delegate that contains the results of the operation, an unchanged delegate, or `null`.</span></span> <span data-ttu-id="3f057-137">Операция объединения возвращает `null`, если результатом операции является делегат, который не ссылается хотя бы на один метод.</span><span class="sxs-lookup"><span data-stu-id="3f057-137">A combining operation returns `null` when the result of the operation is a delegate that does not reference at least one method.</span></span> <span data-ttu-id="3f057-138">Операция объединения возвращает делегат без изменений, если запрошенная операция не имеет результата.</span><span class="sxs-lookup"><span data-stu-id="3f057-138">A combining operation returns an unchanged delegate when the requested operation has no effect.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f057-139">Управляемые языки используют методы <xref:System.Delegate.Combine%2A> и <xref:System.Delegate.Remove%2A> для реализации операций делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-139">Managed languages use the <xref:System.Delegate.Combine%2A> and <xref:System.Delegate.Remove%2A> methods to implement delegate operations.</span></span> <span data-ttu-id="3f057-140">К примерам относятся операторы `AddHandler` и `RemoveHandler` в Visual Basic и операторы + = и-= для типов делегатов C#в.</span><span class="sxs-lookup"><span data-stu-id="3f057-140">Examples include the `AddHandler` and `RemoveHandler` statements in Visual Basic and the += and -= operators on delegate types in C#.</span></span>  
  
 <span data-ttu-id="3f057-141">Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], универсальные типы делегатов могут иметь параметры типа Variant.</span><span class="sxs-lookup"><span data-stu-id="3f057-141">Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], generic delegate types can have variant type parameters.</span></span> <span data-ttu-id="3f057-142">Параметры контравариантного типа можно использовать в качестве типов параметров делегата, а параметр ковариантного типа можно использовать в качестве возвращаемого типа.</span><span class="sxs-lookup"><span data-stu-id="3f057-142">Contravariant type parameters can be used as parameter types of the delegate, and a covariant type parameter can be used as the return type.</span></span> <span data-ttu-id="3f057-143">Эта функция позволяет обеспечить совместимость типов универсальных делегатов, созданных из того же определения универсального типа, если их аргументы типа являются ссылочными типами с отношением наследования, как описано в [ковариации и контрвариация](~/docs/standard/generics/covariance-and-contravariance.md).</span><span class="sxs-lookup"><span data-stu-id="3f057-143">This feature allows generic delegate types that are constructed from the same generic type definition to be assignment-compatible if their type arguments are reference types with an inheritance relationship, as explained in [Covariance and Contravariance](~/docs/standard/generics/covariance-and-contravariance.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f057-144">Универсальные делегаты, совместимые с присваиванием, в связи с дисперсией не всегда являются комбинированными.</span><span class="sxs-lookup"><span data-stu-id="3f057-144">Generic delegates that are assignment-compatible because of variance are not necessarily combinable.</span></span> <span data-ttu-id="3f057-145">Чтобы обеспечить возможность комбинирования, типы должны точно совпадать.</span><span class="sxs-lookup"><span data-stu-id="3f057-145">To be combinable, the types must match exactly.</span></span> <span data-ttu-id="3f057-146">Например, предположим, что класс с именем `Derived` является производным от класса с именем `Base`.</span><span class="sxs-lookup"><span data-stu-id="3f057-146">For example, suppose that a class named `Derived` is derived from a class named `Base`.</span></span> <span data-ttu-id="3f057-147">Делегат типа `Action<Base>` (`Action(Of Base)` в Visual Basic) может быть назначен переменной типа `Action<Derived>`, но эти два делегата не могут быть объединены, так как типы не совпадают в точности.</span><span class="sxs-lookup"><span data-stu-id="3f057-147">A delegate of type `Action<Base>` (`Action(Of Base)` in Visual Basic) can be assigned to a variable of type `Action<Derived>`, but the two delegates cannot be combined because the types do not match exactly.</span></span>  
  
 <span data-ttu-id="3f057-148">Если вызванный метод создает исключение, метод прекращает выполнение, исключение передается обратно вызывающему объекту делегата, а остальные методы в списке вызовов не вызываются.</span><span class="sxs-lookup"><span data-stu-id="3f057-148">If an invoked method throws an exception, the method stops executing, the exception is passed back to the caller of the delegate, and remaining methods in the invocation list are not invoked.</span></span> <span data-ttu-id="3f057-149">Перехват исключения в вызывающем объекте не влияет на это поведение.</span><span class="sxs-lookup"><span data-stu-id="3f057-149">Catching the exception in the caller does not alter this behavior.</span></span>  
  
 <span data-ttu-id="3f057-150">Когда сигнатура методов, вызываемых делегатом, содержит возвращаемое значение, делегат возвращает возвращаемое значение последнего элемента в списке вызовов.</span><span class="sxs-lookup"><span data-stu-id="3f057-150">When the signature of the methods invoked by a delegate includes a return value, the delegate returns the return value of the last element in the invocation list.</span></span> <span data-ttu-id="3f057-151">Если сигнатура содержит параметр, передаваемый по ссылке, то конечное значение параметра представляет собой результат каждого метода в списке вызовов, который выполняется последовательно и обновляет значение параметра.</span><span class="sxs-lookup"><span data-stu-id="3f057-151">When the signature includes a parameter that is passed by reference, the final value of the parameter is the result of every method in the invocation list executing sequentially and updating the parameter's value.</span></span>  
  
 <span data-ttu-id="3f057-152">Ближайший эквивалент делегата в языке C является указателем на функцию.</span><span class="sxs-lookup"><span data-stu-id="3f057-152">The closest equivalent of a delegate in C is a function pointer.</span></span> <span data-ttu-id="3f057-153">Делегат может представлять статический метод или метод экземпляра.</span><span class="sxs-lookup"><span data-stu-id="3f057-153">A delegate can represent a static method or an instance method.</span></span> <span data-ttu-id="3f057-154">Когда делегат представляет метод экземпляра, в делегате хранится не только ссылка на точку входа метода, но и ссылка на экземпляр класса.</span><span class="sxs-lookup"><span data-stu-id="3f057-154">When the delegate represents an instance method, the delegate stores not only a reference to the method's entry point, but also a reference to the class instance.</span></span> <span data-ttu-id="3f057-155">В отличие от указателей функций делегаты являются объектно ориентированными и типизированными.</span><span class="sxs-lookup"><span data-stu-id="3f057-155">Unlike function pointers, delegates are object oriented and type safe.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f057-156">В следующем примере показано, как определить делегат с именем `myMethodDelegate`.</span><span class="sxs-lookup"><span data-stu-id="3f057-156">The following example shows how to define a delegate named `myMethodDelegate`.</span></span> <span data-ttu-id="3f057-157">Экземпляры этого делегата создаются для метода экземпляра и статического метода вложенного класса `mySampleClass`.</span><span class="sxs-lookup"><span data-stu-id="3f057-157">Instances of this delegate are created for an instance method and a static method of the nested `mySampleClass` class.</span></span> <span data-ttu-id="3f057-158">Для делегата метода экземпляра требуется экземпляр `mySampleClass`.</span><span class="sxs-lookup"><span data-stu-id="3f057-158">The delegate for the instance method requires an instance of `mySampleClass`.</span></span> <span data-ttu-id="3f057-159">`mySampleClass` экземпляр сохраняется в переменной с именем `mySC`.</span><span class="sxs-lookup"><span data-stu-id="3f057-159">The `mySampleClass` instance is saved in a variable named `mySC`.</span></span>  
  
 [!code-cpp[Classic Delegate Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Delegate Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Delegate Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Delegate Example/CS/source.cs#1)]
 [!code-vb[Classic Delegate Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Delegate Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.MulticastDelegate" />
    <related type="Article" href="https://msdn.microsoft.com/library/41972034-92ed-450a-9664-ab93fcc6f1fb"><span data-ttu-id="3f057-160">Асинхронный вызов синхронных методов</span><span class="sxs-lookup"><span data-stu-id="3f057-160">Calling Synchronous Methods Asynchronously</span></span></related>
    <related type="Article" href="~/docs/csharp/programming-guide/delegates/index.md"><span data-ttu-id="3f057-161">Делегаты (Руководство по программированию на C#)</span><span class="sxs-lookup"><span data-stu-id="3f057-161">Delegates (C# Programming Guide)</span></span></related>
    <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/delegates/index.md"><span data-ttu-id="3f057-162">Делегаты (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="3f057-162">Delegates (Visual Basic)</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/1cdf3420-89c1-47c0-b796-aa984020e0f8"><span data-ttu-id="3f057-163">Практическое руководство. Определение и использование делегатов (C++/CLI)</span><span class="sxs-lookup"><span data-stu-id="3f057-163">How to: Define and Use Delegates (C++/CLI)</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f"><span data-ttu-id="3f057-164">Обработка и вызов событий</span><span class="sxs-lookup"><span data-stu-id="3f057-164">Handling and Raising Events</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3f057-165">Инициализирует новый делегат.</span><span class="sxs-lookup"><span data-stu-id="3f057-165">Initializes a new delegate.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Object, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : obj * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="target" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="method" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="3f057-166">Экземпляр класса, метод <paramref name="method" /> которого вызывает делегат.</span><span class="sxs-lookup"><span data-stu-id="3f057-166">The class instance on which the delegate invokes <paramref name="method" />.</span></span></param>
        <param name="method"><span data-ttu-id="3f057-167">Имя представленного делегатом метода экземпляра.</span><span class="sxs-lookup"><span data-stu-id="3f057-167">The name of the instance method that the delegate represents.</span></span></param>
        <summary><span data-ttu-id="3f057-168">Инициализирует делегат, вызывающий заданный метод экземпляра указанного класса.</span><span class="sxs-lookup"><span data-stu-id="3f057-168">Initializes a delegate that invokes the specified instance method on the specified class instance.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f057-169">Этот конструктор нельзя использовать в коде приложения.</span><span class="sxs-lookup"><span data-stu-id="3f057-169">This constructor cannot be used in application code.</span></span> <span data-ttu-id="3f057-170">Чтобы создать делегат, указав имя метода экземпляра, используйте перегрузку метода <xref:System.Delegate.CreateDelegate%2A>, который указывает имя метода и целевой объект.</span><span class="sxs-lookup"><span data-stu-id="3f057-170">To create a delegate by specifying the name of an instance method, use an overload of the <xref:System.Delegate.CreateDelegate%2A> method that specifies a method name and a target object.</span></span> <span data-ttu-id="3f057-171">Например, перегрузка метода <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29> создает делегат для метода экземпляра с указанным именем.</span><span class="sxs-lookup"><span data-stu-id="3f057-171">For example, the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29> method overload creates a delegate for an instance method with a specified name.</span></span>  
  
 <span data-ttu-id="3f057-172">Этот конструктор создает делегаты только для методов экземпляра.</span><span class="sxs-lookup"><span data-stu-id="3f057-172">This constructor creates delegates for instance methods only.</span></span> <span data-ttu-id="3f057-173">Метод экземпляра — это метод, связанный с экземпляром класса; статический метод — это метод, который связан с самим классом.</span><span class="sxs-lookup"><span data-stu-id="3f057-173">An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3f057-174"><paramref name="target" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-174"><paramref name="target" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="3f057-175">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-175">-or-</span></span> 
 <span data-ttu-id="3f057-176"><paramref name="method" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-176"><paramref name="method" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3f057-177">Произошла ошибка связывания с целевым методом.</span><span class="sxs-lookup"><span data-stu-id="3f057-177">There was an error binding to the target method.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="3f057-178">При вызове поздней привязки с помощью таких механизмов, как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-178">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="3f057-179">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="3f057-179">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="T:System.Object" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Type, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : Type * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="target" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="method" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="3f057-180">Тип <see cref="T:System.Type" />, представляющий класс, в котором определен метод <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-180">The <see cref="T:System.Type" /> representing the class that defines <paramref name="method" />.</span></span></param>
        <param name="method"><span data-ttu-id="3f057-181">Имя представленного делегатом статического метода.</span><span class="sxs-lookup"><span data-stu-id="3f057-181">The name of the static method that the delegate represents.</span></span></param>
        <summary><span data-ttu-id="3f057-182">Инициализирует делегат, вызывающий заданный статистический метод указанного класса.</span><span class="sxs-lookup"><span data-stu-id="3f057-182">Initializes a delegate that invokes the specified static method from the specified class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f057-183">Этот конструктор нельзя использовать в коде приложения.</span><span class="sxs-lookup"><span data-stu-id="3f057-183">This constructor cannot be used in application code.</span></span> <span data-ttu-id="3f057-184">Чтобы создать делегат, указав имя статического метода, используйте перегрузку метода <xref:System.Delegate.CreateDelegate%2A>, который указывает имя метода, но не указывает целевой объект.</span><span class="sxs-lookup"><span data-stu-id="3f057-184">To create a delegate by specifying the name of a static method, use an overload of the <xref:System.Delegate.CreateDelegate%2A> method that specifies a method name but does not specify a target object.</span></span> <span data-ttu-id="3f057-185">Например, перегрузка метода <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29> создает статический делегат для метода с указанным именем.</span><span class="sxs-lookup"><span data-stu-id="3f057-185">For example, the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29> method overload creates a static delegate for a method with a specified name.</span></span>  
  
 <span data-ttu-id="3f057-186">Этот конструктор создает делегаты только для статических методов.</span><span class="sxs-lookup"><span data-stu-id="3f057-186">This constructor creates delegates for static methods only.</span></span> <span data-ttu-id="3f057-187">Метод экземпляра — это метод, связанный с экземпляром класса; статический метод — это метод, который связан с самим классом.</span><span class="sxs-lookup"><span data-stu-id="3f057-187">An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3f057-188"><paramref name="target" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-188"><paramref name="target" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="3f057-189">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-189">-or-</span></span> 
 <span data-ttu-id="3f057-190"><paramref name="method" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-190"><paramref name="method" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3f057-191"><paramref name="target" /> не является объектом типа <see langword="RuntimeType" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-191"><paramref name="target" /> is not a <see langword="RuntimeType" />.</span></span> <span data-ttu-id="3f057-192">См. статью [Типы среды выполнения в отражении](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span><span class="sxs-lookup"><span data-stu-id="3f057-192">See [Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span></span>  
  
<span data-ttu-id="3f057-193">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-193">-or-</span></span> 
 <span data-ttu-id="3f057-194"><paramref name="target" /> представляет открытый универсальный тип.</span><span class="sxs-lookup"><span data-stu-id="3f057-194"><paramref name="target" /> represents an open generic type.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="3f057-195">При вызове поздней привязки с помощью таких механизмов, как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-195">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="3f057-196">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="3f057-196">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="delegate.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3f057-197">Создает неполную копию делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-197">Creates a shallow copy of the delegate.</span></span></summary>
        <returns><span data-ttu-id="3f057-198">Неполная копия делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-198">A shallow copy of the delegate.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f057-199">Клон имеет тот же <xref:System.Type>, целевой объект, метод и список вызовов, что и исходный делегат.</span><span class="sxs-lookup"><span data-stu-id="3f057-199">The clone has the same <xref:System.Type>, target, method, and invocation list as the original delegate.</span></span>  
  
 <span data-ttu-id="3f057-200">Неполная копия создает новый экземпляр того же типа, что и исходный объект, а затем копирует нестатические поля исходного объекта.</span><span class="sxs-lookup"><span data-stu-id="3f057-200">A shallow copy creates a new instance of the same type as the original object, and then copies the nonstatic fields of the original object.</span></span> <span data-ttu-id="3f057-201">Если поле имеет тип значения, выполняется побитовая копия поля.</span><span class="sxs-lookup"><span data-stu-id="3f057-201">If the field is a value type, a bit-by-bit copy of the field is performed.</span></span> <span data-ttu-id="3f057-202">Если поле является ссылочным типом, то ссылка копируется, но на объект, на который указывает ссылка, нет; Поэтому ссылка в исходном объекте и ссылка в точке клона указывают на один и тот же объект.</span><span class="sxs-lookup"><span data-stu-id="3f057-202">If the field is a reference type, the reference is copied but the referred object is not; therefore, the reference in the original object and the reference in the clone point to the same object.</span></span> <span data-ttu-id="3f057-203">В отличие от этого, глубокая копия объекта дублирует все, на которые прямо или косвенно ссылаются поля в объекте.</span><span class="sxs-lookup"><span data-stu-id="3f057-203">In contrast, a deep copy of an object duplicates everything directly or indirectly referenced by the fields in the object.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="3f057-204">При вызове поздней привязки с помощью таких механизмов, как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-204">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="3f057-205">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="3f057-205">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3f057-206">Сцепляет списки вызовов заданных групповых (комбинируемых) делегатов.</span><span class="sxs-lookup"><span data-stu-id="3f057-206">Concatenates the invocation lists of the specified multicast (combinable) delegates.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (params Delegate[] delegates);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate[] delegates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray delegates As Delegate()) As Delegate" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(... cli::array &lt;Delegate ^&gt; ^ delegates);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate[] -&gt; Delegate" Usage="System.Delegate.Combine delegates" />
      <MemberSignature Language="C#" Value="public static Delegate Combine (Delegate[] delegates);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (delegates As Delegate()) As Delegate" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(cli::array &lt;Delegate ^&gt; ^ delegates);" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegates" Type="System.Delegate[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegates"><span data-ttu-id="3f057-207">Массив объединяемых делегатов.</span><span class="sxs-lookup"><span data-stu-id="3f057-207">The array of delegates to combine.</span></span></param>
        <summary><span data-ttu-id="3f057-208">Сцепляет списки вызовов массива делегатов.</span><span class="sxs-lookup"><span data-stu-id="3f057-208">Concatenates the invocation lists of an array of delegates.</span></span></summary>
        <returns><span data-ttu-id="3f057-209">Новый делегат со списком вызова, представляющим собой сцепление списков вызова делегатов в массиве <paramref name="delegates" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-209">A new delegate with an invocation list that concatenates the invocation lists of the delegates in the <paramref name="delegates" /> array.</span></span> <span data-ttu-id="3f057-210">Возвращает <see langword="null" />, если <paramref name="delegates" /> имеет значение <see langword="null" />, если <paramref name="delegates" /> содержит ноль элементов либо если каждая запись в <paramref name="delegates" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-210">Returns <see langword="null" /> if <paramref name="delegates" /> is <see langword="null" />, if <paramref name="delegates" /> contains zero elements, or if every entry in <paramref name="delegates" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f057-211">Если `delegates` массив содержит записи, которые `null`, эти записи игнорируются.</span><span class="sxs-lookup"><span data-stu-id="3f057-211">If the `delegates` array contains entries that are `null`, those entries are ignored.</span></span>  
  
 <span data-ttu-id="3f057-212">Список вызовов может содержать дублирующиеся записи. то есть записи, ссылающиеся на один и тот же метод для одного и того же объекта.</span><span class="sxs-lookup"><span data-stu-id="3f057-212">The invocation list can contain duplicate entries; that is, entries that refer to the same method on the same object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f057-213">Универсальные делегаты, совместимые с присваиванием, в связи с дисперсией не всегда являются комбинированными.</span><span class="sxs-lookup"><span data-stu-id="3f057-213">Generic delegates that are assignment-compatible because of variance are not necessarily combinable.</span></span> <span data-ttu-id="3f057-214">Чтобы обеспечить возможность комбинирования, типы должны точно совпадать.</span><span class="sxs-lookup"><span data-stu-id="3f057-214">To be combinable, the types must match exactly.</span></span> <span data-ttu-id="3f057-215">Например, предположим, что класс с именем `Derived` является производным от класса с именем `Base`.</span><span class="sxs-lookup"><span data-stu-id="3f057-215">For example, suppose that a class named `Derived` is derived from a class named `Base`.</span></span> <span data-ttu-id="3f057-216">Делегат типа `Action<Base>` (`Action(Of Base)` в Visual Basic) может быть назначен переменной типа `Action<Derived>`, как описано в [ковариации и контрвариация](~/docs/standard/generics/covariance-and-contravariance.md), но два делегата не могут быть объединены, так как типы не совпадают в точности.</span><span class="sxs-lookup"><span data-stu-id="3f057-216">A delegate of type `Action<Base>` (`Action(Of Base)` in Visual Basic) can be assigned to a variable of type `Action<Derived>`, as explained in [Covariance and Contravariance](~/docs/standard/generics/covariance-and-contravariance.md), but the two delegates cannot be combined because the types do not match exactly.</span></span>  
  
 <span data-ttu-id="3f057-217"><xref:System.Delegate.Combine%2A> удобно использовать для создания обработчиков событий, которые вызывают несколько методов при каждом возникновении события.</span><span class="sxs-lookup"><span data-stu-id="3f057-217"><xref:System.Delegate.Combine%2A> is useful for creating event handlers that call multiple methods each time an event occurs.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3f057-218">Не все ненулевые записи в <paramref name="delegates" /> являются экземплярами одного и того же типа делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-218">Not all the non-null entries in <paramref name="delegates" /> are instances of the same delegate type.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="3f057-219">При вызове поздней привязки с помощью таких механизмов, как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-219">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="3f057-220">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="3f057-220">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (Delegate a, Delegate b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate a, class System.Delegate b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (a As Delegate, b As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(Delegate ^ a, Delegate ^ b);" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Combine (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Delegate" />
        <Parameter Name="b" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="a"><span data-ttu-id="3f057-221">Делегат, список вызова которого передан первым.</span><span class="sxs-lookup"><span data-stu-id="3f057-221">The delegate whose invocation list comes first.</span></span></param>
        <param name="b"><span data-ttu-id="3f057-222">Делегат, список вызова которого передан последним.</span><span class="sxs-lookup"><span data-stu-id="3f057-222">The delegate whose invocation list comes last.</span></span></param>
        <summary><span data-ttu-id="3f057-223">Сцепляет списки вызовов двух делегатов.</span><span class="sxs-lookup"><span data-stu-id="3f057-223">Concatenates the invocation lists of two delegates.</span></span></summary>
        <returns><span data-ttu-id="3f057-224">Новый делегат со списком вызова, представляющим собой сцепление списков вызова, заданных в параметрах <paramref name="a" /> и <paramref name="b" /> в указанном порядке.</span><span class="sxs-lookup"><span data-stu-id="3f057-224">A new delegate with an invocation list that concatenates the invocation lists of <paramref name="a" /> and <paramref name="b" /> in that order.</span></span> <span data-ttu-id="3f057-225">Возвращает <paramref name="a" />, если <paramref name="b" /> имеет значение <see langword="null" />; возвращает <paramref name="b" />, если <paramref name="a" /> является пустой ссылкой; возвращает пустую ссылку, если <paramref name="a" /> и <paramref name="b" /> являются пустыми ссылками.</span><span class="sxs-lookup"><span data-stu-id="3f057-225">Returns <paramref name="a" /> if <paramref name="b" /> is <see langword="null" />, returns <paramref name="b" /> if <paramref name="a" /> is a null reference, and returns a null reference if both <paramref name="a" /> and <paramref name="b" /> are null references.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f057-226">Список вызовов может содержать дублирующиеся записи. то есть записи, ссылающиеся на один и тот же метод для одного и того же объекта.</span><span class="sxs-lookup"><span data-stu-id="3f057-226">The invocation list can contain duplicate entries; that is, entries that refer to the same method on the same object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f057-227">Универсальные делегаты, совместимые с присваиванием, в связи с дисперсией не всегда являются комбинированными.</span><span class="sxs-lookup"><span data-stu-id="3f057-227">Generic delegates that are assignment-compatible because of variance are not necessarily combinable.</span></span> <span data-ttu-id="3f057-228">Чтобы обеспечить возможность комбинирования, типы должны точно совпадать.</span><span class="sxs-lookup"><span data-stu-id="3f057-228">To be combinable, the types must match exactly.</span></span> <span data-ttu-id="3f057-229">Например, предположим, что класс с именем `Derived` является производным от класса с именем `Base`.</span><span class="sxs-lookup"><span data-stu-id="3f057-229">For example, suppose that a class named `Derived` is derived from a class named `Base`.</span></span> <span data-ttu-id="3f057-230">Делегат типа `Action<Base>` (`Action(Of Base)` в Visual Basic) может быть назначен переменной типа `Action<Derived>`, как описано в [ковариации и контрвариация](~/docs/standard/generics/covariance-and-contravariance.md), но два делегата не могут быть объединены, так как типы не совпадают в точности.</span><span class="sxs-lookup"><span data-stu-id="3f057-230">A delegate of type `Action<Base>` (`Action(Of Base)` in Visual Basic) can be assigned to a variable of type `Action<Derived>`, as explained in [Covariance and Contravariance](~/docs/standard/generics/covariance-and-contravariance.md), but the two delegates cannot be combined because the types do not match exactly.</span></span>  
  
 <span data-ttu-id="3f057-231"><xref:System.Delegate.Combine%2A> удобно использовать для создания обработчиков событий, которые вызывают несколько методов при каждом возникновении события.</span><span class="sxs-lookup"><span data-stu-id="3f057-231"><xref:System.Delegate.Combine%2A> is useful for creating event handlers that call multiple methods each time an event occurs.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3f057-232"><paramref name="a" /> и <paramref name="b" /> не имеют значение <see langword="null" />, а <paramref name="a" /> и <paramref name="b" /> не являются экземплярами одного и того же типа делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-232">Both <paramref name="a" /> and <paramref name="b" /> are not <see langword="null" />, and <paramref name="a" /> and <paramref name="b" /> are not instances of the same delegate type.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="3f057-233">При вызове поздней привязки с помощью таких механизмов, как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-233">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="3f057-234">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="3f057-234">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="CombineImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate CombineImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate CombineImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CombineImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CombineImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ CombineImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member CombineImpl : Delegate -&gt; Delegate&#xA;override this.CombineImpl : Delegate -&gt; Delegate" Usage="delegate.CombineImpl d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="3f057-235">Групповой (комбинируемый) делегат, чей список вызовов необходимо добавить в конец списка вызовов текущего группового (комбинируемого) делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-235">The multicast (combinable) delegate whose invocation list to append to the end of the invocation list of the current multicast (combinable) delegate.</span></span></param>
        <summary><span data-ttu-id="3f057-236">Сцепляет списки вызовов заданного группового (комбинируемого) делегата и текущего группового (комбинируемого) делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-236">Concatenates the invocation lists of the specified multicast (combinable) delegate and the current multicast (combinable) delegate.</span></span></summary>
        <returns><span data-ttu-id="3f057-237">Новый групповой (комбинируемый) делегат со списком вызовов, состоящим из сцепления списков вызовов текущего группового (комбинируемого) делегата и делегата, заданного в параметре <paramref name="d" />, или текущий групповой (комбинируемый) делегат, если <paramref name="d" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-237">A new multicast (combinable) delegate with an invocation list that concatenates the invocation list of the current multicast (combinable) delegate and the invocation list of <paramref name="d" />, or the current multicast (combinable) delegate if <paramref name="d" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f057-238">Этот метод применяется только в том случае, если текущий делегат является многоадресным (комбинированным).</span><span class="sxs-lookup"><span data-stu-id="3f057-238">This method applies only if the current delegate is multicast (combinable).</span></span>  
  
 <span data-ttu-id="3f057-239">Текущая реализация просто создает <xref:System.MulticastNotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="3f057-239">The current implementation simply throws a <xref:System.MulticastNotSupportedException>.</span></span>  
  
 <span data-ttu-id="3f057-240">Список вызовов может содержать дублирующиеся записи. то есть записи, ссылающиеся на один и тот же метод для одного и того же объекта.</span><span class="sxs-lookup"><span data-stu-id="3f057-240">The invocation list can contain duplicate entries; that is, entries that refer to the same method on the same object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MulticastNotSupportedException"><span data-ttu-id="3f057-241">Создается всегда.</span><span class="sxs-lookup"><span data-stu-id="3f057-241">Always thrown.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="3f057-242">При вызове поздней привязки с помощью таких механизмов, как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-242">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="3f057-243">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="3f057-243">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3f057-244">Создает делегат указанного типа.</span><span class="sxs-lookup"><span data-stu-id="3f057-244">Creates a delegate of the specified type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="3f057-245">Тип <see cref="T:System.Type" /> создаваемого делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-245">The <see cref="T:System.Type" /> of delegate to create.</span></span></param>
        <param name="method"><span data-ttu-id="3f057-246">Объект <see cref="T:System.Reflection.MethodInfo" />, описывающий статический метод или метод экземпляра, который будет представлен делегатом.</span><span class="sxs-lookup"><span data-stu-id="3f057-246">The <see cref="T:System.Reflection.MethodInfo" /> describing the static or instance method the delegate is to represent.</span></span> <span data-ttu-id="3f057-247">На платформе .NET Framework версий 1.0 и 1.1 поддерживаются только статические методы.</span><span class="sxs-lookup"><span data-stu-id="3f057-247">Only static methods are supported in the .NET Framework version 1.0 and 1.1.</span></span></param>
        <summary><span data-ttu-id="3f057-248">Создает делегат указанного типа, представляющий заданный статический метод.</span><span class="sxs-lookup"><span data-stu-id="3f057-248">Creates a delegate of the specified type to represent the specified static method.</span></span></summary>
        <returns><span data-ttu-id="3f057-249">Делегат указанного типа, представляющий заданный статический метод.</span><span class="sxs-lookup"><span data-stu-id="3f057-249">A delegate of the specified type to represent the specified static method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f057-250">В .NET Framework версии 1,0 и 1,1 Эта перегрузка метода создает делегаты только для статических методов.</span><span class="sxs-lookup"><span data-stu-id="3f057-250">In the .NET Framework version 1.0 and 1.1, this method overload creates delegates for static methods only.</span></span> <span data-ttu-id="3f057-251">В .NET Framework версии 2,0 Эта перегрузка метода также может создавать делегаты методов открытого экземпляра. Это значит, что делегаты явно предоставляют скрытый первый аргумент методов экземпляра.</span><span class="sxs-lookup"><span data-stu-id="3f057-251">In the .NET Framework version 2.0, this method overload also can create open instance method delegates; that is, delegates that explicitly supply the hidden first argument of instance methods.</span></span> <span data-ttu-id="3f057-252">Подробное описание см. в более общем перегрузке метода <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29>, которая позволяет создавать все сочетания открытых или закрытых делегатов для экземпляров или статических методов, а также при необходимости указывать первый аргумент.</span><span class="sxs-lookup"><span data-stu-id="3f057-252">For a detailed explanation, see the more general <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> method overload, which allows you to create all combinations of open or closed delegates for instance or static methods, and optionally to specify a first argument.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f057-253">Этот перегруженный метод следует использовать, когда делегат не закрыт по первому аргументу, так как в этом случае он выполняется несколько быстрее.</span><span class="sxs-lookup"><span data-stu-id="3f057-253">This method overload should be used when the delegate is not closed over its first argument, because it is somewhat faster in that case.</span></span>  
  
 <span data-ttu-id="3f057-254">Перегрузка этого метода эквивалентна вызову перегрузки метода <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> и указанию `true` для `throwOnBindFailure`.</span><span class="sxs-lookup"><span data-stu-id="3f057-254">This method overload is equivalent to calling the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> method overload and specifying `true` for `throwOnBindFailure`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f057-255">Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]этот метод можно использовать для доступа к неоткрытым методам, если вызывающий объект был предоставлен <xref:System.Security.Permissions.ReflectionPermission> с флагом <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> и если набор прав неоткрытых методов ограничен набором предоставления вызывающего объекта или его подмножеством.</span><span class="sxs-lookup"><span data-stu-id="3f057-255">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="3f057-256">(См. раздел [вопросы безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="3f057-256">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="3f057-257">Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.</span><span class="sxs-lookup"><span data-stu-id="3f057-257">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
## <a name="compatible-parameter-types-and-return-type"></a><span data-ttu-id="3f057-258">Совместимые типы параметров и возвращаемый тип</span><span class="sxs-lookup"><span data-stu-id="3f057-258">Compatible Parameter Types and Return Type</span></span>  
 <span data-ttu-id="3f057-259">В .NET Framework версии 2,0 типы параметров и тип возвращаемого значения делегата, созданного с помощью этой перегрузки метода, должны быть совместимы с типами параметров и типом возвращаемого значения метода, который представляет делегат. типы не обязательно должны точно совпадать.</span><span class="sxs-lookup"><span data-stu-id="3f057-259">In the .NET Framework version 2.0, the parameter types and return type of a delegate created using this method overload must be compatible with the parameter types and return type of the method the delegate represents; the types do not have to match exactly.</span></span> <span data-ttu-id="3f057-260">Это представляет ослабление поведения привязки в .NET Framework версии 1,0 и 1,1, где типы должны точно совпадать.</span><span class="sxs-lookup"><span data-stu-id="3f057-260">This represents a relaxation of the binding behavior in the .NET Framework version 1.0 and 1.1, where the types must match exactly.</span></span>  
  
 <span data-ttu-id="3f057-261">Если тип параметра делегата является более строгим, чем тип параметра метода, то параметр делегата совместим с соответствующим параметром метода, так как это гарантирует, что аргумент, переданный делегату, может быть безопасно передан методу.</span><span class="sxs-lookup"><span data-stu-id="3f057-261">A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</span></span>  
  
 <span data-ttu-id="3f057-262">Аналогичным образом, тип возвращаемого значения делегата совместим с типом возвращаемого значения метода, если тип возвращаемого значения метода является более строгим, чем тип возвращаемого значения делегата, так как это гарантирует, что возвращаемое значение метода может быть безопасно приведено к типу возвращаемого значения делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-262">Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</span></span>  
  
 <span data-ttu-id="3f057-263">Например, делегат с параметром типа <xref:System.Collections.Hashtable> и типом возвращаемого значения <xref:System.Object> может представлять метод с параметром типа <xref:System.Object> и возвращаемым значением типа <xref:System.Collections.Hashtable>.</span><span class="sxs-lookup"><span data-stu-id="3f057-263">For example, a delegate with a parameter of type <xref:System.Collections.Hashtable> and a return type of <xref:System.Object> can represent a method with a parameter of type <xref:System.Object> and a return value of type <xref:System.Collections.Hashtable>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f057-264">Этот раздел содержит два примера кода.</span><span class="sxs-lookup"><span data-stu-id="3f057-264">This section contains two code examples.</span></span> <span data-ttu-id="3f057-265">В первом примере показаны два вида делегатов, которые можно создать с помощью этой перегрузки метода: открыть через метод экземпляра и открыть в статическом методе.</span><span class="sxs-lookup"><span data-stu-id="3f057-265">The first example demonstrates the two kinds of delegates that can be created with this method overload: open over an instance method and open over a static method.</span></span>  
  
 <span data-ttu-id="3f057-266">Во втором примере кода демонстрируются совместимые типы параметров и возвращаемые типы.</span><span class="sxs-lookup"><span data-stu-id="3f057-266">The second code example demonstrates compatible parameter types and return types.</span></span>  
  
 <span data-ttu-id="3f057-267">**Пример 1**</span><span class="sxs-lookup"><span data-stu-id="3f057-267">**Example 1**</span></span>  
  
 <span data-ttu-id="3f057-268">В следующем примере кода показаны два способа создания делегата с помощью этой перегрузки метода <xref:System.Delegate.CreateDelegate%2A>.</span><span class="sxs-lookup"><span data-stu-id="3f057-268">The following code example demonstrates the two ways a delegate can be created using this overload of the <xref:System.Delegate.CreateDelegate%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f057-269">Существует две перегрузки метода <xref:System.Delegate.CreateDelegate%2A>, указывающие <xref:System.Reflection.MethodInfo>, но не первый аргумент. их функциональные возможности одинаковы, за исключением того, что позволяет указать, следует ли создавать привязку при ошибке, а вторая всегда создает исключение.</span><span class="sxs-lookup"><span data-stu-id="3f057-269">There are two overloads of the <xref:System.Delegate.CreateDelegate%2A> method that specify a <xref:System.Reflection.MethodInfo> but not a first argument; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</span></span> <span data-ttu-id="3f057-270">В этом примере кода используются обе перегрузки.</span><span class="sxs-lookup"><span data-stu-id="3f057-270">This code example uses both overloads.</span></span>  
  
 <span data-ttu-id="3f057-271">В примере объявляется класс `C` с статическим методом `M2` и методом экземпляра `M1`, а также два типа делегата: `D1` принимает экземпляр `C` и строку, а `D2` принимает строку.</span><span class="sxs-lookup"><span data-stu-id="3f057-271">The example declares a class `C` with a static method `M2` and an instance method `M1`, and two delegate types: `D1` takes an instance of `C` and a string, and `D2` takes a string.</span></span>  
  
 <span data-ttu-id="3f057-272">Второй класс с именем `Example` содержит код, создающий делегаты.</span><span class="sxs-lookup"><span data-stu-id="3f057-272">A second class named `Example` contains the code that creates the delegates.</span></span>  
  
-   <span data-ttu-id="3f057-273">Делегат типа `D1`, представляющий открытый метод экземпляра, создается для метода экземпляра `M1`.</span><span class="sxs-lookup"><span data-stu-id="3f057-273">A delegate of type `D1`, representing an open instance method, is created for the instance method `M1`.</span></span> <span data-ttu-id="3f057-274">Экземпляр должен передаваться при вызове делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-274">An instance must be passed when the delegate is invoked.</span></span>  
  
-   <span data-ttu-id="3f057-275">Делегат типа `D2`, представляющий открытый статический метод, создается для `M2`статического метода.</span><span class="sxs-lookup"><span data-stu-id="3f057-275">A delegate of type `D2`, representing an open static method, is created for the static method `M2`.</span></span>  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 <span data-ttu-id="3f057-276">**Пример 2**</span><span class="sxs-lookup"><span data-stu-id="3f057-276">**Example 2**</span></span>  
  
 <span data-ttu-id="3f057-277">В следующем примере кода демонстрируется совместимость типов параметров и возвращаемых типов.</span><span class="sxs-lookup"><span data-stu-id="3f057-277">The following code example demonstrates compatibility of parameter types and return types.</span></span>  
  
 <span data-ttu-id="3f057-278">В примере кода определяется базовый класс с именем `Base` и класс с именем `Derived`, производный от `Base`.</span><span class="sxs-lookup"><span data-stu-id="3f057-278">The code example defines a base class named `Base` and a class named `Derived` that derives from `Base`.</span></span> <span data-ttu-id="3f057-279">Производный класс имеет `static` метод (`Shared` в Visual Basic) с именем `MyMethod` с одним параметром типа `Base` и типом возвращаемого значения `Derived`.</span><span class="sxs-lookup"><span data-stu-id="3f057-279">The derived class has a `static` (`Shared` in Visual Basic) method named `MyMethod` with one parameter of type `Base` and a return type of `Derived`.</span></span> <span data-ttu-id="3f057-280">В примере кода также определяется делегат с именем `Example` с одним параметром типа `Derived` и типом возвращаемого значения `Base`.</span><span class="sxs-lookup"><span data-stu-id="3f057-280">The code example also defines a delegate named `Example` that has one parameter of type `Derived` and a return type of `Base`.</span></span>  
  
 <span data-ttu-id="3f057-281">В примере кода показано, что делегат с именем `Example` можно использовать для представления метода `MyMethod`.</span><span class="sxs-lookup"><span data-stu-id="3f057-281">The code example demonstrates that the delegate named `Example` can be used to represent the method `MyMethod`.</span></span> <span data-ttu-id="3f057-282">Метод можно привязать к делегату по следующим причинам:</span><span class="sxs-lookup"><span data-stu-id="3f057-282">The method can be bound to the delegate because:</span></span>  
  
-   <span data-ttu-id="3f057-283">Тип параметра делегата (`Derived`) имеет более строгое значение, чем тип параметра `MyMethod` (`Base`), чтобы всегда быть в безопасности передавать аргумент делегата в `MyMethod`.</span><span class="sxs-lookup"><span data-stu-id="3f057-283">The parameter type of the delegate (`Derived`) is more restrictive than the parameter type of `MyMethod` (`Base`), so that it is always safe to pass the argument of the delegate to `MyMethod`.</span></span>  
  
-   <span data-ttu-id="3f057-284">Тип возвращаемого значения `MyMethod` (`Derived`) является более строгой, чем тип параметра делегата (`Base`), чтобы всегда быть уверенным в том, чтобы привести возвращаемый тип метода к возвращаемому типу делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-284">The return type of `MyMethod` (`Derived`) is more restrictive than the parameter type of the delegate (`Base`), so that it is always safe to cast the return type of the method to the return type of the delegate.</span></span>  
  
 <span data-ttu-id="3f057-285">В примере кода выходные данные не создаются.</span><span class="sxs-lookup"><span data-stu-id="3f057-285">The code example produces no output.</span></span>  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3f057-286"><paramref name="type" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-286"><paramref name="type" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="3f057-287">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-287">-or-</span></span> 
 <span data-ttu-id="3f057-288"><paramref name="method" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-288"><paramref name="method" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3f057-289"><paramref name="type" /> не является производным от <see cref="T:System.MulticastDelegate" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-289"><paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span></span>  
  
<span data-ttu-id="3f057-290">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-290">-or-</span></span> 
 <span data-ttu-id="3f057-291"><paramref name="type" /> не является объектом типа <see langword="RuntimeType" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-291"><paramref name="type" /> is not a <see langword="RuntimeType" />.</span></span> <span data-ttu-id="3f057-292">См. статью [Типы среды выполнения в отражении](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span><span class="sxs-lookup"><span data-stu-id="3f057-292">See [Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span></span>  
  
<span data-ttu-id="3f057-293">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-293">-or-</span></span> 
 <span data-ttu-id="3f057-294"><paramref name="method" /> не является статическим методом, а версия платформы .NET Framework имеет значение 1.0 или 1.1.</span><span class="sxs-lookup"><span data-stu-id="3f057-294"><paramref name="method" /> is not a static method, and the .NET Framework version is 1.0 or 1.1.</span></span>  
  
<span data-ttu-id="3f057-295">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-295">-or-</span></span> 
 <span data-ttu-id="3f057-296">Метод <paramref name="method" /> невозможно привязать.</span><span class="sxs-lookup"><span data-stu-id="3f057-296"><paramref name="method" /> cannot be bound.</span></span>  
  
<span data-ttu-id="3f057-297">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-297">-or-</span></span> 
 <span data-ttu-id="3f057-298"><paramref name="method" /> не является объектом типа <see langword="RuntimeMethodInfo" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-298"><paramref name="method" /> is not a <see langword="RuntimeMethodInfo" />.</span></span> <span data-ttu-id="3f057-299">См. статью [Типы среды выполнения в отражении](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span><span class="sxs-lookup"><span data-stu-id="3f057-299">See [Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="3f057-300">Метод <see langword="Invoke" /> для <paramref name="type" /> не найден.</span><span class="sxs-lookup"><span data-stu-id="3f057-300">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="3f057-301">Вызывающий объект не имеет необходимых разрешений для доступа к <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-301">The caller does not have the permissions necessary to access <paramref name="method" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="3f057-302">При вызове поздней привязки с помощью таких механизмов, как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-302">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="3f057-303">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-303">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="firstArgument" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="3f057-304">Тип <see cref="T:System.Type" /> создаваемого делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-304">The <see cref="T:System.Type" /> of delegate to create.</span></span></param>
        <param name="firstArgument"><span data-ttu-id="3f057-305">Объект, с которым связан делегат, или значение <see langword="null" />, чтобы обработать <paramref name="method" /> как <see langword="static" /> (<see langword="Shared" /> в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="3f057-305">The object to which the delegate is bound, or <see langword="null" /> to treat <paramref name="method" /> as <see langword="static" /> (<see langword="Shared" /> in Visual Basic).</span></span></param>
        <param name="method"><span data-ttu-id="3f057-306">Объект <see cref="T:System.Reflection.MethodInfo" />, описывающий статический метод или метод экземпляра, который будет представлен делегатом.</span><span class="sxs-lookup"><span data-stu-id="3f057-306">The <see cref="T:System.Reflection.MethodInfo" /> describing the static or instance method the delegate is to represent.</span></span></param>
        <summary><span data-ttu-id="3f057-307">Создает делегат указанного типа, представляющий заданный статический метод или метод экземпляра, с заданным первым аргументом.</span><span class="sxs-lookup"><span data-stu-id="3f057-307">Creates a delegate of the specified type that represents the specified static or instance method, with the specified first argument.</span></span></summary>
        <returns><span data-ttu-id="3f057-308">Делегат указанного типа, представляющий заданный статический метод или метод экземпляра.</span><span class="sxs-lookup"><span data-stu-id="3f057-308">A delegate of the specified type that represents the specified static or instance method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f057-309">Вызов этой перегрузки метода эквивалентен вызову перегрузки метода <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> и указанию `true` для `throwOnBindFailure`.</span><span class="sxs-lookup"><span data-stu-id="3f057-309">Calling this method overload is equivalent to calling the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> method overload and specifying `true` for `throwOnBindFailure`.</span></span> <span data-ttu-id="3f057-310">Эти две перегрузки обеспечивают наиболее гибкий способ создания делегатов.</span><span class="sxs-lookup"><span data-stu-id="3f057-310">These two overloads provide the most flexible way to create delegates.</span></span> <span data-ttu-id="3f057-311">Их можно использовать для создания делегатов для статических методов или, а также для указания первого аргумента.</span><span class="sxs-lookup"><span data-stu-id="3f057-311">You can use them to create delegates for either static or instance methods, and optionally to specify the first argument.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f057-312">Если не указать первый аргумент, используйте перегрузку метода <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> для повышения производительности.</span><span class="sxs-lookup"><span data-stu-id="3f057-312">If you do not supply a first argument, use the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> method overload for better performance.</span></span>  
  
 <span data-ttu-id="3f057-313">Тип делегата и метод должны иметь совместимые типы возвращаемых значения.</span><span class="sxs-lookup"><span data-stu-id="3f057-313">The delegate type and the method must have compatible return types.</span></span> <span data-ttu-id="3f057-314">То есть тип возвращаемого значения `method` должен быть назначен типу возвращаемого значения `type`.</span><span class="sxs-lookup"><span data-stu-id="3f057-314">That is, the return type of `method` must be assignable to the return type of `type`.</span></span>  
  
 <span data-ttu-id="3f057-315">Если указан параметр `firstArgument`, он передается `method` каждый раз при вызове делегата; считается, что `firstArgument` привязано к делегату, и делегат называется закрытым для своего первого аргумента.</span><span class="sxs-lookup"><span data-stu-id="3f057-315">If `firstArgument` is supplied, it is passed to `method` every time the delegate is invoked; `firstArgument` is said to be bound to the delegate, and the delegate is said to be closed over its first argument.</span></span> <span data-ttu-id="3f057-316">Если `method` `static` (`Shared` в Visual Basic), список аргументов, предоставленный при вызове делегата, включает все параметры, кроме первого; Если `method` является методом экземпляра, то `firstArgument` передается в параметр скрытого экземпляра (представленный `this` в C#или `Me` в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="3f057-316">If `method` is `static` (`Shared` in Visual Basic), the argument list supplied when invoking the delegate includes all parameters except the first; if `method` is an instance method, then `firstArgument` is passed to the hidden instance parameter (represented by `this` in C#, or by `Me` in Visual Basic).</span></span>  
  
 <span data-ttu-id="3f057-317">Если указан `firstArgument`, первый параметр `method` должен быть ссылочным типом, а `firstArgument` должен быть совместим с этим типом.</span><span class="sxs-lookup"><span data-stu-id="3f057-317">If `firstArgument` is supplied, the first parameter of `method` must be a reference type, and `firstArgument` must be compatible with that type.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="3f057-318">Если `method` `static` (`Shared` в Visual Basic), а первый параметр имеет тип <xref:System.Object> или <xref:System.ValueType>, то `firstArgument` может быть типом значения.</span><span class="sxs-lookup"><span data-stu-id="3f057-318">If `method` is `static` (`Shared` in Visual Basic) and its first parameter is of type <xref:System.Object> or <xref:System.ValueType>, then `firstArgument` can be a value type.</span></span> <span data-ttu-id="3f057-319">В этом случае `firstArgument` автоматически упаковывается.</span><span class="sxs-lookup"><span data-stu-id="3f057-319">In this case `firstArgument` is automatically boxed.</span></span> <span data-ttu-id="3f057-320">Автоматическая упаковка- C# преобразование не выполняется для других аргументов, как в вызове функции или Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="3f057-320">Automatic boxing does not occur for any other arguments, as it would in a C# or Visual Basic function call.</span></span>  
  
 <span data-ttu-id="3f057-321">Если `firstArgument` является пустой ссылкой и `method` является методом экземпляра, результат зависит от сигнатур типа делегата, `type` и от `method`:</span><span class="sxs-lookup"><span data-stu-id="3f057-321">If `firstArgument` is a null reference and `method` is an instance method, the result depends on the signatures of the delegate type `type` and of `method`:</span></span>  
  
-   <span data-ttu-id="3f057-322">Если сигнатура `type` явно включает скрытый первый параметр `method`, то говорят, что делегат представляет открытый метод экземпляра.</span><span class="sxs-lookup"><span data-stu-id="3f057-322">If the signature of `type` explicitly includes the hidden first parameter of `method`, the delegate is said to represent an open instance method.</span></span> <span data-ttu-id="3f057-323">При вызове делегата первый аргумент в списке аргументов передается в параметр скрытого экземпляра `method`.</span><span class="sxs-lookup"><span data-stu-id="3f057-323">When the delegate is invoked, the first argument in the argument list is passed to the hidden instance parameter of `method`.</span></span>  
  
-   <span data-ttu-id="3f057-324">Если сигнатуры `method` и `type` совпадают (т. е. все типы параметров совместимы), то делегат называется закрытым по пустой ссылке.</span><span class="sxs-lookup"><span data-stu-id="3f057-324">If the signatures of `method` and `type` match (that is, all parameter types are compatible), then the delegate is said to be closed over a null reference.</span></span> <span data-ttu-id="3f057-325">Вызов делегата аналогичен вызову метода экземпляра для экземпляра со значением NULL, что не особенно полезно для этого.</span><span class="sxs-lookup"><span data-stu-id="3f057-325">Invoking the delegate is like calling an instance method on a null instance, which is not a particularly useful thing to do.</span></span>  
  
 <span data-ttu-id="3f057-326">Если `firstArgument` является пустой ссылкой, а `method` является статическим, результат зависит от сигнатур типа делегата, `type` и от `method`:</span><span class="sxs-lookup"><span data-stu-id="3f057-326">If `firstArgument` is a null reference and `method` is static, the result depends on the signatures of the delegate type `type` and of `method`:</span></span>  
  
-   <span data-ttu-id="3f057-327">Если сигнатура `method` и `type` совпадают (то есть все типы параметров совместимы), делегат называется открытым статическим методом.</span><span class="sxs-lookup"><span data-stu-id="3f057-327">If the signature of `method` and `type` match (that is, all parameter types are compatible), the delegate is said to represent an open static method.</span></span> <span data-ttu-id="3f057-328">Это наиболее распространенный случай для статических методов.</span><span class="sxs-lookup"><span data-stu-id="3f057-328">This is the most common case for static methods.</span></span> <span data-ttu-id="3f057-329">В этом случае можно получить немного более высокую производительность с помощью перегрузки метода <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29>.</span><span class="sxs-lookup"><span data-stu-id="3f057-329">In this case, you can get slightly better performance by using the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> method overload.</span></span>  
  
-   <span data-ttu-id="3f057-330">Если сигнатура `type` начинается со второго параметра `method` и остальные типы параметров совместимы, то делегат называется закрытым с помощью пустой ссылки.</span><span class="sxs-lookup"><span data-stu-id="3f057-330">If the signature of `type` begins with the second parameter of `method` and the rest of the parameter types are compatible, then the delegate is said to be closed over a null reference.</span></span> <span data-ttu-id="3f057-331">При вызове делегата в первый параметр `method`передается пустая ссылка.</span><span class="sxs-lookup"><span data-stu-id="3f057-331">When the delegate is invoked, a null reference is passed to the first parameter of `method`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f057-332">Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]этот метод можно использовать для доступа к неоткрытым методам, если вызывающий объект был предоставлен <xref:System.Security.Permissions.ReflectionPermission> с флагом <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> и если набор прав неоткрытых методов ограничен набором предоставления вызывающего объекта или его подмножеством.</span><span class="sxs-lookup"><span data-stu-id="3f057-332">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="3f057-333">(См. раздел [вопросы безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="3f057-333">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="3f057-334">Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.</span><span class="sxs-lookup"><span data-stu-id="3f057-334">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
## <a name="compatible-parameter-types-and-return-type"></a><span data-ttu-id="3f057-335">Совместимые типы параметров и возвращаемый тип</span><span class="sxs-lookup"><span data-stu-id="3f057-335">Compatible Parameter Types and Return Type</span></span>  
 <span data-ttu-id="3f057-336">Типы параметров и возвращаемый тип делегата должны быть совместимы с типами параметров и типом возвращаемого значения метода, который представляет делегат. типы не обязательно должны точно совпадать.</span><span class="sxs-lookup"><span data-stu-id="3f057-336">The parameter types and return type of a delegate must be compatible with the parameter types and return type of the method the delegate represents; the types do not have to match exactly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f057-337">В .NET Framework версии 1,0 и 1,1 типы должны точно совпадать.</span><span class="sxs-lookup"><span data-stu-id="3f057-337">In the .NET Framework version 1.0 and 1.1, the types must match exactly.</span></span>  
  
 <span data-ttu-id="3f057-338">Если тип параметра делегата является более строгим, чем тип параметра метода, то параметр делегата совместим с соответствующим параметром метода, так как это гарантирует, что аргумент, переданный делегату, может быть безопасно передан методу.</span><span class="sxs-lookup"><span data-stu-id="3f057-338">A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</span></span>  
  
 <span data-ttu-id="3f057-339">Аналогичным образом, тип возвращаемого значения делегата совместим с типом возвращаемого значения метода, если тип возвращаемого значения метода является более строгим, чем тип возвращаемого значения делегата, так как это гарантирует, что возвращаемое значение метода может быть безопасно приведено к типу возвращаемого значения делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-339">Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</span></span>  
  
 <span data-ttu-id="3f057-340">Например, делегат с параметром типа <xref:System.Collections.Hashtable> и типом возвращаемого значения <xref:System.Object> может представлять метод с параметром типа <xref:System.Object> и возвращаемым значением типа <xref:System.Collections.Hashtable>.</span><span class="sxs-lookup"><span data-stu-id="3f057-340">For example, a delegate with a parameter of type <xref:System.Collections.Hashtable> and a return type of <xref:System.Object> can represent a method with a parameter of type <xref:System.Object> and a return value of type <xref:System.Collections.Hashtable>.</span></span>  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a><span data-ttu-id="3f057-341">Определение методов, которые может представлять делегат</span><span class="sxs-lookup"><span data-stu-id="3f057-341">Determining the Methods a Delegate Can Represent</span></span>  
 <span data-ttu-id="3f057-342">Еще один полезный способ представить гибкость, обеспечиваемую этой перегрузкой <xref:System.Delegate.CreateDelegate%2A> заключается в том, что любой заданный делегат может представлять четыре различных сочетания сигнатуры и типа метода (статический и экземпляр).</span><span class="sxs-lookup"><span data-stu-id="3f057-342">Another useful way to think of the flexibility provided by this overload of <xref:System.Delegate.CreateDelegate%2A> is that any given delegate can represent four different combinations of method signature and method kind (static versus instance).</span></span> <span data-ttu-id="3f057-343">Рассмотрим тип делегата `D` с одним аргументом типа `C`.</span><span class="sxs-lookup"><span data-stu-id="3f057-343">Consider a delegate type `D` with one argument of type `C`.</span></span> <span data-ttu-id="3f057-344">Ниже описаны методы, которые `D` могут представлять, игнорируя возвращаемый тип, так как он должен совпадать во всех случаях:</span><span class="sxs-lookup"><span data-stu-id="3f057-344">The following describes the methods `D` can represent, ignoring the return type since it must match in all cases:</span></span>  
  
-   <span data-ttu-id="3f057-345">`D` может представлять любой метод экземпляра, имеющий ровно один аргумент типа `C`, независимо от типа, которому принадлежит метод экземпляра.</span><span class="sxs-lookup"><span data-stu-id="3f057-345">`D` can represent any instance method that has exactly one argument of type `C`, regardless of what type the instance method belongs to.</span></span> <span data-ttu-id="3f057-346">При вызове <xref:System.Delegate.CreateDelegate%2A> `firstArgument` является экземпляром типа, к которому принадлежит `method`, а получившийся делегат называется закрытым для этого экземпляра.</span><span class="sxs-lookup"><span data-stu-id="3f057-346">When <xref:System.Delegate.CreateDelegate%2A> is called, `firstArgument` is an instance of the type `method` belongs to, and the resulting delegate is said to be closed over that instance.</span></span> <span data-ttu-id="3f057-347">(Тривиальный `D` также может быть закрыта по пустой ссылке, если `firstArgument` является пустой ссылкой.)</span><span class="sxs-lookup"><span data-stu-id="3f057-347">(Trivially, `D` can also be closed over a null reference if `firstArgument` is a null reference.)</span></span>  
  
-   <span data-ttu-id="3f057-348">`D` может представлять метод экземпляра `C`, не имеющий аргументов.</span><span class="sxs-lookup"><span data-stu-id="3f057-348">`D` can represent an instance method of `C` that has no arguments.</span></span> <span data-ttu-id="3f057-349">При вызове <xref:System.Delegate.CreateDelegate%2A> `firstArgument` является пустой ссылкой.</span><span class="sxs-lookup"><span data-stu-id="3f057-349">When <xref:System.Delegate.CreateDelegate%2A> is called, `firstArgument` is a null reference.</span></span> <span data-ttu-id="3f057-350">Результирующий делегат представляет открытый метод экземпляра, а экземпляр `C` должен предоставляться каждый раз при вызове метода.</span><span class="sxs-lookup"><span data-stu-id="3f057-350">The resulting delegate represents an open instance method, and an instance of `C` must be supplied each time it is invoked.</span></span>  
  
-   <span data-ttu-id="3f057-351">`D` может представлять статический метод, который принимает один аргумент типа `C`, и этот метод может принадлежать любому типу.</span><span class="sxs-lookup"><span data-stu-id="3f057-351">`D` can represent a static method that takes one argument of type `C`, and that method can belong to any type.</span></span> <span data-ttu-id="3f057-352">При вызове <xref:System.Delegate.CreateDelegate%2A> `firstArgument` является пустой ссылкой.</span><span class="sxs-lookup"><span data-stu-id="3f057-352">When <xref:System.Delegate.CreateDelegate%2A> is called, `firstArgument` is a null reference.</span></span> <span data-ttu-id="3f057-353">Результирующий делегат представляет открытый статический метод, а экземпляр `C` должен предоставляться каждый раз при вызове метода.</span><span class="sxs-lookup"><span data-stu-id="3f057-353">The resulting delegate represents an open static method, and an instance of `C` must be supplied each time it is invoked.</span></span>  
  
-   <span data-ttu-id="3f057-354">`D` может представлять статический метод, который принадлежит к типу `F` и имеет два аргумента типа `F` и типа `C`.</span><span class="sxs-lookup"><span data-stu-id="3f057-354">`D` can represent a static method that belongs to type `F` and has two arguments, of type `F` and type `C`.</span></span> <span data-ttu-id="3f057-355">При вызове <xref:System.Delegate.CreateDelegate%2A> `firstArgument` является экземпляром `F`.</span><span class="sxs-lookup"><span data-stu-id="3f057-355">When <xref:System.Delegate.CreateDelegate%2A> is called, `firstArgument` is an instance of `F`.</span></span> <span data-ttu-id="3f057-356">Результирующий делегат представляет статический метод, закрытый для этого экземпляра `F`.</span><span class="sxs-lookup"><span data-stu-id="3f057-356">The resulting delegate represents a static method that is closed over that instance of `F`.</span></span> <span data-ttu-id="3f057-357">Обратите внимание, что в случае, когда `F` и `C` имеют один и тот же тип, статический метод имеет два аргумента этого типа.</span><span class="sxs-lookup"><span data-stu-id="3f057-357">Note that in the case where `F` and `C` are the same type, the static method has two arguments of that type.</span></span> <span data-ttu-id="3f057-358">(В данном случае `D` закрывается по пустой ссылке, если `firstArgument` является пустой ссылкой.)</span><span class="sxs-lookup"><span data-stu-id="3f057-358">(In this case, `D` is closed over a null reference if `firstArgument` is a null reference.)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f057-359">Этот раздел содержит три примера кода.</span><span class="sxs-lookup"><span data-stu-id="3f057-359">This section contains three code examples.</span></span> <span data-ttu-id="3f057-360">В первом примере показаны четыре типа делегатов, которые могут быть созданы: закрыто над методом экземпляра, открыто через метод экземпляра, открыто через статический метод и закрыто по статическому методу.</span><span class="sxs-lookup"><span data-stu-id="3f057-360">The first example demonstrates the four kinds of delegates that can be created: closed over an instance method, open over an instance method, open over a static method, and closed over a static method.</span></span>  
  
 <span data-ttu-id="3f057-361">Во втором примере кода демонстрируются совместимые типы параметров и возвращаемые типы.</span><span class="sxs-lookup"><span data-stu-id="3f057-361">The second code example demonstrates compatible parameter types and return types.</span></span>  
  
 <span data-ttu-id="3f057-362">В третьем примере кода определяется один тип делегата и отображаются все методы, которые могут представляться типом делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-362">The third code example defines a single delegate type, and shows all the methods that delegate type can represent.</span></span>  
  
 <span data-ttu-id="3f057-363">**Пример 1**</span><span class="sxs-lookup"><span data-stu-id="3f057-363">**Example 1**</span></span>  
  
 <span data-ttu-id="3f057-364">В следующем примере кода показаны четыре способа создания делегата с помощью этой перегрузки метода <xref:System.Delegate.CreateDelegate%2A>.</span><span class="sxs-lookup"><span data-stu-id="3f057-364">The following code example demonstrates the four ways a delegate can be created using this overload of the <xref:System.Delegate.CreateDelegate%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f057-365">Существует две перегрузки метода <xref:System.Delegate.CreateDelegate%2A>, указывающие `firstArgument` и <xref:System.Reflection.MethodInfo>. их функциональные возможности одинаковы, за исключением того, что позволяет указать, следует ли создавать привязку при ошибке, а вторая всегда создает исключение.</span><span class="sxs-lookup"><span data-stu-id="3f057-365">There are two overloads of the <xref:System.Delegate.CreateDelegate%2A> method that specify `firstArgument` and a <xref:System.Reflection.MethodInfo>; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</span></span> <span data-ttu-id="3f057-366">В этом примере кода используются обе перегрузки.</span><span class="sxs-lookup"><span data-stu-id="3f057-366">This code example uses both overloads.</span></span>  
  
 <span data-ttu-id="3f057-367">В примере объявляется класс `C` с статическим методом `M2` и методом экземпляра `M1`, а также три типа делегата: `D1` принимает экземпляр `C` и строку, `D2` принимает строку, а `D3` не имеет аргументов.</span><span class="sxs-lookup"><span data-stu-id="3f057-367">The example declares a class `C` with a static method `M2` and an instance method `M1`, and three delegate types: `D1` takes an instance of `C` and a string, `D2` takes a string, and `D3` has no arguments.</span></span>  
  
 <span data-ttu-id="3f057-368">Второй класс с именем `Example` содержит код, создающий делегаты.</span><span class="sxs-lookup"><span data-stu-id="3f057-368">A second class named `Example` contains the code that creates the delegates.</span></span>  
  
-   <span data-ttu-id="3f057-369">Делегат типа `D2`, закрытый для экземпляра `C`, создается для метода экземпляра `M1`.</span><span class="sxs-lookup"><span data-stu-id="3f057-369">A delegate of type `D2`, closed over an instance of `C`, is created for the instance method `M1`.</span></span> <span data-ttu-id="3f057-370">Он вызывается с разными строками, чтобы продемонстрировать, что привязанный экземпляр `C` всегда используется.</span><span class="sxs-lookup"><span data-stu-id="3f057-370">It is invoked with different strings, to show that the bound instance of `C` is always used.</span></span>  
  
-   <span data-ttu-id="3f057-371">Делегат типа `D1`, представляющий открытый метод экземпляра, создается для метода экземпляра `M1`.</span><span class="sxs-lookup"><span data-stu-id="3f057-371">A delegate of type `D1`, representing an open instance method, is created for the instance method `M1`.</span></span> <span data-ttu-id="3f057-372">Экземпляр должен передаваться при вызове делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-372">An instance must be passed when the delegate is invoked.</span></span>  
  
-   <span data-ttu-id="3f057-373">Делегат типа `D2`, представляющий открытый статический метод, создается для `M2`статического метода.</span><span class="sxs-lookup"><span data-stu-id="3f057-373">A delegate of type `D2`, representing an open static method, is created for the static method `M2`.</span></span>  
  
-   <span data-ttu-id="3f057-374">Наконец, делегат типа `D3`, закрытый над строкой, создается для статического метода `M2`.</span><span class="sxs-lookup"><span data-stu-id="3f057-374">Finally, a delegate of type `D3`, closed over a string, is created for the static method `M2`.</span></span> <span data-ttu-id="3f057-375">Метод вызывается, чтобы продемонстрировать, что он использует привязанную строку.</span><span class="sxs-lookup"><span data-stu-id="3f057-375">The method is invoked to show that it uses the bound string.</span></span>  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 <span data-ttu-id="3f057-376">**Пример 2**</span><span class="sxs-lookup"><span data-stu-id="3f057-376">**Example 2**</span></span>  
  
 <span data-ttu-id="3f057-377">В следующем примере кода демонстрируется совместимость типов параметров и возвращаемых типов.</span><span class="sxs-lookup"><span data-stu-id="3f057-377">The following code example demonstrates compatibility of parameter types and return types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f057-378">В этом примере кода используется перегрузка метода <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29>.</span><span class="sxs-lookup"><span data-stu-id="3f057-378">This code example uses the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> method overload.</span></span> <span data-ttu-id="3f057-379">Использование других перегрузок, принимающих <xref:System.Reflection.MethodInfo>, аналогично.</span><span class="sxs-lookup"><span data-stu-id="3f057-379">The use of other overloads that take <xref:System.Reflection.MethodInfo> is similar.</span></span>  
  
 <span data-ttu-id="3f057-380">В примере кода определяется базовый класс с именем `Base` и класс с именем `Derived`, производный от `Base`.</span><span class="sxs-lookup"><span data-stu-id="3f057-380">The code example defines a base class named `Base` and a class named `Derived` that derives from `Base`.</span></span> <span data-ttu-id="3f057-381">Производный класс имеет `static` метод (`Shared` в Visual Basic) с именем `MyMethod` с одним параметром типа `Base` и типом возвращаемого значения `Derived`.</span><span class="sxs-lookup"><span data-stu-id="3f057-381">The derived class has a `static` (`Shared` in Visual Basic) method named `MyMethod` with one parameter of type `Base` and a return type of `Derived`.</span></span> <span data-ttu-id="3f057-382">В примере кода также определяется делегат с именем `Example` с одним параметром типа `Derived` и типом возвращаемого значения `Base`.</span><span class="sxs-lookup"><span data-stu-id="3f057-382">The code example also defines a delegate named `Example` that has one parameter of type `Derived` and a return type of `Base`.</span></span>  
  
 <span data-ttu-id="3f057-383">В примере кода показано, что делегат с именем `Example` можно использовать для представления метода `MyMethod`.</span><span class="sxs-lookup"><span data-stu-id="3f057-383">The code example demonstrates that the delegate named `Example` can be used to represent the method `MyMethod`.</span></span> <span data-ttu-id="3f057-384">Метод можно привязать к делегату по следующим причинам:</span><span class="sxs-lookup"><span data-stu-id="3f057-384">The method can be bound to the delegate because:</span></span>  
  
-   <span data-ttu-id="3f057-385">Тип параметра делегата (`Derived`) имеет более строгое значение, чем тип параметра `MyMethod` (`Base`), чтобы всегда быть в безопасности передавать аргумент делегата в `MyMethod`.</span><span class="sxs-lookup"><span data-stu-id="3f057-385">The parameter type of the delegate (`Derived`) is more restrictive than the parameter type of `MyMethod` (`Base`), so that it is always safe to pass the argument of the delegate to `MyMethod`.</span></span>  
  
-   <span data-ttu-id="3f057-386">Тип возвращаемого значения `MyMethod` (`Derived`) является более строгой, чем тип параметра делегата (`Base`), чтобы всегда быть уверенным в том, чтобы привести возвращаемый тип метода к возвращаемому типу делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-386">The return type of `MyMethod` (`Derived`) is more restrictive than the parameter type of the delegate (`Base`), so that it is always safe to cast the return type of the method to the return type of the delegate.</span></span>  
  
 <span data-ttu-id="3f057-387">В примере кода выходные данные не создаются.</span><span class="sxs-lookup"><span data-stu-id="3f057-387">The code example produces no output.</span></span>  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 <span data-ttu-id="3f057-388">**Пример 3**</span><span class="sxs-lookup"><span data-stu-id="3f057-388">**Example 3**</span></span>  
  
 <span data-ttu-id="3f057-389">В следующем примере кода показаны все методы, которые может представлять один тип делегата, с помощью метода <xref:System.Delegate.CreateDelegate%2A> для создания делегатов.</span><span class="sxs-lookup"><span data-stu-id="3f057-389">The following code example shows all the methods a single delegate type can represent, using the <xref:System.Delegate.CreateDelegate%2A> method to create the delegates.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f057-390">Существует две перегрузки метода <xref:System.Delegate.CreateDelegate%2A>, указывающие `firstArgument` и <xref:System.Reflection.MethodInfo>. их функциональные возможности одинаковы, за исключением того, что позволяет указать, следует ли создавать привязку при ошибке, а вторая всегда создает исключение.</span><span class="sxs-lookup"><span data-stu-id="3f057-390">There are two overloads of the <xref:System.Delegate.CreateDelegate%2A> method that specify `firstArgument` and a <xref:System.Reflection.MethodInfo>; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</span></span> <span data-ttu-id="3f057-391">В этом примере кода используются обе перегрузки.</span><span class="sxs-lookup"><span data-stu-id="3f057-391">This code example uses both overloads.</span></span>  
  
 <span data-ttu-id="3f057-392">В примере кода определяются два класса: `C` и `F`, а также тип делегата `D` с одним аргументом типа `C`.</span><span class="sxs-lookup"><span data-stu-id="3f057-392">The code example defines two classes, `C` and `F`, and a delegate type `D` with one argument of type `C`.</span></span> <span data-ttu-id="3f057-393">Классы имеют совпадающие статические и методы экземпляра `M1`, `M3`и `M4`, а класс `C` также имеет метод экземпляра `M2`, не имеющий аргументов.</span><span class="sxs-lookup"><span data-stu-id="3f057-393">The classes have matching static and instance methods `M1`, `M3`, and `M4`, and class `C` also has an instance method `M2` that has no arguments.</span></span>  
  
 <span data-ttu-id="3f057-394">Третий класс с именем `Example` содержит код, создающий делегаты.</span><span class="sxs-lookup"><span data-stu-id="3f057-394">A third class named `Example` contains the code that creates the delegates.</span></span>  
  
-   <span data-ttu-id="3f057-395">Делегаты создаются для метода экземпляра `M1` типа `C` и типа `F`; Каждый из них закрыт для экземпляра соответствующего типа.</span><span class="sxs-lookup"><span data-stu-id="3f057-395">Delegates are created for instance method `M1` of type `C` and type `F`; each is closed over an instance of the respective type.</span></span> <span data-ttu-id="3f057-396">Метод `M1` типа `C` отображает свойства `ID` привязанного экземпляра и аргумента.</span><span class="sxs-lookup"><span data-stu-id="3f057-396">Method `M1` of type `C` displays the `ID` properties of the bound instance and of the argument.</span></span>  
  
-   <span data-ttu-id="3f057-397">Делегат создается для метода `M2` типа `C`.</span><span class="sxs-lookup"><span data-stu-id="3f057-397">A delegate is created for method `M2` of type `C`.</span></span> <span data-ttu-id="3f057-398">Это делегат открытого экземпляра, в котором аргумент делегата представляет собой скрытый первый аргумент в методе экземпляра.</span><span class="sxs-lookup"><span data-stu-id="3f057-398">This is an open instance delegate, in which the argument of the delegate represents the hidden first argument on the instance method.</span></span> <span data-ttu-id="3f057-399">Метод не имеет других аргументов.</span><span class="sxs-lookup"><span data-stu-id="3f057-399">The method has no other arguments.</span></span> <span data-ttu-id="3f057-400">Он вызывается, как если бы он был статическим методом.</span><span class="sxs-lookup"><span data-stu-id="3f057-400">It is called as if it were a static method.</span></span>  
  
-   <span data-ttu-id="3f057-401">Делегаты создаются для статического метода `M3` типа `C` и типа `F`; Это открытые статические делегаты.</span><span class="sxs-lookup"><span data-stu-id="3f057-401">Delegates are created for static method `M3` of type `C` and type `F`; these are open static delegates.</span></span>  
  
-   <span data-ttu-id="3f057-402">Наконец, создаются делегаты для статического метода `M4` типа `C` и типа `F`; Каждый метод имеет объявляющий тип в качестве первого аргумента, и предоставляется экземпляр типа, поэтому делегаты закрываются в своих первых аргументах.</span><span class="sxs-lookup"><span data-stu-id="3f057-402">Finally, delegates are created for static method `M4` of type `C` and type `F`; each method has the declaring type as its first argument, and an instance of the type is supplied, so the delegates are closed over their first arguments.</span></span> <span data-ttu-id="3f057-403">Метод `M4` типа `C` отображает свойства `ID` привязанного экземпляра и аргумента.</span><span class="sxs-lookup"><span data-stu-id="3f057-403">Method `M4` of type `C` displays the `ID` properties of the bound instance and of the argument.</span></span>  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3f057-404"><paramref name="type" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-404"><paramref name="type" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="3f057-405">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-405">-or-</span></span> 
 <span data-ttu-id="3f057-406"><paramref name="method" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-406"><paramref name="method" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3f057-407"><paramref name="type" /> не является производным от <see cref="T:System.MulticastDelegate" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-407"><paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span></span>  
  
<span data-ttu-id="3f057-408">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-408">-or-</span></span> 
 <span data-ttu-id="3f057-409"><paramref name="type" /> не является объектом типа <see langword="RuntimeType" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-409"><paramref name="type" /> is not a <see langword="RuntimeType" />.</span></span> <span data-ttu-id="3f057-410">См. статью [Типы среды выполнения в отражении](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span><span class="sxs-lookup"><span data-stu-id="3f057-410">See [Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span></span>  
  
<span data-ttu-id="3f057-411">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-411">-or-</span></span> 
 <span data-ttu-id="3f057-412">Метод <paramref name="method" /> невозможно привязать.</span><span class="sxs-lookup"><span data-stu-id="3f057-412"><paramref name="method" /> cannot be bound.</span></span>  
  
<span data-ttu-id="3f057-413">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-413">-or-</span></span> 
 <span data-ttu-id="3f057-414"><paramref name="method" /> не является объектом типа <see langword="RuntimeMethodInfo" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-414"><paramref name="method" /> is not a <see langword="RuntimeMethodInfo" />.</span></span> <span data-ttu-id="3f057-415">См. статью [Типы среды выполнения в отражении](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span><span class="sxs-lookup"><span data-stu-id="3f057-415">See [Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="3f057-416">Метод <see langword="Invoke" /> для <paramref name="type" /> не найден.</span><span class="sxs-lookup"><span data-stu-id="3f057-416">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="3f057-417">Вызывающий объект не имеет необходимых разрешений для доступа к <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-417">The caller does not have the permissions necessary to access <paramref name="method" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="3f057-418">При вызове поздней привязки с помощью таких механизмов, как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-418">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="3f057-419">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-419">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="target" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="3f057-420">Тип <see cref="T:System.Type" /> создаваемого делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-420">The <see cref="T:System.Type" /> of delegate to create.</span></span></param>
        <param name="target"><span data-ttu-id="3f057-421">Экземпляр класса, для которого вызывается метод <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-421">The class instance on which <paramref name="method" /> is invoked.</span></span></param>
        <param name="method"><span data-ttu-id="3f057-422">Имя метода экземпляра, который должен быть представлен делегатом.</span><span class="sxs-lookup"><span data-stu-id="3f057-422">The name of the instance method that the delegate is to represent.</span></span></param>
        <summary><span data-ttu-id="3f057-423">Создает делегат указанного типа, представляющий заданный метод экземпляра, который вызывается для заданного экземпляра класса.</span><span class="sxs-lookup"><span data-stu-id="3f057-423">Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</span></span></summary>
        <returns><span data-ttu-id="3f057-424">Создает делегат указанного типа, представляющий заданный метод экземпляра, который вызывается для заданного экземпляра класса.</span><span class="sxs-lookup"><span data-stu-id="3f057-424">A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f057-425">Этот метод создает делегаты только для методов экземпляра.</span><span class="sxs-lookup"><span data-stu-id="3f057-425">This method creates delegates for instance methods only.</span></span> <span data-ttu-id="3f057-426">Метод экземпляра — это метод, связанный с экземпляром класса; статический метод — это метод, который связан с самим классом.</span><span class="sxs-lookup"><span data-stu-id="3f057-426">An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</span></span>  
  
 <span data-ttu-id="3f057-427">Перегрузка этого метода эквивалентна вызову перегрузки метода <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29>, указывающей `false` для `ignoreCase` и `true` для `throwOnBindFailure`.</span><span class="sxs-lookup"><span data-stu-id="3f057-427">This method overload is equivalent to calling the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> method overload, specifying `false` for `ignoreCase` and `true` for `throwOnBindFailure`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f057-428">Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]этот метод можно использовать для доступа к неоткрытым методам, если вызывающий объект был предоставлен <xref:System.Security.Permissions.ReflectionPermission> с флагом <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> и если набор прав неоткрытых методов ограничен набором предоставления вызывающего объекта или его подмножеством.</span><span class="sxs-lookup"><span data-stu-id="3f057-428">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="3f057-429">(См. раздел [вопросы безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="3f057-429">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="3f057-430">Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.</span><span class="sxs-lookup"><span data-stu-id="3f057-430">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3f057-431"><paramref name="type" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-431"><paramref name="type" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="3f057-432">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-432">-or-</span></span> 
 <span data-ttu-id="3f057-433"><paramref name="target" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-433"><paramref name="target" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="3f057-434">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-434">-or-</span></span> 
 <span data-ttu-id="3f057-435"><paramref name="method" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-435"><paramref name="method" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3f057-436"><paramref name="type" /> не является производным от <see cref="T:System.MulticastDelegate" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-436"><paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span></span>  
  
<span data-ttu-id="3f057-437">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-437">-or-</span></span> 
 <span data-ttu-id="3f057-438"><paramref name="type" /> не является объектом типа <see langword="RuntimeType" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-438"><paramref name="type" /> is not a <see langword="RuntimeType" />.</span></span> <span data-ttu-id="3f057-439">См. статью [Типы среды выполнения в отражении](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span><span class="sxs-lookup"><span data-stu-id="3f057-439">See [Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span></span>  
  
<span data-ttu-id="3f057-440">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-440">-or-</span></span> 
 <span data-ttu-id="3f057-441"><paramref name="method" /> не является методом экземпляра.</span><span class="sxs-lookup"><span data-stu-id="3f057-441"><paramref name="method" /> is not an instance method.</span></span>  
  
<span data-ttu-id="3f057-442">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-442">-or-</span></span> 
 <span data-ttu-id="3f057-443">Параметр <paramref name="method" /> невозможно привязать, например, потому, что его не удалось найти.</span><span class="sxs-lookup"><span data-stu-id="3f057-443"><paramref name="method" /> cannot be bound, for example because it cannot be found.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="3f057-444">Метод <see langword="Invoke" /> для <paramref name="type" /> не найден.</span><span class="sxs-lookup"><span data-stu-id="3f057-444">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="3f057-445">Вызывающий объект не имеет необходимых разрешений для доступа к <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-445">The caller does not have the permissions necessary to access <paramref name="method" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="3f057-446">При вызове поздней привязки с помощью таких механизмов, как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-446">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="3f057-447">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-447">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="3f057-448">Тип <see cref="T:System.Type" /> создаваемого делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-448">The <see cref="T:System.Type" /> of delegate to create.</span></span></param>
        <param name="method"><span data-ttu-id="3f057-449">Объект <see cref="T:System.Reflection.MethodInfo" />, описывающий статический метод или метод экземпляра, который будет представлен делегатом.</span><span class="sxs-lookup"><span data-stu-id="3f057-449">The <see cref="T:System.Reflection.MethodInfo" /> describing the static or instance method the delegate is to represent.</span></span></param>
        <param name="throwOnBindFailure"><span data-ttu-id="3f057-450">Значение <see langword="true" /> для создания исключения, если метод <paramref name="method" /> невозможно привязать; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-450"><see langword="true" /> to throw an exception if <paramref name="method" /> cannot be bound; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="3f057-451">Создает делегат указанного типа, представляющий заданный статический метод, с заданным поведением на случай, если операция связывания завершится неудачей.</span><span class="sxs-lookup"><span data-stu-id="3f057-451">Creates a delegate of the specified type to represent the specified static method, with the specified behavior on failure to bind.</span></span></summary>
        <returns><span data-ttu-id="3f057-452">Делегат указанного типа, представляющий заданный статический метод.</span><span class="sxs-lookup"><span data-stu-id="3f057-452">A delegate of the specified type to represent the specified static method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f057-453">Эта перегрузка метода может создавать делегаты открытых статических методов и делегаты методов открытого экземпляра, т. е. Делегаты, которые предоставляют скрытый первый аргумент методов экземпляра.</span><span class="sxs-lookup"><span data-stu-id="3f057-453">This method overload can create open static method delegates and open instance method delegates - that is, delegates that expose the hidden first argument of instance methods.</span></span> <span data-ttu-id="3f057-454">Подробное описание см. в более общем перегрузке метода <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29>, которая позволяет создавать все сочетания открытых или закрытых делегатов для экземпляров или статических методов.</span><span class="sxs-lookup"><span data-stu-id="3f057-454">For a detailed explanation, see the more general <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> method overload, which allows you to create all combinations of open or closed delegates for instance or static methods.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f057-455">Этот перегруженный метод следует использовать, когда делегат не закрыт по первому аргументу, так как в этом случае он выполняется несколько быстрее.</span><span class="sxs-lookup"><span data-stu-id="3f057-455">This method overload should be used when the delegate is not closed over its first argument, because it is somewhat faster in that case.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f057-456">Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]этот метод можно использовать для доступа к неоткрытым методам, если вызывающий объект был предоставлен <xref:System.Security.Permissions.ReflectionPermission> с флагом <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> и если набор прав неоткрытых методов ограничен набором предоставления вызывающего объекта или его подмножеством.</span><span class="sxs-lookup"><span data-stu-id="3f057-456">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="3f057-457">(См. раздел [вопросы безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="3f057-457">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="3f057-458">Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.</span><span class="sxs-lookup"><span data-stu-id="3f057-458">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
## <a name="compatible-parameter-types-and-return-type"></a><span data-ttu-id="3f057-459">Совместимые типы параметров и возвращаемый тип</span><span class="sxs-lookup"><span data-stu-id="3f057-459">Compatible Parameter Types and Return Type</span></span>  
 <span data-ttu-id="3f057-460">Типы параметров и возвращаемый тип делегата должны быть совместимы с типами параметров и типом возвращаемого значения метода, который представляет делегат. типы не обязательно должны точно совпадать.</span><span class="sxs-lookup"><span data-stu-id="3f057-460">The parameter types and return type of a delegate must be compatible with the parameter types and return type of the method the delegate represents; the types do not have to match exactly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f057-461">В .NET Framework версии 1,0 и 1,1 типы должны точно совпадать.</span><span class="sxs-lookup"><span data-stu-id="3f057-461">In the .NET Framework version 1.0 and 1.1, the types must match exactly.</span></span>  
  
 <span data-ttu-id="3f057-462">Если тип параметра делегата является более строгим, чем тип параметра метода, то параметр делегата совместим с соответствующим параметром метода, так как это гарантирует, что аргумент, переданный делегату, может быть безопасно передан методу.</span><span class="sxs-lookup"><span data-stu-id="3f057-462">A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</span></span>  
  
 <span data-ttu-id="3f057-463">Аналогичным образом, тип возвращаемого значения делегата совместим с типом возвращаемого значения метода, если тип возвращаемого значения метода является более строгим, чем тип возвращаемого значения делегата, так как это гарантирует, что возвращаемое значение метода может быть безопасно приведено к типу возвращаемого значения делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-463">Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</span></span>  
  
 <span data-ttu-id="3f057-464">Например, делегат с параметром типа <xref:System.Collections.Hashtable> и типом возвращаемого значения <xref:System.Object> может представлять метод с параметром типа <xref:System.Object> и возвращаемым значением типа <xref:System.Collections.Hashtable>.</span><span class="sxs-lookup"><span data-stu-id="3f057-464">For example, a delegate with a parameter of type <xref:System.Collections.Hashtable> and a return type of <xref:System.Object> can represent a method with a parameter of type <xref:System.Object> and a return value of type <xref:System.Collections.Hashtable>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f057-465">Этот раздел содержит два примера кода.</span><span class="sxs-lookup"><span data-stu-id="3f057-465">This section contains two code examples.</span></span> <span data-ttu-id="3f057-466">В первом примере показаны два вида делегатов, которые можно создать с помощью этой перегрузки метода: открыть через метод экземпляра и открыть в статическом методе.</span><span class="sxs-lookup"><span data-stu-id="3f057-466">The first example demonstrates the two kinds of delegates that can be created with this method overload: open over an instance method and open over a static method.</span></span>  
  
 <span data-ttu-id="3f057-467">Во втором примере кода демонстрируются совместимые типы параметров и возвращаемые типы.</span><span class="sxs-lookup"><span data-stu-id="3f057-467">The second code example demonstrates compatible parameter types and return types.</span></span>  
  
 <span data-ttu-id="3f057-468">**Пример 1**</span><span class="sxs-lookup"><span data-stu-id="3f057-468">**Example 1**</span></span>  
  
 <span data-ttu-id="3f057-469">В следующем примере кода показаны два способа создания делегата с помощью этой перегрузки метода <xref:System.Delegate.CreateDelegate%2A>.</span><span class="sxs-lookup"><span data-stu-id="3f057-469">The following code example demonstrates the two ways a delegate can be created using this overload of the <xref:System.Delegate.CreateDelegate%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f057-470">Существует две перегрузки метода <xref:System.Delegate.CreateDelegate%2A>, указывающие <xref:System.Reflection.MethodInfo>, но не первый аргумент. их функциональные возможности одинаковы, за исключением того, что позволяет указать, следует ли создавать привязку при ошибке, а вторая всегда создает исключение.</span><span class="sxs-lookup"><span data-stu-id="3f057-470">There are two overloads of the <xref:System.Delegate.CreateDelegate%2A> method that specify a <xref:System.Reflection.MethodInfo> but not a first argument; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</span></span> <span data-ttu-id="3f057-471">В этом примере кода используются обе перегрузки.</span><span class="sxs-lookup"><span data-stu-id="3f057-471">This code example uses both overloads.</span></span>  
  
 <span data-ttu-id="3f057-472">В примере объявляется класс `C` с статическим методом `M2` и методом экземпляра `M1`, а также два типа делегата: `D1` принимает экземпляр `C` и строку, а `D2` принимает строку.</span><span class="sxs-lookup"><span data-stu-id="3f057-472">The example declares a class `C` with a static method `M2` and an instance method `M1`, and two delegate types: `D1` takes an instance of `C` and a string, and `D2` takes a string.</span></span>  
  
 <span data-ttu-id="3f057-473">Второй класс с именем `Example` содержит код, создающий делегаты.</span><span class="sxs-lookup"><span data-stu-id="3f057-473">A second class named `Example` contains the code that creates the delegates.</span></span>  
  
-   <span data-ttu-id="3f057-474">Делегат типа `D1`, представляющий открытый метод экземпляра, создается для метода экземпляра `M1`.</span><span class="sxs-lookup"><span data-stu-id="3f057-474">A delegate of type `D1`, representing an open instance method, is created for the instance method `M1`.</span></span> <span data-ttu-id="3f057-475">Экземпляр должен передаваться при вызове делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-475">An instance must be passed when the delegate is invoked.</span></span>  
  
-   <span data-ttu-id="3f057-476">Делегат типа `D2`, представляющий открытый статический метод, создается для `M2`статического метода.</span><span class="sxs-lookup"><span data-stu-id="3f057-476">A delegate of type `D2`, representing an open static method, is created for the static method `M2`.</span></span>  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 <span data-ttu-id="3f057-477">**Пример 2**</span><span class="sxs-lookup"><span data-stu-id="3f057-477">**Example 2**</span></span>  
  
 <span data-ttu-id="3f057-478">В следующем примере кода демонстрируется совместимость типов параметров и возвращаемых типов.</span><span class="sxs-lookup"><span data-stu-id="3f057-478">The following code example demonstrates compatibility of parameter types and return types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f057-479">В этом примере кода используется перегрузка метода <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29>.</span><span class="sxs-lookup"><span data-stu-id="3f057-479">This code example uses the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> method overload.</span></span> <span data-ttu-id="3f057-480">Использование других перегрузок, принимающих <xref:System.Reflection.MethodInfo>, аналогично.</span><span class="sxs-lookup"><span data-stu-id="3f057-480">The use of other overloads that take <xref:System.Reflection.MethodInfo> is similar.</span></span>  
  
 <span data-ttu-id="3f057-481">В примере кода определяется базовый класс с именем `Base` и класс с именем `Derived`, производный от `Base`.</span><span class="sxs-lookup"><span data-stu-id="3f057-481">The code example defines a base class named `Base` and a class named `Derived` that derives from `Base`.</span></span> <span data-ttu-id="3f057-482">Производный класс имеет `static` метод (`Shared` в Visual Basic) с именем `MyMethod` с одним параметром типа `Base` и типом возвращаемого значения `Derived`.</span><span class="sxs-lookup"><span data-stu-id="3f057-482">The derived class has a `static` (`Shared` in Visual Basic) method named `MyMethod` with one parameter of type `Base` and a return type of `Derived`.</span></span> <span data-ttu-id="3f057-483">В примере кода также определяется делегат с именем `Example` с одним параметром типа `Derived` и типом возвращаемого значения `Base`.</span><span class="sxs-lookup"><span data-stu-id="3f057-483">The code example also defines a delegate named `Example` that has one parameter of type `Derived` and a return type of `Base`.</span></span>  
  
 <span data-ttu-id="3f057-484">В примере кода показано, что делегат с именем `Example` можно использовать для представления метода `MyMethod`.</span><span class="sxs-lookup"><span data-stu-id="3f057-484">The code example demonstrates that the delegate named `Example` can be used to represent the method `MyMethod`.</span></span> <span data-ttu-id="3f057-485">Метод можно привязать к делегату по следующим причинам:</span><span class="sxs-lookup"><span data-stu-id="3f057-485">The method can be bound to the delegate because:</span></span>  
  
-   <span data-ttu-id="3f057-486">Тип параметра делегата (`Derived`) имеет более строгое значение, чем тип параметра `MyMethod` (`Base`), чтобы всегда быть в безопасности передавать аргумент делегата в `MyMethod`.</span><span class="sxs-lookup"><span data-stu-id="3f057-486">The parameter type of the delegate (`Derived`) is more restrictive than the parameter type of `MyMethod` (`Base`), so that it is always safe to pass the argument of the delegate to `MyMethod`.</span></span>  
  
-   <span data-ttu-id="3f057-487">Тип возвращаемого значения `MyMethod` (`Derived`) является более строгой, чем тип параметра делегата (`Base`), чтобы всегда быть уверенным в том, чтобы привести возвращаемый тип метода к возвращаемому типу делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-487">The return type of `MyMethod` (`Derived`) is more restrictive than the parameter type of the delegate (`Base`), so that it is always safe to cast the return type of the method to the return type of the delegate.</span></span>  
  
 <span data-ttu-id="3f057-488">В примере кода выходные данные не создаются.</span><span class="sxs-lookup"><span data-stu-id="3f057-488">The code example produces no output.</span></span>  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3f057-489"><paramref name="type" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-489"><paramref name="type" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="3f057-490">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-490">-or-</span></span> 
 <span data-ttu-id="3f057-491"><paramref name="method" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-491"><paramref name="method" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3f057-492"><paramref name="type" /> не является производным от <see cref="T:System.MulticastDelegate" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-492"><paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span></span>  
  
<span data-ttu-id="3f057-493">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-493">-or-</span></span> 
 <span data-ttu-id="3f057-494"><paramref name="type" /> не является объектом типа <see langword="RuntimeType" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-494"><paramref name="type" /> is not a <see langword="RuntimeType" />.</span></span> <span data-ttu-id="3f057-495">См. статью [Типы среды выполнения в отражении](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span><span class="sxs-lookup"><span data-stu-id="3f057-495">See [Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span></span>  
  
<span data-ttu-id="3f057-496">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-496">-or-</span></span> 
 <span data-ttu-id="3f057-497"><paramref name="method" /> невозможно привязать, и <paramref name="throwOnBindFailure" /> имеет значение <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-497"><paramref name="method" /> cannot be bound, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.</span></span>  
  
<span data-ttu-id="3f057-498">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-498">-or-</span></span> 
 <span data-ttu-id="3f057-499"><paramref name="method" /> не является объектом типа <see langword="RuntimeMethodInfo" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-499"><paramref name="method" /> is not a <see langword="RuntimeMethodInfo" />.</span></span> <span data-ttu-id="3f057-500">См. статью [Типы среды выполнения в отражении](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span><span class="sxs-lookup"><span data-stu-id="3f057-500">See [Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="3f057-501">Метод <see langword="Invoke" /> для <paramref name="type" /> не найден.</span><span class="sxs-lookup"><span data-stu-id="3f057-501">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="3f057-502">Вызывающий объект не имеет необходимых разрешений для доступа к <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-502">The caller does not have the permissions necessary to access <paramref name="method" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="3f057-503">При вызове поздней привязки с помощью таких механизмов, как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-503">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="3f057-504">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-504">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="target" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="3f057-505">Тип <see cref="T:System.Type" /> создаваемого делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-505">The <see cref="T:System.Type" /> of delegate to create.</span></span></param>
        <param name="target"><span data-ttu-id="3f057-506">Тип <see cref="T:System.Type" />, представляющий класс, в котором реализован метод <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-506">The <see cref="T:System.Type" /> representing the class that implements <paramref name="method" />.</span></span></param>
        <param name="method"><span data-ttu-id="3f057-507">Имя статического метода, который должен быть представлен делегатом.</span><span class="sxs-lookup"><span data-stu-id="3f057-507">The name of the static method that the delegate is to represent.</span></span></param>
        <summary><span data-ttu-id="3f057-508">Создает делегат указанного типа, представляющий заданный статический метод заданного класса.</span><span class="sxs-lookup"><span data-stu-id="3f057-508">Creates a delegate of the specified type that represents the specified static method of the specified class.</span></span></summary>
        <returns><span data-ttu-id="3f057-509">Делегат указанного типа, представляющий заданный статический метод заданного класса.</span><span class="sxs-lookup"><span data-stu-id="3f057-509">A delegate of the specified type that represents the specified static method of the specified class.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f057-510">Этот метод создает делегаты только для статических методов.</span><span class="sxs-lookup"><span data-stu-id="3f057-510">This method creates delegates for static methods only.</span></span> <span data-ttu-id="3f057-511">Метод экземпляра — это метод, связанный с экземпляром класса; статический метод — это метод, который связан с самим классом.</span><span class="sxs-lookup"><span data-stu-id="3f057-511">An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</span></span>  
  
 <span data-ttu-id="3f057-512">Перегрузка этого метода эквивалентна вызову перегрузки метода <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29>, указывающей `false` для `ignoreCase` и `true` для `throwOnBindFailure`.</span><span class="sxs-lookup"><span data-stu-id="3f057-512">This method overload is equivalent to calling the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> method overload, specifying `false` for `ignoreCase` and `true` for `throwOnBindFailure`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f057-513">Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]этот метод можно использовать для доступа к неоткрытым методам, если вызывающий объект был предоставлен <xref:System.Security.Permissions.ReflectionPermission> с флагом <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> и если набор прав неоткрытых методов ограничен набором предоставления вызывающего объекта или его подмножеством.</span><span class="sxs-lookup"><span data-stu-id="3f057-513">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="3f057-514">(См. раздел [вопросы безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="3f057-514">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="3f057-515">Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.</span><span class="sxs-lookup"><span data-stu-id="3f057-515">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3f057-516"><paramref name="type" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-516"><paramref name="type" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="3f057-517">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-517">-or-</span></span> 
 <span data-ttu-id="3f057-518"><paramref name="target" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-518"><paramref name="target" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="3f057-519">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-519">-or-</span></span> 
 <span data-ttu-id="3f057-520"><paramref name="method" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-520"><paramref name="method" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3f057-521"><paramref name="type" /> не является производным от <see cref="T:System.MulticastDelegate" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-521"><paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span></span>  
  
<span data-ttu-id="3f057-522">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-522">-or-</span></span> 
 <span data-ttu-id="3f057-523"><paramref name="type" /> не является объектом типа <see langword="RuntimeType" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-523"><paramref name="type" /> is not a <see langword="RuntimeType" />.</span></span> <span data-ttu-id="3f057-524">См. статью [Типы среды выполнения в отражении](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span><span class="sxs-lookup"><span data-stu-id="3f057-524">See [Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span></span>  
  
<span data-ttu-id="3f057-525">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-525">-or-</span></span> 
 <span data-ttu-id="3f057-526"><paramref name="target" /> не является объектом <see langword="RuntimeType" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-526"><paramref name="target" /> is not a <see langword="RuntimeType" />.</span></span>  
  
<span data-ttu-id="3f057-527">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-527">-or-</span></span> 
 <span data-ttu-id="3f057-528"><paramref name="target" /> представляет собой открытый универсальный тип.</span><span class="sxs-lookup"><span data-stu-id="3f057-528"><paramref name="target" /> is an open generic type.</span></span> <span data-ttu-id="3f057-529">То есть свойство <see cref="P:System.Type.ContainsGenericParameters" /> имеет значение <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-529">That is, its <see cref="P:System.Type.ContainsGenericParameters" /> property is <see langword="true" />.</span></span>  
  
<span data-ttu-id="3f057-530">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-530">-or-</span></span> 
 <span data-ttu-id="3f057-531"><paramref name="method" /> не является методом <see langword="static" /> (метод <see langword="Shared" /> в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="3f057-531"><paramref name="method" /> is not a <see langword="static" /> method (<see langword="Shared" /> method in Visual Basic).</span></span>  
  
<span data-ttu-id="3f057-532">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-532">-or-</span></span> 
 <span data-ttu-id="3f057-533">Параметр <paramref name="method" /> невозможно привязать, например, потому, что его невозможно найти, а <paramref name="throwOnBindFailure" /> имеет значение <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-533"><paramref name="method" /> cannot be bound, for example because it cannot be found, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="3f057-534">Метод <see langword="Invoke" /> для <paramref name="type" /> не найден.</span><span class="sxs-lookup"><span data-stu-id="3f057-534">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="3f057-535">Вызывающий объект не имеет необходимых разрешений для доступа к <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-535">The caller does not have the permissions necessary to access <paramref name="method" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="3f057-536">При вызове поздней привязки с помощью таких механизмов, как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-536">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="3f057-537">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-537">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="firstArgument" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="3f057-538">Объект <see cref="T:System.Type" />, представляющий тип создаваемого делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-538">A <see cref="T:System.Type" /> representing the type of delegate to create.</span></span></param>
        <param name="firstArgument"><span data-ttu-id="3f057-539">Объект <see cref="T:System.Object" />, являющийся первым аргументом метода, представленного делегатом.</span><span class="sxs-lookup"><span data-stu-id="3f057-539">An <see cref="T:System.Object" /> that is the first argument of the method the delegate represents.</span></span> <span data-ttu-id="3f057-540">Для методов экземпляра он должен быть совместим с типом экземпляра.</span><span class="sxs-lookup"><span data-stu-id="3f057-540">For instance methods, it must be compatible with the instance type.</span></span></param>
        <param name="method"><span data-ttu-id="3f057-541">Объект <see cref="T:System.Reflection.MethodInfo" />, описывающий статический метод или метод экземпляра, который будет представлен делегатом.</span><span class="sxs-lookup"><span data-stu-id="3f057-541">The <see cref="T:System.Reflection.MethodInfo" /> describing the static or instance method the delegate is to represent.</span></span></param>
        <param name="throwOnBindFailure"><span data-ttu-id="3f057-542">Значение <see langword="true" /> для создания исключения, если метод <paramref name="method" /> невозможно привязать; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-542"><see langword="true" /> to throw an exception if <paramref name="method" /> cannot be bound; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="3f057-543">Создает делегат указанного типа, представляющий заданный статический метод или метод экземпляра, с заданным первым аргументом и поведением на случай, если операция связывания завершится неудачей.</span><span class="sxs-lookup"><span data-stu-id="3f057-543">Creates a delegate of the specified type that represents the specified static or instance method, with the specified first argument and the specified behavior on failure to bind.</span></span></summary>
        <returns><span data-ttu-id="3f057-544">Делегат заданного типа, представляющий указанный статический метод или метод экземпляра, либо значение <see langword="null" />, если значение <paramref name="throwOnBindFailure" /> равно <see langword="false" /> и делегат нельзя связать с методом <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-544">A delegate of the specified type that represents the specified static or instance method, or <see langword="null" /> if <paramref name="throwOnBindFailure" /> is <see langword="false" /> and the delegate cannot be bound to <paramref name="method" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f057-545">Этот перегруженный метод и перегрузка метода <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29>, которая всегда вызывает сбой при привязке, предоставляют наиболее гибкий способ создания делегатов.</span><span class="sxs-lookup"><span data-stu-id="3f057-545">This method overload and the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> method overload, which always throws on failure to bind, provide the most flexible way to create delegates.</span></span> <span data-ttu-id="3f057-546">Их можно использовать для создания делегатов для статических методов или и без первого аргумента.</span><span class="sxs-lookup"><span data-stu-id="3f057-546">You can use them to create delegates for either static or instance methods, with or without a first argument.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f057-547">Если не указать первый аргумент, используйте перегрузку метода <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> для повышения производительности.</span><span class="sxs-lookup"><span data-stu-id="3f057-547">If you do not supply a first argument, use the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> method overload for better performance.</span></span>  
  
 <span data-ttu-id="3f057-548">Тип делегата и метод должны иметь совместимые типы возвращаемых значения.</span><span class="sxs-lookup"><span data-stu-id="3f057-548">The delegate type and the method must have compatible return types.</span></span> <span data-ttu-id="3f057-549">То есть тип возвращаемого значения `method` должен быть назначен типу возвращаемого значения `type`.</span><span class="sxs-lookup"><span data-stu-id="3f057-549">That is, the return type of `method` must be assignable to the return type of `type`.</span></span>  
  
 <span data-ttu-id="3f057-550">Если указан параметр `firstArgument`, он передается `method` каждый раз при вызове делегата; считается, что `firstArgument` привязано к делегату, и делегат называется закрытым для своего первого аргумента.</span><span class="sxs-lookup"><span data-stu-id="3f057-550">If `firstArgument` is supplied, it is passed to `method` every time the delegate is invoked; `firstArgument` is said to be bound to the delegate, and the delegate is said to be closed over its first argument.</span></span> <span data-ttu-id="3f057-551">Если `method` `static` (`Shared` в Visual Basic), список аргументов, предоставленный при вызове делегата, включает все параметры, кроме первого; Если `method` является методом экземпляра, то `firstArgument` передается в параметр скрытого экземпляра (представленный `this` в C#или `Me` в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="3f057-551">If `method` is `static` (`Shared` in Visual Basic), the argument list supplied when invoking the delegate includes all parameters except the first; if `method` is an instance method, then `firstArgument` is passed to the hidden instance parameter (represented by `this` in C#, or by `Me` in Visual Basic).</span></span>  
  
 <span data-ttu-id="3f057-552">Если указан `firstArgument`, первый параметр `method` должен быть ссылочным типом, а `firstArgument` должен быть совместим с этим типом.</span><span class="sxs-lookup"><span data-stu-id="3f057-552">If `firstArgument` is supplied, the first parameter of `method` must be a reference type, and `firstArgument` must be compatible with that type.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="3f057-553">Если `method` `static` (`Shared` в Visual Basic), а первый параметр имеет тип <xref:System.Object> или <xref:System.ValueType>, то `firstArgument` может быть типом значения.</span><span class="sxs-lookup"><span data-stu-id="3f057-553">If `method` is `static` (`Shared` in Visual Basic) and its first parameter is of type <xref:System.Object> or <xref:System.ValueType>, then `firstArgument` can be a value type.</span></span> <span data-ttu-id="3f057-554">В этом случае `firstArgument` автоматически упаковывается.</span><span class="sxs-lookup"><span data-stu-id="3f057-554">In this case `firstArgument` is automatically boxed.</span></span> <span data-ttu-id="3f057-555">Автоматическая упаковка- C# преобразование не выполняется для других аргументов, как в вызове функции или Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="3f057-555">Automatic boxing does not occur for any other arguments, as it would in a C# or Visual Basic function call.</span></span>  
  
 <span data-ttu-id="3f057-556">Если `firstArgument` является пустой ссылкой и `method` является методом экземпляра, результат зависит от сигнатур типа делегата, `type` и от `method`:</span><span class="sxs-lookup"><span data-stu-id="3f057-556">If `firstArgument` is a null reference and `method` is an instance method, the result depends on the signatures of the delegate type `type` and of `method`:</span></span>  
  
-   <span data-ttu-id="3f057-557">Если сигнатура `type` явно включает скрытый первый параметр `method`, то говорят, что делегат представляет открытый метод экземпляра.</span><span class="sxs-lookup"><span data-stu-id="3f057-557">If the signature of `type` explicitly includes the hidden first parameter of `method`, the delegate is said to represent an open instance method.</span></span> <span data-ttu-id="3f057-558">При вызове делегата первый аргумент в списке аргументов передается в параметр скрытого экземпляра `method`.</span><span class="sxs-lookup"><span data-stu-id="3f057-558">When the delegate is invoked, the first argument in the argument list is passed to the hidden instance parameter of `method`.</span></span>  
  
-   <span data-ttu-id="3f057-559">Если сигнатуры `method` и `type` совпадают (т. е. все типы параметров совместимы), то делегат называется закрытым по пустой ссылке.</span><span class="sxs-lookup"><span data-stu-id="3f057-559">If the signatures of `method` and `type` match (that is, all parameter types are compatible), then the delegate is said to be closed over a null reference.</span></span> <span data-ttu-id="3f057-560">Вызов делегата аналогичен вызову метода экземпляра для экземпляра со значением NULL, что не особенно полезно для этого.</span><span class="sxs-lookup"><span data-stu-id="3f057-560">Invoking the delegate is like calling an instance method on a null instance, which is not a particularly useful thing to do.</span></span>  
  
 <span data-ttu-id="3f057-561">Если `firstArgument` является пустой ссылкой, а `method` является статическим, результат зависит от сигнатур типа делегата, `type` и от `method`:</span><span class="sxs-lookup"><span data-stu-id="3f057-561">If `firstArgument` is a null reference and `method` is static, the result depends on the signatures of the delegate type `type` and of `method`:</span></span>  
  
-   <span data-ttu-id="3f057-562">Если сигнатура `method` и `type` совпадают (то есть все типы параметров совместимы), делегат называется открытым статическим методом.</span><span class="sxs-lookup"><span data-stu-id="3f057-562">If the signature of `method` and `type` match (that is, all parameter types are compatible), the delegate is said to represent an open static method.</span></span> <span data-ttu-id="3f057-563">Это наиболее распространенный случай для статических методов.</span><span class="sxs-lookup"><span data-stu-id="3f057-563">This is the most common case for static methods.</span></span> <span data-ttu-id="3f057-564">В этом случае можно получить немного более высокую производительность с помощью перегрузки метода <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29>.</span><span class="sxs-lookup"><span data-stu-id="3f057-564">In this case, you can get slightly better performance by using the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> method overload.</span></span>  
  
-   <span data-ttu-id="3f057-565">Если сигнатура `type` начинается со второго параметра `method` и остальные типы параметров совместимы, то делегат называется закрытым с помощью пустой ссылки.</span><span class="sxs-lookup"><span data-stu-id="3f057-565">If the signature of `type` begins with the second parameter of `method` and the rest of the parameter types are compatible, then the delegate is said to be closed over a null reference.</span></span> <span data-ttu-id="3f057-566">При вызове делегата в первый параметр `method`передается пустая ссылка.</span><span class="sxs-lookup"><span data-stu-id="3f057-566">When the delegate is invoked, a null reference is passed to the first parameter of `method`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f057-567">Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]этот метод можно использовать для доступа к неоткрытым методам, если вызывающий объект был предоставлен <xref:System.Security.Permissions.ReflectionPermission> с флагом <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> и если набор прав неоткрытых методов ограничен набором предоставления вызывающего объекта или его подмножеством.</span><span class="sxs-lookup"><span data-stu-id="3f057-567">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="3f057-568">(См. раздел [вопросы безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="3f057-568">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="3f057-569">Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.</span><span class="sxs-lookup"><span data-stu-id="3f057-569">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
## <a name="compatible-parameter-types-and-return-type"></a><span data-ttu-id="3f057-570">Совместимые типы параметров и возвращаемый тип</span><span class="sxs-lookup"><span data-stu-id="3f057-570">Compatible Parameter Types and Return Type</span></span>  
 <span data-ttu-id="3f057-571">Типы параметров и возвращаемый тип делегата должны быть совместимы с типами параметров и типом возвращаемого значения метода, который представляет делегат. типы не обязательно должны точно совпадать.</span><span class="sxs-lookup"><span data-stu-id="3f057-571">The parameter types and return type of a delegate must be compatible with the parameter types and return type of the method the delegate represents; the types do not have to match exactly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f057-572">В .NET Framework версии 1,0 и 1,1 типы должны точно совпадать.</span><span class="sxs-lookup"><span data-stu-id="3f057-572">In the .NET Framework version 1.0 and 1.1 the types must match exactly.</span></span>  
  
 <span data-ttu-id="3f057-573">Если тип параметра делегата является более строгим, чем тип параметра метода, то параметр делегата совместим с соответствующим параметром метода, так как это гарантирует, что аргумент, переданный делегату, может быть безопасно передан методу.</span><span class="sxs-lookup"><span data-stu-id="3f057-573">A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</span></span>  
  
 <span data-ttu-id="3f057-574">Аналогичным образом, тип возвращаемого значения делегата совместим с типом возвращаемого значения метода, если тип возвращаемого значения метода является более строгим, чем тип возвращаемого значения делегата, так как это гарантирует, что возвращаемое значение метода может быть безопасно приведено к типу возвращаемого значения делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-574">Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</span></span>  
  
 <span data-ttu-id="3f057-575">Например, делегат с параметром типа <xref:System.Collections.Hashtable> и типом возвращаемого значения <xref:System.Object> может представлять метод с параметром типа <xref:System.Object> и возвращаемым значением типа <xref:System.Collections.Hashtable>.</span><span class="sxs-lookup"><span data-stu-id="3f057-575">For example, a delegate with a parameter of type <xref:System.Collections.Hashtable> and a return type of <xref:System.Object> can represent a method with a parameter of type <xref:System.Object> and a return value of type <xref:System.Collections.Hashtable>.</span></span>  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a><span data-ttu-id="3f057-576">Определение методов, которые может представлять делегат</span><span class="sxs-lookup"><span data-stu-id="3f057-576">Determining the Methods a Delegate Can Represent</span></span>  
 <span data-ttu-id="3f057-577">Еще один полезный способ представить гибкость, обеспечиваемую этой перегрузкой <xref:System.Delegate.CreateDelegate%2A> заключается в том, что любой заданный делегат может представлять четыре различных сочетания сигнатуры и типа метода (статический и экземпляр).</span><span class="sxs-lookup"><span data-stu-id="3f057-577">Another useful way to think of the flexibility provided by this overload of <xref:System.Delegate.CreateDelegate%2A> is that any given delegate can represent four different combinations of method signature and method kind (static versus instance).</span></span> <span data-ttu-id="3f057-578">Рассмотрим тип делегата `D` с одним аргументом типа `C`.</span><span class="sxs-lookup"><span data-stu-id="3f057-578">Consider a delegate type `D` with one argument of type `C`.</span></span> <span data-ttu-id="3f057-579">Ниже описаны методы, которые `D` могут представлять, игнорируя возвращаемый тип, так как он должен совпадать во всех случаях:</span><span class="sxs-lookup"><span data-stu-id="3f057-579">The following describes the methods `D` can represent, ignoring the return type since it must match in all cases:</span></span>  
  
-   <span data-ttu-id="3f057-580">`D` может представлять любой метод экземпляра, имеющий ровно один аргумент типа `C`, независимо от типа, которому принадлежит метод экземпляра.</span><span class="sxs-lookup"><span data-stu-id="3f057-580">`D` can represent any instance method that has exactly one argument of type `C`, regardless of what type the instance method belongs to.</span></span> <span data-ttu-id="3f057-581">При вызове <xref:System.Delegate.CreateDelegate%2A> `firstArgument` является экземпляром типа, к которому принадлежит `method`, а получившийся делегат называется закрытым для этого экземпляра.</span><span class="sxs-lookup"><span data-stu-id="3f057-581">When <xref:System.Delegate.CreateDelegate%2A> is called, `firstArgument` is an instance of the type `method` belongs to, and the resulting delegate is said to be closed over that instance.</span></span> <span data-ttu-id="3f057-582">(Тривиально, `D` также можно закрыть по пустой ссылке, если `firstArgument` `null`.)</span><span class="sxs-lookup"><span data-stu-id="3f057-582">(Trivially, `D` can also be closed over a null reference if `firstArgument` is `null`.)</span></span>  
  
-   <span data-ttu-id="3f057-583">`D` может представлять метод экземпляра `C`, не имеющий аргументов.</span><span class="sxs-lookup"><span data-stu-id="3f057-583">`D` can represent an instance method of `C` that has no arguments.</span></span> <span data-ttu-id="3f057-584">При вызове <xref:System.Delegate.CreateDelegate%2A> `firstArgument` является пустой ссылкой.</span><span class="sxs-lookup"><span data-stu-id="3f057-584">When <xref:System.Delegate.CreateDelegate%2A> is called, `firstArgument` is a null reference.</span></span> <span data-ttu-id="3f057-585">Результирующий делегат представляет открытый метод экземпляра, а экземпляр `C` должен предоставляться каждый раз при вызове метода.</span><span class="sxs-lookup"><span data-stu-id="3f057-585">The resulting delegate represents an open instance method, and an instance of `C` must be supplied each time it is invoked.</span></span>  
  
-   <span data-ttu-id="3f057-586">`D` может представлять статический метод, который принимает один аргумент типа `C`, и этот метод может принадлежать любому типу.</span><span class="sxs-lookup"><span data-stu-id="3f057-586">`D` can represent a static method that takes one argument of type `C`, and that method can belong to any type.</span></span> <span data-ttu-id="3f057-587">При вызове <xref:System.Delegate.CreateDelegate%2A> `firstArgument` является пустой ссылкой.</span><span class="sxs-lookup"><span data-stu-id="3f057-587">When <xref:System.Delegate.CreateDelegate%2A> is called, `firstArgument` is a null reference.</span></span> <span data-ttu-id="3f057-588">Результирующий делегат представляет открытый статический метод, а экземпляр `C` должен предоставляться каждый раз при вызове метода.</span><span class="sxs-lookup"><span data-stu-id="3f057-588">The resulting delegate represents an open static method, and an instance of `C` must be supplied each time it is invoked.</span></span>  
  
-   <span data-ttu-id="3f057-589">`D` может представлять статический метод, который принадлежит к типу `F` и имеет два аргумента типа `F` и типа `C`.</span><span class="sxs-lookup"><span data-stu-id="3f057-589">`D` can represent a static method that belongs to type `F` and has two arguments, of type `F` and type `C`.</span></span> <span data-ttu-id="3f057-590">При вызове <xref:System.Delegate.CreateDelegate%2A> `firstArgument` является экземпляром `F`.</span><span class="sxs-lookup"><span data-stu-id="3f057-590">When <xref:System.Delegate.CreateDelegate%2A> is called, `firstArgument` is an instance of `F`.</span></span> <span data-ttu-id="3f057-591">Результирующий делегат представляет статический метод, закрытый для этого экземпляра `F`.</span><span class="sxs-lookup"><span data-stu-id="3f057-591">The resulting delegate represents a static method that is closed over that instance of `F`.</span></span> <span data-ttu-id="3f057-592">Обратите внимание, что в случае, когда `F` и `C` имеют один и тот же тип, статический метод имеет два аргумента этого типа.</span><span class="sxs-lookup"><span data-stu-id="3f057-592">Note that in the case where `F` and `C` are the same type, the static method has two arguments of that type.</span></span> <span data-ttu-id="3f057-593">(В данном случае `D` закрывается по пустой ссылке, если `firstArgument` `null`.)</span><span class="sxs-lookup"><span data-stu-id="3f057-593">(In this case, `D` is closed over a null reference if `firstArgument` is `null`.)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f057-594">Этот раздел содержит три примера кода.</span><span class="sxs-lookup"><span data-stu-id="3f057-594">This section contains three code examples.</span></span> <span data-ttu-id="3f057-595">В первом примере показаны четыре типа делегатов, которые могут быть созданы: закрыто над методом экземпляра, открыто через метод экземпляра, открыто через статический метод и закрыто по статическому методу.</span><span class="sxs-lookup"><span data-stu-id="3f057-595">The first example demonstrates the four kinds of delegates that can be created: closed over an instance method, open over an instance method, open over a static method, and closed over a static method.</span></span>  
  
 <span data-ttu-id="3f057-596">Во втором примере кода демонстрируются совместимые типы параметров и возвращаемые типы.</span><span class="sxs-lookup"><span data-stu-id="3f057-596">The second code example demonstrates compatible parameter types and return types.</span></span>  
  
 <span data-ttu-id="3f057-597">В третьем примере кода определяется один тип делегата и отображаются все методы, которые могут представляться типом делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-597">The third code example defines a single delegate type, and shows all the methods that delegate type can represent.</span></span>  
  
 <span data-ttu-id="3f057-598">**Пример 1**</span><span class="sxs-lookup"><span data-stu-id="3f057-598">**Example 1**</span></span>  
  
 <span data-ttu-id="3f057-599">В следующем примере кода показаны четыре способа создания делегата с помощью этой перегрузки метода <xref:System.Delegate.CreateDelegate%2A>.</span><span class="sxs-lookup"><span data-stu-id="3f057-599">The following code example demonstrates the four ways a delegate can be created using this overload of the <xref:System.Delegate.CreateDelegate%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f057-600">Существует две перегрузки метода <xref:System.Delegate.CreateDelegate%2A>, указывающие `firstArgument` и <xref:System.Reflection.MethodInfo>. их функциональные возможности одинаковы, за исключением того, что позволяет указать, следует ли создавать привязку при ошибке, а вторая всегда создает исключение.</span><span class="sxs-lookup"><span data-stu-id="3f057-600">There are two overloads of the <xref:System.Delegate.CreateDelegate%2A> method that specify `firstArgument` and a <xref:System.Reflection.MethodInfo>; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</span></span> <span data-ttu-id="3f057-601">В этом примере кода используются обе перегрузки.</span><span class="sxs-lookup"><span data-stu-id="3f057-601">This code example uses both overloads.</span></span>  
  
 <span data-ttu-id="3f057-602">В примере объявляется класс `C` с статическим методом `M2` и методом экземпляра `M1`, а также три типа делегата: `D1` принимает экземпляр `C` и строку, `D2` принимает строку, а `D3` не имеет аргументов.</span><span class="sxs-lookup"><span data-stu-id="3f057-602">The example declares a class `C` with a static method `M2` and an instance method `M1`, and three delegate types: `D1` takes an instance of `C` and a string, `D2` takes a string, and `D3` has no arguments.</span></span>  
  
 <span data-ttu-id="3f057-603">Второй класс с именем `Example` содержит код, создающий делегаты.</span><span class="sxs-lookup"><span data-stu-id="3f057-603">A second class named `Example` contains the code that creates the delegates.</span></span>  
  
-   <span data-ttu-id="3f057-604">Делегат типа `D2`, закрытый для экземпляра `C`, создается для метода экземпляра `M1`.</span><span class="sxs-lookup"><span data-stu-id="3f057-604">A delegate of type `D2`, closed over an instance of `C`, is created for the instance method `M1`.</span></span> <span data-ttu-id="3f057-605">Он вызывается с разными строками, чтобы продемонстрировать, что привязанный экземпляр `C` всегда используется.</span><span class="sxs-lookup"><span data-stu-id="3f057-605">It is invoked with different strings, to show that the bound instance of `C` is always used.</span></span>  
  
-   <span data-ttu-id="3f057-606">Делегат типа `D1`, представляющий открытый метод экземпляра, создается для метода экземпляра `M1`.</span><span class="sxs-lookup"><span data-stu-id="3f057-606">A delegate of type `D1`, representing an open instance method, is created for the instance method `M1`.</span></span> <span data-ttu-id="3f057-607">Экземпляр должен передаваться при вызове делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-607">An instance must be passed when the delegate is invoked.</span></span>  
  
-   <span data-ttu-id="3f057-608">Делегат типа `D2`, представляющий открытый статический метод, создается для `M2`статического метода.</span><span class="sxs-lookup"><span data-stu-id="3f057-608">A delegate of type `D2`, representing an open static method, is created for the static method `M2`.</span></span>  
  
-   <span data-ttu-id="3f057-609">Наконец, делегат типа `D3`, закрытый над строкой, создается для статического метода `M2`.</span><span class="sxs-lookup"><span data-stu-id="3f057-609">Finally, a delegate of type `D3`, closed over a string, is created for the static method `M2`.</span></span> <span data-ttu-id="3f057-610">Метод вызывается, чтобы продемонстрировать, что он использует привязанную строку.</span><span class="sxs-lookup"><span data-stu-id="3f057-610">The method is invoked to show that it uses the bound string.</span></span>  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 <span data-ttu-id="3f057-611">**Пример 2**</span><span class="sxs-lookup"><span data-stu-id="3f057-611">**Example 2**</span></span>  
  
 <span data-ttu-id="3f057-612">В следующем примере кода демонстрируется совместимость типов параметров и возвращаемых типов.</span><span class="sxs-lookup"><span data-stu-id="3f057-612">The following code example demonstrates compatibility of parameter types and return types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f057-613">В этом примере кода используется перегрузка метода <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29>.</span><span class="sxs-lookup"><span data-stu-id="3f057-613">This code example uses the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> method overload.</span></span> <span data-ttu-id="3f057-614">Использование других перегрузок, принимающих <xref:System.Reflection.MethodInfo>, аналогично.</span><span class="sxs-lookup"><span data-stu-id="3f057-614">The use of other overloads that take <xref:System.Reflection.MethodInfo> is similar.</span></span>  
  
 <span data-ttu-id="3f057-615">В примере кода определяется базовый класс с именем `Base` и класс с именем `Derived`, производный от `Base`.</span><span class="sxs-lookup"><span data-stu-id="3f057-615">The code example defines a base class named `Base` and a class named `Derived` that derives from `Base`.</span></span> <span data-ttu-id="3f057-616">Производный класс имеет `static` метод (`Shared` в Visual Basic) с именем `MyMethod` с одним параметром типа `Base` и типом возвращаемого значения `Derived`.</span><span class="sxs-lookup"><span data-stu-id="3f057-616">The derived class has a `static` (`Shared` in Visual Basic) method named `MyMethod` with one parameter of type `Base` and a return type of `Derived`.</span></span> <span data-ttu-id="3f057-617">В примере кода также определяется делегат с именем `Example` с одним параметром типа `Derived` и типом возвращаемого значения `Base`.</span><span class="sxs-lookup"><span data-stu-id="3f057-617">The code example also defines a delegate named `Example` that has one parameter of type `Derived` and a return type of `Base`.</span></span>  
  
 <span data-ttu-id="3f057-618">В примере кода показано, что делегат с именем `Example` можно использовать для представления метода `MyMethod`.</span><span class="sxs-lookup"><span data-stu-id="3f057-618">The code example demonstrates that the delegate named `Example` can be used to represent the method `MyMethod`.</span></span> <span data-ttu-id="3f057-619">Метод можно привязать к делегату по следующим причинам:</span><span class="sxs-lookup"><span data-stu-id="3f057-619">The method can be bound to the delegate because:</span></span>  
  
-   <span data-ttu-id="3f057-620">Тип параметра делегата (`Derived`) имеет более строгое значение, чем тип параметра `MyMethod` (`Base`), чтобы всегда быть в безопасности передавать аргумент делегата в `MyMethod`.</span><span class="sxs-lookup"><span data-stu-id="3f057-620">The parameter type of the delegate (`Derived`) is more restrictive than the parameter type of `MyMethod` (`Base`), so that it is always safe to pass the argument of the delegate to `MyMethod`.</span></span>  
  
-   <span data-ttu-id="3f057-621">Тип возвращаемого значения `MyMethod` (`Derived`) является более строгой, чем тип параметра делегата (`Base`), чтобы всегда быть уверенным в том, чтобы привести возвращаемый тип метода к возвращаемому типу делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-621">The return type of `MyMethod` (`Derived`) is more restrictive than the parameter type of the delegate (`Base`), so that it is always safe to cast the return type of the method to the return type of the delegate.</span></span>  
  
 <span data-ttu-id="3f057-622">В примере кода выходные данные не создаются.</span><span class="sxs-lookup"><span data-stu-id="3f057-622">The code example produces no output.</span></span>  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 <span data-ttu-id="3f057-623">**Пример 3**</span><span class="sxs-lookup"><span data-stu-id="3f057-623">**Example 3**</span></span>  
  
 <span data-ttu-id="3f057-624">В следующем примере кода показаны все методы, которые может представлять один тип делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-624">The following code example shows all the methods a single delegate type can represent.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f057-625">Существует две перегрузки метода <xref:System.Delegate.CreateDelegate%2A>, указывающие `firstArgument` и <xref:System.Reflection.MethodInfo>. их функциональные возможности одинаковы, за исключением того, что позволяет указать, следует ли создавать привязку при ошибке, а вторая всегда создает исключение.</span><span class="sxs-lookup"><span data-stu-id="3f057-625">There are two overloads of the <xref:System.Delegate.CreateDelegate%2A> method that specify `firstArgument` and a <xref:System.Reflection.MethodInfo>; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</span></span> <span data-ttu-id="3f057-626">В этом примере кода используются обе перегрузки.</span><span class="sxs-lookup"><span data-stu-id="3f057-626">This code example uses both overloads.</span></span>  
  
 <span data-ttu-id="3f057-627">В примере кода определяются два класса: `C` и `F`, а также тип делегата `D` с одним аргументом типа `C`.</span><span class="sxs-lookup"><span data-stu-id="3f057-627">The code example defines two classes, `C` and `F`, and a delegate type `D` with one argument of type `C`.</span></span> <span data-ttu-id="3f057-628">Классы имеют совпадающие статические и методы экземпляра `M1`, `M3`и `M4`, а класс `C` также имеет метод экземпляра `M2`, не имеющий аргументов.</span><span class="sxs-lookup"><span data-stu-id="3f057-628">The classes have matching static and instance methods `M1`, `M3`, and `M4`, and class `C` also has an instance method `M2` that has no arguments.</span></span>  
  
 <span data-ttu-id="3f057-629">Третий класс с именем `Example` содержит код, создающий делегаты.</span><span class="sxs-lookup"><span data-stu-id="3f057-629">A third class named `Example` contains the code that creates the delegates.</span></span>  
  
-   <span data-ttu-id="3f057-630">Делегаты создаются для метода экземпляра `M1` типа `C` и типа `F`; Каждый из них закрыт для экземпляра соответствующего типа.</span><span class="sxs-lookup"><span data-stu-id="3f057-630">Delegates are created for instance method `M1` of type `C` and type `F`; each is closed over an instance of the respective type.</span></span> <span data-ttu-id="3f057-631">Метод `M1` типа `C` отображает свойства `ID` привязанного экземпляра и аргумента.</span><span class="sxs-lookup"><span data-stu-id="3f057-631">Method `M1` of type `C` displays the `ID` properties of the bound instance and of the argument.</span></span>  
  
-   <span data-ttu-id="3f057-632">Делегат создается для метода `M2` типа `C`.</span><span class="sxs-lookup"><span data-stu-id="3f057-632">A delegate is created for method `M2` of type `C`.</span></span> <span data-ttu-id="3f057-633">Это делегат открытого экземпляра, в котором аргумент делегата представляет собой скрытый первый аргумент в методе экземпляра.</span><span class="sxs-lookup"><span data-stu-id="3f057-633">This is an open instance delegate, in which the argument of the delegate represents the hidden first argument on the instance method.</span></span> <span data-ttu-id="3f057-634">Метод не имеет других аргументов.</span><span class="sxs-lookup"><span data-stu-id="3f057-634">The method has no other arguments.</span></span>  
  
-   <span data-ttu-id="3f057-635">Делегаты создаются для статического метода `M3` типа `C` и типа `F`; Это открытые статические делегаты.</span><span class="sxs-lookup"><span data-stu-id="3f057-635">Delegates are created for static method `M3` of type `C` and type `F`; these are open static delegates.</span></span>  
  
-   <span data-ttu-id="3f057-636">Наконец, создаются делегаты для статического метода `M4` типа `C` и типа `F`; Каждый метод имеет объявляющий тип в качестве первого аргумента, и предоставляется экземпляр типа, поэтому делегаты закрываются в своих первых аргументах.</span><span class="sxs-lookup"><span data-stu-id="3f057-636">Finally, delegates are created for static method `M4` of type `C` and type `F`; each method has the declaring type as its first argument, and an instance of the type is supplied, so the delegates are closed over their first arguments.</span></span> <span data-ttu-id="3f057-637">Метод `M4` типа `C` отображает свойства `ID` привязанного экземпляра и аргумента.</span><span class="sxs-lookup"><span data-stu-id="3f057-637">Method `M4` of type `C` displays the `ID` properties of the bound instance and of the argument.</span></span>  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3f057-638"><paramref name="type" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-638"><paramref name="type" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="3f057-639">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-639">-or-</span></span> 
 <span data-ttu-id="3f057-640"><paramref name="method" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-640"><paramref name="method" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3f057-641"><paramref name="type" /> не является производным от <see cref="T:System.MulticastDelegate" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-641"><paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span></span>  
  
<span data-ttu-id="3f057-642">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-642">-or-</span></span> 
 <span data-ttu-id="3f057-643"><paramref name="type" /> не является объектом типа <see langword="RuntimeType" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-643"><paramref name="type" /> is not a <see langword="RuntimeType" />.</span></span> <span data-ttu-id="3f057-644">См. статью [Типы среды выполнения в отражении](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span><span class="sxs-lookup"><span data-stu-id="3f057-644">See [Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span></span>  
  
<span data-ttu-id="3f057-645">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-645">-or-</span></span> 
 <span data-ttu-id="3f057-646"><paramref name="method" /> невозможно привязать, и <paramref name="throwOnBindFailure" /> имеет значение <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-646"><paramref name="method" /> cannot be bound, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.</span></span>  
  
<span data-ttu-id="3f057-647">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-647">-or-</span></span> 
 <span data-ttu-id="3f057-648"><paramref name="method" /> не является объектом типа <see langword="RuntimeMethodInfo" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-648"><paramref name="method" /> is not a <see langword="RuntimeMethodInfo" />.</span></span> <span data-ttu-id="3f057-649">См. статью [Типы среды выполнения в отражении](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span><span class="sxs-lookup"><span data-stu-id="3f057-649">See [Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="3f057-650">Метод <see langword="Invoke" /> для <paramref name="type" /> не найден.</span><span class="sxs-lookup"><span data-stu-id="3f057-650">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="3f057-651">Вызывающий объект не имеет необходимых разрешений для доступа к <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-651">The caller does not have the permissions necessary to access <paramref name="method" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="3f057-652">При вызове поздней привязки с помощью таких механизмов, как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-652">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="3f057-653">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-653">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="target" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="3f057-654">Тип <see cref="T:System.Type" /> создаваемого делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-654">The <see cref="T:System.Type" /> of delegate to create.</span></span></param>
        <param name="target"><span data-ttu-id="3f057-655">Экземпляр класса, для которого вызывается метод <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-655">The class instance on which <paramref name="method" /> is invoked.</span></span></param>
        <param name="method"><span data-ttu-id="3f057-656">Имя метода экземпляра, который должен быть представлен делегатом.</span><span class="sxs-lookup"><span data-stu-id="3f057-656">The name of the instance method that the delegate is to represent.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="3f057-657">Логическое значение, указывающее, следует ли учитывать регистр при сравнении имени метода.</span><span class="sxs-lookup"><span data-stu-id="3f057-657">A Boolean indicating whether to ignore the case when comparing the name of the method.</span></span></param>
        <summary><span data-ttu-id="3f057-658">Создает делегат указанного типа, представляющий заданный метод экземпляра, который вызывается из заданного экземпляра класса с заданной установкой учета регистра.</span><span class="sxs-lookup"><span data-stu-id="3f057-658">Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance with the specified case-sensitivity.</span></span></summary>
        <returns><span data-ttu-id="3f057-659">Создает делегат указанного типа, представляющий заданный метод экземпляра, который вызывается для заданного экземпляра класса.</span><span class="sxs-lookup"><span data-stu-id="3f057-659">A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f057-660">Этот метод создает делегаты только для методов экземпляра.</span><span class="sxs-lookup"><span data-stu-id="3f057-660">This method creates delegates for instance methods only.</span></span> <span data-ttu-id="3f057-661">Метод экземпляра — это метод, связанный с экземпляром класса; статический метод — это метод, который связан с самим классом.</span><span class="sxs-lookup"><span data-stu-id="3f057-661">An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</span></span>  
  
 <span data-ttu-id="3f057-662">Перегрузка этого метода эквивалентна вызову перегрузки метода <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29>, указывающей `true` для `throwOnBindFailure`.</span><span class="sxs-lookup"><span data-stu-id="3f057-662">This method overload is equivalent to calling the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> method overload, specifying `true` for `throwOnBindFailure`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f057-663">Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]этот метод можно использовать для доступа к неоткрытым методам, если вызывающий объект был предоставлен <xref:System.Security.Permissions.ReflectionPermission> с флагом <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> и если набор прав неоткрытых методов ограничен набором предоставления вызывающего объекта или его подмножеством.</span><span class="sxs-lookup"><span data-stu-id="3f057-663">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="3f057-664">(См. раздел [вопросы безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="3f057-664">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="3f057-665">Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.</span><span class="sxs-lookup"><span data-stu-id="3f057-665">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3f057-666"><paramref name="type" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-666"><paramref name="type" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="3f057-667">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-667">-or-</span></span> 
 <span data-ttu-id="3f057-668"><paramref name="target" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-668"><paramref name="target" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="3f057-669">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-669">-or-</span></span> 
 <span data-ttu-id="3f057-670"><paramref name="method" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-670"><paramref name="method" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3f057-671"><paramref name="type" /> не является производным от <see cref="T:System.MulticastDelegate" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-671"><paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span></span>  
  
<span data-ttu-id="3f057-672">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-672">-or-</span></span> 
 <span data-ttu-id="3f057-673"><paramref name="type" /> не является объектом типа <see langword="RuntimeType" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-673"><paramref name="type" /> is not a <see langword="RuntimeType" />.</span></span> <span data-ttu-id="3f057-674">См. статью [Типы среды выполнения в отражении](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span><span class="sxs-lookup"><span data-stu-id="3f057-674">See [Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span></span>  
  
<span data-ttu-id="3f057-675">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-675">-or-</span></span> 
 <span data-ttu-id="3f057-676"><paramref name="method" /> не является методом экземпляра.</span><span class="sxs-lookup"><span data-stu-id="3f057-676"><paramref name="method" /> is not an instance method.</span></span>  
  
<span data-ttu-id="3f057-677">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-677">-or-</span></span> 
 <span data-ttu-id="3f057-678">Параметр <paramref name="method" /> невозможно привязать, например, потому, что его не удалось найти.</span><span class="sxs-lookup"><span data-stu-id="3f057-678"><paramref name="method" /> cannot be bound, for example because it cannot be found.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="3f057-679">Метод <see langword="Invoke" /> для <paramref name="type" /> не найден.</span><span class="sxs-lookup"><span data-stu-id="3f057-679">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="3f057-680">Вызывающий объект не имеет необходимых разрешений для доступа к <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-680">The caller does not have the permissions necessary to access <paramref name="method" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="3f057-681">При вызове поздней привязки с помощью таких механизмов, как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-681">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="3f057-682">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-682">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="target" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="3f057-683">Тип <see cref="T:System.Type" /> создаваемого делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-683">The <see cref="T:System.Type" /> of delegate to create.</span></span></param>
        <param name="target"><span data-ttu-id="3f057-684">Тип <see cref="T:System.Type" />, представляющий класс, в котором реализован метод <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-684">The <see cref="T:System.Type" /> representing the class that implements <paramref name="method" />.</span></span></param>
        <param name="method"><span data-ttu-id="3f057-685">Имя статического метода, который должен быть представлен делегатом.</span><span class="sxs-lookup"><span data-stu-id="3f057-685">The name of the static method that the delegate is to represent.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="3f057-686">Логическое значение, указывающее, следует ли учитывать регистр при сравнении имени метода.</span><span class="sxs-lookup"><span data-stu-id="3f057-686">A Boolean indicating whether to ignore the case when comparing the name of the method.</span></span></param>
        <summary><span data-ttu-id="3f057-687">Создает делегат указанного типа, представляющий заданный статический метод заданного класса с заданной установкой учета регистра.</span><span class="sxs-lookup"><span data-stu-id="3f057-687">Creates a delegate of the specified type that represents the specified static method of the specified class, with the specified case-sensitivity.</span></span></summary>
        <returns><span data-ttu-id="3f057-688">Делегат указанного типа, представляющий заданный статический метод заданного класса.</span><span class="sxs-lookup"><span data-stu-id="3f057-688">A delegate of the specified type that represents the specified static method of the specified class.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f057-689">Этот метод создает делегаты только для статических методов.</span><span class="sxs-lookup"><span data-stu-id="3f057-689">This method creates delegates for static methods only.</span></span> <span data-ttu-id="3f057-690">Метод экземпляра — это метод, связанный с экземпляром класса; статический метод — это метод, который связан с самим классом.</span><span class="sxs-lookup"><span data-stu-id="3f057-690">An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</span></span>  
  
 <span data-ttu-id="3f057-691">Перегрузка этого метода эквивалентна вызову перегрузки метода <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29>, указывающей `true` для `throwOnBindFailure`.</span><span class="sxs-lookup"><span data-stu-id="3f057-691">This method overload is equivalent to calling the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> method overload, specifying `true` for `throwOnBindFailure`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f057-692">Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]этот метод можно использовать для доступа к неоткрытым методам, если вызывающий объект был предоставлен <xref:System.Security.Permissions.ReflectionPermission> с флагом <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> и если набор прав неоткрытых методов ограничен набором предоставления вызывающего объекта или его подмножеством.</span><span class="sxs-lookup"><span data-stu-id="3f057-692">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="3f057-693">(См. раздел [вопросы безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="3f057-693">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="3f057-694">Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.</span><span class="sxs-lookup"><span data-stu-id="3f057-694">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3f057-695"><paramref name="type" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-695"><paramref name="type" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="3f057-696">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-696">-or-</span></span> 
 <span data-ttu-id="3f057-697"><paramref name="target" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-697"><paramref name="target" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="3f057-698">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-698">-or-</span></span> 
 <span data-ttu-id="3f057-699"><paramref name="method" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-699"><paramref name="method" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3f057-700"><paramref name="type" /> не является производным от <see cref="T:System.MulticastDelegate" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-700"><paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span></span>  
  
<span data-ttu-id="3f057-701">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-701">-or-</span></span> 
 <span data-ttu-id="3f057-702"><paramref name="type" /> не является объектом типа <see langword="RuntimeType" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-702"><paramref name="type" /> is not a <see langword="RuntimeType" />.</span></span> <span data-ttu-id="3f057-703">См. статью [Типы среды выполнения в отражении](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span><span class="sxs-lookup"><span data-stu-id="3f057-703">See [Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span></span>  
  
<span data-ttu-id="3f057-704">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-704">-or-</span></span> 
 <span data-ttu-id="3f057-705"><paramref name="target" /> не является объектом <see langword="RuntimeType" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-705"><paramref name="target" /> is not a <see langword="RuntimeType" />.</span></span>  
  
<span data-ttu-id="3f057-706">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-706">-or-</span></span> 
 <span data-ttu-id="3f057-707"><paramref name="target" /> представляет собой открытый универсальный тип.</span><span class="sxs-lookup"><span data-stu-id="3f057-707"><paramref name="target" /> is an open generic type.</span></span> <span data-ttu-id="3f057-708">То есть свойство <see cref="P:System.Type.ContainsGenericParameters" /> имеет значение <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-708">That is, its <see cref="P:System.Type.ContainsGenericParameters" /> property is <see langword="true" />.</span></span>  
  
<span data-ttu-id="3f057-709">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-709">-or-</span></span> 
 <span data-ttu-id="3f057-710"><paramref name="method" /> не является методом <see langword="static" /> (метод <see langword="Shared" /> в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="3f057-710"><paramref name="method" /> is not a <see langword="static" /> method (<see langword="Shared" /> method in Visual Basic).</span></span>  
  
<span data-ttu-id="3f057-711">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-711">-or-</span></span> 
 <span data-ttu-id="3f057-712">Параметр <paramref name="method" /> невозможно привязать, например, потому, что его не удалось найти.</span><span class="sxs-lookup"><span data-stu-id="3f057-712"><paramref name="method" /> cannot be bound, for example because it cannot be found.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="3f057-713">Метод <see langword="Invoke" /> для <paramref name="type" /> не найден.</span><span class="sxs-lookup"><span data-stu-id="3f057-713">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="3f057-714">Вызывающий объект не имеет необходимых разрешений для доступа к <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-714">The caller does not have the permissions necessary to access <paramref name="method" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="3f057-715">При вызове поздней привязки с помощью таких механизмов, как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-715">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="3f057-716">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-716">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="target" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="3f057-717">Тип <see cref="T:System.Type" /> создаваемого делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-717">The <see cref="T:System.Type" /> of delegate to create.</span></span></param>
        <param name="target"><span data-ttu-id="3f057-718">Экземпляр класса, для которого вызывается метод <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-718">The class instance on which <paramref name="method" /> is invoked.</span></span></param>
        <param name="method"><span data-ttu-id="3f057-719">Имя метода экземпляра, который должен быть представлен делегатом.</span><span class="sxs-lookup"><span data-stu-id="3f057-719">The name of the instance method that the delegate is to represent.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="3f057-720">Логическое значение, указывающее, следует ли учитывать регистр при сравнении имени метода.</span><span class="sxs-lookup"><span data-stu-id="3f057-720">A Boolean indicating whether to ignore the case when comparing the name of the method.</span></span></param>
        <param name="throwOnBindFailure"><span data-ttu-id="3f057-721">Значение <see langword="true" /> для создания исключения, если метод <paramref name="method" /> невозможно привязать; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-721"><see langword="true" /> to throw an exception if <paramref name="method" /> cannot be bound; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="3f057-722">Создает делегат указанного типа, представляющий заданный статический метод, вызываемый для заданного экземпляра класса с заданной установкой учета регистра и заданным поведением на случай, если операция связывания завершится неудачей.</span><span class="sxs-lookup"><span data-stu-id="3f057-722">Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance, with the specified case-sensitivity and the specified behavior on failure to bind.</span></span></summary>
        <returns><span data-ttu-id="3f057-723">Создает делегат указанного типа, представляющий заданный метод экземпляра, который вызывается для заданного экземпляра класса.</span><span class="sxs-lookup"><span data-stu-id="3f057-723">A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f057-724">Этот метод создает делегаты только для методов экземпляра.</span><span class="sxs-lookup"><span data-stu-id="3f057-724">This method creates delegates for instance methods only.</span></span> <span data-ttu-id="3f057-725">Метод экземпляра — это метод, связанный с экземпляром класса; статический метод — это метод, который связан с самим классом.</span><span class="sxs-lookup"><span data-stu-id="3f057-725">An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f057-726">Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]этот метод можно использовать для доступа к неоткрытым методам, если вызывающий объект был предоставлен <xref:System.Security.Permissions.ReflectionPermission> с флагом <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> и если набор прав неоткрытых методов ограничен набором предоставления вызывающего объекта или его подмножеством.</span><span class="sxs-lookup"><span data-stu-id="3f057-726">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="3f057-727">(См. раздел [вопросы безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="3f057-727">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="3f057-728">Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.</span><span class="sxs-lookup"><span data-stu-id="3f057-728">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3f057-729"><paramref name="type" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-729"><paramref name="type" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="3f057-730">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-730">-or-</span></span> 
 <span data-ttu-id="3f057-731"><paramref name="target" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-731"><paramref name="target" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="3f057-732">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-732">-or-</span></span> 
 <span data-ttu-id="3f057-733"><paramref name="method" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-733"><paramref name="method" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3f057-734"><paramref name="type" /> не является производным от <see cref="T:System.MulticastDelegate" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-734"><paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span></span>  
  
<span data-ttu-id="3f057-735">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-735">-or-</span></span> 
 <span data-ttu-id="3f057-736"><paramref name="type" /> не является объектом типа <see langword="RuntimeType" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-736"><paramref name="type" /> is not a <see langword="RuntimeType" />.</span></span> <span data-ttu-id="3f057-737">См. статью [Типы среды выполнения в отражении](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span><span class="sxs-lookup"><span data-stu-id="3f057-737">See [Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span></span>  
  
<span data-ttu-id="3f057-738">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-738">-or-</span></span> 
 <span data-ttu-id="3f057-739"><paramref name="method" /> не является методом экземпляра.</span><span class="sxs-lookup"><span data-stu-id="3f057-739"><paramref name="method" /> is not an instance method.</span></span>  
  
<span data-ttu-id="3f057-740">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-740">-or-</span></span> 
 <span data-ttu-id="3f057-741">Параметр <paramref name="method" /> невозможно привязать, например, потому, что его невозможно найти, а <paramref name="throwOnBindFailure" /> имеет значение <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-741"><paramref name="method" /> cannot be bound, for example because it cannot be found, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="3f057-742">Метод <see langword="Invoke" /> для <paramref name="type" /> не найден.</span><span class="sxs-lookup"><span data-stu-id="3f057-742">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="3f057-743">Вызывающий объект не имеет необходимых разрешений для доступа к <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-743">The caller does not have the permissions necessary to access <paramref name="method" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="3f057-744">При вызове поздней привязки с помощью таких механизмов, как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-744">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="3f057-745">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-745">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="target" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="3f057-746">Тип <see cref="T:System.Type" /> создаваемого делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-746">The <see cref="T:System.Type" /> of delegate to create.</span></span></param>
        <param name="target"><span data-ttu-id="3f057-747">Тип <see cref="T:System.Type" />, представляющий класс, в котором реализован метод <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-747">The <see cref="T:System.Type" /> representing the class that implements <paramref name="method" />.</span></span></param>
        <param name="method"><span data-ttu-id="3f057-748">Имя статического метода, который должен быть представлен делегатом.</span><span class="sxs-lookup"><span data-stu-id="3f057-748">The name of the static method that the delegate is to represent.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="3f057-749">Логическое значение, указывающее, следует ли учитывать регистр при сравнении имени метода.</span><span class="sxs-lookup"><span data-stu-id="3f057-749">A Boolean indicating whether to ignore the case when comparing the name of the method.</span></span></param>
        <param name="throwOnBindFailure"><span data-ttu-id="3f057-750">Значение <see langword="true" /> для создания исключения, если метод <paramref name="method" /> невозможно привязать; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-750"><see langword="true" /> to throw an exception if <paramref name="method" /> cannot be bound; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="3f057-751">Создает делегат заданного типа, представляющий заданный статический метод заданного класса с заданными установками учета регистра и поведением на случай, если операция связывания завершится неудачей.</span><span class="sxs-lookup"><span data-stu-id="3f057-751">Creates a delegate of the specified type that represents the specified static method of the specified class, with the specified case-sensitivity and the specified behavior on failure to bind.</span></span></summary>
        <returns><span data-ttu-id="3f057-752">Делегат указанного типа, представляющий заданный статический метод заданного класса.</span><span class="sxs-lookup"><span data-stu-id="3f057-752">A delegate of the specified type that represents the specified static method of the specified class.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f057-753">Этот метод создает делегаты только для статических методов.</span><span class="sxs-lookup"><span data-stu-id="3f057-753">This method creates delegates for static methods only.</span></span> <span data-ttu-id="3f057-754">Метод экземпляра — это метод, связанный с экземпляром класса; статический метод — это метод, который связан с самим классом.</span><span class="sxs-lookup"><span data-stu-id="3f057-754">An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f057-755">Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]этот метод можно использовать для доступа к неоткрытым методам, если вызывающий объект был предоставлен <xref:System.Security.Permissions.ReflectionPermission> с флагом <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> и если набор прав неоткрытых методов ограничен набором предоставления вызывающего объекта или его подмножеством.</span><span class="sxs-lookup"><span data-stu-id="3f057-755">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="3f057-756">(См. раздел [вопросы безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="3f057-756">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="3f057-757">Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.</span><span class="sxs-lookup"><span data-stu-id="3f057-757">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3f057-758"><paramref name="type" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-758"><paramref name="type" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="3f057-759">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-759">-or-</span></span> 
 <span data-ttu-id="3f057-760"><paramref name="target" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-760"><paramref name="target" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="3f057-761">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-761">-or-</span></span> 
 <span data-ttu-id="3f057-762"><paramref name="method" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-762"><paramref name="method" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3f057-763"><paramref name="type" /> не является производным от <see cref="T:System.MulticastDelegate" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-763"><paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span></span>  
  
<span data-ttu-id="3f057-764">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-764">-or-</span></span> 
 <span data-ttu-id="3f057-765"><paramref name="type" /> не является объектом типа <see langword="RuntimeType" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-765"><paramref name="type" /> is not a <see langword="RuntimeType" />.</span></span> <span data-ttu-id="3f057-766">См. статью [Типы среды выполнения в отражении](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span><span class="sxs-lookup"><span data-stu-id="3f057-766">See [Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span></span>  
  
<span data-ttu-id="3f057-767">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-767">-or-</span></span> 
 <span data-ttu-id="3f057-768"><paramref name="target" /> не является объектом <see langword="RuntimeType" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-768"><paramref name="target" /> is not a <see langword="RuntimeType" />.</span></span>  
  
<span data-ttu-id="3f057-769">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-769">-or-</span></span> 
 <span data-ttu-id="3f057-770"><paramref name="target" /> представляет собой открытый универсальный тип.</span><span class="sxs-lookup"><span data-stu-id="3f057-770"><paramref name="target" /> is an open generic type.</span></span> <span data-ttu-id="3f057-771">То есть свойство <see cref="P:System.Type.ContainsGenericParameters" /> имеет значение <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-771">That is, its <see cref="P:System.Type.ContainsGenericParameters" /> property is <see langword="true" />.</span></span>  
  
<span data-ttu-id="3f057-772">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-772">-or-</span></span> 
 <span data-ttu-id="3f057-773"><paramref name="method" /> не является методом <see langword="static" /> (метод <see langword="Shared" /> в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="3f057-773"><paramref name="method" /> is not a <see langword="static" /> method (<see langword="Shared" /> method in Visual Basic).</span></span>  
  
<span data-ttu-id="3f057-774">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-774">-or-</span></span> 
 <span data-ttu-id="3f057-775">Параметр <paramref name="method" /> невозможно привязать, например, потому, что его невозможно найти, а <paramref name="throwOnBindFailure" /> имеет значение <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-775"><paramref name="method" /> cannot be bound, for example because it cannot be found, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="3f057-776">Метод <see langword="Invoke" /> для <paramref name="type" /> не найден.</span><span class="sxs-lookup"><span data-stu-id="3f057-776">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="3f057-777">Вызывающий объект не имеет необходимых разрешений для доступа к <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-777">The caller does not have the permissions necessary to access <paramref name="method" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="3f057-778">При вызове поздней привязки с помощью таких механизмов, как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-778">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="3f057-779">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-779">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvoke">
      <MemberSignature Language="C#" Value="public object DynamicInvoke (params object[] args);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object DynamicInvoke(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvoke(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DynamicInvoke (ParamArray args As Object()) As Object" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ DynamicInvoke(... cli::array &lt;System::Object ^&gt; ^ args);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.DynamicInvoke : obj[] -&gt; obj" Usage="delegate.DynamicInvoke args" />
      <MemberSignature Language="C#" Value="public object DynamicInvoke (object[] args);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Function DynamicInvoke (args As Object()) As Object" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ DynamicInvoke(cli::array &lt;System::Object ^&gt; ^ args);" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args"><span data-ttu-id="3f057-780">Массив объектов, которые передаются в качестве аргументов методу, представленному текущим делегатом.</span><span class="sxs-lookup"><span data-stu-id="3f057-780">An array of objects that are the arguments to pass to the method represented by the current delegate.</span></span>  
  
<span data-ttu-id="3f057-781">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-781">-or-</span></span> 
 <span data-ttu-id="3f057-782">Значение <see langword="null" />, если метод, представленный текущим делегатом, не требует аргументов.</span><span class="sxs-lookup"><span data-stu-id="3f057-782"><see langword="null" />, if the method represented by the current delegate does not require arguments.</span></span></param>
        <summary><span data-ttu-id="3f057-783">Динамически (с поздней привязкой) вызывает метод, представленный текущим делегатом.</span><span class="sxs-lookup"><span data-stu-id="3f057-783">Dynamically invokes (late-bound) the method represented by the current delegate.</span></span></summary>
        <returns><span data-ttu-id="3f057-784">Объект, возвращаемый методом, представленным делегатом.</span><span class="sxs-lookup"><span data-stu-id="3f057-784">The object returned by the method represented by the delegate.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f057-785">Этот метод вызывает метод <xref:System.Delegate.DynamicInvokeImpl%2A>.</span><span class="sxs-lookup"><span data-stu-id="3f057-785">This method calls the <xref:System.Delegate.DynamicInvokeImpl%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="3f057-786">Вызывающий объект не имеет доступа к методу, представленному делегатом (например, если метод является закрытым).</span><span class="sxs-lookup"><span data-stu-id="3f057-786">The caller does not have access to the method represented by the delegate (for example, if the method is private).</span></span>  
  
<span data-ttu-id="3f057-787">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-787">-or-</span></span> 
<span data-ttu-id="3f057-788">Количество, порядок или тип параметров в списке <paramref name="args" /> является недопустимым.</span><span class="sxs-lookup"><span data-stu-id="3f057-788">The number, order, or type of parameters listed in <paramref name="args" /> is invalid.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3f057-789">Представленный делегатом метод вызывается для объекта или класса, которые его не поддерживают.</span><span class="sxs-lookup"><span data-stu-id="3f057-789">The method represented by the delegate is invoked on an object or a class that does not support it.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="3f057-790">Представленный делегатом метод является методом экземпляра, а целевой объект имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-790">The method represented by the delegate is an instance method and the target object is <see langword="null" />.</span></span>  
  
<span data-ttu-id="3f057-791">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-791">-or-</span></span> 
<span data-ttu-id="3f057-792">Один из инкапсулированных методов выбрасывает исключение.</span><span class="sxs-lookup"><span data-stu-id="3f057-792">One of the encapsulated methods throws an exception.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="3f057-793">При вызове поздней привязки с помощью таких механизмов, как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-793">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="3f057-794">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="3f057-794">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvokeImpl">
      <MemberSignature Language="C#" Value="protected virtual object DynamicInvokeImpl (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object DynamicInvokeImpl(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function DynamicInvokeImpl (args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ DynamicInvokeImpl(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member DynamicInvokeImpl : obj[] -&gt; obj&#xA;override this.DynamicInvokeImpl : obj[] -&gt; obj" Usage="delegate.DynamicInvokeImpl args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="args"><span data-ttu-id="3f057-795">Массив объектов, которые передаются в качестве аргументов методу, представленному текущим делегатом.</span><span class="sxs-lookup"><span data-stu-id="3f057-795">An array of objects that are the arguments to pass to the method represented by the current delegate.</span></span>  
  
<span data-ttu-id="3f057-796">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-796">-or-</span></span> 
 <span data-ttu-id="3f057-797">Значение <see langword="null" />, если метод, представленный текущим делегатом, не требует аргументов.</span><span class="sxs-lookup"><span data-stu-id="3f057-797"><see langword="null" />, if the method represented by the current delegate does not require arguments.</span></span></param>
        <summary><span data-ttu-id="3f057-798">Динамически (с поздней привязкой) вызывает метод, представленный текущим делегатом.</span><span class="sxs-lookup"><span data-stu-id="3f057-798">Dynamically invokes (late-bound) the method represented by the current delegate.</span></span></summary>
        <returns><span data-ttu-id="3f057-799">Объект, возвращаемый методом, представленным делегатом.</span><span class="sxs-lookup"><span data-stu-id="3f057-799">The object returned by the method represented by the delegate.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f057-800">Этот метод реализует метод <xref:System.Delegate.DynamicInvoke%2A> .</span><span class="sxs-lookup"><span data-stu-id="3f057-800">This method implements the <xref:System.Delegate.DynamicInvoke%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="3f057-801">Вызывающий объект не имеет доступа к методу, представленному делегатом (например, если метод является закрытым).</span><span class="sxs-lookup"><span data-stu-id="3f057-801">The caller does not have access to the method represented by the delegate (for example, if the method is private).</span></span>  
  
<span data-ttu-id="3f057-802">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-802">-or-</span></span> 
<span data-ttu-id="3f057-803">Количество, порядок или тип параметров в списке <paramref name="args" /> является недопустимым.</span><span class="sxs-lookup"><span data-stu-id="3f057-803">The number, order, or type of parameters listed in <paramref name="args" /> is invalid.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3f057-804">Представленный делегатом метод вызывается для объекта или класса, которые его не поддерживают.</span><span class="sxs-lookup"><span data-stu-id="3f057-804">The method represented by the delegate is invoked on an object or a class that does not support it.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="3f057-805">Представленный делегатом метод является методом экземпляра, а целевой объект имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-805">The method represented by the delegate is an instance method and the target object is <see langword="null" />.</span></span>  
  
<span data-ttu-id="3f057-806">-или-</span><span class="sxs-lookup"><span data-stu-id="3f057-806">-or-</span></span> 
<span data-ttu-id="3f057-807">Один из инкапсулированных методов выбрасывает исключение.</span><span class="sxs-lookup"><span data-stu-id="3f057-807">One of the encapsulated methods throws an exception.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="3f057-808">При вызове поздней привязки с помощью таких механизмов, как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-808">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="3f057-809">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="3f057-809">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Delegate.DynamicInvoke(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="delegate.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="3f057-810">Объект, который требуется сравнить с текущим делегатом.</span><span class="sxs-lookup"><span data-stu-id="3f057-810">The object to compare with the current delegate.</span></span></param>
        <summary><span data-ttu-id="3f057-811">Определяет, принадлежат ли заданный объект и текущий делегат к одному типу, и одинаковы ли их целевые объекты, методы и списки вызовов.</span><span class="sxs-lookup"><span data-stu-id="3f057-811">Determines whether the specified object and the current delegate are of the same type and share the same targets, methods, and invocation list.</span></span></summary>
        <returns><span data-ttu-id="3f057-812">Значение <see langword="true" />, если <paramref name="obj" /> и текущий делегат имеют одинаковые целевые объекты, методы и списки вызовов. В противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-812"><see langword="true" /> if <paramref name="obj" /> and the current delegate have the same targets, methods, and invocation list; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f057-813">Если два делегата имеют разные типы, они не считаются равными.</span><span class="sxs-lookup"><span data-stu-id="3f057-813">If the two delegates are not of the same type, they are not considered equal.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="3f057-814">В .NET Framework версии 1,0 и 1,1 два делегата считаются равными, если их цели, методы и список вызовов равны, даже если делегаты имеют разные типы.</span><span class="sxs-lookup"><span data-stu-id="3f057-814">In the .NET Framework version 1.0 and 1.1, two delegates were considered equal if their targets, methods, and invocation list were equal, even if the delegates were of different types.</span></span>  
  
 <span data-ttu-id="3f057-815">Методы и целевые объекты сравниваются на равенство следующим образом:</span><span class="sxs-lookup"><span data-stu-id="3f057-815">The methods and targets are compared for equality as follows:</span></span>  
  
-   <span data-ttu-id="3f057-816">Если два сравниваемых метода являются статическими и одинаковы для одного и того же класса, то методы считаются равными, а целевые объекты также считаются равными.</span><span class="sxs-lookup"><span data-stu-id="3f057-816">If the two methods being compared are both static and are the same method on the same class, the methods are considered equal and the targets are also considered equal.</span></span>  
  
-   <span data-ttu-id="3f057-817">Если два сравниваемых метода являются методами экземпляра и одинаковы для одного и того же объекта, то методы считаются равными, а целевые объекты также считаются равными.</span><span class="sxs-lookup"><span data-stu-id="3f057-817">If the two methods being compared are instance methods and are the same method on the same object, the methods are considered equal and the targets are also considered equal.</span></span>  
  
-   <span data-ttu-id="3f057-818">В противном случае методы не считаются равными, а целевые объекты также не считаются равными.</span><span class="sxs-lookup"><span data-stu-id="3f057-818">Otherwise, the methods are not considered to be equal and the targets are also not considered to be equal.</span></span>  
  
 <span data-ttu-id="3f057-819">Два списка вызовов считаются идентичными только в том случае, если они имеют одинаковый порядок, а соответствующие элементы из двух списков представляют один и тот же метод и целевой объект.</span><span class="sxs-lookup"><span data-stu-id="3f057-819">Two invocation lists are considered identical only if they have the same order and the corresponding elements from the two lists represent the same method and target.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="3f057-820">Вызывающий объект не имеет доступа к методу, представленному делегатом (например, если метод является закрытым).</span><span class="sxs-lookup"><span data-stu-id="3f057-820">The caller does not have access to the method represented by the delegate (for example, if the method is private).</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="3f057-821">При вызове поздней привязки с помощью таких механизмов, как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-821">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="3f057-822">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="3f057-822">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="delegate.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3f057-823">Возвращает хэш-код делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-823">Returns a hash code for the delegate.</span></span></summary>
        <returns><span data-ttu-id="3f057-824">Хэш-код делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-824">A hash code for the delegate.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f057-825">Возвращаемое значение этого метода не должно сохраняться по двум причинам.</span><span class="sxs-lookup"><span data-stu-id="3f057-825">The return value of this method must not be persisted for two reasons.</span></span> <span data-ttu-id="3f057-826">Во-первых, функция хэширования класса может быть изменена для более эффективного распределения, что позволяет выдавать любые значения из старой хэш-функции.</span><span class="sxs-lookup"><span data-stu-id="3f057-826">First, the hash function of a class might be altered to generate a better distribution, rendering any values from the old hash function useless.</span></span> <span data-ttu-id="3f057-827">Во-вторых, реализация по умолчанию этого класса не гарантирует, что одно и то же значение будет возвращаться разными экземплярами.</span><span class="sxs-lookup"><span data-stu-id="3f057-827">Second, the default implementation of this class does not guarantee that the same value will be returned by different instances.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="3f057-828">При вызове поздней привязки с помощью таких механизмов, как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-828">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="3f057-829">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="3f057-829">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetInvocationList">
      <MemberSignature Language="C#" Value="public virtual Delegate[] GetInvocationList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Delegate[] GetInvocationList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetInvocationList" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInvocationList () As Delegate()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Delegate ^&gt; ^ GetInvocationList();" />
      <MemberSignature Language="F#" Value="abstract member GetInvocationList : unit -&gt; Delegate[]&#xA;override this.GetInvocationList : unit -&gt; Delegate[]" Usage="delegate.GetInvocationList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3f057-830">Возвращает список вызовов делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-830">Returns the invocation list of the delegate.</span></span></summary>
        <returns><span data-ttu-id="3f057-831">Массив делегатов, представляющих список вызовов текущего делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-831">An array of delegates representing the invocation list of the current delegate.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f057-832">Каждый делегат в массиве представляет ровно один метод.</span><span class="sxs-lookup"><span data-stu-id="3f057-832">Each delegate in the array represents exactly one method.</span></span>  
  
 <span data-ttu-id="3f057-833">Порядок делегатов в массиве совпадает с порядком, в котором текущий делегат вызывает методы, которые представляют эти делегаты.</span><span class="sxs-lookup"><span data-stu-id="3f057-833">The order of the delegates in the array is the same order in which the current delegate invokes the methods that those delegates represent.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f057-834">В следующем примере для делегата назначается три метода.</span><span class="sxs-lookup"><span data-stu-id="3f057-834">The following example assigns three methods to a delegate.</span></span> <span data-ttu-id="3f057-835">Затем он вызывает метод <xref:System.Delegate.GetInvocationList%2A> для получения общего числа методов, назначенных делегату, для выполнения делегатов в обратном порядке и для выполнения методов, имя которых не включает в себя подстроку "File".</span><span class="sxs-lookup"><span data-stu-id="3f057-835">It then calls the  <xref:System.Delegate.GetInvocationList%2A> method to get a total count of the methods assigned to the delegate, to execute the delegates in reverse order, and to execute the methods whose name do not include the substring "File".</span></span>  
  
 [!code-csharp[System.Delegate.GetInvocationList#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/cs/GetInvocationList1.cs#1)]
 [!code-vb[System.Delegate.GetInvocationList#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/vb/GetInvocationList1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="3f057-836">При вызове поздней привязки с помощью таких механизмов, как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-836">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="3f057-837">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="3f057-837">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetMethodImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetMethodImpl () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : unit -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : unit -&gt; System.Reflection.MethodInfo" Usage="delegate.GetMethodImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3f057-838">Возвращает статический метод, представленный текущим делегатом.</span><span class="sxs-lookup"><span data-stu-id="3f057-838">Gets the static method represented by the current delegate.</span></span></summary>
        <returns><span data-ttu-id="3f057-839"><see cref="T:System.Reflection.MethodInfo" />, описывающий статический метод, представленный текущим делегатом.</span><span class="sxs-lookup"><span data-stu-id="3f057-839">A <see cref="T:System.Reflection.MethodInfo" /> describing the static method represented by the current delegate.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f057-840">Этот метод применяется только в том случае, если текущий делегат представляет статический метод.</span><span class="sxs-lookup"><span data-stu-id="3f057-840">This method applies only if the current delegate represents a static method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="3f057-841">Вызывающий объект не имеет доступа к методу, представленному делегатом (например, если метод является закрытым).</span><span class="sxs-lookup"><span data-stu-id="3f057-841">The caller does not have access to the method represented by the delegate (for example, if the method is private).</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="3f057-842">При вызове поздней привязки с помощью таких механизмов, как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-842">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="3f057-843">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="3f057-843">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Delegate.Method" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="delegate.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="info"><span data-ttu-id="3f057-844">Не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="3f057-844">Not supported.</span></span></param>
        <param name="context"><span data-ttu-id="3f057-845">Не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="3f057-845">Not supported.</span></span></param>
        <summary><span data-ttu-id="3f057-846">Не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="3f057-846">Not supported.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="3f057-847">Этот метод не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="3f057-847">This method is not supported.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="3f057-848">требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="3f057-848">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="3f057-849">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="3f057-849">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo Method { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo Method" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Method" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Method As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodInfo ^ Method { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Method : System.Reflection.MethodInfo" Usage="System.Delegate.Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3f057-850">Возвращает метод, представленный делегатом.</span><span class="sxs-lookup"><span data-stu-id="3f057-850">Gets the method represented by the delegate.</span></span></summary>
        <value><span data-ttu-id="3f057-851">Объект <see cref="T:System.Reflection.MethodInfo" />, описывающий метод, представленный делегатом.</span><span class="sxs-lookup"><span data-stu-id="3f057-851">A <see cref="T:System.Reflection.MethodInfo" /> describing the method represented by the delegate.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="3f057-852">Вызывающий объект не имеет доступа к методу, представленному делегатом (например, если метод является закрытым).</span><span class="sxs-lookup"><span data-stu-id="3f057-852">The caller does not have access to the method represented by the delegate (for example, if the method is private).</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="3f057-853">При вызове поздней привязки с помощью таких механизмов, как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-853">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="3f057-854">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="3f057-854">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Delegate.GetMethodImpl" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Delegate * Delegate -&gt; bool" Usage="d1 = d2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1"><span data-ttu-id="3f057-855">Первый делегат для операции сравнения.</span><span class="sxs-lookup"><span data-stu-id="3f057-855">The first delegate to compare.</span></span></param>
        <param name="d2"><span data-ttu-id="3f057-856">Второй делегат для операции сравнения.</span><span class="sxs-lookup"><span data-stu-id="3f057-856">The second delegate to compare.</span></span></param>
        <summary><span data-ttu-id="3f057-857">Определяет, равны ли два заданных делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-857">Determines whether the specified delegates are equal.</span></span></summary>
        <returns><span data-ttu-id="3f057-858"><see langword="true" />, если значения параметров <paramref name="d1" /> и <paramref name="d2" /> равны; в противном случае — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-858"><see langword="true" /> if <paramref name="d1" /> is equal to <paramref name="d2" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f057-859">Два делегата одного типа с одинаковыми целевыми объектами, методами и списками вызовов считаются равными.</span><span class="sxs-lookup"><span data-stu-id="3f057-859">Two delegates of the same type with the same targets, methods, and invocation lists are considered equal.</span></span>  
  
 <span data-ttu-id="3f057-860">Если два делегата имеют разные типы, они не считаются равными.</span><span class="sxs-lookup"><span data-stu-id="3f057-860">If the two delegates are not of the same type, they are not considered equal.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="3f057-861">В .NET Framework версии 1,0 и 1,1 два делегата считаются равными, если их цели, методы и список вызовов равны, даже если делегаты имеют разные типы.</span><span class="sxs-lookup"><span data-stu-id="3f057-861">In the .NET Framework version 1.0 and 1.1, two delegates were considered equal if their targets, methods, and invocation list were equal, even if the delegates were of different types.</span></span>  
  
 <span data-ttu-id="3f057-862">Методы и целевые объекты сравниваются на равенство следующим образом:</span><span class="sxs-lookup"><span data-stu-id="3f057-862">The methods and targets are compared for equality as follows:</span></span>  
  
-   <span data-ttu-id="3f057-863">Если два сравниваемых метода являются статическими и одинаковы для одного и того же класса, то методы считаются равными, а целевые объекты также считаются равными.</span><span class="sxs-lookup"><span data-stu-id="3f057-863">If the two methods being compared are both static and are the same method on the same class, the methods are considered equal and the targets are also considered equal.</span></span>  
  
-   <span data-ttu-id="3f057-864">Если два сравниваемых метода являются методами экземпляра и одинаковы для одного и того же объекта, то методы считаются равными, а целевые объекты также считаются равными.</span><span class="sxs-lookup"><span data-stu-id="3f057-864">If the two methods being compared are instance methods and are the same method on the same object, the methods are considered equal and the targets are also considered equal.</span></span>  
  
-   <span data-ttu-id="3f057-865">В противном случае методы не считаются равными, а целевые объекты также не считаются равными.</span><span class="sxs-lookup"><span data-stu-id="3f057-865">Otherwise, the methods are not considered to be equal and the targets are also not considered to be equal.</span></span>  
  
 <span data-ttu-id="3f057-866">Два списка вызовов считаются идентичными, если они имеют одинаковый порядок, а соответствующие элементы из двух списков представляют один и тот же метод и целевой объект.</span><span class="sxs-lookup"><span data-stu-id="3f057-866">Two invocation lists are considered identical if they have the same order and the corresponding elements from the two lists represent the same method and target.</span></span>  
  
 <span data-ttu-id="3f057-867">Эквивалентным методом для этого оператора является <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="3f057-867">The equivalent method for this operator is <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="3f057-868">При вызове поздней привязки с помощью таких механизмов, как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-868">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="3f057-869">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="3f057-869">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Delegate * Delegate -&gt; bool" Usage="System.Delegate.op_Inequality (d1, d2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1"><span data-ttu-id="3f057-870">Первый делегат для операции сравнения.</span><span class="sxs-lookup"><span data-stu-id="3f057-870">The first delegate to compare.</span></span></param>
        <param name="d2"><span data-ttu-id="3f057-871">Второй делегат для операции сравнения.</span><span class="sxs-lookup"><span data-stu-id="3f057-871">The second delegate to compare.</span></span></param>
        <summary><span data-ttu-id="3f057-872">Определяет, являются ли заданные делегаты неравными.</span><span class="sxs-lookup"><span data-stu-id="3f057-872">Determines whether the specified delegates are not equal.</span></span></summary>
        <returns><span data-ttu-id="3f057-873"><see langword="true" />, если значения <paramref name="d1" /> и <paramref name="d2" /> не равны; в противном случае — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-873"><see langword="true" /> if <paramref name="d1" /> is not equal to <paramref name="d2" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f057-874">Два делегата считаются неравными, если они относятся к разным типам или имеют разные методы, разные целевые объекты или разные списки вызовов.</span><span class="sxs-lookup"><span data-stu-id="3f057-874">Two delegates are considered not equal if they are of different types, or have different methods, different targets, or different invocation lists.</span></span>  
  
 <span data-ttu-id="3f057-875">Если два делегата имеют разные типы, они не считаются равными.</span><span class="sxs-lookup"><span data-stu-id="3f057-875">If the two delegates are not of the same type, they are not considered equal.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="3f057-876">В .NET Framework версии 1,0 и 1,1 два делегата считаются равными, если их цели, методы и список вызовов равны, даже если делегаты относятся к разным типам.</span><span class="sxs-lookup"><span data-stu-id="3f057-876">In the .NET Framework version 1.0 and 1.1, two delegates are considered equal if their targets, methods, and invocation list were equal, even if the delegates were of different types.</span></span>  
  
 <span data-ttu-id="3f057-877">Методы и целевые объекты сравниваются на равенство следующим образом:</span><span class="sxs-lookup"><span data-stu-id="3f057-877">The methods and targets are compared for equality as follows:</span></span>  
  
-   <span data-ttu-id="3f057-878">Если два сравниваемых метода являются статическими и одинаковы для одного и того же класса, то методы считаются равными, а целевые объекты также считаются равными.</span><span class="sxs-lookup"><span data-stu-id="3f057-878">If the two methods being compared are both static and are the same method on the same class, the methods are considered equal and the targets are also considered equal.</span></span>  
  
-   <span data-ttu-id="3f057-879">Если два сравниваемых метода являются методами экземпляра и одинаковы для одного и того же объекта, то методы считаются равными, а целевые объекты также считаются равными.</span><span class="sxs-lookup"><span data-stu-id="3f057-879">If the two methods being compared are instance methods and are the same method on the same object, the methods are considered equal and the targets are also considered equal.</span></span>  
  
-   <span data-ttu-id="3f057-880">В противном случае методы не считаются равными, а целевые объекты также не считаются равными.</span><span class="sxs-lookup"><span data-stu-id="3f057-880">Otherwise, the methods are not considered to be equal and the targets are also not considered to be equal.</span></span>  
  
 <span data-ttu-id="3f057-881">Два списка вызовов не равны, если они имеют разные размеры, если они упорядочены по-разному, или если хотя бы один элемент из одного списка представляет метод или целевой объект, отличный от того, который представлен соответствующим элементом в другом списке.</span><span class="sxs-lookup"><span data-stu-id="3f057-881">Two invocation lists are not equal if they have different sizes, if they are ordered differently, or if at least one element from one list represents a method or target that is different from that represented by its corresponding element in the other list.</span></span>  
  
 <span data-ttu-id="3f057-882">Эквивалентным методом для этого оператора является <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="3f057-882">The equivalent method for this operator is <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="3f057-883">При вызове поздней привязки с помощью таких механизмов, как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-883">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="3f057-884">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="3f057-884">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public static Delegate Remove (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Remove(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remove (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Remove(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member Remove : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Remove (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="3f057-885">Делегат, из списка вызовов которого необходимо удалить список вызовов <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-885">The delegate from which to remove the invocation list of <paramref name="value" />.</span></span></param>
        <param name="value"><span data-ttu-id="3f057-886">Делегат, представляющий список вызовов, который необходимо удалить из списка вызовов <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-886">The delegate that supplies the invocation list to remove from the invocation list of <paramref name="source" />.</span></span></param>
        <summary><span data-ttu-id="3f057-887">Удаляет последнее вхождение списка вызовов делегата из списка вызовов другого делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-887">Removes the last occurrence of the invocation list of a delegate from the invocation list of another delegate.</span></span></summary>
        <returns><span data-ttu-id="3f057-888">Новый делегат со списком вызовов, сформированным путем удаления из <paramref name="source" /> последнего вхождения списка вызовов <paramref name="value" />, если список вызовов <paramref name="value" /> найден в списке вызовов <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-888">A new delegate with an invocation list formed by taking the invocation list of <paramref name="source" /> and removing the last occurrence of the invocation list of <paramref name="value" />, if the invocation list of <paramref name="value" /> is found within the invocation list of <paramref name="source" />.</span></span> <span data-ttu-id="3f057-889">Возвращает <paramref name="source" />, если <paramref name="value" /> имеет значение <see langword="null" /> либо список вызовов <paramref name="value" /> не найден в списке вызовов <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-889">Returns <paramref name="source" /> if <paramref name="value" /> is <see langword="null" /> or if the invocation list of <paramref name="value" /> is not found within the invocation list of <paramref name="source" />.</span></span> <span data-ttu-id="3f057-890">Возвращает пустую ссылку, если список вызовов <paramref name="value" /> равен списку вызовов <paramref name="source" /> либо <paramref name="source" /> является пустой ссылкой.</span><span class="sxs-lookup"><span data-stu-id="3f057-890">Returns a null reference if the invocation list of <paramref name="value" /> is equal to the invocation list of <paramref name="source" /> or if <paramref name="source" /> is a null reference.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f057-891">Если список вызовов `value` соответствует непрерывному набору элементов в списке вызовов `source`, то считается, что список вызовов `value` встречается в списке вызовов `source`.</span><span class="sxs-lookup"><span data-stu-id="3f057-891">If the invocation list of `value` matches a contiguous set of elements in the invocation list of `source`, then the invocation list of `value` is said to occur within the invocation list of `source`.</span></span> <span data-ttu-id="3f057-892">Если список вызовов `value` встречается несколько раз в списке вызовов `source`, Последнее вхождение удаляется.</span><span class="sxs-lookup"><span data-stu-id="3f057-892">If the invocation list of `value` occurs more than once in the invocation list of `source`, the last occurrence is removed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="3f057-893">Вызывающий объект не имеет доступа к методу, представленному делегатом (например, если метод является закрытым).</span><span class="sxs-lookup"><span data-stu-id="3f057-893">The caller does not have access to the method represented by the delegate (for example, if the method is private).</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3f057-894">Типы делегатов не совпадают.</span><span class="sxs-lookup"><span data-stu-id="3f057-894">The delegate types do not match.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="3f057-895">При вызове поздней привязки с помощью таких механизмов, как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-895">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="3f057-896">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="3f057-896">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public static Delegate RemoveAll (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate RemoveAll(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RemoveAll (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ RemoveAll(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member RemoveAll : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.RemoveAll (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="3f057-897">Делегат, из списка вызовов которого необходимо удалить список вызовов <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-897">The delegate from which to remove the invocation list of <paramref name="value" />.</span></span></param>
        <param name="value"><span data-ttu-id="3f057-898">Делегат, представляющий список вызовов, который необходимо удалить из списка вызовов <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-898">The delegate that supplies the invocation list to remove from the invocation list of <paramref name="source" />.</span></span></param>
        <summary><span data-ttu-id="3f057-899">Удаляет все вхождения списка вызовов одного делегата из списка вызовов другого делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-899">Removes all occurrences of the invocation list of a delegate from the invocation list of another delegate.</span></span></summary>
        <returns><span data-ttu-id="3f057-900">Новый делегат со списком вызовов, сформированным путем удаления из списка вызовов <paramref name="source" /> всех вхождений списка вызовов <paramref name="value" />, если список вызовов <paramref name="value" /> найден в списке вызовов <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-900">A new delegate with an invocation list formed by taking the invocation list of <paramref name="source" /> and removing all occurrences of the invocation list of <paramref name="value" />, if the invocation list of <paramref name="value" /> is found within the invocation list of <paramref name="source" />.</span></span> <span data-ttu-id="3f057-901">Возвращает <paramref name="source" />, если <paramref name="value" /> имеет значение <see langword="null" /> либо список вызовов <paramref name="value" /> не найден в списке вызовов <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-901">Returns <paramref name="source" /> if <paramref name="value" /> is <see langword="null" /> or if the invocation list of <paramref name="value" /> is not found within the invocation list of <paramref name="source" />.</span></span> <span data-ttu-id="3f057-902">Возвращает пустую ссылку, если список вызовов <paramref name="value" /> равен списку вызовов <paramref name="source" />, либо список вызовов <paramref name="source" /> содержит только списки вызовов <paramref name="value" />, либо <paramref name="source" /> является пустой ссылкой.</span><span class="sxs-lookup"><span data-stu-id="3f057-902">Returns a null reference if the invocation list of <paramref name="value" /> is equal to the invocation list of <paramref name="source" />, if <paramref name="source" /> contains only a series of invocation lists that are equal to the invocation list of <paramref name="value" />, or if <paramref name="source" /> is a null reference.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f057-903">Если список вызовов `value` соответствует непрерывному набору элементов в списке вызовов `source`, то считается, что список вызовов `value` встречается в списке вызовов `source`.</span><span class="sxs-lookup"><span data-stu-id="3f057-903">If the invocation list of `value` matches a contiguous set of elements in the invocation list of `source`, then the invocation list of `value` is said to occur within the invocation list of `source`.</span></span> <span data-ttu-id="3f057-904">Если список вызовов `value` встречается в списке вызовов `source`несколько раз, удаляются все вхождения.</span><span class="sxs-lookup"><span data-stu-id="3f057-904">If the invocation list of `value` occurs more than once in the invocation list of `source`, all occurrences are removed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="3f057-905">Вызывающий объект не имеет доступа к методу, представленному делегатом (например, если метод является закрытым).</span><span class="sxs-lookup"><span data-stu-id="3f057-905">The caller does not have access to the method represented by the delegate (for example, if the method is private).</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3f057-906">Типы делегатов не совпадают.</span><span class="sxs-lookup"><span data-stu-id="3f057-906">The delegate types do not match.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="3f057-907">При вызове поздней привязки с помощью таких механизмов, как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-907">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="3f057-908">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="3f057-908">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate RemoveImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate RemoveImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function RemoveImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ RemoveImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member RemoveImpl : Delegate -&gt; Delegate&#xA;override this.RemoveImpl : Delegate -&gt; Delegate" Usage="delegate.RemoveImpl d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="3f057-909">Делегат, представляющий список вызовов, который необходимо удалить из списка вызовов текущего делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-909">The delegate that supplies the invocation list to remove from the invocation list of the current delegate.</span></span></param>
        <summary><span data-ttu-id="3f057-910">Удаляет список вызовов одного делегата из списка вызовов другого делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-910">Removes the invocation list of a delegate from the invocation list of another delegate.</span></span></summary>
        <returns><span data-ttu-id="3f057-911">Новый делегат со списком вызовов, сформированным удаления списка вызовов <paramref name="value" /> из списка вызовов текущего делегата, если список вызовов <paramref name="value" /> найден в списке вызовов текущего делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-911">A new delegate with an invocation list formed by taking the invocation list of the current delegate and removing the invocation list of <paramref name="value" />, if the invocation list of <paramref name="value" /> is found within the current delegate's invocation list.</span></span> <span data-ttu-id="3f057-912">Возвращает текущий делегат, если <paramref name="value" /> имеет значение <see langword="null" /> или список вызовов <paramref name="value" /> не найден в списке вызовов текущего делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-912">Returns the current delegate if <paramref name="value" /> is <see langword="null" /> or if the invocation list of <paramref name="value" /> is not found within the current delegate's invocation list.</span></span> <span data-ttu-id="3f057-913">Возвращает <see langword="null" />, если список вызовов <paramref name="value" /> равен списку вызовов текущего делегата.</span><span class="sxs-lookup"><span data-stu-id="3f057-913">Returns <see langword="null" /> if the invocation list of <paramref name="value" /> is equal to the current delegate's invocation list.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f057-914">Если список вызовов `value` соответствует непрерывному набору элементов в списке вызовов текущего делегата, то в списке вызовов текущего делегата возникает список вызовов `value`.</span><span class="sxs-lookup"><span data-stu-id="3f057-914">If the invocation list of `value` matches a contiguous set of elements in the current delegate's invocation list, then the invocation list of `value` is said to occur within the current delegate's invocation list.</span></span> <span data-ttu-id="3f057-915">Если список вызовов `value` встречается более одного раза в списке вызовов текущего делегата, Последнее вхождение удаляется.</span><span class="sxs-lookup"><span data-stu-id="3f057-915">If the invocation list of `value` occurs more than once in the current delegate's invocation list, the last occurrence is removed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="3f057-916">Вызывающий объект не имеет доступа к методу, представленному делегатом (например, если метод является закрытым).</span><span class="sxs-lookup"><span data-stu-id="3f057-916">The caller does not have access to the method represented by the delegate (for example, if the method is private).</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="3f057-917">При вызове поздней привязки с помощью таких механизмов, как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-917">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="3f057-918">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="3f057-918">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Target">
      <MemberSignature Language="C#" Value="public object Target { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Target" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Target" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Target As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Target { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Target : obj" Usage="System.Delegate.Target" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3f057-919">Возвращает экземпляр класса, метод которого вызывает текущий делегат.</span><span class="sxs-lookup"><span data-stu-id="3f057-919">Gets the class instance on which the current delegate invokes the instance method.</span></span></summary>
        <value><span data-ttu-id="3f057-920">Объект, для которого текущий делегат вызывает метод экземпляра, если делегат представляет метод экземпляра, либо <see langword="null" /> если делегат представляет статический метод.</span><span class="sxs-lookup"><span data-stu-id="3f057-920">The object on which the current delegate invokes the instance method, if the delegate represents an instance method; <see langword="null" /> if the delegate represents a static method.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f057-921">Метод экземпляра — это метод, связанный с экземпляром класса; статический метод — это метод, который связан с самим классом.</span><span class="sxs-lookup"><span data-stu-id="3f057-921">An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</span></span>  
  
 <span data-ttu-id="3f057-922">Если делегат вызывает один или несколько методов экземпляра, это свойство возвращает целевой объект последнего метода экземпляра в списке вызовов.</span><span class="sxs-lookup"><span data-stu-id="3f057-922">If the delegate invokes one or more instance methods, this property returns the target of the last instance method in the invocation list.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="3f057-923">При вызове поздней привязки с помощью таких механизмов, как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="3f057-923">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="3f057-924">Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="3f057-924">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
      </Docs>
    </Member>
  </Members>
</Type>
