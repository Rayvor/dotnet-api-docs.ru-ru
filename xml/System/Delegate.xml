<Type Name="Delegate" FullName="System.Delegate">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7fef904577d04b32b33e58ae8584c9ebb4f953e6" /><Meta Name="ms.sourcegitcommit" Value="a22d0855bbf24d893f43605f8b7e3a44bd9551a5" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70372387" /></Metadata><TypeSignature Language="C#" Value="public abstract class Delegate : ICloneable, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Delegate extends System.Object implements class System.ICloneable, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Delegate" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Delegate&#xA;Implements ICloneable, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Delegate abstract : ICloneable, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Delegate = class&#xA;    interface ICloneable&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет делегат — структуру данных, указывающую на статический метод или на экземпляр класса и метод экземпляра этого класса.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Delegate> Класс является базовым классом для типов делегатов. Однако только система и компиляторы могут явно наследоваться от <xref:System.Delegate> класса или <xref:System.MulticastDelegate> класса. Также не допускается получение нового типа из типа делегата. <xref:System.Delegate> Класс не считается типом делегата; это класс, используемый для наследования типов делегатов.  
  
 Большинство языков реализуют `delegate` ключевое слово, и компиляторы для этих языков могут быть производными <xref:System.MulticastDelegate> от класса, поэтому пользователи должны использовать `delegate` ключевое слово, предоставляемое языком.  
  
> [!NOTE]
>  Среда CLR предоставляет `Invoke` метод для каждого типа делегата с той же сигнатурой, что и делегат. Нет необходимости вызывать этот метод явно из C#, Visual Basic или Visual C++, так как компиляторы вызывают его автоматически. Метод полезен в отражении, если требуется найти сигнатуру типа делегата. [](~/docs/framework/reflection-and-codedom/reflection.md) `Invoke`  
  
 Среда CLR предоставляет каждому типу `BeginInvoke` делегата методы и `EndInvoke` , чтобы обеспечить асинхронный вызов делегата. Дополнительные сведения об этих методах см. в разделе [асинхронный вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
 Объявление типа делегата устанавливает контракт, указывающий сигнатуру одного или нескольких методов. Делегат — это экземпляр типа делегата, который имеет ссылки на:  
  
-   Метод экземпляра типа и целевой объект, назначаемый этому типу.  
  
-   Метод экземпляра типа с скрытым `this` параметром, предоставленным в списке формальных параметров. Говорят, что делегат является открытым делегатом экземпляра.  
  
-   Статический метод.  
  
-   Статический метод и целевой объект, назначаемые первому параметру метода. Говорят, что делегат закрыт по первому аргументу.  
  
 Дополнительные сведения о привязке делегата см. <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> в разделе перегрузка метода.  
  
> [!NOTE]
>  В .NET Framework версиях 1,0 и 1,1 делегат может представлять метод только в том случае, если сигнатура метода точно соответствует сигнатуре, заданной типом делегата. Поэтому поддерживаются только первый и третий маркеры в приведенном выше списке, и первый маркер требует точного совпадения типа.  
  
 Когда делегат представляет метод экземпляра, закрытый для первого аргумента (наиболее распространенный случай), делегат сохраняет ссылку на точку входа метода и ссылку на объект, называемый целевым объектом, который имеет тип, который можно присвоить типу, который определил Method. Когда делегат представляет открытый метод экземпляра, он сохраняет ссылку на точку входа метода. Сигнатура делегата должна включать скрытый `this` параметр в список формальных параметров; в этом случае делегат не имеет ссылки на целевой объект, и при вызове делегата должен быть указан целевой объект.  
  
 Когда делегат представляет статический метод, делегат сохраняет ссылку на точку входа метода. Когда делегат представляет статический метод, закрытый для своего первого аргумента, делегат сохраняет ссылку на точку входа метода и ссылку на целевой объект, назначаемый типу первого аргумента метода. При вызове делегата первый аргумент статического метода получает целевой объект.  
  
 Список вызовов делегата — это упорядоченный набор делегатов, в которых каждый элемент списка вызывает только один из методов, представленных делегатом. Список вызовов может содержать дублирующиеся методы. Во время вызова методы вызываются в том порядке, в котором они указаны в списке вызовов. Делегат пытается вызвать каждый метод в своем списке вызовов; дубликаты вызываются один раз для каждого, когда они появляются в списке вызовов. Делегаты являются неизменяемыми; После создания список вызовов делегата не изменяется.  
  
 Делегаты называются многоадресностью или комбинированными, так как делегат может вызывать один или несколько методов и может использоваться в операциях объединения.  
  
 Объединение операций, таких как <xref:System.Delegate.Combine%2A> и <xref:System.Delegate.Remove%2A>, не приводит к изменению существующих делегатов. Вместо этого такая операция возвращает новый делегат, который содержит результаты операции, неизмененный делегат или `null`. Операция объединения возвращает `null` , когда результатом операции является делегат, который не ссылается хотя бы на один метод. Операция объединения возвращает делегат без изменений, если запрошенная операция не имеет результата.  
  
> [!NOTE]
>  Управляемые языки используют <xref:System.Delegate.Combine%2A> методы и <xref:System.Delegate.Remove%2A> для реализации операций делегата. Примеры включают в `AddHandler` себя `RemoveHandler` операторы и в Visual Basic и операторы + = и-= для типов делегатов C#в.  
  
 Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], универсальные типы делегатов могут иметь параметры типа Variant. Параметры контравариантного типа можно использовать в качестве типов параметров делегата, а параметр ковариантного типа можно использовать в качестве возвращаемого типа. Эта функция позволяет обеспечить совместимость типов универсальных делегатов, созданных из того же определения универсального типа, если их аргументы типа являются ссылочными типами с отношением наследования, как описано в [ковариации и контрвариация ](~/docs/standard/generics/covariance-and-contravariance.md).  
  
> [!NOTE]
>  Универсальные делегаты, совместимые с присваиванием, в связи с дисперсией не всегда являются комбинированными. Чтобы обеспечить возможность комбинирования, типы должны точно совпадать. Например, предположим, что класс с именем `Derived` является производным от класса с `Base`именем. Делегат типа `Action<Base>` (`Action(Of Base)` в Visual Basic) может быть присвоен переменной типа `Action<Derived>`, но два делегата не могут быть объединены, так как типы не совпадают в точности.  
  
 Если вызванный метод создает исключение, метод прекращает выполнение, исключение передается обратно вызывающему объекту делегата, а остальные методы в списке вызовов не вызываются. Перехват исключения в вызывающем объекте не влияет на это поведение.  
  
 Когда сигнатура методов, вызываемых делегатом, содержит возвращаемое значение, делегат возвращает возвращаемое значение последнего элемента в списке вызовов. Если сигнатура содержит параметр, передаваемый по ссылке, то конечное значение параметра представляет собой результат каждого метода в списке вызовов, который выполняется последовательно и обновляет значение параметра.  
  
 Ближайший эквивалент делегата в языке C является указателем на функцию. Делегат может представлять статический метод или метод экземпляра. Когда делегат представляет метод экземпляра, в делегате хранится не только ссылка на точку входа метода, но и ссылка на экземпляр класса. В отличие от указателей функций делегаты являются объектно ориентированными и типизированными.  
  
   
  
## Examples  
 В следующем примере показано, как определить делегат с именем `myMethodDelegate`. Экземпляры этого делегата создаются для метода экземпляра и статического метода вложенного `mySampleClass` класса. Делегат для метода экземпляра требует наличия экземпляра `mySampleClass`. Экземпляр сохраняется в переменной с именем `mySC`. `mySampleClass`  
  
 [!code-cpp[Classic Delegate Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Delegate Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Delegate Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Delegate Example/CS/source.cs#1)]
 [!code-vb[Classic Delegate Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Delegate Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.MulticastDelegate" />
    <related type="Article" href="https://msdn.microsoft.com/library/41972034-92ed-450a-9664-ab93fcc6f1fb">Асинхронный вызов синхронных методов</related>
    <related type="Article" href="~/docs/csharp/programming-guide/delegates/index.md">Делегаты (Руководство по программированию на C#)</related>
    <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/delegates/index.md">Делегаты (Visual Basic)</related>
    <related type="Article" href="https://msdn.microsoft.com/library/1cdf3420-89c1-47c0-b796-aa984020e0f8">Практическое руководство. Определение и использование делегатов (C++/CLI)</related>
    <related type="Article" href="https://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f">Обработка и вызов событий</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый делегат.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Object, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : obj * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="target" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="target">Экземпляр класса, метод <paramref name="method" /> которого вызывает делегат.</param>
        <param name="method">Имя представленного делегатом метода экземпляра.</param>
        <summary>Инициализирует делегат, вызывающий заданный метод экземпляра указанного класса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор нельзя использовать в коде приложения. Чтобы создать делегат, указав имя метода экземпляра, используйте перегрузку <xref:System.Delegate.CreateDelegate%2A> метода, который указывает имя метода и целевой объект. Например, <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29> перегрузка метода создает делегат для метода экземпляра с указанным именем.  
  
 Этот конструктор создает делегаты только для методов экземпляра. Метод экземпляра — это метод, связанный с экземпляром класса; статический метод — это метод, который связан с самим классом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="target" /> имеет значение <see langword="null" />.  
  
-или- 
 Свойство <paramref name="method" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Произошла ошибка связывания с целевым методом.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязки с помощью таких механизмов <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />, как. Связанное перечисление:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Object" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Type, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : Type * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="target" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="target">Тип <see cref="T:System.Type" />, представляющий класс, в котором определен метод <paramref name="method" />.</param>
        <param name="method">Имя представленного делегатом статического метода.</param>
        <summary>Инициализирует делегат, вызывающий заданный статистический метод указанного класса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор нельзя использовать в коде приложения. Чтобы создать делегат, указав имя статического метода, используйте перегрузку <xref:System.Delegate.CreateDelegate%2A> метода, который указывает имя метода, но не указывает целевой объект. Например, <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29> перегрузка метода создает статический делегат для метода с указанным именем.  
  
 Этот конструктор создает делегаты только для статических методов. Метод экземпляра — это метод, связанный с экземпляром класса; статический метод — это метод, который связан с самим классом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="target" /> имеет значение <see langword="null" />.  
  
-или- 
 <paramref name="method" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="target" /> не является объектом <see langword="RuntimeType" />. См. статью [Типы среды выполнения в отражении](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
- или - 
 <paramref name="target" /> представляет открытый универсальный тип.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязки с помощью таких механизмов <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />, как. Связанное перечисление:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="delegate.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает неполную копию делегата.</summary>
        <returns>Неполная копия делегата.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Клон имеет тот же <xref:System.Type>, целевой, метод и список вызовов, что и исходный делегат.  
  
 Неполная копия создает новый экземпляр того же типа, что и исходный объект, а затем копирует нестатические поля исходного объекта. Если поле имеет тип значения, выполняется побитовая копия поля. Если поле является ссылочным типом, то ссылка копируется, но на объект, на который указывает ссылка, нет; Поэтому ссылка в исходном объекте и ссылка в точке клона указывают на один и тот же объект. В отличие от этого, глубокая копия объекта дублирует все, на которые прямо или косвенно ссылаются поля в объекте.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязки с помощью таких механизмов <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />, как. Связанное перечисление:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Сцепляет списки вызовов заданных групповых (комбинируемых) делегатов.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (params Delegate[] delegates);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate[] delegates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray delegates As Delegate()) As Delegate" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(... cli::array &lt;Delegate ^&gt; ^ delegates);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate[] -&gt; Delegate" Usage="System.Delegate.Combine delegates" />
      <MemberSignature Language="C#" Value="public static Delegate Combine (Delegate[] delegates);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (delegates As Delegate()) As Delegate" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(cli::array &lt;Delegate ^&gt; ^ delegates);" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegates" Type="System.Delegate[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegates">Массив комбинируемых делегатов.</param>
        <summary>Сцепляет списки вызовов массива делегатов.</summary>
        <returns>Новый делегат со списком вызовов, представляющим собой сцепление списков вызовов делегатов, заданных в массиве <paramref name="delegates" />. Возвращает <see langword="null" />, если <paramref name="delegates" /> имеет значение <see langword="null" />, либо <paramref name="delegates" /> содержит нуль элементов, либо каждый элемент в <paramref name="delegates" /> имеет значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если массив содержит записи `null`, то эти записи игнорируются. `delegates`  
  
 Список вызовов может содержать дублирующиеся записи. то есть записи, ссылающиеся на один и тот же метод для одного и того же объекта.  
  
> [!NOTE]
>  Универсальные делегаты, совместимые с присваиванием, в связи с дисперсией не всегда являются комбинированными. Чтобы обеспечить возможность комбинирования, типы должны точно совпадать. Например, предположим, что класс с именем `Derived` является производным от класса с `Base`именем. Делегат типа `Action<Base>` (`Action(Of Base)` в Visual Basic) может быть присвоен переменной типа `Action<Derived>`, как описано в [ковариации и контрвариация](~/docs/standard/generics/covariance-and-contravariance.md), но два делегата не могут быть объединены, так как типы не совпадают в точности.  
  
 <xref:System.Delegate.Combine%2A>полезен для создания обработчиков событий, которые вызывают несколько методов при каждом возникновении события.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Не все ненулевые элементы в <paramref name="delegates" /> являются экземплярами одного типа делегата.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязки с помощью таких механизмов <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />, как. Связанное перечисление:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (Delegate a, Delegate b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate a, class System.Delegate b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (a As Delegate, b As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(Delegate ^ a, Delegate ^ b);" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Combine (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Delegate" />
        <Parameter Name="b" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="a">Делегат, список вызовов которого передан первым.</param>
        <param name="b">Делегат, список вызовов которого передан вторым.</param>
        <summary>Сцепляет списки вызовов двух делегатов.</summary>
        <returns>Новый делегат со списком вызовов, представляющим собой сцепление списков вызовов, заданных в параметрах <paramref name="a" /> и <paramref name="b" /> в указанном порядке. Возвращает <paramref name="a" />, если <paramref name="b" /> имеет значение <see langword="null" />; возвращает <paramref name="b" />, если <paramref name="a" /> является пустой ссылкой; возвращает пустую ссылку, если <paramref name="a" /> и <paramref name="b" /> являются пустыми ссылками.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Список вызовов может содержать дублирующиеся записи. то есть записи, ссылающиеся на один и тот же метод для одного и того же объекта.  
  
> [!NOTE]
>  Универсальные делегаты, совместимые с присваиванием, в связи с дисперсией не всегда являются комбинированными. Чтобы обеспечить возможность комбинирования, типы должны точно совпадать. Например, предположим, что класс с именем `Derived` является производным от класса с `Base`именем. Делегат типа `Action<Base>` (`Action(Of Base)` в Visual Basic) может быть присвоен переменной типа `Action<Derived>`, как описано в [ковариации и контрвариация](~/docs/standard/generics/covariance-and-contravariance.md), но два делегата не могут быть объединены, так как типы не совпадают в точности.  
  
 <xref:System.Delegate.Combine%2A>полезен для создания обработчиков событий, которые вызывают несколько методов при каждом возникновении события.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение обоих параметров, <paramref name="a" /> и <paramref name="b" />, не равно <see langword="null" />, и эти параметры <paramref name="a" /> и <paramref name="b" /> не являются экземплярами одного и того же типа делегата.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязки с помощью таких механизмов <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />, как. Связанное перечисление:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="CombineImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate CombineImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate CombineImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CombineImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CombineImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ CombineImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member CombineImpl : Delegate -&gt; Delegate&#xA;override this.CombineImpl : Delegate -&gt; Delegate" Usage="delegate.CombineImpl d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="d">Групповой (комбинируемый) делегат, чей список вызовов необходимо добавить в конец списка вызовов текущего группового (комбинируемого) делегата.</param>
        <summary>Сцепляет списки вызовов заданного группового (комбинируемого) делегата и текущего группового (комбинируемого) делегата.</summary>
        <returns>Новый групповой (комбинируемый) делегат со списком вызовов, состоящим из сцепления списков вызовов текущего группового (комбинируемого) делегата и делегата, заданного в параметре <paramref name="d" />, или текущий групповой (комбинируемый) делегат, если <paramref name="d" /> имеет значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод применяется только в том случае, если текущий делегат является многоадресным (комбинированным).  
  
 Текущая реализация просто создает исключение <xref:System.MulticastNotSupportedException>.  
  
 Список вызовов может содержать дублирующиеся записи. то есть записи, ссылающиеся на один и тот же метод для одного и того же объекта.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MulticastNotSupportedException">Создается всегда.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязки с помощью таких механизмов <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />, как. Связанное перечисление:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает делегат указанного типа.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" /> создаваемого делегата.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" />, описывающий статический метод или метод экземпляра, который будет представлен делегатом. На платформе .NET Framework версий 1.0 и 1.1 поддерживаются только статические методы.</param>
        <summary>Создает делегат указанного типа, представляющий заданный статический метод.</summary>
        <returns>Делегат указанного типа, представляющий заданный статический метод.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В .NET Framework версии 1,0 и 1,1 Эта перегрузка метода создает делегаты только для статических методов. В .NET Framework версии 2,0 Эта перегрузка метода также может создавать делегаты методов открытого экземпляра. Это значит, что делегаты явно предоставляют скрытый первый аргумент методов экземпляра. Подробное описание см. в разделе более общий <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> перегруженный метод, который позволяет создавать все сочетания открытых или закрытых делегатов для экземпляров или статических методов, а также при необходимости указывать первый аргумент.  
  
> [!NOTE]
>  Этот перегруженный метод следует использовать, когда делегат не закрыт по первому аргументу, так как в этом случае он выполняется несколько быстрее.  
  
 Перегрузка этого метода эквивалентна вызову <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> перегрузки метода и указанию `true` для `throwOnBindFailure`.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для доступа к закрытым методам, если вызывающему объекту был предоставлен <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> флаг, и если набор разрешений неоткрытых методов ограничен набором предоставления вызывающего объекта или подмножеством сочетани. (См. раздел [вопросы безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
## <a name="compatible-parameter-types-and-return-type"></a>Совместимые типы параметров и возвращаемый тип  
 В .NET Framework версии 2,0 типы параметров и тип возвращаемого значения делегата, созданного с помощью этой перегрузки метода, должны быть совместимы с типами параметров и типом возвращаемого значения метода, который представляет делегат. типы не обязательно должны точно совпадать. Это представляет ослабление поведения привязки в .NET Framework версии 1,0 и 1,1, где типы должны точно совпадать.  
  
 Если тип параметра делегата является более строгим, чем тип параметра метода, то параметр делегата совместим с соответствующим параметром метода, так как это гарантирует, что аргумент, переданный делегату, может быть безопасно передан методу.  
  
 Аналогичным образом, тип возвращаемого значения делегата совместим с типом возвращаемого значения метода, если тип возвращаемого значения метода является более строгим, чем тип возвращаемого значения делегата, так как это гарантирует, что возвращаемое значение метода может быть безопасно приведено к типу возвращаемого значения делегата.  
  
 Например, делегат <xref:System.Collections.Hashtable> с параметром типа и <xref:System.Object> типом возвращаемого значения может представлять метод с параметром типа <xref:System.Object> и возвращаемым значением типа <xref:System.Collections.Hashtable>.  
  
   
  
## Examples  
 Этот раздел содержит два примера кода. В первом примере показаны два вида делегатов, которые можно создать с помощью этой перегрузки метода: открыть через метод экземпляра и открыть в статическом методе.  
  
 Во втором примере кода демонстрируются совместимые типы параметров и возвращаемые типы.  
  
 **Пример 1**  
  
 В следующем примере кода показаны два способа создания делегата с помощью этой перегрузки <xref:System.Delegate.CreateDelegate%2A> метода.  
  
> [!NOTE]
>  Существует две перегрузки <xref:System.Delegate.CreateDelegate%2A> метода, указывающие, <xref:System.Reflection.MethodInfo> но не первый аргумент; их функциональные возможности одинаковы, за исключением того, что можно указать, следует ли создавать привязку при сбое, а другое всегда создает исключение. В этом примере кода используются обе перегрузки.  
  
 В примере объявляется `C` класс со статическим методом `M2` и методом `M1`экземпляра, а также `C` два типа делегата: `D1` принимает экземпляр и строку и `D2` принимает строку.  
  
 Второй класс с именем `Example` содержит код, создающий делегаты.  
  
-   Делегат типа `D1`, представляющий открытый метод экземпляра, создается для метода `M1`экземпляра. Экземпляр должен передаваться при вызове делегата.  
  
-   Для статического метода `M2`создается `D2`делегат типа, представляющий открытый статический метод.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Пример 2**  
  
 В следующем примере кода демонстрируется совместимость типов параметров и возвращаемых типов.  
  
 В примере кода определяется базовый класс с именем `Base` и `Derived` класс, производный от `Base`. Производный `static` класс имеет метод (`Shared` в Visual Basic) с именем `MyMethod` с одним параметром типа `Base` и типом возвращаемого значения `Derived`. В примере кода также определяется делегат с именем `Example` с одним параметром типа `Derived` и типом возвращаемого значения `Base`.  
  
 В примере кода показано, что для представления `Example` метода `MyMethod`можно использовать делегат с именем. Метод можно привязать к делегату по следующим причинам:  
  
-   Тип`Derived`параметра делегата () более ограничен, чем `MyMethod` тип параметра (`Base`), чтобы всегда быть уверенным `MyMethod`в передаче аргумента делегата.  
  
-   Тип возвращаемого значения `MyMethod` (`Derived`) является более строгой, чем тип параметра делегата (`Base`), чтобы всегда быть уверенным в том, чтобы привести возвращаемый тип метода к возвращаемому типу делегата.  
  
 В примере кода выходные данные не создаются.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="type" /> имеет значение <see langword="null" />.  
  
- или - 
 Свойство <paramref name="method" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> не является производным от <see cref="T:System.MulticastDelegate" />.  
  
-или- 
 <paramref name="type" /> не является объектом типа <see langword="RuntimeType" />. См. статью [Типы среды выполнения в отражении](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
-или- 
 <paramref name="method" /> не является статическим методом и платформа .NET Framework имеет версию 1.0 или 1.1.  
  
-или- 
 Не удалось выполнить связывание <paramref name="method" />.  
  
-или- 
 <paramref name="method" /> не является объектом типа <see langword="RuntimeMethodInfo" />. См. статью [Типы среды выполнения в отражении](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">Метод <see langword="Invoke" /> типа <paramref name="type" /> не найден.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет необходимых разрешений для доступа к <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязки с помощью таких механизмов <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />, как. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="firstArgument" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type">Тип <see cref="T:System.Type" /> создаваемого делегата.</param>
        <param name="firstArgument">Объект, с которым связан делегат, или <see langword="null" /> для интерпретации <paramref name="method" /> как <see langword="static" /> (<see langword="Shared" /> в Visual Basic).</param>
        <param name="method">Объект <see cref="T:System.Reflection.MethodInfo" />, описывающий статический метод или метод экземпляра, который будет представлен делегатом.</param>
        <summary>Создает делегат указанного типа, представляющий заданный статический метод или метод экземпляра, с заданным первым аргументом.</summary>
        <returns>Делегат указанного типа, представляющий заданный статический метод или метод экземпляра.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов этой перегрузки метода эквивалентен вызову <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> перегрузки метода и указанию `true` для `throwOnBindFailure`. Эти две перегрузки обеспечивают наиболее гибкий способ создания делегатов. Их можно использовать для создания делегатов для статических методов или, а также для указания первого аргумента.  
  
> [!NOTE]
>  Если не указать первый аргумент, используйте <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> перегрузку метода для повышения производительности.  
  
 Тип делегата и метод должны иметь совместимые типы возвращаемых значения. То есть тип `method` возвращаемого значения должен быть назначен возвращаемому `type`типу.  
  
 Если `firstArgument` указан аргумент, он `method` передается при каждом вызове делегата; `firstArgument` считается привязанным к делегату, и делегат называется закрытым для своего первого аргумента. Если `method` имеет `static` значение(`Shared` в Visual Basic), список аргументов, предоставленный при вызове делегата, включает все параметры, кроме `method` первого; если является методом экземпляра `firstArgument` , то передается в скрытый экземпляр. параметр (представленный `this` в C#или `Me` в Visual Basic).  
  
 Если `firstArgument` указан аргумент, первый `method` параметр должен быть ссылочным типом и `firstArgument` должен быть совместим с этим типом.  
  
> [!IMPORTANT]
>  Если `method` имеет `firstArgument` <xref:System.ValueType> <xref:System.Object> значение (`Shared` в Visual Basic) и его первый параметр имеет тип или, то может быть типом значения. `static` В этом случае `firstArgument` автоматически упаковывается. Автоматическая упаковка- C# преобразование не выполняется для других аргументов, как в вызове функции или Visual Basic.  
  
 Если `firstArgument` является пустой ссылкой и `method` является методом экземпляра, результат зависит от сигнатур типа `type` делегата и `method`:  
  
-   Если сигнатура `type` явно включает в себя скрытый первый `method`параметр, то говорят, что делегат представляет открытый метод экземпляра. При вызове делегата первый аргумент в списке аргументов передается в параметр `method`скрытого экземпляра.  
  
-   Если сигнатуры `method` и `type` совпадают (то есть все типы параметров совместимы), делегат считается закрытым по пустой ссылке. Вызов делегата аналогичен вызову метода экземпляра для экземпляра со значением NULL, что не особенно полезно для этого.  
  
 Если `firstArgument` параметр является пустой ссылкой и `method` является статическим, результат зависит от сигнатур типа `type` делегата и `method`:  
  
-   Если сигнатура `method` и `type` совпадает (то есть все типы параметров совместимы), делегат называется открытым статическим методом. Это наиболее распространенный случай для статических методов. В этом случае можно получить немного более высокую производительность с помощью <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> перегрузки метода.  
  
-   Если сигнатура `type` начинается со второго `method` параметра, а остальные типы параметров совместимы, то делегат называется закрытым с помощью пустой ссылки. При вызове делегата в первый параметр метода `method`передается пустая ссылка.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для доступа к закрытым методам, если вызывающему объекту был предоставлен <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> флаг, и если набор разрешений неоткрытых методов ограничен набором предоставления вызывающего объекта или подмножеством сочетани. (См. раздел [вопросы безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
## <a name="compatible-parameter-types-and-return-type"></a>Совместимые типы параметров и возвращаемый тип  
 Типы параметров и возвращаемый тип делегата должны быть совместимы с типами параметров и типом возвращаемого значения метода, который представляет делегат. типы не обязательно должны точно совпадать.  
  
> [!NOTE]
>  В .NET Framework версии 1,0 и 1,1 типы должны точно совпадать.  
  
 Если тип параметра делегата является более строгим, чем тип параметра метода, то параметр делегата совместим с соответствующим параметром метода, так как это гарантирует, что аргумент, переданный делегату, может быть безопасно передан методу.  
  
 Аналогичным образом, тип возвращаемого значения делегата совместим с типом возвращаемого значения метода, если тип возвращаемого значения метода является более строгим, чем тип возвращаемого значения делегата, так как это гарантирует, что возвращаемое значение метода может быть безопасно приведено к типу возвращаемого значения делегата.  
  
 Например, делегат <xref:System.Collections.Hashtable> с параметром типа и <xref:System.Object> типом возвращаемого значения может представлять метод с параметром типа <xref:System.Object> и возвращаемым значением типа <xref:System.Collections.Hashtable>.  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>Определение методов, которые может представлять делегат  
 Еще один полезный способ представить гибкость, обеспечиваемую этой перегрузкой <xref:System.Delegate.CreateDelegate%2A> , заключается в том, что любой заданный делегат может представлять четыре различных сочетания сигнатуры и типа метода (статический и экземпляр). Рассмотрим тип `D` делегата с одним аргументом типа `C`. Ниже описаны методы `D` , которые могут представлять, игнорируя возвращаемый тип, так как он должен совпадать во всех случаях:  
  
-   `D`может представлять любой метод экземпляра, имеющий только один аргумент типа `C`, независимо от того, к какому типу относится метод экземпляра. При <xref:System.Delegate.CreateDelegate%2A> `method` вызове метод является экземпляром типа, а получившийся делегат называется закрытым для этого экземпляра. `firstArgument` (Тривиальный элемент `D` также может быть закрыт над пустой ссылкой, если `firstArgument` является пустой ссылкой.)  
  
-   `D`может представлять метод `C` экземпляра, не имеющий аргументов. <xref:System.Delegate.CreateDelegate%2A> При`firstArgument` вызове метода является пустой ссылкой. Результирующий делегат представляет открытый метод экземпляра, а экземпляр `C` должен предоставляться каждый раз при вызове метода.  
  
-   `D`может представлять статический метод, который принимает один аргумент типа `C`, и этот метод может принадлежать любому типу. <xref:System.Delegate.CreateDelegate%2A> При`firstArgument` вызове метода является пустой ссылкой. Результирующий делегат представляет открытый статический метод, а экземпляр `C` должен предоставляться каждый раз при вызове метода.  
  
-   `D`может представлять статический метод, принадлежащий типу `F` и имеющий два аргумента типа `F` и типа `C`. При <xref:System.Delegate.CreateDelegate%2A> `F`вызове метод является экземпляром. `firstArgument` Результирующий делегат представляет статический метод, закрытый для этого экземпляра `F`. Обратите внимание, что в `F` случае `C` , когда и относятся к одному и тому же типу, статический метод имеет два аргумента этого типа. (В данном случае закрывается по пустой ссылке, `D` если `firstArgument` является пустой ссылкой.)  
  
   
  
## Examples  
 Этот раздел содержит три примера кода. В первом примере показаны четыре типа делегатов, которые могут быть созданы: закрыто над методом экземпляра, открыто через метод экземпляра, открыто через статический метод и закрыто по статическому методу.  
  
 Во втором примере кода демонстрируются совместимые типы параметров и возвращаемые типы.  
  
 В третьем примере кода определяется один тип делегата и отображаются все методы, которые могут представляться типом делегата.  
  
 **Пример 1**  
  
 В следующем примере кода показаны четыре способа создания делегата с помощью этой перегрузки <xref:System.Delegate.CreateDelegate%2A> метода.  
  
> [!NOTE]
>  Существует две перегрузки <xref:System.Delegate.CreateDelegate%2A> метода, которые задают `firstArgument` и <xref:System.Reflection.MethodInfo>; их функциональные возможности одинаковы, за исключением того, что позволяет указать, следует ли создавать привязку при ошибке, а вторая всегда создает исключение. В этом примере кода используются обе перегрузки.  
  
 В примере объявляется `C` класс со статическим методом `M2` и методом `M1`экземпляра, а также `C` три типа делегата: `D1` принимает экземпляр и строку, `D2` принимает строку и `D3`не имеет аргументов.  
  
 Второй класс с именем `Example` содержит код, создающий делегаты.  
  
-   Делегат типа `D2`, закрытый над `C`экземпляром, создается для метода `M1`экземпляра. Он вызывается с разными строками, чтобы продемонстрировать, что привязанный экземпляр `C` всегда используется.  
  
-   Делегат типа `D1`, представляющий открытый метод экземпляра, создается для метода `M1`экземпляра. Экземпляр должен передаваться при вызове делегата.  
  
-   Для статического метода `M2`создается `D2`делегат типа, представляющий открытый статический метод.  
  
-   Наконец, для статического метода `D3` `M2`создается делегат типа, закрытый над строкой. Метод вызывается, чтобы продемонстрировать, что он использует привязанную строку.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Пример 2**  
  
 В следующем примере кода демонстрируется совместимость типов параметров и возвращаемых типов.  
  
> [!NOTE]
>  В <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> этом примере кода используется перегрузка метода. Использование других перегрузок, которые принимаются <xref:System.Reflection.MethodInfo> , аналогично.  
  
 В примере кода определяется базовый класс с именем `Base` и `Derived` класс, производный от `Base`. Производный `static` класс имеет метод (`Shared` в Visual Basic) с именем `MyMethod` с одним параметром типа `Base` и типом возвращаемого значения `Derived`. В примере кода также определяется делегат с именем `Example` с одним параметром типа `Derived` и типом возвращаемого значения `Base`.  
  
 В примере кода показано, что для представления `Example` метода `MyMethod`можно использовать делегат с именем. Метод можно привязать к делегату по следующим причинам:  
  
-   Тип`Derived`параметра делегата () более ограничен, чем `MyMethod` тип параметра (`Base`), чтобы всегда быть уверенным `MyMethod`в передаче аргумента делегата.  
  
-   Тип возвращаемого значения `MyMethod` (`Derived`) является более строгой, чем тип параметра делегата (`Base`), чтобы всегда быть уверенным в том, чтобы привести возвращаемый тип метода к возвращаемому типу делегата.  
  
 В примере кода выходные данные не создаются.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **Пример 3**  
  
 В следующем примере кода показаны все методы, которые может представлять один тип делегата, с <xref:System.Delegate.CreateDelegate%2A> помощью метода для создания делегатов.  
  
> [!NOTE]
>  Существует две перегрузки <xref:System.Delegate.CreateDelegate%2A> метода, которые задают `firstArgument` и <xref:System.Reflection.MethodInfo>; их функциональные возможности одинаковы, за исключением того, что позволяет указать, следует ли создавать привязку при ошибке, а вторая всегда создает исключение. В этом примере кода используются обе перегрузки.  
  
 В примере кода определяются два класса `C` : `F`и, и тип `D` делегата с одним аргументом `C`типа. Классы имеют совпадающие статические методы и `M1`метод `M3`экземпляра, `M4`, и, `C` а класс также имеет метод `M2` экземпляра, не имеющий аргументов.  
  
 Третий класс с именем `Example` содержит код, создающий делегаты.  
  
-   Делегаты создаются для метода `M1` экземпляра типа `C` и типа `F`, каждый из которых закрыт для экземпляра соответствующего типа. Метод `M1` типа `C` отображает`ID` свойства привязанного экземпляра и аргумента.  
  
-   Делегат создается для метода `M2` типа. `C` Это делегат открытого экземпляра, в котором аргумент делегата представляет собой скрытый первый аргумент в методе экземпляра. Метод не имеет других аргументов. Он вызывается, как если бы он был статическим методом.  
  
-   Делегаты создаются для статического метода `M3` типа `C` и типа `F`. это открытые статические делегаты.  
  
-   Наконец, делегаты создаются для статического метода `M4` типа `C` и типа `F`; каждый метод имеет объявляющий тип в качестве первого аргумента и предоставляется экземпляр типа, поэтому делегаты закрываются по первым аргументам. . Метод `M4` типа `C` отображает`ID` свойства привязанного экземпляра и аргумента.  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="type" /> имеет значение <see langword="null" />.  
  
-или- 
 Свойство <paramref name="method" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> не является производным от <see cref="T:System.MulticastDelegate" />.  
  
- или - 
 <paramref name="type" /> не является объектом типа <see langword="RuntimeType" />. См. статью [Типы среды выполнения в отражении](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
- или - 
 Не удалось выполнить связывание <paramref name="method" />.  
  
-или- 
 <paramref name="method" /> не является объектом типа <see langword="RuntimeMethodInfo" />. См. статью [Типы среды выполнения в отражении](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">Метод <see langword="Invoke" /> типа <paramref name="type" /> не найден.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет необходимых разрешений для доступа к <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязки с помощью таких механизмов <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />, как. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type">Тип <see cref="T:System.Type" /> создаваемого делегата.</param>
        <param name="target">Экземпляр класса, для которого вызывается метод <paramref name="method" />.</param>
        <param name="method">Имя метода экземпляра, который должен быть представлен делегатом.</param>
        <summary>Создает делегат указанного типа, представляющий заданный метод экземпляра, который вызывается для заданного экземпляра класса.</summary>
        <returns>Создает делегат указанного типа, представляющий заданный метод экземпляра, который вызывается для заданного экземпляра класса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод создает делегаты только для методов экземпляра. Метод экземпляра — это метод, связанный с экземпляром класса; статический метод — это метод, который связан с самим классом.  
  
 Перегрузка этого <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> метода эквивалентна вызову перегрузки метода, указывающей `true` `false` для `throwOnBindFailure` `ignoreCase` и для.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для доступа к закрытым методам, если вызывающему объекту был предоставлен <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> флаг, и если набор разрешений неоткрытых методов ограничен набором предоставления вызывающего объекта или подмножеством сочетани. (См. раздел [вопросы безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> — <see langword="null" />.  
  
- или - 
 <paramref name="target" /> — <see langword="null" />.  
  
- или - 
 <paramref name="method" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> не является производным от <see cref="T:System.MulticastDelegate" />.  
  
- или - 
 <paramref name="type" /> не является объектом типа <see langword="RuntimeType" />. См. статью [Типы среды выполнения в отражении](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
- или - 
 <paramref name="method" /> не является методом экземпляра.  
  
-или- 
 Параметр <paramref name="method" /> невозможно привязать, например, потому, что его не удалось найти.</exception>
        <exception cref="T:System.MissingMethodException">Метод <see langword="Invoke" /> для <paramref name="type" /> не найден.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет необходимых разрешений для доступа к <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязки с помощью таких механизмов <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />, как. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type">Тип <see cref="T:System.Type" /> создаваемого делегата.</param>
        <param name="method">Объект <see cref="T:System.Reflection.MethodInfo" />, описывающий статический метод или метод экземпляра, который будет представлен делегатом.</param>
        <param name="throwOnBindFailure">Значение <see langword="true" /> для создания исключения, если метод <paramref name="method" /> привязать невозможно; в противном случае — значение <see langword="false" />.</param>
        <summary>Создает делегат указанного типа, представляющий заданный статический метод, с заданным поведением на случай, если операция связывания завершится неудачей.</summary>
        <returns>Делегат указанного типа, представляющий заданный статический метод.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка метода может создавать делегаты открытых статических методов и делегаты методов открытого экземпляра, т. е. Делегаты, которые предоставляют скрытый первый аргумент методов экземпляра. Подробное описание см. в разделе более общий <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> перегруженный метод, который позволяет создавать все сочетания открытых или закрытых делегатов для экземпляров или статических методов.  
  
> [!NOTE]
>  Этот перегруженный метод следует использовать, когда делегат не закрыт по первому аргументу, так как в этом случае он выполняется несколько быстрее.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для доступа к закрытым методам, если вызывающему объекту был предоставлен <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> флаг, и если набор разрешений неоткрытых методов ограничен набором предоставления вызывающего объекта или подмножеством сочетани. (См. раздел [вопросы безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
## <a name="compatible-parameter-types-and-return-type"></a>Совместимые типы параметров и возвращаемый тип  
 Типы параметров и возвращаемый тип делегата должны быть совместимы с типами параметров и типом возвращаемого значения метода, который представляет делегат. типы не обязательно должны точно совпадать.  
  
> [!NOTE]
>  В .NET Framework версии 1,0 и 1,1 типы должны точно совпадать.  
  
 Если тип параметра делегата является более строгим, чем тип параметра метода, то параметр делегата совместим с соответствующим параметром метода, так как это гарантирует, что аргумент, переданный делегату, может быть безопасно передан методу.  
  
 Аналогичным образом, тип возвращаемого значения делегата совместим с типом возвращаемого значения метода, если тип возвращаемого значения метода является более строгим, чем тип возвращаемого значения делегата, так как это гарантирует, что возвращаемое значение метода может быть безопасно приведено к типу возвращаемого значения делегата.  
  
 Например, делегат <xref:System.Collections.Hashtable> с параметром типа и <xref:System.Object> типом возвращаемого значения может представлять метод с параметром типа <xref:System.Object> и возвращаемым значением типа <xref:System.Collections.Hashtable>.  
  
   
  
## Examples  
 Этот раздел содержит два примера кода. В первом примере показаны два вида делегатов, которые можно создать с помощью этой перегрузки метода: открыть через метод экземпляра и открыть в статическом методе.  
  
 Во втором примере кода демонстрируются совместимые типы параметров и возвращаемые типы.  
  
 **Пример 1**  
  
 В следующем примере кода показаны два способа создания делегата с помощью этой перегрузки <xref:System.Delegate.CreateDelegate%2A> метода.  
  
> [!NOTE]
>  Существует две перегрузки <xref:System.Delegate.CreateDelegate%2A> метода, указывающие, <xref:System.Reflection.MethodInfo> но не первый аргумент; их функциональные возможности одинаковы, за исключением того, что можно указать, следует ли создавать привязку при сбое, а другое всегда создает исключение. В этом примере кода используются обе перегрузки.  
  
 В примере объявляется `C` класс со статическим методом `M2` и методом `M1`экземпляра, а также `C` два типа делегата: `D1` принимает экземпляр и строку и `D2` принимает строку.  
  
 Второй класс с именем `Example` содержит код, создающий делегаты.  
  
-   Делегат типа `D1`, представляющий открытый метод экземпляра, создается для метода `M1`экземпляра. Экземпляр должен передаваться при вызове делегата.  
  
-   Для статического метода `M2`создается `D2`делегат типа, представляющий открытый статический метод.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Пример 2**  
  
 В следующем примере кода демонстрируется совместимость типов параметров и возвращаемых типов.  
  
> [!NOTE]
>  В <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> этом примере кода используется перегрузка метода. Использование других перегрузок, которые принимаются <xref:System.Reflection.MethodInfo> , аналогично.  
  
 В примере кода определяется базовый класс с именем `Base` и `Derived` класс, производный от `Base`. Производный `static` класс имеет метод (`Shared` в Visual Basic) с именем `MyMethod` с одним параметром типа `Base` и типом возвращаемого значения `Derived`. В примере кода также определяется делегат с именем `Example` с одним параметром типа `Derived` и типом возвращаемого значения `Base`.  
  
 В примере кода показано, что для представления `Example` метода `MyMethod`можно использовать делегат с именем. Метод можно привязать к делегату по следующим причинам:  
  
-   Тип`Derived`параметра делегата () более ограничен, чем `MyMethod` тип параметра (`Base`), чтобы всегда быть уверенным `MyMethod`в передаче аргумента делегата.  
  
-   Тип возвращаемого значения `MyMethod` (`Derived`) является более строгой, чем тип параметра делегата (`Base`), чтобы всегда быть уверенным в том, чтобы привести возвращаемый тип метода к возвращаемому типу делегата.  
  
 В примере кода выходные данные не создаются.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="type" /> имеет значение <see langword="null" />.  
  
-или- 
 Свойство <paramref name="method" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> не является производным от <see cref="T:System.MulticastDelegate" />.  
  
- или - 
 <paramref name="type" /> не является объектом типа <see langword="RuntimeType" />. См. статью [Типы среды выполнения в отражении](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
-или- 
 <paramref name="method" /> невозможно привязать, и <paramref name="throwOnBindFailure" /> имеет значение <see langword="true" />.  
  
-или- 
 <paramref name="method" /> не является объектом типа <see langword="RuntimeMethodInfo" />. См. статью [Типы среды выполнения в отражении](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">Метод <see langword="Invoke" /> типа <paramref name="type" /> не найден.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет необходимых разрешений для доступа к <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязки с помощью таких механизмов <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />, как. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type">Тип <see cref="T:System.Type" /> создаваемого делегата.</param>
        <param name="target">Тип <see cref="T:System.Type" />, представляющий класс, в котором реализован метод <paramref name="method" />.</param>
        <param name="method">Имя статического метода, который должен быть представлен делегатом.</param>
        <summary>Создает делегат указанного типа, представляющий заданный статический метод заданного класса.</summary>
        <returns>Делегат указанного типа, представляющий заданный статический метод заданного класса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод создает делегаты только для статических методов. Метод экземпляра — это метод, связанный с экземпляром класса; статический метод — это метод, который связан с самим классом.  
  
 Перегрузка этого <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> метода эквивалентна вызову перегрузки метода, указывающей `true` `false` для `throwOnBindFailure` `ignoreCase` и для.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для доступа к закрытым методам, если вызывающему объекту был предоставлен <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> флаг, и если набор разрешений неоткрытых методов ограничен набором предоставления вызывающего объекта или подмножеством сочетани. (См. раздел [вопросы безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="type" /> имеет значение <see langword="null" />.  
  
- или - 
 Свойство <paramref name="target" /> имеет значение <see langword="null" />.  
  
- или - 
 <paramref name="method" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> не является производным от <see cref="T:System.MulticastDelegate" />.  
  
-или- 
 <paramref name="type" /> не является объектом типа <see langword="RuntimeType" />. См. статью [Типы среды выполнения в отражении](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
- или - 
 <paramref name="target" /> не является объектом <see langword="RuntimeType" />.  
  
-или- 
 Параметр <paramref name="target" /> является открытым универсальным типом. То есть свойство <see cref="P:System.Type.ContainsGenericParameters" /> имеет значение <see langword="true" />.  
  
-или- 
 <paramref name="method" /> не является методом <see langword="static" /> (метод <see langword="Shared" /> в Visual Basic).  
  
- или - 
 Параметр <paramref name="method" /> невозможно привязать, например, потому, что его невозможно найти, а <paramref name="throwOnBindFailure" /> имеет значение <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">Метод <see langword="Invoke" /> для <paramref name="type" /> не найден.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет необходимых разрешений для доступа к <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязки с помощью таких механизмов <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />, как. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="firstArgument" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type">Объект <see cref="T:System.Type" />, представляющий тип создаваемого делегата.</param>
        <param name="firstArgument"><see cref="T:System.Object" />, являющийся первым аргументом метода, представленного делегатом. Для методов экземпляра он должен быть совместим с типом экземпляра.</param>
        <param name="method">Объект <see cref="T:System.Reflection.MethodInfo" />, описывающий статический метод или метод экземпляра, который будет представлен делегатом.</param>
        <param name="throwOnBindFailure">Значение <see langword="true" /> для создания исключения, если метод <paramref name="method" /> невозможно привязать; в противном случае — значение <see langword="false" />.</param>
        <summary>Создает делегат указанного типа, представляющий заданный статический метод или метод экземпляра, с заданным первым аргументом и поведением на случай, если операция связывания завершится неудачей.</summary>
        <returns>Делегат заданного типа, представляющий указанный статический метод или метод экземпляра, либо значение <see langword="null" />, если значение параметра <paramref name="throwOnBindFailure" /> равно <see langword="false" /> и делегат не удалось связать с методом <paramref name="method" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот перегруженный метод и <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> перегрузка метода, которая всегда вызывает сбой при привязке, предоставляют наиболее гибкий способ создания делегатов. Их можно использовать для создания делегатов для статических методов или и без первого аргумента.  
  
> [!NOTE]
>  Если не указать первый аргумент, используйте <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> перегрузку метода для повышения производительности.  
  
 Тип делегата и метод должны иметь совместимые типы возвращаемых значения. То есть тип `method` возвращаемого значения должен быть назначен возвращаемому `type`типу.  
  
 Если `firstArgument` указан аргумент, он `method` передается при каждом вызове делегата; `firstArgument` считается привязанным к делегату, и делегат называется закрытым для своего первого аргумента. Если `method` имеет `static` значение(`Shared` в Visual Basic), список аргументов, предоставленный при вызове делегата, включает все параметры, кроме `method` первого; если является методом экземпляра `firstArgument` , то передается в скрытый экземпляр. параметр (представленный `this` в C#или `Me` в Visual Basic).  
  
 Если `firstArgument` указан аргумент, первый `method` параметр должен быть ссылочным типом и `firstArgument` должен быть совместим с этим типом.  
  
> [!IMPORTANT]
>  Если `method` имеет `firstArgument` <xref:System.ValueType> <xref:System.Object> значение (`Shared` в Visual Basic) и его первый параметр имеет тип или, то может быть типом значения. `static` В этом случае `firstArgument` автоматически упаковывается. Автоматическая упаковка- C# преобразование не выполняется для других аргументов, как в вызове функции или Visual Basic.  
  
 Если `firstArgument` является пустой ссылкой и `method` является методом экземпляра, результат зависит от сигнатур типа `type` делегата и `method`:  
  
-   Если сигнатура `type` явно включает в себя скрытый первый `method`параметр, то говорят, что делегат представляет открытый метод экземпляра. При вызове делегата первый аргумент в списке аргументов передается в параметр `method`скрытого экземпляра.  
  
-   Если сигнатуры `method` и `type` совпадают (то есть все типы параметров совместимы), делегат считается закрытым по пустой ссылке. Вызов делегата аналогичен вызову метода экземпляра для экземпляра со значением NULL, что не особенно полезно для этого.  
  
 Если `firstArgument` параметр является пустой ссылкой и `method` является статическим, результат зависит от сигнатур типа `type` делегата и `method`:  
  
-   Если сигнатура `method` и `type` совпадает (то есть все типы параметров совместимы), делегат называется открытым статическим методом. Это наиболее распространенный случай для статических методов. В этом случае можно получить немного более высокую производительность с помощью <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> перегрузки метода.  
  
-   Если сигнатура `type` начинается со второго `method` параметра, а остальные типы параметров совместимы, то делегат называется закрытым с помощью пустой ссылки. При вызове делегата в первый параметр метода `method`передается пустая ссылка.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для доступа к закрытым методам, если вызывающему объекту был предоставлен <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> флаг, и если набор разрешений неоткрытых методов ограничен набором предоставления вызывающего объекта или подмножеством сочетани. (См. раздел [вопросы безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
## <a name="compatible-parameter-types-and-return-type"></a>Совместимые типы параметров и возвращаемый тип  
 Типы параметров и возвращаемый тип делегата должны быть совместимы с типами параметров и типом возвращаемого значения метода, который представляет делегат. типы не обязательно должны точно совпадать.  
  
> [!NOTE]
>  В .NET Framework версии 1,0 и 1,1 типы должны точно совпадать.  
  
 Если тип параметра делегата является более строгим, чем тип параметра метода, то параметр делегата совместим с соответствующим параметром метода, так как это гарантирует, что аргумент, переданный делегату, может быть безопасно передан методу.  
  
 Аналогичным образом, тип возвращаемого значения делегата совместим с типом возвращаемого значения метода, если тип возвращаемого значения метода является более строгим, чем тип возвращаемого значения делегата, так как это гарантирует, что возвращаемое значение метода может быть безопасно приведено к типу возвращаемого значения делегата.  
  
 Например, делегат <xref:System.Collections.Hashtable> с параметром типа и <xref:System.Object> типом возвращаемого значения может представлять метод с параметром типа <xref:System.Object> и возвращаемым значением типа <xref:System.Collections.Hashtable>.  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>Определение методов, которые может представлять делегат  
 Еще один полезный способ представить гибкость, обеспечиваемую этой перегрузкой <xref:System.Delegate.CreateDelegate%2A> , заключается в том, что любой заданный делегат может представлять четыре различных сочетания сигнатуры и типа метода (статический и экземпляр). Рассмотрим тип `D` делегата с одним аргументом типа `C`. Ниже описаны методы `D` , которые могут представлять, игнорируя возвращаемый тип, так как он должен совпадать во всех случаях:  
  
-   `D`может представлять любой метод экземпляра, имеющий только один аргумент типа `C`, независимо от того, к какому типу относится метод экземпляра. При <xref:System.Delegate.CreateDelegate%2A> `method` вызове метод является экземпляром типа, а получившийся делегат называется закрытым для этого экземпляра. `firstArgument` (Тривиальный элемент `D` также может быть закрыт над пустой ссылкой, если `firstArgument` имеет `null`значение.)  
  
-   `D`может представлять метод `C` экземпляра, не имеющий аргументов. <xref:System.Delegate.CreateDelegate%2A> При`firstArgument` вызове метода является пустой ссылкой. Результирующий делегат представляет открытый метод экземпляра, а экземпляр `C` должен предоставляться каждый раз при вызове метода.  
  
-   `D`может представлять статический метод, который принимает один аргумент типа `C`, и этот метод может принадлежать любому типу. <xref:System.Delegate.CreateDelegate%2A> При`firstArgument` вызове метода является пустой ссылкой. Результирующий делегат представляет открытый статический метод, а экземпляр `C` должен предоставляться каждый раз при вызове метода.  
  
-   `D`может представлять статический метод, принадлежащий типу `F` и имеющий два аргумента типа `F` и типа `C`. При <xref:System.Delegate.CreateDelegate%2A> `F`вызове метод является экземпляром. `firstArgument` Результирующий делегат представляет статический метод, закрытый для этого экземпляра `F`. Обратите внимание, что в `F` случае `C` , когда и относятся к одному и тому же типу, статический метод имеет два аргумента этого типа. (В данном случае закрывается с пустой ссылкой, `D` если `firstArgument` имеет `null`значение.)  
  
   
  
## Examples  
 Этот раздел содержит три примера кода. В первом примере показаны четыре типа делегатов, которые могут быть созданы: закрыто над методом экземпляра, открыто через метод экземпляра, открыто через статический метод и закрыто по статическому методу.  
  
 Во втором примере кода демонстрируются совместимые типы параметров и возвращаемые типы.  
  
 В третьем примере кода определяется один тип делегата и отображаются все методы, которые могут представляться типом делегата.  
  
 **Пример 1**  
  
 В следующем примере кода показаны четыре способа создания делегата с помощью этой перегрузки <xref:System.Delegate.CreateDelegate%2A> метода.  
  
> [!NOTE]
>  Существует две перегрузки <xref:System.Delegate.CreateDelegate%2A> метода, которые задают `firstArgument` и <xref:System.Reflection.MethodInfo>; их функциональные возможности одинаковы, за исключением того, что позволяет указать, следует ли создавать привязку при ошибке, а вторая всегда создает исключение. В этом примере кода используются обе перегрузки.  
  
 В примере объявляется `C` класс со статическим методом `M2` и методом `M1`экземпляра, а также `C` три типа делегата: `D1` принимает экземпляр и строку, `D2` принимает строку и `D3`не имеет аргументов.  
  
 Второй класс с именем `Example` содержит код, создающий делегаты.  
  
-   Делегат типа `D2`, закрытый над `C`экземпляром, создается для метода `M1`экземпляра. Он вызывается с разными строками, чтобы продемонстрировать, что привязанный экземпляр `C` всегда используется.  
  
-   Делегат типа `D1`, представляющий открытый метод экземпляра, создается для метода `M1`экземпляра. Экземпляр должен передаваться при вызове делегата.  
  
-   Для статического метода `M2`создается `D2`делегат типа, представляющий открытый статический метод.  
  
-   Наконец, для статического метода `D3` `M2`создается делегат типа, закрытый над строкой. Метод вызывается, чтобы продемонстрировать, что он использует привязанную строку.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Пример 2**  
  
 В следующем примере кода демонстрируется совместимость типов параметров и возвращаемых типов.  
  
> [!NOTE]
>  В <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> этом примере кода используется перегрузка метода. Использование других перегрузок, которые принимаются <xref:System.Reflection.MethodInfo> , аналогично.  
  
 В примере кода определяется базовый класс с именем `Base` и `Derived` класс, производный от `Base`. Производный `static` класс имеет метод (`Shared` в Visual Basic) с именем `MyMethod` с одним параметром типа `Base` и типом возвращаемого значения `Derived`. В примере кода также определяется делегат с именем `Example` с одним параметром типа `Derived` и типом возвращаемого значения `Base`.  
  
 В примере кода показано, что для представления `Example` метода `MyMethod`можно использовать делегат с именем. Метод можно привязать к делегату по следующим причинам:  
  
-   Тип`Derived`параметра делегата () более ограничен, чем `MyMethod` тип параметра (`Base`), чтобы всегда быть уверенным `MyMethod`в передаче аргумента делегата.  
  
-   Тип возвращаемого значения `MyMethod` (`Derived`) является более строгой, чем тип параметра делегата (`Base`), чтобы всегда быть уверенным в том, чтобы привести возвращаемый тип метода к возвращаемому типу делегата.  
  
 В примере кода выходные данные не создаются.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **Пример 3**  
  
 В следующем примере кода показаны все методы, которые может представлять один тип делегата.  
  
> [!NOTE]
>  Существует две перегрузки <xref:System.Delegate.CreateDelegate%2A> метода, которые задают `firstArgument` и <xref:System.Reflection.MethodInfo>; их функциональные возможности одинаковы, за исключением того, что позволяет указать, следует ли создавать привязку при ошибке, а вторая всегда создает исключение. В этом примере кода используются обе перегрузки.  
  
 В примере кода определяются два класса `C` : `F`и, и тип `D` делегата с одним аргументом `C`типа. Классы имеют совпадающие статические методы и `M1`метод `M3`экземпляра, `M4`, и, `C` а класс также имеет метод `M2` экземпляра, не имеющий аргументов.  
  
 Третий класс с именем `Example` содержит код, создающий делегаты.  
  
-   Делегаты создаются для метода `M1` экземпляра типа `C` и типа `F`, каждый из которых закрыт для экземпляра соответствующего типа. Метод `M1` типа `C` отображает`ID` свойства привязанного экземпляра и аргумента.  
  
-   Делегат создается для метода `M2` типа. `C` Это делегат открытого экземпляра, в котором аргумент делегата представляет собой скрытый первый аргумент в методе экземпляра. Метод не имеет других аргументов.  
  
-   Делегаты создаются для статического метода `M3` типа `C` и типа `F`. это открытые статические делегаты.  
  
-   Наконец, делегаты создаются для статического метода `M4` типа `C` и типа `F`; каждый метод имеет объявляющий тип в качестве первого аргумента и предоставляется экземпляр типа, поэтому делегаты закрываются по первым аргументам. . Метод `M4` типа `C` отображает`ID` свойства привязанного экземпляра и аргумента.  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="type" /> имеет значение <see langword="null" />.  
  
- или - 
 <paramref name="method" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> не является производным от <see cref="T:System.MulticastDelegate" />.  
  
-или- 
 <paramref name="type" /> не является объектом типа <see langword="RuntimeType" />. См. статью [Типы среды выполнения в отражении](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
- или - 
 <paramref name="method" /> невозможно привязать, и <paramref name="throwOnBindFailure" /> имеет значение <see langword="true" />.  
  
- или - 
 <paramref name="method" /> не является объектом типа <see langword="RuntimeMethodInfo" />. См. статью [Типы среды выполнения в отражении](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">Метод <see langword="Invoke" /> типа <paramref name="type" /> не найден.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет необходимых разрешений для доступа к <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязки с помощью таких механизмов <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />, как. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type">Тип <see cref="T:System.Type" /> создаваемого делегата.</param>
        <param name="target">Экземпляр класса, для которого вызывается метод <paramref name="method" />.</param>
        <param name="method">Имя метода экземпляра, который должен быть представлен делегатом.</param>
        <param name="ignoreCase">Логическое значение, указывающее, следует ли учитывать регистр при сравнении имени метода.</param>
        <summary>Создает делегат указанного типа, представляющий заданный метод экземпляра, который вызывается из заданного экземпляра класса с заданной установкой учета регистра.</summary>
        <returns>Создает делегат указанного типа, представляющий заданный метод экземпляра, который вызывается для заданного экземпляра класса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод создает делегаты только для методов экземпляра. Метод экземпляра — это метод, связанный с экземпляром класса; статический метод — это метод, который связан с самим классом.  
  
 Перегрузка этого метода эквивалентна вызову <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> перегрузки метода, задающей `true` для `throwOnBindFailure`.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для доступа к закрытым методам, если вызывающему объекту был предоставлен <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> флаг, и если набор разрешений неоткрытых методов ограничен набором предоставления вызывающего объекта или подмножеством сочетани. (См. раздел [вопросы безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="type" /> имеет значение <see langword="null" />.  
  
- или - 
 Свойство <paramref name="target" /> имеет значение <see langword="null" />.  
  
-или- 
 Свойство <paramref name="method" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> не является производным от <see cref="T:System.MulticastDelegate" />.  
  
-или- 
 <paramref name="type" /> не является объектом типа <see langword="RuntimeType" />. См. статью [Типы среды выполнения в отражении](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
-или- 
 <paramref name="method" /> не является методом экземпляра.  
  
- или - 
 Параметр <paramref name="method" /> невозможно привязать, например, потому, что его не удалось найти.</exception>
        <exception cref="T:System.MissingMethodException">Метод <see langword="Invoke" /> для <paramref name="type" /> не найден.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет необходимых разрешений для доступа к <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязки с помощью таких механизмов <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />, как. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type">Тип <see cref="T:System.Type" /> создаваемого делегата.</param>
        <param name="target">Тип <see cref="T:System.Type" />, представляющий класс, в котором реализован метод <paramref name="method" />.</param>
        <param name="method">Имя статического метода, который должен быть представлен делегатом.</param>
        <param name="ignoreCase">Логическое значение, указывающее, следует ли учитывать регистр при сравнении имени метода.</param>
        <summary>Создает делегат указанного типа, представляющий заданный статический метод заданного класса с заданной установкой учета регистра.</summary>
        <returns>Делегат указанного типа, представляющий заданный статический метод заданного класса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод создает делегаты только для статических методов. Метод экземпляра — это метод, связанный с экземпляром класса; статический метод — это метод, который связан с самим классом.  
  
 Перегрузка этого метода эквивалентна вызову <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> перегрузки метода, задающей `true` для `throwOnBindFailure`.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для доступа к закрытым методам, если вызывающему объекту был предоставлен <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> флаг, и если набор разрешений неоткрытых методов ограничен набором предоставления вызывающего объекта или подмножеством сочетани. (См. раздел [вопросы безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="type" /> имеет значение <see langword="null" />.  
  
-или- 
 Свойство <paramref name="target" /> имеет значение <see langword="null" />.  
  
- или - 
 Свойство <paramref name="method" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> не является производным от <see cref="T:System.MulticastDelegate" />.  
  
- или - 
 <paramref name="type" /> не является объектом типа <see langword="RuntimeType" />. См. статью [Типы среды выполнения в отражении](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
- или - 
 <paramref name="target" /> не является объектом <see langword="RuntimeType" />.  
  
- или - 
 Параметр <paramref name="target" /> является открытым универсальным типом. То есть свойство <see cref="P:System.Type.ContainsGenericParameters" /> имеет значение <see langword="true" />.  
  
- или - 
 <paramref name="method" /> не является методом <see langword="static" /> (метод <see langword="Shared" /> в Visual Basic).  
  
-или- 
 Параметр <paramref name="method" /> невозможно привязать, например, потому, что его не удалось найти.</exception>
        <exception cref="T:System.MissingMethodException">Метод <see langword="Invoke" /> для <paramref name="type" /> не найден.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет необходимых разрешений для доступа к <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязки с помощью таких механизмов <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />, как. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type">Тип <see cref="T:System.Type" /> создаваемого делегата.</param>
        <param name="target">Экземпляр класса, для которого вызывается метод <paramref name="method" />.</param>
        <param name="method">Имя метода экземпляра, который должен быть представлен делегатом.</param>
        <param name="ignoreCase">Логическое значение, указывающее, следует ли учитывать регистр при сравнении имени метода.</param>
        <param name="throwOnBindFailure">Значение <see langword="true" /> для создания исключения, если метод <paramref name="method" /> невозможно привязать; в противном случае — значение <see langword="false" />.</param>
        <summary>Создает делегат указанного типа, представляющий заданный статический метод, вызываемый для заданного экземпляра класса с заданной установкой учета регистра и заданным поведением на случай, если операция связывания завершится неудачей.</summary>
        <returns>Создает делегат указанного типа, представляющий заданный метод экземпляра, который вызывается для заданного экземпляра класса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод создает делегаты только для методов экземпляра. Метод экземпляра — это метод, связанный с экземпляром класса; статический метод — это метод, который связан с самим классом.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для доступа к закрытым методам, если вызывающему объекту был предоставлен <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> флаг, и если набор разрешений неоткрытых методов ограничен набором предоставления вызывающего объекта или подмножеством сочетани. (См. раздел [вопросы безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> — <see langword="null" />.  
  
- или - 
 Свойство <paramref name="target" /> имеет значение <see langword="null" />.  
  
- или - 
 <paramref name="method" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> не является производным от <see cref="T:System.MulticastDelegate" />.  
  
- или - 
 <paramref name="type" /> не является объектом типа <see langword="RuntimeType" />. См. статью [Типы среды выполнения в отражении](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
- или - 
 <paramref name="method" /> не является методом экземпляра.  
  
-или- 
 Параметр <paramref name="method" /> невозможно привязать, например, потому, что его невозможно найти, а <paramref name="throwOnBindFailure" /> имеет значение <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">Метод <see langword="Invoke" /> для <paramref name="type" /> не найден.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет необходимых разрешений для доступа к <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязки с помощью таких механизмов <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />, как. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type">Тип <see cref="T:System.Type" /> создаваемого делегата.</param>
        <param name="target">Тип <see cref="T:System.Type" />, представляющий класс, в котором реализован метод <paramref name="method" />.</param>
        <param name="method">Имя статического метода, который должен быть представлен делегатом.</param>
        <param name="ignoreCase">Логическое значение, указывающее, следует ли учитывать регистр при сравнении имени метода.</param>
        <param name="throwOnBindFailure">Значение <see langword="true" /> для создания исключения, если метод <paramref name="method" /> невозможно привязать; в противном случае — значение <see langword="false" />.</param>
        <summary>Создает делегат заданного типа, представляющий заданный статический метод заданного класса с заданными установками учета регистра и поведением на случай, если операция связывания завершится неудачей.</summary>
        <returns>Делегат указанного типа, представляющий заданный статический метод заданного класса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод создает делегаты только для статических методов. Метод экземпляра — это метод, связанный с экземпляром класса; статический метод — это метод, который связан с самим классом.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для доступа к закрытым методам, если вызывающему объекту был предоставлен <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> флаг, и если набор разрешений неоткрытых методов ограничен набором предоставления вызывающего объекта или подмножеством сочетани. (См. раздел [вопросы безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="type" /> имеет значение <see langword="null" />.  
  
- или - 
 <paramref name="target" /> — <see langword="null" />.  
  
-или- 
 <paramref name="method" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> не является производным от <see cref="T:System.MulticastDelegate" />.  
  
-или- 
 <paramref name="type" /> не является объектом типа <see langword="RuntimeType" />. См. статью [Типы среды выполнения в отражении](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
- или - 
 <paramref name="target" /> не является объектом <see langword="RuntimeType" />.  
  
-или- 
 Параметр <paramref name="target" /> является открытым универсальным типом. То есть свойство <see cref="P:System.Type.ContainsGenericParameters" /> имеет значение <see langword="true" />.  
  
- или - 
 <paramref name="method" /> не является методом <see langword="static" /> (метод <see langword="Shared" /> в Visual Basic).  
  
- или - 
 Параметр <paramref name="method" /> невозможно привязать, например, потому, что его невозможно найти, а <paramref name="throwOnBindFailure" /> имеет значение <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">Метод <see langword="Invoke" /> для <paramref name="type" /> не найден.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет необходимых разрешений для доступа к <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязки с помощью таких механизмов <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />, как. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvoke">
      <MemberSignature Language="C#" Value="public object DynamicInvoke (params object[] args);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object DynamicInvoke(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvoke(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DynamicInvoke (ParamArray args As Object()) As Object" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ DynamicInvoke(... cli::array &lt;System::Object ^&gt; ^ args);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.DynamicInvoke : obj[] -&gt; obj" Usage="delegate.DynamicInvoke args" />
      <MemberSignature Language="C#" Value="public object DynamicInvoke (object[] args);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Function DynamicInvoke (args As Object()) As Object" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ DynamicInvoke(cli::array &lt;System::Object ^&gt; ^ args);" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">Массив объектов, которые передаются в качестве аргументов методу, представленному текущим делегатом.  
  
- или - 
 Значение <see langword="null" />, если метод, представленный текущим делегатом, не требует аргументов.</param>
        <summary>Динамически (с поздней привязкой) вызывает метод, представленный текущим делегатом.</summary>
        <returns>Объект, возвращаемый методом, представленным делегатом.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывает метод <xref:System.Delegate.DynamicInvokeImpl%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Вызывающий объект не имеет доступа к методу, представленному делегатом (например, если метод является закрытым).  
  
- или - 
Количество, порядок или тип параметров в списке <paramref name="args" /> является недопустимым.</exception>
        <exception cref="T:System.ArgumentException">Представленный делегатом метод вызывается для объекта или класса, которые его не поддерживают.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Представленный делегатом метод является методом экземпляра, а целевой объект имеет значение <see langword="null" />.  
  
-или- 
Один из инкапсулированных методов выбрасывает исключение.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязки с помощью таких механизмов <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />, как. Связанное перечисление:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvokeImpl">
      <MemberSignature Language="C#" Value="protected virtual object DynamicInvokeImpl (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object DynamicInvokeImpl(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function DynamicInvokeImpl (args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ DynamicInvokeImpl(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member DynamicInvokeImpl : obj[] -&gt; obj&#xA;override this.DynamicInvokeImpl : obj[] -&gt; obj" Usage="delegate.DynamicInvokeImpl args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="args">Массив объектов, которые передаются в качестве аргументов методу, представленному текущим делегатом.  
  
-или- 
 Значение <see langword="null" />, если метод, представленный текущим делегатом, не требует аргументов.</param>
        <summary>Динамически (с поздней привязкой) вызывает метод, представленный текущим делегатом.</summary>
        <returns>Объект, возвращаемый методом, представленным делегатом.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод реализует метод <xref:System.Delegate.DynamicInvoke%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Вызывающий объект не имеет доступа к методу, представленному делегатом (например, если метод является закрытым).  
  
- или - 
Количество, порядок или тип параметров в списке <paramref name="args" /> является недопустимым.</exception>
        <exception cref="T:System.ArgumentException">Представленный делегатом метод вызывается для объекта или класса, которые его не поддерживают.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Представленный делегатом метод является методом экземпляра, а целевой объект имеет значение <see langword="null" />.  
  
- или - 
Один из инкапсулированных методов выбрасывает исключение.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязки с помощью таких механизмов <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />, как. Связанное перечисление:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.DynamicInvoke(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="delegate.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, который требуется сравнить с текущим делегатом.</param>
        <summary>Определяет, принадлежат ли заданный объект и текущий делегат к одному типу, и одинаковы ли их целевые объекты, методы и списки вызовов.</summary>
        <returns>Значение <see langword="true" />, если <paramref name="obj" /> и текущий делегат имеют одинаковые целевые объекты, методы и списки вызовов. В противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если два делегата имеют разные типы, они не считаются равными.  
  
> [!IMPORTANT]
>  В .NET Framework версии 1,0 и 1,1 два делегата считаются равными, если их цели, методы и список вызовов равны, даже если делегаты имеют разные типы.  
  
 Методы и целевые объекты сравниваются на равенство следующим образом:  
  
-   Если два сравниваемых метода являются статическими и одинаковы для одного и того же класса, то методы считаются равными, а целевые объекты также считаются равными.  
  
-   Если два сравниваемых метода являются методами экземпляра и одинаковы для одного и того же объекта, то методы считаются равными, а целевые объекты также считаются равными.  
  
-   В противном случае методы не считаются равными, а целевые объекты также не считаются равными.  
  
 Два списка вызовов считаются идентичными только в том случае, если они имеют одинаковый порядок, а соответствующие элементы из двух списков представляют один и тот же метод и целевой объект.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Вызывающий объект не имеет доступа к методу, представленному делегатом (например, если метод является закрытым).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязки с помощью таких механизмов <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />, как. Связанное перечисление:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="delegate.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает хэш-код делегата.</summary>
        <returns>Хэш-код делегата.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращаемое значение этого метода не должно сохраняться по двум причинам. Во-первых, функция хэширования класса может быть изменена для более эффективного распределения, что позволяет выдавать любые значения из старой хэш-функции. Во-вторых, реализация по умолчанию этого класса не гарантирует, что одно и то же значение будет возвращаться разными экземплярами.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязки с помощью таких механизмов <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />, как. Связанное перечисление:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetInvocationList">
      <MemberSignature Language="C#" Value="public virtual Delegate[] GetInvocationList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Delegate[] GetInvocationList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetInvocationList" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInvocationList () As Delegate()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Delegate ^&gt; ^ GetInvocationList();" />
      <MemberSignature Language="F#" Value="abstract member GetInvocationList : unit -&gt; Delegate[]&#xA;override this.GetInvocationList : unit -&gt; Delegate[]" Usage="delegate.GetInvocationList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает список вызовов делегата.</summary>
        <returns>Массив делегатов, представляющих список вызовов текущего делегата.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждый делегат в массиве представляет ровно один метод.  
  
 Порядок делегатов в массиве совпадает с порядком, в котором текущий делегат вызывает методы, которые представляют эти делегаты.  
  
   
  
## Examples  
 В следующем примере для делегата назначается три метода. Затем он вызывает <xref:System.Delegate.GetInvocationList%2A> метод для получения общего числа методов, назначенных делегату, для выполнения делегатов в обратном порядке и для выполнения методов, имя которых не включает в себя подстроку "File".  
  
 [!code-csharp[System.Delegate.GetInvocationList#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/cs/GetInvocationList1.cs#1)]
 [!code-vb[System.Delegate.GetInvocationList#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/vb/GetInvocationList1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязки с помощью таких механизмов <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />, как. Связанное перечисление:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetMethodImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetMethodImpl () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : unit -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : unit -&gt; System.Reflection.MethodInfo" Usage="delegate.GetMethodImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает статический метод, представленный текущим делегатом.</summary>
        <returns><see cref="T:System.Reflection.MethodInfo" />, описывающий статический метод, представленный текущим делегатом.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод применяется только в том случае, если текущий делегат представляет статический метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Вызывающий объект не имеет доступа к методу, представленному делегатом (например, если метод является закрытым).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязки с помощью таких механизмов <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />, как. Связанное перечисление:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Delegate.Method" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="delegate.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info">Не поддерживается.</param>
        <param name="context">Не поддерживается.</param>
        <summary>Не поддерживается.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Этот метод не поддерживается.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo Method { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo Method" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Method" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Method As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodInfo ^ Method { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Method : System.Reflection.MethodInfo" Usage="System.Delegate.Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает метод, представленный делегатом.</summary>
        <value>Объект <see cref="T:System.Reflection.MethodInfo" />, описывающий метод, представленный делегатом.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.MemberAccessException">Вызывающий объект не имеет доступа к методу, представленному делегатом (например, если метод является закрытым).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязки с помощью таких механизмов <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />, как. Связанное перечисление:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Delegate.GetMethodImpl" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Delegate * Delegate -&gt; bool" Usage="d1 = d2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">Первый делегат для операции сравнения.</param>
        <param name="d2">Второй делегат для операции сравнения.</param>
        <summary>Определяет, равны ли два заданных делегата.</summary>
        <returns><see langword="true" />, если значения параметров <paramref name="d1" /> и <paramref name="d2" /> равны; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Два делегата одного типа с одинаковыми целевыми объектами, методами и списками вызовов считаются равными.  
  
 Если два делегата имеют разные типы, они не считаются равными.  
  
> [!IMPORTANT]
>  В .NET Framework версии 1,0 и 1,1 два делегата считаются равными, если их цели, методы и список вызовов равны, даже если делегаты имеют разные типы.  
  
 Методы и целевые объекты сравниваются на равенство следующим образом:  
  
-   Если два сравниваемых метода являются статическими и одинаковы для одного и того же класса, то методы считаются равными, а целевые объекты также считаются равными.  
  
-   Если два сравниваемых метода являются методами экземпляра и одинаковы для одного и того же объекта, то методы считаются равными, а целевые объекты также считаются равными.  
  
-   В противном случае методы не считаются равными, а целевые объекты также не считаются равными.  
  
 Два списка вызовов считаются идентичными, если они имеют одинаковый порядок, а соответствующие элементы из двух списков представляют один и тот же метод и целевой объект.  
  
 Эквивалентным методом для этого оператора является<xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязки с помощью таких механизмов <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />, как. Связанное перечисление:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Delegate * Delegate -&gt; bool" Usage="System.Delegate.op_Inequality (d1, d2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">Первый делегат для операции сравнения.</param>
        <param name="d2">Второй делегат для операции сравнения.</param>
        <summary>Определяет, являются ли заданные делегаты неравными.</summary>
        <returns><see langword="true" />, если значения <paramref name="d1" /> и <paramref name="d2" /> не равны; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Два делегата считаются неравными, если они относятся к разным типам или имеют разные методы, разные целевые объекты или разные списки вызовов.  
  
 Если два делегата имеют разные типы, они не считаются равными.  
  
> [!IMPORTANT]
>  В .NET Framework версии 1,0 и 1,1 два делегата считаются равными, если их цели, методы и список вызовов равны, даже если делегаты относятся к разным типам.  
  
 Методы и целевые объекты сравниваются на равенство следующим образом:  
  
-   Если два сравниваемых метода являются статическими и одинаковы для одного и того же класса, то методы считаются равными, а целевые объекты также считаются равными.  
  
-   Если два сравниваемых метода являются методами экземпляра и одинаковы для одного и того же объекта, то методы считаются равными, а целевые объекты также считаются равными.  
  
-   В противном случае методы не считаются равными, а целевые объекты также не считаются равными.  
  
 Два списка вызовов не равны, если они имеют разные размеры, если они упорядочены по-разному, или если хотя бы один элемент из одного списка представляет метод или целевой объект, отличный от того, который представлен соответствующим элементом в другом списке.  
  
 Эквивалентным методом для этого оператора является<xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязки с помощью таких механизмов <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />, как. Связанное перечисление:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public static Delegate Remove (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Remove(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remove (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Remove(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member Remove : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Remove (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">Делегат, из списка вызовов которого необходимо удалить список вызовов <paramref name="value" />.</param>
        <param name="value">Делегат, представляющий список вызовов, который необходимо удалить из списка вызовов <paramref name="source" />.</param>
        <summary>Удаляет последнее вхождение списка вызовов делегата из списка вызовов другого делегата.</summary>
        <returns>Новый делегат со списком вызовов, сформированным путем удаления из <paramref name="source" /> последнего вхождения списка вызовов <paramref name="value" />, если список вызовов <paramref name="value" /> найден в списке вызовов <paramref name="source" />. Возвращает <paramref name="source" />, если <paramref name="value" /> имеет значение <see langword="null" /> либо список вызовов <paramref name="value" /> не найден в списке вызовов <paramref name="source" />. Возвращает пустую ссылку, если список вызовов <paramref name="value" /> равен списку вызовов <paramref name="source" /> либо <paramref name="source" /> является пустой ссылкой.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если список `value` вызовов соответствует непрерывному набору элементов в `source`списке вызовов, то `value` в списке вызовов, о котором говорится, возникает `source`список вызовов. Если список `value` вызовов встречается более одного раза в `source`списке вызовов, Последнее вхождение удаляется.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Вызывающий объект не имеет доступа к методу, представленному делегатом (например, если метод является закрытым).</exception>
        <exception cref="T:System.ArgumentException">Типы делегатов не совпадают.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязки с помощью таких механизмов <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />, как. Связанное перечисление:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public static Delegate RemoveAll (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate RemoveAll(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RemoveAll (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ RemoveAll(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member RemoveAll : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.RemoveAll (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">Делегат, из списка вызовов которого необходимо удалить список вызовов <paramref name="value" />.</param>
        <param name="value">Делегат, представляющий список вызовов, который необходимо удалить из списка вызовов <paramref name="source" />.</param>
        <summary>Удаляет все вхождения списка вызовов одного делегата из списка вызовов другого делегата.</summary>
        <returns>Новый делегат со списком вызовов, сформированным путем удаления из списка вызовов <paramref name="source" /> всех вхождений списка вызовов <paramref name="value" />, если список вызовов <paramref name="value" /> найден в списке вызовов <paramref name="source" />. Возвращает <paramref name="source" />, если <paramref name="value" /> имеет значение <see langword="null" /> либо список вызовов <paramref name="value" /> не найден в списке вызовов <paramref name="source" />. Возвращает пустую ссылку, если список вызовов <paramref name="value" /> равен списку вызовов <paramref name="source" />, либо список вызовов <paramref name="source" /> содержит только списки вызовов <paramref name="value" />, либо <paramref name="source" /> является пустой ссылкой.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если список `value` вызовов соответствует непрерывному набору элементов в `source`списке вызовов, то `value` в списке вызовов, о котором говорится, возникает `source`список вызовов. Если список `value` вызовов встречается несколько раз в `source`списке вызовов, все вхождения удаляются.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Вызывающий объект не имеет доступа к методу, представленному делегатом (например, если метод является закрытым).</exception>
        <exception cref="T:System.ArgumentException">Типы делегатов не совпадают.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязки с помощью таких механизмов <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />, как. Связанное перечисление:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate RemoveImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate RemoveImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function RemoveImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ RemoveImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member RemoveImpl : Delegate -&gt; Delegate&#xA;override this.RemoveImpl : Delegate -&gt; Delegate" Usage="delegate.RemoveImpl d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="d">Делегат, представляющий список вызовов, который необходимо удалить из списка вызовов текущего делегата.</param>
        <summary>Удаляет список вызовов одного делегата из списка вызовов другого делегата.</summary>
        <returns>Новый делегат со списком вызовов, сформированным удаления списка вызовов <paramref name="value" /> из списка вызовов текущего делегата, если список вызовов <paramref name="value" /> найден в списке вызовов текущего делегата. Возвращает текущий делегат, если <paramref name="value" /> имеет значение <see langword="null" /> или список вызовов <paramref name="value" /> не найден в списке вызовов текущего делегата. Возвращает <see langword="null" />, если список вызовов <paramref name="value" /> равен списку вызовов текущего делегата.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если список `value` вызовов соответствует непрерывному набору элементов в списке вызовов текущего делегата, то в списке вызовов текущего делегата `value` будет стоять список вызовов. Если список `value` вызовов встречается более одного раза в списке вызовов текущего делегата, Последнее вхождение удаляется.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Вызывающий объект не имеет доступа к методу, представленному делегатом (например, если метод является закрытым).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязки с помощью таких механизмов <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />, как. Связанное перечисление:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Target">
      <MemberSignature Language="C#" Value="public object Target { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Target" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Target" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Target As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Target { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Target : obj" Usage="System.Delegate.Target" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает экземпляр класса, метод которого вызывает текущий делегат.</summary>
        <value>Объект, для которого текущий делегат вызывает метод экземпляра, если делегат представляет метод экземпляра, либо <see langword="null" /> если делегат представляет статический метод.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод экземпляра — это метод, связанный с экземпляром класса; статический метод — это метод, который связан с самим классом.  
  
 Если делегат вызывает один или несколько методов экземпляра, это свойство возвращает целевой объект последнего метода экземпляра в списке вызовов.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязки с помощью таких механизмов <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />, как. Связанное перечисление:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>
