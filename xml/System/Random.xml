<Type Name="Random" FullName="System.Random">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a5d099662a51c9ac6e434b6e8eb94d1a73c68700" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69419506" /></Metadata><TypeSignature Language="C#" Value="public class Random" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Random extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Random" />
  <TypeSignature Language="VB.NET" Value="Public Class Random" />
  <TypeSignature Language="C++ CLI" Value="public ref class Random" />
  <TypeSignature Language="F#" Value="type Random = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="28b3c-101">Представляет генератор псевдослучайных чисел, то есть устройство, которое выдает последовательность чисел, отвечающую определенным статистическим критериям случайности.</span><span class="sxs-lookup"><span data-stu-id="28b3c-101">Represents a pseudo-random number generator, which is a device that produces a sequence of numbers that meet certain statistical requirements for randomness.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28b3c-102">Псевдо-случайные числа выбираются с равной вероятностью из конечного набора чисел.</span><span class="sxs-lookup"><span data-stu-id="28b3c-102">Pseudo-random numbers are chosen with equal probability from a finite set of numbers.</span></span> <span data-ttu-id="28b3c-103">Выбранные числа не являются полностью случайными, поскольку для их выбора используется математический алгоритм, но они достаточно случайные для практических целей.</span><span class="sxs-lookup"><span data-stu-id="28b3c-103">The chosen numbers are not completely random because a mathematical algorithm is used to select them, but they are sufficiently random for practical purposes.</span></span> <span data-ttu-id="28b3c-104">Текущая реализация <xref:System.Random> класса основана на измененной версии алгоритма генератора случайных чисел Дональд E. кнута с вычитанием.</span><span class="sxs-lookup"><span data-stu-id="28b3c-104">The current implementation of the <xref:System.Random> class is based on a modified version of Donald E. Knuth's subtractive random number generator algorithm.</span></span> <span data-ttu-id="28b3c-105">Дополнительные сведения см. в разделе D. E.</span><span class="sxs-lookup"><span data-stu-id="28b3c-105">For more information, see D. E.</span></span> <span data-ttu-id="28b3c-106">Кнута.</span><span class="sxs-lookup"><span data-stu-id="28b3c-106">Knuth.</span></span> <span data-ttu-id="28b3c-107">*Искусство компьютерной программирования, том 2: Алгоритмы*семинумерикал.</span><span class="sxs-lookup"><span data-stu-id="28b3c-107">*The Art of Computer Programming, Volume 2: Seminumerical Algorithms*.</span></span> <span data-ttu-id="28b3c-108">Addison-Wesley, чтение, MA, третий выпуск, 1997.</span><span class="sxs-lookup"><span data-stu-id="28b3c-108">Addison-Wesley, Reading, MA, third edition, 1997.</span></span>  
  
 <span data-ttu-id="28b3c-109">Чтобы создать криптографически защищенное случайное число, например подходящее для создания случайного пароля, используйте <xref:System.Security.Cryptography.RNGCryptoServiceProvider> класс или наследует класс от. <xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="28b3c-109">To generate a cryptographically secure random number, such as one that's suitable for creating a random password, use the <xref:System.Security.Cryptography.RNGCryptoServiceProvider> class or derive a class from <xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="28b3c-110">В этом разделе.</span><span class="sxs-lookup"><span data-stu-id="28b3c-110">In this topic:</span></span>  
  
 <span data-ttu-id="28b3c-111">[Создание экземпляра генератора случайных чисел](#Instantiate) </span><span class="sxs-lookup"><span data-stu-id="28b3c-111">[Instantiating the random number generator](#Instantiate) </span></span>  
 <span data-ttu-id="28b3c-112">[Предотвращение нескольких экземпляров](#Multiple) </span><span class="sxs-lookup"><span data-stu-id="28b3c-112">[Avoiding multiple instantiations](#Multiple) </span></span>  
 <span data-ttu-id="28b3c-113">[Класс System. Random и безопасность потоков](#ThreadSafety) </span><span class="sxs-lookup"><span data-stu-id="28b3c-113">[The System.Random class and thread safety](#ThreadSafety) </span></span>  
 <span data-ttu-id="28b3c-114">[Создание различных типов случайных чисел](#Functionality) </span><span class="sxs-lookup"><span data-stu-id="28b3c-114">[Generating different types of random numbers](#Functionality) </span></span>  
 <span data-ttu-id="28b3c-115">[Замена собственного алгоритма](#Overriding) </span><span class="sxs-lookup"><span data-stu-id="28b3c-115">[Substituting your own algorithm](#Overriding) </span></span>  
 <span data-ttu-id="28b3c-116">[Как использовать System. Random to...](#Operations) </span><span class="sxs-lookup"><span data-stu-id="28b3c-116">[How do you use System.Random to…](#Operations) </span></span>  
 [<span data-ttu-id="28b3c-117">Получение той же последовательности случайных значений</span><span class="sxs-lookup"><span data-stu-id="28b3c-117">Retrieve the same sequence of random values</span></span>](#Same)  
 [<span data-ttu-id="28b3c-118">Получение уникальных последовательностей случайных значений</span><span class="sxs-lookup"><span data-stu-id="28b3c-118">Retrieve unique sequences of random values</span></span>](#Unique)  
 [<span data-ttu-id="28b3c-119">Получение целых чисел в указанном диапазоне</span><span class="sxs-lookup"><span data-stu-id="28b3c-119">Retrieve integers in a specified range</span></span>](#Range)  
 [<span data-ttu-id="28b3c-120">Получение целых чисел с указанным числом цифр</span><span class="sxs-lookup"><span data-stu-id="28b3c-120">Retrieve integers with a specified number of digits</span></span>](#Digits)  
 [<span data-ttu-id="28b3c-121">Получение значений с плавающей запятой в указанном диапазоне</span><span class="sxs-lookup"><span data-stu-id="28b3c-121">Retrieve floating-point values in a specified range</span></span>](#Floats)  
 [<span data-ttu-id="28b3c-122">Создание случайных логических значений</span><span class="sxs-lookup"><span data-stu-id="28b3c-122">Generate random Boolean values</span></span>](#Boolean)  
 [<span data-ttu-id="28b3c-123">Создавать случайные 64-разрядные целые числа</span><span class="sxs-lookup"><span data-stu-id="28b3c-123">Generate random 64-bit integers</span></span>](#Long)  
 [<span data-ttu-id="28b3c-124">Извлечение байтов в указанном диапазоне</span><span class="sxs-lookup"><span data-stu-id="28b3c-124">Retrieve bytes in a specified range</span></span>](#Bytes)  
 [<span data-ttu-id="28b3c-125">Извлечение элемента из массива или коллекции в случайном порядке</span><span class="sxs-lookup"><span data-stu-id="28b3c-125">Retrieve an element from an array or collection at random</span></span>](#Array)  
 [<span data-ttu-id="28b3c-126">Извлечение уникального элемента из массива или коллекции</span><span class="sxs-lookup"><span data-stu-id="28b3c-126">Retrieve a unique element from an array or collection</span></span>](#UniqueArray)  
  
<a name="Instantiate"></a>   
## <a name="instantiating-the-random-number-generator"></a><span data-ttu-id="28b3c-127">Создание экземпляра генератора случайных чисел</span><span class="sxs-lookup"><span data-stu-id="28b3c-127">Instantiating the random number generator</span></span>  
 <span data-ttu-id="28b3c-128">Чтобы создать экземпляр генератора случайных чисел, укажите начальное значение (начальное значение для алгоритма формирования псевдо-случайных чисел) конструктору <xref:System.Random.%23ctor%2A> класса.</span><span class="sxs-lookup"><span data-stu-id="28b3c-128">You instantiate the random number generator by providing a seed value (a starting value for the pseudo-random number generation algorithm) to a <xref:System.Random.%23ctor%2A> class constructor.</span></span>  <span data-ttu-id="28b3c-129">Начальное значение можно указать явно или неявно:</span><span class="sxs-lookup"><span data-stu-id="28b3c-129">You can supply the seed value either explicitly or implicitly:</span></span>  
  
-   <span data-ttu-id="28b3c-130"><xref:System.Random.%23ctor%28System.Int32%29> Конструктор использует явно указываемое начальное значение.</span><span class="sxs-lookup"><span data-stu-id="28b3c-130">The <xref:System.Random.%23ctor%28System.Int32%29> constructor uses an explicit seed value that you supply.</span></span>  
  
-   <span data-ttu-id="28b3c-131">Для предоставления начального значения конструкториспользуетсистемныечасы.<xref:System.Random.%23ctor></span><span class="sxs-lookup"><span data-stu-id="28b3c-131">The <xref:System.Random.%23ctor> constructor uses the system clock to provide a seed value.</span></span> <span data-ttu-id="28b3c-132">Это наиболее распространенный способ создания экземпляра генератора случайных чисел.</span><span class="sxs-lookup"><span data-stu-id="28b3c-132">This is the most common way of instantiating the random number generator.</span></span>  
  
 <span data-ttu-id="28b3c-133">Если для отдельных <xref:System.Random> объектов используется одно и то же начальное значение, они будут создавать одинаковые ряды случайных чисел.</span><span class="sxs-lookup"><span data-stu-id="28b3c-133">If the same seed is used for separate <xref:System.Random> objects, they will generate the same series of random numbers.</span></span> <span data-ttu-id="28b3c-134">Это может быть полезно для создания набора тестов, который обрабатывает случайные значения или для воспроизведения игр, которые наследуют данные от случайных чисел.</span><span class="sxs-lookup"><span data-stu-id="28b3c-134">This can be useful for creating a test suite that processes random values, or for replaying games that derive their data from random numbers.</span></span> <span data-ttu-id="28b3c-135">Однако обратите внимание <xref:System.Random> , что объекты в процессах, выполняющихся в разных версиях .NET Framework, могут возвращать разные серии случайных чисел, даже если они создаются с одинаковыми начальными значениями.</span><span class="sxs-lookup"><span data-stu-id="28b3c-135">However, note that <xref:System.Random> objects in processes running under different versions of the .NET Framework may return different series of random numbers even if they're instantiated with identical seed values.</span></span>  
  
 <span data-ttu-id="28b3c-136">Для создания различных последовательностей случайных чисел можно сделать начальное значение зависимым от времени, тем самым создавая другой ряд с каждым новым экземпляром <xref:System.Random>.</span><span class="sxs-lookup"><span data-stu-id="28b3c-136">To produce different sequences of random numbers, you can make the seed value time-dependent, thereby producing a different series with each new instance of <xref:System.Random>.</span></span> <span data-ttu-id="28b3c-137">Параметризованный <xref:System.Random.%23ctor%28System.Int32%29> конструктор может <xref:System.Int32> принимать значение на основе числа тактов в текущем времени, <xref:System.Random.%23ctor> тогда как конструктор без параметров использует системные часы для создания начального значения.</span><span class="sxs-lookup"><span data-stu-id="28b3c-137">The parameterized <xref:System.Random.%23ctor%28System.Int32%29> constructor can take an <xref:System.Int32> value based on the number of ticks in the current time, whereas the parameterless <xref:System.Random.%23ctor> constructor uses the system clock to generate its seed value.</span></span> <span data-ttu-id="28b3c-138">Однако, поскольку часы имеют конечное разрешение, использование конструктора без параметров для создания различных <xref:System.Random> объектов в случае закрытия завершает создание генераторов случайных чисел, создающих идентичные последовательности случайных чисел.</span><span class="sxs-lookup"><span data-stu-id="28b3c-138">However, because the clock has finite resolution, using the parameterless constructor to create different <xref:System.Random> objects in close succession creates random number generators that produce identical sequences of random numbers.</span></span> <span data-ttu-id="28b3c-139">В следующем примере показано, как <xref:System.Random> два объекта, создаваемые при закрытии, формируют идентичные последовательности случайных чисел.</span><span class="sxs-lookup"><span data-stu-id="28b3c-139">The following example illustrates how two <xref:System.Random> objects that are instantiated in close succession generate an identical series of random numbers.</span></span> <span data-ttu-id="28b3c-140">В большинстве систем Windows объекты <xref:System.Random> , созданные в течение 15 миллисекунд, могут иметь одинаковые начальные значения.</span><span class="sxs-lookup"><span data-stu-id="28b3c-140">On most Windows systems, <xref:System.Random> objects created within 15 milliseconds of one another are likely to have identical seed values.</span></span>  
  
 [!code-cpp[System.Random#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random1.cpp#1)]
 [!code-csharp[System.Random#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random1.cs#1)]
 [!code-vb[System.Random#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random1.vb#1)]  
  
 <span data-ttu-id="28b3c-141">Чтобы избежать этой проблемы, создайте один <xref:System.Random> объект, а не несколько объектов.</span><span class="sxs-lookup"><span data-stu-id="28b3c-141">To avoid this problem, create a single <xref:System.Random> object instead of multiple objects.</span></span>  
  
<a name="Multiple"></a>   
## <a name="avoiding-multiple-instantiations"></a><span data-ttu-id="28b3c-142">Предотвращение нескольких экземпляров</span><span class="sxs-lookup"><span data-stu-id="28b3c-142">Avoiding multiple instantiations</span></span>  
 <span data-ttu-id="28b3c-143">Инициализация двух генераторов случайных чисел в тесном цикле или при быстром выполнении создает два генератора случайных чисел, которые могут формировать идентичные последовательности случайных чисел.</span><span class="sxs-lookup"><span data-stu-id="28b3c-143">Initializing two random number generators in a tight loop or in rapid succession creates two random number generators that can produce identical sequences of random numbers.</span></span> <span data-ttu-id="28b3c-144">В большинстве случаев это не является намерением разработчика и может привести к проблемам с производительностью, поскольку создание и инициализация генератора случайных чисел является сравнительно дорогостоящим процессом.</span><span class="sxs-lookup"><span data-stu-id="28b3c-144">In most cases, this is not the developer's intent and can lead to performance issues, because instantiating and initializing a random number generator is a relatively expensive process.</span></span>  
  
 <span data-ttu-id="28b3c-145">Чтобы повысить производительность и избежать случайного создания отдельных генераторов случайных чисел, создающих идентичные числовые последовательности, рекомендуется создать один <xref:System.Random> объект для создания множества случайных чисел с течением времени, а не создавать новые <xref:System.Random> объекты для создания одного случайного числа.</span><span class="sxs-lookup"><span data-stu-id="28b3c-145">Both to improve performance and to avoid inadvertently creating separate random number generators that generate identical numeric sequences, we recommend that you create one <xref:System.Random> object to generate many random numbers over time, instead of creating new <xref:System.Random> objects to generate one random number.</span></span>  
  
 <span data-ttu-id="28b3c-146"><xref:System.Random> Однако класс не является потокобезопасным.</span><span class="sxs-lookup"><span data-stu-id="28b3c-146">However, the <xref:System.Random> class isn't thread safe.</span></span> <span data-ttu-id="28b3c-147">При вызове <xref:System.Random> методов из нескольких потоков следуйте рекомендациям, изложенным в следующем разделе.</span><span class="sxs-lookup"><span data-stu-id="28b3c-147">If you call <xref:System.Random> methods from multiple threads, follow the guidelines discussed in the next section.</span></span>  
  
<a name="ThreadSafety"></a>   
## <a name="the-systemrandom-class-and-thread-safety"></a><span data-ttu-id="28b3c-148">Класс System. Random и безопасность потоков</span><span class="sxs-lookup"><span data-stu-id="28b3c-148">The System.Random class and thread safety</span></span>  
 <span data-ttu-id="28b3c-149">Вместо создания экземпляров отдельных <xref:System.Random> объектов рекомендуется создать один <xref:System.Random> экземпляр для создания всех случайных чисел, необходимых для приложения.</span><span class="sxs-lookup"><span data-stu-id="28b3c-149">Instead of instantiating individual <xref:System.Random> objects, we recommend that you create a single <xref:System.Random> instance to generate all the random numbers needed by your app.</span></span> <span data-ttu-id="28b3c-150"><xref:System.Random> Однако объекты не являются потокобезопасными.</span><span class="sxs-lookup"><span data-stu-id="28b3c-150">However, <xref:System.Random> objects are not thread safe.</span></span> <span data-ttu-id="28b3c-151">Если приложение вызывает <xref:System.Random> методы из нескольких потоков, необходимо использовать объект синхронизации, чтобы убедиться, что только один поток может одновременно получить доступ к генератору случайных чисел.</span><span class="sxs-lookup"><span data-stu-id="28b3c-151">If your app calls <xref:System.Random> methods from multiple threads, you must use a synchronization object to ensure that only one thread can access the random number generator at a time.</span></span> <span data-ttu-id="28b3c-152">Если не гарантировать, что <xref:System.Random> доступ к объекту осуществляется потокобезопасным способом, вызовы методов, возвращающих случайные числа, возвращают 0.</span><span class="sxs-lookup"><span data-stu-id="28b3c-152">If you don't ensure that the <xref:System.Random> object is accessed in a thread-safe way, calls to methods that return random numbers return 0.</span></span>  
  
 <span data-ttu-id="28b3c-153">В следующем примере используется C# [оператор lock](~/docs/csharp/language-reference/keywords/lock-statement.md) и [оператор Visual Basic SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) , чтобы гарантировать, что один генератор случайных чисел обращается к 11 потокам потокобезопасным образом.</span><span class="sxs-lookup"><span data-stu-id="28b3c-153">The following example uses the C# [lock Statement](~/docs/csharp/language-reference/keywords/lock-statement.md) and the Visual Basic [SyncLock statement](~/docs/visual-basic/language-reference/statements/synclock-statement.md) to ensure that a single random number generator is accessed by 11 threads in a thread-safe manner.</span></span> <span data-ttu-id="28b3c-154">Каждый поток создает 2 000 000 случайных чисел, подсчитывает количество создаваемых случайных чисел и вычисляет их сумму, а затем обновляет итоги для всех потоков после завершения выполнения.</span><span class="sxs-lookup"><span data-stu-id="28b3c-154">Each thread generates 2 million random numbers, counts the number of random numbers generated and calculates their sum, and then updates the totals for all threads when it finishes executing.</span></span>  
  
 [!code-cpp[System.Random#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/threadsafeex1.cpp#3)]
 [!code-csharp[System.Random#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex1.cs#3)]
 [!code-vb[System.Random#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex1.vb#3)]  
  
 <span data-ttu-id="28b3c-155">В примере безопасность потоков обеспечивается следующими способами.</span><span class="sxs-lookup"><span data-stu-id="28b3c-155">The example ensures thread-safety in the following ways:</span></span>  
  
-   <span data-ttu-id="28b3c-156"><xref:System.ThreadStaticAttribute> Атрибут используется для определения локальных переменных потока, которые отправляют общее число формируемых случайных чисел и их сумму для каждого потока.</span><span class="sxs-lookup"><span data-stu-id="28b3c-156">The <xref:System.ThreadStaticAttribute> attribute is used to define thread-local variables that track the total number of random numbers generated and their sum for each thread.</span></span>  
  
-   <span data-ttu-id="28b3c-157">Блокировка ( `lock` оператор в C# и `SyncLock` оператор в Visual Basic) обеспечивает защиту доступа к переменным для общего количества и суммирования всех случайных чисел, созданных во всех потоках.</span><span class="sxs-lookup"><span data-stu-id="28b3c-157">A lock (the `lock` statement in C# and the `SyncLock` statement in Visual Basic) protects access to the variables for the total count and sum of all random numbers generated on all threads.</span></span>  
  
-   <span data-ttu-id="28b3c-158">Семафор ( <xref:System.Threading.CountdownEvent> объект) используется, чтобы обеспечить блокировку основного потока до завершения выполнения всех остальных потоков.</span><span class="sxs-lookup"><span data-stu-id="28b3c-158">A semaphore (the <xref:System.Threading.CountdownEvent> object) is used to ensure that the main thread blocks until all other threads complete execution.</span></span>  
  
-   <span data-ttu-id="28b3c-159">В примере проверяется, поврежден ли генератор случайных чисел, путем определения, будут ли два последовательных вызова методов генерации случайных чисел возвращать 0.</span><span class="sxs-lookup"><span data-stu-id="28b3c-159">The example checks whether the random number generator has become corrupted by determining whether two consecutive calls to random number generation methods return 0.</span></span> <span data-ttu-id="28b3c-160">Если обнаружено повреждение, в примере используется <xref:System.Threading.CancellationTokenSource> объект для сигнализации о том, что все потоки должны быть отменены.</span><span class="sxs-lookup"><span data-stu-id="28b3c-160">If corruption is detected, the example uses the <xref:System.Threading.CancellationTokenSource> object to signal that all threads should be canceled.</span></span>  
  
-   <span data-ttu-id="28b3c-161">Перед созданием каждого случайного числа каждый поток проверяет состояние <xref:System.Threading.CancellationToken> объекта.</span><span class="sxs-lookup"><span data-stu-id="28b3c-161">Before generating each random number, each thread checks the state of the <xref:System.Threading.CancellationToken> object.</span></span> <span data-ttu-id="28b3c-162">При запросе отмены в примере вызывается <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> метод для отмены потока.</span><span class="sxs-lookup"><span data-stu-id="28b3c-162">If cancellation is requested, the example calls the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> method to cancel the thread.</span></span>  
  
 <span data-ttu-id="28b3c-163">Следующий пример идентичен первому, за исключением того, что он использует <xref:System.Threading.Tasks.Task> объект и лямбда-выражение <xref:System.Threading.Thread> вместо объектов.</span><span class="sxs-lookup"><span data-stu-id="28b3c-163">The following example is identical to the first, except that it uses a <xref:System.Threading.Tasks.Task> object and a lambda expression instead of <xref:System.Threading.Thread> objects.</span></span>  
  
 [!code-csharp[System.Random#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex2.cs#4)]
 [!code-vb[System.Random#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex2.vb#4)]  
  
 <span data-ttu-id="28b3c-164">Он отличается от первого примера следующими способами.</span><span class="sxs-lookup"><span data-stu-id="28b3c-164">It differs from the first example in the following ways:</span></span>  
  
-   <span data-ttu-id="28b3c-165">Переменные, которые следует отследить от количества формируемых случайных чисел и их сумму в каждой задаче, являются локальными для задачи, поэтому нет необходимости использовать <xref:System.ThreadStaticAttribute> атрибут.</span><span class="sxs-lookup"><span data-stu-id="28b3c-165">The variables to keep track of the number of random numbers generated and their sum in each task are local to the task, so there is no need to use the <xref:System.ThreadStaticAttribute> attribute.</span></span>  
  
-   <span data-ttu-id="28b3c-166">Статический <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> метод используется, чтобы гарантировать, что главный поток не завершится до завершения всех задач.</span><span class="sxs-lookup"><span data-stu-id="28b3c-166">The static <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method is used to ensure that the main thread doesn't complete before all tasks have finished.</span></span> <span data-ttu-id="28b3c-167"><xref:System.Threading.CountdownEvent> Объект не требуется.</span><span class="sxs-lookup"><span data-stu-id="28b3c-167">There is no need for the <xref:System.Threading.CountdownEvent> object.</span></span>  
  
-   <span data-ttu-id="28b3c-168">Исключение, полученное в результате отмены задачи, отображается в <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> методе.</span><span class="sxs-lookup"><span data-stu-id="28b3c-168">The exception that results from task cancellation is surfaced in the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="28b3c-169">В предыдущем примере он обрабатывается каждым потоком.</span><span class="sxs-lookup"><span data-stu-id="28b3c-169">In the previous example, it is handled by each thread.</span></span>  
  
<a name="Functionality"></a>   
## <a name="generating-different-types-of-random-numbers"></a><span data-ttu-id="28b3c-170">Создание различных типов случайных чисел</span><span class="sxs-lookup"><span data-stu-id="28b3c-170">Generating different types of random numbers</span></span>  
 <span data-ttu-id="28b3c-171">Генератор случайных чисел предоставляет методы, позволяющие создавать следующие виды случайных чисел:</span><span class="sxs-lookup"><span data-stu-id="28b3c-171">The random number generator provides methods that let you generate the following kinds of random numbers:</span></span>  
  
-   <span data-ttu-id="28b3c-172">Ряд <xref:System.Byte> значений.</span><span class="sxs-lookup"><span data-stu-id="28b3c-172">A series of <xref:System.Byte> values.</span></span> <span data-ttu-id="28b3c-173">Вы определяете количество байтовых значений, передавая массив, инициализируемый в число элементов, которые метод должен вернуть <xref:System.Random.NextBytes%2A> в метод.</span><span class="sxs-lookup"><span data-stu-id="28b3c-173">You determine the number of byte values by passing an array initialized to the number of elements you want the method to return to the <xref:System.Random.NextBytes%2A> method.</span></span> <span data-ttu-id="28b3c-174">Следующий пример приводит к возникновению 20 байтов.</span><span class="sxs-lookup"><span data-stu-id="28b3c-174">The following example generates 20 bytes.</span></span>  
  
     [!code-cpp[System.Random#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextbytes1.cpp#5)]
     [!code-csharp[System.Random#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextbytes1.cs#5)]
     [!code-vb[System.Random#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextbytes1.vb#5)]  
  
-   <span data-ttu-id="28b3c-175">Одно целое число.</span><span class="sxs-lookup"><span data-stu-id="28b3c-175">A single integer.</span></span> <span data-ttu-id="28b3c-176">Можно выбрать, требуется ли целое число от 0 до максимального значения (<xref:System.Int32.MaxValue?displayProperty=nameWithType> -1), <xref:System.Random.Next> вызвав метод, целое число от 0 до <xref:System.Random.Next%28System.Int32%29> определенного значения путем вызова метода или целого числа в диапазоне значений, вызвав метод <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>метод.</span><span class="sxs-lookup"><span data-stu-id="28b3c-176">You can choose whether you want an integer from 0 to a maximum value (<xref:System.Int32.MaxValue?displayProperty=nameWithType> - 1) by calling the <xref:System.Random.Next> method, an integer between 0 and a specific value by calling the <xref:System.Random.Next%28System.Int32%29> method, or an integer within a range of values by calling the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method.</span></span> <span data-ttu-id="28b3c-177">В параметризованных перегрузках указанное максимальное значение является эксклюзивным; то есть фактическое максимальное число, созданное на единицу, меньше указанного значения.</span><span class="sxs-lookup"><span data-stu-id="28b3c-177">In the parameterized overloads, the specified maximum value is exclusive; that is, the actual maximum number generated is one less than the specified value.</span></span>  
  
     <span data-ttu-id="28b3c-178">В следующем примере вызывается <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> метод для создания 10 случайных чисел в диапазоне от-10 до 10.</span><span class="sxs-lookup"><span data-stu-id="28b3c-178">The following example calls the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method to generate 10 random numbers between -10 and 10.</span></span> <span data-ttu-id="28b3c-179">Обратите внимание, что второй аргумент метода указывает эксклюзивную верхнюю границу диапазона случайных значений, возвращаемых методом.</span><span class="sxs-lookup"><span data-stu-id="28b3c-179">Note that the second argument to the method specifies the exclusive upper bound of the range of random values returned by the method.</span></span> <span data-ttu-id="28b3c-180">Иными словами, самое большое целое число, которое метод может вернуть, меньше этого значения.</span><span class="sxs-lookup"><span data-stu-id="28b3c-180">In other words, the largest integer that the method can return is one less than this value.</span></span>  
  
     [!code-cpp[System.Random#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextex1.cpp#6)]
     [!code-csharp[System.Random#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextex1.cs#6)]
     [!code-vb[System.Random#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextex1.vb#6)]  
  
-   <span data-ttu-id="28b3c-181">Одиночное значение с плавающей запятой от 0,0 до меньше 1,0 путем вызова <xref:System.Random.NextDouble%2A> метода.</span><span class="sxs-lookup"><span data-stu-id="28b3c-181">A single floating-point value from 0.0 to less than 1.0 by calling the <xref:System.Random.NextDouble%2A> method.</span></span> <span data-ttu-id="28b3c-182">Эксклюзивная верхняя граница случайного числа, возвращаемого методом, — 1, поэтому фактическая верхняя граница — 0.99999999999999978.</span><span class="sxs-lookup"><span data-stu-id="28b3c-182">The exclusive upper bound of the random number returned by the method is 1, so its actual upper bound is 0.99999999999999978.</span></span> <span data-ttu-id="28b3c-183">В следующем примере создаются 10 случайных чисел с плавающей запятой.</span><span class="sxs-lookup"><span data-stu-id="28b3c-183">The following example generates 10 random floating-point numbers.</span></span>  
  
     [!code-cpp[System.Random#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextdoubleex1.cpp#7)]
     [!code-csharp[System.Random#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextdoubleex1.cs#7)]
     [!code-vb[System.Random#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextdoubleex1.vb#7)]  
  
> [!IMPORTANT]
>  <span data-ttu-id="28b3c-184"><xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> Метод позволяет указать диапазон возвращаемого случайного числа.</span><span class="sxs-lookup"><span data-stu-id="28b3c-184">The <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method allows you to specify the range of the returned random number.</span></span> <span data-ttu-id="28b3c-185">`maxValue` Однако параметр, который указывает верхний возвращенный диапазон, является эксклюзивным, а не инклюзивным значением.</span><span class="sxs-lookup"><span data-stu-id="28b3c-185">However, the `maxValue` parameter, which specifies the upper range returned number, is an exclusive, not an inclusive, value.</span></span> <span data-ttu-id="28b3c-186">Это означает, что вызов `Next(0, 100)` метода возвращает значение от 0 до 99, а не между 0 и 100.</span><span class="sxs-lookup"><span data-stu-id="28b3c-186">This means that the method call `Next(0, 100)` returns a value between 0 and 99, and not between 0 and 100.</span></span>  
  
 <span data-ttu-id="28b3c-187"><xref:System.Random> Класс также можно использовать для таких задач, как создание [случайных значений T:System.Boolean](#Boolean), создание [случайных значений с плавающей запятой с диапазоном, отличным от 0 до 1](#Floats), создание [случайных 64-разрядных целых чисел](#Long)и [случайное получение уникального элемента из массива или коллекции](#UniqueArray).</span><span class="sxs-lookup"><span data-stu-id="28b3c-187">You can also use the <xref:System.Random> class for such tasks as generating [random T:System.Boolean values](#Boolean), generating [random floating point values with a range other than 0 to 1](#Floats), generating [random 64-bit integers](#Long), and [randomly retrieving a unique element from an array or collection](#UniqueArray).</span></span> <span data-ttu-id="28b3c-188">Эти и другие распространенные задачи см. в разделе [как использовать System. Random to...](#Operations)</span><span class="sxs-lookup"><span data-stu-id="28b3c-188">For these and other common tasks, see the [How do you use System.Random to…](#Operations)</span></span> <span data-ttu-id="28b3c-189">раздела.</span><span class="sxs-lookup"><span data-stu-id="28b3c-189">section.</span></span>  
  
<a name="Overriding"></a>   
## <a name="substituting-your-own-algorithm"></a><span data-ttu-id="28b3c-190">Замена собственного алгоритма</span><span class="sxs-lookup"><span data-stu-id="28b3c-190">Substituting your own algorithm</span></span>  
 <span data-ttu-id="28b3c-191">Вы можете реализовать собственный генератор случайных чисел, наследуя от <xref:System.Random> класса и указав алгоритм создания случайных чисел.</span><span class="sxs-lookup"><span data-stu-id="28b3c-191">You can implement your own random number generator by inheriting from the <xref:System.Random> class and supplying your random number generation algorithm.</span></span> <span data-ttu-id="28b3c-192">Чтобы указать собственный алгоритм, необходимо переопределить <xref:System.Random.Sample%2A> метод, который реализует алгоритм создания случайных чисел.</span><span class="sxs-lookup"><span data-stu-id="28b3c-192">To supply your own algorithm, you must override the <xref:System.Random.Sample%2A> method, which implements the random number generation algorithm.</span></span> <span data-ttu-id="28b3c-193">Также следует переопределить <xref:System.Random.Next>методы, <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>и <xref:System.Random.NextBytes%2A> , чтобы убедиться, что они вызывают переопределенный <xref:System.Random.Sample%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="28b3c-193">You should also override the <xref:System.Random.Next>, <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>, and <xref:System.Random.NextBytes%2A> methods to ensure that they call your overridden <xref:System.Random.Sample%2A> method.</span></span> <span data-ttu-id="28b3c-194">Вам не нужно переопределять <xref:System.Random.Next%28System.Int32%29> методы и. <xref:System.Random.NextDouble%2A></span><span class="sxs-lookup"><span data-stu-id="28b3c-194">You don't have to override the <xref:System.Random.Next%28System.Int32%29> and <xref:System.Random.NextDouble%2A> methods.</span></span>  
  
 <span data-ttu-id="28b3c-195">Пример, который является производным от <xref:System.Random> класса и изменяет генератор случайных чисел псевдослучайных значений по умолчанию, см. на <xref:System.Random.Sample%2A> странице справки.</span><span class="sxs-lookup"><span data-stu-id="28b3c-195">For an example that derives from the <xref:System.Random> class and modifies its default pseudo-random number generator, see the <xref:System.Random.Sample%2A> reference page.</span></span>  
  
<a name="Operations"></a>   
## <a name="how-do-you-use-systemrandom-to"></a><span data-ttu-id="28b3c-196">Как использовать System. Random to...</span><span class="sxs-lookup"><span data-stu-id="28b3c-196">How do you use System.Random to…</span></span>  
 <span data-ttu-id="28b3c-197">В следующих разделах приводятся примеры кода для некоторых способов использования случайных чисел в приложении.</span><span class="sxs-lookup"><span data-stu-id="28b3c-197">The following sections discuss and provide sample code for some of the ways you might want to use random numbers in your app.</span></span>  
  
<a name="Same"></a>   
### <a name="retrieve-the-same-sequence-of-random-values"></a><span data-ttu-id="28b3c-198">Получение той же последовательности случайных значений</span><span class="sxs-lookup"><span data-stu-id="28b3c-198">Retrieve the same sequence of random values</span></span>  
 <span data-ttu-id="28b3c-199">Иногда требуется создать одну и ту же последовательность случайных чисел в сценариях тестирования программного обеспечения и в игре.</span><span class="sxs-lookup"><span data-stu-id="28b3c-199">Sometimes you want to generate the same sequence of random numbers in software test scenarios and in game playing.</span></span> <span data-ttu-id="28b3c-200">Проверка с одинаковой последовательностью случайных чисел позволяет обнаруживать регрессию и подтверждать исправления ошибок.</span><span class="sxs-lookup"><span data-stu-id="28b3c-200">Testing with the same sequence of random numbers allows you to detect regressions and confirm bug fixes.</span></span> <span data-ttu-id="28b3c-201">Использование одинаковой последовательности случайных чисел в играх позволяет воспроизводить предыдущие игры.</span><span class="sxs-lookup"><span data-stu-id="28b3c-201">Using the same sequence of random number in games allows you to replay previous games.</span></span>  
  
 <span data-ttu-id="28b3c-202">Вы можете создать одну и ту же последовательность случайных чисел, предоставив <xref:System.Random.%23ctor%28System.Int32%29> конструктору одно и то же начальное значение.</span><span class="sxs-lookup"><span data-stu-id="28b3c-202">You can generate the same sequence of random numbers by providing the same seed value to the <xref:System.Random.%23ctor%28System.Int32%29> constructor.</span></span> <span data-ttu-id="28b3c-203">Начальное значение предоставляет начальное значение для алгоритма формирования псевдослучайных чисел.</span><span class="sxs-lookup"><span data-stu-id="28b3c-203">The seed value provides a starting value for the pseudo-random number generation algorithm.</span></span> <span data-ttu-id="28b3c-204">В следующем примере используется 100100 в качестве произвольного начального значения для создания экземпляра <xref:System.Random> объекта, выводится 20 случайных значений с плавающей запятой и сохраняется начальное значение.</span><span class="sxs-lookup"><span data-stu-id="28b3c-204">The following example uses 100100 as an arbitrary seed value to instantiate the <xref:System.Random> object, displays 20 random floating-point values, and persists the seed value.</span></span> <span data-ttu-id="28b3c-205">Затем оно восстанавливает начальное значение, создает новый генератор случайных чисел и отображает те же 20 случайных значений с плавающей точкой.</span><span class="sxs-lookup"><span data-stu-id="28b3c-205">It then restores the seed value, instantiates a new random number generator, and displays the same 20 random floating-point values.</span></span>  <span data-ttu-id="28b3c-206">Обратите внимание, что в примере могут формироваться различные последовательности случайных чисел, если они работают в разных версиях .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="28b3c-206">Note that the example may produce different sequences of random numbers if run on different versions of the .NET Framework.</span></span>  
  
 [!code-cpp[System.Random#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/same1.cpp#12)]
 [!code-csharp[System.Random#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/same1.cs#12)]
 [!code-vb[System.Random#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/same1.vb#12)]  
  
<a name="Unique"></a>   
### <a name="retrieve-unique-sequences-of-random-numbers"></a><span data-ttu-id="28b3c-207">Получение уникальных последовательностей случайных чисел</span><span class="sxs-lookup"><span data-stu-id="28b3c-207">Retrieve unique sequences of random numbers</span></span>  
 <span data-ttu-id="28b3c-208">Предоставление различных начальных значений экземплярам <xref:System.Random> класса приводит к тому, что каждый генератор случайных чисел создает другую последовательность значений.</span><span class="sxs-lookup"><span data-stu-id="28b3c-208">Providing different seed values to instances of the <xref:System.Random> class causes each random number generator to produce a different sequence of values.</span></span> <span data-ttu-id="28b3c-209">Начальное значение можно указать явным образом путем вызова <xref:System.Random.%23ctor%28System.Int32%29> конструктора или неявно путем <xref:System.Random.%23ctor> вызова конструктора.</span><span class="sxs-lookup"><span data-stu-id="28b3c-209">You can provide a seed value either explicitly by calling the <xref:System.Random.%23ctor%28System.Int32%29> constructor, or implicitly by calling the <xref:System.Random.%23ctor> constructor.</span></span> <span data-ttu-id="28b3c-210">Большинство разработчиков вызывают конструктор без параметров, который использует системные часы.</span><span class="sxs-lookup"><span data-stu-id="28b3c-210">Most developers call the parameterless constructor, which uses the system clock.</span></span> <span data-ttu-id="28b3c-211">В следующем примере используется этот подход для создания экземпляров двух <xref:System.Random> экземпляров.</span><span class="sxs-lookup"><span data-stu-id="28b3c-211">The following example uses this approach to instantiate two <xref:System.Random> instances.</span></span> <span data-ttu-id="28b3c-212">Каждый экземпляр отображает последовательность из 10 случайных целых чисел.</span><span class="sxs-lookup"><span data-stu-id="28b3c-212">Each instance displays a series of 10 random integers.</span></span>  
  
 [!code-cpp[System.Random#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/unique.cpp#13)]
 [!code-csharp[System.Random#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/unique.cs#13)]
 [!code-vb[System.Random#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/unique.vb#13)]  
  
 <span data-ttu-id="28b3c-213">Однако из-за его конечного разрешения системные часы не обнаруживают разницы во времени, которые менее 15 миллисекунд.</span><span class="sxs-lookup"><span data-stu-id="28b3c-213">However, because of its finite resolution, the system clock doesn't detect time differences that are less than approximately 15 milliseconds.</span></span> <span data-ttu-id="28b3c-214">Таким образом, если код вызывает <xref:System.Random.%23ctor> перегрузку для создания экземпляров двух <xref:System.Random> объектов, вы можете случайно предоставить объекты с одинаковыми начальными значениями.</span><span class="sxs-lookup"><span data-stu-id="28b3c-214">Therefore, if your code calls the <xref:System.Random.%23ctor> overload to instantiate two <xref:System.Random> objects in succession, you might inadvertently be providing the objects with identical seed values.</span></span> <span data-ttu-id="28b3c-215">Чтобы увидеть это в предыдущем примере, закомментируйте <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> вызов метода, а затем скомпилируйте и запустите пример еще раз.</span><span class="sxs-lookup"><span data-stu-id="28b3c-215">To see this in the previous example, comment out the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method call, and compile and run the example again.</span></span>  
  
 <span data-ttu-id="28b3c-216">Чтобы предотвратить это, рекомендуется создать экземпляр одного <xref:System.Random> объекта, а не несколько.</span><span class="sxs-lookup"><span data-stu-id="28b3c-216">To prevent this from happening, we recommend that you instantiate a single <xref:System.Random> object rather than multiple ones.</span></span> <span data-ttu-id="28b3c-217">Однако, поскольку <xref:System.Random> не является потокобезопасным, необходимо использовать некоторое устройство синхронизации при <xref:System.Random> доступе к экземпляру из нескольких потоков. Дополнительные сведения см. в разделе [случайный класс и безопасность потоков](#ThreadSafety) ранее в этой статье.</span><span class="sxs-lookup"><span data-stu-id="28b3c-217">However, since <xref:System.Random> isn't thread safe, you must use some synchronization device if you access a <xref:System.Random> instance from multiple threads; for more information, see [The Random class and thread safety](#ThreadSafety) earlier in this topic.</span></span> <span data-ttu-id="28b3c-218">Кроме того, можно использовать механизм задержки, например <xref:System.Threading.Thread.Sleep%2A> метод, используемый в предыдущем примере, чтобы убедиться в том, что создание экземпляров происходит более чем на 15 миллисекунд.</span><span class="sxs-lookup"><span data-stu-id="28b3c-218">Alternately, you can use a delay mechanism, such as the <xref:System.Threading.Thread.Sleep%2A> method used in the previous example, to ensure that the instantiations occur more than 15 millisecond apart.</span></span>  
  
<a name="Range"></a>   
### <a name="retrieve-integers-in-a-specified-range"></a><span data-ttu-id="28b3c-219">Получение целых чисел в указанном диапазоне</span><span class="sxs-lookup"><span data-stu-id="28b3c-219">Retrieve integers in a specified range</span></span>  
 <span data-ttu-id="28b3c-220">Вы можете получить целые числа в указанном диапазоне, вызвав <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> метод, который позволяет указать нижнюю и верхнюю границы чисел, которые нужно вернуть генератору случайных чисел.</span><span class="sxs-lookup"><span data-stu-id="28b3c-220">You can retrieve integers in a specified range by calling the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method, which lets you specify both the lower and the upper bound of the numbers you'd like the random number generator to return.</span></span> <span data-ttu-id="28b3c-221">Верхняя граница — это эксклюзивное, а не инклюзивное значение.</span><span class="sxs-lookup"><span data-stu-id="28b3c-221">The upper bound is an exclusive, not an inclusive, value.</span></span> <span data-ttu-id="28b3c-222">То есть он не включается в диапазон значений, возвращаемых методом.</span><span class="sxs-lookup"><span data-stu-id="28b3c-222">That is, it isn't included in the range of values returned by the method.</span></span> <span data-ttu-id="28b3c-223">В следующем примере этот метод используется для создания случайных целых чисел от-10 до 10.</span><span class="sxs-lookup"><span data-stu-id="28b3c-223">The following example uses this method to generate random integers between -10 and 10.</span></span> <span data-ttu-id="28b3c-224">Обратите внимание, что в нем указано значение 11, которое больше, чем требуемое значение, в `maxValue` качестве значения аргумента в вызове метода.</span><span class="sxs-lookup"><span data-stu-id="28b3c-224">Note that it specifies 11, which is one greater than the desired value, as the value of the `maxValue` argument in the method call.</span></span>  
  
 [!code-cpp[System.Random#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range1.cpp#15)]
 [!code-csharp[System.Random#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range1.cs#15)]
 [!code-vb[System.Random#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range1.vb#15)]  
  
<a name="Digits"></a>   
### <a name="retrieve-integers-with-a-specified-number-of-digits"></a><span data-ttu-id="28b3c-225">Получение целых чисел с указанным числом цифр</span><span class="sxs-lookup"><span data-stu-id="28b3c-225">Retrieve integers with a specified number of digits</span></span>  
 <span data-ttu-id="28b3c-226"><xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> Метод можно вызвать для получения чисел с указанным числом цифр.</span><span class="sxs-lookup"><span data-stu-id="28b3c-226">You can call the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method to retrieve numbers with a specified number of digits.</span></span> <span data-ttu-id="28b3c-227">Например, чтобы получить числа с четырьмя цифрами (т. е. числа в диапазоне от 1000 до 9999), вызовите <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> метод `minValue` со `maxValue` значением 1000 и значением 10000, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="28b3c-227">For example, to retrieve numbers with four digits (that is, numbers that range from 1000 to 9999), you call the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method with a `minValue` value of 1000 and a `maxValue` value of 10000, as the following example shows.</span></span>  
  
 [!code-cpp[System.Random#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range2.cpp#16)]
 [!code-csharp[System.Random#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range2.cs#16)]
 [!code-vb[System.Random#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range2.vb#16)]  
  
<a name="Floats"></a>   
### <a name="retrieve-floating-point-values-in-a-specified-range"></a><span data-ttu-id="28b3c-228">Получение значений с плавающей запятой в указанном диапазоне</span><span class="sxs-lookup"><span data-stu-id="28b3c-228">Retrieve floating-point values in a specified range</span></span>  
 <span data-ttu-id="28b3c-229"><xref:System.Random.NextDouble%2A> Метод возвращает случайные значения с плавающей запятой в диапазоне от 0 до меньше 1.</span><span class="sxs-lookup"><span data-stu-id="28b3c-229">The <xref:System.Random.NextDouble%2A> method returns random floating-point values that range from 0 to less than 1.</span></span> <span data-ttu-id="28b3c-230">Однако часто требуется создавать случайные значения в каком бы то ни было другом диапазоне.</span><span class="sxs-lookup"><span data-stu-id="28b3c-230">However, you'll often want to generate random values in some other range.</span></span>  
  
 <span data-ttu-id="28b3c-231">Если интервал между минимальным и максимальным требуемыми значениями равен 1, можно добавить разницу между требуемым начальным интервалом и значением 0 для числа, возвращаемого <xref:System.Random.NextDouble%2A> методом.</span><span class="sxs-lookup"><span data-stu-id="28b3c-231">If the interval between the minimum and maximum desired values is 1, you can add the difference between the desired starting interval and 0 to the number returned by the <xref:System.Random.NextDouble%2A> method.</span></span> <span data-ttu-id="28b3c-232">В следующем примере это делается для создания 10 случайных чисел в диапазоне от-1 до 0.</span><span class="sxs-lookup"><span data-stu-id="28b3c-232">The following example does this to generate 10 random numbers between -1 and 0.</span></span>  
  
 [!code-cpp[System.Random#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange2.cpp#17)]
 [!code-csharp[System.Random#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange2.cs#17)]
 [!code-vb[System.Random#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange2.vb#17)]  
  
 <span data-ttu-id="28b3c-233">Для создания случайных чисел с плавающей запятой, Нижняя граница которых равна 0, но верхняя граница больше 1 (или, в случае отрицательных чисел, Нижняя граница которой меньше-1, а верхняя граница равна 0), умножьте случайное число на ненулевую границу.</span><span class="sxs-lookup"><span data-stu-id="28b3c-233">To generate random floating-point numbers whose lower bound is 0 but upper bound is greater than 1 (or, in the case of negative numbers, whose lower bound is less than -1 and upper bound is 0), multiply the random number by the non-zero bound.</span></span> <span data-ttu-id="28b3c-234">В следующем примере это делается для создания 20 000 000 случайных чисел с плавающей запятой в диапазоне от 0 <xref:System.Int64.MaxValue?displayProperty=nameWithType>до.</span><span class="sxs-lookup"><span data-stu-id="28b3c-234">The following example does this to generate 20 million random floating-point numbers that range from 0 to <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="28b3c-235">В также отображает распределение случайных значений, созданных методом.</span><span class="sxs-lookup"><span data-stu-id="28b3c-235">In also displays the distribution of the random values generated by the method.</span></span>  
  
 [!code-cpp[System.Random#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange1.cpp#18)]
 [!code-csharp[System.Random#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange1.cs#18)]
 [!code-vb[System.Random#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange1.vb#18)]  
  
 <span data-ttu-id="28b3c-236">Чтобы создать случайные числа с плавающей запятой между двумя произвольными значениями, <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> например метод для целых чисел, используйте следующую формулу:</span><span class="sxs-lookup"><span data-stu-id="28b3c-236">To generate random floating-point numbers between two arbitrary values, like the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method does for integers, use the following formula:</span></span>  
  
```csharp  
Random.NextDouble() * (maxValue - minValue) + minValue  
```  
  
 <span data-ttu-id="28b3c-237">Следующий пример приводит к возникновению ошибки 1 000 000 случайных чисел в диапазоне от 10,0 до 11,0 и отображении их распределения.</span><span class="sxs-lookup"><span data-stu-id="28b3c-237">The following example generates 1 million random numbers that range from 10.0 to 11.0, and displays their distribution.</span></span>  
  
 [!code-cpp[System.Random#19](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange3.cpp#19)]
 [!code-csharp[System.Random#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange3.cs#19)]
 [!code-vb[System.Random#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange3.vb#19)]  
  
<a name="Boolean"></a>   
### <a name="generate-random-boolean-values"></a><span data-ttu-id="28b3c-238">Создание случайных логических значений</span><span class="sxs-lookup"><span data-stu-id="28b3c-238">Generate random Boolean values</span></span>  
 <span data-ttu-id="28b3c-239">Класс не предоставляет методы, создающие <xref:System.Boolean> значения. <xref:System.Random></span><span class="sxs-lookup"><span data-stu-id="28b3c-239">The <xref:System.Random> class doesn't provide methods that generate <xref:System.Boolean> values.</span></span> <span data-ttu-id="28b3c-240">Однако для этого можно определить собственный класс или метод.</span><span class="sxs-lookup"><span data-stu-id="28b3c-240">However, you can define your own class or method to do that.</span></span> <span data-ttu-id="28b3c-241">В следующем примере определяется класс `BooleanGenerator`с одним `NextBoolean`методом.</span><span class="sxs-lookup"><span data-stu-id="28b3c-241">The following example defines a class, `BooleanGenerator`, with a single method, `NextBoolean`.</span></span> <span data-ttu-id="28b3c-242">`BooleanGenerator` Класс<xref:System.Random> сохраняет объект как закрытую переменную.</span><span class="sxs-lookup"><span data-stu-id="28b3c-242">The `BooleanGenerator` class stores a <xref:System.Random> object as a private variable.</span></span> <span data-ttu-id="28b3c-243">Метод вызывает метод и<xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType> передает результат в метод. <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> `NextBoolean`</span><span class="sxs-lookup"><span data-stu-id="28b3c-243">The `NextBoolean` method calls the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method and passes the result to the <xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="28b3c-244">Обратите внимание, что в качестве аргумента используется 2, чтобы указать верхнюю границу случайного числа.</span><span class="sxs-lookup"><span data-stu-id="28b3c-244">Note that 2 is used as the argument to specify the upper bound of the random number.</span></span> <span data-ttu-id="28b3c-245">Так как это значение является эксклюзивным, вызов метода возвращает значение 0 или 1.</span><span class="sxs-lookup"><span data-stu-id="28b3c-245">Since this is an exclusive value, the method call returns either 0 or 1.</span></span>  
  
 [!code-cpp[System.Random#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans1.cpp#8)]
 [!code-csharp[System.Random#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans1.cs#8)]
 [!code-vb[System.Random#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans1.vb#8)]  
  
 <span data-ttu-id="28b3c-246">Вместо создания отдельного класса для создания случайных <xref:System.Boolean> значений в примере можно просто определить один метод.</span><span class="sxs-lookup"><span data-stu-id="28b3c-246">Instead of creating a separate class to generate random <xref:System.Boolean> values, the example could simply have defined a single method.</span></span> <span data-ttu-id="28b3c-247">Однако <xref:System.Random> в этом случае объект должен быть определен как переменная уровня класса, чтобы избежать создания экземпляра нового <xref:System.Random> экземпляра в каждом вызове метода.</span><span class="sxs-lookup"><span data-stu-id="28b3c-247">In that case, however, the <xref:System.Random> object should have been defined as a class-level variable to avoid instantiating a new <xref:System.Random> instance in each method call.</span></span> <span data-ttu-id="28b3c-248">В Visual Basic случайный экземпляр может быть определен как [статическая](~/docs/visual-basic/language-reference/modifiers/static.md) переменная в `NextBoolean` методе.</span><span class="sxs-lookup"><span data-stu-id="28b3c-248">In Visual Basic, the Random instance can be defined as a [Static](~/docs/visual-basic/language-reference/modifiers/static.md) variable in the `NextBoolean` method.</span></span>  <span data-ttu-id="28b3c-249">В следующем примере показана реализация.</span><span class="sxs-lookup"><span data-stu-id="28b3c-249">The following example provides an implementation.</span></span>  
  
 [!code-cpp[System.Random#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans2.cpp#20)]
 [!code-csharp[System.Random#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans2.cs#20)]
 [!code-vb[System.Random#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans2.vb#20)]  
  
<a name="Long"></a>   
### <a name="generate-random-64-bit-integers"></a><span data-ttu-id="28b3c-250">Создавать случайные 64-разрядные целые числа</span><span class="sxs-lookup"><span data-stu-id="28b3c-250">Generate random 64-bit integers</span></span>  
 <span data-ttu-id="28b3c-251">Перегрузки <xref:System.Random.Next%2A> метода возвращают 32-разрядные целые числа.</span><span class="sxs-lookup"><span data-stu-id="28b3c-251">The overloads of the <xref:System.Random.Next%2A> method return 32-bit integers.</span></span> <span data-ttu-id="28b3c-252">Однако в некоторых случаях может потребоваться работать с 64-разрядными целыми числами.</span><span class="sxs-lookup"><span data-stu-id="28b3c-252">However, in some cases, you might want to work with 64-bit integers.</span></span> <span data-ttu-id="28b3c-253">Это можно сделать следующим образом:</span><span class="sxs-lookup"><span data-stu-id="28b3c-253">You can do this as follows:</span></span>  
  
1.  <span data-ttu-id="28b3c-254">Вызовите <xref:System.Random.NextDouble%2A> метод, чтобы получить значение двойной точности с плавающей запятой.</span><span class="sxs-lookup"><span data-stu-id="28b3c-254">Call the <xref:System.Random.NextDouble%2A> method to retrieve a double-precision floating point value.</span></span>  
  
2.  <span data-ttu-id="28b3c-255">Умножьте это значение на <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="28b3c-255">Multiply that value by <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="28b3c-256">В следующем примере этот метод используется для создания 20 000 000 случайных длинных целых чисел и классификации их в 10 равных группах.</span><span class="sxs-lookup"><span data-stu-id="28b3c-256">The following example uses this technique to generate 20 million random long integers and categorizes them in 10 equal groups.</span></span> <span data-ttu-id="28b3c-257">Затем он вычисляет распределение случайных чисел, подчисляя число в каждой группе от 0 до <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="28b3c-257">It then evaluates the distribution of the random numbers by counting the number in each group from 0 to <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="28b3c-258">Как видно из выходных данных примера, числа распределяются более или реже по диапазону длинного целого числа.</span><span class="sxs-lookup"><span data-stu-id="28b3c-258">As the output from the example shows, the numbers are distributed more or less equally through the range of a long integer.</span></span>  
  
 [!code-cpp[System.Random#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/long1.cpp#14)]
 [!code-csharp[System.Random#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/long1.cs#14)]
 [!code-vb[System.Random#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/long1.vb#14)]  
  
 <span data-ttu-id="28b3c-259">Альтернативный метод, использующий побитовую обработку, не создает действительно случайных чисел.</span><span class="sxs-lookup"><span data-stu-id="28b3c-259">An alternative technique that uses bit manipulation does not generate truly random numbers.</span></span> <span data-ttu-id="28b3c-260">Этот метод вызывает <xref:System.Random.Next> метод для создания двух целых чисел, сдвига влево по одному на 32 бит и or их вместе.</span><span class="sxs-lookup"><span data-stu-id="28b3c-260">This technique calls <xref:System.Random.Next> to generate two integers, left-shifts one by 32 bits, and ORs them together.</span></span> <span data-ttu-id="28b3c-261">Этот метод имеет два ограничения:</span><span class="sxs-lookup"><span data-stu-id="28b3c-261">This technique has two limitations:</span></span>  
  
1.  <span data-ttu-id="28b3c-262">Поскольку бит 31 является битом знака, значение в битовом 31 полученного длинного целого числа всегда равно 0.</span><span class="sxs-lookup"><span data-stu-id="28b3c-262">Because bit 31 is the sign bit, the value in bit 31 of the resulting long integer is always 0.</span></span>  <span data-ttu-id="28b3c-263">Это можно решить путем создания случайного значения 0 или 1, сдвига влево на 31 бит и индексами его с исходным произвольным целым числом.</span><span class="sxs-lookup"><span data-stu-id="28b3c-263">This can be addressed by generating a random 0 or 1, left-shifting it 31 bits, and ORing it with the original random long integer.</span></span>  
  
2.  <span data-ttu-id="28b3c-264">Более серьезно, поскольку вероятность того, что значение, возвращаемое, <xref:System.Random.Next> будет равно 0, будет несколько случайных чисел в диапазоне 0x0-0x00000000FFFFFFFF.</span><span class="sxs-lookup"><span data-stu-id="28b3c-264">More seriously, because the probability that the value returned by <xref:System.Random.Next> will be 0, there will be few if any random numbers in the range 0x0-0x00000000FFFFFFFF.</span></span>  
  
<a name="Bytes"></a>   
### <a name="retrieve-bytes-in-a-specified-range"></a><span data-ttu-id="28b3c-265">Извлечение байтов в указанном диапазоне</span><span class="sxs-lookup"><span data-stu-id="28b3c-265">Retrieve bytes in a specified range</span></span>  
 <span data-ttu-id="28b3c-266">Перегрузки <xref:System.Random.Next%2A> метода позволяют указать диапазон случайных чисел, <xref:System.Random.NextBytes%2A> но метод — нет.</span><span class="sxs-lookup"><span data-stu-id="28b3c-266">The overloads of the <xref:System.Random.Next%2A> method allow you to specify the range of random numbers, but the <xref:System.Random.NextBytes%2A> method does not.</span></span> <span data-ttu-id="28b3c-267">В следующем примере реализуется `NextBytes` метод, который позволяет указать диапазон возвращаемых байтов.</span><span class="sxs-lookup"><span data-stu-id="28b3c-267">The following example implements a `NextBytes` method that lets you specify the range of the returned bytes.</span></span> <span data-ttu-id="28b3c-268">Он определяет `Random2` класс, производный от <xref:System.Random> , и перегружает его `NextBytes` метод.</span><span class="sxs-lookup"><span data-stu-id="28b3c-268">It defines a `Random2` class that derives from <xref:System.Random> and overloads its `NextBytes` method.</span></span>  
  
 [!code-cpp[System.Random#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/bytes1.cpp#9)]
 [!code-csharp[System.Random#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/bytes1.cs#9)]
 [!code-vb[System.Random#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/bytes1.vb#9)]  
  
 <span data-ttu-id="28b3c-269">Метод создает оболочку <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> для вызова метода и задает минимальное значение, которое больше максимального значения (в данном случае 0 и 101), которое требуется вернуть в массив байтов. `NextBytes(Byte[], Byte, Byte)`</span><span class="sxs-lookup"><span data-stu-id="28b3c-269">The `NextBytes(Byte[], Byte, Byte)` method wraps a call to the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method and specifies the minimum value and one greater than the maximum value (in this case, 0 and 101) that we want returned in the byte array.</span></span> <span data-ttu-id="28b3c-270">Так как мы уверены, что целочисленные значения, возвращаемые <xref:System.Random.Next%2A> методом, находятся в диапазоне <xref:System.Byte> типа данных, мы можем безопасно привести их (в C#) или преобразовать их (в Visual Basic) из целых чисел в байты.</span><span class="sxs-lookup"><span data-stu-id="28b3c-270">Because we are sure that the integer values returned by the <xref:System.Random.Next%2A> method are within the range of the <xref:System.Byte> data type, we can safely cast them (in C#) or convert them (in Visual Basic) from integers to bytes.</span></span>  
  
<a name="Array"></a>   
### <a name="retrieve-an-element-from-an-array-or-collection-at-random"></a><span data-ttu-id="28b3c-271">Извлечение элемента из массива или коллекции в случайном порядке</span><span class="sxs-lookup"><span data-stu-id="28b3c-271">Retrieve an element from an array or collection at random</span></span>  
 <span data-ttu-id="28b3c-272">Случайные числа часто используются в качестве индексов для получения значений из массивов или коллекций.</span><span class="sxs-lookup"><span data-stu-id="28b3c-272">Random numbers often serve as indexes to retrieve values from arrays or collections.</span></span> <span data-ttu-id="28b3c-273">Чтобы получить случайное значение индекса, можно вызвать <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> метод и использовать нижнюю границу массива в качестве значения его `minValue` аргумента, а на единицу больше, чем верхняя граница массива, в качестве значения его `maxValue` аргумента.</span><span class="sxs-lookup"><span data-stu-id="28b3c-273">To retrieve a random index value, you can call the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method, and use the lower bound of the array as the value of its `minValue` argument and one greater than the upper bound of the array as the value of its `maxValue` argument.</span></span> <span data-ttu-id="28b3c-274">Для массива, начинающегося с нуля, это эквивалентно его <xref:System.Array.Length%2A> свойству или больше значения, возвращаемого <xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType> методом.</span><span class="sxs-lookup"><span data-stu-id="28b3c-274">For a zero-based array, this is equivalent to its <xref:System.Array.Length%2A> property, or one greater than the value returned by the <xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="28b3c-275">В следующем примере случайным образом извлекается имя города в США из массива городов.</span><span class="sxs-lookup"><span data-stu-id="28b3c-275">The following example randomly retrieves the name of a city in the United States from an array of cities.</span></span>  
  
 [!code-cpp[System.Random#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/array1.cpp#10)]
 [!code-csharp[System.Random#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/array1.cs#10)]
 [!code-vb[System.Random#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/array1.vb#10)]  
  
<a name="UniqueArray"></a>   
### <a name="retrieve-a-unique-element-from-an-array-or-collection"></a><span data-ttu-id="28b3c-276">Извлечение уникального элемента из массива или коллекции</span><span class="sxs-lookup"><span data-stu-id="28b3c-276">Retrieve a unique element from an array or collection</span></span>  
 <span data-ttu-id="28b3c-277">Генератор случайных чисел всегда может возвращать дублирующиеся значения.</span><span class="sxs-lookup"><span data-stu-id="28b3c-277">A random number generator can always return duplicate values.</span></span> <span data-ttu-id="28b3c-278">Так как диапазон чисел становится меньше или число формируемых значений становится больше, вероятность повторений растет.</span><span class="sxs-lookup"><span data-stu-id="28b3c-278">As the range of numbers becomes smaller or the number of values generated becomes larger, the probability of duplicates grows.</span></span> <span data-ttu-id="28b3c-279">Если случайные значения должны быть уникальными, создаются дополнительные числа для компенсации дубликатов, что приводит к ухудшению производительности.</span><span class="sxs-lookup"><span data-stu-id="28b3c-279">If random values must be unique, more numbers are generated to compensate for duplicates, resulting in increasingly poor performance.</span></span>  
  
 <span data-ttu-id="28b3c-280">Существует ряд методов для решения этого сценария.</span><span class="sxs-lookup"><span data-stu-id="28b3c-280">There are a number of techniques to handle this scenario.</span></span> <span data-ttu-id="28b3c-281">Одним из распространенных решений является создание массива или коллекции, содержащей значения для извлечения, и параллельный массив, содержащий случайные числа с плавающей запятой.</span><span class="sxs-lookup"><span data-stu-id="28b3c-281">One common solution is to create an array or collection that contains the values to be retrieved, and a parallel array that contains random floating-point numbers.</span></span> <span data-ttu-id="28b3c-282">Второй массив заполняется случайными числами во время создания первого массива, а <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> метод используется для сортировки первого массива с использованием значений в параллельном массиве.</span><span class="sxs-lookup"><span data-stu-id="28b3c-282">The second array is populated with random numbers at the time the first array is created, and the <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> method is used to sort the first array by using the values in the parallel array.</span></span>  
  
 <span data-ttu-id="28b3c-283">Например, если вы разрабатываете игру «косынка», необходимо убедиться, что каждая карта используется только один раз.</span><span class="sxs-lookup"><span data-stu-id="28b3c-283">For example, if you're developing a Solitaire game, you want to ensure that each card is used only once.</span></span> <span data-ttu-id="28b3c-284">Вместо создания случайных чисел для получения карты и отслеживания того, была ли карта уже обработана, можно создать параллельный массив случайных чисел, который можно использовать для сортировки колоды.</span><span class="sxs-lookup"><span data-stu-id="28b3c-284">Instead of generating random numbers to retrieve a card and tracking whether that card has already been dealt, you can create a parallel array of random numbers that can be used to sort the deck.</span></span> <span data-ttu-id="28b3c-285">После сортировки колоды приложение может поддерживать указатель, указывающий на индекс следующей карточки в колоде.</span><span class="sxs-lookup"><span data-stu-id="28b3c-285">Once the deck is sorted, your app can maintain a pointer to indicate the index of the next card on the deck.</span></span>  
  
 <span data-ttu-id="28b3c-286">Этот подход показан в приведенном ниже примере.</span><span class="sxs-lookup"><span data-stu-id="28b3c-286">The following example illustrates this approach.</span></span> <span data-ttu-id="28b3c-287">Он определяет `Card` класс, который представляет собой воспроизводимую карту `Dealer` , и класс, который обрабатывает колоду карточек с случайным перемещением.</span><span class="sxs-lookup"><span data-stu-id="28b3c-287">It defines a `Card` class that represents a playing card and a `Dealer` class that deals a deck of shuffled cards.</span></span> <span data-ttu-id="28b3c-288">Конструктор класса заполняет два массива `deck` : массив, имеющий область класса и представляющий все карты в колоде, и локальный `order` массив, `deck` имеющий то же количество элементов, что и массив, и заполняется `Dealer` со случайно сформированными <xref:System.Double> значениями.</span><span class="sxs-lookup"><span data-stu-id="28b3c-288">The `Dealer` class constructor populates two arrays: a `deck` array that has class scope and that represents all the cards in the deck; and a local `order` array that has the same number of elements as the `deck` array and is populated with randomly generated <xref:System.Double> values.</span></span>  <span data-ttu-id="28b3c-289">Затем вызывается `deck`методдля сортировки массива на основе значений в `order` массиве. <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="28b3c-289">The <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> method is then called to sort the `deck` array based on the values in the `order` array.</span></span>  
  
 [!code-cpp[System.Random#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/uniquearray1.cpp#11)]
 [!code-csharp[System.Random#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/uniquearray1.cs#11)]
 [!code-vb[System.Random#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/uniquearray1.vb#11)]  
  
   
  
## Examples  
 <span data-ttu-id="28b3c-290">В следующем примере создается один генератор случайных чисел и вызывается его <xref:System.Random.NextBytes%2A>методы <xref:System.Random.Next%2A>, и <xref:System.Random.NextDouble%2A> для создания последовательностей случайных чисел в разных диапазонах.</span><span class="sxs-lookup"><span data-stu-id="28b3c-290">The following example creates a single random number generator and calls its <xref:System.Random.NextBytes%2A>, <xref:System.Random.Next%2A>, and <xref:System.Random.NextDouble%2A> methods to generate sequences of random numbers within different ranges.</span></span>  
  
 [!code-cpp[System.Random#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random2.cpp#2)]
 [!code-csharp[System.Random#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random2.cs#2)]
 [!code-vb[System.Random#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random2.vb#2)]  
  
 <span data-ttu-id="28b3c-291">В следующем примере создается случайное целое число, которое используется в качестве индекса для получения строкового значения из массива.</span><span class="sxs-lookup"><span data-stu-id="28b3c-291">The following example generates a random integer that it uses as an index to retrieve a string value from an array.</span></span>  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para><span data-ttu-id="28b3c-292">В .NET Framework 1,0 и 1,1 — минимальная реализация класса, производного от <see cref="T:System.Random" /> обязательного <see cref="M:System.Random.Sample" /> переопределения метода для определения нового или измененного алгоритма создания случайных чисел.</span><span class="sxs-lookup"><span data-stu-id="28b3c-292">In the .NET Framework 1.0 and 1.1, a minimum implementation of a class derived from <see cref="T:System.Random" /> required overriding the <see cref="M:System.Random.Sample" /> method to define a new or modified algorithm for generating random numbers.</span></span> <span data-ttu-id="28b3c-293"><see cref="M:System.Random.Next" />Производный класс может затем полагаться на реализацию базового класса методов <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, <see cref="M:System.Random.Next(System.Int32)" />,, <see cref="M:System.Random.NextBytes(System.Byte[])" />и <see cref="M:System.Random.NextDouble" /> для вызова реализации <see cref="M:System.Random.Sample" /> метода производного класса.</span><span class="sxs-lookup"><span data-stu-id="28b3c-293">The derived class could then rely on the base class implementation of the <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32)" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, <see cref="M:System.Random.NextBytes(System.Byte[])" />, and <see cref="M:System.Random.NextDouble" /> methods to call the derived class implementation of the <see cref="M:System.Random.Sample" /> method.</span></span>  
  
<span data-ttu-id="28b3c-294">В .NET Framework 2,0 <see cref="M:System.Random.Next" />и более поздних версиях поведение методов, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />и <see cref="M:System.Random.NextBytes(System.Byte[])" /> изменилось, так что эти методы не <see cref="M:System.Random.Sample" /> обязательно вызывают реализацию производного класса метода.</span><span class="sxs-lookup"><span data-stu-id="28b3c-294">In the .NET Framework 2.0 and later, the behavior of the <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, and <see cref="M:System.Random.NextBytes(System.Byte[])" /> methods have changed so that these methods do not necessarily call the derived class implementation of the <see cref="M:System.Random.Sample" /> method.</span></span> <span data-ttu-id="28b3c-295">В результате классы, производные от <see cref="T:System.Random" /> класса, предназначенного для .NET Framework 2,0 и более поздних версий, также должны переопределять эти три метода.</span><span class="sxs-lookup"><span data-stu-id="28b3c-295">As a result, classes derived from <see cref="T:System.Random" /> that target the .NET Framework 2.0 and later should also override these three methods.</span></span></para></block>
    <block subset="none" type="usage"><para><span data-ttu-id="28b3c-296">Реализация генератора случайных чисел в <see cref="T:System.Random" /> классе не всегда остается одинаковой для основных версий .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="28b3c-296">The implementation of the random number generator in the <see cref="T:System.Random" /> class isn't guaranteed to remain the same across major versions of the .NET Framework.</span></span> <span data-ttu-id="28b3c-297">В результате не следует рассчитывать на то, что одно и то же начальное значение приведет к той же псевдо-случайной последовательности в разных версиях .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="28b3c-297">As a result, you shouldn't assume that the same seed will result in the same pseudo-random sequence in different versions of the .NET Framework.</span></span></para></block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="28b3c-298">Инициализирует новый экземпляр класса <see cref="T:System.Random" />.</span><span class="sxs-lookup"><span data-stu-id="28b3c-298">Initializes a new instance of the <see cref="T:System.Random" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="28b3c-299">Инициализирует новый экземпляр класса <see cref="T:System.Random" /> с помощью зависимого от времени начального значения по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="28b3c-299">Initializes a new instance of the <see cref="T:System.Random" /> class, using a time-dependent default seed value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28b3c-300">Начальное значение по умолчанию является производным от системных часов и имеет конечное разрешение.</span><span class="sxs-lookup"><span data-stu-id="28b3c-300">The default seed value is derived from the system clock and has finite resolution.</span></span> <span data-ttu-id="28b3c-301">В результате разные <xref:System.Random> объекты, создаваемые при закрытии запроса к конструктору без параметров, будут иметь одинаковые начальные значения по умолчанию и, следовательно, будут создавать идентичные наборы случайных чисел.</span><span class="sxs-lookup"><span data-stu-id="28b3c-301">As a result, different <xref:System.Random> objects that are created in close succession by a call to the parameterless constructor will have identical default seed values and, therefore, will produce identical sets of random numbers.</span></span> <span data-ttu-id="28b3c-302">Эту проблему можно избежать, используя один <xref:System.Random> объект для создания всех случайных чисел.</span><span class="sxs-lookup"><span data-stu-id="28b3c-302">This problem can be avoided by using a single <xref:System.Random> object to generate all random numbers.</span></span> <span data-ttu-id="28b3c-303">Кроме того, его можно обойти, изменив начальное значение, возвращенное системными часами, а затем явно указав это новое <xref:System.Random.%23ctor%28System.Int32%29> начальное значение конструктору.</span><span class="sxs-lookup"><span data-stu-id="28b3c-303">You can also work around it by modifying the seed value returned by the system clock and then explicitly providing this new seed value to the <xref:System.Random.%23ctor%28System.Int32%29> constructor.</span></span> <span data-ttu-id="28b3c-304">Дополнительные сведения см. в <xref:System.Random.%23ctor%28System.Int32%29> описании конструктора.</span><span class="sxs-lookup"><span data-stu-id="28b3c-304">For more information, see the <xref:System.Random.%23ctor%28System.Int32%29> constructor.</span></span>  
  
 <span data-ttu-id="28b3c-305">Вызовите этот конструктор, если вы хотите, чтобы генератор случайных чисел создавал случайную последовательность чисел.</span><span class="sxs-lookup"><span data-stu-id="28b3c-305">Call this constructor if you want your random number generator to generate a random sequence of numbers.</span></span> <span data-ttu-id="28b3c-306">Чтобы создать фиксированную последовательность случайных чисел, которая будет одинаковой для разных генераторов случайных чисел, вызовите <xref:System.Random.%23ctor%28System.Int32%29> конструктор с фиксированным начальным значением.</span><span class="sxs-lookup"><span data-stu-id="28b3c-306">To generate a fixed  sequence of random numbers that will be the same for different random number generators, call the <xref:System.Random.%23ctor%28System.Int32%29> constructor with a fixed seed value .</span></span> <span data-ttu-id="28b3c-307">Эта <xref:System.Random> перегрузка конструктора часто используется при тестировании приложений, использующих случайные числа.</span><span class="sxs-lookup"><span data-stu-id="28b3c-307">This <xref:System.Random> constructor overload is frequently used when testing apps that use random numbers.</span></span>  
  
 <span data-ttu-id="28b3c-308">После создания экземпляра генератора случайных чисел вы вызываете отдельные <xref:System.Random> методы, <xref:System.Random.Next> например или <xref:System.Random.NextDouble>, для создания случайных цифр.</span><span class="sxs-lookup"><span data-stu-id="28b3c-308">Once you've instantiated the random number generator, you call individual <xref:System.Random> methods, such as <xref:System.Random.Next> or <xref:System.Random.NextDouble>, to generate random numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="28b3c-309">В следующем примере конструктор без параметров используется для создания экземпляров трех <xref:System.Random> объектов и отображает последовательность из пяти случайных целых чисел для каждого из них.</span><span class="sxs-lookup"><span data-stu-id="28b3c-309">The following example uses the parameterless constructor to instantiate three <xref:System.Random> objects and displays a sequence of five random integers for each.</span></span> <span data-ttu-id="28b3c-310">Поскольку первые два <xref:System.Random> объекта создаются в результате закрытия, они создаются с использованием идентичных начальных значений, основанных на системных часах, и, следовательно, они создают идентичную последовательность случайных чисел.</span><span class="sxs-lookup"><span data-stu-id="28b3c-310">Because the first two <xref:System.Random> objects are created in close succession, they are instantiated using identical seed values based on the system clock and, therefore, they produce an identical sequence of random numbers.</span></span> <span data-ttu-id="28b3c-311">С другой стороны, конструктор без параметров для третьего <xref:System.Random> объекта вызывается после 2-секундной задержки, вызванной <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> вызовом метода.</span><span class="sxs-lookup"><span data-stu-id="28b3c-311">On the other hand, the parameterless constructor of the third <xref:System.Random> object is called after a two-second delay caused by calling the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="28b3c-312">Поскольку при этом создается другое начальное значение для третьего <xref:System.Random> объекта, создается другая последовательность случайных чисел.</span><span class="sxs-lookup"><span data-stu-id="28b3c-312">Because this produces a different seed value for the third <xref:System.Random> object, it produces a different sequence of random numbers.</span></span>  
  
 [!code-csharp[System.Random.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor1.cs#2)]
 [!code-vb[System.Random.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random (int Seed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 Seed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Seed As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random(int Seed);" />
      <MemberSignature Language="F#" Value="new Random : int -&gt; Random" Usage="new System.Random Seed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Seed" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Seed"><span data-ttu-id="28b3c-313">Число, используемое для вычисления начального значения последовательности псевдослучайных чисел.</span><span class="sxs-lookup"><span data-stu-id="28b3c-313">A number used to calculate a starting value for the pseudo-random number sequence.</span></span> <span data-ttu-id="28b3c-314">Если задано отрицательное число, используется его абсолютное значение.</span><span class="sxs-lookup"><span data-stu-id="28b3c-314">If a negative number is specified, the absolute value of the number is used.</span></span></param>
        <summary><span data-ttu-id="28b3c-315">Инициализирует новый экземпляр класса <see cref="T:System.Random" /> с помощью указанного начального значения.</span><span class="sxs-lookup"><span data-stu-id="28b3c-315">Initializes a new instance of the <see cref="T:System.Random" /> class, using the specified seed value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28b3c-316">Предоставление идентичного начального значения разным <xref:System.Random> объектам приводит к тому, что каждый экземпляр создает идентичные последовательности случайных чисел.</span><span class="sxs-lookup"><span data-stu-id="28b3c-316">Providing an identical seed value to different <xref:System.Random> objects causes each instance to produce identical sequences of random numbers.</span></span> <span data-ttu-id="28b3c-317">Это часто делается при тестировании приложений, зависящих от генераторов случайных чисел.</span><span class="sxs-lookup"><span data-stu-id="28b3c-317">This is often done when testing apps that rely on random number generators.</span></span>  
  
 <span data-ttu-id="28b3c-318">Если приложению требуются разные последовательности случайных чисел, вызывайте этот конструктор многократно с разными начальными значениями.</span><span class="sxs-lookup"><span data-stu-id="28b3c-318">If your application requires different random number sequences, invoke this constructor repeatedly with different seed values.</span></span> <span data-ttu-id="28b3c-319">Один из способов создания уникального начального значения — сделать его зависящим от времени.</span><span class="sxs-lookup"><span data-stu-id="28b3c-319">One way to produce a unique seed value is to make it time-dependent.</span></span> <span data-ttu-id="28b3c-320">Например, получение начального значения из системных часов, как и в <xref:System.Random.%23ctor> случае перегрузки.</span><span class="sxs-lookup"><span data-stu-id="28b3c-320">For example, derive the seed value from the system clock, as the <xref:System.Random.%23ctor> overload does.</span></span> <span data-ttu-id="28b3c-321">Однако системные часы могут не иметь достаточного разрешения, чтобы обеспечить различные вызовы этого конструктора с другим начальным значением.</span><span class="sxs-lookup"><span data-stu-id="28b3c-321">However, the system clock might not have sufficient resolution to provide different invocations of this constructor with a different seed value.</span></span> <span data-ttu-id="28b3c-322">Это приводит к созданию генераторов случайных чисел, создающих идентичные последовательности псевдослучайных чисел, как показано в первых двух <xref:System.Random> объектах в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="28b3c-322">This results in random number generators that generate identical sequences of pseudo-random numbers, as illustrated by the first two <xref:System.Random> objects in the following example.</span></span> <span data-ttu-id="28b3c-323">Чтобы избежать этого, примените алгоритм для различения начального значения при каждом вызове или вызовите <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> метод, чтобы гарантировать, что каждый конструктор будет иметь другое начальное значение.</span><span class="sxs-lookup"><span data-stu-id="28b3c-323">To prevent this, apply an algorithm to differentiate the seed value in each invocation, or call the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to ensure that you provide each constructor with a different seed value.</span></span>  
  
 [!code-csharp[System.Random.Ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor4.cs#4)]
 [!code-vb[System.Random.Ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor4.vb#4)]  
  
 <span data-ttu-id="28b3c-324">Другой вариант — создать экземпляр одного <xref:System.Random> объекта, который используется для создания всех случайных чисел в приложении.</span><span class="sxs-lookup"><span data-stu-id="28b3c-324">Another option is to instantiate a single <xref:System.Random> object that you use to generate all the random numbers in your application.</span></span> <span data-ttu-id="28b3c-325">Это дает немного более высокую производительность, поскольку создание экземпляра генератора случайных чисел занимает довольно много ресурсов.</span><span class="sxs-lookup"><span data-stu-id="28b3c-325">This yields slightly better performance, since instantiating a random number generator is fairly expensive.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="28b3c-326">В следующем примере создаются <xref:System.Random> объекты с конструктором класса, который принимает параметр SEED и создает последовательность случайных целых чисел и Double.</span><span class="sxs-lookup"><span data-stu-id="28b3c-326">The following example creates <xref:System.Random> objects with the class constructor that takes a seed parameter and generates a sequence of random integers and doubles.</span></span> <span data-ttu-id="28b3c-327">В примере показано, что та же последовательность создается при <xref:System.Random> повторном создании объекта с помощью конструктора и параметра начального значения.</span><span class="sxs-lookup"><span data-stu-id="28b3c-327">The example illustrates that the same sequence is generated when the <xref:System.Random> object is created again with the constructor and seed parameter.</span></span>  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Next">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="28b3c-328">Возвращает случайное целое число.</span><span class="sxs-lookup"><span data-stu-id="28b3c-328">Returns a random integer.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next();" />
      <MemberSignature Language="F#" Value="abstract member Next : unit -&gt; int&#xA;override this.Next : unit -&gt; int" Usage="random.Next " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="28b3c-329">Возвращает неотрицательное случайное целое число.</span><span class="sxs-lookup"><span data-stu-id="28b3c-329">Returns a non-negative random integer.</span></span></summary>
        <returns><span data-ttu-id="28b3c-330">32-разрядное целое число со знаком, которое больше или равно нулю и меньше чем <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="28b3c-330">A 32-bit signed integer that is greater than or equal to 0 and less than <see cref="F:System.Int32.MaxValue" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28b3c-331"><xref:System.Random.Next%2A?displayProperty=nameWithType>формирует случайное число, значение которого в диапазоне от 0 до <xref:System.Int32.MaxValue?displayProperty=nameWithType>меньше.</span><span class="sxs-lookup"><span data-stu-id="28b3c-331"><xref:System.Random.Next%2A?displayProperty=nameWithType> generates a random number whose value ranges from 0 to less than <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="28b3c-332">Чтобы создать случайное число, значение которого лежит в диапазоне от 0 до какого-либо другого <xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType> положительного числа, используйте перегрузку метода.</span><span class="sxs-lookup"><span data-stu-id="28b3c-332">To generate a random number whose value ranges from 0 to some other positive number, use the <xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="28b3c-333">Чтобы создать случайное число в другом диапазоне, используйте <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> перегрузку метода.</span><span class="sxs-lookup"><span data-stu-id="28b3c-333">To generate a random number within a different range, use the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="28b3c-334">В следующем примере выполняется повторный вызов <xref:System.Random.Next%2A> метода для создания определенного числа случайных чисел, запрошенных пользователем.</span><span class="sxs-lookup"><span data-stu-id="28b3c-334">The following example makes repeated calls to the <xref:System.Random.Next%2A> method to generate a specific number of random numbers requested by the user.</span></span> <span data-ttu-id="28b3c-335"><xref:System.Console.ReadLine%2A?displayProperty=nameWithType> Метод используется для получения введенных данных клиента.</span><span class="sxs-lookup"><span data-stu-id="28b3c-335">The <xref:System.Console.ReadLine%2A?displayProperty=nameWithType> method is used to get customer input.</span></span>  
  
 [!code-cpp[System.Random.Next#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next3.cpp#5)]
 [!code-csharp[System.Random.Next#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next3.cs#5)]
 [!code-vb[System.Random.Next#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next3.vb#5)]  
  
 <span data-ttu-id="28b3c-336">В следующем примере класс создается производным от <xref:System.Random> класса для создания последовательности случайных чисел, распределение которых отличается от равномерного распределения <xref:System.Random.Sample%2A> , созданного методом базового класса.</span><span class="sxs-lookup"><span data-stu-id="28b3c-336">The following example derives a class from <xref:System.Random> to generate a sequence of random numbers whose distribution differs from the uniform distribution generated by the <xref:System.Random.Sample%2A> method of the base class.</span></span> <span data-ttu-id="28b3c-337">Он переопределяет <xref:System.Random.Sample%2A> метод для предоставления распределения случайных чисел и <xref:System.Random.Next%2A?displayProperty=nameWithType> переопределяет метод для использования ряда случайных чисел.</span><span class="sxs-lookup"><span data-stu-id="28b3c-337">It overrides the <xref:System.Random.Sample%2A> method to provide the distribution of random numbers, and overrides the <xref:System.Random.Next%2A?displayProperty=nameWithType> method to use series of random numbers.</span></span>  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="28b3c-338">Начиная с версии .NET Framework 2,0, если производный класс от <see cref="T:System.Random" /> и <see cref="M:System.Random.Sample" /> переопределяет метод, распределение, предоставляемое реализацией <see cref="M:System.Random.Sample" /> производного класса метода, не используется в вызовах базового класса. <see cref="M:System.Random.Next" /> реализация метода.</span><span class="sxs-lookup"><span data-stu-id="28b3c-338">Starting with the .NET Framework version 2.0, if you derive a class from <see cref="T:System.Random" /> and override the <see cref="M:System.Random.Sample" /> method, the distribution provided by the derived class implementation of the <see cref="M:System.Random.Sample" /> method is not used in calls to the base class implementation of the <see cref="M:System.Random.Next" /> method.</span></span> <span data-ttu-id="28b3c-339">Вместо этого используется равномерное распределение, возвращаемое <see cref="T:System.Random" /> базовым классом.</span><span class="sxs-lookup"><span data-stu-id="28b3c-339">Instead, the uniform distribution returned by the base <see cref="T:System.Random" /> class is used.</span></span> <span data-ttu-id="28b3c-340">Такое поведение повышает общую производительность <see cref="T:System.Random" /> класса.</span><span class="sxs-lookup"><span data-stu-id="28b3c-340">This behavior improves the overall performance of the <see cref="T:System.Random" /> class.</span></span> <span data-ttu-id="28b3c-341">Чтобы изменить это поведение для вызова <see cref="M:System.Random.Sample" /> метода в производном классе, необходимо также <see cref="M:System.Random.Next" /> переопределить метод.</span><span class="sxs-lookup"><span data-stu-id="28b3c-341">To modify this behavior to call the <see cref="M:System.Random.Sample" /> method in the derived class, you must also override the <see cref="M:System.Random.Next" /> method.</span></span></para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int -&gt; int&#xA;override this.Next : int -&gt; int" Usage="random.Next maxValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxValue"><span data-ttu-id="28b3c-342">Эксклюзивная верхняя граница создаваемого случайного числа.</span><span class="sxs-lookup"><span data-stu-id="28b3c-342">The exclusive upper bound of the random number to be generated.</span></span> <span data-ttu-id="28b3c-343"><paramref name="maxValue" /> должно быть больше либо равно 0.</span><span class="sxs-lookup"><span data-stu-id="28b3c-343"><paramref name="maxValue" /> must be greater than or equal to 0.</span></span></param>
        <summary><span data-ttu-id="28b3c-344">Возвращает неотрицательное случайное целое число, которое меньше указанного максимального значения.</span><span class="sxs-lookup"><span data-stu-id="28b3c-344">Returns a non-negative random integer that is less than the specified maximum.</span></span></summary>
        <returns><span data-ttu-id="28b3c-345">32-разрядное целое число со знаком, большее или равное 0 и меньшее, чем <paramref name="maxValue" />. То есть диапазон возвращаемых значений включает в себя 0, но не включает <paramref name="maxValue" />.</span><span class="sxs-lookup"><span data-stu-id="28b3c-345">A 32-bit signed integer that is greater than or equal to 0, and less than <paramref name="maxValue" />; that is, the range of return values ordinarily includes 0 but not <paramref name="maxValue" />.</span></span> <span data-ttu-id="28b3c-346">Однако если значение параметра <paramref name="maxValue" /> равно нулю, возвращается значение <paramref name="maxValue" />.</span><span class="sxs-lookup"><span data-stu-id="28b3c-346">However, if <paramref name="maxValue" /> equals 0, <paramref name="maxValue" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28b3c-347">Перегрузка возвращает случайные целые числа в диапазоне от 0 до `maxValue` -1. <xref:System.Random.Next%28System.Int32%29></span><span class="sxs-lookup"><span data-stu-id="28b3c-347">The <xref:System.Random.Next%28System.Int32%29> overload returns random integers that range from 0 to `maxValue` - 1.</span></span> <span data-ttu-id="28b3c-348">Однако если `maxValue` значение равно 0, метод возвращает 0.</span><span class="sxs-lookup"><span data-stu-id="28b3c-348">However, if `maxValue` is 0, the method returns 0.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="28b3c-349">В следующем примере создаются случайные целые числа с различными перегрузками <xref:System.Random.Next%2A> метода.</span><span class="sxs-lookup"><span data-stu-id="28b3c-349">The following example generates random integers with various overloads of the <xref:System.Random.Next%2A> method.</span></span>  
  
 [!code-cpp[System.Random.Next#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next.cpp#1)]
 [!code-csharp[System.Random.Next#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next.cs#1)]
 [!code-vb[System.Random.Next#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next.vb#1)]  
  
 <span data-ttu-id="28b3c-350">В следующем примере создается случайное целое число, которое используется в качестве индекса для получения строкового значения из массива.</span><span class="sxs-lookup"><span data-stu-id="28b3c-350">The following example generates a random integer that it uses as an index to retrieve a string value from an array.</span></span> <span data-ttu-id="28b3c-351">Так как наибольший индекс массива меньше его длины, значение <xref:System.Array.Length%2A?displayProperty=nameWithType> свойства указывается как `maxValue` параметр.</span><span class="sxs-lookup"><span data-stu-id="28b3c-351">Because the highest index of the array is one less than its length, the value of the <xref:System.Array.Length%2A?displayProperty=nameWithType> property is supplied as a the `maxValue` parameter.</span></span>  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="28b3c-352">Значение параметра <paramref name="maxValue" /> меньше 0.</span><span class="sxs-lookup"><span data-stu-id="28b3c-352"><paramref name="maxValue" /> is less than 0.</span></span></exception>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int minValue, int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 minValue, int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (minValue As Integer, maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int minValue, int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int * int -&gt; int&#xA;override this.Next : int * int -&gt; int" Usage="random.Next (minValue, maxValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minValue" Type="System.Int32" />
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="minValue"><span data-ttu-id="28b3c-353">Включенный нижний предел возвращаемого случайного числа.</span><span class="sxs-lookup"><span data-stu-id="28b3c-353">The inclusive lower bound of the random number returned.</span></span></param>
        <param name="maxValue"><span data-ttu-id="28b3c-354">Исключенный верхний предел возвращаемого случайного числа.</span><span class="sxs-lookup"><span data-stu-id="28b3c-354">The exclusive upper bound of the random number returned.</span></span> <span data-ttu-id="28b3c-355">Значение свойства <paramref name="maxValue" /> должно быть больше или равно значению свойства <paramref name="minValue" />.</span><span class="sxs-lookup"><span data-stu-id="28b3c-355"><paramref name="maxValue" /> must be greater than or equal to <paramref name="minValue" />.</span></span></param>
        <summary><span data-ttu-id="28b3c-356">Возвращает случайное целое число в указанном диапазоне.</span><span class="sxs-lookup"><span data-stu-id="28b3c-356">Returns a random integer that is within a specified range.</span></span></summary>
        <returns><span data-ttu-id="28b3c-357">32-разрядное целое число со знаком большее или равное <paramref name="minValue" /> и меньше, чем <paramref name="maxValue" />; то есть, диапазон возвращаемого значения включает <paramref name="minValue" />, не включает <paramref name="maxValue" />.</span><span class="sxs-lookup"><span data-stu-id="28b3c-357">A 32-bit signed integer greater than or equal to <paramref name="minValue" /> and less than <paramref name="maxValue" />; that is, the range of return values includes <paramref name="minValue" /> but not <paramref name="maxValue" />.</span></span> <span data-ttu-id="28b3c-358">Если значение параметра <paramref name="minValue" /> равно значению параметра <paramref name="maxValue" />, то возвращается значение <paramref name="minValue" />.</span><span class="sxs-lookup"><span data-stu-id="28b3c-358">If <paramref name="minValue" /> equals <paramref name="maxValue" />, <paramref name="minValue" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28b3c-359">Перегрузка возвращает случайные целые числа в диапазоне от `minValue` до `maxValue` – 1. <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29></span><span class="sxs-lookup"><span data-stu-id="28b3c-359">The <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> overload returns random integers that range from `minValue` to `maxValue` - 1.</span></span> <span data-ttu-id="28b3c-360">Однако, если `maxValue` равно `minValue`, метод возвращает `minValue`значение.</span><span class="sxs-lookup"><span data-stu-id="28b3c-360">However, if `maxValue` equals `minValue`, the method returns `minValue`.</span></span>  
  
 <span data-ttu-id="28b3c-361">В отличие от других перегрузок <xref:System.Random.Next%2A> метода, которые возвращают только неотрицательные значения, этот метод может возвращать отрицательное случайное целое число.</span><span class="sxs-lookup"><span data-stu-id="28b3c-361">Unlike the other overloads of the <xref:System.Random.Next%2A> method, which return only non-negative values, this method can return a negative random integer.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="28b3c-362">В следующем примере <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> метод используется для создания случайных целых чисел с тремя разными диапазонами.</span><span class="sxs-lookup"><span data-stu-id="28b3c-362">The following example uses the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method to generate random integers with three distinct ranges.</span></span> <span data-ttu-id="28b3c-363">Обратите внимание, что точный результат из этого примера зависит от предоставленного системой начального значения, переданного <xref:System.Random> конструктору класса.</span><span class="sxs-lookup"><span data-stu-id="28b3c-363">Note that the exact output from the example depends on the system-supplied seed value passed to the <xref:System.Random> class constructor.</span></span>  
  
 [!code-cpp[System.Random.Next#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next2.cpp#2)]
 [!code-csharp[System.Random.Next#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/Next2.cs#2)]
 [!code-vb[System.Random.Next#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next2.vb#2)]  
  
 <span data-ttu-id="28b3c-364">В следующем примере создается случайное целое число, которое используется в качестве индекса для получения строкового значения из массива.</span><span class="sxs-lookup"><span data-stu-id="28b3c-364">The following example generates a random integer that it uses as an index to retrieve a string value from an array.</span></span> <span data-ttu-id="28b3c-365">Так как наибольший индекс массива меньше его длины, значение <xref:System.Array.Length%2A?displayProperty=nameWithType> свойства указывается как `maxValue` параметр.</span><span class="sxs-lookup"><span data-stu-id="28b3c-365">Because the highest index of the array is one less than its length, the value of the <xref:System.Array.Length%2A?displayProperty=nameWithType> property is supplied as a the `maxValue` parameter.</span></span>  
  
 [!code-cpp[System.Random.Next#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next4.cpp#4)]
 [!code-csharp[System.Random.Next#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next4.cs#4)]
 [!code-vb[System.Random.Next#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="28b3c-366">Значение <paramref name="minValue" /> больше значения <paramref name="maxValue" />.</span><span class="sxs-lookup"><span data-stu-id="28b3c-366"><paramref name="minValue" /> is greater than <paramref name="maxValue" />.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="28b3c-367">Начиная с версии .NET Framework 2,0, если производный класс от <see cref="T:System.Random" /> и <see cref="M:System.Random.Sample" /> переопределяет метод, распределение, предоставляемое реализацией <see cref="M:System.Random.Sample" /> производного класса метода, не используется в вызовах базового класса. Реализация перегрузки <paramref name="minValue" /> <paramref name="maxValue" /> <see cref="F:System.Int32.MaxValue" />метода, если разница между параметрами и больше. <see cref="M:System.Random.Next(System.Int32,System.Int32)" /></span><span class="sxs-lookup"><span data-stu-id="28b3c-367">Starting with the .NET Framework version 2.0, if you derive a class from <see cref="T:System.Random" /> and override the <see cref="M:System.Random.Sample" /> method, the distribution provided by the derived class implementation of the <see cref="M:System.Random.Sample" /> method is not used in calls to the base class implementation of the <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> method overload if the difference between the <paramref name="minValue" /> and <paramref name="maxValue" /> parameters is greater than <see cref="F:System.Int32.MaxValue" />.</span></span> <span data-ttu-id="28b3c-368">Вместо этого используется равномерное распределение, возвращаемое <see cref="T:System.Random" /> базовым классом.</span><span class="sxs-lookup"><span data-stu-id="28b3c-368">Instead, the uniform distribution returned by the base <see cref="T:System.Random" /> class is used.</span></span> <span data-ttu-id="28b3c-369">Такое поведение повышает общую производительность <see cref="T:System.Random" /> класса.</span><span class="sxs-lookup"><span data-stu-id="28b3c-369">This behavior improves the overall performance of the <see cref="T:System.Random" /> class.</span></span> <span data-ttu-id="28b3c-370">Чтобы изменить это поведение для вызова <see cref="M:System.Random.Sample" /> метода в производном классе, необходимо также <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> переопределить перегрузку метода.</span><span class="sxs-lookup"><span data-stu-id="28b3c-370">To modify this behavior to call the <see cref="M:System.Random.Sample" /> method in the derived class, you must also override the <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> method overload.</span></span></para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : byte[] -&gt; unit&#xA;override this.NextBytes : byte[] -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="28b3c-371">Массив байтов, содержащий случайные числа.</span><span class="sxs-lookup"><span data-stu-id="28b3c-371">An array of bytes to contain random numbers.</span></span></param>
        <summary><span data-ttu-id="28b3c-372">Заполняет элементы указанного массива байтов случайными числами.</span><span class="sxs-lookup"><span data-stu-id="28b3c-372">Fills the elements of a specified array of bytes with random numbers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28b3c-373">Каждому элементу массива байтов присваивается случайное число, которое больше или равно 0 и меньше или равно <xref:System.Byte.MaxValue>.</span><span class="sxs-lookup"><span data-stu-id="28b3c-373">Each element of the array of bytes is set to a random number greater than or equal to 0, and less than or equal to <xref:System.Byte.MaxValue>.</span></span>  
  
 <span data-ttu-id="28b3c-374">Например, чтобы создать криптографически защищенный случайный номер, подходящий для создания случайного пароля, используйте такой метод, как <xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="28b3c-374">For example, to generate a cryptographically secured random number suitable for creating a random password, use a method such as <xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="28b3c-375">В следующем примере показано, как использовать <xref:System.Random.NextBytes%2A> метод для заполнения массива байтов произвольными байтовыми значениями.</span><span class="sxs-lookup"><span data-stu-id="28b3c-375">The following example demonstrates how to use the <xref:System.Random.NextBytes%2A> method to fill an array of bytes with random byte values.</span></span>  
  
 [!code-cpp[Classic Random.NextBytes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Random.NextBytes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CS/source.cs#1)]
 [!code-vb[Classic Random.NextBytes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="28b3c-376">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="28b3c-376"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="28b3c-377">Начиная с версии .NET Framework 2,0, если производный класс от <see cref="T:System.Random" /> и <see cref="M:System.Random.Sample" /> переопределяет метод, распределение, предоставляемое реализацией <see cref="M:System.Random.Sample" /> производного класса метода, не используется в вызовах базового класса. <see cref="M:System.Random.NextBytes(System.Byte[])" /> реализация метода.</span><span class="sxs-lookup"><span data-stu-id="28b3c-377">Starting with the .NET Framework version 2.0, if you derive a class from <see cref="T:System.Random" /> and override the <see cref="M:System.Random.Sample" /> method, the distribution provided by the derived class implementation of the <see cref="M:System.Random.Sample" /> method is not used in calls to the base class implementation of the <see cref="M:System.Random.NextBytes(System.Byte[])" /> method.</span></span> <span data-ttu-id="28b3c-378">Вместо этого используется равномерное распределение, возвращаемое <see cref="T:System.Random" /> базовым классом.</span><span class="sxs-lookup"><span data-stu-id="28b3c-378">Instead, the uniform distribution returned by the base <see cref="T:System.Random" /> class is used.</span></span> <span data-ttu-id="28b3c-379">Такое поведение повышает общую производительность <see cref="T:System.Random" /> класса.</span><span class="sxs-lookup"><span data-stu-id="28b3c-379">This behavior improves the overall performance of the <see cref="T:System.Random" /> class.</span></span> <span data-ttu-id="28b3c-380">Чтобы изменить это поведение для вызова <see cref="M:System.Random.Sample" /> метода в производном классе, необходимо также <see cref="M:System.Random.NextBytes(System.Byte[])" /> переопределить метод.</span><span class="sxs-lookup"><span data-stu-id="28b3c-380">To modify this behavior to call the <see cref="M:System.Random.Sample" /> method in the derived class, you must also override the <see cref="M:System.Random.NextBytes(System.Byte[])" /> method.</span></span></para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Span(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : Span&lt;byte&gt; -&gt; unit&#xA;override this.NextBytes : Span&lt;byte&gt; -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NextDouble">
      <MemberSignature Language="C#" Value="public virtual double NextDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 NextDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function NextDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double NextDouble();" />
      <MemberSignature Language="F#" Value="abstract member NextDouble : unit -&gt; double&#xA;override this.NextDouble : unit -&gt; double" Usage="random.NextDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="28b3c-381">Возвращает случайное число с плавающей запятой, которое больше или равно 0,0 и меньше 1,0.</span><span class="sxs-lookup"><span data-stu-id="28b3c-381">Returns a random floating-point number that is greater than or equal to 0.0, and less than 1.0.</span></span></summary>
        <returns><span data-ttu-id="28b3c-382">Число двойной точности с плавающей запятой, которое больше или равно 0,0, и меньше 1,0.</span><span class="sxs-lookup"><span data-stu-id="28b3c-382">A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28b3c-383">Фактическая верхняя граница случайного числа, возвращаемого этим методом, — 0.99999999999999978.</span><span class="sxs-lookup"><span data-stu-id="28b3c-383">The actual upper bound of the random number returned by this method is 0.99999999999999978.</span></span>  
  
 <span data-ttu-id="28b3c-384">Чтобы получить случайные значения с плавающей запятой в диапазоне, отличном от 0,0 и 1,0, см. раздел <xref:System.Random> "получение значений с плавающей запятой в указанном диапазоне" раздела класса.</span><span class="sxs-lookup"><span data-stu-id="28b3c-384">To retrieve random floating-point values within a range other than 0.0 and 1.0, see the "Retrieve floating-point values in a specified range" section of the <xref:System.Random> class topic.</span></span>  
  
 <span data-ttu-id="28b3c-385">Этот метод является общедоступной версией защищенного метода <xref:System.Random.Sample%2A>.</span><span class="sxs-lookup"><span data-stu-id="28b3c-385">This method is the public version of the protected method, <xref:System.Random.Sample%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="28b3c-386">В следующем примере <xref:System.Random.NextDouble%2A> метод используется для создания последовательностей случайных чисел типа Double.</span><span class="sxs-lookup"><span data-stu-id="28b3c-386">The following example uses the <xref:System.Random.NextDouble%2A> method to generate sequences of random doubles.</span></span>  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 <span data-ttu-id="28b3c-387">В следующем примере вызывается <xref:System.Random.NextDouble%2A> метод для создания 100 случайных чисел и отображения частоты их распределения.</span><span class="sxs-lookup"><span data-stu-id="28b3c-387">The following example calls the <xref:System.Random.NextDouble%2A> method to generate 100 random numbers and displays their frequency distribution.</span></span>  
  
 [!code-csharp[System.Random.NextDouble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.random.nextdouble/cs/nextdouble1.cs#2)]
 [!code-vb[System.Random.NextDouble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.random.nextdouble/vb/nextdouble1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sample">
      <MemberSignature Language="C#" Value="protected virtual double Sample ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance float64 Sample() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Sample" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Sample () As Double" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual double Sample();" />
      <MemberSignature Language="F#" Value="abstract member Sample : unit -&gt; double&#xA;override this.Sample : unit -&gt; double" Usage="random.Sample " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="28b3c-388">Возвращает случайное число с плавающей запятой в диапазоне от 0,0 до 1,0.</span><span class="sxs-lookup"><span data-stu-id="28b3c-388">Returns a random floating-point number between 0.0 and 1.0.</span></span></summary>
        <returns><span data-ttu-id="28b3c-389">Число двойной точности с плавающей запятой, которое больше или равно 0,0, и меньше 1,0.</span><span class="sxs-lookup"><span data-stu-id="28b3c-389">A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28b3c-390">Для создания другого случайного распределения или другого принципа генератора случайных чисел следует наследовать класс от <xref:System.Random> класса и <xref:System.Random.Sample%2A> переопределить метод.</span><span class="sxs-lookup"><span data-stu-id="28b3c-390">To produce a different random distribution or a different random number generator principle, derive a class from the <xref:System.Random> class and override the <xref:System.Random.Sample%2A> method.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="28b3c-391">Метод — `protected`это, что означает, что он доступен только внутри <xref:System.Random> класса и его производных классов. <xref:System.Random.Sample%2A></span><span class="sxs-lookup"><span data-stu-id="28b3c-391">The <xref:System.Random.Sample%2A> method is `protected`, which means that it is accessible only within the <xref:System.Random> class and its derived classes.</span></span> <span data-ttu-id="28b3c-392">Чтобы создать случайное число от 0 до 1 из <xref:System.Random> экземпляра, <xref:System.Random.NextDouble%2A> вызовите метод.</span><span class="sxs-lookup"><span data-stu-id="28b3c-392">To generate a random number between 0 and 1 from a <xref:System.Random> instance, call the <xref:System.Random.NextDouble%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="28b3c-393">Следующий пример является производным от класса <xref:System.Random> и <xref:System.Random.Sample%2A> переопределяет метод для создания распределения случайных чисел.</span><span class="sxs-lookup"><span data-stu-id="28b3c-393">The following example derives a class from <xref:System.Random> and overrides the <xref:System.Random.Sample%2A> method to generate a distribution of random numbers.</span></span> <span data-ttu-id="28b3c-394">Это распределение отличается от равномерного распределения, <xref:System.Random.Sample%2A> созданного методом базового класса.</span><span class="sxs-lookup"><span data-stu-id="28b3c-394">This distribution is different than the uniform distribution generated by the <xref:System.Random.Sample%2A> method of the base class.</span></span>  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="28b3c-395">Начиная с версии .NET Framework 2,0, если производный класс от <see cref="T:System.Random" /> и <see cref="M:System.Random.Sample" /> переопределяет метод, распределение, предоставляемое реализацией <see cref="M:System.Random.Sample" /> производного класса метода, не используется в вызовах базового класса. реализация следующих методов:</span><span class="sxs-lookup"><span data-stu-id="28b3c-395">Starting with the .NET Framework version 2.0, if you derive a class from <see cref="T:System.Random" /> and override the <see cref="M:System.Random.Sample" /> method, the distribution provided by the derived class implementation of the <see cref="M:System.Random.Sample" /> method is not used in calls to the base class implementation of the following methods:</span></span> 
<span data-ttu-id="28b3c-396">– метод <see cref="M:System.Random.NextBytes(System.Byte[])" />.</span><span class="sxs-lookup"><span data-stu-id="28b3c-396">-   The <see cref="M:System.Random.NextBytes(System.Byte[])" /> method.</span></span>  
  
<span data-ttu-id="28b3c-397">– метод <see cref="M:System.Random.Next" />.</span><span class="sxs-lookup"><span data-stu-id="28b3c-397">-   The <see cref="M:System.Random.Next" /> method.</span></span>  
  
<span data-ttu-id="28b3c-398"><paramref name="maxValue" /> - — Метод, если <see cref="F:System.Int32.MaxValue" />()больше,чем<paramref name="minValue" />. <see cref="M:System.Random.Next(System.Int32,System.Int32)" /></span><span class="sxs-lookup"><span data-stu-id="28b3c-398">-   The <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> method, if (<paramref name="maxValue" /> - <paramref name="minValue" />) is greater than <see cref="F:System.Int32.MaxValue" />.</span></span>  
  
<span data-ttu-id="28b3c-399">Вместо этого используется равномерное распределение, предоставляемое <see cref="T:System.Random" /> базовым классом.</span><span class="sxs-lookup"><span data-stu-id="28b3c-399">Instead, the uniform distribution provided by the base <see cref="T:System.Random" /> class is used.</span></span> <span data-ttu-id="28b3c-400">Такое поведение повышает общую производительность <see cref="T:System.Random" /> класса.</span><span class="sxs-lookup"><span data-stu-id="28b3c-400">This behavior improves the overall performance of the <see cref="T:System.Random" /> class.</span></span> <span data-ttu-id="28b3c-401">Чтобы изменить это поведение для вызова реализации <see cref="M:System.Random.Sample" /> метода в производном классе, необходимо также переопределить поведение этих трех членов.</span><span class="sxs-lookup"><span data-stu-id="28b3c-401">To modify this behavior to call the implementation of the <see cref="M:System.Random.Sample" /> method in the derived class, you must also override the behavior of these three members.</span></span> <span data-ttu-id="28b3c-402">Иллюстрация приведена в примере.</span><span class="sxs-lookup"><span data-stu-id="28b3c-402">The example provides an illustration.</span></span></para></block>
        <altmember cref="M:System.Random.NextDouble" />
      </Docs>
    </Member>
  </Members>
</Type>
