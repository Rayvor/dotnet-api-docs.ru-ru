<Type Name="Random" FullName="System.Random">
  <Metadata><Meta Name="ms.openlocfilehash" Value="71b93b24a898b0e77a8fd8f829c6a1351133af47" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75172405" /></Metadata><TypeSignature Language="C#" Value="public class Random" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Random extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Random" />
  <TypeSignature Language="VB.NET" Value="Public Class Random" />
  <TypeSignature Language="C++ CLI" Value="public ref class Random" />
  <TypeSignature Language="F#" Value="type Random = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет генератор псевдослучайных чисел, то есть устройство, которое выдает последовательность чисел, отвечающую определенным статистическим критериям случайности.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Псевдо-случайные числа выбираются с равной вероятностью из конечного набора чисел. Выбранные числа не являются полностью случайными, поскольку для их выбора используется математический алгоритм, но они достаточно случайные для практических целей. Текущая реализация класса <xref:System.Random> основана на измененной версии алгоритма генератора случайных чисел с вычитанием Дональд E. кнута. Дополнительные сведения см. в разделе D. E. Кнута. *Искусство компьютерной программирования, том 2: алгоритмы семинумерикал*. Addison-Wesley, чтение, MA, третий выпуск, 1997.  
  
 Чтобы создать криптографически защищенное случайное число, например подходящее для создания случайного пароля, используйте класс <xref:System.Security.Cryptography.RNGCryptoServiceProvider> или создайте производный класс от <xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType>.  
  
 В этом разделе.  
  
 [Создание экземпляра генератора случайных чисел](#Instantiate)   
 [Предотвращение создания нескольких экземпляров](#Multiple)   
 [Класс System. Random и безопасность потоков](#ThreadSafety)   
 [Создание различных типов случайных чисел](#Functionality)   
 [Подстановка собственного алгоритма](#Overriding)   
 [Как использовать System. Random to...](#Operations)   
 [Получение той же последовательности случайных значений](#Same)  
 [Получение уникальных последовательностей случайных значений](#Unique)  
 [Получение целых чисел в указанном диапазоне](#Range)  
 [Получение целых чисел с указанным числом цифр](#Digits)  
 [Получение значений с плавающей запятой в указанном диапазоне](#Floats)  
 [Создание случайных логических значений](#Boolean)  
 [Создавать случайные 64-разрядные целые числа](#Long)  
 [Извлечение байтов в указанном диапазоне](#Bytes)  
 [Извлечение элемента из массива или коллекции в случайном порядке](#Array)  
 [Извлечение уникального элемента из массива или коллекции](#UniqueArray)  
  
<a name="Instantiate"></a>   
## <a name="instantiating-the-random-number-generator"></a>Создание экземпляра генератора случайных чисел  
 Чтобы создать экземпляр генератора случайных чисел, укажите начальное значение (начальное значение для алгоритма формирования псевдо-случайных чисел) в конструкторе класса <xref:System.Random.%23ctor%2A>.  Начальное значение можно указать явно или неявно:  
  
-   Конструктор <xref:System.Random.%23ctor%28System.Int32%29> использует явно указываемое начальное значение.  
  
-   Конструктор <xref:System.Random.%23ctor> использует системные часы для предоставления начального значения. Это наиболее распространенный способ создания экземпляра генератора случайных чисел.  
  
 Если одно и то же начальное значение используется для отдельных объектов <xref:System.Random>, они будут создавать одинаковые серии случайных чисел. Это может быть полезно для создания набора тестов, который обрабатывает случайные значения или для воспроизведения игр, которые наследуют данные от случайных чисел. Однако обратите внимание, что <xref:System.Random> объекты в процессах, выполняющихся в разных версиях .NET Framework, могут возвращать разные серии случайных чисел, даже если они создаются с одинаковыми начальными значениями.  
  
 Для создания различных последовательностей случайных чисел можно сделать начальное значение зависимым от времени, тем самым создавая другой ряд с каждым новым экземпляром <xref:System.Random>. Параметризованный конструктор <xref:System.Random.%23ctor%28System.Int32%29> может принимать <xref:System.Int32> значение в зависимости от количества тактов в текущем времени, тогда как конструктор без параметров <xref:System.Random.%23ctor> использует системные часы для создания начального значения. Однако только на .NET Framework, поскольку часы имеют конечное разрешение, использование конструктора без параметров для создания различных <xref:System.Random> объектов в случае закрытия приведет к созданию генераторов случайных чисел, создающих идентичные последовательности случайных чисел. В следующем примере показано, как два <xref:System.Random> объектов, создаваемых в приложении .NET Framework, создают идентичные последовательности случайных чисел. В большинстве систем Windows <xref:System.Random> объекты, созданные в течение 15 миллисекунд, могут иметь одинаковые начальные значения.  
  
 [!code-cpp[System.Random#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random1.cpp#1)]
 [!code-csharp[System.Random#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random1.cs#1)]
 [!code-vb[System.Random#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random1.vb#1)]  
  
Чтобы избежать этой проблемы, создайте один объект <xref:System.Random>, а не несколько объектов. Обратите внимание на то, что класс `Random` в .NET Core не имеет этого ограничения.
  
<a name="Multiple"></a>   
## <a name="avoiding-multiple-instantiations"></a>Предотвращение нескольких экземпляров  
 На .NET Framework инициализация двух генераторов случайных чисел в тесном цикле или при быстром выполнении создает два генератора случайных чисел, которые могут формировать идентичные последовательности случайных чисел. В большинстве случаев это не является намерением разработчика и может привести к проблемам с производительностью, поскольку создание и инициализация генератора случайных чисел является сравнительно дорогостоящим процессом.  
  
 Чтобы повысить производительность и избежать случайного создания отдельных генераторов случайных чисел, создающих идентичные числовые последовательности, рекомендуется создать один объект <xref:System.Random> для создания множества случайных чисел в течение времени, вместо создания новых <xref:System.Random> объектов для создания одного случайного числа.  
  
 Однако класс <xref:System.Random> не является потокобезопасным. При вызове <xref:System.Random> методов из нескольких потоков следуйте рекомендациям, изложенным в следующем разделе.  
  
<a name="ThreadSafety"></a>   
## <a name="the-systemrandom-class-and-thread-safety"></a>Класс System. Random и безопасность потоков  
 Вместо создания экземпляров отдельных объектов <xref:System.Random> рекомендуется создать один экземпляр <xref:System.Random>, чтобы создать все случайные числа, необходимые для приложения. Однако <xref:System.Random> объекты не являются потокобезопасными. Если приложение вызывает <xref:System.Random> методы из нескольких потоков, необходимо использовать объект синхронизации, чтобы убедиться, что только один поток может одновременно получить доступ к генератору случайных чисел. Если не гарантировать, что доступ к <xref:System.Random> объекту осуществляется потокобезопасным способом, вызовы методов, возвращающих случайные числа, возвращают 0.  
  
 В следующем примере используется C# [оператор lock](~/docs/csharp/language-reference/keywords/lock-statement.md) и [оператор Visual Basic SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) , чтобы гарантировать, что один генератор случайных чисел обращается к 11 потокам потокобезопасным образом. Каждый поток создает 2 000 000 случайных чисел, подсчитывает количество создаваемых случайных чисел и вычисляет их сумму, а затем обновляет итоги для всех потоков после завершения выполнения.  
  
 [!code-cpp[System.Random#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/threadsafeex1.cpp#3)]
 [!code-csharp[System.Random#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex1.cs#3)]
 [!code-vb[System.Random#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex1.vb#3)]  
  
 В примере безопасность потоков обеспечивается следующими способами.  
  
-   Атрибут <xref:System.ThreadStaticAttribute> используется для определения локальных переменных потока, которые отправляют общее число формируемых случайных чисел и их сумму для каждого потока.  
  
-   Блокировка (оператор `lock` в C# и инструкция `SyncLock` в Visual Basic) защищает доступ к переменным для общего количества и суммирования всех случайных чисел, созданных во всех потоках.  
  
-   Семафор (объект <xref:System.Threading.CountdownEvent>) используется, чтобы обеспечить блокировку основного потока до завершения выполнения всех остальных потоков.  
  
-   В примере проверяется, поврежден ли генератор случайных чисел, путем определения, будут ли два последовательных вызова методов генерации случайных чисел возвращать 0. Если обнаружено повреждение, в примере используется объект <xref:System.Threading.CancellationTokenSource> для сигнализации о том, что все потоки должны быть отменены.  
  
-   Перед созданием каждого случайного числа каждый поток проверяет состояние объекта <xref:System.Threading.CancellationToken>. При запросе отмены в примере вызывается метод <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> для отмены потока.  
  
 Следующий пример идентичен первому, за исключением того, что он использует объект <xref:System.Threading.Tasks.Task> и лямбда-выражение вместо <xref:System.Threading.Thread> объектов.  
  
 [!code-csharp[System.Random#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex2.cs#4)]
 [!code-vb[System.Random#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex2.vb#4)]  
  
 Он отличается от первого примера следующими способами.  
  
-   Переменные, которые следует отследить от количества формируемых случайных чисел и их сумму в каждой задаче, являются локальными для задачи, поэтому нет необходимости использовать атрибут <xref:System.ThreadStaticAttribute>.  
  
-   Статический метод <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> используется, чтобы гарантировать, что главный поток не завершится до завершения всех задач. Объект <xref:System.Threading.CountdownEvent> не требуется.  
  
-   Исключение, полученное в результате отмены задачи, отображается в методе <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType>. В предыдущем примере он обрабатывается каждым потоком.  
  
<a name="Functionality"></a>   
## <a name="generating-different-types-of-random-numbers"></a>Создание различных типов случайных чисел  
 Генератор случайных чисел предоставляет методы, позволяющие создавать следующие виды случайных чисел:  
  
-   Ряд значений <xref:System.Byte>. Вы определяете количество байтовых значений, передавая массив, инициализируемый в число элементов, которые метод должен вернуть в метод <xref:System.Random.NextBytes%2A>. Следующий пример приводит к возникновению 20 байтов.  
  
     [!code-cpp[System.Random#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextbytes1.cpp#5)]
     [!code-csharp[System.Random#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextbytes1.cs#5)]
     [!code-vb[System.Random#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextbytes1.vb#5)]  
  
-   Одно целое число. Можно выбрать, требуется ли целое число от 0 до максимального значения (<xref:System.Int32.MaxValue?displayProperty=nameWithType>-1), вызвав метод <xref:System.Random.Next>, целое число от 0 до определенного значения, вызвав метод <xref:System.Random.Next%28System.Int32%29> или целое число в диапазоне значений, вызвав метод <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>. В параметризованных перегрузках указанное максимальное значение является эксклюзивным; то есть фактическое максимальное число, созданное на единицу, меньше указанного значения.  
  
     В следующем примере вызывается метод <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> для создания 10 случайных чисел в диапазоне от-10 до 10. Обратите внимание, что второй аргумент метода указывает эксклюзивную верхнюю границу диапазона случайных значений, возвращаемых методом. Иными словами, самое большое целое число, которое метод может вернуть, меньше этого значения.  
  
     [!code-cpp[System.Random#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextex1.cpp#6)]
     [!code-csharp[System.Random#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextex1.cs#6)]
     [!code-vb[System.Random#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextex1.vb#6)]  
  
-   Одиночное значение с плавающей запятой от 0,0 до меньше 1,0 путем вызова метода <xref:System.Random.NextDouble%2A>. Эксклюзивная верхняя граница случайного числа, возвращаемого методом, — 1, поэтому фактическая верхняя граница — 0.99999999999999978. В следующем примере создаются 10 случайных чисел с плавающей запятой.  
  
     [!code-cpp[System.Random#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextdoubleex1.cpp#7)]
     [!code-csharp[System.Random#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextdoubleex1.cs#7)]
     [!code-vb[System.Random#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextdoubleex1.vb#7)]  
  
> [!IMPORTANT]
>  Метод <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> позволяет указать диапазон возвращаемого случайного числа. Однако параметр `maxValue`, указывающий верхний возвращенный диапазон, является эксклюзивным, а не инклюзивным значением. Это означает, что вызов метода `Next(0, 100)` возвращает значение от 0 до 99, а не между 0 и 100.  
  
 Можно также использовать класс <xref:System.Random> для таких задач, как создание [случайных значений T:System.Boolean](#Boolean), создание [случайных значений с плавающей запятой с диапазоном, отличным от 0 до 1](#Floats), создание [случайных 64-разрядных целых чисел](#Long)и [случайное извлечение уникального элемента из массива или коллекции](#UniqueArray). Эти и другие распространенные задачи см. в разделе [как использовать System. Random to...](#Operations) .  
  
<a name="Overriding"></a>   
## <a name="substituting-your-own-algorithm"></a>Замена собственного алгоритма  
 Вы можете реализовать собственный генератор случайных чисел, наследуя от класса <xref:System.Random> и предоставив алгоритм создания случайных чисел. Чтобы указать собственный алгоритм, необходимо переопределить метод <xref:System.Random.Sample%2A>, который реализует алгоритм создания случайных чисел. Также следует переопределить методы <xref:System.Random.Next>, <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>и <xref:System.Random.NextBytes%2A>, чтобы убедиться, что они вызывают переопределенный метод <xref:System.Random.Sample%2A>. Вам не нужно переопределять методы <xref:System.Random.Next%28System.Int32%29> и <xref:System.Random.NextDouble%2A>.  
  
 Пример, который является производным от класса <xref:System.Random> и изменяет генератор псевдослучайных чисел, используемый по умолчанию, см. на странице ссылки на <xref:System.Random.Sample%2A>.  
  
<a name="Operations"></a>   
## <a name="how-do-you-use-systemrandom-to"></a>Как использовать System. Random to...  
 В следующих разделах приводятся примеры кода для некоторых способов использования случайных чисел в приложении.  
  
<a name="Same"></a>   
### <a name="retrieve-the-same-sequence-of-random-values"></a>Получение той же последовательности случайных значений  
 Иногда требуется создать одну и ту же последовательность случайных чисел в сценариях тестирования программного обеспечения и в игре. Проверка с одинаковой последовательностью случайных чисел позволяет обнаруживать регрессию и подтверждать исправления ошибок. Использование одинаковой последовательности случайных чисел в играх позволяет воспроизводить предыдущие игры.  
  
 Можно создать одну и ту же последовательность случайных чисел, указав одно и то же начальное значение для конструктора <xref:System.Random.%23ctor%28System.Int32%29>. Начальное значение предоставляет начальное значение для алгоритма формирования псевдослучайных чисел. В следующем примере используется 100100 в качестве произвольного начального значения для создания экземпляра объекта <xref:System.Random>, выводится 20 случайных значений с плавающей запятой и сохраняется начальное значение. Затем оно восстанавливает начальное значение, создает новый генератор случайных чисел и отображает те же 20 случайных значений с плавающей точкой.  Обратите внимание, что в примере могут формироваться различные последовательности случайных чисел, если они работают в разных версиях .NET Framework.  
  
 [!code-cpp[System.Random#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/same1.cpp#12)]
 [!code-csharp[System.Random#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/same1.cs#12)]
 [!code-vb[System.Random#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/same1.vb#12)]  
  
<a name="Unique"></a>   
### <a name="retrieve-unique-sequences-of-random-numbers"></a>Получение уникальных последовательностей случайных чисел  
 Предоставление различных начальных значений экземплярам класса <xref:System.Random> приводит к тому, что каждый генератор случайных чисел создает другую последовательность значений. Начальное значение можно указать либо явно, вызвав конструктор <xref:System.Random.%23ctor%28System.Int32%29>, либо неявно, вызвав конструктор <xref:System.Random.%23ctor>. Большинство разработчиков вызывают конструктор без параметров, который использует системные часы. В следующем примере используется этот подход для создания экземпляра двух <xref:System.Random> экземпляров. Каждый экземпляр отображает последовательность из 10 случайных целых чисел.  
  
 [!code-cpp[System.Random#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/unique.cpp#13)]
 [!code-csharp[System.Random#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/unique.cs#13)]
 [!code-vb[System.Random#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/unique.vb#13)]  
  
 Однако из-за его конечного разрешения системные часы не обнаруживают разницы во времени, которые менее 15 миллисекунд. Таким образом, если код вызывает перегрузку <xref:System.Random.%23ctor> в .NET Framework для последующего создания экземпляров двух объектов <xref:System.Random>, вы можете случайно предоставить объекты с одинаковыми начальными значениями. (Класс <xref:System.Random> в .NET Core не имеет этого ограничения.) Чтобы увидеть это в предыдущем примере, закомментируйте вызов метода <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>, а затем скомпилируйте и запустите пример еще раз.  
  
 Чтобы предотвратить это, рекомендуется создать экземпляр одного <xref:System.Random> объекта, а не нескольких. Однако поскольку <xref:System.Random> не является потокобезопасным, необходимо использовать некоторое устройство синхронизации при доступе к экземпляру <xref:System.Random> из нескольких потоков. Дополнительные сведения см. в разделе [случайный класс и безопасность потоков](#ThreadSafety) ранее в этой статье. Кроме того, можно использовать механизм задержки, например метод <xref:System.Threading.Thread.Sleep%2A>, используемый в предыдущем примере, чтобы убедиться в том, что создание экземпляров происходит более чем на 15 миллисекунд.  
  
<a name="Range"></a>   
### <a name="retrieve-integers-in-a-specified-range"></a>Получение целых чисел в указанном диапазоне  
 Вы можете получить целые числа в указанном диапазоне, вызвав метод <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>, который позволяет указать нижнюю и верхнюю границы чисел, которые нужно вернуть генератору случайных чисел. Верхняя граница — это эксклюзивное, а не инклюзивное значение. То есть он не включается в диапазон значений, возвращаемых методом. В следующем примере этот метод используется для создания случайных целых чисел от-10 до 10. Обратите внимание, что в нем указано значение 11, которое больше, чем требуемое значение, в качестве значения аргумента `maxValue` в вызове метода.  
  
 [!code-cpp[System.Random#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range1.cpp#15)]
 [!code-csharp[System.Random#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range1.cs#15)]
 [!code-vb[System.Random#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range1.vb#15)]  
  
<a name="Digits"></a>   
### <a name="retrieve-integers-with-a-specified-number-of-digits"></a>Получение целых чисел с указанным числом цифр  
 Можно вызвать метод <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> для получения чисел с указанным числом цифр. Например, чтобы получить числа с четырьмя цифрами (т. е. числа в диапазоне от 1000 до 9999), вызовите метод <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> с `minValue`ным значением 1000 и `maxValue` значением 10000, как показано в следующем примере.  
  
 [!code-cpp[System.Random#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range2.cpp#16)]
 [!code-csharp[System.Random#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range2.cs#16)]
 [!code-vb[System.Random#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range2.vb#16)]  
  
<a name="Floats"></a>   
### <a name="retrieve-floating-point-values-in-a-specified-range"></a>Получение значений с плавающей запятой в указанном диапазоне  
 Метод <xref:System.Random.NextDouble%2A> возвращает случайные значения с плавающей запятой в диапазоне от 0 до меньше 1. Однако часто требуется создавать случайные значения в каком бы то ни было другом диапазоне.  
  
 Если интервал между минимальным и максимальным требуемыми значениями равен 1, можно добавить разницу между требуемым начальным интервалом и значением 0 для числа, возвращаемого методом <xref:System.Random.NextDouble%2A>. В следующем примере это делается для создания 10 случайных чисел в диапазоне от-1 до 0.  
  
 [!code-cpp[System.Random#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange2.cpp#17)]
 [!code-csharp[System.Random#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange2.cs#17)]
 [!code-vb[System.Random#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange2.vb#17)]  
  
 Для создания случайных чисел с плавающей запятой, Нижняя граница которых равна 0, но верхняя граница больше 1 (или, в случае отрицательных чисел, Нижняя граница которой меньше-1, а верхняя граница равна 0), умножьте случайное число на ненулевую границу. В следующем примере это делается для создания 20 000 000 случайных чисел с плавающей запятой в диапазоне от 0 до <xref:System.Int64.MaxValue?displayProperty=nameWithType>. В также отображает распределение случайных значений, созданных методом.  
  
 [!code-cpp[System.Random#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange1.cpp#18)]
 [!code-csharp[System.Random#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange1.cs#18)]
 [!code-vb[System.Random#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange1.vb#18)]  
  
 Чтобы создать случайные числа с плавающей запятой между двумя произвольными значениями, например метод <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> выполняет для целых чисел, используйте следующую формулу:  
  
```csharp  
Random.NextDouble() * (maxValue - minValue) + minValue  
```  
  
 Следующий пример приводит к возникновению ошибки 1 000 000 случайных чисел в диапазоне от 10,0 до 11,0 и отображении их распределения.  
  
 [!code-cpp[System.Random#19](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange3.cpp#19)]
 [!code-csharp[System.Random#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange3.cs#19)]
 [!code-vb[System.Random#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange3.vb#19)]  
  
<a name="Boolean"></a>   
### <a name="generate-random-boolean-values"></a>Создание случайных логических значений  
 Класс <xref:System.Random> не предоставляет методы, создающие <xref:System.Boolean> значения. Однако для этого можно определить собственный класс или метод. В следующем примере определяется класс `BooleanGenerator`с одним методом `NextBoolean`. Класс `BooleanGenerator` сохраняет объект <xref:System.Random> как закрытую переменную. Метод `NextBoolean` вызывает метод <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> и передает результат методу <xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType>. Обратите внимание, что в качестве аргумента используется 2, чтобы указать верхнюю границу случайного числа. Так как это значение является эксклюзивным, вызов метода возвращает значение 0 или 1.  
  
 [!code-cpp[System.Random#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans1.cpp#8)]
 [!code-csharp[System.Random#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans1.cs#8)]
 [!code-vb[System.Random#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans1.vb#8)]  
  
 Вместо создания отдельного класса для создания случайных значений <xref:System.Boolean> в примере можно просто определить один метод. Однако в этом случае объект <xref:System.Random> должен быть определен как переменная уровня класса, чтобы избежать создания экземпляра нового <xref:System.Random> в каждом вызове метода. В Visual Basic случайный экземпляр может быть определен как [статическая](~/docs/visual-basic/language-reference/modifiers/static.md) переменная в методе `NextBoolean`.  В следующем примере показана реализация.  
  
 [!code-cpp[System.Random#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans2.cpp#20)]
 [!code-csharp[System.Random#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans2.cs#20)]
 [!code-vb[System.Random#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans2.vb#20)]  
  
<a name="Long"></a>   
### <a name="generate-random-64-bit-integers"></a>Создавать случайные 64-разрядные целые числа  
 Перегрузки метода <xref:System.Random.Next%2A> возвращают 32-разрядные целые числа. Однако в некоторых случаях может потребоваться работать с 64-разрядными целыми числами. Это можно сделать следующим образом:  
  
1.  Вызовите метод <xref:System.Random.NextDouble%2A>, чтобы получить значение двойной точности с плавающей запятой.  
  
2.  Умножьте это значение на <xref:System.Int64.MaxValue?displayProperty=nameWithType>.  
  
 В следующем примере этот метод используется для создания 20 000 000 случайных длинных целых чисел и классификации их в 10 равных группах. Затем он вычисляет распределение случайных чисел, подчисляя число в каждой группе от 0 до <xref:System.Int64.MaxValue?displayProperty=nameWithType>. Как видно из выходных данных примера, числа распределяются более или реже по диапазону длинного целого числа.  
  
 [!code-cpp[System.Random#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/long1.cpp#14)]
 [!code-csharp[System.Random#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/long1.cs#14)]
 [!code-vb[System.Random#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/long1.vb#14)]  
  
 Альтернативный метод, использующий побитовую обработку, не создает действительно случайных чисел. Этот метод вызывает <xref:System.Random.Next>, чтобы создать два целых числа, сдвигя влево на 32 бит и or их вместе. Этот метод имеет два ограничения:  
  
1.  Поскольку бит 31 является битом знака, значение в битовом 31 полученного длинного целого числа всегда равно 0.  Это можно решить путем создания случайного значения 0 или 1, сдвига влево на 31 бит и индексами его с исходным произвольным целым числом.  
  
2.  Более серьезно, поскольку вероятность того, что значение, возвращаемое <xref:System.Random.Next>, будет равно 0, в ряде случайных чисел в диапазоне 0x0-0x00000000FFFFFFFF будет несколько.  
  
<a name="Bytes"></a>   
### <a name="retrieve-bytes-in-a-specified-range"></a>Извлечение байтов в указанном диапазоне  
 Перегрузки метода <xref:System.Random.Next%2A> позволяют указать диапазон случайных чисел, а метод <xref:System.Random.NextBytes%2A> — нет. В следующем примере реализуется метод `NextBytes`, который позволяет указать диапазон возвращаемых байтов. Он определяет класс `Random2`, производный от <xref:System.Random>, и перегружает его метод `NextBytes`.  
  
 [!code-cpp[System.Random#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/bytes1.cpp#9)]
 [!code-csharp[System.Random#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/bytes1.cs#9)]
 [!code-vb[System.Random#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/bytes1.vb#9)]  
  
 Метод `NextBytes(Byte[], Byte, Byte)` создает оболочку для вызова метода <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> и задает минимальное значение, которое больше максимального значения (в данном случае 0 и 101), которое требуется вернуть в массив байтов. Так как мы уверены, что целочисленные значения, возвращаемые методом <xref:System.Random.Next%2A>, находятся в диапазоне <xref:System.Byte> типа данных, можно безопасно привести их (в C#) или преобразовать их (в Visual Basic) из целых чисел в байты.  
  
<a name="Array"></a>   
### <a name="retrieve-an-element-from-an-array-or-collection-at-random"></a>Извлечение элемента из массива или коллекции в случайном порядке  
 Случайные числа часто используются в качестве индексов для получения значений из массивов или коллекций. Чтобы получить случайное значение индекса, можно вызвать метод <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> и использовать нижнюю границу массива в качестве значения его `minValue`ого аргумента, а на единицу больше, чем верхняя граница массива, в качестве значения аргумента `maxValue`. Для массива, начинающегося с нуля, это эквивалентно его свойству <xref:System.Array.Length%2A> или значение, которое больше значения, возвращаемого методом <xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType>. В следующем примере случайным образом извлекается имя города в США из массива городов.  
  
 [!code-cpp[System.Random#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/array1.cpp#10)]
 [!code-csharp[System.Random#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/array1.cs#10)]
 [!code-vb[System.Random#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/array1.vb#10)]  
  
<a name="UniqueArray"></a>   
### <a name="retrieve-a-unique-element-from-an-array-or-collection"></a>Извлечение уникального элемента из массива или коллекции  
 Генератор случайных чисел всегда может возвращать дублирующиеся значения. Так как диапазон чисел становится меньше или число формируемых значений становится больше, вероятность повторений растет. Если случайные значения должны быть уникальными, создаются дополнительные числа для компенсации дубликатов, что приводит к ухудшению производительности.  
  
 Существует ряд методов для решения этого сценария. Одним из распространенных решений является создание массива или коллекции, содержащей значения для извлечения, и параллельный массив, содержащий случайные числа с плавающей запятой. Второй массив заполняется случайными числами во время создания первого массива, а метод <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> используется для сортировки первого массива с использованием значений в параллельном массиве.  
  
 Например, если вы разрабатываете игру «косынка», необходимо убедиться, что каждая карта используется только один раз. Вместо создания случайных чисел для получения карты и отслеживания того, была ли карта уже обработана, можно создать параллельный массив случайных чисел, который можно использовать для сортировки колоды. После сортировки колоды приложение может поддерживать указатель, указывающий на индекс следующей карточки в колоде.  
  
 Этот подход показан в приведенном ниже примере. Он определяет класс `Card`, представляющий воспроизводимую карту, и класс `Dealer`, который обрабатывает колоду карточек с случайным воспроизведением. Конструктор класса `Dealer` заполняет два массива: массив `deck`, имеющий область класса и представляющий все карты в колоде; и локальный `order` массив с тем же количеством элементов, что и `deck` массив, и заполняется случайными <xref:System.Double> значениями.  Затем вызывается метод <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> для сортировки массива `deck` на основе значений в `order` массиве.  
  
 [!code-cpp[System.Random#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/uniquearray1.cpp#11)]
 [!code-csharp[System.Random#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/uniquearray1.cs#11)]
 [!code-vb[System.Random#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/uniquearray1.vb#11)]  
  
   
  
## Examples  
 В следующем примере создается один генератор случайных чисел и вызывается его <xref:System.Random.NextBytes%2A>, <xref:System.Random.Next%2A>и <xref:System.Random.NextDouble%2A> методы для создания последовательностей случайных чисел в разных диапазонах.  
  
 [!code-cpp[System.Random#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random2.cpp#2)]
 [!code-csharp[System.Random#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random2.cs#2)]
 [!code-vb[System.Random#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random2.vb#2)]  
  
 В следующем примере создается случайное целое число, которое используется в качестве индекса для получения строкового значения из массива.  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>В .NET Framework 1,0 и 1,1 минимальная реализация класса, производного от <see cref="T:System.Random" />, требовала переопределения метода <see cref="M:System.Random.Sample" /> для определения нового или измененного алгоритма создания случайных чисел. Производный класс может затем полагаться на реализацию базового класса <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32)" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, <see cref="M:System.Random.NextBytes(System.Byte[])" />и <see cref="M:System.Random.NextDouble" /> методов для вызова реализации метода <see cref="M:System.Random.Sample" /> в производном классе.  
  
В .NET Framework 2,0 и более поздних версиях поведение методов <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />и <see cref="M:System.Random.NextBytes(System.Byte[])" /> изменилось, поэтому эти методы не обязательно вызывают реализацию производного класса метода <see cref="M:System.Random.Sample" />. В результате классы, производные от <see cref="T:System.Random" />, предназначенных для .NET Framework 2,0 и более поздних версий, также должны переопределять эти три метода.</para></block>
    <block subset="none" type="usage"><para>Реализация генератора случайных чисел в классе <see cref="T:System.Random" /> не всегда остается одинаковой для основных версий .NET Framework. В результате не следует рассчитывать на то, что одно и то же начальное значение приведет к той же псевдо-случайной последовательности в разных версиях .NET Framework.</para></block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Random" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Random" /> с помощью зависимого от времени начального значения по умолчанию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

Начальное значение по умолчанию является производным от системных часов, имеющих конечное разрешение. В результате, только в .NET Framework различные объекты <xref:System.Random>, которые были созданы в результате закрытия с помощью вызова конструктора без параметров, будут иметь идентичные начальные значения по умолчанию и, следовательно, будут создавать идентичные наборы случайных чисел. Эту проблему можно избежать, используя один объект <xref:System.Random> для создания всех случайных чисел. Кроме того, его можно обойти, создав собственное значение случайного начального значения и передав его конструктору <xref:System.Random.%23ctor%28System.Int32%29>. Дополнительные сведения см. в описании конструктора <xref:System.Random.%23ctor%28System.Int32%29>. Обратите внимание, что это ограничение не распространяется на .NET Core.  
  
 Вызовите этот конструктор, если вы хотите, чтобы генератор случайных чисел создавал случайную последовательность чисел. Чтобы создать фиксированную последовательность случайных чисел, которая будет одинаковой для разных генераторов случайных чисел, вызовите конструктор <xref:System.Random.%23ctor%28System.Int32%29> с фиксированным начальным значением. Эта перегрузка конструктора <xref:System.Random> часто используется при тестировании приложений, использующих случайные числа.  
  
 После создания экземпляра генератора случайных чисел вы вызываете отдельные методы <xref:System.Random>, такие как <xref:System.Random.Next> или <xref:System.Random.NextDouble>, для создания случайных чисел.  
  
   
  
## Examples

В следующем примере конструктор без параметров используется для создания экземпляров трех <xref:System.Random> объектов и отображает последовательность из пяти случайных целых чисел для каждого из них. Если он выполняется на .NET Framework, поскольку первые два <xref:System.Random> объектов создаются в результате закрытия, они создаются с использованием идентичных начальных значений, основанных на системных часах, и, следовательно, они создают идентичную последовательность случайных чисел. С другой стороны, конструктор без параметров третьего <xref:System.Random>ного объекта вызывается после двух секунд, вызванных вызовом метода <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>. Поскольку при этом создается другое начальное значение для третьего <xref:System.Random> объекта, создается другая последовательность случайных чисел.  
  
 [!code-csharp[System.Random.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor1.cs#2)]
 [!code-vb[System.Random.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random (int Seed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 Seed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Seed As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random(int Seed);" />
      <MemberSignature Language="F#" Value="new Random : int -&gt; Random" Usage="new System.Random Seed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Seed" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Seed">Число, используемое для вычисления начального значения последовательности псевдослучайных чисел. Если задано отрицательное число, используется его абсолютное значение.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Random" /> с помощью указанного начального значения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Предоставление идентичного начального значения различным объектам <xref:System.Random> приводит к тому, что каждый экземпляр создает идентичные последовательности случайных чисел. Это часто делается при тестировании приложений, зависящих от генераторов случайных чисел.  
  
 Если приложению требуются разные последовательности случайных чисел, вызывайте этот конструктор многократно с разными начальными значениями. Один из способов создания уникального начального значения — сделать его зависящим от времени. Например, получить начальное значение из системных часов, так как перегрузка <xref:System.Random.%23ctor>. Однако системные часы могут не иметь достаточного разрешения, чтобы обеспечить различные вызовы этого конструктора с другим начальным значением. На .NET Framework это приводит к созданию генераторов случайных чисел, создающих идентичные последовательности псевдослучайных чисел, как показано в первых двух <xref:System.Random> объектах в следующем примере. Чтобы избежать этого, примените алгоритм для различения начального значения при каждом вызове или вызовите метод <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>, чтобы гарантировать, что каждый конструктор будет иметь другое начальное значение.  
  
 [!code-csharp[System.Random.Ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor4.cs#4)]
 [!code-vb[System.Random.Ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor4.vb#4)]  
  
 Другой вариант — создать экземпляр одного <xref:System.Random> объекта, который используется для создания всех случайных чисел в приложении. Это дает немного более высокую производительность, поскольку создание экземпляра генератора случайных чисел занимает довольно много ресурсов.  
  
   
  
## Examples  
 В следующем примере создаются объекты <xref:System.Random> с конструктором класса, который принимает параметр SEED и создает последовательность случайных целых чисел и Double. В примере показано, что та же последовательность создается при повторном создании объекта <xref:System.Random> с помощью конструктора и параметра начального значения.  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Next">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает случайное целое число.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next();" />
      <MemberSignature Language="F#" Value="abstract member Next : unit -&gt; int&#xA;override this.Next : unit -&gt; int" Usage="random.Next " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает неотрицательное случайное целое число.</summary>
        <returns>32-разрядное целое число со знаком, которое больше или равно нулю и меньше чем <see cref="F:System.Int32.MaxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Random.Next%2A?displayProperty=nameWithType> создает случайное число, значение которого находится в диапазоне от 0 до меньшего <xref:System.Int32.MaxValue?displayProperty=nameWithType>. Чтобы создать случайное число, значение которого лежит в диапазоне от 0 до какого-либо другого положительного числа, используйте перегрузку метода <xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType>. Чтобы создать случайное число в другом диапазоне, используйте перегрузку метода <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере повторяются вызовы метода <xref:System.Random.Next%2A> для создания определенного числа случайных чисел, запрошенных пользователем. Для получения входных данных клиента используется метод <xref:System.Console.ReadLine%2A?displayProperty=nameWithType>.  
  
 [!code-cpp[System.Random.Next#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next3.cpp#5)]
 [!code-csharp[System.Random.Next#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next3.cs#5)]
 [!code-vb[System.Random.Next#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next3.vb#5)]  
  
 В следующем примере класс создается производным от <xref:System.Random> для создания последовательности случайных чисел, распределение которых отличается от равномерного распределения, созданного методом <xref:System.Random.Sample%2A> базового класса. Он переопределяет метод <xref:System.Random.Sample%2A> для предоставления распределения случайных чисел и переопределяет метод <xref:System.Random.Next%2A?displayProperty=nameWithType> для использования последовательности случайных чисел.  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Начиная с версии .NET Framework 2,0, если вы наследуете класс от <see cref="T:System.Random" /> и переопределяете метод <see cref="M:System.Random.Sample" />, распределение, предоставляемое реализацией производного класса метода <see cref="M:System.Random.Sample" />, не используется в вызовах реализации метода <see cref="M:System.Random.Next" /> базового класса. Вместо этого используется равномерное распределение, возвращенное базовым классом <see cref="T:System.Random" />. Такое поведение повышает общую производительность класса <see cref="T:System.Random" />. Чтобы изменить это поведение для вызова метода <see cref="M:System.Random.Sample" /> в производном классе, необходимо также переопределить метод <see cref="M:System.Random.Next" />.</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int -&gt; int&#xA;override this.Next : int -&gt; int" Usage="random.Next maxValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxValue">Эксклюзивная верхняя граница создаваемого случайного числа. <paramref name="maxValue" /> должно быть больше либо равно 0.</param>
        <summary>Возвращает неотрицательное случайное целое число, которое меньше указанного максимального значения.</summary>
        <returns>32-разрядное целое число со знаком, большее или равное 0 и меньшее, чем <paramref name="maxValue" />. То есть диапазон возвращаемых значений включает в себя 0, но не включает <paramref name="maxValue" />. Однако если значение параметра <paramref name="maxValue" /> равно нулю, возвращается значение <paramref name="maxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Перегрузка <xref:System.Random.Next%28System.Int32%29> возвращает случайные целые числа в диапазоне от 0 до `maxValue`-1. Однако если `maxValue` равен 0, метод возвращает 0.  
  
   
  
## Examples  
 В следующем примере создаются случайные целые числа с различными перегрузками метода <xref:System.Random.Next%2A>.  
  
 [!code-cpp[System.Random.Next#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next.cpp#1)]
 [!code-csharp[System.Random.Next#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next.cs#1)]
 [!code-vb[System.Random.Next#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next.vb#1)]  
  
 В следующем примере создается случайное целое число, которое используется в качестве индекса для получения строкового значения из массива. Так как наибольший индекс массива меньше его длины, значение свойства <xref:System.Array.Length%2A?displayProperty=nameWithType> предоставляется как параметр `maxValue`.  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="maxValue" /> меньше 0.</exception>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int minValue, int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 minValue, int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (minValue As Integer, maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int minValue, int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int * int -&gt; int&#xA;override this.Next : int * int -&gt; int" Usage="random.Next (minValue, maxValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minValue" Type="System.Int32" />
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="minValue">Включенный нижний предел возвращаемого случайного числа.</param>
        <param name="maxValue">Исключенный верхний предел возвращаемого случайного числа. Значение свойства <paramref name="maxValue" /> должно быть больше или равно значению свойства <paramref name="minValue" />.</param>
        <summary>Возвращает случайное целое число в указанном диапазоне.</summary>
        <returns>32-разрядное целое число со знаком большее или равное <paramref name="minValue" /> и меньше, чем <paramref name="maxValue" />; то есть, диапазон возвращаемого значения включает <paramref name="minValue" />, не включает <paramref name="maxValue" />. Если значение параметра <paramref name="minValue" /> равно значению параметра <paramref name="maxValue" />, то возвращается значение <paramref name="minValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Перегрузка <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> возвращает случайные целые числа в диапазоне от `minValue` до `maxValue`-1. Однако если `maxValue` равно `minValue`, метод возвращает `minValue`.  
  
 В отличие от других перегрузок метода <xref:System.Random.Next%2A>, которые возвращают только неотрицательные значения, этот метод может возвращать отрицательное случайное целое число.  
  
   
  
## Examples  
 В следующем примере используется метод <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> для создания случайных целых чисел с тремя разными диапазонами. Обратите внимание, что точный результат из примера зависит от предоставленного системой начального значения, передаваемого конструктору класса <xref:System.Random>.  
  
 [!code-cpp[System.Random.Next#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next2.cpp#2)]
 [!code-csharp[System.Random.Next#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/Next2.cs#2)]
 [!code-vb[System.Random.Next#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next2.vb#2)]  
  
 В следующем примере создается случайное целое число, которое используется в качестве индекса для получения строкового значения из массива. Так как наибольший индекс массива меньше его длины, значение свойства <xref:System.Array.Length%2A?displayProperty=nameWithType> предоставляется как параметр `maxValue`.  
  
 [!code-cpp[System.Random.Next#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next4.cpp#4)]
 [!code-csharp[System.Random.Next#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next4.cs#4)]
 [!code-vb[System.Random.Next#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="minValue" /> больше значения <paramref name="maxValue" />.</exception>
        <block subset="none" type="overrides"><para>Начиная с версии .NET Framework 2,0, если вы наследуете класс от <see cref="T:System.Random" /> и переопределяете метод <see cref="M:System.Random.Sample" />, распространение, предоставляемое реализацией производного класса метода <see cref="M:System.Random.Sample" />, не используется в вызовах реализации базового класса перегрузки метода <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, если разница между параметрами <paramref name="minValue" /> и <paramref name="maxValue" /> превышает <see cref="F:System.Int32.MaxValue" />. Вместо этого используется равномерное распределение, возвращенное базовым классом <see cref="T:System.Random" />. Такое поведение повышает общую производительность класса <see cref="T:System.Random" />. Чтобы изменить это поведение для вызова метода <see cref="M:System.Random.Sample" /> в производном классе, необходимо также переопределить перегрузку метода <see cref="M:System.Random.Next(System.Int32,System.Int32)" />.</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : byte[] -&gt; unit&#xA;override this.NextBytes : byte[] -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив, заполняемый случайными числами.</param>
        <summary>Заполняет элементы указанного массива байтов случайными числами.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждому элементу массива байтов присваивается случайное число, большее или равное 0 и меньшее или равное <xref:System.Byte.MaxValue>.  
  
 Например, чтобы создать криптографически защищенный случайный номер, подходящий для создания случайного пароля, используйте такой метод, как <xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере показано, как использовать метод <xref:System.Random.NextBytes%2A> для заполнения массива байтов произвольными байтовыми значениями.  
  
 [!code-cpp[Classic Random.NextBytes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Random.NextBytes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CS/source.cs#1)]
 [!code-vb[Classic Random.NextBytes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> имеет значение <see langword="null" />.</exception>
        <block subset="none" type="overrides"><para>Начиная с версии .NET Framework 2,0, если вы наследуете класс от <see cref="T:System.Random" /> и переопределяете метод <see cref="M:System.Random.Sample" />, распределение, предоставляемое реализацией производного класса метода <see cref="M:System.Random.Sample" />, не используется в вызовах реализации метода <see cref="M:System.Random.NextBytes(System.Byte[])" /> базового класса. Вместо этого используется равномерное распределение, возвращенное базовым классом <see cref="T:System.Random" />. Такое поведение повышает общую производительность класса <see cref="T:System.Random" />. Чтобы изменить это поведение для вызова метода <see cref="M:System.Random.Sample" /> в производном классе, необходимо также переопределить метод <see cref="M:System.Random.NextBytes(System.Byte[])" />.</para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Span(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : Span&lt;byte&gt; -&gt; unit&#xA;override this.NextBytes : Span&lt;byte&gt; -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив, заполняемый случайными числами.</param>
        <summary>Заполняет элементы указанного диапазона байтов случайными числами.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Каждому элементу диапазона байтов присваивается случайное число, которое больше или равно 0 и меньше или равно значению <xref:System.Byte.MaxValue>.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NextDouble">
      <MemberSignature Language="C#" Value="public virtual double NextDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 NextDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function NextDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double NextDouble();" />
      <MemberSignature Language="F#" Value="abstract member NextDouble : unit -&gt; double&#xA;override this.NextDouble : unit -&gt; double" Usage="random.NextDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает случайное число с плавающей запятой, которое больше или равно 0,0 и меньше 1,0.</summary>
        <returns>Число двойной точности с плавающей запятой, которое больше или равно 0,0, и меньше 1,0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Фактическая верхняя граница случайного числа, возвращаемого этим методом, — 0.99999999999999978.  
  
 Чтобы получить случайные значения с плавающей запятой в диапазоне, отличном от 0,0 и 1,0, см. раздел "получение значений с плавающей запятой в указанном диапазоне" раздела <xref:System.Random> Class.  
  
 Этот метод является общедоступной версией защищенного метода <xref:System.Random.Sample%2A>.  
  
   
  
## Examples  
 В следующем примере метод <xref:System.Random.NextDouble%2A> используется для создания последовательностей случайных чисел типа Double.  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 В следующем примере вызывается метод <xref:System.Random.NextDouble%2A> для создания 100 случайных чисел и отображения частоты их распределения.  
  
 [!code-csharp[System.Random.NextDouble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.random.nextdouble/cs/nextdouble1.cs#2)]
 [!code-vb[System.Random.NextDouble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.random.nextdouble/vb/nextdouble1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sample">
      <MemberSignature Language="C#" Value="protected virtual double Sample ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance float64 Sample() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Sample" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Sample () As Double" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual double Sample();" />
      <MemberSignature Language="F#" Value="abstract member Sample : unit -&gt; double&#xA;override this.Sample : unit -&gt; double" Usage="random.Sample " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает случайное число с плавающей запятой в диапазоне от 0,0 до 1,0.</summary>
        <returns>Число двойной точности с плавающей запятой, которое больше или равно 0,0, и меньше 1,0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для создания другого случайного распределения или другого принципа генератора случайных чисел необходимо создать класс, производный от класса <xref:System.Random>, и переопределить метод <xref:System.Random.Sample%2A>.  
  
> [!IMPORTANT]
>  Метод <xref:System.Random.Sample%2A> `protected`, что означает, что он доступен только в классе <xref:System.Random> и его производных классах. Чтобы создать случайное число от 0 до 1 из экземпляра <xref:System.Random>, вызовите метод <xref:System.Random.NextDouble%2A>.  
  
   
  
## Examples  
 В следующем примере класс является производным от <xref:System.Random> и переопределяет метод <xref:System.Random.Sample%2A> для создания распределения случайных чисел. Это распределение отличается от равномерного распределения, созданного методом <xref:System.Random.Sample%2A> базового класса.  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Начиная с версии .NET Framework 2,0, если класс является производным от <see cref="T:System.Random" /> и переопределяется метод <see cref="M:System.Random.Sample" />, распределение, предоставляемое реализацией производного класса метода <see cref="M:System.Random.Sample" />, не используется в вызовах реализации базового класса для следующих методов: 
– метод <see cref="M:System.Random.NextBytes(System.Byte[])" />.  
  
– метод <see cref="M:System.Random.Next" />.  
  
— Метод <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, если значение (<paramref name="maxValue" /> - <paramref name="minValue" />) больше <see cref="F:System.Int32.MaxValue" />.  
  
Вместо этого используется равномерное распределение, предоставляемое базовым классом <see cref="T:System.Random" />. Такое поведение повышает общую производительность класса <see cref="T:System.Random" />. Чтобы изменить это поведение для вызова реализации метода <see cref="M:System.Random.Sample" /> в производном классе, необходимо также переопределить поведение этих трех членов. Иллюстрация приведена в примере.</para></block>
        <altmember cref="M:System.Random.NextDouble" />
      </Docs>
    </Member>
  </Members>
</Type>
