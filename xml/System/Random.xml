<Type Name="Random" FullName="System.Random">
  <Metadata><Meta Name="ms.openlocfilehash" Value="271a79a5bfaf5ae1188446a6544d91f2c0f14890" /><Meta Name="ms.sourcegitcommit" Value="00194cfb0d5c4f2d3f620c0b561d50d547ce2f7f" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="09/06/2019" /><Meta Name="ms.locfileid" Value="70389740" /></Metadata><TypeSignature Language="C#" Value="public class Random" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Random extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Random" />
  <TypeSignature Language="VB.NET" Value="Public Class Random" />
  <TypeSignature Language="C++ CLI" Value="public ref class Random" />
  <TypeSignature Language="F#" Value="type Random = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет генератор псевдослучайных чисел, то есть устройство, которое выдает последовательность чисел, отвечающую определенным статистическим критериям случайности.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Псевдо-случайные числа выбираются с равной вероятностью из конечного набора чисел. Выбранные числа не являются полностью случайными, поскольку для их выбора используется математический алгоритм, но они достаточно случайные для практических целей. Текущая реализация <xref:System.Random> класса основана на измененной версии алгоритма генератора случайных чисел Дональд E. кнута с вычитанием. Дополнительные сведения см. в разделе D. E. Кнута. *Искусство компьютерной программирования, том 2: Алгоритмы*семинумерикал. Addison-Wesley, чтение, MA, третий выпуск, 1997.  
  
 Чтобы создать криптографически защищенное случайное число, например подходящее для создания случайного пароля, используйте <xref:System.Security.Cryptography.RNGCryptoServiceProvider> класс или наследует класс от. <xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType>  
  
 В этом разделе.  
  
 [Создание экземпляра генератора случайных чисел](#Instantiate)   
 [Предотвращение нескольких экземпляров](#Multiple)   
 [Класс System. Random и безопасность потоков](#ThreadSafety)   
 [Создание различных типов случайных чисел](#Functionality)   
 [Замена собственного алгоритма](#Overriding)   
 [Как использовать System. Random to...](#Operations)   
 [Получение той же последовательности случайных значений](#Same)  
 [Получение уникальных последовательностей случайных значений](#Unique)  
 [Получение целых чисел в указанном диапазоне](#Range)  
 [Получение целых чисел с указанным числом цифр](#Digits)  
 [Получение значений с плавающей запятой в указанном диапазоне](#Floats)  
 [Создание случайных логических значений](#Boolean)  
 [Создавать случайные 64-разрядные целые числа](#Long)  
 [Извлечение байтов в указанном диапазоне](#Bytes)  
 [Извлечение элемента из массива или коллекции в случайном порядке](#Array)  
 [Извлечение уникального элемента из массива или коллекции](#UniqueArray)  
  
<a name="Instantiate"></a>   
## <a name="instantiating-the-random-number-generator"></a>Создание экземпляра генератора случайных чисел  
 Чтобы создать экземпляр генератора случайных чисел, укажите начальное значение (начальное значение для алгоритма формирования псевдо-случайных чисел) конструктору <xref:System.Random.%23ctor%2A> класса.  Начальное значение можно указать явно или неявно:  
  
-   <xref:System.Random.%23ctor%28System.Int32%29> Конструктор использует явно указываемое начальное значение.  
  
-   Для предоставления начального значения конструкториспользуетсистемныечасы.<xref:System.Random.%23ctor> Это наиболее распространенный способ создания экземпляра генератора случайных чисел.  
  
 Если для отдельных <xref:System.Random> объектов используется одно и то же начальное значение, они будут создавать одинаковые ряды случайных чисел. Это может быть полезно для создания набора тестов, который обрабатывает случайные значения или для воспроизведения игр, которые наследуют данные от случайных чисел. Однако обратите внимание <xref:System.Random> , что объекты в процессах, выполняющихся в разных версиях .NET Framework, могут возвращать разные серии случайных чисел, даже если они создаются с одинаковыми начальными значениями.  
  
 Для создания различных последовательностей случайных чисел можно сделать начальное значение зависимым от времени, тем самым создавая другой ряд с каждым новым экземпляром <xref:System.Random>. Параметризованный <xref:System.Random.%23ctor%28System.Int32%29> конструктор может <xref:System.Int32> принимать значение на основе числа тактов в текущем времени, <xref:System.Random.%23ctor> тогда как конструктор без параметров использует системные часы для создания начального значения. Однако только на .NET Framework, поскольку часы имеют конечное разрешение, использование конструктора без параметров для создания различных <xref:System.Random> объектов в закрытой последовательности создает генераторы случайных чисел, которые создают идентичные последовательности случайных показатели. В следующем примере показано, как <xref:System.Random> два объекта, создаваемые в приложении .NET Framework, создают идентичные последовательности случайных чисел. В большинстве систем Windows объекты <xref:System.Random> , созданные в течение 15 миллисекунд, могут иметь одинаковые начальные значения.  
  
 [!code-cpp[System.Random#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random1.cpp#1)]
 [!code-csharp[System.Random#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random1.cs#1)]
 [!code-vb[System.Random#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random1.vb#1)]  
  
Чтобы избежать этой проблемы, создайте один <xref:System.Random> объект, а не несколько объектов. Обратите внимание `Random` , что класс в .NET Core не имеет этого ограничения.
  
<a name="Multiple"></a>   
## <a name="avoiding-multiple-instantiations"></a>Предотвращение нескольких экземпляров  
 На .NET Framework инициализация двух генераторов случайных чисел в тесном цикле или при быстром выполнении создает два генератора случайных чисел, которые могут формировать идентичные последовательности случайных чисел. В большинстве случаев это не является намерением разработчика и может привести к проблемам с производительностью, поскольку создание и инициализация генератора случайных чисел является сравнительно дорогостоящим процессом.  
  
 Чтобы повысить производительность и избежать случайного создания отдельных генераторов случайных чисел, создающих идентичные числовые последовательности, рекомендуется создать один <xref:System.Random> объект для создания множества случайных чисел с течением времени, а не создавать новые <xref:System.Random> объекты для создания одного случайного числа.  
  
 <xref:System.Random> Однако класс не является потокобезопасным. При вызове <xref:System.Random> методов из нескольких потоков следуйте рекомендациям, изложенным в следующем разделе.  
  
<a name="ThreadSafety"></a>   
## <a name="the-systemrandom-class-and-thread-safety"></a>Класс System. Random и безопасность потоков  
 Вместо создания экземпляров отдельных <xref:System.Random> объектов рекомендуется создать один <xref:System.Random> экземпляр для создания всех случайных чисел, необходимых для приложения. <xref:System.Random> Однако объекты не являются потокобезопасными. Если приложение вызывает <xref:System.Random> методы из нескольких потоков, необходимо использовать объект синхронизации, чтобы убедиться, что только один поток может одновременно получить доступ к генератору случайных чисел. Если не гарантировать, что <xref:System.Random> доступ к объекту осуществляется потокобезопасным способом, вызовы методов, возвращающих случайные числа, возвращают 0.  
  
 В следующем примере используется C# [оператор lock](~/docs/csharp/language-reference/keywords/lock-statement.md) и [оператор Visual Basic SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) , чтобы гарантировать, что один генератор случайных чисел обращается к 11 потокам потокобезопасным образом. Каждый поток создает 2 000 000 случайных чисел, подсчитывает количество создаваемых случайных чисел и вычисляет их сумму, а затем обновляет итоги для всех потоков после завершения выполнения.  
  
 [!code-cpp[System.Random#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/threadsafeex1.cpp#3)]
 [!code-csharp[System.Random#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex1.cs#3)]
 [!code-vb[System.Random#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex1.vb#3)]  
  
 В примере безопасность потоков обеспечивается следующими способами.  
  
-   <xref:System.ThreadStaticAttribute> Атрибут используется для определения локальных переменных потока, которые отправляют общее число формируемых случайных чисел и их сумму для каждого потока.  
  
-   Блокировка ( `lock` оператор в C# и `SyncLock` оператор в Visual Basic) обеспечивает защиту доступа к переменным для общего количества и суммирования всех случайных чисел, созданных во всех потоках.  
  
-   Семафор ( <xref:System.Threading.CountdownEvent> объект) используется, чтобы обеспечить блокировку основного потока до завершения выполнения всех остальных потоков.  
  
-   В примере проверяется, поврежден ли генератор случайных чисел, путем определения, будут ли два последовательных вызова методов генерации случайных чисел возвращать 0. Если обнаружено повреждение, в примере используется <xref:System.Threading.CancellationTokenSource> объект для сигнализации о том, что все потоки должны быть отменены.  
  
-   Перед созданием каждого случайного числа каждый поток проверяет состояние <xref:System.Threading.CancellationToken> объекта. При запросе отмены в примере вызывается <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> метод для отмены потока.  
  
 Следующий пример идентичен первому, за исключением того, что он использует <xref:System.Threading.Tasks.Task> объект и лямбда-выражение <xref:System.Threading.Thread> вместо объектов.  
  
 [!code-csharp[System.Random#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex2.cs#4)]
 [!code-vb[System.Random#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex2.vb#4)]  
  
 Он отличается от первого примера следующими способами.  
  
-   Переменные, которые следует отследить от количества формируемых случайных чисел и их сумму в каждой задаче, являются локальными для задачи, поэтому нет необходимости использовать <xref:System.ThreadStaticAttribute> атрибут.  
  
-   Статический <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> метод используется, чтобы гарантировать, что главный поток не завершится до завершения всех задач. <xref:System.Threading.CountdownEvent> Объект не требуется.  
  
-   Исключение, полученное в результате отмены задачи, отображается в <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> методе. В предыдущем примере он обрабатывается каждым потоком.  
  
<a name="Functionality"></a>   
## <a name="generating-different-types-of-random-numbers"></a>Создание различных типов случайных чисел  
 Генератор случайных чисел предоставляет методы, позволяющие создавать следующие виды случайных чисел:  
  
-   Ряд <xref:System.Byte> значений. Вы определяете количество байтовых значений, передавая массив, инициализируемый в число элементов, которые метод должен вернуть <xref:System.Random.NextBytes%2A> в метод. Следующий пример приводит к возникновению 20 байтов.  
  
     [!code-cpp[System.Random#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextbytes1.cpp#5)]
     [!code-csharp[System.Random#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextbytes1.cs#5)]
     [!code-vb[System.Random#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextbytes1.vb#5)]  
  
-   Одно целое число. Можно выбрать, требуется ли целое число от 0 до максимального значения (<xref:System.Int32.MaxValue?displayProperty=nameWithType> -1), <xref:System.Random.Next> вызвав метод, целое число от 0 до <xref:System.Random.Next%28System.Int32%29> определенного значения путем вызова метода или целого числа в диапазоне значений, вызвав метод <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>метод. В параметризованных перегрузках указанное максимальное значение является эксклюзивным; то есть фактическое максимальное число, созданное на единицу, меньше указанного значения.  
  
     В следующем примере вызывается <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> метод для создания 10 случайных чисел в диапазоне от-10 до 10. Обратите внимание, что второй аргумент метода указывает эксклюзивную верхнюю границу диапазона случайных значений, возвращаемых методом. Иными словами, самое большое целое число, которое метод может вернуть, меньше этого значения.  
  
     [!code-cpp[System.Random#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextex1.cpp#6)]
     [!code-csharp[System.Random#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextex1.cs#6)]
     [!code-vb[System.Random#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextex1.vb#6)]  
  
-   Одиночное значение с плавающей запятой от 0,0 до меньше 1,0 путем вызова <xref:System.Random.NextDouble%2A> метода. Эксклюзивная верхняя граница случайного числа, возвращаемого методом, — 1, поэтому фактическая верхняя граница — 0.99999999999999978. В следующем примере создаются 10 случайных чисел с плавающей запятой.  
  
     [!code-cpp[System.Random#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextdoubleex1.cpp#7)]
     [!code-csharp[System.Random#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextdoubleex1.cs#7)]
     [!code-vb[System.Random#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextdoubleex1.vb#7)]  
  
> [!IMPORTANT]
>  <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> Метод позволяет указать диапазон возвращаемого случайного числа. `maxValue` Однако параметр, который указывает верхний возвращенный диапазон, является эксклюзивным, а не инклюзивным значением. Это означает, что вызов `Next(0, 100)` метода возвращает значение от 0 до 99, а не между 0 и 100.  
  
 <xref:System.Random> Класс также можно использовать для таких задач, как создание [случайных значений T:System.Boolean](#Boolean), создание [случайных значений с плавающей запятой с диапазоном, отличным от 0 до 1](#Floats), создание [случайных 64-разрядных целых чисел](#Long)и [случайное получение уникального элемента из массива или коллекции](#UniqueArray). Эти и другие распространенные задачи см. в разделе [как использовать System. Random to...](#Operations) раздела.  
  
<a name="Overriding"></a>   
## <a name="substituting-your-own-algorithm"></a>Замена собственного алгоритма  
 Вы можете реализовать собственный генератор случайных чисел, наследуя от <xref:System.Random> класса и указав алгоритм создания случайных чисел. Чтобы указать собственный алгоритм, необходимо переопределить <xref:System.Random.Sample%2A> метод, который реализует алгоритм создания случайных чисел. Также следует переопределить <xref:System.Random.Next>методы, <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>и <xref:System.Random.NextBytes%2A> , чтобы убедиться, что они вызывают переопределенный <xref:System.Random.Sample%2A> метод. Вам не нужно переопределять <xref:System.Random.Next%28System.Int32%29> методы и. <xref:System.Random.NextDouble%2A>  
  
 Пример, который является производным от <xref:System.Random> класса и изменяет генератор случайных чисел псевдослучайных значений по умолчанию, см. на <xref:System.Random.Sample%2A> странице справки.  
  
<a name="Operations"></a>   
## <a name="how-do-you-use-systemrandom-to"></a>Как использовать System. Random to...  
 В следующих разделах приводятся примеры кода для некоторых способов использования случайных чисел в приложении.  
  
<a name="Same"></a>   
### <a name="retrieve-the-same-sequence-of-random-values"></a>Получение той же последовательности случайных значений  
 Иногда требуется создать одну и ту же последовательность случайных чисел в сценариях тестирования программного обеспечения и в игре. Проверка с одинаковой последовательностью случайных чисел позволяет обнаруживать регрессию и подтверждать исправления ошибок. Использование одинаковой последовательности случайных чисел в играх позволяет воспроизводить предыдущие игры.  
  
 Вы можете создать одну и ту же последовательность случайных чисел, предоставив <xref:System.Random.%23ctor%28System.Int32%29> конструктору одно и то же начальное значение. Начальное значение предоставляет начальное значение для алгоритма формирования псевдослучайных чисел. В следующем примере используется 100100 в качестве произвольного начального значения для создания экземпляра <xref:System.Random> объекта, выводится 20 случайных значений с плавающей запятой и сохраняется начальное значение. Затем оно восстанавливает начальное значение, создает новый генератор случайных чисел и отображает те же 20 случайных значений с плавающей точкой.  Обратите внимание, что в примере могут формироваться различные последовательности случайных чисел, если они работают в разных версиях .NET Framework.  
  
 [!code-cpp[System.Random#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/same1.cpp#12)]
 [!code-csharp[System.Random#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/same1.cs#12)]
 [!code-vb[System.Random#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/same1.vb#12)]  
  
<a name="Unique"></a>   
### <a name="retrieve-unique-sequences-of-random-numbers"></a>Получение уникальных последовательностей случайных чисел  
 Предоставление различных начальных значений экземплярам <xref:System.Random> класса приводит к тому, что каждый генератор случайных чисел создает другую последовательность значений. Начальное значение можно указать явным образом путем вызова <xref:System.Random.%23ctor%28System.Int32%29> конструктора или неявно путем <xref:System.Random.%23ctor> вызова конструктора. Большинство разработчиков вызывают конструктор без параметров, который использует системные часы. В следующем примере используется этот подход для создания экземпляров двух <xref:System.Random> экземпляров. Каждый экземпляр отображает последовательность из 10 случайных целых чисел.  
  
 [!code-cpp[System.Random#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/unique.cpp#13)]
 [!code-csharp[System.Random#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/unique.cs#13)]
 [!code-vb[System.Random#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/unique.vb#13)]  
  
 Однако из-за его конечного разрешения системные часы не обнаруживают разницы во времени, которые менее 15 миллисекунд. Таким образом, если код вызывает <xref:System.Random.%23ctor> перегрузку в .NET Framework для одновременного создания экземпляров двух <xref:System.Random> объектов, вы можете случайно предоставить объекты с одинаковыми начальными значениями. <xref:System.Random> (Класс в .NET Core не имеет этого ограничения.) Чтобы увидеть это в предыдущем примере, закомментируйте <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> вызов метода, а затем скомпилируйте и запустите пример еще раз.  
  
 Чтобы предотвратить это, рекомендуется создать экземпляр одного <xref:System.Random> объекта, а не несколько. Однако, поскольку <xref:System.Random> не является потокобезопасным, необходимо использовать некоторое устройство синхронизации при <xref:System.Random> доступе к экземпляру из нескольких потоков. Дополнительные сведения см. в разделе [случайный класс и безопасность потоков](#ThreadSafety) ранее в этой статье. Кроме того, можно использовать механизм задержки, например <xref:System.Threading.Thread.Sleep%2A> метод, используемый в предыдущем примере, чтобы убедиться в том, что создание экземпляров происходит более чем на 15 миллисекунд.  
  
<a name="Range"></a>   
### <a name="retrieve-integers-in-a-specified-range"></a>Получение целых чисел в указанном диапазоне  
 Вы можете получить целые числа в указанном диапазоне, вызвав <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> метод, который позволяет указать нижнюю и верхнюю границы чисел, которые нужно вернуть генератору случайных чисел. Верхняя граница — это эксклюзивное, а не инклюзивное значение. То есть он не включается в диапазон значений, возвращаемых методом. В следующем примере этот метод используется для создания случайных целых чисел от-10 до 10. Обратите внимание, что в нем указано значение 11, которое больше, чем требуемое значение, в `maxValue` качестве значения аргумента в вызове метода.  
  
 [!code-cpp[System.Random#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range1.cpp#15)]
 [!code-csharp[System.Random#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range1.cs#15)]
 [!code-vb[System.Random#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range1.vb#15)]  
  
<a name="Digits"></a>   
### <a name="retrieve-integers-with-a-specified-number-of-digits"></a>Получение целых чисел с указанным числом цифр  
 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> Метод можно вызвать для получения чисел с указанным числом цифр. Например, чтобы получить числа с четырьмя цифрами (т. е. числа в диапазоне от 1000 до 9999), вызовите <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> метод `minValue` со `maxValue` значением 1000 и значением 10000, как показано в следующем примере.  
  
 [!code-cpp[System.Random#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range2.cpp#16)]
 [!code-csharp[System.Random#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range2.cs#16)]
 [!code-vb[System.Random#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range2.vb#16)]  
  
<a name="Floats"></a>   
### <a name="retrieve-floating-point-values-in-a-specified-range"></a>Получение значений с плавающей запятой в указанном диапазоне  
 <xref:System.Random.NextDouble%2A> Метод возвращает случайные значения с плавающей запятой в диапазоне от 0 до меньше 1. Однако часто требуется создавать случайные значения в каком бы то ни было другом диапазоне.  
  
 Если интервал между минимальным и максимальным требуемыми значениями равен 1, можно добавить разницу между требуемым начальным интервалом и значением 0 для числа, возвращаемого <xref:System.Random.NextDouble%2A> методом. В следующем примере это делается для создания 10 случайных чисел в диапазоне от-1 до 0.  
  
 [!code-cpp[System.Random#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange2.cpp#17)]
 [!code-csharp[System.Random#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange2.cs#17)]
 [!code-vb[System.Random#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange2.vb#17)]  
  
 Для создания случайных чисел с плавающей запятой, Нижняя граница которых равна 0, но верхняя граница больше 1 (или, в случае отрицательных чисел, Нижняя граница которой меньше-1, а верхняя граница равна 0), умножьте случайное число на ненулевую границу. В следующем примере это делается для создания 20 000 000 случайных чисел с плавающей запятой в диапазоне от 0 <xref:System.Int64.MaxValue?displayProperty=nameWithType>до. В также отображает распределение случайных значений, созданных методом.  
  
 [!code-cpp[System.Random#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange1.cpp#18)]
 [!code-csharp[System.Random#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange1.cs#18)]
 [!code-vb[System.Random#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange1.vb#18)]  
  
 Чтобы создать случайные числа с плавающей запятой между двумя произвольными значениями, <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> например метод для целых чисел, используйте следующую формулу:  
  
```csharp  
Random.NextDouble() * (maxValue - minValue) + minValue  
```  
  
 Следующий пример приводит к возникновению ошибки 1 000 000 случайных чисел в диапазоне от 10,0 до 11,0 и отображении их распределения.  
  
 [!code-cpp[System.Random#19](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange3.cpp#19)]
 [!code-csharp[System.Random#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange3.cs#19)]
 [!code-vb[System.Random#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange3.vb#19)]  
  
<a name="Boolean"></a>   
### <a name="generate-random-boolean-values"></a>Создание случайных логических значений  
 Класс не предоставляет методы, создающие <xref:System.Boolean> значения. <xref:System.Random> Однако для этого можно определить собственный класс или метод. В следующем примере определяется класс `BooleanGenerator`с одним `NextBoolean`методом. `BooleanGenerator` Класс<xref:System.Random> сохраняет объект как закрытую переменную. Метод вызывает метод и<xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType> передает результат в метод. <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> `NextBoolean` Обратите внимание, что в качестве аргумента используется 2, чтобы указать верхнюю границу случайного числа. Так как это значение является эксклюзивным, вызов метода возвращает значение 0 или 1.  
  
 [!code-cpp[System.Random#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans1.cpp#8)]
 [!code-csharp[System.Random#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans1.cs#8)]
 [!code-vb[System.Random#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans1.vb#8)]  
  
 Вместо создания отдельного класса для создания случайных <xref:System.Boolean> значений в примере можно просто определить один метод. Однако <xref:System.Random> в этом случае объект должен быть определен как переменная уровня класса, чтобы избежать создания экземпляра нового <xref:System.Random> экземпляра в каждом вызове метода. В Visual Basic случайный экземпляр может быть определен как [статическая](~/docs/visual-basic/language-reference/modifiers/static.md) переменная в `NextBoolean` методе.  В следующем примере показана реализация.  
  
 [!code-cpp[System.Random#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans2.cpp#20)]
 [!code-csharp[System.Random#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans2.cs#20)]
 [!code-vb[System.Random#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans2.vb#20)]  
  
<a name="Long"></a>   
### <a name="generate-random-64-bit-integers"></a>Создавать случайные 64-разрядные целые числа  
 Перегрузки <xref:System.Random.Next%2A> метода возвращают 32-разрядные целые числа. Однако в некоторых случаях может потребоваться работать с 64-разрядными целыми числами. Это можно сделать следующим образом:  
  
1.  Вызовите <xref:System.Random.NextDouble%2A> метод, чтобы получить значение двойной точности с плавающей запятой.  
  
2.  Умножьте это значение на <xref:System.Int64.MaxValue?displayProperty=nameWithType>.  
  
 В следующем примере этот метод используется для создания 20 000 000 случайных длинных целых чисел и классификации их в 10 равных группах. Затем он вычисляет распределение случайных чисел, подчисляя число в каждой группе от 0 до <xref:System.Int64.MaxValue?displayProperty=nameWithType>. Как видно из выходных данных примера, числа распределяются более или реже по диапазону длинного целого числа.  
  
 [!code-cpp[System.Random#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/long1.cpp#14)]
 [!code-csharp[System.Random#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/long1.cs#14)]
 [!code-vb[System.Random#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/long1.vb#14)]  
  
 Альтернативный метод, использующий побитовую обработку, не создает действительно случайных чисел. Этот метод вызывает <xref:System.Random.Next> метод для создания двух целых чисел, сдвига влево по одному на 32 бит и or их вместе. Этот метод имеет два ограничения:  
  
1.  Поскольку бит 31 является битом знака, значение в битовом 31 полученного длинного целого числа всегда равно 0.  Это можно решить путем создания случайного значения 0 или 1, сдвига влево на 31 бит и индексами его с исходным произвольным целым числом.  
  
2.  Более серьезно, поскольку вероятность того, что значение, возвращаемое, <xref:System.Random.Next> будет равно 0, будет несколько случайных чисел в диапазоне 0x0-0x00000000FFFFFFFF.  
  
<a name="Bytes"></a>   
### <a name="retrieve-bytes-in-a-specified-range"></a>Извлечение байтов в указанном диапазоне  
 Перегрузки <xref:System.Random.Next%2A> метода позволяют указать диапазон случайных чисел, <xref:System.Random.NextBytes%2A> но метод — нет. В следующем примере реализуется `NextBytes` метод, который позволяет указать диапазон возвращаемых байтов. Он определяет `Random2` класс, производный от <xref:System.Random> , и перегружает его `NextBytes` метод.  
  
 [!code-cpp[System.Random#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/bytes1.cpp#9)]
 [!code-csharp[System.Random#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/bytes1.cs#9)]
 [!code-vb[System.Random#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/bytes1.vb#9)]  
  
 Метод создает оболочку <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> для вызова метода и задает минимальное значение, которое больше максимального значения (в данном случае 0 и 101), которое требуется вернуть в массив байтов. `NextBytes(Byte[], Byte, Byte)` Так как мы уверены, что целочисленные значения, возвращаемые <xref:System.Random.Next%2A> методом, находятся в диапазоне <xref:System.Byte> типа данных, мы можем безопасно привести их (в C#) или преобразовать их (в Visual Basic) из целых чисел в байты.  
  
<a name="Array"></a>   
### <a name="retrieve-an-element-from-an-array-or-collection-at-random"></a>Извлечение элемента из массива или коллекции в случайном порядке  
 Случайные числа часто используются в качестве индексов для получения значений из массивов или коллекций. Чтобы получить случайное значение индекса, можно вызвать <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> метод и использовать нижнюю границу массива в качестве значения его `minValue` аргумента, а на единицу больше, чем верхняя граница массива, в качестве значения его `maxValue` аргумента. Для массива, начинающегося с нуля, это эквивалентно его <xref:System.Array.Length%2A> свойству или больше значения, возвращаемого <xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType> методом. В следующем примере случайным образом извлекается имя города в США из массива городов.  
  
 [!code-cpp[System.Random#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/array1.cpp#10)]
 [!code-csharp[System.Random#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/array1.cs#10)]
 [!code-vb[System.Random#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/array1.vb#10)]  
  
<a name="UniqueArray"></a>   
### <a name="retrieve-a-unique-element-from-an-array-or-collection"></a>Извлечение уникального элемента из массива или коллекции  
 Генератор случайных чисел всегда может возвращать дублирующиеся значения. Так как диапазон чисел становится меньше или число формируемых значений становится больше, вероятность повторений растет. Если случайные значения должны быть уникальными, создаются дополнительные числа для компенсации дубликатов, что приводит к ухудшению производительности.  
  
 Существует ряд методов для решения этого сценария. Одним из распространенных решений является создание массива или коллекции, содержащей значения для извлечения, и параллельный массив, содержащий случайные числа с плавающей запятой. Второй массив заполняется случайными числами во время создания первого массива, а <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> метод используется для сортировки первого массива с использованием значений в параллельном массиве.  
  
 Например, если вы разрабатываете игру «косынка», необходимо убедиться, что каждая карта используется только один раз. Вместо создания случайных чисел для получения карты и отслеживания того, была ли карта уже обработана, можно создать параллельный массив случайных чисел, который можно использовать для сортировки колоды. После сортировки колоды приложение может поддерживать указатель, указывающий на индекс следующей карточки в колоде.  
  
 Этот подход показан в приведенном ниже примере. Он определяет `Card` класс, который представляет собой воспроизводимую карту `Dealer` , и класс, который обрабатывает колоду карточек с случайным перемещением. Конструктор класса заполняет два массива `deck` : массив, имеющий область класса и представляющий все карты в колоде, и локальный `order` массив, `deck` имеющий то же количество элементов, что и массив, и заполняется `Dealer` со случайно сформированными <xref:System.Double> значениями.  Затем вызывается `deck`методдля сортировки массива на основе значений в `order` массиве. <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType>  
  
 [!code-cpp[System.Random#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/uniquearray1.cpp#11)]
 [!code-csharp[System.Random#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/uniquearray1.cs#11)]
 [!code-vb[System.Random#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/uniquearray1.vb#11)]  
  
   
  
## Examples  
 В следующем примере создается один генератор случайных чисел и вызывается его <xref:System.Random.NextBytes%2A>методы <xref:System.Random.Next%2A>, и <xref:System.Random.NextDouble%2A> для создания последовательностей случайных чисел в разных диапазонах.  
  
 [!code-cpp[System.Random#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random2.cpp#2)]
 [!code-csharp[System.Random#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random2.cs#2)]
 [!code-vb[System.Random#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random2.vb#2)]  
  
 В следующем примере создается случайное целое число, которое используется в качестве индекса для получения строкового значения из массива.  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>В .NET Framework 1,0 и 1,1 — минимальная реализация класса, производного от <see cref="T:System.Random" /> обязательного <see cref="M:System.Random.Sample" /> переопределения метода для определения нового или измененного алгоритма создания случайных чисел. <see cref="M:System.Random.Next" />Производный класс может затем полагаться на реализацию базового класса методов <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, <see cref="M:System.Random.Next(System.Int32)" />,, <see cref="M:System.Random.NextBytes(System.Byte[])" />и <see cref="M:System.Random.NextDouble" /> для вызова реализации <see cref="M:System.Random.Sample" /> метода производного класса.  
  
В .NET Framework 2,0 <see cref="M:System.Random.Next" />и более поздних версиях поведение методов, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />и <see cref="M:System.Random.NextBytes(System.Byte[])" /> изменилось, так что эти методы не <see cref="M:System.Random.Sample" /> обязательно вызывают реализацию производного класса метода. В результате классы, производные от <see cref="T:System.Random" /> класса, предназначенного для .NET Framework 2,0 и более поздних версий, также должны переопределять эти три метода.</para></block>
    <block subset="none" type="usage"><para>Реализация генератора случайных чисел в <see cref="T:System.Random" /> классе не всегда остается одинаковой для основных версий .NET Framework. В результате не следует рассчитывать на то, что одно и то же начальное значение приведет к той же псевдо-случайной последовательности в разных версиях .NET Framework.</para></block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Random" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Random" /> с помощью зависимого от времени начального значения по умолчанию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

Начальное значение по умолчанию является производным от системных часов, имеющих конечное разрешение. В результате, только в .NET Framework различные <xref:System.Random> объекты, которые были созданы с помощью вызова конструктора без параметров, будут иметь одинаковые начальные значения по умолчанию и, следовательно, будут создавать идентичные наборы случайных чисел. Эту проблему можно избежать, используя один <xref:System.Random> объект для создания всех случайных чисел. Кроме того, его можно обойти, создав собственное значение случайного начального значения и передав его <xref:System.Random.%23ctor%28System.Int32%29> конструктору. Дополнительные сведения см. в <xref:System.Random.%23ctor%28System.Int32%29> описании конструктора. Обратите внимание, что это ограничение не распространяется на .NET Core.  
  
 Вызовите этот конструктор, если вы хотите, чтобы генератор случайных чисел создавал случайную последовательность чисел. Чтобы создать фиксированную последовательность случайных чисел, которая будет одинаковой для разных генераторов случайных чисел, вызовите <xref:System.Random.%23ctor%28System.Int32%29> конструктор с фиксированным начальным значением. Эта <xref:System.Random> перегрузка конструктора часто используется при тестировании приложений, использующих случайные числа.  
  
 После создания экземпляра генератора случайных чисел вы вызываете отдельные <xref:System.Random> методы, <xref:System.Random.Next> например или <xref:System.Random.NextDouble>, для создания случайных цифр.  
  
   
  
## Examples

В следующем примере конструктор без параметров используется для создания экземпляров трех <xref:System.Random> объектов и отображает последовательность из пяти случайных целых чисел для каждого из них. Если он выполняется на .NET Framework, поскольку первые два <xref:System.Random> объекта создаются в результате закрытия, они создаются с использованием идентичных начальных значений, основанных на системных часах, и, следовательно, они создают идентичную последовательность случайных чисел. С другой стороны, конструктор без параметров для третьего <xref:System.Random> объекта вызывается после 2-секундной задержки, вызванной <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> вызовом метода. Поскольку при этом создается другое начальное значение для третьего <xref:System.Random> объекта, создается другая последовательность случайных чисел.  
  
 [!code-csharp[System.Random.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor1.cs#2)]
 [!code-vb[System.Random.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random (int Seed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 Seed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Seed As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random(int Seed);" />
      <MemberSignature Language="F#" Value="new Random : int -&gt; Random" Usage="new System.Random Seed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Seed" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Seed">Число, используемое для вычисления начального значения последовательности псевдослучайных чисел. Если задано отрицательное число, используется его абсолютное значение.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Random" /> с помощью указанного начального значения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Предоставление идентичного начального значения разным <xref:System.Random> объектам приводит к тому, что каждый экземпляр создает идентичные последовательности случайных чисел. Это часто делается при тестировании приложений, зависящих от генераторов случайных чисел.  
  
 Если приложению требуются разные последовательности случайных чисел, вызывайте этот конструктор многократно с разными начальными значениями. Один из способов создания уникального начального значения — сделать его зависящим от времени. Например, получение начального значения из системных часов, как и в <xref:System.Random.%23ctor> случае перегрузки. Однако системные часы могут не иметь достаточного разрешения, чтобы обеспечить различные вызовы этого конструктора с другим начальным значением. На .NET Framework это приводит к созданию генераторов случайных чисел, создающих идентичные последовательности псевдослучайных чисел, как показано в первых двух <xref:System.Random> объектах в следующем примере. Чтобы избежать этого, примените алгоритм для различения начального значения при каждом вызове или вызовите <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> метод, чтобы гарантировать, что каждый конструктор будет иметь другое начальное значение.  
  
 [!code-csharp[System.Random.Ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor4.cs#4)]
 [!code-vb[System.Random.Ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor4.vb#4)]  
  
 Другой вариант — создать экземпляр одного <xref:System.Random> объекта, который используется для создания всех случайных чисел в приложении. Это дает немного более высокую производительность, поскольку создание экземпляра генератора случайных чисел занимает довольно много ресурсов.  
  
   
  
## Examples  
 В следующем примере создаются <xref:System.Random> объекты с конструктором класса, который принимает параметр SEED и создает последовательность случайных целых чисел и Double. В примере показано, что та же последовательность создается при <xref:System.Random> повторном создании объекта с помощью конструктора и параметра начального значения.  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Next">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает случайное целое число.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next();" />
      <MemberSignature Language="F#" Value="abstract member Next : unit -&gt; int&#xA;override this.Next : unit -&gt; int" Usage="random.Next " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает неотрицательное случайное целое число.</summary>
        <returns>32-разрядное целое число со знаком, которое больше или равно нулю и меньше чем <see cref="F:System.Int32.MaxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Random.Next%2A?displayProperty=nameWithType>формирует случайное число, значение которого в диапазоне от 0 до <xref:System.Int32.MaxValue?displayProperty=nameWithType>меньше. Чтобы создать случайное число, значение которого лежит в диапазоне от 0 до какого-либо другого <xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType> положительного числа, используйте перегрузку метода. Чтобы создать случайное число в другом диапазоне, используйте <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> перегрузку метода.  
  
   
  
## Examples  
 В следующем примере выполняется повторный вызов <xref:System.Random.Next%2A> метода для создания определенного числа случайных чисел, запрошенных пользователем. <xref:System.Console.ReadLine%2A?displayProperty=nameWithType> Метод используется для получения введенных данных клиента.  
  
 [!code-cpp[System.Random.Next#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next3.cpp#5)]
 [!code-csharp[System.Random.Next#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next3.cs#5)]
 [!code-vb[System.Random.Next#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next3.vb#5)]  
  
 В следующем примере класс создается производным от <xref:System.Random> класса для создания последовательности случайных чисел, распределение которых отличается от равномерного распределения <xref:System.Random.Sample%2A> , созданного методом базового класса. Он переопределяет <xref:System.Random.Sample%2A> метод для предоставления распределения случайных чисел и <xref:System.Random.Next%2A?displayProperty=nameWithType> переопределяет метод для использования ряда случайных чисел.  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Начиная с версии .NET Framework 2,0, если производный класс от <see cref="T:System.Random" /> и <see cref="M:System.Random.Sample" /> переопределяет метод, распределение, предоставляемое реализацией <see cref="M:System.Random.Sample" /> производного класса метода, не используется в вызовах базового класса. <see cref="M:System.Random.Next" /> реализация метода. Вместо этого используется равномерное распределение, возвращаемое <see cref="T:System.Random" /> базовым классом. Такое поведение повышает общую производительность <see cref="T:System.Random" /> класса. Чтобы изменить это поведение для вызова <see cref="M:System.Random.Sample" /> метода в производном классе, необходимо также <see cref="M:System.Random.Next" /> переопределить метод.</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int -&gt; int&#xA;override this.Next : int -&gt; int" Usage="random.Next maxValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxValue">Эксклюзивная верхняя граница создаваемого случайного числа. <paramref name="maxValue" /> должно быть больше либо равно 0.</param>
        <summary>Возвращает неотрицательное случайное целое число, которое меньше указанного максимального значения.</summary>
        <returns>32-разрядное целое число со знаком, большее или равное 0 и меньшее, чем <paramref name="maxValue" />. То есть диапазон возвращаемых значений включает в себя 0, но не включает <paramref name="maxValue" />. Однако если значение параметра <paramref name="maxValue" /> равно нулю, возвращается значение <paramref name="maxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Перегрузка возвращает случайные целые числа в диапазоне от 0 до `maxValue` -1. <xref:System.Random.Next%28System.Int32%29> Однако если `maxValue` значение равно 0, метод возвращает 0.  
  
   
  
## Examples  
 В следующем примере создаются случайные целые числа с различными перегрузками <xref:System.Random.Next%2A> метода.  
  
 [!code-cpp[System.Random.Next#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next.cpp#1)]
 [!code-csharp[System.Random.Next#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next.cs#1)]
 [!code-vb[System.Random.Next#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next.vb#1)]  
  
 В следующем примере создается случайное целое число, которое используется в качестве индекса для получения строкового значения из массива. Так как наибольший индекс массива меньше его длины, значение <xref:System.Array.Length%2A?displayProperty=nameWithType> свойства указывается как `maxValue` параметр.  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="maxValue" /> меньше 0.</exception>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int minValue, int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 minValue, int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (minValue As Integer, maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int minValue, int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int * int -&gt; int&#xA;override this.Next : int * int -&gt; int" Usage="random.Next (minValue, maxValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minValue" Type="System.Int32" />
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="minValue">Включенный нижний предел возвращаемого случайного числа.</param>
        <param name="maxValue">Исключенный верхний предел возвращаемого случайного числа. Значение свойства <paramref name="maxValue" /> должно быть больше или равно значению свойства <paramref name="minValue" />.</param>
        <summary>Возвращает случайное целое число в указанном диапазоне.</summary>
        <returns>32-разрядное целое число со знаком большее или равное <paramref name="minValue" /> и меньше, чем <paramref name="maxValue" />; то есть, диапазон возвращаемого значения включает <paramref name="minValue" />, не включает <paramref name="maxValue" />. Если значение параметра <paramref name="minValue" /> равно значению параметра <paramref name="maxValue" />, то возвращается значение <paramref name="minValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Перегрузка возвращает случайные целые числа в диапазоне от `minValue` до `maxValue` – 1. <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> Однако, если `maxValue` равно `minValue`, метод возвращает `minValue`значение.  
  
 В отличие от других перегрузок <xref:System.Random.Next%2A> метода, которые возвращают только неотрицательные значения, этот метод может возвращать отрицательное случайное целое число.  
  
   
  
## Examples  
 В следующем примере <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> метод используется для создания случайных целых чисел с тремя разными диапазонами. Обратите внимание, что точный результат из этого примера зависит от предоставленного системой начального значения, переданного <xref:System.Random> конструктору класса.  
  
 [!code-cpp[System.Random.Next#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next2.cpp#2)]
 [!code-csharp[System.Random.Next#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/Next2.cs#2)]
 [!code-vb[System.Random.Next#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next2.vb#2)]  
  
 В следующем примере создается случайное целое число, которое используется в качестве индекса для получения строкового значения из массива. Так как наибольший индекс массива меньше его длины, значение <xref:System.Array.Length%2A?displayProperty=nameWithType> свойства указывается как `maxValue` параметр.  
  
 [!code-cpp[System.Random.Next#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next4.cpp#4)]
 [!code-csharp[System.Random.Next#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next4.cs#4)]
 [!code-vb[System.Random.Next#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="minValue" /> больше значения <paramref name="maxValue" />.</exception>
        <block subset="none" type="overrides"><para>Начиная с версии .NET Framework 2,0, если производный класс от <see cref="T:System.Random" /> и <see cref="M:System.Random.Sample" /> переопределяет метод, распределение, предоставляемое реализацией <see cref="M:System.Random.Sample" /> производного класса метода, не используется в вызовах базового класса. Реализация перегрузки <paramref name="minValue" /> <paramref name="maxValue" /> <see cref="F:System.Int32.MaxValue" />метода, если разница между параметрами и больше. <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> Вместо этого используется равномерное распределение, возвращаемое <see cref="T:System.Random" /> базовым классом. Такое поведение повышает общую производительность <see cref="T:System.Random" /> класса. Чтобы изменить это поведение для вызова <see cref="M:System.Random.Sample" /> метода в производном классе, необходимо также <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> переопределить перегрузку метода.</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : byte[] -&gt; unit&#xA;override this.NextBytes : byte[] -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив байтов, содержащий случайные числа.</param>
        <summary>Заполняет элементы указанного массива байтов случайными числами.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждому элементу массива байтов присваивается случайное число, которое больше или равно 0 и меньше или равно <xref:System.Byte.MaxValue>.  
  
 Например, чтобы создать криптографически защищенный случайный номер, подходящий для создания случайного пароля, используйте такой метод, как <xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Random.NextBytes%2A> метод для заполнения массива байтов произвольными байтовыми значениями.  
  
 [!code-cpp[Classic Random.NextBytes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Random.NextBytes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CS/source.cs#1)]
 [!code-vb[Classic Random.NextBytes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</exception>
        <block subset="none" type="overrides"><para>Начиная с версии .NET Framework 2,0, если производный класс от <see cref="T:System.Random" /> и <see cref="M:System.Random.Sample" /> переопределяет метод, распределение, предоставляемое реализацией <see cref="M:System.Random.Sample" /> производного класса метода, не используется в вызовах базового класса. <see cref="M:System.Random.NextBytes(System.Byte[])" /> реализация метода. Вместо этого используется равномерное распределение, возвращаемое <see cref="T:System.Random" /> базовым классом. Такое поведение повышает общую производительность <see cref="T:System.Random" /> класса. Чтобы изменить это поведение для вызова <see cref="M:System.Random.Sample" /> метода в производном классе, необходимо также <see cref="M:System.Random.NextBytes(System.Byte[])" /> переопределить метод.</para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Span(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : Span&lt;byte&gt; -&gt; unit&#xA;override this.NextBytes : Span&lt;byte&gt; -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NextDouble">
      <MemberSignature Language="C#" Value="public virtual double NextDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 NextDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function NextDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double NextDouble();" />
      <MemberSignature Language="F#" Value="abstract member NextDouble : unit -&gt; double&#xA;override this.NextDouble : unit -&gt; double" Usage="random.NextDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает случайное число с плавающей запятой, которое больше или равно 0,0 и меньше 1,0.</summary>
        <returns>Число двойной точности с плавающей запятой, которое больше или равно 0,0, и меньше 1,0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Фактическая верхняя граница случайного числа, возвращаемого этим методом, — 0.99999999999999978.  
  
 Чтобы получить случайные значения с плавающей запятой в диапазоне, отличном от 0,0 и 1,0, см. раздел <xref:System.Random> "получение значений с плавающей запятой в указанном диапазоне" раздела класса.  
  
 Этот метод является общедоступной версией защищенного метода <xref:System.Random.Sample%2A>.  
  
   
  
## Examples  
 В следующем примере <xref:System.Random.NextDouble%2A> метод используется для создания последовательностей случайных чисел типа Double.  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 В следующем примере вызывается <xref:System.Random.NextDouble%2A> метод для создания 100 случайных чисел и отображения частоты их распределения.  
  
 [!code-csharp[System.Random.NextDouble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.random.nextdouble/cs/nextdouble1.cs#2)]
 [!code-vb[System.Random.NextDouble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.random.nextdouble/vb/nextdouble1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sample">
      <MemberSignature Language="C#" Value="protected virtual double Sample ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance float64 Sample() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Sample" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Sample () As Double" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual double Sample();" />
      <MemberSignature Language="F#" Value="abstract member Sample : unit -&gt; double&#xA;override this.Sample : unit -&gt; double" Usage="random.Sample " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает случайное число с плавающей запятой в диапазоне от 0,0 до 1,0.</summary>
        <returns>Число двойной точности с плавающей запятой, которое больше или равно 0,0, и меньше 1,0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для создания другого случайного распределения или другого принципа генератора случайных чисел следует наследовать класс от <xref:System.Random> класса и <xref:System.Random.Sample%2A> переопределить метод.  
  
> [!IMPORTANT]
>  Метод — `protected`это, что означает, что он доступен только внутри <xref:System.Random> класса и его производных классов. <xref:System.Random.Sample%2A> Чтобы создать случайное число от 0 до 1 из <xref:System.Random> экземпляра, <xref:System.Random.NextDouble%2A> вызовите метод.  
  
   
  
## Examples  
 Следующий пример является производным от класса <xref:System.Random> и <xref:System.Random.Sample%2A> переопределяет метод для создания распределения случайных чисел. Это распределение отличается от равномерного распределения, <xref:System.Random.Sample%2A> созданного методом базового класса.  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Начиная с версии .NET Framework 2,0, если производный класс от <see cref="T:System.Random" /> и <see cref="M:System.Random.Sample" /> переопределяет метод, распределение, предоставляемое реализацией <see cref="M:System.Random.Sample" /> производного класса метода, не используется в вызовах базового класса. реализация следующих методов: 
– метод <see cref="M:System.Random.NextBytes(System.Byte[])" />.  
  
– метод <see cref="M:System.Random.Next" />.  
  
<paramref name="maxValue" /> - — Метод, если <see cref="F:System.Int32.MaxValue" />()больше,чем<paramref name="minValue" />. <see cref="M:System.Random.Next(System.Int32,System.Int32)" />  
  
Вместо этого используется равномерное распределение, предоставляемое <see cref="T:System.Random" /> базовым классом. Такое поведение повышает общую производительность <see cref="T:System.Random" /> класса. Чтобы изменить это поведение для вызова реализации <see cref="M:System.Random.Sample" /> метода в производном классе, необходимо также переопределить поведение этих трех членов. Иллюстрация приведена в примере.</para></block>
        <altmember cref="M:System.Random.NextDouble" />
      </Docs>
    </Member>
  </Members>
</Type>
