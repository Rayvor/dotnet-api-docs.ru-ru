<Type Name="GC" FullName="System.GC">
  <Metadata><Meta Name="ms.openlocfilehash" Value="676c88be65c8b9bd8db22e8bf5ebde86f4ac0aa2" /><Meta Name="ms.sourcegitcommit" Value="bc24a3ba616ee1df8b858f9400cae4f058ea3a7e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="06/19/2019" /><Meta Name="ms.locfileid" Value="67245135" /></Metadata><TypeSignature Language="C#" Value="public static class GC" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit GC extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.GC" />
  <TypeSignature Language="VB.NET" Value="Public Class GC" />
  <TypeSignature Language="C++ CLI" Value="public ref class GC abstract sealed" />
  <TypeSignature Language="F#" Value="type GC = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="42538-101">Управляет системным сборщиком мусора — службой, которая автоматически высвобождает неиспользуемую память.</span><span class="sxs-lookup"><span data-stu-id="42538-101">Controls the system garbage collector, a service that automatically reclaims unused memory.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42538-102">Сборщик мусора является в компонент среды выполнения, который управляет выделением и освобождением управляемой памяти.</span><span class="sxs-lookup"><span data-stu-id="42538-102">The garbage collector is a common language runtime component that controls the allocation and release of managed memory.</span></span> <span data-ttu-id="42538-103">Методы этого класса влияет на выполнение сбора мусора на объект и освобождать ресурсы, выделенные объекту.</span><span class="sxs-lookup"><span data-stu-id="42538-103">The methods in this class influence when garbage collection is performed on an object and when resources allocated by an object are released.</span></span> <span data-ttu-id="42538-104">Свойства этого класса предоставляют информацию о общий объем памяти, доступной в системе и возрастную категорию или поколения, память, выделенная для объекта.</span><span class="sxs-lookup"><span data-stu-id="42538-104">Properties in this class provide information about the total amount of memory available in the system and the age category, or generation, of memory allocated to an object.</span></span>  
  
 <span data-ttu-id="42538-105">Сборщик мусора отслеживает и уничтожает объекты, находящиеся в управляемой памяти.</span><span class="sxs-lookup"><span data-stu-id="42538-105">The garbage collector tracks and reclaims objects allocated in managed memory.</span></span> <span data-ttu-id="42538-106">Периодически сборщик мусора выполняет сборку мусора для освобождения памяти, выделенной для объектов, для которых не существует допустимых ссылок.</span><span class="sxs-lookup"><span data-stu-id="42538-106">Periodically, the garbage collector performs garbage collection to reclaim memory allocated to objects for which there are no valid references.</span></span> <span data-ttu-id="42538-107">Сборка мусора происходит автоматически, если запрос на выделение памяти не могут быть удовлетворены с помощью доступной свободной памяти.</span><span class="sxs-lookup"><span data-stu-id="42538-107">Garbage collection happens automatically when a request for memory cannot be satisfied using available free memory.</span></span> <span data-ttu-id="42538-108">Кроме того, приложение может принудительно запустить сбор мусора с помощью <xref:System.GC.Collect%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="42538-108">Alternatively, an application can force garbage collection using the <xref:System.GC.Collect%2A> method.</span></span>  
  
 <span data-ttu-id="42538-109">Сборка мусора состоит из следующих действий:</span><span class="sxs-lookup"><span data-stu-id="42538-109">Garbage collection consists of the following steps:</span></span>  
  
1.  <span data-ttu-id="42538-110">Сборщик мусора выполняет поиск управляемых объектов, на которые имеются ссылки в управляемом коде.</span><span class="sxs-lookup"><span data-stu-id="42538-110">The garbage collector searches for managed objects that are referenced in managed code.</span></span>  
  
2.  <span data-ttu-id="42538-111">Сборщик мусора пытается завершить объекты, на которые нет ссылок.</span><span class="sxs-lookup"><span data-stu-id="42538-111">The garbage collector tries to finalize objects that are not referenced.</span></span>  
  
3.  <span data-ttu-id="42538-112">Сборщик мусора освобождает объекты, на которые нет ссылок и возвращает их память.</span><span class="sxs-lookup"><span data-stu-id="42538-112">The garbage collector frees objects that are not referenced and reclaims their memory.</span></span>  
  
 <span data-ttu-id="42538-113">Этот раздел включает следующие подразделы:</span><span class="sxs-lookup"><span data-stu-id="42538-113">This topic includes the following sections:</span></span>  
  
 <span data-ttu-id="42538-114">[Сборщик мусора и неуправляемых ресурсов](#unmanaged) </span><span class="sxs-lookup"><span data-stu-id="42538-114">[The garbage collector and unmanaged resources](#unmanaged) </span></span>  
 <span data-ttu-id="42538-115">[Время существования объекта и поколений](#generations) </span><span class="sxs-lookup"><span data-stu-id="42538-115">[Object aging and generations](#generations) </span></span>  
 [<span data-ttu-id="42538-116">Отключение сбора мусора</span><span class="sxs-lookup"><span data-stu-id="42538-116">Disallowing garbage collection</span></span>](#NoGCRegion)  
  
<a name="unmanaged"></a>   
## <a name="the-garbage-collector-and-unmanaged-resources"></a><span data-ttu-id="42538-117">Сборщик мусора и неуправляемых ресурсов</span><span class="sxs-lookup"><span data-stu-id="42538-117">The garbage collector and unmanaged resources</span></span>  
 <span data-ttu-id="42538-118">Во время сбора сборщик мусора не освобождает объект при обнаружении одну или несколько ссылок на объект в управляемом коде.</span><span class="sxs-lookup"><span data-stu-id="42538-118">During a collection, the garbage collector will not free an object if it finds one or more references to the object in managed code.</span></span> <span data-ttu-id="42538-119">Тем не менее сборщик мусора не распознает ссылки на объект из неуправляемого кода и может уничтожать объекты, которые используются исключительно в неуправляемом коде, если явно запрещено сделать это.</span><span class="sxs-lookup"><span data-stu-id="42538-119">However, the garbage collector does not recognize references to an object from unmanaged code, and might free objects that are being used exclusively in unmanaged code unless explicitly prevented from doing so.</span></span> <span data-ttu-id="42538-120"><xref:System.GC.KeepAlive%2A> Метод предоставляет механизм, который не позволяет сборщику мусора сбор объектов, которые по-прежнему используются в неуправляемом коде.</span><span class="sxs-lookup"><span data-stu-id="42538-120">The <xref:System.GC.KeepAlive%2A> method provides a mechanism that prevents the garbage collector from collecting objects that are still in use in unmanaged code.</span></span>  
  
 <span data-ttu-id="42538-121">Помимо распределения управляемой памяти реализации сборщика мусора не работают со сведениями о ресурсах, принадлежащих объекту, такие как дескрипторы файлов или подключения к базе данных.</span><span class="sxs-lookup"><span data-stu-id="42538-121">Aside from managed memory allocations, implementations of the garbage collector do not maintain information about resources held by an object, such as file handles or database connections.</span></span> <span data-ttu-id="42538-122">Если тип использует неуправляемые ресурсы, которые должны быть освобождены до освобождения экземпляров типа, тип может реализовать метод завершения.</span><span class="sxs-lookup"><span data-stu-id="42538-122">When a type uses unmanaged resources that must be released before instances of the type are reclaimed, the type can implement a finalizer.</span></span>  
  
 <span data-ttu-id="42538-123">В большинстве случаев методы завершения реализуются путем переопределения <xref:System.Object.Finalize%2A?displayProperty=nameWithType> метода; тем не менее, типы, написанные на C# или C++ реализуют деструкторы, которые компилятор преобразует в переопределения <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="42538-123">In most cases, finalizers are implemented by overriding the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method; however, types written in C# or C++ implement destructors, which compilers turn into an override of <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="42538-124">В большинстве случаев Если объект имеет метод завершения, сборщик мусора вызывает его перед освобождением объекта.</span><span class="sxs-lookup"><span data-stu-id="42538-124">In most cases, if an object has a finalizer, the garbage collector calls it prior to freeing the object.</span></span> <span data-ttu-id="42538-125">Тем не менее сборщик мусора не является обязательным для вызова методов завершения во всех ситуациях; например <xref:System.GC.SuppressFinalize%2A> метод явным образом запрещает финализатор объекта вызова.</span><span class="sxs-lookup"><span data-stu-id="42538-125">However, the garbage collector is not required to call finalizers in all situations; for example, the <xref:System.GC.SuppressFinalize%2A> method explicitly prevents an object's finalizer from being called.</span></span> <span data-ttu-id="42538-126">Кроме того сборщик мусора не требуется использовать из определенного потока для завершения объектов или гарантирует порядок, в котором вызываются методы завершения для объектов, которые ссылаются друг на друга, но в остальном доступных для сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-126">Also, the garbage collector is not required to use a specific thread to finalize objects, or guarantee the order in which finalizers are called for objects that reference each other but are otherwise available for garbage collection.</span></span>  
  
 <span data-ttu-id="42538-127">В сценариях, где в определенное время, в котором необходимо освободить ресурсы, классы могут реализовывать <xref:System.IDisposable> интерфейс, содержащий <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> метод, который выполняет задачи управления и очистки ресурсов.</span><span class="sxs-lookup"><span data-stu-id="42538-127">In scenarios where resources must be released at a specific time, classes can implement the <xref:System.IDisposable> interface, which contains the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method that performs resource management and cleanup tasks.</span></span> <span data-ttu-id="42538-128">Классы, реализующие <xref:System.IDisposable.Dispose%2A> , необходимо указать как часть своего контракта класса, при потребителями класса вызовите метод, чтобы очистить объект.</span><span class="sxs-lookup"><span data-stu-id="42538-128">Classes that implement <xref:System.IDisposable.Dispose%2A> must specify, as part of their class contract, if and when class consumers call the method to clean up the object.</span></span> <span data-ttu-id="42538-129">Сборщик мусора не, по умолчанию вызывает <xref:System.IDisposable.Dispose%2A> метод, однако реализации <xref:System.IDisposable.Dispose%2A> метод можно вызывать методы в <xref:System.GC> класс для настройки поведения сборщика мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-129">The garbage collector does not, by default, call the <xref:System.IDisposable.Dispose%2A> method; however, implementations of the <xref:System.IDisposable.Dispose%2A> method can call methods in the <xref:System.GC> class to customize the finalization behavior of the garbage collector.</span></span>  
  
 <span data-ttu-id="42538-130">Дополнительные сведения о завершение объекта и шаблон dispose, см. в разделе [очистки неуправляемых ресурсов](~/docs/standard/garbage-collection/unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="42538-130">For more information on object finalization and the dispose pattern, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span>  
  
<a name="generations"></a>   
## <a name="object-aging-and-generations"></a><span data-ttu-id="42538-131">Время существования объекта и поколений</span><span class="sxs-lookup"><span data-stu-id="42538-131">Object aging and generations</span></span>  
 <span data-ttu-id="42538-132">Сборщик мусора в среда CLR поддерживает время существования объекта, с помощью поколений.</span><span class="sxs-lookup"><span data-stu-id="42538-132">The garbage collector in the common language runtime supports object aging using generations.</span></span> <span data-ttu-id="42538-133">Поколение — это единица измерения относительного времени хранения объектов в памяти.</span><span class="sxs-lookup"><span data-stu-id="42538-133">A generation is a unit of measure of the relative age of objects in memory.</span></span> <span data-ttu-id="42538-134">Номер поколения, или возраст объекта указывает поколения, к которой принадлежит объект.</span><span class="sxs-lookup"><span data-stu-id="42538-134">The generation number, or age, of an object indicates the generation to which an object belongs.</span></span> <span data-ttu-id="42538-135">Объекты, создаваемые дополнительные недавно входят новые поколения и имеют меньший номер поколения, чем цикл объекты, созданные ранее в жизни приложения.</span><span class="sxs-lookup"><span data-stu-id="42538-135">Objects created more recently are part of newer generations, and have lower generation numbers than objects created earlier in the application life cycle.</span></span> <span data-ttu-id="42538-136">Объекты в самого последнего поколения находятся в поколении 0.</span><span class="sxs-lookup"><span data-stu-id="42538-136">Objects in the most recent generation are in generation 0.</span></span> <span data-ttu-id="42538-137">Эта реализация сборщика мусора поддерживает три поколения объектов поколений 0, 1 и 2.</span><span class="sxs-lookup"><span data-stu-id="42538-137">This implementation of the garbage collector supports three generations of objects, generations 0, 1, and 2.</span></span> <span data-ttu-id="42538-138">Можно получить значение <xref:System.GC.MaxGeneration%2A> свойства, чтобы определить максимальный номер поколения поддерживается системой.</span><span class="sxs-lookup"><span data-stu-id="42538-138">You can retrieve the value of the <xref:System.GC.MaxGeneration%2A> property to determine the maximum generation number supported by the system.</span></span>  
  
 <span data-ttu-id="42538-139">Время существования объекта позволяет приложениям целевой сборка мусора на конкретный набор поколений, а не что сборщику мусора обрабатывать все поколения.</span><span class="sxs-lookup"><span data-stu-id="42538-139">Object aging allows applications to target garbage collection at a specific set of generations rather than requiring the garbage collector to evaluate all generations.</span></span> <span data-ttu-id="42538-140">Перегруженные версии <xref:System.GC.Collect%2A> метод, который включают `generation` параметра позволяют пользователю указать старших поколений, для быть подвергнута сбору мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-140">Overloads of the <xref:System.GC.Collect%2A> method that include a `generation` parameter allow you to specify the oldest generation to be garbage collected.</span></span>  
  
<a name="NoGCRegion"></a>   
## <a name="disallowing-garbage-collection"></a><span data-ttu-id="42538-141">Отключение сбора мусора</span><span class="sxs-lookup"><span data-stu-id="42538-141">Disallowing garbage collection</span></span>  
 <span data-ttu-id="42538-142">Начиная с [!INCLUDE[net_v46](~/includes/net-v46-md.md)], сборщик мусора поддерживает GC режим задержки без области, можно использовать во время выполнения критических путей, в какие сборки мусора коллекции может отрицательно сказаться на производительности приложения.</span><span class="sxs-lookup"><span data-stu-id="42538-142">Starting with the [!INCLUDE[net_v46](~/includes/net-v46-md.md)], the garbage collector supports a no GC region latency mode that can be used during the execution of critical paths in which garbage collection can adversely affect an app's performance.</span></span> <span data-ttu-id="42538-143">Сборщик Мусора режим задержки без области, необходимо указать объем памяти, который может быть выделен, не мешая сборщиком мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-143">The no GC region latency mode requires that you specify an amount of memory that can be allocated without interference from the garbage collector.</span></span> <span data-ttu-id="42538-144">Если среда выполнения может выделить память, среда выполнения не выполнит сбор мусора во время выполнения кода на критическом пути.</span><span class="sxs-lookup"><span data-stu-id="42538-144">If the runtime can allocate that memory, the runtime will not perform a garbage collection while code in the critical path is executing.</span></span>  
  
 <span data-ttu-id="42538-145">Определение начала критический путь без области сборки Мусора путем вызова одной из перегрузок <xref:System.GC.TryStartNoGCRegion%2A>.</span><span class="sxs-lookup"><span data-stu-id="42538-145">You define the beginning of the critical path of the no GC region by calling one of the overloads of the <xref:System.GC.TryStartNoGCRegion%2A>.</span></span> <span data-ttu-id="42538-146">Укажите в конец его критического пути, вызвав <xref:System.GC.EndNoGCRegion%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="42538-146">You specify the end of its critical path by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 <span data-ttu-id="42538-147">Не удается вложить вызовы к <xref:System.GC.TryStartNoGCRegion%2A> метод и вы должны вызывать только <xref:System.GC.EndNoGCRegion%2A> метод, если среда выполнения в настоящее время находится в режиме задержки без области сборки Мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-147">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="42538-148">Другими словами, не следует вызывать <xref:System.GC.TryStartNoGCRegion%2A> несколько раз (после первого вызова метода, последующие вызовы не будет выполнено), и не должен ожидать вызовы <xref:System.GC.EndNoGCRegion%2A> для успешного выполнения только потому, что первый вызов <xref:System.GC.TryStartNoGCRegion%2A> выполнена успешно.</span><span class="sxs-lookup"><span data-stu-id="42538-148">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42538-149">В следующем примере несколько методов сборки Мусора поколения памяти данные о блоке неиспользуемых объектов и вывода его на консоль.</span><span class="sxs-lookup"><span data-stu-id="42538-149">The following example uses several GC methods to get generation and memory information about a block of unused objects and print it to the console.</span></span> <span data-ttu-id="42538-150">Неиспользуемые объекты затем собираются и отображаются результирующие итоги памяти.</span><span class="sxs-lookup"><span data-stu-id="42538-150">The unused objects are then collected, and the resulting memory totals are displayed.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Runtime.GCSettings" />
    <related type="Article" href="~/docs/standard/garbage-collection/index.md"><span data-ttu-id="42538-151">Сборка мусора</span><span class="sxs-lookup"><span data-stu-id="42538-151">Garbage Collection</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2"><span data-ttu-id="42538-152">Основы сборки мусора</span><span class="sxs-lookup"><span data-stu-id="42538-152">Fundamentals of Garbage Collection</span></span></related>
  </Docs>
  <Members>
    <Member MemberName="AddMemoryPressure">
      <MemberSignature Language="C#" Value="public static void AddMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.AddMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMemoryPressure(long bytesAllocated);" />
      <MemberSignature Language="F#" Value="static member AddMemoryPressure : int64 -&gt; unit" Usage="System.GC.AddMemoryPressure bytesAllocated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated"><span data-ttu-id="42538-153">Объем, на который увеличен объем выделенной неуправляемой памяти.</span><span class="sxs-lookup"><span data-stu-id="42538-153">The incremental amount of unmanaged memory that has been allocated.</span></span></param>
        <summary><span data-ttu-id="42538-154">Информирует среду выполнения о выделении большого объема неуправляемой памяти, которую необходимо учесть при планировании сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-154">Informs the runtime of a large allocation of unmanaged memory that should be taken into account when scheduling garbage collection.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42538-155">При определении времени запланировать сбор мусора, среда выполнения учитывает объем управляемой памяти выделяется.</span><span class="sxs-lookup"><span data-stu-id="42538-155">In determining when to schedule garbage collection, the runtime takes into account how much managed memory is allocated.</span></span> <span data-ttu-id="42538-156">Если маленький управляемый объект выделяет большой объем неуправляемой памяти, среда выполнения учитывает только управляемую память и поэтому недооценивает срочность планировании сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-156">If a small managed object allocates a large amount of unmanaged memory, the runtime takes into account only the managed memory, and thus underestimates the urgency of scheduling garbage collection.</span></span> <span data-ttu-id="42538-157"><xref:System.GC.AddMemoryPressure%2A> Метод информирует среду CLR о этот дополнительную нагрузку на системную память.</span><span class="sxs-lookup"><span data-stu-id="42538-157">The <xref:System.GC.AddMemoryPressure%2A> method informs the runtime of this additional pressure on system memory.</span></span>  
  
 <span data-ttu-id="42538-158">Самый простой шаблон использования, управляемый объект выделяет неуправляемую память в конструкторе и освобождает его в `Dispose` или `Finalize` метод.</span><span class="sxs-lookup"><span data-stu-id="42538-158">In the simplest usage pattern, a managed object allocates unmanaged memory in the constructor and releases it in the `Dispose` or `Finalize` method.</span></span> <span data-ttu-id="42538-159">Вызовите <xref:System.GC.AddMemoryPressure%2A> метод после выделения неуправляемой памяти и вызовите <xref:System.GC.RemoveMemoryPressure%2A> метод после ее освобождения.</span><span class="sxs-lookup"><span data-stu-id="42538-159">Call the <xref:System.GC.AddMemoryPressure%2A> method after allocating the unmanaged memory, and call the <xref:System.GC.RemoveMemoryPressure%2A> method after releasing it.</span></span>  
  
 <span data-ttu-id="42538-160">В более сложных сценариях, где выделения неуправляемой памяти значительно изменяется в течение времени существования управляемого объекта, можно вызвать <xref:System.GC.AddMemoryPressure%2A> и <xref:System.GC.RemoveMemoryPressure%2A> методы для взаимодействия эти добавочные изменения в среду выполнения.</span><span class="sxs-lookup"><span data-stu-id="42538-160">In more complicated scenarios, where the unmanaged memory allocation changes substantially during the lifetime of the managed object, you can call the <xref:System.GC.AddMemoryPressure%2A> and <xref:System.GC.RemoveMemoryPressure%2A> methods to communicate these incremental changes to the runtime.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="42538-161">Необходимо гарантировать, что удаляется именно степень давления, добавляемые.</span><span class="sxs-lookup"><span data-stu-id="42538-161">You must ensure that you remove exactly the amount of pressure you add.</span></span> <span data-ttu-id="42538-162">Невыполнение этого может отрицательно сказаться на производительности системы в приложениях, выполняемых в течение длительных периодов времени.</span><span class="sxs-lookup"><span data-stu-id="42538-162">Failing to do so can adversely affect the performance of the system in applications that run for long periods of time.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="42538-163"><paramref name="bytesAllocated" /> меньше или равно 0.</span><span class="sxs-lookup"><span data-stu-id="42538-163"><paramref name="bytesAllocated" /> is less than or equal to 0.</span></span>  
  
<span data-ttu-id="42538-164">-или-</span><span class="sxs-lookup"><span data-stu-id="42538-164">-or-</span></span> 
<span data-ttu-id="42538-165">На 32-разрядном компьютере <paramref name="bytesAllocated" /> больше <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="42538-165">On a 32-bit computer, <paramref name="bytesAllocated" /> is larger than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="42538-166">для возможности вызова неуправляемого кода, при обработке приоритетом сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-166">for the ability to call unmanaged code when manipulating garbage-collection priority.</span></span> <span data-ttu-id="42538-167">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="42538-167">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="42538-168">Требует полного доверия для непосредственного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="42538-168">requires full trust for the immediate caller.</span></span> <span data-ttu-id="42538-169">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="42538-169">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CancelFullGCNotification">
      <MemberSignature Language="C#" Value="public static void CancelFullGCNotification ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelFullGCNotification() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CancelFullGCNotification" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelFullGCNotification ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelFullGCNotification();" />
      <MemberSignature Language="F#" Value="static member CancelFullGCNotification : unit -&gt; unit" Usage="System.GC.CancelFullGCNotification " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="42538-170">Отменяет регистрацию уведомления о сборке мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-170">Cancels the registration of a garbage collection notification.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42538-171">Этот метод отменяет уведомление о сборке мусора, зарегистрированный с помощью <xref:System.GC.RegisterForFullGCNotification%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="42538-171">This method cancels a garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="42538-172">Нет необходимости вызывать этот метод перед настройкой пороговые значения параметров в последующих вызовах <xref:System.GC.RegisterForFullGCNotification%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="42538-172">You do not have to call this method before adjusting threshold parameter values in subsequent calls to the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42538-173">В следующем примере отменяется регистрация сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-173">The following example cancels a garbage collection registration.</span></span> <span data-ttu-id="42538-174">Этот пример является частью большего примера для [уведомлений сборки мусора](~/docs/standard/garbage-collection/notifications.md) раздела.</span><span class="sxs-lookup"><span data-stu-id="42538-174">This example is part of a larger example provided for the [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.</span></span>  
  
 [!code-cpp[GCNotification#7](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#7)]
 [!code-csharp[GCNotification#7](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#7)]
 [!code-vb[GCNotification#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42538-175">Этот член недоступен, если включена параллельная сборка мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-175">This member is not available when concurrent garbage collection is enabled.</span></span> <span data-ttu-id="42538-176">Сведения об отключении параллельной сборки мусора см. в статье, посвященной параметру среды выполнения [&lt;gcConcurrent&gt;](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md).</span><span class="sxs-lookup"><span data-stu-id="42538-176">See the [&lt;gcConcurrent&gt;](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) runtime setting for information about how to disable concurrent garbage collection.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="42538-177">для полного доверия для непосредственного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="42538-177">for full trust for the immediate caller.</span></span> <span data-ttu-id="42538-178">Этот член не может быть использован частично доверенным кодом.</span><span class="sxs-lookup"><span data-stu-id="42538-178">This member cannot be used by partially trusted code.</span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="42538-179">Требует полного доверия для непосредственного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="42538-179">requires full trust for the immediate caller.</span></span> <span data-ttu-id="42538-180">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="42538-180">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89"><span data-ttu-id="42538-181">Уведомления о сборке мусора</span><span class="sxs-lookup"><span data-stu-id="42538-181">Garbage Collection Notifications</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Collect">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="42538-182">Принудительно начинает сборку мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-182">Forces garbage collection.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect();" />
      <MemberSignature Language="F#" Value="static member Collect : unit -&gt; unit" Usage="System.GC.Collect " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="42538-183">Принудительно запускает немедленную сборку мусора для всех поколений.</span><span class="sxs-lookup"><span data-stu-id="42538-183">Forces an immediate garbage collection of all generations.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42538-184">Этот метод позволяет восстанавливать всю память, который недоступен.</span><span class="sxs-lookup"><span data-stu-id="42538-184">Use this method to try to reclaim all memory that is inaccessible.</span></span> <span data-ttu-id="42538-185">Он выполняет блокирующей сборки мусора для всех поколений.</span><span class="sxs-lookup"><span data-stu-id="42538-185">It performs a blocking garbage collection of all generations.</span></span>  
  
 <span data-ttu-id="42538-186">Все объекты, независимо от того, как долго они находятся в памяти, считаются для коллекции; Тем не менее объекты, упоминаемые в управляемом коде не собираются.</span><span class="sxs-lookup"><span data-stu-id="42538-186">All objects, regardless of how long they have been in memory, are considered for collection; however, objects that are referenced in managed code are not collected.</span></span> <span data-ttu-id="42538-187">Этот метод позволяет принудительно предпринять попытку освободить максимальный объем доступной памяти.</span><span class="sxs-lookup"><span data-stu-id="42538-187">Use this method to force the system to try to reclaim the maximum amount of available memory.</span></span>  
  
 <span data-ttu-id="42538-188">Начиная с [!INCLUDE[net_v451](~/includes/net-v451-md.md)], можно сжать кучу больших объектов (LOH), задав <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> свойства <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> перед вызовом <xref:System.GC.Collect%2A> метод, как показано следующем примере.</span><span class="sxs-lookup"><span data-stu-id="42538-188">Starting with the [!INCLUDE[net_v451](~/includes/net-v451-md.md)], you can compact the large object heap (LOH) by setting the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> before calling the <xref:System.GC.Collect%2A> method, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Runtime.GCSettings#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.gcsettings/cs/lohcompactionmode1.cs#1)]
 [!code-vb[System.Runtime.GCSettings#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.gcsettings/vb/lohcompactionmode1.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="42538-189">Следующий пример демонстрирует, как использовать <xref:System.GC.Collect%2A> метод, чтобы выполнить сборку мусора для всех поколений памяти.</span><span class="sxs-lookup"><span data-stu-id="42538-189">The following example demonstrates how to use the <xref:System.GC.Collect%2A> method to perform a collection on all generations of memory.</span></span> <span data-ttu-id="42538-190">Код создает число неиспользуемых объектов, а затем вызывает <xref:System.GC.Collect%2A> метод для их удаления из памяти.</span><span class="sxs-lookup"><span data-stu-id="42538-190">The code generates a number of unused objects, and then calls the <xref:System.GC.Collect%2A> method to clean them from memory.</span></span>  
  
 [!code-cpp[System.GC.Collect Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.Collect Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.Collect Example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.Collect Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/019008fe-4708-4e65-bebf-04fd9941e149"><span data-ttu-id="42538-191">Индуцированные коллекции</span><span class="sxs-lookup"><span data-stu-id="42538-191">Induced Collections</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation);" />
      <MemberSignature Language="F#" Value="static member Collect : int -&gt; unit" Usage="System.GC.Collect generation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="generation"><span data-ttu-id="42538-192">Количество старших поколений, для которых следует выполнить сборку мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-192">The number of the oldest generation to be garbage collected.</span></span></param>
        <summary><span data-ttu-id="42538-193">Принудительно начинает немедленную сборку мусора, начиная с нулевого поколения и вплоть до указанного поколения.</span><span class="sxs-lookup"><span data-stu-id="42538-193">Forces an immediate garbage collection from generation 0 through a specified generation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42538-194">Используйте этот метод для освобождения памяти, который недоступен.</span><span class="sxs-lookup"><span data-stu-id="42538-194">Use this method to try to reclaim memory that is inaccessible.</span></span> <span data-ttu-id="42538-195">Тем не менее с помощью этого метода не гарантирует что всю память, недоступны в указанном поколении.</span><span class="sxs-lookup"><span data-stu-id="42538-195">However, using this method does not guarantee that all inaccessible memory in the specified generation is reclaimed.</span></span>  
  
 <span data-ttu-id="42538-196">Если реализуется время существования объекта, сборщик мусора не собирать объекты с номер поколения больше заданного поколения.</span><span class="sxs-lookup"><span data-stu-id="42538-196">If object aging is implemented, the garbage collector does not collect objects with a generation number that is higher than the specified generation.</span></span> <span data-ttu-id="42538-197">Если время существования объекта не реализован, сборщик мусора считает, что все объекты во время сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-197">If object aging is not implemented, the garbage collector considers all objects during the garbage collection.</span></span>  
  
 <span data-ttu-id="42538-198">Используйте <xref:System.GC.MaxGeneration%2A> свойства, чтобы определить максимальное допустимое значение параметра `generation` параметр.</span><span class="sxs-lookup"><span data-stu-id="42538-198">Use the <xref:System.GC.MaxGeneration%2A> property to determine the maximum valid value of the `generation` parameter.</span></span>  
  
 <span data-ttu-id="42538-199">Чтобы сборщик мусора учесть все объекты, независимо от их создания, используйте версию этого метода, который не принимает параметров.</span><span class="sxs-lookup"><span data-stu-id="42538-199">To have the garbage collector consider all objects regardless of their generation, use the version of this method that takes no parameters.</span></span> <span data-ttu-id="42538-200">Чтобы сборщик мусора освобождает объекты, на основе <xref:System.GCCollectionMode> задание, используйте <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=nameWithType> перегрузки метода.</span><span class="sxs-lookup"><span data-stu-id="42538-200">To have the garbage collector reclaim objects based on a <xref:System.GCCollectionMode> setting, use the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=nameWithType> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42538-201">Следующий пример демонстрирует, как использовать <xref:System.GC.Collect%2A> метод, чтобы выполнить сборку мусора для отдельных уровней памяти.</span><span class="sxs-lookup"><span data-stu-id="42538-201">The following example demonstrates how to use the <xref:System.GC.Collect%2A> method to perform a collection on individual layers of memory.</span></span> <span data-ttu-id="42538-202">Код создает число неиспользуемых объектов, а затем вызывает <xref:System.GC.Collect%2A> метод для их удаления из памяти.</span><span class="sxs-lookup"><span data-stu-id="42538-202">The code generates a number of unused objects, and then calls the <xref:System.GC.Collect%2A> method to clean them from memory.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="42538-203">Недопустимый параметр <paramref name="generation" />.</span><span class="sxs-lookup"><span data-stu-id="42538-203"><paramref name="generation" /> is not valid.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/019008fe-4708-4e65-bebf-04fd9941e149"><span data-ttu-id="42538-204">Индуцированные коллекции</span><span class="sxs-lookup"><span data-stu-id="42538-204">Induced Collections</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode -&gt; unit" Usage="System.GC.Collect (generation, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.GCCollectionMode" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="generation"><span data-ttu-id="42538-205">Количество старших поколений, для которых следует выполнить сборку мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-205">The number of the oldest generation to be garbage collected.</span></span></param>
        <param name="mode"><span data-ttu-id="42538-206">Значение перечисления, указывающее, является ли сборка мусора принудительной (<see cref="F:System.GCCollectionMode.Default" /> или <see cref="F:System.GCCollectionMode.Forced" />) или оптимизированной (<see cref="F:System.GCCollectionMode.Optimized" />).</span><span class="sxs-lookup"><span data-stu-id="42538-206">An enumeration value that specifies whether the garbage collection is forced (<see cref="F:System.GCCollectionMode.Default" /> or <see cref="F:System.GCCollectionMode.Forced" />) or optimized (<see cref="F:System.GCCollectionMode.Optimized" />).</span></span></param>
        <summary><span data-ttu-id="42538-207">Принудительно запускает немедленную сборку мусора начиная с нулевого поколения и вплоть до указанного поколения в момент времени, заданный значением <see cref="T:System.GCCollectionMode" />.</span><span class="sxs-lookup"><span data-stu-id="42538-207">Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <see cref="T:System.GCCollectionMode" /> value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42538-208">Используйте `mode` параметр для указания сборки мусора должна ли выполняться немедленно или только если время является оптимальным для освобождения объектов.</span><span class="sxs-lookup"><span data-stu-id="42538-208">Use the `mode` parameter to specify whether garbage collection should occur immediately or only if the time is optimal to reclaim objects.</span></span> <span data-ttu-id="42538-209">С помощью этого метода не гарантирует что всю память, недоступны в указанном поколении.</span><span class="sxs-lookup"><span data-stu-id="42538-209">Using this method does not guarantee that all inaccessible memory in the specified generation is reclaimed.</span></span>  
  
 <span data-ttu-id="42538-210">Чтобы настроить степень вмешательства сборщика мусора критические периоды, в приложении, установите <xref:System.Runtime.GCSettings.LatencyMode%2A> свойство.</span><span class="sxs-lookup"><span data-stu-id="42538-210">To adjust the intrusiveness of garbage collection during critical periods in your application, set the <xref:System.Runtime.GCSettings.LatencyMode%2A> property.</span></span>  
  
 <span data-ttu-id="42538-211">Сборщик мусора не собирает объекты с номер поколения, выше, чем указано в `generation` параметра.</span><span class="sxs-lookup"><span data-stu-id="42538-211">The garbage collector does not collect objects with a generation number higher than specified by the `generation` parameter.</span></span> <span data-ttu-id="42538-212">Используйте <xref:System.GC.MaxGeneration%2A> свойства, чтобы определить максимальное допустимое значение `generation`.</span><span class="sxs-lookup"><span data-stu-id="42538-212">Use the <xref:System.GC.MaxGeneration%2A> property to determine the maximum valid value of `generation`.</span></span>  
  
 <span data-ttu-id="42538-213">Чтобы сборщик мусора учесть все объекты, независимо от их создания, используйте версию этого метода, который не принимает параметров.</span><span class="sxs-lookup"><span data-stu-id="42538-213">To have the garbage collector consider all objects regardless of their generation, use the version of this method that takes no parameters.</span></span>  
  
 <span data-ttu-id="42538-214">Чтобы сборщик мусора освобождает объекты, вплоть до указанного поколения объектов, используйте <xref:System.GC.Collect%28System.Int32%29?displayProperty=nameWithType> перегрузки метода.</span><span class="sxs-lookup"><span data-stu-id="42538-214">To have the garbage collector reclaim objects up to a specified generation of objects, use the <xref:System.GC.Collect%28System.Int32%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="42538-215">При указании максимально возможного поколения собираются все объекты.</span><span class="sxs-lookup"><span data-stu-id="42538-215">When you specify the maximum generation, all objects are collected.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42538-216">Следующий пример принудительно проводит сборку мусора для объектов поколения 2 с <xref:System.GCCollectionMode.Optimized> параметр.</span><span class="sxs-lookup"><span data-stu-id="42538-216">The following example forces a garbage collection for generation 2 objects with the <xref:System.GCCollectionMode.Optimized> setting.</span></span>  
  
 [!code-csharp[System.GC.GCCollectionMode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GCCollectionMode/cs/Program.cs#1)]
 [!code-vb[System.GC.GCCollectionMode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GCCollectionMode/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="42538-217">Недопустимый параметр <paramref name="generation" />.</span><span class="sxs-lookup"><span data-stu-id="42538-217"><paramref name="generation" /> is not valid.</span></span>  
  
<span data-ttu-id="42538-218">-или-</span><span class="sxs-lookup"><span data-stu-id="42538-218">-or-</span></span> 
 <span data-ttu-id="42538-219">Параметр <paramref name="mode" /> не является одним из значений <see cref="T:System.GCCollectionMode" />.</span><span class="sxs-lookup"><span data-stu-id="42538-219"><paramref name="mode" /> is not one of the <see cref="T:System.GCCollectionMode" /> values.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/019008fe-4708-4e65-bebf-04fd9941e149"><span data-ttu-id="42538-220">Индуцированные коллекции</span><span class="sxs-lookup"><span data-stu-id="42538-220">Induced Collections</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode * bool -&gt; unit" Usage="System.GC.Collect (generation, mode, blocking)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.GCCollectionMode" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="blocking" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="generation"><span data-ttu-id="42538-221">Количество старших поколений, для которых следует выполнить сборку мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-221">The number of the oldest generation to be garbage collected.</span></span></param>
        <param name="mode"><span data-ttu-id="42538-222">Значение перечисления, указывающее, является ли сборка мусора принудительной (<see cref="F:System.GCCollectionMode.Default" /> или <see cref="F:System.GCCollectionMode.Forced" />) или оптимизированной (<see cref="F:System.GCCollectionMode.Optimized" />).</span><span class="sxs-lookup"><span data-stu-id="42538-222">An enumeration value that specifies whether the garbage collection is forced (<see cref="F:System.GCCollectionMode.Default" /> or <see cref="F:System.GCCollectionMode.Forced" />) or optimized (<see cref="F:System.GCCollectionMode.Optimized" />).</span></span></param>
        <param name="blocking"><span data-ttu-id="42538-223">Значение <see langword="true" /> для выполнения сборки мусора с блокировкой; значение <see langword="false" /> для выполнения фоновой сборки мусора, где это возможно.</span><span class="sxs-lookup"><span data-stu-id="42538-223"><see langword="true" /> to perform a blocking garbage collection; <see langword="false" /> to perform a background garbage collection where possible.</span></span></param>
        <summary><span data-ttu-id="42538-224">Принудительная сборка мусора с поколения 0 до указанного поколения во время, указанное значением <see cref="T:System.GCCollectionMode" />, со значением, указывающим, должна ли сборка быть блокирующей.</span><span class="sxs-lookup"><span data-stu-id="42538-224">Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <see cref="T:System.GCCollectionMode" /> value, with a value specifying whether the collection should be blocking.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42538-225">В следующей таблице перечислены взаимодействия `mode` и `blocking` параметры:</span><span class="sxs-lookup"><span data-stu-id="42538-225">The following table summarizes the interaction of the `mode` and `blocking` parameters:</span></span>  
  
|`mode`|<span data-ttu-id="42538-226">`blocking` равно `true`</span><span class="sxs-lookup"><span data-stu-id="42538-226">`blocking` is `true`</span></span>|<span data-ttu-id="42538-227">Параметр `blocking` содержит значение `false`</span><span class="sxs-lookup"><span data-stu-id="42538-227">`blocking` is `false`</span></span>|  
|-|-|-|  
|<span data-ttu-id="42538-228"><xref:System.GCCollectionMode.Forced> или <xref:System.GCCollectionMode.Default></span><span class="sxs-lookup"><span data-stu-id="42538-228"><xref:System.GCCollectionMode.Forced> or <xref:System.GCCollectionMode.Default></span></span>|<span data-ttu-id="42538-229">Блокирующий сбор выполнится, как только это станет возможным.</span><span class="sxs-lookup"><span data-stu-id="42538-229">A blocking collection is performed as soon as possible.</span></span> <span data-ttu-id="42538-230">Если фоновая сборка выполняется и `generation` равен 0 или 1, <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> метод немедленно активирует блокирующую сборку и возвращает при завершении коллекции.</span><span class="sxs-lookup"><span data-stu-id="42538-230">If a background collection is in progress and `generation` is 0 or 1, the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method immediately triggers a blocking collection and returns when the collection is finished.</span></span> <span data-ttu-id="42538-231">Если фоновая сборка выполняется и `generation` равно 2, метод дожидается завершения фоновой сборки, активирует блокирующую сборку поколения 2 и возвращает.</span><span class="sxs-lookup"><span data-stu-id="42538-231">If a background collection is in progress and `generation` is 2, the method waits until the background collection is finished, triggers a blocking generation 2 collection, and then returns.</span></span>|<span data-ttu-id="42538-232">Сборка выполнится, как только это станет возможным.</span><span class="sxs-lookup"><span data-stu-id="42538-232">A collection is performed as soon as possible.</span></span> <span data-ttu-id="42538-233">Метод <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> запрашивает фоновую коллекцию, однако это не гарантированно. В зависимости от обстоятельств блокирующая коллекция может выполняться.</span><span class="sxs-lookup"><span data-stu-id="42538-233">The <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed.</span></span> <span data-ttu-id="42538-234">Если фоновая сборка уже выполняется, метод возвращает управление немедленно.</span><span class="sxs-lookup"><span data-stu-id="42538-234">If a background collection is already in progress, the method returns immediately.</span></span>|  
|<xref:System.GCCollectionMode.Optimized>|<span data-ttu-id="42538-235">Заблокированная коллекция может быть выполнена в зависимости от состояния сборщика мусора и параметра `generation`.</span><span class="sxs-lookup"><span data-stu-id="42538-235">A blocking collection may be performed, depending on the state of the garbage collector and the `generation` parameter.</span></span> <span data-ttu-id="42538-236">Сборщик мусора пытается обеспечить оптимальную производительность.</span><span class="sxs-lookup"><span data-stu-id="42538-236">The garbage collector tries to provide optimal performance.</span></span>|<span data-ttu-id="42538-237">Коллекция может быть выполнена в зависимости от состояния сборщика мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-237">A collection may be performed, depending on the state of the garbage collector.</span></span> <span data-ttu-id="42538-238">Метод <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> запрашивает фоновую коллекцию, однако это не гарантированно. В зависимости от обстоятельств блокирующая коллекция может выполняться.</span><span class="sxs-lookup"><span data-stu-id="42538-238">The <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed.</span></span> <span data-ttu-id="42538-239">Сборщик мусора пытается обеспечить оптимальную производительность.</span><span class="sxs-lookup"><span data-stu-id="42538-239">The garbage collector tries to provide optimal performance.</span></span> <span data-ttu-id="42538-240">Если фоновая сборка уже выполняется, метод возвращает управление немедленно.</span><span class="sxs-lookup"><span data-stu-id="42538-240">If a background collection is already in progress, the method returns immediately.</span></span>|  
  
 <span data-ttu-id="42538-241">Если в вызове <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> полной блокирующей сборки мусора выполняет метод, можно также сжать кучу больших объектов, задав <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> свойства <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> перед вызовом <xref:System.GC.Collect%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="42538-241">If a call to the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method performs a full blocking garbage collection, you can also compact the large object heap by setting the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> before calling the <xref:System.GC.Collect%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="42538-242">Недопустимый параметр <paramref name="generation" />.</span><span class="sxs-lookup"><span data-stu-id="42538-242"><paramref name="generation" /> is not valid.</span></span>  
  
<span data-ttu-id="42538-243">-или-</span><span class="sxs-lookup"><span data-stu-id="42538-243">-or-</span></span> 
 <span data-ttu-id="42538-244">Параметр <paramref name="mode" /> не является одним из значений <see cref="T:System.GCCollectionMode" />.</span><span class="sxs-lookup"><span data-stu-id="42538-244"><paramref name="mode" /> is not one of the <see cref="T:System.GCCollectionMode" /> values.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking, bool compacting) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean, compacting As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode * bool * bool -&gt; unit" Usage="System.GC.Collect (generation, mode, blocking, compacting)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="mode" Type="System.GCCollectionMode" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="blocking" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="compacting" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="generation"><span data-ttu-id="42538-245">Количество старших поколений, для которых следует выполнить сборку мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-245">The number of the oldest generation to be garbage collected.</span></span></param>
        <param name="mode"><span data-ttu-id="42538-246">Значение перечисления, указывающее, является ли сборка мусора принудительной (<see cref="F:System.GCCollectionMode.Default" /> или <see cref="F:System.GCCollectionMode.Forced" />) или оптимизированной (<see cref="F:System.GCCollectionMode.Optimized" />).</span><span class="sxs-lookup"><span data-stu-id="42538-246">An enumeration value that specifies whether the garbage collection is forced (<see cref="F:System.GCCollectionMode.Default" /> or <see cref="F:System.GCCollectionMode.Forced" />) or optimized (<see cref="F:System.GCCollectionMode.Optimized" />).</span></span></param>
        <param name="blocking"><span data-ttu-id="42538-247">Значение <see langword="true" /> для выполнения сборки мусора с блокировкой; значение <see langword="false" /> для выполнения фоновой сборки мусора, где это возможно.</span><span class="sxs-lookup"><span data-stu-id="42538-247"><see langword="true" /> to perform a blocking garbage collection; <see langword="false" /> to perform a background garbage collection where possible.</span></span></param>
        <param name="compacting"><span data-ttu-id="42538-248">Значение <see langword="true" />, чтобы сжимать кучу маленьких объектов; значение <see langword="false" />, чтобы только очищать.</span><span class="sxs-lookup"><span data-stu-id="42538-248"><see langword="true" /> to compact the small object heap; <see langword="false" /> to sweep only.</span></span></param>
        <summary><span data-ttu-id="42538-249">Принудительная сборка мусора с поколения 0 до указанного поколения во время, указанное значением <see cref="T:System.GCCollectionMode" />, со значениями, указывающими, должна ли сборка быть блокирующей и сжимающей.</span><span class="sxs-lookup"><span data-stu-id="42538-249">Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <see cref="T:System.GCCollectionMode" /> value, with values that specify whether the collection should be blocking and compacting.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42538-250">Если `blocking` является `false`, сборщик Мусора решает, следует ли для выполнения фоновых или блокирующей сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-250">If `blocking` is `false`, the GC decides whether to perform a background or a blocking garbage collection.</span></span> <span data-ttu-id="42538-251">Если `compacting` является `true`, он выполняет блокирующей сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-251">If `compacting` is `true`, it performs a blocking garbage collection.</span></span>  
  
 <span data-ttu-id="42538-252">Если `compacting` является `true`, среда выполнения сжимает кучу небольших объектов (SOH).</span><span class="sxs-lookup"><span data-stu-id="42538-252">If `compacting` is `true`, the runtime compacts the small object heap (SOH).</span></span> <span data-ttu-id="42538-253">Куча больших объектов (LOH) не сжимается, если не <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> свойству <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="42538-253">The large object heap (LOH) is not compacted unless the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property is set to <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>.</span></span> <span data-ttu-id="42538-254">Обратите внимание, что сюда входят все блокирующие сборки мусора, не только полностью блокирующие сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-254">Note that this includes all blocking garbage collections, not just full blocking garbage collections.</span></span>  
  
 <span data-ttu-id="42538-255">Вы можете вызвать <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> метод уменьшить размер управляемой кучи до минимального размера, как показано в следующем фрагменте кода.</span><span class="sxs-lookup"><span data-stu-id="42538-255">You can call the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> method to reduce the managed heap to the smallest size possible, as the following code fragment illustrates.</span></span>  
  
 [!code-csharp[System.GC.Collect#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect/cs/collect4.cs#1)]
 [!code-vb[System.GC.Collect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect/vb/collect4.vb#1)]  
  
 <span data-ttu-id="42538-256">Указание `true` для `compacting` аргумент гарантирует со сжатием, полной блокирующей сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-256">Specifying `true` for the `compacting` argument guarantees a compacting, full blocking garbage collection.</span></span> <span data-ttu-id="42538-257">Установка <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> свойства <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> гарантирует, что SOH и LOH сжимаются.</span><span class="sxs-lookup"><span data-stu-id="42538-257">Setting the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> ensures that both the LOH and SOH are compacted.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CollectionCount">
      <MemberSignature Language="C#" Value="public static int CollectionCount (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CollectionCount(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CollectionCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CollectionCount (generation As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CollectionCount(int generation);" />
      <MemberSignature Language="F#" Value="static member CollectionCount : int -&gt; int" Usage="System.GC.CollectionCount generation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="generation"><span data-ttu-id="42538-258">Поколение объектов, для которого будет определено количество операций сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-258">The generation of objects for which the garbage collection count is to be determined.</span></span></param>
        <summary><span data-ttu-id="42538-259">Возвращает количество операций сборки мусора, выполненных для заданного поколения объектов.</span><span class="sxs-lookup"><span data-stu-id="42538-259">Returns the number of times garbage collection has occurred for the specified generation of objects.</span></span></summary>
        <returns><span data-ttu-id="42538-260">Количество операций сборки мусора, выполненных для заданного поколения объектов с начала процесса.</span><span class="sxs-lookup"><span data-stu-id="42538-260">The number of times garbage collection has occurred for the specified generation since the process was started.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42538-261">Если вы реализуете собственное управление ресурсами, может потребоваться принудительно запустить сборку мусора периодически путем вызова <xref:System.GC.Collect%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="42538-261">If you implement your own resource management, you might need to force garbage collection periodically by calling the <xref:System.GC.Collect%2A> method.</span></span> <span data-ttu-id="42538-262">Так как это ресурсоемкая операция, можно повысить производительность, пропуская указанный вызов, когда сбор мусора выполнена недавно.</span><span class="sxs-lookup"><span data-stu-id="42538-262">Because this is an expensive operation, you can improve performance by skipping the call when a garbage collection has occurred recently.</span></span> <span data-ttu-id="42538-263">Сохраните значение, возвращенное <xref:System.GC.CollectionCount%2A> сразу после вызова <xref:System.GC.Collect%2A>.</span><span class="sxs-lookup"><span data-stu-id="42538-263">Save the value returned by <xref:System.GC.CollectionCount%2A> immediately after calling <xref:System.GC.Collect%2A>.</span></span> <span data-ttu-id="42538-264">В следующий раз, необходимо вызвать <xref:System.GC.Collect%2A>, сравнить текущее значение, возвращенное <xref:System.GC.CollectionCount%2A> сохраненному значению.</span><span class="sxs-lookup"><span data-stu-id="42538-264">The next time you need to call <xref:System.GC.Collect%2A>, compare the current value returned by <xref:System.GC.CollectionCount%2A> to the saved value.</span></span> <span data-ttu-id="42538-265">Если два значения равны, ни одна из коллекций произошло до этого времени, и следует вызвать <xref:System.GC.Collect%2A> еще раз.</span><span class="sxs-lookup"><span data-stu-id="42538-265">If the two values are equal, no collection has occurred in the interim and it is reasonable to call <xref:System.GC.Collect%2A> again.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="42538-266">Значение параметра <paramref name="generation" /> меньше 0.</span><span class="sxs-lookup"><span data-stu-id="42538-266"><paramref name="generation" /> is less than 0.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndNoGCRegion">
      <MemberSignature Language="C#" Value="public static void EndNoGCRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndNoGCRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.EndNoGCRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndNoGCRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndNoGCRegion();" />
      <MemberSignature Language="F#" Value="static member EndNoGCRegion : unit -&gt; unit" Usage="System.GC.EndNoGCRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="42538-267">Завершает режим задержки без области сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-267">Ends the no GC region latency mode.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42538-268"><xref:System.GC.EndNoGCRegion%2A> Вызывает метод <xref:System.InvalidOperationException> если сборщик мусора не находится в режиме задержки без области сборки Мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-268">The <xref:System.GC.EndNoGCRegion%2A> method throws an <xref:System.InvalidOperationException> if the garbage collector is not in no GC region latency mode.</span></span> <span data-ttu-id="42538-269">Это происходит при любом из следующих условий:</span><span class="sxs-lookup"><span data-stu-id="42538-269">This occurs under any of the following conditions:</span></span>  
  
-   <span data-ttu-id="42538-270"><xref:System.GC.TryStartNoGCRegion%2A> Метод не был вызван ранее.</span><span class="sxs-lookup"><span data-stu-id="42538-270">The <xref:System.GC.TryStartNoGCRegion%2A> method was not called previously.</span></span>  
  
-   <span data-ttu-id="42538-271">Вызов <xref:System.GC.TryStartNoGCRegion%2A> возвращаемое значение метода `false`.</span><span class="sxs-lookup"><span data-stu-id="42538-271">The call to the <xref:System.GC.TryStartNoGCRegion%2A> method returned `false`.</span></span>  
  
-   <span data-ttu-id="42538-272">Вызов <xref:System.GC.TryStartNoGCRegion%2A> метод вызвал исключение.</span><span class="sxs-lookup"><span data-stu-id="42538-272">The call to the <xref:System.GC.TryStartNoGCRegion%2A> method threw an exception.</span></span>  
  
 <span data-ttu-id="42538-273">С помощью следующего кода можно предотвратить возникновение исключений для любой из следующих причин:</span><span class="sxs-lookup"><span data-stu-id="42538-273">You can prevent an exception for any of these reasons by using code such as the following:</span></span>  
  
 [!code-csharp[System.GC.EndNoGCRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.endnogcregion/cs/endnogcregion1.cs#1)]
 [!code-vb[System.GC.EndNoGCRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.endnogcregion/vb/endnogcregion1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42538-274">Сборщик мусора не находится в режиме задержки без области сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-274">The garbage collector is not in no GC region latency mode.</span></span>  
  
<span data-ttu-id="42538-275">-или-</span><span class="sxs-lookup"><span data-stu-id="42538-275">-or-</span></span> 
<span data-ttu-id="42538-276">Режим задержки без области сборки мусора был завершен заранее, поскольку была вызвана сборка мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-276">The no GC region latency mode was ended previously because a garbage collection was induced.</span></span>  
  
<span data-ttu-id="42538-277">-или-</span><span class="sxs-lookup"><span data-stu-id="42538-277">-or-</span></span> 
<span data-ttu-id="42538-278">Выделение памяти превышает объем, указанный в вызове метода <see cref="M:System.GC.TryStartNoGCRegion(System.Int64)" />.</span><span class="sxs-lookup"><span data-stu-id="42538-278">A memory allocation exceeded the amount specified in the call to the <see cref="M:System.GC.TryStartNoGCRegion(System.Int64)" /> method.</span></span></exception>
        <altmember cref="M:System.GC.TryStartNoGCRegion(System.Int64)" />
        <altmember cref="P:System.Runtime.GCSettings.LatencyMode" />
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81"><span data-ttu-id="42538-279">Режимы задержки</span><span class="sxs-lookup"><span data-stu-id="42538-279">Latency Modes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetAllocatedBytesForCurrentThread">
      <MemberSignature Language="C#" Value="public static long GetAllocatedBytesForCurrentThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetAllocatedBytesForCurrentThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetAllocatedBytesForCurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAllocatedBytesForCurrentThread () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetAllocatedBytesForCurrentThread();" />
      <MemberSignature Language="F#" Value="static member GetAllocatedBytesForCurrentThread : unit -&gt; int64" Usage="System.GC.GetAllocatedBytesForCurrentThread " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="42538-280">Возвращает общее число байтов, выделенных для текущего потока с начала времени его существования.</span><span class="sxs-lookup"><span data-stu-id="42538-280">Gets the total number of bytes allocated to the current thread since the beginning of its lifetime.</span></span></summary>
        <returns><span data-ttu-id="42538-281">Общее число байтов, выделенных для текущего потока с начала времени его существования.</span><span class="sxs-lookup"><span data-stu-id="42538-281">The total number of bytes allocated to the current thread since the beginning of its lifetime.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="42538-282">`GetAllocatedBytesForCurrentThread` Метод возвращает общее число байтов, выделенных в управляемой куче, в течение времени существования потока, а не общее число байтов, которые остались после сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-282">The `GetAllocatedBytesForCurrentThread` method returns the total number of bytes allocated on the managed heap during the lifetime of a thread, not the total number of bytes that have survived garbage collection.</span></span> <span data-ttu-id="42538-283">Возвращаемое значение также не поддерживает все собственные выделения.</span><span class="sxs-lookup"><span data-stu-id="42538-283">The returned value also does not include any native allocations.</span></span>

<span data-ttu-id="42538-284">Этот метод особенно полезен в сценарии для измерения отличаются выделения памяти интервалы времени или события мониторинга.</span><span class="sxs-lookup"><span data-stu-id="42538-284">This method is most useful in monitoring scenarios for measuring the difference in memory allocation between time intervals or events.</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGCMemoryInfo">
      <MemberSignature Language="C#" Value="public static GCMemoryInfo GetGCMemoryInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCMemoryInfo GetGCMemoryInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGCMemoryInfo" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGCMemoryInfo () As GCMemoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCMemoryInfo GetGCMemoryInfo();" />
      <MemberSignature Language="F#" Value="static member GetGCMemoryInfo : unit -&gt; GCMemoryInfo" Usage="System.GC.GetGCMemoryInfo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.GCMemoryInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGeneration">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="42538-285">Возвращает текущий номер поколения объекта.</span><span class="sxs-lookup"><span data-stu-id="42538-285">Returns the current generation number of an object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (obj As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetGeneration : obj -&gt; int" Usage="System.GC.GetGeneration obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="42538-286">Объект, информация о поколении которого извлекается.</span><span class="sxs-lookup"><span data-stu-id="42538-286">The object that generation information is retrieved for.</span></span></param>
        <summary><span data-ttu-id="42538-287">Возвращает номер текущего поколения указанного объекта.</span><span class="sxs-lookup"><span data-stu-id="42538-287">Returns the current generation number of the specified object.</span></span></summary>
        <returns><span data-ttu-id="42538-288">Текущий номер поколения <paramref name="obj" />.</span><span class="sxs-lookup"><span data-stu-id="42538-288">The current generation number of <paramref name="obj" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42538-289">Этот метод позволяет определить возраст объекта, а затем использовать эти сведения с <xref:System.GC.Collect%2A> объектов способ принудительного сборщику мусора этого поколения.</span><span class="sxs-lookup"><span data-stu-id="42538-289">Use this method to determine the age of an object, and then use that information with the <xref:System.GC.Collect%2A> method to force the garbage collector to collect objects in the same generation.</span></span> <span data-ttu-id="42538-290">Например используйте этот метод при наличии набора объектов, которые создаются в виде группы и стали недоступными в то же время.</span><span class="sxs-lookup"><span data-stu-id="42538-290">For example, use this method when you have a set of objects that are created as a group and that become inaccessible at the same time.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42538-291">Следующий пример демонстрирует, как использовать <xref:System.GC.GetGeneration%2A> метод, чтобы определить возраст объекта.</span><span class="sxs-lookup"><span data-stu-id="42538-291">The following example demonstrates how to use the <xref:System.GC.GetGeneration%2A> method to determine the age of an object.</span></span> <span data-ttu-id="42538-292">Затем в примере выполняется сборки мусора для очистки памяти. и сравнения pre и post итоги памяти коллекции в консоли.</span><span class="sxs-lookup"><span data-stu-id="42538-292">The example then performs garbage collections to clean up memory and compare the pre and post collection memory totals in the console.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (WeakReference wo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(class System.WeakReference wo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.WeakReference)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (wo As WeakReference) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(WeakReference ^ wo);" />
      <MemberSignature Language="F#" Value="static member GetGeneration : WeakReference -&gt; int" Usage="System.GC.GetGeneration wo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="wo" Type="System.WeakReference" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="wo"><span data-ttu-id="42538-293">Объект <see cref="T:System.WeakReference" />, указывающий на целевой объект, номер поколения которого требуется определить.</span><span class="sxs-lookup"><span data-stu-id="42538-293">A <see cref="T:System.WeakReference" /> that refers to the target object whose generation number is to be determined.</span></span></param>
        <summary><span data-ttu-id="42538-294">Возвращает текущий номер поколения для целевого объекта указанной слабой ссылки.</span><span class="sxs-lookup"><span data-stu-id="42538-294">Returns the current generation number of the target of a specified weak reference.</span></span></summary>
        <returns><span data-ttu-id="42538-295">Текущий номер поколения для целевого объекта <paramref name="wo" />.</span><span class="sxs-lookup"><span data-stu-id="42538-295">The current generation number of the target of <paramref name="wo" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="42538-296">В следующем примере показано использование <xref:System.GC.GetGeneration%2A> метод, чтобы определить, как давно обновлялось объект слабой ссылки.</span><span class="sxs-lookup"><span data-stu-id="42538-296">The following example demonstrates the use of the <xref:System.GC.GetGeneration%2A> method to determine the age of a weak reference object.</span></span>  
  
 [!code-cpp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CPP/systemgcgetgenerationweak.cpp#1)]
 [!code-csharp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CS/systemgcgetgenerationweak.cs#1)]
 [!code-vb[System.GC.GetGenerationWeak Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/VB/systemgcgetgenerationweak.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="42538-297">Сборка мусора уже выполнена для <paramref name="wo" />.</span><span class="sxs-lookup"><span data-stu-id="42538-297">Garbage collection has already been performed on <paramref name="wo" />.</span></span></exception>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetTotalAllocatedBytes">
      <MemberSignature Language="C#" Value="public static long GetTotalAllocatedBytes (bool precise = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetTotalAllocatedBytes(bool precise) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetTotalAllocatedBytes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTotalAllocatedBytes (Optional precise As Boolean = false) As Long" />
      <MemberSignature Language="F#" Value="static member GetTotalAllocatedBytes : bool -&gt; int64" Usage="System.GC.GetTotalAllocatedBytes precise" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="precise" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="precise">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTotalMemory">
      <MemberSignature Language="C#" Value="public static long GetTotalMemory (bool forceFullCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetTotalMemory(bool forceFullCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetTotalMemory(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTotalMemory (forceFullCollection As Boolean) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetTotalMemory(bool forceFullCollection);" />
      <MemberSignature Language="F#" Value="static member GetTotalMemory : bool -&gt; int64" Usage="System.GC.GetTotalMemory forceFullCollection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forceFullCollection" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="forceFullCollection"><span data-ttu-id="42538-298"><see langword="true" />, чтобы указать, что перед возвратом этот метод может дождаться выполнения сборки мусора; в противном случае — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="42538-298"><see langword="true" /> to indicate that this method can wait for garbage collection to occur before returning; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="42538-299">Извлекает предполагаемое количество выделенных в данный момент байтов.</span><span class="sxs-lookup"><span data-stu-id="42538-299">Retrieves the number of bytes currently thought to be allocated.</span></span> <span data-ttu-id="42538-300">Параметр указывает, может ли этот метод выдержать короткий интервал времени ожидания перед возвратом, пока система выполняет сборку мусора и завершает объекты.</span><span class="sxs-lookup"><span data-stu-id="42538-300">A parameter indicates whether this method can wait a short interval before returning, to allow the system to collect garbage and finalize objects.</span></span></summary>
        <returns><span data-ttu-id="42538-301">Наилучшая доступная аппроксимация числа байтов, распределенных в данный момент в управляемой памяти.</span><span class="sxs-lookup"><span data-stu-id="42538-301">A number that is the best available approximation of the number of bytes currently allocated in managed memory.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42538-302">Если `forceFullCollection` параметр `true`, этот метод ожидает короткий интервал времени перед возвратом, пока система выполняет сборку мусора и завершает объекты.</span><span class="sxs-lookup"><span data-stu-id="42538-302">If the `forceFullCollection` parameter is `true`, this method waits a short interval before returning while the system collects garbage and finalizes objects.</span></span> <span data-ttu-id="42538-303">Длительность интервала находится внутри заданного зависит от числа циклов сборки мусора завершена и изменения восстановленного объема памяти между циклами.</span><span class="sxs-lookup"><span data-stu-id="42538-303">The duration of the interval is an internally specified limit determined by the number of garbage collection cycles completed and the change in the amount of memory recovered between cycles.</span></span> <span data-ttu-id="42538-304">Сборщик мусора не гарантирует, что собираются все недоступной памяти.</span><span class="sxs-lookup"><span data-stu-id="42538-304">The garbage collector does not guarantee that all inaccessible memory is collected.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42538-305">Следующий пример демонстрирует, как использовать <xref:System.GC.GetTotalMemory%2A> метод для возврата и отображения число байтов, выделенных в данный момент в управляемой памяти.</span><span class="sxs-lookup"><span data-stu-id="42538-305">The following example demonstrates how to use the <xref:System.GC.GetTotalMemory%2A> method to get and display the number of bytes currently allocated in managed memory.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public static void KeepAlive (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void KeepAlive(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.KeepAlive(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub KeepAlive (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void KeepAlive(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member KeepAlive : obj -&gt; unit" Usage="System.GC.KeepAlive obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="42538-306">Объект для ссылки.</span><span class="sxs-lookup"><span data-stu-id="42538-306">The object to reference.</span></span></param>
        <summary><span data-ttu-id="42538-307">Ссылается на указанный объект, делая его недоступным для сборщика мусора с момента начала текущей процедуры до вызова этого метода.</span><span class="sxs-lookup"><span data-stu-id="42538-307">References the specified object, which makes it ineligible for garbage collection from the start of the current routine to the point where this method is called.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42538-308">Цель <xref:System.GC.KeepAlive%2A> метод является обеспечить наличие ссылки на объект, который находится под угрозой из преждевременно освобождается сборщиком мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-308">The purpose of the <xref:System.GC.KeepAlive%2A> method is to ensure the existence of a reference to an object that is at risk of being prematurely reclaimed by the garbage collector.</span></span> <span data-ttu-id="42538-309">Обычно такая ситуация может сложиться — при отсутствии ссылок на объект в управляемом коде или данных, но он по-прежнему используется в неуправляемом коде, таких как Windows API, неуправляемых библиотек DLL, или методов с использованием модели COM.</span><span class="sxs-lookup"><span data-stu-id="42538-309">A common scenario where this might happen is when there are no references to the object in managed code or data, but the object is still in use in unmanaged code such as Windows APIs, unmanaged DLLs, or methods using COM.</span></span>  
  
 <span data-ttu-id="42538-310">Ссылается на этот метод `obj` параметра, что делает этот объект становится недоступным для сборки мусора в начале подпрограммы к точке, в порядке их выполнения, где вызывается этот метод.</span><span class="sxs-lookup"><span data-stu-id="42538-310">This method references the `obj` parameter, making that object ineligible for garbage collection from the start of the routine to the point, in execution order, where this method is called.</span></span> <span data-ttu-id="42538-311">Код этого метода в конце, а не в начале диапазона инструкций, где `obj` должны быть доступны.</span><span class="sxs-lookup"><span data-stu-id="42538-311">Code this method at the end, not the beginning, of the range of instructions where `obj` must be available.</span></span>  
  
 <span data-ttu-id="42538-312"><xref:System.GC.KeepAlive%2A> Метод не выполняет никаких действий и создает без побочных эффектов, отличный от увеличения времени существования объекта, переданного в качестве параметра.</span><span class="sxs-lookup"><span data-stu-id="42538-312">The <xref:System.GC.KeepAlive%2A> method performs no operation and produces no side effects other than extending the lifetime of the object passed in as a parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42538-313">В следующем примере кода создает объект в начале его `Main` метода и не ссылается на объект до самого конца при <xref:System.GC.KeepAlive%2A> вызывается метод.</span><span class="sxs-lookup"><span data-stu-id="42538-313">The following code example creates an object at the beginning of its `Main` method and does not refer to the object again until the end, when the <xref:System.GC.KeepAlive%2A> method is called.</span></span> <span data-ttu-id="42538-314">Объект сохраняется в течение 30-секундной `Main` метод, несмотря на вызовы <xref:System.GC.Collect%2A> и <xref:System.GC.WaitForPendingFinalizers%2A> методы.</span><span class="sxs-lookup"><span data-stu-id="42538-314">The object persists for the 30-second duration of the `Main` method, despite calls to the <xref:System.GC.Collect%2A> and <xref:System.GC.WaitForPendingFinalizers%2A> methods.</span></span>  
  
 [!code-cpp[System.GC.KeepAlive Example2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CPP/gckeepalive.cpp#1)]
 [!code-csharp[System.GC.KeepAlive Example2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CS/gckeepalive.cs#1)]
 [!code-vb[System.GC.KeepAlive Example2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/VB/gckeepalive.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxGeneration">
      <MemberSignature Language="C#" Value="public static int MaxGeneration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxGeneration" />
      <MemberSignature Language="DocId" Value="P:System.GC.MaxGeneration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MaxGeneration As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxGeneration { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaxGeneration : int" Usage="System.GC.MaxGeneration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="42538-315">Возвращает наибольшее число поколений, поддерживаемое системой в настоящее время.</span><span class="sxs-lookup"><span data-stu-id="42538-315">Gets the maximum number of generations that the system currently supports.</span></span></summary>
        <value><span data-ttu-id="42538-316">Значение от нуля до максимального числа поддерживаемых поколений.</span><span class="sxs-lookup"><span data-stu-id="42538-316">A value that ranges from zero to the maximum number of supported generations.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42538-317">Номер поколения, или возраст объекта — это определяемое реализацией относительная мера из объекта зависящая от.</span><span class="sxs-lookup"><span data-stu-id="42538-317">The generation number, or age, of an object is an implementation-defined relative measure of an object's lifespan.</span></span> <span data-ttu-id="42538-318">Недавно созданные объекты являются в поколении 0. они самые старые объекты в поколении, меньше или равно поколение возвращаемые <xref:System.GC.MaxGeneration%2A> свойство.</span><span class="sxs-lookup"><span data-stu-id="42538-318">The most recently created objects are in generation 0 and the oldest objects are in a generation less than or equal to the generation returned by the <xref:System.GC.MaxGeneration%2A> property.</span></span>  
  
 <span data-ttu-id="42538-319">Сборщик мусора предполагает, что память, выделенная скорее всего будет под сбор мусора, чем старые памяти.</span><span class="sxs-lookup"><span data-stu-id="42538-319">The garbage collector assumes that newer memory is more likely to be eligible for garbage collection than older memory.</span></span> <span data-ttu-id="42538-320">Таким образом, сборщик мусора повышает его производительность, настраивая номера поколений каждый раз, он освобождает память, и <xref:System.GC.MaxGeneration%2A> значение свойства может увеличиваться с течением времени.</span><span class="sxs-lookup"><span data-stu-id="42538-320">Therefore, the garbage collector improves its performance by adjusting generation numbers each time it reclaims memory, and the <xref:System.GC.MaxGeneration%2A> property value can grow over time.</span></span>  
  
 <span data-ttu-id="42538-321">Если время существования объекта реализован, <xref:System.GC.MaxGeneration%2A> свойство возвращает максимальный номер поколения используемой системой; в противном случае это свойство возвращает ноль.</span><span class="sxs-lookup"><span data-stu-id="42538-321">If object aging is implemented, the <xref:System.GC.MaxGeneration%2A> property returns the maximum generation number used by the system; otherwise, this property returns zero.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42538-322">Следующий пример демонстрирует использование свойства MaxGeneration для отображения наибольший номер поколения в настоящее время используется.</span><span class="sxs-lookup"><span data-stu-id="42538-322">The following example demonstrates how to use the MaxGeneration property to display the largest generation number currently in use.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="42538-323">Для этой реализации значение, возвращаемое функцией <see cref="P:System.GC.MaxGeneration" /> свойство гарантированно не изменяются в течение времени существования выполнения приложения.</span><span class="sxs-lookup"><span data-stu-id="42538-323">For this implementation, the value returned by the <see cref="P:System.GC.MaxGeneration" /> property is guaranteed to remain constant for the lifetime of an executing application.</span></span>  
  
<span data-ttu-id="42538-324">Используйте <see cref="P:System.GC.MaxGeneration" /> свойства, чтобы определить максимальное значение, которое можно указать при вызове <see cref="M:System.GC.Collect(System.Int32)" /> метод, принимающий параметр поколения.</span><span class="sxs-lookup"><span data-stu-id="42538-324">Use the <see cref="P:System.GC.MaxGeneration" /> property to determine the maximum value you can specify when calling the <see cref="M:System.GC.Collect(System.Int32)" /> method that takes a generation parameter.</span></span></para></block>
        <altmember cref="M:System.GC.GetGeneration(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForFullGCNotification">
      <MemberSignature Language="C#" Value="public static void RegisterForFullGCNotification (int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterForFullGCNotification(int32 maxGenerationThreshold, int32 largeObjectHeapThreshold) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterForFullGCNotification (maxGenerationThreshold As Integer, largeObjectHeapThreshold As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterForFullGCNotification(int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberSignature Language="F#" Value="static member RegisterForFullGCNotification : int * int -&gt; unit" Usage="System.GC.RegisterForFullGCNotification (maxGenerationThreshold, largeObjectHeapThreshold)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxGenerationThreshold" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="largeObjectHeapThreshold" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="maxGenerationThreshold"><span data-ttu-id="42538-325">Число от 1 до 99, указывающее условия создания уведомления в зависимости от объектов, выделенных в поколение 2.</span><span class="sxs-lookup"><span data-stu-id="42538-325">A number between 1 and 99 that specifies when the notification should be raised based on the objects allocated in generation 2.</span></span></param>
        <param name="largeObjectHeapThreshold"><span data-ttu-id="42538-326">Число от 1 до 99, указывающее условия создания уведомления в зависимости от объектов, помещенных в кучу больших объектов.</span><span class="sxs-lookup"><span data-stu-id="42538-326">A number between 1 and 99 that specifies when the notification should be raised based on objects allocated in the large object heap.</span></span></param>
        <summary><span data-ttu-id="42538-327">Указывает, что необходимо отправлять уведомления о сборке мусора, когда соблюдены условия для полной сборки мусора и когда завершена сборка.</span><span class="sxs-lookup"><span data-stu-id="42538-327">Specifies that a garbage collection notification should be raised when conditions favor full garbage collection and when the collection has been completed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42538-328">Для каждого поколения сборщик мусора Задает пороговое значение для выделений памяти в этом поколении.</span><span class="sxs-lookup"><span data-stu-id="42538-328">For each generation, the garbage collector sets a threshold for allocations into that generation.</span></span> <span data-ttu-id="42538-329">Превышение этого порогового значения, размер выделений мусора этого поколения.</span><span class="sxs-lookup"><span data-stu-id="42538-329">When the size of allocations exceeds this threshold, a garbage collection is triggered on that generation.</span></span> <span data-ttu-id="42538-330">Для примера, если пороговое значение поколения 2 составляет 20 МБ (что означает, что 20 МБ выдерживает его поколения 1 и перешедшие в поколение 2) и более чем 20 МБ уцелел после сборки поколения 1 и предлагается в поколение 2, будет предпринята попытка следующей сборки мусора как сборки поколения 2.</span><span class="sxs-lookup"><span data-stu-id="42538-330">For example, if generation 2's threshold is 20MB (which means that 20MB survives generation 1 collections and is promoted into generation 2), and more than 20MB has survived generation 1 and is prompted into generation 2, the next garbage collection will be attempted as a generation 2 collection.</span></span> <span data-ttu-id="42538-331">Аналогичным образом Если куча больших объектов (LOH) пороговое значение — 20 МБ и приложения выделил более чем 20 МБ больших объектов, следующей сборки мусора также будет выполняться как поколения 2, (поскольку LOH собирается только в сборках мусора поколения 2).</span><span class="sxs-lookup"><span data-stu-id="42538-331">Similarly, if the large object heap's (LOH's) threshold is 20MB and your app has allocated more than 20MB of large objects, the next garbage collection will also be attempted as a generation 2 collection (since the LOH is only collected in gen2 garbage collections).</span></span>  
  
 <span data-ttu-id="42538-332">`maxGenerationThreshold` И `largeObjectHeapThreshold` пороговые значения контролировать, насколько заранее вы получите уведомление, прежде чем произойдет полная сборка мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-332">The `maxGenerationThreshold` and `largeObjectHeapThreshold` thresholds control how much in advance you are notified before a full garbage collection occurs.</span></span> <span data-ttu-id="42538-333">Чем больше порогового значения, дополнительные распределения, которые могут возникать между уведомлений и следующей сборке мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-333">The greater the threshold, the more allocations that can occur between notification and the next full garbage collection.</span></span>  
  
 <span data-ttu-id="42538-334">Если у вас есть ситуации, в которых полная сборка мусора средой CLR бы отрицательно на производительность приложения, вы можете запросить получать уведомления, когда среда выполнения собирается выполнить полную сборку мусора и обходить эту сборку вызывая сборку самостоятельно (с помощью <xref:System.GC.Collect%2A> метод) Если предпочтительна, по-прежнему выполняются условия.</span><span class="sxs-lookup"><span data-stu-id="42538-334">If you have situations in which a full garbage collection by the common language runtime would adversely affect your application's performance, you can ask to be notified when the runtime is about to do a full garbage collection and circumvent that collection by inducing a collection yourself (using the <xref:System.GC.Collect%2A> method) when conditions are still favorable.</span></span> <span data-ttu-id="42538-335">Помимо изменения расписание сбора мусора самостоятельно, полный текст уведомления сборки Мусора полезно в следующих сценариях:</span><span class="sxs-lookup"><span data-stu-id="42538-335">In addition to changing the garbage collection schedule yourself, full GC notification is useful in following the scenarios:</span></span>  
  
-   <span data-ttu-id="42538-336">Мониторинг для подхода полная сборка мусора и, если вы получите уведомление, что один приближается, снижается размер динамических данных (например, освободив некоторые записи кэша).</span><span class="sxs-lookup"><span data-stu-id="42538-336">You monitor for the approach of a full garbage collection and, when you are notified that one is approaching, you reduce live data size (for example, by releasing some cache entries).</span></span> <span data-ttu-id="42538-337">Таким образом когда происходит сборка мусора, имеет возможность освободить больше памяти.</span><span class="sxs-lookup"><span data-stu-id="42538-337">As a result, when the garbage collection occurs, it is able to reclaim more memory.</span></span>  
  
-   <span data-ttu-id="42538-338">Вы отслеживать завершения полной сборки мусора, таким образом, вы можете собирать статистику.</span><span class="sxs-lookup"><span data-stu-id="42538-338">You monitor for the completion of a full garbage collection so that you can collect some statistics.</span></span>  <span data-ttu-id="42538-339">Например может потребоваться измерить размер кучи по завершении сборки Мусора, чтобы знать размер данных в реальном времени.</span><span class="sxs-lookup"><span data-stu-id="42538-339">For example, you might want to measure the size of the heap at GC completion so that you know the size of live data.</span></span> <span data-ttu-id="42538-340">(После полной сборки Мусора, кучи — наименьший размер.)</span><span class="sxs-lookup"><span data-stu-id="42538-340">(After a full GC, the heap is at its smallest size.)</span></span>  
  
 <span data-ttu-id="42538-341">Дополнительные сведения о что представляет полную сборку мусора, см. в разделе [уведомлений сборки мусора](~/docs/standard/garbage-collection/notifications.md).</span><span class="sxs-lookup"><span data-stu-id="42538-341">For more information about what represents a full garbage collection, see [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md).</span></span>  
  
 <span data-ttu-id="42538-342">При регистрации уведомлений о сборке мусора, вы можете получать при приближении полной сборки мусора и когда она готова.</span><span class="sxs-lookup"><span data-stu-id="42538-342">When you register for a garbage collection notification, you can be notified when a full garbage collection is approaching and when it is completed.</span></span> <span data-ttu-id="42538-343">Этот шаблон похож на том, как операционная система отслеживает уведомления о нехватке памяти.</span><span class="sxs-lookup"><span data-stu-id="42538-343">This pattern resembles how the operating system monitors for low memory notifications.</span></span>  
  
 <span data-ttu-id="42538-344">Следуйте приведенным ниже рекомендациям для указания `maxGenerationThreshold` и `largeObjectHeapThreshold` параметры:</span><span class="sxs-lookup"><span data-stu-id="42538-344">Use the following guidelines for specifying the `maxGenerationThreshold` and `largeObjectHeapThreshold` parameters:</span></span>  
  
-   <span data-ttu-id="42538-345">Больше верхнего порогового значения, дополнительные выделения происходит между уведомление и полной сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-345">The larger the threshold value, the more allocations will occur between the notification and the full garbage collection.</span></span>  
  
     <span data-ttu-id="42538-346">Больше верхнего порогового значения обеспечивает дополнительные возможности для среды выполнения проверить приближение сборки.</span><span class="sxs-lookup"><span data-stu-id="42538-346">A larger threshold value provides more opportunities for the runtime to check for an approaching collection.</span></span> <span data-ttu-id="42538-347">Это увеличивает вероятность того, что вы получите уведомление.</span><span class="sxs-lookup"><span data-stu-id="42538-347">This increases the likelihood that you will be notified.</span></span> <span data-ttu-id="42538-348">Тем не менее следует не задано слишком высокое пороговое значение, так как дополнительные выделения прежде, чем среда выполнения вызывает следующую сборку.</span><span class="sxs-lookup"><span data-stu-id="42538-348">However, you should not set the threshold too high because that results in a more allocations before the runtime induces the next collection.</span></span>  
  
     <span data-ttu-id="42538-349">Когда вы сборку мусора самостоятельно после уведомления, используя значение верхнего порогового значения, меньше объектов были удалены, не будет утилизирован очередную сборку мусора среды выполнения.</span><span class="sxs-lookup"><span data-stu-id="42538-349">When you induce a collection yourself upon notification using a high threshold value, fewer objects are reclaimed than would be reclaimed by the runtime's next collection.</span></span>  
  
-   <span data-ttu-id="42538-350">Чем меньше порогового значения, меньше операции выделения памяти от уведомления до полной сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-350">The smaller the threshold value, the fewer the allocations between notification and the full garbage collection.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42538-351">В следующем примере показано, как зарегистрировать уведомление о сборке мусора и запустить поток, чтобы отслеживать состояние уведомления о сборке мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-351">The following example shows how to register a garbage collection notification and start a thread to monitor the status of the garbage collection notification.</span></span> <span data-ttu-id="42538-352">Данный пример кода является частью большего примера для [уведомлений сборки мусора](~/docs/standard/garbage-collection/notifications.md) раздела.</span><span class="sxs-lookup"><span data-stu-id="42538-352">This code example is part of a larger example provided for [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.</span></span>  
  
 [!code-cpp[GCNotification#2](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#2)]
 [!code-csharp[GCNotification#2](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#2)]
 [!code-vb[GCNotification#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="42538-353">Значение параметра <paramref name="maxGenerationThreshold" /> или <paramref name="largeObjectHeapThreshold" /> не входит в диапазон от 1 до 99.</span><span class="sxs-lookup"><span data-stu-id="42538-353"><paramref name="maxGenerationThreshold" /> or <paramref name="largeObjectHeapThreshold" /> is not between 1 and 99.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="42538-354">для полного доверия для непосредственного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="42538-354">for full trust for the immediate caller.</span></span> <span data-ttu-id="42538-355">Этот член не может быть использован частично доверенным кодом.</span><span class="sxs-lookup"><span data-stu-id="42538-355">This member cannot be used by partially trusted code.</span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="42538-356">Требует полного доверия для непосредственного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="42538-356">requires full trust for the immediate caller.</span></span> <span data-ttu-id="42538-357">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="42538-357">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89"><span data-ttu-id="42538-358">Уведомления о сборке мусора</span><span class="sxs-lookup"><span data-stu-id="42538-358">Garbage Collection Notifications</span></span></related>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42538-359">Данный элемент недоступен, если включена параллельная сборка мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-359">This member is not available when concurrent garbage collection is enabled.</span></span> <span data-ttu-id="42538-360">Сведения об отключении параллельной сборки мусора см. в статье, посвященной параметру среды выполнения &lt;gcConcurrent&gt;.</span><span class="sxs-lookup"><span data-stu-id="42538-360">See the &lt;gcConcurrent&gt; runtime setting for information about how to disable concurrent garbage collection.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveMemoryPressure">
      <MemberSignature Language="C#" Value="public static void RemoveMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RemoveMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMemoryPressure(long bytesAllocated);" />
      <MemberSignature Language="F#" Value="static member RemoveMemoryPressure : int64 -&gt; unit" Usage="System.GC.RemoveMemoryPressure bytesAllocated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated"><span data-ttu-id="42538-361">Объем, на который увеличен объем освобожденной неуправляемой памяти.</span><span class="sxs-lookup"><span data-stu-id="42538-361">The amount of unmanaged memory that has been released.</span></span></param>
        <summary><span data-ttu-id="42538-362">Информирует среду выполнения о том, что неуправляемая память освобождена и ее более не требуется учитывать при планировании сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-362">Informs the runtime that unmanaged memory has been released and no longer needs to be taken into account when scheduling garbage collection.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42538-363">При определении времени запланировать сбор мусора, среда выполнения учитывает объем управляемой памяти выделяется.</span><span class="sxs-lookup"><span data-stu-id="42538-363">In determining when to schedule garbage collection, the runtime takes into account how much managed memory is allocated.</span></span> <span data-ttu-id="42538-364">Если маленький управляемый объект выделяет большой объем неуправляемой памяти, среда выполнения учитывает только управляемую память и поэтому недооценивает срочность планировании сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-364">If a small managed object allocates a large amount of unmanaged memory, the runtime takes into account only the managed memory, and thus underestimates the urgency of scheduling garbage collection.</span></span> <span data-ttu-id="42538-365"><xref:System.GC.AddMemoryPressure%2A> Метод информирует среду CLR о этот дополнительную нагрузку на память системы и <xref:System.GC.RemoveMemoryPressure%2A> метод сообщает среде выполнения отжатии дополнительных давление.</span><span class="sxs-lookup"><span data-stu-id="42538-365">The <xref:System.GC.AddMemoryPressure%2A> method informs the runtime of this additional pressure on system memory, and the <xref:System.GC.RemoveMemoryPressure%2A> method informs the runtime that the additional pressure has been released.</span></span>  
  
 <span data-ttu-id="42538-366">Самый простой шаблон использования, управляемый объект выделяет неуправляемую память в конструкторе и освобождает его в `Dispose` или `Finalize` метод.</span><span class="sxs-lookup"><span data-stu-id="42538-366">In the simplest usage pattern, a managed object allocates unmanaged memory in the constructor and releases it in the `Dispose` or `Finalize` method.</span></span> <span data-ttu-id="42538-367">Вызовите <xref:System.GC.AddMemoryPressure%2A> метод после выделения неуправляемой памяти и вызовите <xref:System.GC.RemoveMemoryPressure%2A> метод после ее освобождения.</span><span class="sxs-lookup"><span data-stu-id="42538-367">Call the <xref:System.GC.AddMemoryPressure%2A> method after allocating the unmanaged memory, and call the <xref:System.GC.RemoveMemoryPressure%2A> method after releasing it.</span></span>  
  
 <span data-ttu-id="42538-368">В более сложных сценариях, где выделения неуправляемой памяти значительно изменяется в течение времени существования управляемого объекта, можно вызвать <xref:System.GC.AddMemoryPressure%2A> и <xref:System.GC.RemoveMemoryPressure%2A> методы для взаимодействия эти добавочные изменения в среду выполнения.</span><span class="sxs-lookup"><span data-stu-id="42538-368">In more complicated scenarios, where the unmanaged memory allocation changes substantially during the lifetime of the managed object, you can call the <xref:System.GC.AddMemoryPressure%2A> and <xref:System.GC.RemoveMemoryPressure%2A> methods to communicate these incremental changes to the runtime.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="42538-369">Необходимо гарантировать, что удаляется именно степень давления, добавляемые.</span><span class="sxs-lookup"><span data-stu-id="42538-369">You must ensure that you remove exactly the amount of pressure you add.</span></span> <span data-ttu-id="42538-370">Невыполнение этого может отрицательно сказаться на производительности системы в приложениях, выполняемых в течение длительных периодов времени.</span><span class="sxs-lookup"><span data-stu-id="42538-370">Failing to do so can adversely affect the performance of the system in applications that run for long periods of time.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="42538-371"><paramref name="bytesAllocated" /> меньше или равно 0.</span><span class="sxs-lookup"><span data-stu-id="42538-371"><paramref name="bytesAllocated" /> is less than or equal to 0.</span></span>  
  
<span data-ttu-id="42538-372">-или-</span><span class="sxs-lookup"><span data-stu-id="42538-372">-or-</span></span> 
<span data-ttu-id="42538-373">На 32-разрядном компьютере <paramref name="bytesAllocated" /> больше <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="42538-373">On a 32-bit computer, <paramref name="bytesAllocated" /> is larger than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="42538-374">для возможности вызова неуправляемого кода, при обработке приоритетом сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-374">for the ability to call unmanaged code when manipulating garbage-collection priority.</span></span> <span data-ttu-id="42538-375">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="42538-375">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="42538-376">Требует полного доверия для непосредственного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="42538-376">requires full trust for the immediate caller.</span></span> <span data-ttu-id="42538-377">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="42538-377">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ReRegisterForFinalize">
      <MemberSignature Language="C#" Value="public static void ReRegisterForFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReRegisterForFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.ReRegisterForFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReRegisterForFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ReRegisterForFinalize(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member ReRegisterForFinalize : obj -&gt; unit" Usage="System.GC.ReRegisterForFinalize obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="42538-378">Объект, для которого должен быть вызван метод завершения.</span><span class="sxs-lookup"><span data-stu-id="42538-378">The object that a finalizer must be called for.</span></span></param>
        <summary><span data-ttu-id="42538-379">Требует, чтобы система вызвала метод завершения для указанного объекта, для которого ранее был вызван метод <see cref="M:System.GC.SuppressFinalize(System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="42538-379">Requests that the system call the finalizer for the specified object for which <see cref="M:System.GC.SuppressFinalize(System.Object)" /> has previously been called.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42538-380"><xref:System.GC.ReRegisterForFinalize%2A> Добавляет метод `obj` параметр к списку объектов, которые запрашивают завершения, прежде чем сборщик мусора освободит объект.</span><span class="sxs-lookup"><span data-stu-id="42538-380">The <xref:System.GC.ReRegisterForFinalize%2A> method adds the `obj` parameter to the list of objects that request finalization before the garbage collector frees the object.</span></span> <span data-ttu-id="42538-381">`obj` Параметр должен быть вызывающая сторона этого метода.</span><span class="sxs-lookup"><span data-stu-id="42538-381">The `obj` parameter must be the caller of this method.</span></span>  
  
 <span data-ttu-id="42538-382">Вызов <xref:System.GC.ReRegisterForFinalize%2A> не гарантирует, что сборщик мусора вызывает финализатор объекта.</span><span class="sxs-lookup"><span data-stu-id="42538-382">Calling the <xref:System.GC.ReRegisterForFinalize%2A> method does not guarantee that the garbage collector will call an object's finalizer.</span></span>  
  
 <span data-ttu-id="42538-383">По умолчанию все объекты, реализующие методы завершения добавляются в список объектов, которые требуют завершения; Тем не менее, объект может быть уже завершен или может отключен путем вызова <xref:System.GC.SuppressFinalize%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="42538-383">By default, all objects that implement finalizers are added to the list of objects that require finalization; however, an object might have already been finalized or might have disabled finalization by calling the <xref:System.GC.SuppressFinalize%2A> method.</span></span>  
  
 <span data-ttu-id="42538-384">Метод завершения может использовать этот метод, чтобы восстановить себя или объект, который он ссылается.</span><span class="sxs-lookup"><span data-stu-id="42538-384">A finalizer can use this method to resurrect itself or an object that it references.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42538-385">В следующем примере показано, как с помощью метода ReRegisterForFinalize завершить объект второй после сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-385">The following example demonstrates how to use the ReRegisterForFinalize method to finalize an object a second time after garbage collection.</span></span>  
  
 [!code-cpp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CS/class1.cs#1)]
 [!code-vb[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42538-386"><paramref name="obj" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="42538-386"><paramref name="obj" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="SuppressFinalize">
      <MemberSignature Language="C#" Value="public static void SuppressFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SuppressFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.SuppressFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SuppressFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SuppressFinalize(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member SuppressFinalize : obj -&gt; unit" Usage="System.GC.SuppressFinalize obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="42538-387">Объект, метод завершения для которого не должен выполняться.</span><span class="sxs-lookup"><span data-stu-id="42538-387">The object whose finalizer must not be executed.</span></span></param>
        <summary><span data-ttu-id="42538-388">Сообщает среде CLR, что она на не должна вызывать метод завершения для указанного объекта.</span><span class="sxs-lookup"><span data-stu-id="42538-388">Requests that the common language runtime not call the finalizer for the specified object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42538-389">Этот метод устанавливает для бита в заголовке объекта `obj`, который среда выполнения проверяет при вызове метода завершения.</span><span class="sxs-lookup"><span data-stu-id="42538-389">This method sets a bit in the object header of `obj`, which the runtime checks when calling finalizers.</span></span> <span data-ttu-id="42538-390">Метод завершения, который представляется <xref:System.Object.Finalize%2A?displayProperty=nameWithType> метод, используемый для освобождения неуправляемых ресурсов, прежде чем объекта сборщиком мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-390">A finalizer, which is represented by the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method, is used to release unmanaged resources before an object is garbage-collected.</span></span> <span data-ttu-id="42538-391">Если `obj` не метод завершения, вызов <xref:System.GC.SuppressFinalize%2A> метод не оказывает влияния.</span><span class="sxs-lookup"><span data-stu-id="42538-391">If `obj` does not have a finalizer, the call to the <xref:System.GC.SuppressFinalize%2A> method has no effect.</span></span>  
  
 <span data-ttu-id="42538-392">Объекты, реализующие <xref:System.IDisposable> интерфейс этот метод можно вызывать из объекта <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> реализацию, чтобы помешать сборщику мусора вызвать <xref:System.Object.Finalize%2A?displayProperty=nameWithType> на объекте, который она не является обязательной.</span><span class="sxs-lookup"><span data-stu-id="42538-392">Objects that implement the <xref:System.IDisposable> interface can call this method from the object's <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation to prevent the garbage collector from calling <xref:System.Object.Finalize%2A?displayProperty=nameWithType> on an object that does not require it.</span></span> <span data-ttu-id="42538-393">Как правило, это позволяет предотвратить метода завершения освободить неуправляемые ресурсы, которые уже был освобожден, <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> реализации.</span><span class="sxs-lookup"><span data-stu-id="42538-393">Typically, this is done to prevent the finalizer from releasing unmanaged resources that have already been freed by the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42538-394">Следующий пример демонстрирует, как использовать <xref:System.GC.SuppressFinalize%2A> метод в класс ресурсов для предотвращения избыточной сборки мусора из вызова.</span><span class="sxs-lookup"><span data-stu-id="42538-394">The following example demonstrates how to use the <xref:System.GC.SuppressFinalize%2A> method in a resource class to prevent a redundant garbage collection from being called.</span></span> <span data-ttu-id="42538-395">В примере используется [dispose](~/docs/standard/garbage-collection/implementing-dispose.md) шаблон освободить как управляемые ресурсы (то есть объекты, реализующие <xref:System.IDisposable>) и неуправляемые ресурсы.</span><span class="sxs-lookup"><span data-stu-id="42538-395">The example uses the [dispose pattern](~/docs/standard/garbage-collection/implementing-dispose .md) to free both managed resources (that is, objects that implement <xref:System.IDisposable>) and unmanaged resources.</span></span>  
  
 [!code-csharp[System.GC.SuppressFinalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.suppressfinalize/cs/suppressfinalize1.cs#1)]
 [!code-vb[System.GC.SuppressFinalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.suppressfinalize/vb/suppressfinalize1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42538-396"><paramref name="obj" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="42538-396"><paramref name="obj" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.Object.Finalize" />
        <related type="Article" href="https://msdn.microsoft.com/library/31a6c13b-d6a2-492b-9a9f-e5238c983bcb"><span data-ttu-id="42538-397">Шаблон ликвидации</span><span class="sxs-lookup"><span data-stu-id="42538-397">Dispose Pattern</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryStartNoGCRegion">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="42538-398">Пытается запретить сборку мусора во время выполнения критического пути.</span><span class="sxs-lookup"><span data-stu-id="42538-398">Attempts to disallow garbage collection during the execution of a critical path.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="42538-399">Не удается вложить вызовы к <xref:System.GC.TryStartNoGCRegion%2A> метод и вы должны вызывать только <xref:System.GC.EndNoGCRegion%2A> метод, если среда выполнения в настоящее время находится в режиме задержки без области сборки Мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-399">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="42538-400">Другими словами, не следует вызывать <xref:System.GC.TryStartNoGCRegion%2A> несколько раз (после первого вызова метода, последующие вызовы не будет выполнено), и не должен ожидать вызовы <xref:System.GC.EndNoGCRegion%2A> для успешного выполнения только потому, что первый вызов <xref:System.GC.TryStartNoGCRegion%2A> выполнена успешно.</span><span class="sxs-lookup"><span data-stu-id="42538-400">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 -&gt; bool" Usage="System.GC.TryStartNoGCRegion totalSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="totalSize"><span data-ttu-id="42538-401">Объем памяти в байтах для выделения без запуска сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-401">The amount of memory in bytes to allocate without triggering a garbage collection.</span></span> <span data-ttu-id="42538-402">Он должен быть меньше или равен размеру временного сегмента.</span><span class="sxs-lookup"><span data-stu-id="42538-402">It must be less than or equal to the size of an ephemeral segment.</span></span> <span data-ttu-id="42538-403">Сведения о размере эфемерных сегментов см. в разделе "Эфемерные поколения и сегменты" статьи [Основы сборки мусора](~/docs/standard/garbage-collection/fundamentals.md).</span><span class="sxs-lookup"><span data-stu-id="42538-403">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span></span></param>
        <summary><span data-ttu-id="42538-404">Пытается запретить сборку мусора во время выполнения критического пути, если доступен указанный достаточный объем памяти.</span><span class="sxs-lookup"><span data-stu-id="42538-404">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available.</span></span></summary>
        <returns><span data-ttu-id="42538-405">Значение <see langword="true" />, если среде выполнения удалось зафиксировать необходимый объем памяти и сборщик мусора может перейти в режим задержки без области сборки мусора; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="42538-405"><see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42538-406"><xref:System.GC.TryStartNoGCRegion%28System.Int64%29> Метод пытается перевести сборщик мусора в GC режим задержки без области, который не разрешает сбор мусора, пока приложение выполняет критической области кода.</span><span class="sxs-lookup"><span data-stu-id="42538-406">The <xref:System.GC.TryStartNoGCRegion%28System.Int64%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</span></span>  <span data-ttu-id="42538-407">Если среда выполнения не может изначально выделяемый запрошенного объема памяти, сборщик мусора выполняет полной блокирующей сборки мусора, при попытке освободить память.</span><span class="sxs-lookup"><span data-stu-id="42538-407">If the runtime is unable to initially allocate the requested amount of memory, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory.</span></span> <span data-ttu-id="42538-408">Сборщик мусора переходит в режим задержки без области сборки Мусора, если он может выделить необходимый объем памяти, что в данном случае является фактически 2 \* `totalSize` байт (он пытается выделить `totalSize` байт для кучи маленьких объектов и `totalSize` байт для куча больших объектов).</span><span class="sxs-lookup"><span data-stu-id="42538-408">The garbage collector enters no GC region latency mode if it is able to allocate the required amount of memory, which in this case is actually 2 \* `totalSize` bytes (it attempts to allocate `totalSize` bytes for the small object heap and `totalSize` bytes for the large object heap).</span></span>  
  
 <span data-ttu-id="42538-409">`totalSize` должно быть достаточно большим для обработки всех операций выделения памяти, которые происходят в критический путь.</span><span class="sxs-lookup"><span data-stu-id="42538-409">`totalSize` must be large enough to handle all memory allocations that occur in the critical path.</span></span> <span data-ttu-id="42538-410">Сюда входят выделения, приложение, а также параметры распределения, среда выполнения предоставляет от имени приложения.</span><span class="sxs-lookup"><span data-stu-id="42538-410">This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="42538-411">Не удается вложить вызовы к <xref:System.GC.TryStartNoGCRegion%2A> метод и вы должны вызывать только <xref:System.GC.EndNoGCRegion%2A> метод, если среда выполнения в настоящее время находится в режиме задержки без области сборки Мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-411">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="42538-412">Другими словами, не следует вызывать <xref:System.GC.TryStartNoGCRegion%2A> несколько раз (после первого вызова метода, последующие вызовы не будет выполнено), и не должен ожидать вызовы <xref:System.GC.EndNoGCRegion%2A> для успешного выполнения только потому, что первый вызов <xref:System.GC.TryStartNoGCRegion%2A> выполнена успешно.</span><span class="sxs-lookup"><span data-stu-id="42538-412">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 <span data-ttu-id="42538-413">Сборщик Мусора режим задержки без области можно выйти посредством вызова метода <xref:System.GC.EndNoGCRegion%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="42538-413">You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="42538-414"><paramref name="totalSize" /> превышает размер эфемерного сегмента.</span><span class="sxs-lookup"><span data-stu-id="42538-414"><paramref name="totalSize" /> exceeds the ephemeral segment size.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42538-415">Процесс уже находится в режиме задержки без области сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-415">The process is already in no GC region latency mode.</span></span></exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2"><span data-ttu-id="42538-416">Основы сборки мусора</span><span class="sxs-lookup"><span data-stu-id="42538-416">Fundamentals of Garbage Collection</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81"><span data-ttu-id="42538-417">Режимы задержки</span><span class="sxs-lookup"><span data-stu-id="42538-417">Latency Modes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * bool -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, disallowFullBlockingGC)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="totalSize"><span data-ttu-id="42538-418">Объем памяти в байтах для выделения без запуска сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-418">The amount of memory in bytes to allocate without triggering a garbage collection.</span></span> <span data-ttu-id="42538-419">Он должен быть меньше или равен размеру временного сегмента.</span><span class="sxs-lookup"><span data-stu-id="42538-419">It must be less than or equal to the size of an ephemeral segment.</span></span> <span data-ttu-id="42538-420">Сведения о размере эфемерных сегментов см. в разделе "Эфемерные поколения и сегменты" статьи [Основы сборки мусора](~/docs/standard/garbage-collection/fundamentals.md).</span><span class="sxs-lookup"><span data-stu-id="42538-420">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span></span></param>
        <param name="disallowFullBlockingGC"><span data-ttu-id="42538-421">Значение <see langword="true" />, чтобы пропустить полную блокирующую сборку мусора, если сборщику мусора изначально не удалось выделить <paramref name="totalSize" /> байтов; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="42538-421"><see langword="true" /> to omit a full blocking garbage collection if the garbage collector is initially unable to allocate <paramref name="totalSize" /> bytes; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="42538-422">Пытается запретить сборку мусора во время выполнения критического пути, если доступен указанный объем памяти, и устанавливает, будет ли выполняться полная блокирующая сборка мусора, если изначально не хватает памяти.</span><span class="sxs-lookup"><span data-stu-id="42538-422">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available, and controls whether the garbage collector does a full blocking garbage collection if not enough memory is initially available.</span></span></summary>
        <returns><span data-ttu-id="42538-423">Значение <see langword="true" />, если среде выполнения удалось зафиксировать необходимый объем памяти и сборщик мусора может перейти в режим задержки без области сборки мусора; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="42538-423"><see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42538-424"><xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29> Метод пытается перевести сборщик мусора в GC режим задержки без области, который не разрешает сбор мусора, пока приложение выполняет критической области кода.</span><span class="sxs-lookup"><span data-stu-id="42538-424">The <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</span></span>  <span data-ttu-id="42538-425">Если среда выполнения не может изначально выделяемый запрошенного объема памяти и `disallowFullBlockingGC` аргумент `false`, сборщик мусора выполняет полной блокирующей сборки мусора, при попытке освободить память; в противном случае выделение происходит сбой и метод возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="42538-425">If the runtime is unable to initially allocate the requested amount of memory and the `disallowFullBlockingGC` argument is `false`, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory; otherwise, the allocation fails, and the method returns `false`.</span></span> <span data-ttu-id="42538-426">Сборщик мусора переходит в режим задержки без области сборки Мусора, если он может выделить необходимый объем памяти, что в данном случае является фактически 2 \* `totalSize` (он пытается выделить `totalSize` для кучи маленьких объектов и `totalSize` для больших объектов куча).</span><span class="sxs-lookup"><span data-stu-id="42538-426">The garbage collector enters no GC region latency mode if it is able to allocate the required amount of memory, which in this case is actually 2 \* `totalSize` (it attempts to allocate `totalSize` for the small object heap and `totalSize` for the large object heap).</span></span>  
  
 <span data-ttu-id="42538-427">`totalSize` должно быть достаточно большим для обработки всех операций выделения памяти, которые происходят в критический путь.</span><span class="sxs-lookup"><span data-stu-id="42538-427">`totalSize` must be large enough to handle all memory allocations that occur in the critical path.</span></span> <span data-ttu-id="42538-428">Сюда входят выделения, приложение, а также параметры распределения, среда выполнения предоставляет от имени приложения.</span><span class="sxs-lookup"><span data-stu-id="42538-428">This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</span></span>  
  
 <span data-ttu-id="42538-429">Установка `disallowFullBlockingGC` для `true` для предотвращения полной блокирующей сборки мусора коллекция, если изначально не хватает памяти наиболее полезен в сценарии балансировки нагрузки: одной системы можно вызвать этот метод и сообщает о себе как Готово к приему запросов, если он возвращает `true`, и Подсистема балансировки нагрузки перенаправлять запросы в другие системы, если он возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="42538-429">Setting `disallowFullBlockingGC` to `true` to prevent a full blocking garbage collection if not enough memory is initially available is most useful in load balancing scenarios: one system can call this method and report itself as ready to accept requests if it returns `true`, and have the load balancer redirect requests to other systems if it returns `false`.</span></span> <span data-ttu-id="42538-430">Его можно затем выполните полной блокирующей сборки мусора, когда он не обрабатывает запросы путем вызова <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> метод.</span><span class="sxs-lookup"><span data-stu-id="42538-430">It can then do a full blocking garbage collection when it's not handling requests by calling the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> method.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="42538-431">Не удается вложить вызовы к <xref:System.GC.TryStartNoGCRegion%2A> метод и вы должны вызывать только <xref:System.GC.EndNoGCRegion%2A> метод, если среда выполнения в настоящее время находится в режиме задержки без области сборки Мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-431">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="42538-432">Другими словами, не следует вызывать <xref:System.GC.TryStartNoGCRegion%2A> несколько раз (после первого вызова метода, последующие вызовы не будет выполнено), и не должен ожидать вызовы <xref:System.GC.EndNoGCRegion%2A> для успешного выполнения только потому, что первый вызов <xref:System.GC.TryStartNoGCRegion%2A> выполнена успешно.</span><span class="sxs-lookup"><span data-stu-id="42538-432">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 <span data-ttu-id="42538-433">Сборщик Мусора режим задержки без области можно выйти посредством вызова метода <xref:System.GC.EndNoGCRegion%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="42538-433">You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="42538-434"><paramref name="totalSize" /> превышает размер эфемерного сегмента.</span><span class="sxs-lookup"><span data-stu-id="42538-434"><paramref name="totalSize" /> exceeds the ephemeral segment size.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42538-435">Процесс уже находится в режиме задержки без области сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-435">The process is already in no GC region latency mode.</span></span></exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2"><span data-ttu-id="42538-436">Основы сборки мусора</span><span class="sxs-lookup"><span data-stu-id="42538-436">Fundamentals of Garbage Collection</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81"><span data-ttu-id="42538-437">Режимы задержки</span><span class="sxs-lookup"><span data-stu-id="42538-437">Latency Modes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * int64 -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, lohSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="lohSize" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="totalSize"><span data-ttu-id="42538-438">Объем памяти в байтах для выделения без запуска сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-438">The amount of memory in bytes to allocate without triggering a garbage collection.</span></span> <span data-ttu-id="42538-439">Значение <paramref name="totalSize" /> -<paramref name="lohSize" /> должно быть меньше или равно размеру эфемерного сегмента.</span><span class="sxs-lookup"><span data-stu-id="42538-439"><paramref name="totalSize" /> -<paramref name="lohSize" /> must be less than or equal to the size of an ephemeral segment.</span></span> <span data-ttu-id="42538-440">Сведения о размере эфемерных сегментов см. в разделе "Эфемерные поколения и сегменты" статьи [Основы сборки мусора](~/docs/standard/garbage-collection/fundamentals.md).</span><span class="sxs-lookup"><span data-stu-id="42538-440">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span></span></param>
        <param name="lohSize"><span data-ttu-id="42538-441">Число байтов в <paramref name="totalSize" /> для назначения кучи больших объектов.</span><span class="sxs-lookup"><span data-stu-id="42538-441">The number of bytes in <paramref name="totalSize" /> to use for large object heap (LOH) allocations.</span></span></param>
        <summary><span data-ttu-id="42538-442">Пытается запретить сборку мусора во время выполнения критического пути, если указанный объем памяти доступен для кучи больших объектов и для кучи маленьких объектов.</span><span class="sxs-lookup"><span data-stu-id="42538-442">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available for the large object heap and the small object heap.</span></span></summary>
        <returns><span data-ttu-id="42538-443">Значение <see langword="true" />, если среде выполнения удалось зафиксировать необходимый объем памяти и сборщик мусора может перейти в режим задержки без области сборки мусора; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="42538-443"><see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42538-444"><xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29> Метод пытается перевести сборщик мусора в GC режим задержки без области, который не разрешает сбор мусора, пока приложение выполняет критической области кода.</span><span class="sxs-lookup"><span data-stu-id="42538-444">The <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</span></span>  <span data-ttu-id="42538-445">Если среда выполнения не может изначально выделяемый запрошенного объема памяти, сборщик мусора выполняет полной блокирующей сборки мусора, при попытке освободить память.</span><span class="sxs-lookup"><span data-stu-id="42538-445">If the runtime is unable to initially allocate the requested amount of memory, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory.</span></span> <span data-ttu-id="42538-446">Сборщик мусора переходит в режим задержки без области сборки Мусора, если он может выделить `lohSize` для кучи массивных Объектов и `totalSize`  -  `lohSize` для кучи маленьких объектов (SOH).</span><span class="sxs-lookup"><span data-stu-id="42538-446">The garbage collector enters no GC region latency mode if it is able to allocate `lohSize` for the LOH and `totalSize` - `lohSize` for the small object heap (SOH).</span></span>  
  
 <span data-ttu-id="42538-447">`lohSize` должен быть достаточно большим для обработки всех операций выделения памяти, которые происходят в критический путь для кучи массивных Объектов, и `totalSize`  -  `lohSize` должен быть достаточно большим для обработки всех операций выделения памяти, которые происходят в критический путь для SOH.</span><span class="sxs-lookup"><span data-stu-id="42538-447">`lohSize` must be large enough to handle all memory allocations that occur in the critical path for the LOH, and `totalSize` - `lohSize` must be large enough to handle all memory allocations that occur in the critical path for the SOH.</span></span> <span data-ttu-id="42538-448">Сюда входят выделения, приложение, а также параметры распределения, среда выполнения предоставляет от имени приложения.</span><span class="sxs-lookup"><span data-stu-id="42538-448">This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="42538-449">Не удается вложить вызовы к <xref:System.GC.TryStartNoGCRegion%2A> метод и вы должны вызывать только <xref:System.GC.EndNoGCRegion%2A> метод, если среда выполнения в настоящее время находится в режиме задержки без области сборки Мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-449">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="42538-450">Другими словами, не следует вызывать <xref:System.GC.TryStartNoGCRegion%2A> несколько раз (после первого вызова метода, последующие вызовы не будет выполнено), и не должен ожидать вызовы <xref:System.GC.EndNoGCRegion%2A> для успешного выполнения только потому, что первый вызов <xref:System.GC.TryStartNoGCRegion%2A> выполнена успешно.</span><span class="sxs-lookup"><span data-stu-id="42538-450">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 <span data-ttu-id="42538-451">Сборщик Мусора режим задержки без области можно выйти посредством вызова метода <xref:System.GC.EndNoGCRegion%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="42538-451">You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="42538-452"><paramref name="totalSize" /> - <paramref name="lohSize" /> превышает размер эфемерного сегмента.</span><span class="sxs-lookup"><span data-stu-id="42538-452"><paramref name="totalSize" /> - <paramref name="lohSize" /> exceeds the ephemeral segment size.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42538-453">Процесс уже находится в режиме задержки без области сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-453">The process is already in no GC region latency mode.</span></span></exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2"><span data-ttu-id="42538-454">Основы сборки мусора</span><span class="sxs-lookup"><span data-stu-id="42538-454">Fundamentals of Garbage Collection</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81"><span data-ttu-id="42538-455">Режимы задержки</span><span class="sxs-lookup"><span data-stu-id="42538-455">Latency Modes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * int64 * bool -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, lohSize, disallowFullBlockingGC)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="lohSize" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="totalSize"><span data-ttu-id="42538-456">Объем памяти в байтах для выделения без запуска сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-456">The amount of memory in bytes to allocate without triggering a garbage collection.</span></span> <span data-ttu-id="42538-457">Значение <paramref name="totalSize" /> -<paramref name="lohSize" /> должно быть меньше или равно размеру эфемерного сегмента.</span><span class="sxs-lookup"><span data-stu-id="42538-457"><paramref name="totalSize" /> -<paramref name="lohSize" /> must be less than or equal to the size of an ephemeral segment.</span></span> <span data-ttu-id="42538-458">Сведения о размере эфемерных сегментов см. в разделе "Эфемерные поколения и сегменты" статьи [Основы сборки мусора](~/docs/standard/garbage-collection/fundamentals.md).</span><span class="sxs-lookup"><span data-stu-id="42538-458">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span></span></param>
        <param name="lohSize"><span data-ttu-id="42538-459">Число байтов в <paramref name="totalSize" /> для назначения кучи больших объектов.</span><span class="sxs-lookup"><span data-stu-id="42538-459">The number of bytes in <paramref name="totalSize" /> to use for large object heap (LOH) allocations.</span></span></param>
        <param name="disallowFullBlockingGC"><span data-ttu-id="42538-460">Значение <see langword="true" />, чтобы пропустить полную блокирующую сборку мусора, если сборщику мусора изначально не удалось выделить указанную память в куче малых и в куче больших объектов; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="42538-460"><see langword="true" /> to omit a full blocking garbage collection if the garbage collector is initially unable to allocate the specified memory on the small object heap (SOH) and LOH; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="42538-461">Пытается запретить сборку мусора во время выполнения критического пути, если доступен указанный объем памяти для кучи больших объектов и для кучи маленьких объектов, и устанавливает, будет ли выполняться полная блокирующая сборка мусора, если изначально не хватает памяти.</span><span class="sxs-lookup"><span data-stu-id="42538-461">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available for the large object heap and the small object heap, and controls whether the garbage collector does a full blocking garbage collection if not enough memory is initially available.</span></span></summary>
        <returns><span data-ttu-id="42538-462">Значение <see langword="true" />, если среде выполнения удалось зафиксировать необходимый объем памяти и сборщик мусора может перейти в режим задержки без области сборки мусора; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="42538-462"><see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42538-463"><xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29> Метод пытается перевести сборщик мусора в GC режим задержки без области, который не разрешает сбор мусора, пока приложение выполняет критической области кода.</span><span class="sxs-lookup"><span data-stu-id="42538-463">The <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</span></span>  <span data-ttu-id="42538-464">Если среда выполнения не может изначально выделяемый запрошенного объема памяти и `disallowFullBlockingGC` аргумент `false`, сборщик мусора выполняет полной блокирующей сборки мусора, при попытке освободить память; в противном случае выделение происходит сбой и метод возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="42538-464">If the runtime is unable to initially allocate the requested amount of memory and the `disallowFullBlockingGC` argument is `false`, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory; otherwise, the allocation fails, and the method returns `false`.</span></span> <span data-ttu-id="42538-465">Сборщик мусора переходит в режим задержки без области сборки Мусора, если он может выделить `lohSize` для кучи массивных Объектов и `totalSize`  -  `lohSize` для кучи маленьких объектов (SOH).</span><span class="sxs-lookup"><span data-stu-id="42538-465">The garbage collector enters no GC region latency mode if it is able to allocate `lohSize` for the LOH and `totalSize` - `lohSize` for the small object heap (SOH).</span></span>  
  
 <span data-ttu-id="42538-466">`lohSize` должен быть достаточно большим для обработки всех операций выделения памяти, которые происходят в критический путь для кучи массивных Объектов, и `totalSize`  -  `lohSize` должен быть достаточно большим для обработки всех операций выделения памяти, которые происходят в критический путь для SOH.</span><span class="sxs-lookup"><span data-stu-id="42538-466">`lohSize` must be large enough to handle all memory allocations that occur in the critical path for the LOH, and `totalSize` - `lohSize` must be large enough to handle all memory allocations that occur in the critical path for the SOH.</span></span> <span data-ttu-id="42538-467">Сюда входят выделения, приложение, а также параметры распределения, среда выполнения предоставляет от имени приложения.</span><span class="sxs-lookup"><span data-stu-id="42538-467">This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</span></span>  
  
 <span data-ttu-id="42538-468">Установка `disallowFullBlockingGC` для `true` для предотвращения полной блокирующей сборки мусора коллекция, если изначально не хватает памяти наиболее полезен в сценарии балансировки нагрузки: одной системы можно вызвать этот метод и сообщает о себе как Готово к приему запросов, если он возвращает `true`, и Подсистема балансировки нагрузки перенаправлять запросы в другие системы, если он возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="42538-468">Setting `disallowFullBlockingGC` to `true` to prevent a full blocking garbage collection if not enough memory is initially available is most useful in load balancing scenarios: one system can call this method and report itself as ready to accept requests if it returns `true`, and have the load balancer redirect requests to other systems if it returns `false`.</span></span> <span data-ttu-id="42538-469">Его можно затем выполните полной блокирующей сборки мусора, когда он не обрабатывает запросы путем вызова <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> метод.</span><span class="sxs-lookup"><span data-stu-id="42538-469">It can then do a full blocking garbage collection when it's not handling requests by calling the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> method.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="42538-470">Не удается вложить вызовы к <xref:System.GC.TryStartNoGCRegion%2A> метод и вы должны вызывать только <xref:System.GC.EndNoGCRegion%2A> метод, если среда выполнения в настоящее время находится в режиме задержки без области сборки Мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-470">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="42538-471">Другими словами, не следует вызывать <xref:System.GC.TryStartNoGCRegion%2A> несколько раз (после первого вызова метода, последующие вызовы не будет выполнено), и не должен ожидать вызовы <xref:System.GC.EndNoGCRegion%2A> для успешного выполнения только потому, что первый вызов <xref:System.GC.TryStartNoGCRegion%2A> выполнена успешно.</span><span class="sxs-lookup"><span data-stu-id="42538-471">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 <span data-ttu-id="42538-472">Сборщик Мусора режим задержки без области можно выйти посредством вызова метода <xref:System.GC.EndNoGCRegion%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="42538-472">You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="42538-473"><paramref name="totalSize" /> - <paramref name="lohSize" /> превышает размер эфемерного сегмента.</span><span class="sxs-lookup"><span data-stu-id="42538-473"><paramref name="totalSize" /> - <paramref name="lohSize" /> exceeds the ephemeral segment size.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42538-474">Процесс уже находится в режиме задержки без области сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-474">The process is already in no GC region latency mode.</span></span></exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2"><span data-ttu-id="42538-475">Основы сборки мусора</span><span class="sxs-lookup"><span data-stu-id="42538-475">Fundamentals of Garbage Collection</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81"><span data-ttu-id="42538-476">Режимы задержки</span><span class="sxs-lookup"><span data-stu-id="42538-476">Latency Modes</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCApproach">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="42538-477">Возвращает состояние зарегистрированного уведомления, чтобы определить, является ли неизбежной полная блокировка сборки мусора средой CLR.</span><span class="sxs-lookup"><span data-stu-id="42538-477">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach();" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCApproach : unit -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCApproach " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="42538-478">Возвращает состояние зарегистрированного уведомления, чтобы определить, является ли неизбежной полная блокировка сборки мусора средой CLR.</span><span class="sxs-lookup"><span data-stu-id="42538-478">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</span></span></summary>
        <returns><span data-ttu-id="42538-479">Состояние зарегистрированного уведомления о сборке мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-479">The status of the registered garbage collection notification.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42538-480">Используйте <xref:System.GCNotificationStatus> перечисление, возвращенное этим методом, чтобы определить состояние текущего уведомления сбора мусора, зарегистрированный с помощью <xref:System.GC.RegisterForFullGCNotification%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="42538-480">Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="42538-481">Можно также использовать <xref:System.GC.WaitForFullGCComplete%2A> метод, чтобы определить, завершена ли полная сборка мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-481">You can also use the <xref:System.GC.WaitForFullGCComplete%2A> method to determine whether the full garbage collection has completed.</span></span>  
  
 <span data-ttu-id="42538-482">При возвращении перечисления <xref:System.GCNotificationStatus.Succeeded>, вы можете выполнять задачи, такие как дополнительные объекты, предотвращая выделяется и вызывая сборку самостоятельно с помощью <xref:System.GC.Collect%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="42538-482">When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as preventing additional objects from being allocated and inducing a collection yourself with the <xref:System.GC.Collect%2A> method.</span></span> <span data-ttu-id="42538-483">Обратите внимание, что уведомление не гарантирует, что полная сборка мусора будет выполнена, только то, что условия Достигнуто пороговое значение, подходящую для полной сборки мусора возникает.</span><span class="sxs-lookup"><span data-stu-id="42538-483">Note that the notification does not guarantee that a full garbage collection will occur, only that conditions have reached the threshold that are favorable for a full garbage collection to occur.</span></span>  
  
 <span data-ttu-id="42538-484">Этот метод бесконечно ожидает уведомление о сборке мусора получить невозможно.</span><span class="sxs-lookup"><span data-stu-id="42538-484">This method waits indefinitely for a garbage collection notification to be obtained.</span></span> <span data-ttu-id="42538-485">Если вы хотите указать время ожидания для метода для возврата, если не удается получить уведомление, используйте <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> перегрузки метода.</span><span class="sxs-lookup"><span data-stu-id="42538-485">If you want to specify a time-out period for the method to return if the notification cannot be obtained, use the <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="42538-486">Если этот метод вызывается без указания времени ожидания, можно вызвать <xref:System.GC.CancelFullGCNotification%2A> метод, если ожидается больше, чем предпочтительные.</span><span class="sxs-lookup"><span data-stu-id="42538-486">If you call this method without specifying a time-out, you can call the <xref:System.GC.CancelFullGCNotification%2A> method if you are waiting longer than preferred.</span></span>  
  
 <span data-ttu-id="42538-487">Этот метод с вызовом необходимо следовать <xref:System.GC.WaitForFullGCComplete%2A> метод, чтобы убедиться в том, что имеется полная сборка мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-487">You should follow this method with a call to the <xref:System.GC.WaitForFullGCComplete%2A> method to make sure that you have had a full garbage collection.</span></span> <span data-ttu-id="42538-488">Вызов этого метода только дает неопределенные результаты.</span><span class="sxs-lookup"><span data-stu-id="42538-488">Calling this method alone causes indeterminate results.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42538-489">В следующем примере показано, как этот метод позволяет определить, приближается ли полная блокировка сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-489">The following example shows how to use this method to determine whether a full, blocking garbage collection is approaching.</span></span> <span data-ttu-id="42538-490">Каждый раз, когда находится в состоянии уведомление <xref:System.GCNotificationStatus.Succeeded>, пользовательский метод `OnFullGCApproachNotify` вызывается для выполнения действий в соответствии с размером около коллекции.</span><span class="sxs-lookup"><span data-stu-id="42538-490">Whenever the status of the notification is <xref:System.GCNotificationStatus.Succeeded>, the user method `OnFullGCApproachNotify` is called to perform actions in response to the approaching collection.</span></span> <span data-ttu-id="42538-491">Данный пример кода является частью большего примера для [уведомлений сборки мусора](~/docs/standard/garbage-collection/notifications.md) раздела.</span><span class="sxs-lookup"><span data-stu-id="42538-491">This code example is part of a larger example provided for [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.</span></span>  
  
 [!code-cpp[GCNotification#3](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#3)]
 [!code-csharp[GCNotification#3](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#3)]
 [!code-vb[GCNotification#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="42538-492">для полного доверия для непосредственного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="42538-492">for full trust for the immediate caller.</span></span> <span data-ttu-id="42538-493">Этот член не может быть использован частично доверенным кодом.</span><span class="sxs-lookup"><span data-stu-id="42538-493">This member cannot be used by partially trusted code.</span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="42538-494">Требует полного доверия для непосредственного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="42538-494">requires full trust for the immediate caller.</span></span> <span data-ttu-id="42538-495">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="42538-495">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89"><span data-ttu-id="42538-496">Уведомления о сборке мусора</span><span class="sxs-lookup"><span data-stu-id="42538-496">Garbage Collection Notifications</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCApproach : int -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCApproach millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="42538-497">Продолжительность времени ожидания, прежде чем можно извлечь состояние уведомления.</span><span class="sxs-lookup"><span data-stu-id="42538-497">The length of time to wait before a notification status can be obtained.</span></span> <span data-ttu-id="42538-498">Укажите значение -1, если период ожидания неограниченный.</span><span class="sxs-lookup"><span data-stu-id="42538-498">Specify -1 to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="42538-499">Возвращает состояние зарегистрированного уведомления в пределах указанного времени ожидания, чтобы определить, является ли неизбежной полная блокировка сборки мусора средой CLR.</span><span class="sxs-lookup"><span data-stu-id="42538-499">Returns, in a specified time-out period, the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</span></span></summary>
        <returns><span data-ttu-id="42538-500">Состояние зарегистрированного уведомления о сборке мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-500">The status of the registered garbage collection notification.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42538-501">Используйте <xref:System.GCNotificationStatus> перечисление, возвращенное этим методом, чтобы определить состояние текущего уведомления сбора мусора, зарегистрированный с помощью <xref:System.GC.RegisterForFullGCNotification%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="42538-501">Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="42538-502">Можно также использовать <xref:System.GC.WaitForFullGCComplete%2A> метод, чтобы определить, завершена ли полная сборка мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-502">You can also use the <xref:System.GC.WaitForFullGCComplete%2A> method to determine whether the full garbage collection has completed.</span></span>  
  
 <span data-ttu-id="42538-503">Обратите внимание, что этот метод возвращается сразу же каждый раз, когда получается состояние уведомления сбора мусора, независимо от значения, указанного в `millisecondsTimeout`.</span><span class="sxs-lookup"><span data-stu-id="42538-503">Note that this method returns immediately whenever a garbage collection notification status is obtained, regardless of the value specified by `millisecondsTimeout`.</span></span> <span data-ttu-id="42538-504">Если состояние уведомления сбора мусора не будет получена перед `millisecondsTimeout` раз, этот метод возвращает <xref:System.GCNotificationStatus.NotApplicable>.</span><span class="sxs-lookup"><span data-stu-id="42538-504">If a garbage collection notification status is not obtained before `millisecondsTimeout` times out, this method returns <xref:System.GCNotificationStatus.NotApplicable>.</span></span>  
  
 <span data-ttu-id="42538-505">При возвращении перечисления <xref:System.GCNotificationStatus.Succeeded>, вы можете выполнять задачи, такие как дополнительные объекты, предотвращая выделяется и вызывая сборку самостоятельно с помощью <xref:System.GC.Collect%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="42538-505">When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as preventing additional objects from being allocated and inducing a collection yourself with the <xref:System.GC.Collect%2A> method.</span></span> <span data-ttu-id="42538-506">Обратите внимание, что уведомление не гарантирует, что полная сборка мусора будет выполнена, только то, что условия Достигнуто пороговое значение, подходящую для полной сборки мусора возникает.</span><span class="sxs-lookup"><span data-stu-id="42538-506">Note that the notification does not guarantee that a full garbage collection will occur, only that conditions have reached the threshold that are favorable for a full garbage collection to occur.</span></span>  
  
 <span data-ttu-id="42538-507">Вы можете вызвать <xref:System.GC.CancelFullGCNotification%2A> метод, если вы не можете ждать период ожидания, которое должно пройти.</span><span class="sxs-lookup"><span data-stu-id="42538-507">You can call the <xref:System.GC.CancelFullGCNotification%2A> method when you cannot wait for the time-out period to elapse.</span></span>  
  
 <span data-ttu-id="42538-508">Этот метод с вызовом необходимо следовать <xref:System.GC.WaitForFullGCComplete%2A> метод, чтобы убедиться в том, что имеется полная сборка мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-508">You should follow this method with a call to the <xref:System.GC.WaitForFullGCComplete%2A> method to make sure that you have had a full garbage collection.</span></span> <span data-ttu-id="42538-509">Вызов этого метода только дает неопределенные результаты.</span><span class="sxs-lookup"><span data-stu-id="42538-509">Calling this method alone causes indeterminate results.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="42538-510">Значение <paramref name="millisecondsTimeout" /> должно быть либо неотрицательным, либо меньше или равно <see cref="F:System.Int32.MaxValue" /> или –1.</span><span class="sxs-lookup"><span data-stu-id="42538-510"><paramref name="millisecondsTimeout" /> must be either non-negative or less than or equal to <see cref="F:System.Int32.MaxValue" /> or -1.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="42538-511">для полного доверия для непосредственного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="42538-511">for full trust for the immediate caller.</span></span> <span data-ttu-id="42538-512">Этот член не может быть использован частично доверенным кодом.</span><span class="sxs-lookup"><span data-stu-id="42538-512">This member cannot be used by partially trusted code.</span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="42538-513">Требует полного доверия для непосредственного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="42538-513">requires full trust for the immediate caller.</span></span> <span data-ttu-id="42538-514">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="42538-514">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89"><span data-ttu-id="42538-515">Уведомления о сборке мусора</span><span class="sxs-lookup"><span data-stu-id="42538-515">Garbage Collection Notifications</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCComplete">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="42538-516">Возвращает состояние зарегистрированного уведомления, чтобы определить, завершена ли полная блокировка сборки мусора средой CLR.</span><span class="sxs-lookup"><span data-stu-id="42538-516">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime has completed.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete();" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCComplete : unit -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="42538-517">Возвращает состояние зарегистрированного уведомления, чтобы определить, завершена ли полная блокировка сборки мусора средой CLR.</span><span class="sxs-lookup"><span data-stu-id="42538-517">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime has completed.</span></span></summary>
        <returns><span data-ttu-id="42538-518">Состояние зарегистрированного уведомления о сборке мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-518">The status of the registered garbage collection notification.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42538-519">Используйте <xref:System.GCNotificationStatus> перечисление, возвращенное этим методом, чтобы определить состояние текущего уведомления сбора мусора, зарегистрированный с помощью <xref:System.GC.RegisterForFullGCNotification%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="42538-519">Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="42538-520">Можно также использовать <xref:System.GC.WaitForFullGCApproach%2A> метод, чтобы определить, является ли неизбежной полная сборка мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-520">You can also use the <xref:System.GC.WaitForFullGCApproach%2A> method to determine whether a full garbage collection is imminent.</span></span>  
  
 <span data-ttu-id="42538-521">При возвращении перечисления <xref:System.GCNotificationStatus.Succeeded>, вы можете выполнять задачи, такие как возобновление работы и получения число коллекций с <xref:System.GC.CollectionCount%2A> свойство.</span><span class="sxs-lookup"><span data-stu-id="42538-521">When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as resuming work and obtaining a collection count with the <xref:System.GC.CollectionCount%2A> property.</span></span>  
  
 <span data-ttu-id="42538-522">Этот метод бесконечно ожидает уведомление о сборке мусора получить невозможно.</span><span class="sxs-lookup"><span data-stu-id="42538-522">This method waits indefinitely for a garbage collection notification to be obtained.</span></span> <span data-ttu-id="42538-523">Если вы хотите указать время ожидания для метода для возврата, если не удается получить уведомление, используйте <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> перегрузки метода.</span><span class="sxs-lookup"><span data-stu-id="42538-523">If you want to specify a time-out period for the method to return if the notification cannot be obtained, use the <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="42538-524">Если этот метод вызывается без указания времени ожидания, можно вызвать <xref:System.GC.CancelFullGCNotification%2A> метод, если ожидается больше, чем предпочтительные.</span><span class="sxs-lookup"><span data-stu-id="42538-524">If you call this method without specifying a time-out, you can call the <xref:System.GC.CancelFullGCNotification%2A> method if you are waiting longer than preferred.</span></span>  
  
 <span data-ttu-id="42538-525">Вызов этого метода необходимо указывать с помощью вызова <xref:System.GC.WaitForFullGCApproach%2A> метод, чтобы убедиться в том, что имеется полная сборка мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-525">This method call should be preceded with a call to the <xref:System.GC.WaitForFullGCApproach%2A> method to make sure that you have had a full garbage collection.</span></span> <span data-ttu-id="42538-526">Сам по себе вызов этого метода может привести к непредсказуемым результатам.</span><span class="sxs-lookup"><span data-stu-id="42538-526">Calling this method alone can produce indeterminate results.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42538-527">В следующем примере показано, как этот метод позволяет определить, завершена ли полная сборка мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-527">The following example shows how to use this method to determine whether a full garbage collection has completed.</span></span> <span data-ttu-id="42538-528">Каждый раз, когда находится в состоянии уведомление <xref:System.GCNotificationStatus.Succeeded>, пользовательский метод `OnFullGCCompletedNotify` вызывается для выполнения действий в ответ на выполненной сборки.</span><span class="sxs-lookup"><span data-stu-id="42538-528">Whenever the status of the notification is <xref:System.GCNotificationStatus.Succeeded>, the user method `OnFullGCCompletedNotify` is called to perform actions in response to the completed collection.</span></span> <span data-ttu-id="42538-529">Данный пример кода является частью большего примера для [уведомлений сборки мусора](~/docs/standard/garbage-collection/notifications.md) раздела.</span><span class="sxs-lookup"><span data-stu-id="42538-529">This code example is part of a larger example provided for [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.</span></span>  
  
 [!code-cpp[GCNotification#4](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#4)]
 [!code-csharp[GCNotification#4](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#4)]
 [!code-vb[GCNotification#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="42538-530">для полного доверия для непосредственного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="42538-530">for full trust for the immediate caller.</span></span> <span data-ttu-id="42538-531">Этот член не может быть использован частично доверенным кодом.</span><span class="sxs-lookup"><span data-stu-id="42538-531">This member cannot be used by partially trusted code.</span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="42538-532">Требует полного доверия для непосредственного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="42538-532">requires full trust for the immediate caller.</span></span> <span data-ttu-id="42538-533">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="42538-533">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89"><span data-ttu-id="42538-534">Уведомления о сборке мусора</span><span class="sxs-lookup"><span data-stu-id="42538-534">Garbage Collection Notifications</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCComplete : int -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCComplete millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="42538-535">Продолжительность времени ожидания, прежде чем можно извлечь состояние уведомления.</span><span class="sxs-lookup"><span data-stu-id="42538-535">The length of time to wait before a notification status can be obtained.</span></span> <span data-ttu-id="42538-536">Укажите значение -1, если период ожидания неограниченный.</span><span class="sxs-lookup"><span data-stu-id="42538-536">Specify -1 to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="42538-537">Возвращает состояние зарегистрированного уведомления в пределах указанного времени ожидания, чтобы определить, завершена ли полная блокировка сборки мусора средой CLR.</span><span class="sxs-lookup"><span data-stu-id="42538-537">Returns, in a specified time-out period, the status of a registered notification for determining whether a full, blocking garbage collection by common language the runtime has completed.</span></span></summary>
        <returns><span data-ttu-id="42538-538">Состояние зарегистрированного уведомления о сборке мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-538">The status of the registered garbage collection notification.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42538-539">Используйте <xref:System.GCNotificationStatus> перечисление, возвращенное этим методом, чтобы определить состояние текущего уведомления сбора мусора, зарегистрированный с помощью <xref:System.GC.RegisterForFullGCNotification%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="42538-539">Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="42538-540">Можно также использовать <xref:System.GC.WaitForFullGCApproach%2A> метод, чтобы определить, является ли неизбежной полная сборка мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-540">You can also use the <xref:System.GC.WaitForFullGCApproach%2A> method to determine whether a full garbage collection is imminent.</span></span>  
  
 <span data-ttu-id="42538-541">Обратите внимание, что этот метод возвращается сразу же каждый раз, когда получается состояние уведомления сбора мусора, независимо от значения, указанного в `millisecondsTimeout`.</span><span class="sxs-lookup"><span data-stu-id="42538-541">Note that this method returns immediately whenever a garbage collection notification status is obtained, regardless of the value specified by `millisecondsTimeout`.</span></span> <span data-ttu-id="42538-542">Если состояние уведомления сбора мусора не будет получена перед `millisecondsTimeout` раз, этот метод возвращает <xref:System.GCNotificationStatus.NotApplicable>.</span><span class="sxs-lookup"><span data-stu-id="42538-542">If a garbage collection notification status is not obtained before `millisecondsTimeout` times out, this method returns <xref:System.GCNotificationStatus.NotApplicable>.</span></span>  
  
 <span data-ttu-id="42538-543">При возвращении перечисления <xref:System.GCNotificationStatus.Succeeded>, вы можете выполнять задачи, такие как возобновление работы и получения число коллекций с <xref:System.GC.CollectionCount%2A> свойство.</span><span class="sxs-lookup"><span data-stu-id="42538-543">When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as resuming work and obtaining a collection count with the <xref:System.GC.CollectionCount%2A> property.</span></span>  
  
 <span data-ttu-id="42538-544">Вы можете вызвать <xref:System.GC.CancelFullGCNotification%2A> метод, если вы не можете ждать период ожидания, которое должно пройти.</span><span class="sxs-lookup"><span data-stu-id="42538-544">You can call the <xref:System.GC.CancelFullGCNotification%2A> method when you cannot wait for the time-out period to elapse.</span></span>  
  
 <span data-ttu-id="42538-545">Вызов этого метода необходимо указывать с помощью вызова <xref:System.GC.WaitForFullGCApproach%2A> метод, чтобы убедиться в том, что имеется полная сборка мусора.</span><span class="sxs-lookup"><span data-stu-id="42538-545">This method call should be preceded with a call to the <xref:System.GC.WaitForFullGCApproach%2A> method to make sure that you have had a full garbage collection.</span></span> <span data-ttu-id="42538-546">Сам по себе вызов этого метода может привести к непредсказуемым результатам.</span><span class="sxs-lookup"><span data-stu-id="42538-546">Calling this method alone can produce indeterminate results.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42538-547">Значение <paramref name="millisecondsTimeout" /> должно быть либо неотрицательным, либо меньше или равно <see cref="F:System.Int32.MaxValue" /> или –1.</span><span class="sxs-lookup"><span data-stu-id="42538-547"><paramref name="millisecondsTimeout" /> must be either non-negative or less than or equal to <see cref="F:System.Int32.MaxValue" /> or -1.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="42538-548">для полного доверия для непосредственного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="42538-548">for full trust for the immediate caller.</span></span> <span data-ttu-id="42538-549">Этот член не может быть использован частично доверенным кодом.</span><span class="sxs-lookup"><span data-stu-id="42538-549">This member cannot be used by partially trusted code.</span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="42538-550">Требует полного доверия для непосредственного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="42538-550">requires full trust for the immediate caller.</span></span> <span data-ttu-id="42538-551">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="42538-551">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89"><span data-ttu-id="42538-552">Уведомления о сборке мусора</span><span class="sxs-lookup"><span data-stu-id="42538-552">Garbage Collection Notifications</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WaitForPendingFinalizers">
      <MemberSignature Language="C#" Value="public static void WaitForPendingFinalizers ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitForPendingFinalizers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForPendingFinalizers" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WaitForPendingFinalizers ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitForPendingFinalizers();" />
      <MemberSignature Language="F#" Value="static member WaitForPendingFinalizers : unit -&gt; unit" Usage="System.GC.WaitForPendingFinalizers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="42538-553">Приостанавливает текущий поток до тех пор, пока поток, обрабатывающий очередь методов завершения, не обработает всю очередь.</span><span class="sxs-lookup"><span data-stu-id="42538-553">Suspends the current thread until the thread that is processing the queue of finalizers has emptied that queue.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42538-554">Когда сборщик мусора находит объекты, которые могут быть освобождены, он проверяет каждый объект, для определения требований к финализации объекта.</span><span class="sxs-lookup"><span data-stu-id="42538-554">When the garbage collector finds objects that can be reclaimed, it checks each object to determine the object's finalization requirements.</span></span> <span data-ttu-id="42538-555">Если объект реализует метод завершения и завершения не отключен, вызвав <xref:System.GC.SuppressFinalize%2A>, то объект помещается в список объектов, которые помечены как готовые к завершению.</span><span class="sxs-lookup"><span data-stu-id="42538-555">If an object implements a finalizer and has not disabled finalization by calling <xref:System.GC.SuppressFinalize%2A>, the object is placed in a list of objects that are marked as ready for finalization.</span></span> <span data-ttu-id="42538-556">Сборщик мусора вызывает <xref:System.Object.Finalize%2A> методы для объектов в этом списке и удаляет элементы из списка.</span><span class="sxs-lookup"><span data-stu-id="42538-556">The garbage collector calls the <xref:System.Object.Finalize%2A> methods for the objects in this list and removes the entries from the list.</span></span> <span data-ttu-id="42538-557">Этот метод блокируется до завершения всех выполненных до завершения.</span><span class="sxs-lookup"><span data-stu-id="42538-557">This method blocks until all finalizers have run to completion.</span></span>  
  
 <span data-ttu-id="42538-558">Поток, на котором выполняются методы завершения не определен, поэтому нет никакой гарантии, что этот метод будет завершена.</span><span class="sxs-lookup"><span data-stu-id="42538-558">The thread on which finalizers are run is unspecified, so there is no guarantee that this method will terminate.</span></span> <span data-ttu-id="42538-559">Тем не менее, этот поток может быть прерван другим потоком <xref:System.GC.WaitForPendingFinalizers%2A> метод выполняется.</span><span class="sxs-lookup"><span data-stu-id="42538-559">However, this thread can be interrupted by another thread while the <xref:System.GC.WaitForPendingFinalizers%2A> method is in progress.</span></span> <span data-ttu-id="42538-560">Например можно запустить другой поток, который ожидает в течение определенного периода времени и затем прерывает работу потока, если он по-прежнему находится в приостановленном состоянии.</span><span class="sxs-lookup"><span data-stu-id="42538-560">For example, you can start another thread that waits for a period of time and then interrupts this thread if this thread is still suspended.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42538-561">Следующий пример демонстрирует, как использовать <xref:System.GC.WaitForPendingFinalizers%2A> методе для приостановки текущего потока до завершения всех объектов.</span><span class="sxs-lookup"><span data-stu-id="42538-561">The following example demonstrates how to use the <xref:System.GC.WaitForPendingFinalizers%2A> method to suspend the current thread until finalization of all the collected objects is complete.</span></span>  
  
 [!code-cpp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CS/class1.cs#1)]
 [!code-vb[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>