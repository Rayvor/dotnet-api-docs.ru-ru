<Type Name="CharEnumerator" FullName="System.CharEnumerator">
  <Metadata><Meta Name="ms.openlocfilehash" Value="674ca0ff6ab128d0807cf2b9d4f07caded3523e1" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69406905" /></Metadata><TypeSignature Language="C#" Value="public sealed class CharEnumerator : ICloneable, System.Collections.Generic.IEnumerator&lt;char&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit CharEnumerator extends System.Object implements class System.Collections.Generic.IEnumerator`1&lt;char&gt;, class System.Collections.IEnumerator, class System.ICloneable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.CharEnumerator" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class CharEnumerator&#xA;Implements ICloneable, IEnumerator(Of Char)" />
  <TypeSignature Language="C++ CLI" Value="public ref class CharEnumerator sealed : ICloneable, System::Collections::Generic::IEnumerator&lt;char&gt;" />
  <TypeSignature Language="F#" Value="type CharEnumerator = class&#xA;    interface IEnumerator&#xA;    interface ICloneable&#xA;    interface IEnumerator&lt;char&gt;&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerator&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerator</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Поддерживает итерацию по объекту <see cref="T:System.String" /> и чтение отдельных его символов. Этот класс не наследуется.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Предоставляет доступ только для чтения к символам в упоминаемом <xref:System.String> объекте. <xref:System.CharEnumerator> Например, `foreach` оператор Microsoft Visual Basic и C# языки программирования, которые просматривают элементы <xref:System.CharEnumerator> коллекции, <xref:System.String> получают из объекта, чтобы выполнить итерацию по символам. в этом объекте.  

> [!IMPORTANT]
> Класс перечисляет отдельные 16-разрядные <xref:System.Char> экземпляры. `CharEnumerator` Он не учитывает графемес (то есть символ, за которым следует один или несколько комбидинг символов) или суррогатные пары (т. е. символы за пределами многоязычной многоязыковой плоскости Юникода) как одиночные символы. Для перечислителя, который обрабатывает эти типы символов как единое целое, используйте <xref:System.Globalization.StringInfo> класс.

 Нет общего конструктора для <xref:System.CharEnumerator>. Вместо этого вызовите <xref:System.String> <xref:System.String.GetEnumerator%2A> метод объекта, чтобы получить объект <xref:System.CharEnumerator> , инициализируемый для ссылки на строку.  
  
 Поддерживает внутренний индекс символов в строке, <xref:System.CharEnumerator> на которые ссылаются. <xref:System.CharEnumerator> Состояние индекса недопустимо, если он ссылается на расположение символа, логически предшествующее первому символу или после последнего символа в строке, и допустимо, если он ссылается на символ в строке. Индекс инициализируется в позиции, логически предшествующей первому символу, и устанавливается в позиции после последнего символа после завершения итерации. Исключение возникает при попытке доступа к символу, если индекс является недопустимым.  
  
 <xref:System.CharEnumerator.MoveNext%2A> Метод увеличивает индекс на единицу, поэтому доступ к первому и последующим символам осуществляется по очереди. <xref:System.CharEnumerator.Reset%2A> Метод задает для индекса расположение, логически предшествующее первому символу. <xref:System.CharEnumerator.Current%2A> Свойство получает символ, на который в данный момент ссылается индекс. Метод создает копию <xref:System.CharEnumerator>объекта. <xref:System.CharEnumerator.Clone%2A>  
  
> [!NOTE]
>  Несколько независимых экземпляров <xref:System.CharEnumerator> в одном или нескольких потоках могут иметь доступ к одному <xref:System.String>экземпляру. Этот класс реализован для поддержки <xref:System.Collections.IEnumerator> интерфейса. Дополнительные сведения об использовании перечислителя см. в <xref:System.Collections.IEnumerator> разделе.  
  
   
  
## Examples  
 В следующем примере <xref:System.CharEnumerator> класс используется для перечисления отдельных символов в строке. Он создает экземпляр <xref:System.CharEnumerator> объекта, <xref:System.String.GetEnumerator%2A?displayProperty=nameWithType> вызывая метод, перемещает от одного символа к другому, вызывая <xref:System.CharEnumerator.MoveNext%2A> метод, и отображает текущий <xref:System.CharEnumerator.Current%2A> символ, получая значение свойства.  
  
 [!code-cpp[System.CharEnumerator.Class#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.CharEnumerator.Class/cpp/charenumerator1.cpp#1)]
 [!code-csharp[System.CharEnumerator.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.CharEnumerator.Class/cs/CharEnumerator1.cs#1)]
 [!code-vb[System.CharEnumerator.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.CharEnumerator.Class/vb/CharEnumerator1.vb#1)]  
  
 Однако обратите внимание, что одна и та же операция может быть выполнена несколько более интуитивно с помощью `foreach` ( `For Each` в C#) или (в Visual Basic), как показано в следующем примере.  
  
 [!code-cpp[System.CharEnumerator.Class#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.CharEnumerator.Class/cpp/charenumerator1.cpp#2)]
 [!code-csharp[System.CharEnumerator.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.CharEnumerator.Class/cs/CharEnumerator1.cs#2)]
 [!code-vb[System.CharEnumerator.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.CharEnumerator.Class/vb/CharEnumerator1.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.String" />
    <altmember cref="T:System.Collections.IEnumerator" />
    <altmember cref="T:System.Collections.IEnumerable" />
    <altmember cref="T:System.Collections.ICollection" />
  </Docs>
  <Members>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CharEnumerator.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="charEnumerator.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает копию текущего объекта <see cref="T:System.CharEnumerator" />.</summary>
        <returns>Объект <see cref="T:System.Object" />, являющийся копией текущего объекта <see cref="T:System.CharEnumerator" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращаемое значение является копией этого экземпляра <xref:System.CharEnumerator> и его текущим состоянием. Это полезно для сохранения состояния при переборе <xref:System.String> объекта.  
  
 Например, предположим, что приложение использует исходный экземпляр <xref:System.CharEnumerator> для итерации каждого символа <xref:System.String>в. При обнаружении уникального символа приложение приостанавливает обработку и вызывает <xref:System.CharEnumerator.Clone%2A> метод. Фактически это сохраняет <xref:System.CharEnumerator> индекс объекта <xref:System.String>в.  
  
 Приложение использует клон для перехода к другой части, `String` чтобы выполнить некоторую вспомогательную обработку. Побочным результатом этой навигации является то, что клон теряет позицию остановки обработки. Однако по завершении вспомогательной обработки приложение удаляет клон и использует исходный <xref:System.CharEnumerator> экземпляр для возобновления работы с тем, <xref:System.String> где остановлена исходная обработка.  
  
> [!NOTE]
>  Этот метод реализован для поддержки <xref:System.ICloneable> интерфейса.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public char Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Current" />
      <MemberSignature Language="DocId" Value="P:System.CharEnumerator.Current" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Current As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char Current { char get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : char" Usage="System.CharEnumerator.Current" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IEnumerator`1.Current</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает текущий символ в строке, обходимой данным объектом <see cref="T:System.CharEnumerator" />.</summary>
        <value>Возвращает символ Юникод, на которой указывает данный объект <see cref="T:System.CharEnumerator" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Класс поддерживает внутренний индекс для перечисленной строки, <xref:System.CharEnumerator.Current%2A> а свойство возвращает символ, на который в данный момент ссылается индекс. <xref:System.CharEnumerator> Это свойство должно вызываться, только если индекс является допустимым; в противном случае создается исключение.  
  
 Индекс всегда является недопустимым для пустой строки (""). Индекс также является недопустимым после <xref:System.String.GetEnumerator%2A?displayProperty=nameWithType> вызова <xref:System.CharEnumerator.Reset%2A> метода или. После вызова любого из этих методов вызовите <xref:System.CharEnumerator.MoveNext%2A> метод, чтобы изменить индекс на первый символ в перечисленной строке. Индекс действителен всякий раз, <xref:System.CharEnumerator.MoveNext%2A> когда метод `true`возвращает значение.  
  
 <xref:System.CharEnumerator.Current%2A>не перемещает индекс <xref:System.CharEnumerator.Current%2A> , а последовательные вызовы возвращают один и тот же символ, пока <xref:System.String.GetEnumerator%2A?displayProperty=nameWithType> <xref:System.CharEnumerator.MoveNext%2A>не будет вызван метод, <xref:System.CharEnumerator.Reset%2A>или.  
  
   
  
## Examples  
 В следующем примере <xref:System.CharEnumerator> класс используется для перечисления отдельных символов в строке. Он создает экземпляр <xref:System.CharEnumerator> объекта, <xref:System.String.GetEnumerator%2A?displayProperty=nameWithType> вызывая метод, перемещает от одного символа к другому, вызывая <xref:System.CharEnumerator.MoveNext%2A> метод, и отображает текущий <xref:System.CharEnumerator.Current%2A> символ, получая значение свойства.  
  
 [!code-cpp[System.CharEnumerator.Class#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.CharEnumerator.Class/cpp/charenumerator1.cpp#1)]
 [!code-csharp[System.CharEnumerator.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.CharEnumerator.Class/cs/CharEnumerator1.cs#1)]
 [!code-vb[System.CharEnumerator.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.CharEnumerator.Class/vb/CharEnumerator1.vb#1)]  
  
 Однако обратите внимание, что одна и та же операция может быть выполнена несколько более интуитивно с помощью `foreach` ( `For Each` в C#) или (в Visual Basic), как показано в следующем примере.  
  
 [!code-cpp[System.CharEnumerator.Class#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.CharEnumerator.Class/cpp/charenumerator1.cpp#2)]
 [!code-csharp[System.CharEnumerator.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.CharEnumerator.Class/cs/CharEnumerator1.cs#2)]
 [!code-vb[System.CharEnumerator.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.CharEnumerator.Class/vb/CharEnumerator1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Индекс является недопустимым; это означает, что он находится перед первым или после последнего символа обходимой строки.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CharEnumerator.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="charEnumerator.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.CharEnumerator" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите метод <xref:System.CharEnumerator.Dispose%2A> по окончании использования класса <xref:System.CharEnumerator>. Метод <xref:System.CharEnumerator.Dispose%2A> оставляет класс <xref:System.CharEnumerator> в непригодном для использования состоянии. После вызова <xref:System.CharEnumerator.Dispose%2A>необходимо освободить все ссылки <xref:System.CharEnumerator> на, чтобы сборщик мусора мог освободить память, которую <xref:System.CharEnumerator> занимают.  
  
 Дополнительные сведения см. в разделе [Очистка неуправляемых ресурсов](~/docs/standard/garbage-collection/unmanaged.md) и [Реализация метода Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Всегда вызывайте метод <xref:System.CharEnumerator.Dispose%2A> перед освобождением последней ссылки на класс <xref:System.CharEnumerator>. В противном случае используемые им ресурсы не будут освобождены до тех пор, пока сборщик мусора не вызовет для объекта <xref:System.CharEnumerator> метод `Finalize`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CharEnumerator.MoveNext" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveNext();" />
      <MemberSignature Language="F#" Value="abstract member MoveNext : unit -&gt; bool&#xA;override this.MoveNext : unit -&gt; bool" Usage="charEnumerator.MoveNext " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.MoveNext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Увеличивает внутренний индекс текущего объекта <see cref="T:System.CharEnumerator" />, чтобы он указывал на следующий символ перечисляемой строки.</summary>
        <returns>Значение <see langword="true" /> если индекс успешно увеличен и находится в пределах перечисляемой строки; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Класс поддерживает внутренний индекс для перечисленной строки, <xref:System.CharEnumerator.MoveNext%2A> а метод увеличивает индекс на единицу. <xref:System.CharEnumerator> Вызов <xref:System.CharEnumerator.MoveNext%2A> после вызова <xref:System.String.GetEnumerator%2A> или <xref:System.CharEnumerator.Reset%2A> для увеличения текущего позиции символа до первого символа в перечисленной строке. Убедитесь, что возвращаемое значение `true` определяет допустимость текущей позиции символа.  
  
 Если индекс уже находится за последним символом перечисленной строки, индекс не изменяется и `false` возвращается.  
  
 Обратите внимание, что если перечисленная строка пуста (""), состояние <xref:System.CharEnumerator> объекта всегда является недопустимым. Это происходит потому, что внутренний индекс для <xref:System.CharEnumerator> объекта изначально предшествует первому символу перечисленной строки и поэтому является недопустимым. <xref:System.CharEnumerator.MoveNext%2A>логически задает индекс после последнего (несуществующего) символа перечисленной строки, который также является недопустимым.  
  
   
  
## Examples  
 В следующем примере <xref:System.CharEnumerator> класс используется для перечисления отдельных символов в строке. Он создает экземпляр <xref:System.CharEnumerator> объекта, <xref:System.String.GetEnumerator%2A?displayProperty=nameWithType> вызывая метод, перемещает от одного символа к другому, вызывая <xref:System.CharEnumerator.MoveNext%2A> метод, и отображает текущий <xref:System.CharEnumerator.Current%2A> символ, получая значение свойства.  
  
 [!code-cpp[System.CharEnumerator.Class#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.CharEnumerator.Class/cpp/charenumerator1.cpp#1)]
 [!code-csharp[System.CharEnumerator.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.CharEnumerator.Class/cs/CharEnumerator1.cs#1)]
 [!code-vb[System.CharEnumerator.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.CharEnumerator.Class/vb/CharEnumerator1.vb#1)]  
  
 Однако обратите внимание, что одна и та же операция может быть выполнена несколько более интуитивно с помощью `foreach` ( `For Each` в C#) или (в Visual Basic), как показано в следующем примере.  
  
 [!code-cpp[System.CharEnumerator.Class#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.CharEnumerator.Class/cpp/charenumerator1.cpp#2)]
 [!code-csharp[System.CharEnumerator.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.CharEnumerator.Class/cs/CharEnumerator1.cs#2)]
 [!code-vb[System.CharEnumerator.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.CharEnumerator.Class/vb/CharEnumerator1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CharEnumerator.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="charEnumerator.Reset " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.Reset</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Инициализирует индекс позицией, логически расположенной перед первым символом обходимой строки.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Класс поддерживает внутренний индекс для перечисленной строки, <xref:System.CharEnumerator.Reset%2A> а метод задает для индекса недопустимое состояние. <xref:System.CharEnumerator>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerator.Current">
      <MemberSignature Language="C#" Value="object System.Collections.IEnumerator.Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IEnumerator.Current" />
      <MemberSignature Language="DocId" Value="P:System.CharEnumerator.System#Collections#IEnumerator#Current" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Current As Object Implements IEnumerator.Current" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IEnumerator::Current { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IEnumerator.Current" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IEnumerator.Current</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает текущий символ в строке, обходимой данным объектом <see cref="T:System.CharEnumerator" />. Описание этого члена см. в разделе <see cref="P:System.Collections.IEnumerator.Current" />.</summary>
        <value>Упакованный символ Юникод, на которой указывает данный объект <see cref="T:System.CharEnumerator" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.CharEnumerator> приведен к типу интерфейса <xref:System.Collections.IEnumerator>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Перечисление не начиналось.  
  
 - или -  
  
 Обход завершен.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CharEnumerator.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает все ресурсы, используемые классом <see cref="T:System.CharEnumerator" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Вызовите IDisposable. Dispose по завершении использования <xref:System.CharEnumerator> класса. Метод оставляет <xref:System.CharEnumerator> класс в непригодном для использования состоянии. После вызова метода необходимо освободить все ссылки на <xref:System.CharEnumerator> класс, чтобы сборщик мусора мог освободить память <xref:System.CharEnumerator> , занимаемую классом.

Дополнительные сведения см. в разделе [Очистка неуправляемых ресурсов](~/docs/standard/garbage-collection/unmanaged.md) и [Реализация метода Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).

> [!NOTE]
> Всегда вызывайте IDisposable. Dispose перед освобождением последней ссылки на <xref:System.CharEnumerator> класс. В противном случае используемые им ресурсы не будут освобождены до тех пор, пока сборщик мусора не вызовет для объекта <xref:System.CharEnumerator> метод <xref:System.Object.Finalize>.

]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
