<Type Name="AppDomain" FullName="System.AppDomain">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8193f1d65725a40b2301463ace7d4d95fbe76d8c" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70646966" /></Metadata><TypeSignature Language="C#" Value="public sealed class AppDomain : MarshalByRefObject, _AppDomain, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit AppDomain extends System.MarshalByRefObject implements class System._AppDomain, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.AppDomain" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AppDomain&#xA;Inherits MarshalByRefObject&#xA;Implements _AppDomain, IEvidenceFactory" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppDomain sealed : MarshalByRefObject, _AppDomain, System::Security::IEvidenceFactory" />
  <TypeSignature Language="F#" Value="type AppDomain = class&#xA;    inherit MarshalByRefObject&#xA;    interface _AppDomain&#xA;    interface IEvidenceFactory" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System._AppDomain</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System._AppDomain))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="be398-101">Представляет домен приложения, являющийся изолированной средой, в которой выполняются приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-101">Represents an application domain, which is an isolated environment where applications execute.</span></span> <span data-ttu-id="be398-102">Этот класс не наследуется.</span><span class="sxs-lookup"><span data-stu-id="be398-102">This class cannot be inherited.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-103">Домены приложений, представленные <xref:System.AppDomain> объектами, помогают обеспечить изоляцию, выгрузку и границы безопасности для исполнения управляемого кода.</span><span class="sxs-lookup"><span data-stu-id="be398-103">Application domains, which are represented by <xref:System.AppDomain> objects, help provide isolation, unloading, and security boundaries for executing managed code.</span></span>  
  
-   <span data-ttu-id="be398-104">Используйте домены приложений для изоляции задач, которые могут привести к завершению процесса.</span><span class="sxs-lookup"><span data-stu-id="be398-104">Use application domains to isolate tasks that might bring down a process.</span></span> <span data-ttu-id="be398-105">Если состояние <xref:System.AppDomain> , в котором выполняется задача, станет нестабильным, можно <xref:System.AppDomain> выгрузить его, не влияя на процесс.</span><span class="sxs-lookup"><span data-stu-id="be398-105">If the state of the <xref:System.AppDomain> that's executing a task becomes unstable, the <xref:System.AppDomain> can be unloaded without affecting the process.</span></span> <span data-ttu-id="be398-106">Это важно, когда процесс должен выполняться в течение длительных периодов без перезапуска.</span><span class="sxs-lookup"><span data-stu-id="be398-106">This is important when a process must run for long periods without restarting.</span></span> <span data-ttu-id="be398-107">Кроме того, домены приложений можно использовать для изоляции задач, которые не должны обмениваться данными.</span><span class="sxs-lookup"><span data-stu-id="be398-107">You can also use application domains to isolate tasks that should not share data.</span></span>  
  
-   <span data-ttu-id="be398-108">Если сборка загружается в домен приложения по умолчанию, она не может быть выгружена из памяти во время выполнения процесса.</span><span class="sxs-lookup"><span data-stu-id="be398-108">If an assembly is loaded into the default application domain, it cannot be unloaded from memory while the process is running.</span></span> <span data-ttu-id="be398-109">Однако при открытии второго домена приложения для загрузки и выполнения сборки сборка выгружается при выгрузке этого домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-109">However, if you open a second application domain to load and execute the assembly, the assembly is unloaded when that application domain is unloaded.</span></span> <span data-ttu-id="be398-110">Используйте этот способ для сворачивания рабочего набора длительно выполняющихся процессов, которые иногда используют большие библиотеки DLL.</span><span class="sxs-lookup"><span data-stu-id="be398-110">Use this technique to minimize the working set of long-running processes that occasionally use large DLLs.</span></span>  
  
 > [!NOTE]
 >  <span data-ttu-id="be398-111">В .NET Core <xref:System.AppDomain> реализация ограничена конструкцией и не обеспечивает изоляцию, выгрузку или границы безопасности.</span><span class="sxs-lookup"><span data-stu-id="be398-111">On .NET Core, the <xref:System.AppDomain> implementation is limited by design and does not provide isolation, unloading, or security boundaries.</span></span> <span data-ttu-id="be398-112">Для .NET Core существует только один <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="be398-112">For .NET Core, there is exactly one <xref:System.AppDomain>.</span></span> <span data-ttu-id="be398-113">Изоляция и выгрузка обеспечиваются <xref:System.Runtime.Loader.AssemblyLoadContext>с помощью.</span><span class="sxs-lookup"><span data-stu-id="be398-113">Isolation and unloading are provided through <xref:System.Runtime.Loader.AssemblyLoadContext>.</span></span> <span data-ttu-id="be398-114">Границы безопасности должны предоставляться границами процессов и соответствующими методами удаленного взаимодействия.</span><span class="sxs-lookup"><span data-stu-id="be398-114">Security boundaries should be provided by process boundaries and appropriate remoting techniques.</span></span>
 
 <span data-ttu-id="be398-115">Несколько доменов приложений могут работать в одном процессе; Однако между доменами приложений и потоками не существует однозначной корреляции.</span><span class="sxs-lookup"><span data-stu-id="be398-115">Multiple application domains can run in a single process; however, there is not a one-to-one correlation between application domains and threads.</span></span> <span data-ttu-id="be398-116">Несколько потоков могут принадлежать одному домену приложения, а пока заданный поток не ограничен одним доменом приложения в любой момент времени, поток выполняется в одном домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-116">Several threads can belong to a single application domain, and while a given thread is not confined to a single application domain, at any given time, a thread executes in a single application domain.</span></span>  
  
 <span data-ttu-id="be398-117">Домены приложений создаются с помощью <xref:System.AppDomain.CreateDomain%2A> метода.</span><span class="sxs-lookup"><span data-stu-id="be398-117">Application domains are created using the <xref:System.AppDomain.CreateDomain%2A> method.</span></span> <span data-ttu-id="be398-118"><xref:System.AppDomain>экземпляры используются для загрузки и выполнения сборок (<xref:System.Reflection.Assembly>).</span><span class="sxs-lookup"><span data-stu-id="be398-118"><xref:System.AppDomain> instances are used to load and execute assemblies (<xref:System.Reflection.Assembly>).</span></span> <span data-ttu-id="be398-119">Если объект <xref:System.AppDomain> больше не используется, его можно выгрузить.</span><span class="sxs-lookup"><span data-stu-id="be398-119">When an <xref:System.AppDomain> is no longer in use, it can be unloaded.</span></span>  
  
 <span data-ttu-id="be398-120"><xref:System.AppDomain> Класс реализует набор событий, которые позволяют приложениям реагировать при загрузке сборки, при выгрузке домена приложения или при возникновении необработанного исключения.</span><span class="sxs-lookup"><span data-stu-id="be398-120">The <xref:System.AppDomain> class implements a set of events that enable applications to respond when an assembly is loaded, when an application domain will be unloaded, or when an unhandled exception is thrown.</span></span>  
  
 <span data-ttu-id="be398-121">Дополнительные сведения об использовании доменов приложений см. в разделе [домены приложений](~/docs/framework/app-domains/application-domains.md).</span><span class="sxs-lookup"><span data-stu-id="be398-121">For more information on using application domains, see [Application Domains](~/docs/framework/app-domains/application-domains.md).</span></span>  
  
 <span data-ttu-id="be398-122">Этот класс реализует <xref:System.MarshalByRefObject>интерфейсы, <xref:System._AppDomain>и. <xref:System.Security.IEvidenceFactory></span><span class="sxs-lookup"><span data-stu-id="be398-122">This class implements the <xref:System.MarshalByRefObject>, <xref:System._AppDomain>, and <xref:System.Security.IEvidenceFactory> interfaces.</span></span>  
  
 <span data-ttu-id="be398-123">Никогда не следует создавать обертку для <xref:System.AppDomain> удаленных объектов.</span><span class="sxs-lookup"><span data-stu-id="be398-123">You should never create a remotable wrapper for an <xref:System.AppDomain> object.</span></span> <span data-ttu-id="be398-124">Это может опубликовать удаленную ссылку на это <xref:System.AppDomain>, предоставляя такие методы, как <xref:System.AppDomain.CreateInstance%2A> удаленный доступ, и эффективно уничтожая безопасность доступа к <xref:System.AppDomain>коду.</span><span class="sxs-lookup"><span data-stu-id="be398-124">Doing so could publish a remote reference to that <xref:System.AppDomain>, exposing methods such as <xref:System.AppDomain.CreateInstance%2A> to remote access and effectively destroying code access security for that <xref:System.AppDomain>.</span></span> <span data-ttu-id="be398-125">Вредоносные клиенты, подключающиеся к <xref:System.AppDomain> удаленной службе, могут получить доступ к <xref:System.AppDomain> любому ресурсу, к которому у него есть доступ.</span><span class="sxs-lookup"><span data-stu-id="be398-125">Malicious clients connecting to the remoted <xref:System.AppDomain> could obtain access to any resource the <xref:System.AppDomain> itself has access to.</span></span> <span data-ttu-id="be398-126">Не создавайте оболочки, поддерживающие удаленное взаимодействие, для <xref:System.MarshalByRefObject> любого типа, который расширяет и реализует методы, которые могут использоваться вредоносными клиентами для обхода системы безопасности.</span><span class="sxs-lookup"><span data-stu-id="be398-126">Do not create remotable wrappers for any type that extends <xref:System.MarshalByRefObject> and that implements methods that could be used by malicious clients to bypass the security system.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="be398-127">Значение по умолчанию для <xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType> свойства — `false`.</span><span class="sxs-lookup"><span data-stu-id="be398-127">The default value for the <xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType> property is `false`.</span></span> <span data-ttu-id="be398-128">Этот параметр является ненадежным для служб.</span><span class="sxs-lookup"><span data-stu-id="be398-128">This setting is unsafe for services.</span></span> <span data-ttu-id="be398-129">Чтобы службы не загружали частично доверенный код, задайте для `true`этого свойства значение.</span><span class="sxs-lookup"><span data-stu-id="be398-129">To prevent services from downloading partially trusted code, set this property to `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-130">В этом примере показано, как создать новый <xref:System.AppDomain>объект, создать экземпляр типа в этом новом <xref:System.AppDomain>объекте и взаимодействовать с объектом этого типа.</span><span class="sxs-lookup"><span data-stu-id="be398-130">This example shows how to create a new <xref:System.AppDomain>, instantiate a type in that new <xref:System.AppDomain>, and communicate with that type's object.</span></span> <span data-ttu-id="be398-131">Кроме того, в этом примере показано, как выгрузить, <xref:System.AppDomain> вызывающий сбор мусора для объекта.</span><span class="sxs-lookup"><span data-stu-id="be398-131">In addition, this example shows how to unload the <xref:System.AppDomain> causing the object to be garbage collected.</span></span>  
  
 [!code-cpp[AppDomainX#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainX/cpp/AppDomainX.cpp#1)]
 [!code-csharp[AppDomainX#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainX/cs/AppDomainX.cs#1)]
 [!code-vb[AppDomainX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainX/VB/AppDomainX.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/07ea8438-7a34-49f0-a7e8-3d6ff7e4a482"><span data-ttu-id="be398-132">Как настроить домен приложения</span><span class="sxs-lookup"><span data-stu-id="be398-132">How To: Configure an Application Domain</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/ba1fa43e-49f5-47d9-bd7f-3024af16f4ba"><span data-ttu-id="be398-133">Как создать домен приложения</span><span class="sxs-lookup"><span data-stu-id="be398-133">How To: Create an Application Domain</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/1432aa2d-bd83-4346-bf3b-a1b7920e2aa9"><span data-ttu-id="be398-134">Практическое руководство. Загрузка сборок в домен приложения</span><span class="sxs-lookup"><span data-stu-id="be398-134">How to: Load Assemblies into an Application Domain</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/f356116d-e415-4f7c-a332-6e6a60227192"><span data-ttu-id="be398-135">Практическое руководство. Выгрузка домена приложения</span><span class="sxs-lookup"><span data-stu-id="be398-135">How to: Unload an Application Domain</span></span></related>
  </Docs>
  <Members>
    <Member MemberName="ActivationContext">
      <MemberSignature Language="C#" Value="public ActivationContext ActivationContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ActivationContext ActivationContext" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ActivationContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActivationContext As ActivationContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ActivationContext ^ ActivationContext { ActivationContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ActivationContext : ActivationContext" Usage="System.AppDomain.ActivationContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ActivationContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="be398-136">Возвращает контекст активации по умолчанию для текущего домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-136">Gets the activation context for the current application domain.</span></span></summary>
        <value><span data-ttu-id="be398-137">Объект, представляющий контекст активации для текущего домена приложения, или значение <see langword="null" />, если этот домен не имеет контекста активации.</span><span class="sxs-lookup"><span data-stu-id="be398-137">An object that represents the activation context for the current application domain, or <see langword="null" /> if the domain has no activation context.</span></span></value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="be398-138">Требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="be398-138">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="be398-139">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="be398-139">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="AppendPrivatePath">
      <MemberSignature Language="C#" Value="public void AppendPrivatePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AppendPrivatePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.AppendPrivatePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendPrivatePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AppendPrivatePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member AppendPrivatePath : string -&gt; unit&#xA;override this.AppendPrivatePath : string -&gt; unit" Usage="appDomain.AppendPrivatePath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.AppendPrivatePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="be398-140">Имя каталога, который следует добавить в закрытый путь.</span><span class="sxs-lookup"><span data-stu-id="be398-140">The name of the directory to be appended to the private path.</span></span></param>
        <summary><span data-ttu-id="be398-141">Добавляет указанное имя каталога к закрытому списку путей.</span><span class="sxs-lookup"><span data-stu-id="be398-141">Appends the specified directory name to the private path list.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-142">Использовать это свойство не рекомендуется, так как оно может изменить путь поиска для сборок после того, как они уже были загружены.</span><span class="sxs-lookup"><span data-stu-id="be398-142">The use of this property is not recommended, because it might change the probing path for assemblies after they have already been loaded.</span></span> <span data-ttu-id="be398-143">Вместо этого следует использовать свойство <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="be398-143">Use the <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType> property instead.</span></span>  
  
 <span data-ttu-id="be398-144">Частный путь или относительный путь поиска — это путь относительно базового каталога, в котором арбитр сборок проверяет наличие закрытых сборок.</span><span class="sxs-lookup"><span data-stu-id="be398-144">The private path, or relative search path, is the path relative to the base directory where the assembly resolver probes for private assemblies.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-145">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-145">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="be398-146">Требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="be398-146">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="be398-147">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="be398-147">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationIdentity">
      <MemberSignature Language="C#" Value="public ApplicationIdentity ApplicationIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ApplicationIdentity ApplicationIdentity" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationIdentity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationIdentity As ApplicationIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ApplicationIdentity ^ ApplicationIdentity { ApplicationIdentity ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationIdentity : ApplicationIdentity" Usage="System.AppDomain.ApplicationIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ApplicationIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="be398-148">Возвращает удостоверение приложения в данном домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-148">Gets the identity of the application in the application domain.</span></span></summary>
        <value><span data-ttu-id="be398-149">Объект, идентифицирующий приложение в данном домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-149">An object that identifies the application in the application domain.</span></span></value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="be398-150">Требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="be398-150">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="be398-151">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="be398-151">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationTrust" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationTrust As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::ApplicationTrust ^ ApplicationTrust { System::Security::Policy::ApplicationTrust ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationTrust : System.Security.Policy.ApplicationTrust" Usage="System.AppDomain.ApplicationTrust" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="be398-152">Возвращает информацию, описывающую разрешения, предоставленные приложению, и то, имеет ли приложение уровень доверия, позволяющий ему выполняться.</span><span class="sxs-lookup"><span data-stu-id="be398-152">Gets information describing permissions granted to an application and whether the application has a trust level that allows it to run.</span></span></summary>
        <value><span data-ttu-id="be398-153">Объект, инкапсулирующий сведения о разрешениях и доверии для приложения в домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-153">An object that encapsulates permission and trust information for the application in the application domain.</span></span></value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="be398-154">Требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="be398-154">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="be398-155">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="be398-155">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ApplyPolicy">
      <MemberSignature Language="C#" Value="public string ApplyPolicy (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ApplyPolicy(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ApplyPolicy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyPolicy (assemblyName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ApplyPolicy(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.ApplyPolicy : string -&gt; string" Usage="appDomain.ApplyPolicy assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="be398-156">Отображаемое имя сборки в форме, заданной свойством <see cref="P:System.Reflection.Assembly.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-156">The assembly display name, in the form provided by the <see cref="P:System.Reflection.Assembly.FullName" /> property.</span></span></param>
        <summary><span data-ttu-id="be398-157">Возвращает отображаемое имя сборки после применения политики.</span><span class="sxs-lookup"><span data-stu-id="be398-157">Returns the assembly display name after policy has been applied.</span></span></summary>
        <returns><span data-ttu-id="be398-158">Строка, содержащая отображаемое имя сборки после применения политики.</span><span class="sxs-lookup"><span data-stu-id="be398-158">A string containing the assembly display name after policy has been applied.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-159"><xref:System.AppDomain.ApplyPolicy%2A> Метод принимает отображаемое имя сборки и возвращает отображаемое имя после применения политики.</span><span class="sxs-lookup"><span data-stu-id="be398-159">The <xref:System.AppDomain.ApplyPolicy%2A> method takes an assembly display name and returns the post-policy display name.</span></span> <span data-ttu-id="be398-160">Это полезно, если необходимо загрузить сборку с помощью политики, так как контекст только для отражения не применяет политику.</span><span class="sxs-lookup"><span data-stu-id="be398-160">This is useful if you need to load an assembly using policy, because the reflection-only context does not apply policy.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyLoad">
      <MemberSignature Language="C#" Value="public event AssemblyLoadEventHandler AssemblyLoad;" />
      <MemberSignature Language="ILAsm" Value=".event class System.AssemblyLoadEventHandler AssemblyLoad" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyLoad" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyLoad As AssemblyLoadEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event AssemblyLoadEventHandler ^ AssemblyLoad;" />
      <MemberSignature Language="F#" Value="member this.AssemblyLoad : AssemblyLoadEventHandler " Usage="member this.AssemblyLoad : System.AssemblyLoadEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyLoad</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AssemblyLoadEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="be398-161">происходит, когда загружена сборка.</span><span class="sxs-lookup"><span data-stu-id="be398-161">Occurs when an assembly is loaded.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-162">Делегат <xref:System.AssemblyLoadEventHandler> для этого события указывает, какая сборка была загружена.</span><span class="sxs-lookup"><span data-stu-id="be398-162">The <xref:System.AssemblyLoadEventHandler> delegate for this event indicates what assembly was loaded.</span></span>  
  
 <span data-ttu-id="be398-163">Чтобы зарегистрировать обработчик событий для этого события, необходимо иметь необходимые разрешения или <xref:System.Security.SecurityException> исключение.</span><span class="sxs-lookup"><span data-stu-id="be398-163">To register an event handler for this event, you must have the required permissions, or a <xref:System.Security.SecurityException> is thrown.</span></span>  
  
 <span data-ttu-id="be398-164">Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).</span><span class="sxs-lookup"><span data-stu-id="be398-164">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-165">В следующем примере демонстрируется <xref:System.AppDomain.AssemblyLoad> событие.</span><span class="sxs-lookup"><span data-stu-id="be398-165">The following sample demonstrates the <xref:System.AppDomain.AssemblyLoad> event.</span></span>  
  
 <span data-ttu-id="be398-166">Для выполнения этого примера кода необходимо указать полное имя сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-166">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="be398-167">Дополнительные сведения о получении полного имени сборки см. в разделе [имена сборок](~/docs/framework/app-domains/assembly-names.md).</span><span class="sxs-lookup"><span data-stu-id="be398-167">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_AssemblyLoad#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CPP/assemblyload.cpp#1)]
 [!code-csharp[AppDomain_AssemblyLoad#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CS/assemblyload.cs#1)]
 [!code-vb[AppDomain_AssemblyLoad#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_AssemblyLoad/VB/assemblyload.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="be398-168">Требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="be398-168">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="be398-169">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="be398-169">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="AssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler AssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler AssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ AssemblyResolve;" />
      <MemberSignature Language="F#" Value="member this.AssemblyResolve : ResolveEventHandler " Usage="member this.AssemblyResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="be398-170">Происходит, когда разрешение сборки завершается неудачей.</span><span class="sxs-lookup"><span data-stu-id="be398-170">Occurs when the resolution of an assembly fails.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-171">Для того <xref:System.ResolveEventHandler> , чтобы это событие возвращало сборку, указанную <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> свойством, или значение null, если сборка не распознается, она отвечает за это.</span><span class="sxs-lookup"><span data-stu-id="be398-171">It is the responsibility of the <xref:System.ResolveEventHandler> for this event to return the assembly that is specified by the <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> property, or to return null if the assembly is not recognized.</span></span> <span data-ttu-id="be398-172">Сборка должна быть загружена в контекст выполнения; при загрузке в контекст, предназначенный только для отражения, нагрузка, вызвавшая это событие, завершается ошибкой.</span><span class="sxs-lookup"><span data-stu-id="be398-172">The assembly must be loaded into an execution context; if it is loaded into the reflection-only context, the load that caused this event to be raised fails.</span></span>  
  
 <span data-ttu-id="be398-173">Рекомендации по использованию этого события см. в разделе [разрешение загрузки сборок](~/docs/framework/app-domains/resolve-assembly-loads.md).</span><span class="sxs-lookup"><span data-stu-id="be398-173">For guidance on the use of this event, see [Resolving Assembly Loads](~/docs/framework/app-domains/resolve-assembly-loads.md).</span></span>  
  
 <span data-ttu-id="be398-174">Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> , свойство возвращает сборку, которая запросила загрузку сборки, которую не удалось разрешить.</span><span class="sxs-lookup"><span data-stu-id="be398-174">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> property returns the assembly that requested the assembly load that could not be resolved.</span></span> <span data-ttu-id="be398-175">Например, загрузчику может быть невозможно загрузить зависимость запрашивающей сборки, так как запрашивающая сборка и ее зависимость не находятся в пути поиска.</span><span class="sxs-lookup"><span data-stu-id="be398-175">For example, the loader might be unable to load a dependency of the requesting assembly because the requesting assembly and its dependency are not in the probing path.</span></span> <span data-ttu-id="be398-176">Знание идентификации запрашивающей сборки может оказаться полезным при поиске зависимости или при определении правильной версии, если доступна более чем одна версия зависимости.</span><span class="sxs-lookup"><span data-stu-id="be398-176">Knowing the identity of the requesting assembly might be useful in locating the dependency or in identifying the correct version, if more than one version of the dependency is available.</span></span> <span data-ttu-id="be398-177">Для получения дополнительной информации см. <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="be398-177">For more information, see <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="be398-178">Начиная с [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] <xref:System.ResolveEventHandler> , событие вызывается для всех сборок, включая сборки ресурсов.</span><span class="sxs-lookup"><span data-stu-id="be398-178">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the <xref:System.ResolveEventHandler> event is raised for all assemblies, including resource assemblies.</span></span> <span data-ttu-id="be398-179">В более ранних версиях событие не было вызвано для сборок ресурсов.</span><span class="sxs-lookup"><span data-stu-id="be398-179">In earlier versions, the event was not raised for resource assemblies.</span></span> <span data-ttu-id="be398-180">Если операционная система локализована, обработчик может вызываться несколько раз: один раз для каждого языка и региональных параметров в цепочке резервов.</span><span class="sxs-lookup"><span data-stu-id="be398-180">If the operating system is localized, the handler might be called multiple times: once for each culture in the fallback chain.</span></span>  
  
 <span data-ttu-id="be398-181">Для этого события <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> свойство возвращает имя сборки перед применением политики.</span><span class="sxs-lookup"><span data-stu-id="be398-181">For this event, the <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> property returns the assembly name before policy is applied.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="be398-182">Если для этого события зарегистрировано более одного обработчика событий, обработчики событий вызываются по порядку, пока обработчик событий не вернет значение, `null`которое не является.</span><span class="sxs-lookup"><span data-stu-id="be398-182">If more than one event handler is registered for this event, the event handlers are called in order until an event handler returns a value that isn't `null`.</span></span> <span data-ttu-id="be398-183">Последующие обработчики событий игнорируются.</span><span class="sxs-lookup"><span data-stu-id="be398-183">Subsequent event handlers are ignored.</span></span>
  
 <span data-ttu-id="be398-184">Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).</span><span class="sxs-lookup"><span data-stu-id="be398-184">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-185">В следующем примере демонстрируется <xref:System.AppDomain.AssemblyResolve> событие.</span><span class="sxs-lookup"><span data-stu-id="be398-185">The following sample demonstrates the <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="be398-186">Для выполнения этого примера кода необходимо указать полное имя сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-186">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="be398-187">Дополнительные сведения о получении полного имени сборки см. в разделе [имена сборок](~/docs/framework/app-domains/assembly-names.md).</span><span class="sxs-lookup"><span data-stu-id="be398-187">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AssemblyResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyResolve/CPP/assemblyresolve.cpp#1)]
 [!code-csharp[AssemblyResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyResolve/CS/assemblyresolve.cs#1)]
 [!code-vb[AssemblyResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyResolve/VB/assemblyresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="be398-188">Требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="be398-188">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="be398-189">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="be398-189">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
        <related type="Article" href="https://msdn.microsoft.com/library/5099e549-f4fd-49fb-a290-549edd456c6a"><span data-ttu-id="be398-190">Разрешение загрузки сборок</span><span class="sxs-lookup"><span data-stu-id="be398-190">Resolving Assembly Loads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BaseDirectory">
      <MemberSignature Language="C#" Value="public string BaseDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.BaseDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ BaseDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseDirectory : string" Usage="System.AppDomain.BaseDirectory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.BaseDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="be398-191">Возвращает базовый каталог, в котором распознаватель сборок производит поиск.</span><span class="sxs-lookup"><span data-stu-id="be398-191">Gets the base directory that the assembly resolver uses to probe for assemblies.</span></span></summary>
        <value><span data-ttu-id="be398-192">Базовый каталог, в котором распознаватель сборок производит поиск.</span><span class="sxs-lookup"><span data-stu-id="be398-192">The base directory that the assembly resolver uses to probe for assemblies.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-193">Это свойство соответствует <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType> свойству.</span><span class="sxs-lookup"><span data-stu-id="be398-193">This property corresponds to the <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="be398-194">Его также можно получить с помощью <xref:System.AppDomain.GetData%2A> метода со строкой "AppBase".</span><span class="sxs-lookup"><span data-stu-id="be398-194">It can also be retrieved using the <xref:System.AppDomain.GetData%2A> method with the string "APPBASE".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-195">В следующем примере кода создается новый домен приложения с указанием базового каталога, который будет использоваться при поиске сборок для загрузки в домен.</span><span class="sxs-lookup"><span data-stu-id="be398-195">The following code example creates a new application domain, specifying a base directory to use when searching for assemblies to load into the domain.</span></span> <span data-ttu-id="be398-196">Затем в примере используется <xref:System.AppDomain.BaseDirectory%2A> свойство для получения пути к базовому каталогу для вывода на консоль.</span><span class="sxs-lookup"><span data-stu-id="be398-196">The example then uses the <xref:System.AppDomain.BaseDirectory%2A> property to obtain the base directory path, for display to the console.</span></span>  
  
 [!code-cpp[ADSetup#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetup/CPP/adsetup.cpp#1)]
 [!code-csharp[ADSetup#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetup/CS/adsetup.cs#1)]
 [!code-vb[ADSetup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetup/VB/adsetup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-197">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-197">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="be398-198">для доступа к сведениям в самом пути, в том числе если путь имеет формат "file://" или \\\унк\дир или "c:\\".</span><span class="sxs-lookup"><span data-stu-id="be398-198">for access to the information in the path itself, including if the path is in the form "file://" or \\\UNC\dir or "c:\\".</span></span> <span data-ttu-id="be398-199">Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="be398-199">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <altmember cref="P:System.AppDomainSetup.ApplicationBase" />
      </Docs>
    </Member>
    <Member MemberName="ClearPrivatePath">
      <MemberSignature Language="C#" Value="public void ClearPrivatePath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearPrivatePath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearPrivatePath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearPrivatePath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearPrivatePath();" />
      <MemberSignature Language="F#" Value="abstract member ClearPrivatePath : unit -&gt; unit&#xA;override this.ClearPrivatePath : unit -&gt; unit" Usage="appDomain.ClearPrivatePath " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearPrivatePath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="be398-200">Сбрасывает путь, указывающий на размещение закрытых сборок, присваивая ему пустую строку ("").</span><span class="sxs-lookup"><span data-stu-id="be398-200">Resets the path that specifies the location of private assemblies to the empty string ("").</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-201">Частный путь — это путь относительно базового каталога, который среда CLR ищет для поиска закрытых сборок.</span><span class="sxs-lookup"><span data-stu-id="be398-201">The private path is a path relative to the base directory that the common language runtime searches to locate private assemblies.</span></span>  
  
 <span data-ttu-id="be398-202">Для получения дополнительной информации см. <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="be398-202">For more information, see <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-203">В следующем примере кода показано, как использовать <xref:System.AppDomain.ClearPrivatePath%2A> метод для удаления всех записей из списка закрытых путей для поиска при загрузке сборок.</span><span class="sxs-lookup"><span data-stu-id="be398-203">The following code example demonstrates how to use the <xref:System.AppDomain.ClearPrivatePath%2A> method to remove all entries from the list of private paths to search when assemblies are loaded.</span></span>  
  
 <span data-ttu-id="be398-204">Теперь этот метод устарел и не должен использоваться для новой разработки.</span><span class="sxs-lookup"><span data-stu-id="be398-204">This method is now obsolete, and should not be used for new development.</span></span>  
  
 [!code-cpp[ADClearPrivatePath#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADClearPrivatePath/CPP/adclearprivatepath.cpp#1)]
 [!code-csharp[ADClearPrivatePath#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADClearPrivatePath/CS/adclearprivatepath.cs#1)]
 [!code-vb[ADClearPrivatePath#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADClearPrivatePath/VB/adclearprivatepath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-205">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-205">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="be398-206">Требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="be398-206">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="be398-207">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="be398-207">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="F:System.String.Empty" />
      </Docs>
    </Member>
    <Member MemberName="ClearShadowCopyPath">
      <MemberSignature Language="C#" Value="public void ClearShadowCopyPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearShadowCopyPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearShadowCopyPath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearShadowCopyPath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearShadowCopyPath();" />
      <MemberSignature Language="F#" Value="abstract member ClearShadowCopyPath : unit -&gt; unit&#xA;override this.ClearShadowCopyPath : unit -&gt; unit" Usage="appDomain.ClearShadowCopyPath " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearShadowCopyPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.ClearShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("AppDomain.ClearShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="be398-208">Сбрасывает список каталогов, содержащих теневые копии сборок, присваивая ему пустую строку ("").</span><span class="sxs-lookup"><span data-stu-id="be398-208">Resets the list of directories containing shadow copied assemblies to the empty string ("").</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-209">Путь к теневой копии представляет собой список каталогов, в которых хранятся теневые копии сборок.</span><span class="sxs-lookup"><span data-stu-id="be398-209">The shadow copy path is a list of directories where shadow copied assemblies are stored.</span></span>  
  
 <span data-ttu-id="be398-210">Дополнительные сведения см. в <xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType> разделе и [теневое копирование сборок](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span><span class="sxs-lookup"><span data-stu-id="be398-210">For more information, see <xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType> and [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-211">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-211">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="be398-212">Требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="be398-212">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="be398-213">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="be398-213">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="F:System.String.Empty" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md"><span data-ttu-id="be398-214">Теневое копирование сборок</span><span class="sxs-lookup"><span data-stu-id="be398-214">Shadow Copying Assemblies</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateComInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="be398-215">Создает новый экземпляр заданного типа COM.</span><span class="sxs-lookup"><span data-stu-id="be398-215">Creates a new instance of a specified COM type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateComInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateComInstanceFrom (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="be398-216">Имя файла, который содержит сборку, определяющую запрошенный тип.</span><span class="sxs-lookup"><span data-stu-id="be398-216">The name of a file containing an assembly that defines the requested type.</span></span></param>
        <param name="typeName"><span data-ttu-id="be398-217">Имя запрошенного типа.</span><span class="sxs-lookup"><span data-stu-id="be398-217">The name of the requested type.</span></span></param>
        <summary><span data-ttu-id="be398-218">Создает новый экземпляр заданного типа COM.</span><span class="sxs-lookup"><span data-stu-id="be398-218">Creates a new instance of a specified COM type.</span></span> <span data-ttu-id="be398-219">Параметры задают имя файла сборки, содержащей этот тип, и имя типа.</span><span class="sxs-lookup"><span data-stu-id="be398-219">Parameters specify the name of a file that contains an assembly containing the type and the name of the type.</span></span></summary>
        <returns><span data-ttu-id="be398-220">Объект, являющийся оболочкой для нового экземпляра, заданного параметром <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-220">An object that is a wrapper for the new instance specified by <paramref name="typeName" />.</span></span> <span data-ttu-id="be398-221">Необходимо распаковать возвращенное значение, чтобы получить доступ к реальному объекту.</span><span class="sxs-lookup"><span data-stu-id="be398-221">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-222">Используйте этот метод для удаленного создания объектов без необходимости загрузки типа локально.</span><span class="sxs-lookup"><span data-stu-id="be398-222">Use this method to create objects remotely without having to load the type locally.</span></span>  
  
 <span data-ttu-id="be398-223">Чтобы получить доступ к реальному объекту, возвращаемое значение должно быть распаковано.</span><span class="sxs-lookup"><span data-stu-id="be398-223">The return value must to be unwrapped to access the real object.</span></span>  
  
 <span data-ttu-id="be398-224">Атрибут со значением должен применяться явно или по умолчанию к типу com, чтобы этот метод создавал экземпляр <xref:System.TypeLoadException> этого типа. в противном случае создается исключение. `true` <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="be398-224">A <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> attribute with a value of `true` must be applied either explicitly or by default to the COM type for this method to create an instance of that type; otherwise, <xref:System.TypeLoadException> is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-225">В следующем примере демонстрируется</span><span class="sxs-lookup"><span data-stu-id="be398-225">The following sample demonstrates</span></span>  
  
 [!code-cpp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CPP/createcominstancefrom.cpp#1)]
 [!code-csharp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CS/createcominstancefrom.cs#1)]
 [!code-vb[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/VB/createcominstancefrom.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-226">Параметр <paramref name="assemblyName" /> или <paramref name="typeName" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-226"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="be398-227">Невозможно загрузить тип.</span><span class="sxs-lookup"><span data-stu-id="be398-227">The type cannot be loaded.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-228">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-228">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="be398-229">Открытый конструктор без параметров не найден.</span><span class="sxs-lookup"><span data-stu-id="be398-229">No public parameterless constructor was found.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="be398-230"><paramref name="assemblyName" /> не найден.</span><span class="sxs-lookup"><span data-stu-id="be398-230"><paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="be398-231">Класс <paramref name="typeName" /> является абстрактным.</span><span class="sxs-lookup"><span data-stu-id="be398-231"><paramref name="typeName" /> is an abstract class.</span></span>  
  
<span data-ttu-id="be398-232">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-232">-or-</span></span> 
<span data-ttu-id="be398-233">Этот элемент был вызван при помощи механизма позднего связывания.</span><span class="sxs-lookup"><span data-stu-id="be398-233">This member was invoked with a late-binding mechanism.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="be398-234">Вызывающий объект не может предоставить атрибуты активации для объекта, который не является производным от <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="be398-234">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be398-235">Параметр <paramref name="assemblyName" /> является пустой строкой ("").</span><span class="sxs-lookup"><span data-stu-id="be398-235"><paramref name="assemblyName" /> is an empty string ("").</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="be398-236"><paramref name="assemblyName" /> не является допустимой сборкой.</span><span class="sxs-lookup"><span data-stu-id="be398-236"><paramref name="assemblyName" /> is not a valid assembly.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="be398-237">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</span><span class="sxs-lookup"><span data-stu-id="be398-237">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="be398-238">Указанный объект COM равен <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-238">The COM object that is being referred to is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="be398-239">для возможности чтения файла, содержащего манифест сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-239">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="be398-240">Связанное перечисление:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="be398-240">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="be398-241">значение для возможности доступа к расположению сборки, если сборка не является локальной.</span><span class="sxs-lookup"><span data-stu-id="be398-241">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyFile, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyFile, string typeName, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyFile As String, typeName As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.CreateComInstanceFrom : string * string * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateComInstanceFrom (assemblyFile, typeName, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="hashValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="be398-242">Имя файла, который содержит сборку, определяющую запрошенный тип.</span><span class="sxs-lookup"><span data-stu-id="be398-242">The name of a file containing an assembly that defines the requested type.</span></span></param>
        <param name="typeName"><span data-ttu-id="be398-243">Имя запрошенного типа.</span><span class="sxs-lookup"><span data-stu-id="be398-243">The name of the requested type.</span></span></param>
        <param name="hashValue"><span data-ttu-id="be398-244">Представляет значение вычисленного хэш-кода.</span><span class="sxs-lookup"><span data-stu-id="be398-244">Represents the value of the computed hash code.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="be398-245">Представляет хэш-алгоритм, используемый манифестом сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-245">Represents the hash algorithm used by the assembly manifest.</span></span></param>
        <summary><span data-ttu-id="be398-246">Создает новый экземпляр заданного типа COM.</span><span class="sxs-lookup"><span data-stu-id="be398-246">Creates a new instance of a specified COM type.</span></span> <span data-ttu-id="be398-247">Параметры задают имя файла сборки, содержащей этот тип, и имя типа.</span><span class="sxs-lookup"><span data-stu-id="be398-247">Parameters specify the name of a file that contains an assembly containing the type and the name of the type.</span></span></summary>
        <returns><span data-ttu-id="be398-248">Объект, являющийся оболочкой для нового экземпляра, заданного параметром <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-248">An object that is a wrapper for the new instance specified by <paramref name="typeName" />.</span></span> <span data-ttu-id="be398-249">Необходимо распаковать возвращенное значение, чтобы получить доступ к реальному объекту.</span><span class="sxs-lookup"><span data-stu-id="be398-249">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-250">Используйте этот метод для удаленного создания объектов без необходимости загрузки типа локально.</span><span class="sxs-lookup"><span data-stu-id="be398-250">Use this method to create objects remotely without having to load the type locally.</span></span>  
  
 <span data-ttu-id="be398-251">Чтобы получить доступ к реальному объекту, возвращаемое значение должно быть распаковано.</span><span class="sxs-lookup"><span data-stu-id="be398-251">The return value must to be unwrapped to access the real object.</span></span>  
  
 <span data-ttu-id="be398-252">Атрибут со значением должен применяться явно или по умолчанию к типу com, чтобы этот метод создавал экземпляр <xref:System.TypeLoadException> этого типа. в противном случае создается исключение. `true` <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="be398-252">A <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> attribute with a value of `true` must be applied either explicitly or by default to the COM type for this method to create an instance of that type; otherwise, <xref:System.TypeLoadException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-253">Значение параметра <paramref name="assemblyName" /> или <paramref name="typeName" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-253"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="be398-254">Невозможно загрузить тип.</span><span class="sxs-lookup"><span data-stu-id="be398-254">The type cannot be loaded.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-255">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-255">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="be398-256">Открытый конструктор без параметров не найден.</span><span class="sxs-lookup"><span data-stu-id="be398-256">No public parameterless constructor was found.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="be398-257"><paramref name="assemblyFile" /> не найден.</span><span class="sxs-lookup"><span data-stu-id="be398-257"><paramref name="assemblyFile" /> is not found.</span></span></exception>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="be398-258">Класс <paramref name="typeName" /> является абстрактным.</span><span class="sxs-lookup"><span data-stu-id="be398-258"><paramref name="typeName" /> is an abstract class.</span></span>  
  
<span data-ttu-id="be398-259">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-259">-or-</span></span> 
<span data-ttu-id="be398-260">Этот элемент был вызван при помощи механизма позднего связывания.</span><span class="sxs-lookup"><span data-stu-id="be398-260">This member was invoked with a late-binding mechanism.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="be398-261">Вызывающий объект не может предоставить атрибуты активации для объекта, который не является производным от <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="be398-261">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be398-262"><paramref name="assemblyFile" /> является пустой строкой ("").</span><span class="sxs-lookup"><span data-stu-id="be398-262"><paramref name="assemblyFile" /> is the empty string ("").</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="be398-263"><paramref name="assemblyFile" /> не является допустимой сборкой.</span><span class="sxs-lookup"><span data-stu-id="be398-263"><paramref name="assemblyFile" /> is not a valid assembly.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="be398-264">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</span><span class="sxs-lookup"><span data-stu-id="be398-264">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="be398-265">Указанный объект COM равен <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-265">The COM object that is being referred to is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="be398-266">для возможности чтения файла, содержащего манифест сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-266">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="be398-267">Связанное перечисление:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="be398-267">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="be398-268">значение для возможности доступа к расположению сборки, если сборка не является локальной.</span><span class="sxs-lookup"><span data-stu-id="be398-268">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDomain">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="be398-269">Создает новый домен приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-269">Creates a new application domain.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string -&gt; AppDomain" Usage="System.AppDomain.CreateDomain friendlyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="friendlyName"><span data-ttu-id="be398-270">Понятное имя домена.</span><span class="sxs-lookup"><span data-stu-id="be398-270">The friendly name of the domain.</span></span></param>
        <summary><span data-ttu-id="be398-271">Создает новый домен приложения с заданным именем.</span><span class="sxs-lookup"><span data-stu-id="be398-271">Creates a new application domain with the specified name.</span></span></summary>
        <returns><span data-ttu-id="be398-272">Вновь созданный домен приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-272">The newly created application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-273">`friendlyName` Параметр предназначен для однозначного обнаружения домена, который имеет смысл для человека.</span><span class="sxs-lookup"><span data-stu-id="be398-273">The `friendlyName` parameter is intended to identify the domain in a manner that is meaningful to humans.</span></span> <span data-ttu-id="be398-274">Эта строка должна быть подходящей для вывода в пользовательских интерфейсах.</span><span class="sxs-lookup"><span data-stu-id="be398-274">This string should be suitable for display in user interfaces.</span></span>  
  
 <span data-ttu-id="be398-275">Эта перегрузка метода использует <xref:System.AppDomainSetup> сведения из домена приложения по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="be398-275">This method overload uses the <xref:System.AppDomainSetup> information from the default application domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-276">В следующем примере показано, как создать домен, используя одну из <xref:System.AppDomain.CreateDomain%2A> перегрузок.</span><span class="sxs-lookup"><span data-stu-id="be398-276">The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.</span></span>  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-277">Свойство <paramref name="friendlyName" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-277"><paramref name="friendlyName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="be398-278">Метод не поддерживается в .NET Core.</span><span class="sxs-lookup"><span data-stu-id="be398-278">Method not supported on .NET Core.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="be398-279">для предоставления свидетельства.</span><span class="sxs-lookup"><span data-stu-id="be398-279">to provide evidence.</span></span> <span data-ttu-id="be398-280">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="be398-280">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <altmember cref="P:System.AppDomain.FriendlyName" />
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="friendlyName"><span data-ttu-id="be398-281">Понятное имя домена.</span><span class="sxs-lookup"><span data-stu-id="be398-281">The friendly name of the domain.</span></span> <span data-ttu-id="be398-282">Это понятное имя может отображаться в пользовательском интерфейсе для определения домена.</span><span class="sxs-lookup"><span data-stu-id="be398-282">This friendly name can be displayed in user interfaces to identify the domain.</span></span> <span data-ttu-id="be398-283">Для получения дополнительной информации см. <see cref="P:System.AppDomain.FriendlyName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-283">For more information, see <see cref="P:System.AppDomain.FriendlyName" />.</span></span></param>
        <param name="securityInfo"><span data-ttu-id="be398-284">Свидетельство, идентифицирующее код, который выполняется в домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-284">Evidence that establishes the identity of the code that runs in the application domain.</span></span> <span data-ttu-id="be398-285">Передайте значение <see langword="null" /> для использования свидетельства текущего домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-285">Pass <see langword="null" /> to use the evidence of the current application domain.</span></span></param>
        <summary><span data-ttu-id="be398-286">Создает новый домен приложения с заданным именем с помощью предоставленного свидетельства.</span><span class="sxs-lookup"><span data-stu-id="be398-286">Creates a new application domain with the given name using the supplied evidence.</span></span></summary>
        <returns><span data-ttu-id="be398-287">Вновь созданный домен приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-287">The newly created application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-288">Эта перегрузка метода использует <xref:System.AppDomainSetup> сведения из домена приложения по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="be398-288">This method overload uses the <xref:System.AppDomainSetup> information from the default application domain.</span></span>  
  
 <span data-ttu-id="be398-289">Если `securityInfo` аргумент не указан, используется свидетельство из текущего домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-289">If `securityInfo` is not supplied, the evidence from the current application domain is used.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="be398-290">Не используйте эту перегрузку метода для создания изолированных доменов приложений.</span><span class="sxs-lookup"><span data-stu-id="be398-290">Do not use this method overload to create sandboxed application domains.</span></span> <span data-ttu-id="be398-291">Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], свидетельство, передаваемое для `securityInfo` , больше не влияет на набор прав домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-291">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain.</span></span> <span data-ttu-id="be398-292">Используйте перегрузку <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> метода для создания доменов изолированных приложений.</span><span class="sxs-lookup"><span data-stu-id="be398-292">Use the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> method overload to create sandboxed application domains.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-293">В следующем примере показано, как создать домен, используя одну из <xref:System.AppDomain.CreateDomain%2A> перегрузок.</span><span class="sxs-lookup"><span data-stu-id="be398-293">The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.</span></span>  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-294">Свойство <paramref name="friendlyName" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-294"><paramref name="friendlyName" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="be398-295">для предоставления свидетельства.</span><span class="sxs-lookup"><span data-stu-id="be398-295">to provide evidence.</span></span> <span data-ttu-id="be398-296">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="be398-296">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * AppDomainSetup -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, info)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="info" Type="System.AppDomainSetup" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="friendlyName"><span data-ttu-id="be398-297">Понятное имя домена.</span><span class="sxs-lookup"><span data-stu-id="be398-297">The friendly name of the domain.</span></span> <span data-ttu-id="be398-298">Это понятное имя может отображаться в пользовательском интерфейсе для определения домена.</span><span class="sxs-lookup"><span data-stu-id="be398-298">This friendly name can be displayed in user interfaces to identify the domain.</span></span> <span data-ttu-id="be398-299">Для получения дополнительной информации см. <see cref="P:System.AppDomain.FriendlyName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-299">For more information, see <see cref="P:System.AppDomain.FriendlyName" />.</span></span></param>
        <param name="securityInfo"><span data-ttu-id="be398-300">Свидетельство, идентифицирующее код, который выполняется в домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-300">Evidence that establishes the identity of the code that runs in the application domain.</span></span> <span data-ttu-id="be398-301">Передайте значение <see langword="null" /> для использования свидетельства текущего домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-301">Pass <see langword="null" /> to use the evidence of the current application domain.</span></span></param>
        <param name="info"><span data-ttu-id="be398-302">Объект, в котором содержатся сведения об инициализации домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-302">An object that contains application domain initialization information.</span></span></param>
        <summary><span data-ttu-id="be398-303">Создает новый домен приложения с использованием заданного имени, свидетельства и сведений об установке домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-303">Creates a new application domain using the specified name, evidence, and application domain setup information.</span></span></summary>
        <returns><span data-ttu-id="be398-304">Вновь созданный домен приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-304">The newly created application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-305">Если `info` не указан, эта перегрузка метода <xref:System.AppDomainSetup> использует сведения из домена приложения по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="be398-305">If `info` is not supplied, this method overload uses the <xref:System.AppDomainSetup> information from the default application domain.</span></span>  
  
 <span data-ttu-id="be398-306">Если `securityInfo` аргумент не указан, используется свидетельство из текущего домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-306">If `securityInfo` is not supplied, the evidence from the current application domain is used.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="be398-307">Не используйте эту перегрузку метода для создания изолированных доменов приложений.</span><span class="sxs-lookup"><span data-stu-id="be398-307">Do not use this method overload to create sandboxed application domains.</span></span> <span data-ttu-id="be398-308">Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], свидетельство, передаваемое для `securityInfo` , больше не влияет на набор прав домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-308">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain.</span></span> <span data-ttu-id="be398-309">Используйте перегрузку <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> метода для создания доменов изолированных приложений.</span><span class="sxs-lookup"><span data-stu-id="be398-309">Use the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> method overload to create sandboxed application domains.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-310">В следующем примере показано, как создать домен, используя одну из <xref:System.AppDomain.CreateDomain%2A> перегрузок.</span><span class="sxs-lookup"><span data-stu-id="be398-310">The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.</span></span>  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-311">Свойство <paramref name="friendlyName" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-311"><paramref name="friendlyName" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="be398-312">для предоставления свидетельства.</span><span class="sxs-lookup"><span data-stu-id="be398-312">to provide evidence.</span></span> <span data-ttu-id="be398-313">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="be398-313">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info, System.Security.PermissionSet grantSet, params System.Security.Policy.StrongName[] fullTrustAssemblies);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info, class System.Security.PermissionSet grantSet, class System.Security.Policy.StrongName[] fullTrustAssemblies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup, grantSet As PermissionSet, ParamArray fullTrustAssemblies As StrongName()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info, System::Security::PermissionSet ^ grantSet, ... cli::array &lt;System::Security::Policy::StrongName ^&gt; ^ fullTrustAssemblies);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * AppDomainSetup * System.Security.PermissionSet * System.Security.Policy.StrongName[] -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, info, grantSet, fullTrustAssemblies)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="info" Type="System.AppDomainSetup" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="grantSet" Type="System.Security.PermissionSet" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="fullTrustAssemblies" Type="System.Security.Policy.StrongName[]" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="friendlyName"><span data-ttu-id="be398-314">Понятное имя домена.</span><span class="sxs-lookup"><span data-stu-id="be398-314">The friendly name of the domain.</span></span> <span data-ttu-id="be398-315">Это понятное имя может отображаться в пользовательском интерфейсе для определения домена.</span><span class="sxs-lookup"><span data-stu-id="be398-315">This friendly name can be displayed in user interfaces to identify the domain.</span></span> <span data-ttu-id="be398-316">Дополнительные сведения см. в описании <see cref="P:System.AppDomain.FriendlyName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-316">For more information, see the description of <see cref="P:System.AppDomain.FriendlyName" />.</span></span></param>
        <param name="securityInfo"><span data-ttu-id="be398-317">Свидетельство, идентифицирующее код, который выполняется в домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-317">Evidence that establishes the identity of the code that runs in the application domain.</span></span> <span data-ttu-id="be398-318">Передайте значение <see langword="null" /> для использования свидетельства текущего домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-318">Pass <see langword="null" /> to use the evidence of the current application domain.</span></span></param>
        <param name="info"><span data-ttu-id="be398-319">Объект, в котором содержатся сведения об инициализации домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-319">An object that contains application domain initialization information.</span></span></param>
        <param name="grantSet"><span data-ttu-id="be398-320">Используемый по умолчанию набор разрешений, которые предоставляются всем сборкам, загружаемым в новый домен приложения, не имеющих специальных разрешений.</span><span class="sxs-lookup"><span data-stu-id="be398-320">A default permission set that is granted to all assemblies loaded into the new application domain that do not have specific grants.</span></span></param>
        <param name="fullTrustAssemblies"><span data-ttu-id="be398-321">Массив строгих имен, представляющих сборки, которые будут считаться обладающими полным доверием в новом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-321">An array of strong names representing assemblies to be considered fully trusted in the new application domain.</span></span></param>
        <summary><span data-ttu-id="be398-322">Создает новый домен приложения с использованием заданного имени, свидетельства, сведений об установке домена приложения, используемого по умолчанию набора разрешений и массива сборок с полным доверием.</span><span class="sxs-lookup"><span data-stu-id="be398-322">Creates a new application domain using the specified name, evidence, application domain setup information, default permission set, and array of fully trusted assemblies.</span></span></summary>
        <returns><span data-ttu-id="be398-323">Вновь созданный домен приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-323">The newly created application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-324">Необходимо задать <xref:System.AppDomainSetup.ApplicationBase%2A> свойство <xref:System.AppDomainSetup> объекта, предоставляемого для `info`.</span><span class="sxs-lookup"><span data-stu-id="be398-324">You must set the <xref:System.AppDomainSetup.ApplicationBase%2A> property of the <xref:System.AppDomainSetup> object that you supply for `info`.</span></span> <span data-ttu-id="be398-325">В противном случае создается исключение.</span><span class="sxs-lookup"><span data-stu-id="be398-325">Otherwise, an exception is thrown.</span></span>  
  
 <span data-ttu-id="be398-326">Если `securityInfo` аргумент не указан, используется свидетельство из текущего домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-326">If `securityInfo` is not supplied, the evidence from the current application domain is used.</span></span>  
  
 <span data-ttu-id="be398-327">Сведения, предоставленные `grantSet` для `fullTrustAssemblies` и <xref:System.Security.Policy.ApplicationTrust> , используются для создания объекта для нового домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-327">The information provided for `grantSet` and `fullTrustAssemblies` is used to create an <xref:System.Security.Policy.ApplicationTrust> object for the new application domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-328">Свойство <paramref name="friendlyName" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-328"><paramref name="friendlyName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="be398-329">Домен приложения равен <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-329">The application domain is <see langword="null" />.</span></span>  
  
<span data-ttu-id="be398-330">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-330">-or-</span></span> 
<span data-ttu-id="be398-331">Свойство <see cref="P:System.AppDomainSetup.ApplicationBase" /> не задано в объекте <see cref="T:System.AppDomainSetup" />, который предоставляется для <paramref name="info" />.</span><span class="sxs-lookup"><span data-stu-id="be398-331">The <see cref="P:System.AppDomainSetup.ApplicationBase" /> property is not set on the <see cref="T:System.AppDomainSetup" /> object that is supplied for <paramref name="info" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="be398-332">возможность создания домена приложения и управления им.</span><span class="sxs-lookup"><span data-stu-id="be398-332">for the ability to create and manipulate an application domain.</span></span> <span data-ttu-id="be398-333">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />.</span><span class="sxs-lookup"><span data-stu-id="be398-333">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />.</span></span> <span data-ttu-id="be398-334">Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span><span class="sxs-lookup"><span data-stu-id="be398-334">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * string * string * bool -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, appBasePath, appRelativeSearchPath, shadowCopyFiles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="appBasePath" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="friendlyName"><span data-ttu-id="be398-335">Понятное имя домена.</span><span class="sxs-lookup"><span data-stu-id="be398-335">The friendly name of the domain.</span></span> <span data-ttu-id="be398-336">Это понятное имя может отображаться в пользовательском интерфейсе для определения домена.</span><span class="sxs-lookup"><span data-stu-id="be398-336">This friendly name can be displayed in user interfaces to identify the domain.</span></span> <span data-ttu-id="be398-337">Для получения дополнительной информации см. <see cref="P:System.AppDomain.FriendlyName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-337">For more information, see <see cref="P:System.AppDomain.FriendlyName" />.</span></span></param>
        <param name="securityInfo"><span data-ttu-id="be398-338">Свидетельство, идентифицирующее код, который выполняется в домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-338">Evidence that establishes the identity of the code that runs in the application domain.</span></span> <span data-ttu-id="be398-339">Передайте значение <see langword="null" /> для использования свидетельства текущего домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-339">Pass <see langword="null" /> to use the evidence of the current application domain.</span></span></param>
        <param name="appBasePath"><span data-ttu-id="be398-340">Базовый каталог, в котором распознаватель сборок производит поиск.</span><span class="sxs-lookup"><span data-stu-id="be398-340">The base directory that the assembly resolver uses to probe for assemblies.</span></span> <span data-ttu-id="be398-341">Для получения дополнительной информации см. <see cref="P:System.AppDomain.BaseDirectory" />.</span><span class="sxs-lookup"><span data-stu-id="be398-341">For more information, see <see cref="P:System.AppDomain.BaseDirectory" />.</span></span></param>
        <param name="appRelativeSearchPath"><span data-ttu-id="be398-342">Путь, соответствующий базовому каталогу, в котором распознаватель сборок будет производить поиск закрытых сборок.</span><span class="sxs-lookup"><span data-stu-id="be398-342">The path relative to the base directory where the assembly resolver should probe for private assemblies.</span></span> <span data-ttu-id="be398-343">Для получения дополнительной информации см. <see cref="P:System.AppDomain.RelativeSearchPath" />.</span><span class="sxs-lookup"><span data-stu-id="be398-343">For more information, see <see cref="P:System.AppDomain.RelativeSearchPath" />.</span></span></param>
        <param name="shadowCopyFiles"><span data-ttu-id="be398-344">Если <see langword="true" />, теневая копия сборки загружается в этот домен приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-344">If <see langword="true" />, a shadow copy of an assembly is loaded into this application domain.</span></span></param>
        <summary><span data-ttu-id="be398-345">Создает новый домен приложения с заданным именем с использованием свидетельства, пути к базовой папке приложения, относительного пути поиска и параметра, указывающего, должна ли загружаться теневая копия сборки в домен приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-345">Creates a new application domain with the given name, using evidence, application base path, relative search path, and a parameter that specifies whether a shadow copy of an assembly is to be loaded into the application domain.</span></span></summary>
        <returns><span data-ttu-id="be398-346">Вновь созданный домен приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-346">The newly created application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-347">Если `securityInfo` аргумент не указан, используется свидетельство из текущего домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-347">If `securityInfo` is not supplied, the evidence from the current application domain is used.</span></span>  
  
 <span data-ttu-id="be398-348">Дополнительные сведения о теневом копировании см <xref:System.AppDomain.ShadowCopyFiles%2A> . в разделе и [теневое копирование сборок](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span><span class="sxs-lookup"><span data-stu-id="be398-348">For more information about shadow copying, see <xref:System.AppDomain.ShadowCopyFiles%2A> and [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="be398-349">Не используйте эту перегрузку метода для создания изолированных доменов приложений.</span><span class="sxs-lookup"><span data-stu-id="be398-349">Do not use this method overload to create sandboxed application domains.</span></span> <span data-ttu-id="be398-350">Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], свидетельство, передаваемое для `securityInfo` , больше не влияет на набор прав домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-350">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain.</span></span> <span data-ttu-id="be398-351">Используйте перегрузку <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> метода для создания доменов изолированных приложений.</span><span class="sxs-lookup"><span data-stu-id="be398-351">Use the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> method overload to create sandboxed application domains.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-352">В следующем примере показано, как создать домен, используя одну из <xref:System.AppDomain.CreateDomain%2A> перегрузок.</span><span class="sxs-lookup"><span data-stu-id="be398-352">The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.</span></span>  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-353">Свойство <paramref name="friendlyName" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-353"><paramref name="friendlyName" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="be398-354">для предоставления свидетельства.</span><span class="sxs-lookup"><span data-stu-id="be398-354">to provide evidence.</span></span> <span data-ttu-id="be398-355">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="be398-355">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer adInit, string[] adInitArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, class System.AppDomainInitializer adInit, string[] adInitArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean, adInit As AppDomainInitializer, adInitArgs As String()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer ^ adInit, cli::array &lt;System::String ^&gt; ^ adInitArgs);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * string * string * bool * AppDomainInitializer * string[] -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, appBasePath, appRelativeSearchPath, shadowCopyFiles, adInit, adInitArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="appBasePath" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="adInit" Type="System.AppDomainInitializer" Index="5" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="adInitArgs" Type="System.String[]" Index="6" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="friendlyName"><span data-ttu-id="be398-356">Понятное имя домена.</span><span class="sxs-lookup"><span data-stu-id="be398-356">The friendly name of the domain.</span></span> <span data-ttu-id="be398-357">Это понятное имя может отображаться в пользовательском интерфейсе для определения домена.</span><span class="sxs-lookup"><span data-stu-id="be398-357">This friendly name can be displayed in user interfaces to identify the domain.</span></span> <span data-ttu-id="be398-358">Для получения дополнительной информации см. <see cref="P:System.AppDomain.FriendlyName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-358">For more information, see <see cref="P:System.AppDomain.FriendlyName" />.</span></span></param>
        <param name="securityInfo"><span data-ttu-id="be398-359">Свидетельство, идентифицирующее код, который выполняется в домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-359">Evidence that establishes the identity of the code that runs in the application domain.</span></span> <span data-ttu-id="be398-360">Передайте значение <see langword="null" /> для использования свидетельства текущего домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-360">Pass <see langword="null" /> to use the evidence of the current application domain.</span></span></param>
        <param name="appBasePath"><span data-ttu-id="be398-361">Базовый каталог, в котором распознаватель сборок производит поиск.</span><span class="sxs-lookup"><span data-stu-id="be398-361">The base directory that the assembly resolver uses to probe for assemblies.</span></span> <span data-ttu-id="be398-362">Для получения дополнительной информации см. <see cref="P:System.AppDomain.BaseDirectory" />.</span><span class="sxs-lookup"><span data-stu-id="be398-362">For more information, see <see cref="P:System.AppDomain.BaseDirectory" />.</span></span></param>
        <param name="appRelativeSearchPath"><span data-ttu-id="be398-363">Путь, соответствующий базовому каталогу, в котором распознаватель сборок будет производить поиск закрытых сборок.</span><span class="sxs-lookup"><span data-stu-id="be398-363">The path relative to the base directory where the assembly resolver should probe for private assemblies.</span></span> <span data-ttu-id="be398-364">Для получения дополнительной информации см. <see cref="P:System.AppDomain.RelativeSearchPath" />.</span><span class="sxs-lookup"><span data-stu-id="be398-364">For more information, see <see cref="P:System.AppDomain.RelativeSearchPath" />.</span></span></param>
        <param name="shadowCopyFiles"><span data-ttu-id="be398-365">Значение <see langword="true" /> для загрузки теневой копии сборки в этот домен приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-365"><see langword="true" /> to load a shadow copy of an assembly into the application domain.</span></span></param>
        <param name="adInit"><span data-ttu-id="be398-366">Делегат <see cref="T:System.AppDomainInitializer" />, представляющий метод обратного вызова, вызываемый при инициализации нового объекта <see cref="T:System.AppDomain" />.</span><span class="sxs-lookup"><span data-stu-id="be398-366">An <see cref="T:System.AppDomainInitializer" /> delegate that represents a callback method to invoke when the new <see cref="T:System.AppDomain" /> object is initialized.</span></span></param>
        <param name="adInitArgs"><span data-ttu-id="be398-367">Массив строковых аргументов, передаваемый методу обратного вызова, представленному объектом <paramref name="adInit" />, когда инициализируется новый объект <see cref="T:System.AppDomain" />.</span><span class="sxs-lookup"><span data-stu-id="be398-367">An array of string arguments to be passed to the callback represented by <paramref name="adInit" />, when the new <see cref="T:System.AppDomain" /> object is initialized.</span></span></param>
        <summary><span data-ttu-id="be398-368">Создает новый домен приложения с заданным именем с использованием свидетельства, пути к базовой папке приложения, относительного пути поиска и параметра, указывающего, должна ли загружаться теневая копия сборки в домен приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-368">Creates a new application domain with the given name, using evidence, application base path, relative search path, and a parameter that specifies whether a shadow copy of an assembly is to be loaded into the application domain.</span></span> <span data-ttu-id="be398-369">Задает метод обратного вызова, вызываемый, когда инициализируется домен приложения, и массив строковых аргументов для передачи методу обратного вызова.</span><span class="sxs-lookup"><span data-stu-id="be398-369">Specifies a callback method that is invoked when the application domain is initialized, and an array of string arguments to pass the callback method.</span></span></summary>
        <returns><span data-ttu-id="be398-370">Вновь созданный домен приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-370">The newly created application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-371">Метод, представленный `adInit` , выполняется в контексте только что созданного домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-371">The method represented by `adInit` is executed in the context of the newly created application domain.</span></span>  
  
 <span data-ttu-id="be398-372">Если `securityInfo` аргумент не указан, используется свидетельство из текущего домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-372">If `securityInfo` is not supplied, the evidence from the current application domain is used.</span></span>  
  
 <span data-ttu-id="be398-373">Дополнительные сведения о теневом копировании см <xref:System.AppDomain.ShadowCopyFiles%2A> . в разделе и [теневое копирование сборок](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span><span class="sxs-lookup"><span data-stu-id="be398-373">For more information about shadow copying, see <xref:System.AppDomain.ShadowCopyFiles%2A> and [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="be398-374">Не используйте эту перегрузку метода для создания изолированных доменов приложений.</span><span class="sxs-lookup"><span data-stu-id="be398-374">Do not use this method overload to create sandboxed application domains.</span></span> <span data-ttu-id="be398-375">Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], свидетельство, передаваемое для `securityInfo` , больше не влияет на набор прав домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-375">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain.</span></span> <span data-ttu-id="be398-376">Используйте перегрузку <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> метода для создания доменов изолированных приложений.</span><span class="sxs-lookup"><span data-stu-id="be398-376">Use the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> method overload to create sandboxed application domains.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-377">Свойство <paramref name="friendlyName" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-377"><paramref name="friendlyName" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="be398-378">для предоставления свидетельства.</span><span class="sxs-lookup"><span data-stu-id="be398-378">to provide evidence.</span></span> <span data-ttu-id="be398-379">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="be398-379">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="be398-380">Создает новый экземпляр заданного типа, определенного в указанной сборке.</span><span class="sxs-lookup"><span data-stu-id="be398-380">Creates a new instance of a specified type defined in a specified assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="be398-381">Отображаемое имя сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-381">The display name of the assembly.</span></span> <span data-ttu-id="be398-382">См. раздел <see cref="P:System.Reflection.Assembly.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-382">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="be398-383">Полное имя запрошенного типа, включая пространство имен, но не сборку (см. описание свойства <see cref="P:System.Type.FullName" />).</span><span class="sxs-lookup"><span data-stu-id="be398-383">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <summary><span data-ttu-id="be398-384">Создает новый экземпляр заданного типа, определенного в указанной сборке.</span><span class="sxs-lookup"><span data-stu-id="be398-384">Creates a new instance of the specified type defined in the specified assembly.</span></span></summary>
        <returns><span data-ttu-id="be398-385">Объект, являющийся оболочкой для нового экземпляра, заданного параметром <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-385">An object that is a wrapper for the new instance specified by <paramref name="typeName" />.</span></span> <span data-ttu-id="be398-386">Необходимо распаковать возвращенное значение, чтобы получить доступ к реальному объекту.</span><span class="sxs-lookup"><span data-stu-id="be398-386">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-387">Этот метод вызывает конструктор без параметров для `typeName`.</span><span class="sxs-lookup"><span data-stu-id="be398-387">This method calls the parameterless constructor for `typeName`.</span></span>  
  
 <span data-ttu-id="be398-388">См <xref:System.Reflection.AssemblyName> `assemblyName`. раздел для формата.</span><span class="sxs-lookup"><span data-stu-id="be398-388">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span>  
  
 <span data-ttu-id="be398-389">Попытка вызова <xref:System.AppDomain.CreateInstance%2A> в домене целевого приложения, который не является текущим доменом приложения, приведет к успешной загрузке сборки в целевом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-389">An attempt to call <xref:System.AppDomain.CreateInstance%2A> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain.</span></span> <span data-ttu-id="be398-390">Поскольку не <xref:System.Reflection.Assembly> <xref:System.MarshalByRefObject>имеет значения <xref:System.Reflection.Assembly>  , когда этот метод пытается вернуть для загруженной сборки в текущий домен приложения, среда CLR пытается загрузить сборку в текущий домен приложения, а может произойти сбой загрузки.</span><span class="sxs-lookup"><span data-stu-id="be398-390">Since an <xref:System.Reflection.Assembly> is not <xref:System.MarshalByRefObject>, when this method attempts to return the <xref:System.Reflection.Assembly> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail.</span></span> <span data-ttu-id="be398-391">Сборка, загруженная в текущий домен приложения, может отличаться от сборки, которая была загружена первой, если параметры пути для двух доменов приложений различаются.</span><span class="sxs-lookup"><span data-stu-id="be398-391">The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-392">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-392">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-393">Параметр <paramref name="assemblyName" /> или <paramref name="typeName" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-393"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="be398-394"><paramref name="assemblyName" /> не является допустимой сборкой.</span><span class="sxs-lookup"><span data-stu-id="be398-394"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="be398-395">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-395">-or-</span></span> 
<span data-ttu-id="be398-396">В настоящий момент загружена версия 2.0 среды CLR, а параметр <paramref name="assemblyName" /> был скомпилирован в более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="be398-396">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="be398-397">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</span><span class="sxs-lookup"><span data-stu-id="be398-397">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="be398-398">Не удалось найти <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-398"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="be398-399">Вызывающий код не имеет разрешения на вызов этого конструктора.</span><span class="sxs-lookup"><span data-stu-id="be398-399">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="be398-400">Соответствующий открытый конструктор не найден.</span><span class="sxs-lookup"><span data-stu-id="be398-400">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="be398-401">Не удалось найти <paramref name="typename" /> в <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-401"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="be398-402">Этот экземпляр имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-402">This instance is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="be398-403">для доступа к чтению из файла или каталога, а также для доступа к данным в самом пути.</span><span class="sxs-lookup"><span data-stu-id="be398-403">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="be398-404">Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="be398-404">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="be398-405">значение для возможности доступа к расположению сборки, если сборка не является локальной.</span><span class="sxs-lookup"><span data-stu-id="be398-405">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="be398-406">для возможности вызова неуправляемого кода при создании экземпляра делегата.</span><span class="sxs-lookup"><span data-stu-id="be398-406">for the ability to call unmanaged code when creating an instance of a delegate.</span></span> <span data-ttu-id="be398-407">Связанное перечисление:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="be398-407">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="2" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="be398-408">Отображаемое имя сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-408">The display name of the assembly.</span></span> <span data-ttu-id="be398-409">См. раздел <see cref="P:System.Reflection.Assembly.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-409">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="be398-410">Полное имя запрошенного типа, включая пространство имен, но не сборку (см. описание свойства <see cref="P:System.Type.FullName" />).</span><span class="sxs-lookup"><span data-stu-id="be398-410">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="be398-411">Массив, состоящий из одного или нескольких атрибутов, которые могут участвовать в активации.</span><span class="sxs-lookup"><span data-stu-id="be398-411">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="be398-412">Обычно это массив, содержащий один объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />, определяющий URL-адрес, необходимый для активации удаленного объекта.</span><span class="sxs-lookup"><span data-stu-id="be398-412">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="be398-413">Этот параметр связан с объектами, активируемыми клиентом. Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений.</span><span class="sxs-lookup"><span data-stu-id="be398-413">This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="be398-414">Сейчас в распределенных приложениях следует использовать Windows Communication Foundation.</span><span class="sxs-lookup"><span data-stu-id="be398-414">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="be398-415">Создает новый экземпляр заданного типа, определенного в указанной сборке.</span><span class="sxs-lookup"><span data-stu-id="be398-415">Creates a new instance of the specified type defined in the specified assembly.</span></span> <span data-ttu-id="be398-416">Параметр определяет массив атрибутов активации.</span><span class="sxs-lookup"><span data-stu-id="be398-416">A parameter specifies an array of activation attributes.</span></span></summary>
        <returns><span data-ttu-id="be398-417">Объект, являющийся оболочкой для нового экземпляра, заданного параметром <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-417">An object that is a wrapper for the new instance specified by <paramref name="typeName" />.</span></span> <span data-ttu-id="be398-418">Необходимо распаковать возвращенное значение, чтобы получить доступ к реальному объекту.</span><span class="sxs-lookup"><span data-stu-id="be398-418">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-419">Этот метод вызывает конструктор без параметров для `typeName`.</span><span class="sxs-lookup"><span data-stu-id="be398-419">This method calls the parameterless constructor for `typeName`.</span></span>  
  
 <span data-ttu-id="be398-420">См <xref:System.Reflection.AssemblyName> `assemblyName`. раздел для формата.</span><span class="sxs-lookup"><span data-stu-id="be398-420">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span>  
  
 <span data-ttu-id="be398-421">Попытка вызова <xref:System.AppDomain.CreateInstance%2A> в домене целевого приложения, который не является текущим доменом приложения, приведет к успешной загрузке сборки в целевом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-421">An attempt to call <xref:System.AppDomain.CreateInstance%2A> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain.</span></span> <span data-ttu-id="be398-422">Поскольку не <xref:System.Reflection.Assembly> <xref:System.MarshalByRefObject>имеет значения <xref:System.Reflection.Assembly>  , когда этот метод пытается вернуть для загруженной сборки в текущий домен приложения, среда CLR пытается загрузить сборку в текущий домен приложения, а может произойти сбой загрузки.</span><span class="sxs-lookup"><span data-stu-id="be398-422">Since an <xref:System.Reflection.Assembly> is not <xref:System.MarshalByRefObject>, when this method attempts to return the <xref:System.Reflection.Assembly> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail.</span></span> <span data-ttu-id="be398-423">Сборка, загруженная в текущий домен приложения, может отличаться от сборки, которая была загружена первой, если параметры пути для двух доменов приложений различаются.</span><span class="sxs-lookup"><span data-stu-id="be398-423">The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-424">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-424">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-425">Значение параметра <paramref name="assemblyName" /> или <paramref name="typeName" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-425"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="be398-426"><paramref name="assemblyName" /> не является допустимой сборкой.</span><span class="sxs-lookup"><span data-stu-id="be398-426"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="be398-427">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-427">-or-</span></span> 
<span data-ttu-id="be398-428">В настоящий момент загружена версия 2.0 среды CLR, а параметр <paramref name="assemblyName" /> был скомпилирован в более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="be398-428">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="be398-429">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</span><span class="sxs-lookup"><span data-stu-id="be398-429">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="be398-430">Не удалось найти <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-430"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="be398-431">Вызывающий код не имеет разрешения на вызов этого конструктора.</span><span class="sxs-lookup"><span data-stu-id="be398-431">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="be398-432">Соответствующий общий конструктор не найден.</span><span class="sxs-lookup"><span data-stu-id="be398-432">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="be398-433">Вызывающий объект не может предоставить атрибуты активации для объекта, который не является производным от <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="be398-433">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="be398-434">Не удалось найти <paramref name="typename" /> в <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-434"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="be398-435">Этот экземпляр имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-435">This instance is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="be398-436">для возможности чтения файла, содержащего манифест сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-436">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="be398-437">Связанное перечисление:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="be398-437">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="be398-438">значение для возможности доступа к расположению сборки, если сборка не является локальной.</span><span class="sxs-lookup"><span data-stu-id="be398-438">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="be398-439">для возможности вызова неуправляемого кода при создании экземпляра делегата.</span><span class="sxs-lookup"><span data-stu-id="be398-439">for the ability to call unmanaged code when creating an instance of a delegate.</span></span> <span data-ttu-id="be398-440">Связанное перечисление:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="be398-440">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="be398-441">для возможности вызова операций для всех членов типа.</span><span class="sxs-lookup"><span data-stu-id="be398-441">for the ability to invoke operations on all type members.</span></span> <span data-ttu-id="be398-442">Связанное перечисление:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="be398-442">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="be398-443">Отображаемое имя сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-443">The display name of the assembly.</span></span> <span data-ttu-id="be398-444">См. раздел <see cref="P:System.Reflection.Assembly.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-444">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="be398-445">Полное имя запрошенного типа, включая пространство имен, но не сборку (см. описание свойства <see cref="P:System.Type.FullName" />).</span><span class="sxs-lookup"><span data-stu-id="be398-445">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="be398-446">Логическое значение, указывающее, следует ли учитывать регистр при поиске.</span><span class="sxs-lookup"><span data-stu-id="be398-446">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="be398-447">Сочетание битовых флагов, влияющих на поиск конструктора <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-447">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="be398-448">Если значение параметра <paramref name="bindingAttr" /> равно нулю, проводится поиск открытых конструкторов с учетом регистра.</span><span class="sxs-lookup"><span data-stu-id="be398-448">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="be398-449">Объект, позволяющий осуществлять привязку, приведение типов аргументов, вызов элементов, а также поиск объектов <see cref="T:System.Reflection.MemberInfo" /> с помощью отражения.</span><span class="sxs-lookup"><span data-stu-id="be398-449">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects using reflection.</span></span> <span data-ttu-id="be398-450">Если параметр <paramref name="binder" /> имеет значение null, то используется модуль привязки по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="be398-450">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="be398-451">Аргументы для передачи конструктору.</span><span class="sxs-lookup"><span data-stu-id="be398-451">The arguments to pass to the constructor.</span></span> <span data-ttu-id="be398-452">Массив аргументов должен соответствовать по числу, порядку и типу параметров вызываемому конструктору.</span><span class="sxs-lookup"><span data-stu-id="be398-452">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="be398-453">Если предпочтителен конструктор без параметров, то объект <paramref name="args" /> должен быть пустым массивом или значением NULL.</span><span class="sxs-lookup"><span data-stu-id="be398-453">If the parameterless constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="be398-454">Сведения о языке и региональных параметрах, которые влияют на приведение <paramref name="args" /> к формальным типам, объявленным для конструктора <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-454">Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="be398-455">Если параметр <paramref name="culture" /> имеет значение <see langword="null" />, для текущего потока используется объект <see cref="T:System.Globalization.CultureInfo" />.</span><span class="sxs-lookup"><span data-stu-id="be398-455">If <paramref name="culture" /> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="be398-456">Массив, состоящий из одного или нескольких атрибутов, которые могут участвовать в активации.</span><span class="sxs-lookup"><span data-stu-id="be398-456">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="be398-457">Обычно это массив, содержащий один объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />, определяющий URL-адрес, необходимый для активации удаленного объекта.</span><span class="sxs-lookup"><span data-stu-id="be398-457">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="be398-458">Этот параметр связан с объектами, активируемыми клиентом.</span><span class="sxs-lookup"><span data-stu-id="be398-458">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="be398-459">Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений.</span><span class="sxs-lookup"><span data-stu-id="be398-459">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="be398-460">Сейчас в распределенных приложениях следует использовать Windows Communication Foundation.</span><span class="sxs-lookup"><span data-stu-id="be398-460">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="be398-461">Создает новый экземпляр заданного типа, определенного в указанной сборке.</span><span class="sxs-lookup"><span data-stu-id="be398-461">Creates a new instance of the specified type defined in the specified assembly.</span></span> <span data-ttu-id="be398-462">Параметры определяют средство связывания, флаги привязки, аргументы конструктора, сведения, связанные с языком и региональными параметрами, используемые для интерпретации аргументов, и необязательные атрибуты активации.</span><span class="sxs-lookup"><span data-stu-id="be398-462">Parameters specify a binder, binding flags, constructor arguments, culture-specific information used to interpret arguments, and optional activation attributes.</span></span></summary>
        <returns><span data-ttu-id="be398-463">Объект, являющийся оболочкой для нового экземпляра, заданного параметром <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-463">An object that is a wrapper for the new instance specified by <paramref name="typeName" />.</span></span> <span data-ttu-id="be398-464">Необходимо распаковать возвращенное значение, чтобы получить доступ к реальному объекту.</span><span class="sxs-lookup"><span data-stu-id="be398-464">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-465">См <xref:System.Reflection.AssemblyName> `assemblyName`. раздел для формата.</span><span class="sxs-lookup"><span data-stu-id="be398-465">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span>  
  
 <span data-ttu-id="be398-466">Попытка вызова <xref:System.AppDomain.CreateInstance%2A> в домене целевого приложения, который не является текущим доменом приложения, приведет к успешной загрузке сборки в целевом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-466">An attempt to call <xref:System.AppDomain.CreateInstance%2A> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain.</span></span> <span data-ttu-id="be398-467">Поскольку не <xref:System.Reflection.Assembly> <xref:System.MarshalByRefObject>имеет значения <xref:System.Reflection.Assembly>  , когда этот метод пытается вернуть для загруженной сборки в текущий домен приложения, среда CLR пытается загрузить сборку в текущий домен приложения, а может произойти сбой загрузки.</span><span class="sxs-lookup"><span data-stu-id="be398-467">Since an <xref:System.Reflection.Assembly> is not <xref:System.MarshalByRefObject>, when this method attempts to return the <xref:System.Reflection.Assembly> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail.</span></span> <span data-ttu-id="be398-468">Сборка, загруженная в текущий домен приложения, может отличаться от сборки, которая была загружена первой, если параметры пути для двух доменов приложений различаются.</span><span class="sxs-lookup"><span data-stu-id="be398-468">The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-469">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-469">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-470">Значение параметра <paramref name="assemblyName" /> или <paramref name="typeName" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-470"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="be398-471"><paramref name="assemblyName" /> не является допустимой сборкой.</span><span class="sxs-lookup"><span data-stu-id="be398-471"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="be398-472">-или-</span><span class="sxs-lookup"><span data-stu-id="be398-472">-or-</span></span> 
 <span data-ttu-id="be398-473">Сборка <paramref name="assemblyName" /> была скомпилирована в более поздней версии среды CLR, чем версия, загруженная в текущий момент.</span><span class="sxs-lookup"><span data-stu-id="be398-473"><paramref name="assemblyName" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="be398-474">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</span><span class="sxs-lookup"><span data-stu-id="be398-474">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="be398-475">Не удалось найти <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-475"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="be398-476">Вызывающий объект не имеет разрешения на вызов этого конструктора.</span><span class="sxs-lookup"><span data-stu-id="be398-476">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="be398-477">Соответствующий конструктор не найден.</span><span class="sxs-lookup"><span data-stu-id="be398-477">No matching constructor was found.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="be398-478">Вызывающий объект не может предоставить атрибуты активации для объекта, который не является производным от <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="be398-478">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="be398-479">Не удалось найти <paramref name="typename" /> в <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-479"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="be398-480">Этот экземпляр имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-480">This instance is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="be398-481">для возможности чтения файла, содержащего манифест сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-481">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="be398-482">Связанное перечисление:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="be398-482">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="be398-483">значение для возможности доступа к расположению сборки, если сборка не является локальной.</span><span class="sxs-lookup"><span data-stu-id="be398-483">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="be398-484">для возможности вызова неуправляемого кода при создании экземпляра делегата.</span><span class="sxs-lookup"><span data-stu-id="be398-484">for the ability to call unmanaged code when creating an instance of a delegate.</span></span> <span data-ttu-id="be398-485">Связанное перечисление:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="be398-485">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="be398-486">для возможности вызова операций для всех членов типа.</span><span class="sxs-lookup"><span data-stu-id="be398-486">for the ability to invoke operations on all type members.</span></span> <span data-ttu-id="be398-487">Связанное перечисление:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="be398-487">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" Index="8" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="be398-488">Отображаемое имя сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-488">The display name of the assembly.</span></span> <span data-ttu-id="be398-489">См. раздел <see cref="P:System.Reflection.Assembly.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-489">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="be398-490">Полное имя запрошенного типа, включая пространство имен, но не сборку (см. описание свойства <see cref="P:System.Type.FullName" />).</span><span class="sxs-lookup"><span data-stu-id="be398-490">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="be398-491">Логическое значение, указывающее, следует ли учитывать регистр при поиске.</span><span class="sxs-lookup"><span data-stu-id="be398-491">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="be398-492">Сочетание битовых флагов, влияющих на поиск конструктора <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-492">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="be398-493">Если значение параметра <paramref name="bindingAttr" /> равно нулю, проводится поиск открытых конструкторов с учетом регистра.</span><span class="sxs-lookup"><span data-stu-id="be398-493">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="be398-494">Объект, позволяющий осуществлять привязку, приведение типов аргументов, вызов элементов, а также поиск объектов <see cref="T:System.Reflection.MemberInfo" /> с помощью отражения.</span><span class="sxs-lookup"><span data-stu-id="be398-494">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects using reflection.</span></span> <span data-ttu-id="be398-495">Если параметр <paramref name="binder" /> имеет значение null, то используется модуль привязки по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="be398-495">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="be398-496">Аргументы для передачи конструктору.</span><span class="sxs-lookup"><span data-stu-id="be398-496">The arguments to pass to the constructor.</span></span> <span data-ttu-id="be398-497">Массив аргументов должен соответствовать по числу, порядку и типу параметров вызываемому конструктору.</span><span class="sxs-lookup"><span data-stu-id="be398-497">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="be398-498">Если предпочтителен конструктор без параметров, то объект <paramref name="args" /> должен быть пустым массивом или значением NULL.</span><span class="sxs-lookup"><span data-stu-id="be398-498">If the parameterless constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="be398-499">Сведения о языке и региональных параметрах, которые влияют на приведение <paramref name="args" /> к формальным типам, объявленным для конструктора <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-499">Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="be398-500">Если параметр <paramref name="culture" /> имеет значение <see langword="null" />, для текущего потока используется объект <see cref="T:System.Globalization.CultureInfo" />.</span><span class="sxs-lookup"><span data-stu-id="be398-500">If <paramref name="culture" /> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="be398-501">Массив, состоящий из одного или нескольких атрибутов, которые могут участвовать в активации.</span><span class="sxs-lookup"><span data-stu-id="be398-501">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="be398-502">Обычно это массив, содержащий один объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />, определяющий URL-адрес, необходимый для активации удаленного объекта.</span><span class="sxs-lookup"><span data-stu-id="be398-502">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="be398-503">Этот параметр связан с объектами, активируемыми клиентом. Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений.</span><span class="sxs-lookup"><span data-stu-id="be398-503">This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="be398-504">Сейчас в распределенных приложениях следует использовать Windows Communication Foundation.</span><span class="sxs-lookup"><span data-stu-id="be398-504">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <param name="securityAttributes"><span data-ttu-id="be398-505">Сведения, используемые для авторизации создания <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-505">Information used to authorize creation of <paramref name="typeName" />.</span></span></param>
        <summary><span data-ttu-id="be398-506">Создает новый экземпляр заданного типа, определенного в указанной сборке.</span><span class="sxs-lookup"><span data-stu-id="be398-506">Creates a new instance of the specified type defined in the specified assembly.</span></span> <span data-ttu-id="be398-507">Параметры определяют средство связывания, флаги привязки, аргументы конструктора, сведения, связанные с языком и региональными параметрами, используемые для интерпретации аргументов, атрибуты активации и авторизацию для создания типа.</span><span class="sxs-lookup"><span data-stu-id="be398-507">Parameters specify a binder, binding flags, constructor arguments, culture-specific information used to interpret arguments, activation attributes, and authorization to create the type.</span></span></summary>
        <returns><span data-ttu-id="be398-508">Объект, являющийся оболочкой для нового экземпляра, заданного параметром <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-508">An object that is a wrapper for the new instance specified by <paramref name="typeName" />.</span></span> <span data-ttu-id="be398-509">Необходимо распаковать возвращенное значение, чтобы получить доступ к реальному объекту.</span><span class="sxs-lookup"><span data-stu-id="be398-509">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-510">См <xref:System.Reflection.AssemblyName> `assemblyName`. раздел для формата.</span><span class="sxs-lookup"><span data-stu-id="be398-510">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span>  
  
 <span data-ttu-id="be398-511">Попытка вызова <xref:System.AppDomain.CreateInstance%2A> в домене целевого приложения, который не является текущим доменом приложения, приведет к успешной загрузке сборки в целевом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-511">An attempt to call <xref:System.AppDomain.CreateInstance%2A> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain.</span></span> <span data-ttu-id="be398-512">Поскольку не <xref:System.Reflection.Assembly> <xref:System.MarshalByRefObject>имеет значения <xref:System.Reflection.Assembly>  , когда этот метод пытается вернуть для загруженной сборки в текущий домен приложения, среда CLR пытается загрузить сборку в текущий домен приложения, а может произойти сбой загрузки.</span><span class="sxs-lookup"><span data-stu-id="be398-512">Since an <xref:System.Reflection.Assembly> is not <xref:System.MarshalByRefObject>, when this method attempts to return the <xref:System.Reflection.Assembly> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail.</span></span> <span data-ttu-id="be398-513">Сборка, загруженная в текущий домен приложения, может отличаться от сборки, которая была загружена первой, если параметры пути для двух доменов приложений различаются.</span><span class="sxs-lookup"><span data-stu-id="be398-513">The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-514">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-514">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-515">Значение параметра <paramref name="assemblyName" /> или <paramref name="typeName" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-515"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="be398-516"><paramref name="assemblyName" /> не является допустимой сборкой.</span><span class="sxs-lookup"><span data-stu-id="be398-516"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="be398-517">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-517">-or-</span></span> 
<span data-ttu-id="be398-518">В настоящий момент загружена версия 2.0 среды CLR, а параметр <paramref name="assemblyName" /> был скомпилирован в более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="be398-518">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="be398-519">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</span><span class="sxs-lookup"><span data-stu-id="be398-519">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="be398-520">Не удалось найти <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-520"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="be398-521">Вызывающий объект не имеет разрешения на вызов этого конструктора.</span><span class="sxs-lookup"><span data-stu-id="be398-521">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="be398-522">Соответствующий конструктор не найден.</span><span class="sxs-lookup"><span data-stu-id="be398-522">No matching constructor was found.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="be398-523">Вызывающий код не может предоставить атрибуты активации для объекта, не являющегося наследником <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="be398-523">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span>  
  
<span data-ttu-id="be398-524">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-524">-or-</span></span> 
 <span data-ttu-id="be398-525">Значение <paramref name="securityAttributes" /> не <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-525"><paramref name="securityAttributes" /> is not <see langword="null" />.</span></span> <span data-ttu-id="be398-526">Когда устаревшие политики разграничения доступа кода не включены, <paramref name="securityAttributes" /> должен равняться <see langword="null." />.</span><span class="sxs-lookup"><span data-stu-id="be398-526">When legacy CAS policy is not enabled, <paramref name="securityAttributes" /> should be <see langword="null." /></span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="be398-527">Не удалось найти <paramref name="typename" /> в <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-527"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="be398-528">Этот экземпляр имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-528">This instance is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="be398-529">для возможности чтения файла, содержащего манифест сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-529">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="be398-530">Связанное перечисление:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="be398-530">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="be398-531">значение для возможности доступа к расположению сборки, если сборка не является локальной.</span><span class="sxs-lookup"><span data-stu-id="be398-531">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="be398-532">для предоставления свидетельства.</span><span class="sxs-lookup"><span data-stu-id="be398-532">to provide evidence.</span></span> <span data-ttu-id="be398-533">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="be398-533">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="be398-534">для возможности вызова операций для всех членов типа.</span><span class="sxs-lookup"><span data-stu-id="be398-534">for the ability to invoke operations on all type members.</span></span> <span data-ttu-id="be398-535">Связанное перечисление:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="be398-535">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="be398-536">Создает новый экземпляр заданного типа.</span><span class="sxs-lookup"><span data-stu-id="be398-536">Creates a new instance of a specified type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="be398-537">Отображаемое имя сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-537">The display name of the assembly.</span></span> <span data-ttu-id="be398-538">См. раздел <see cref="P:System.Reflection.Assembly.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-538">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="be398-539">Полное имя запрошенного типа, включая пространство имен, но не сборку, возвращаемое свойством <see cref="P:System.Type.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-539">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <summary><span data-ttu-id="be398-540">Создает новый экземпляр заданного типа.</span><span class="sxs-lookup"><span data-stu-id="be398-540">Creates a new instance of the specified type.</span></span> <span data-ttu-id="be398-541">Параметры задают сборку, где определен тип, и имя типа.</span><span class="sxs-lookup"><span data-stu-id="be398-541">Parameters specify the assembly where the type is defined, and the name of the type.</span></span></summary>
        <returns><span data-ttu-id="be398-542">Экземпляр объекта, заданного параметром <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-542">An instance of the object specified by <paramref name="typeName" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-543">Это удобный метод, который сочетает <xref:System.AppDomain.CreateInstance%2A> и. <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="be398-543">This is a convenience method that combines <xref:System.AppDomain.CreateInstance%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="be398-544">Этот метод вызывает конструктор без параметров для `typeName`.</span><span class="sxs-lookup"><span data-stu-id="be398-544">This method calls the parameterless constructor for `typeName`.</span></span>  
  
 <span data-ttu-id="be398-545">См <xref:System.Reflection.AssemblyName> `assemblyName`. раздел для формата.</span><span class="sxs-lookup"><span data-stu-id="be398-545">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span> <span data-ttu-id="be398-546">`typeName`См. <xref:System.Type.FullName%2A?displayProperty=nameWithType> свойство в формате.</span><span class="sxs-lookup"><span data-stu-id="be398-546">See the <xref:System.Type.FullName%2A?displayProperty=nameWithType> property for the format of `typeName`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="be398-547">Если выполнить вызов с ранней привязкой к методу `M` объекта типа `T1` , возвращенного <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>методом, и этот метод выполняет вызов метода с ранней привязкой к методу объекта типа `T2` в сборке `C` , отличной от Текущая сборка или сборка, содержащая `T1`сборку `C` , загружается в текущий домен приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-547">If you make an early-bound call to a method `M` of an object of type `T1` that was returned by <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, and that method makes an early-bound call to a method of an object of type `T2` in an assembly `C` other than the current assembly or the assembly containing `T1`, assembly `C` is loaded into the current application domain.</span></span> <span data-ttu-id="be398-548">Эта загрузка происходит даже в том случае, если вызов `T1.M()` с ранней привязкой был сделан в теле <xref:System.Reflection.Emit.DynamicMethod>или в другом динамически создаваемом коде.</span><span class="sxs-lookup"><span data-stu-id="be398-548">This loading occurs even if the early-bound call to `T1.M()` was made in the body of a <xref:System.Reflection.Emit.DynamicMethod>, or in other dynamically generated code.</span></span> <span data-ttu-id="be398-549">Если текущий домен является доменом по умолчанию, `C` сборка не может быть выгружена до завершения процесса.</span><span class="sxs-lookup"><span data-stu-id="be398-549">If the current domain is the default domain, assembly `C` cannot be unloaded until the process ends.</span></span> <span data-ttu-id="be398-550">Если текущий домен позже попытается загрузить сборку `C`, может произойти сбой загрузки.</span><span class="sxs-lookup"><span data-stu-id="be398-550">If the current domain later attempts to load assembly `C`, the load might fail.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-551">В следующем примере кода показан самый простой способ выполнения кода в другом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-551">The following code example shows the simplest way to execute code in another application domain.</span></span> <span data-ttu-id="be398-552">В примере определяется класс с именем `Worker` , наследуемый <xref:System.MarshalByRefObject>от.</span><span class="sxs-lookup"><span data-stu-id="be398-552">The example defines a class named `Worker` that inherits from <xref:System.MarshalByRefObject>.</span></span> <span data-ttu-id="be398-553">`Worker` Класс определяет метод, который отображает имя домена приложения, в котором оно выполняется.</span><span class="sxs-lookup"><span data-stu-id="be398-553">The `Worker` class defines a method that displays the name of the application domain in which it is executing.</span></span> <span data-ttu-id="be398-554">В примере создаются экземпляры `Worker` в домене приложения по умолчанию и в новом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-554">The example creates instances of `Worker` in the default application domain and in a new application domain.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="be398-555">Сборка, которая содержит `Worker` , должна быть загружена в оба домена приложений, но может загружать другие сборки, существующие только в новом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-555">The assembly that contains `Worker` must be loaded into both application domains, but it can load other assemblies that exist only in the new application domain.</span></span>  
  
 [!code-cpp[CreateInstanceAndUnwrap2#1](~/samples/snippets/cpp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cpp/source.cpp#1)]
 [!code-csharp[CreateInstanceAndUnwrap2#1](~/samples/snippets/csharp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cs/source.cs#1)]
 [!code-vb[CreateInstanceAndUnwrap2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CreateInstanceAndUnwrap2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-556">Значение параметра <paramref name="assemblyName" /> или <paramref name="typeName" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-556"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="be398-557">Соответствующий общий конструктор не найден.</span><span class="sxs-lookup"><span data-stu-id="be398-557">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="be398-558">Не удалось найти <paramref name="typename" /> в <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-558"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="be398-559">Не удалось найти <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-559"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="be398-560">Вызывающий объект не имеет разрешения на вызов этого конструктора.</span><span class="sxs-lookup"><span data-stu-id="be398-560">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-561">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-561">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="be398-562">Сборка, определенная параметром <paramref name="assemblyName" />, является недопустимой.</span><span class="sxs-lookup"><span data-stu-id="be398-562"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="be398-563">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-563">-or-</span></span> 
<span data-ttu-id="be398-564">В настоящий момент загружена версия 2.0 среды CLR, а параметр <paramref name="assemblyName" /> был скомпилирован в более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="be398-564">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="be398-565">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</span><span class="sxs-lookup"><span data-stu-id="be398-565">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="be398-566">для возможности чтения файла, содержащего манифест сборки, или при создании типа из модуля, отличного от файла манифеста.</span><span class="sxs-lookup"><span data-stu-id="be398-566">for the ability to read the file containing the assembly manifest, or if you are creating a type from a module other than the manifest file.</span></span> <span data-ttu-id="be398-567">Связанное перечисление:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="be398-567">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="be398-568">значение для возможности доступа к расположению сборки, если сборка не является локальной.</span><span class="sxs-lookup"><span data-stu-id="be398-568">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * obj[] -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="2" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="be398-569">Отображаемое имя сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-569">The display name of the assembly.</span></span> <span data-ttu-id="be398-570">См. раздел <see cref="P:System.Reflection.Assembly.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-570">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="be398-571">Полное имя запрошенного типа, включая пространство имен, но не сборку (см. описание свойства <see cref="P:System.Type.FullName" />).</span><span class="sxs-lookup"><span data-stu-id="be398-571">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="be398-572">Массив, состоящий из одного или нескольких атрибутов, которые могут участвовать в активации.</span><span class="sxs-lookup"><span data-stu-id="be398-572">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="be398-573">Обычно это массив, содержащий один объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />, определяющий URL-адрес, необходимый для активации удаленного объекта.</span><span class="sxs-lookup"><span data-stu-id="be398-573">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="be398-574">Этот параметр связан с объектами, активируемыми клиентом. Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений.</span><span class="sxs-lookup"><span data-stu-id="be398-574">This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="be398-575">Сейчас в распределенных приложениях следует использовать Windows Communication Foundation.</span><span class="sxs-lookup"><span data-stu-id="be398-575">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="be398-576">Создает новый экземпляр заданного типа.</span><span class="sxs-lookup"><span data-stu-id="be398-576">Creates a new instance of the specified type.</span></span> <span data-ttu-id="be398-577">Параметры задают сборку, где определен тип, имя типа и массив атрибутов активации.</span><span class="sxs-lookup"><span data-stu-id="be398-577">Parameters specify the assembly where the type is defined, the name of the type, and an array of activation attributes.</span></span></summary>
        <returns><span data-ttu-id="be398-578">Экземпляр объекта, заданного параметром <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-578">An instance of the object specified by <paramref name="typeName" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-579">Это удобный метод, который сочетает <xref:System.AppDomain.CreateInstance%2A> и. <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="be398-579">This is a convenience method that combines <xref:System.AppDomain.CreateInstance%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="be398-580">Этот метод вызывает конструктор без параметров для `typeName`.</span><span class="sxs-lookup"><span data-stu-id="be398-580">This method calls the parameterless constructor for `typeName`.</span></span>  
  
 <span data-ttu-id="be398-581">См <xref:System.Reflection.AssemblyName> `assemblyName`. раздел для формата.</span><span class="sxs-lookup"><span data-stu-id="be398-581">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span> <span data-ttu-id="be398-582">`typeName`См. <xref:System.Type.FullName%2A?displayProperty=nameWithType> свойство в формате.</span><span class="sxs-lookup"><span data-stu-id="be398-582">See the <xref:System.Type.FullName%2A?displayProperty=nameWithType> property for the format of `typeName`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="be398-583">Если выполнить вызов с ранней привязкой к методу `M` объекта типа `T1` , возвращенного <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>методом, и этот метод выполняет вызов метода с ранней привязкой к методу объекта типа `T2` в сборке `C` , отличной от Текущая сборка или сборка, содержащая `T1`сборку `C` , загружается в текущий домен приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-583">If you make an early-bound call to a method `M` of an object of type `T1` that was returned by <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, and that method makes an early-bound call to a method of an object of type `T2` in an assembly `C` other than the current assembly or the assembly containing `T1`, assembly `C` is loaded into the current application domain.</span></span> <span data-ttu-id="be398-584">Эта загрузка происходит даже в том случае, если вызов `T1.M()` с ранней привязкой был сделан в теле <xref:System.Reflection.Emit.DynamicMethod>или в другом динамически создаваемом коде.</span><span class="sxs-lookup"><span data-stu-id="be398-584">This loading occurs even if the early-bound call to `T1.M()` was made in the body of a <xref:System.Reflection.Emit.DynamicMethod>, or in other dynamically generated code.</span></span> <span data-ttu-id="be398-585">Если текущий домен является доменом по умолчанию, `C` сборка не может быть выгружена до завершения процесса.</span><span class="sxs-lookup"><span data-stu-id="be398-585">If the current domain is the default domain, assembly `C` cannot be unloaded until the process ends.</span></span> <span data-ttu-id="be398-586">Если текущий домен позже попытается загрузить сборку `C`, может произойти сбой загрузки.</span><span class="sxs-lookup"><span data-stu-id="be398-586">If the current domain later attempts to load assembly `C`, the load might fail.</span></span>  
  
   
  
## Examples  
 [!code-cpp[ADDyno#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-587">Параметр <paramref name="assemblyName" /> или <paramref name="typeName" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-587"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="be398-588">Соответствующий общий конструктор не найден.</span><span class="sxs-lookup"><span data-stu-id="be398-588">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="be398-589">Не удалось найти <paramref name="typename" /> в <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-589"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="be398-590">Не удалось найти <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-590"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="be398-591">Вызывающий объект не имеет разрешения на вызов этого конструктора.</span><span class="sxs-lookup"><span data-stu-id="be398-591">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="be398-592">Вызывающий объект не может предоставить атрибуты активации для объекта, который не является производным от <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="be398-592">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-593">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-593">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="be398-594">Сборка, определенная параметром <paramref name="assemblyName" />, является недопустимой.</span><span class="sxs-lookup"><span data-stu-id="be398-594"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="be398-595">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-595">-or-</span></span> 
<span data-ttu-id="be398-596">В настоящий момент загружена версия 2.0 среды CLR, а параметр <paramref name="assemblyName" /> был скомпилирован в более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="be398-596">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="be398-597">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</span><span class="sxs-lookup"><span data-stu-id="be398-597">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="be398-598">для возможности чтения файла, содержащего манифест сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-598">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="be398-599">Связанное перечисление:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="be398-599">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="be398-600">значение для возможности доступа к расположению сборки, если сборка не является локальной.</span><span class="sxs-lookup"><span data-stu-id="be398-600">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="be398-601">для возможности вызова неуправляемого кода при создании экземпляра делегата.</span><span class="sxs-lookup"><span data-stu-id="be398-601">for the ability to call unmanaged code when creating an instance of a delegate.</span></span> <span data-ttu-id="be398-602">Связанное перечисление:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="be398-602">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="be398-603">для возможности вызова операций для всех членов типа.</span><span class="sxs-lookup"><span data-stu-id="be398-603">for the ability to invoke operations on all type members.</span></span> <span data-ttu-id="be398-604">Связанное перечисление:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="be398-604">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="be398-605">Отображаемое имя сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-605">The display name of the assembly.</span></span> <span data-ttu-id="be398-606">См. раздел <see cref="P:System.Reflection.Assembly.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-606">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="be398-607">Полное имя запрошенного типа, включая пространство имен, но не сборку (см. описание свойства <see cref="P:System.Type.FullName" />).</span><span class="sxs-lookup"><span data-stu-id="be398-607">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="be398-608">Логическое значение, указывающее, следует ли учитывать регистр при поиске.</span><span class="sxs-lookup"><span data-stu-id="be398-608">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="be398-609">Сочетание битовых флагов, влияющих на поиск конструктора <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-609">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="be398-610">Если значение параметра <paramref name="bindingAttr" /> равно нулю, проводится поиск открытых конструкторов с учетом регистра.</span><span class="sxs-lookup"><span data-stu-id="be398-610">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="be398-611">Объект, позволяющий осуществлять привязку, приведение типов аргументов, вызов элементов, а также поиск объектов <see cref="T:System.Reflection.MemberInfo" /> с помощью отражения.</span><span class="sxs-lookup"><span data-stu-id="be398-611">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects using reflection.</span></span> <span data-ttu-id="be398-612">Если параметр <paramref name="binder" /> имеет значение null, то используется модуль привязки по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="be398-612">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="be398-613">Аргументы для передачи конструктору.</span><span class="sxs-lookup"><span data-stu-id="be398-613">The arguments to pass to the constructor.</span></span> <span data-ttu-id="be398-614">Массив аргументов должен соответствовать по числу, порядку и типу параметров вызываемому конструктору.</span><span class="sxs-lookup"><span data-stu-id="be398-614">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="be398-615">Если предпочтителен конструктор без параметров, то объект <paramref name="args" /> должен быть пустым массивом или значением NULL.</span><span class="sxs-lookup"><span data-stu-id="be398-615">If the parameterless constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="be398-616">Объект, зависящий от языка и региональных параметров, который используется для управления приведением типов.</span><span class="sxs-lookup"><span data-stu-id="be398-616">A culture-specific object used to govern the coercion of types.</span></span> <span data-ttu-id="be398-617">Если значение параметра <paramref name="culture" /> равно <see langword="null" />, для текущего потока используется объект <see langword="CultureInfo" />.</span><span class="sxs-lookup"><span data-stu-id="be398-617">If <paramref name="culture" /> is <see langword="null" />, the <see langword="CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="be398-618">Массив, состоящий из одного или нескольких атрибутов, которые могут участвовать в активации.</span><span class="sxs-lookup"><span data-stu-id="be398-618">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="be398-619">Как правило, массив, который содержит единственный объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="be398-619">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object.</span></span> <span data-ttu-id="be398-620">который определяет URL-адрес, необходимый для активации удаленного объекта.</span><span class="sxs-lookup"><span data-stu-id="be398-620">that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="be398-621">Этот параметр связан с объектами, активируемыми клиентом.</span><span class="sxs-lookup"><span data-stu-id="be398-621">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="be398-622">Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений.</span><span class="sxs-lookup"><span data-stu-id="be398-622">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="be398-623">Сейчас в распределенных приложениях следует использовать Windows Communication Foundation.</span><span class="sxs-lookup"><span data-stu-id="be398-623">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="be398-624">Создает новый экземпляр заданного типа, определенного в заданной сборке, указывая, игнорируется ли регистр имени типа; атрибуты привязки и средство привязки, используемые для выбора создаваемого типа; аргументы конструктора; язык и региональные параметры; и атрибуты активации.</span><span class="sxs-lookup"><span data-stu-id="be398-624">Creates a new instance of the specified type defined in the specified assembly, specifying whether the case of the type name is ignored; the binding attributes and the binder that are used to select the type to be created; the arguments of the constructor; the culture; and the activation attributes.</span></span></summary>
        <returns><span data-ttu-id="be398-625">Экземпляр объекта, заданного параметром <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-625">An instance of the object specified by <paramref name="typeName" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-626">Это удобный метод, который сочетает <xref:System.AppDomain.CreateInstance%2A> и. <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="be398-626">This is a convenience method that combines <xref:System.AppDomain.CreateInstance%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="be398-627">См <xref:System.Reflection.AssemblyName> `assemblyName`. раздел для формата.</span><span class="sxs-lookup"><span data-stu-id="be398-627">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span> <span data-ttu-id="be398-628">`typeName`См. <xref:System.Type.FullName%2A?displayProperty=nameWithType> свойство в формате.</span><span class="sxs-lookup"><span data-stu-id="be398-628">See the <xref:System.Type.FullName%2A?displayProperty=nameWithType> property for the format of `typeName`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="be398-629">Если выполнить вызов с ранней привязкой к методу `M` объекта типа `T1` , возвращенного <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>методом, и этот метод выполняет вызов метода с ранней привязкой к методу объекта типа `T2` в сборке `C` , отличной от Текущая сборка или сборка, содержащая `T1`сборку `C` , загружается в текущий домен приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-629">If you make an early-bound call to a method `M` of an object of type `T1` that was returned by <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, and that method makes an early-bound call to a method of an object of type `T2` in an assembly `C` other than the current assembly or the assembly containing `T1`, assembly `C` is loaded into the current application domain.</span></span> <span data-ttu-id="be398-630">Эта загрузка происходит даже в том случае, если вызов `T1.M()` с ранней привязкой был сделан в теле <xref:System.Reflection.Emit.DynamicMethod>или в другом динамически создаваемом коде.</span><span class="sxs-lookup"><span data-stu-id="be398-630">This loading occurs even if the early-bound call to `T1.M()` was made in the body of a <xref:System.Reflection.Emit.DynamicMethod>, or in other dynamically generated code.</span></span> <span data-ttu-id="be398-631">Если текущий домен является доменом по умолчанию, `C` сборка не может быть выгружена до завершения процесса.</span><span class="sxs-lookup"><span data-stu-id="be398-631">If the current domain is the default domain, assembly `C` cannot be unloaded until the process ends.</span></span> <span data-ttu-id="be398-632">Если текущий домен позже попытается загрузить сборку `C`, может произойти сбой загрузки.</span><span class="sxs-lookup"><span data-stu-id="be398-632">If the current domain later attempts to load assembly `C`, the load might fail.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-633">В следующем примере демонстрируется использование `ignoreCase` параметра.</span><span class="sxs-lookup"><span data-stu-id="be398-633">The following sample demonstrates the use of the `ignoreCase` parameter.</span></span>  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-634">Значение параметра <paramref name="assemblyName" /> или <paramref name="typeName" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-634"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="be398-635">Соответствующий конструктор не найден.</span><span class="sxs-lookup"><span data-stu-id="be398-635">No matching constructor was found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="be398-636">Не удалось найти <paramref name="typename" /> в <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-636"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="be398-637">Не удалось найти <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-637"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="be398-638">Вызывающий объект не имеет разрешения на вызов этого конструктора.</span><span class="sxs-lookup"><span data-stu-id="be398-638">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="be398-639">Вызывающий объект не может предоставить атрибуты активации для объекта, который не является производным от <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="be398-639">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-640">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-640">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="be398-641">Сборка, определенная параметром <paramref name="assemblyName" />, является недопустимой.</span><span class="sxs-lookup"><span data-stu-id="be398-641"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="be398-642">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-642">-or-</span></span> 
 <span data-ttu-id="be398-643">Сборка <paramref name="assemblyName" /> была скомпилирована в более поздней версии среды CLR, чем версия, загруженная в текущий момент.</span><span class="sxs-lookup"><span data-stu-id="be398-643"><paramref name="assemblyName" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="be398-644">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</span><span class="sxs-lookup"><span data-stu-id="be398-644">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="be398-645">для возможности чтения файла, содержащего манифест сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-645">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="be398-646">Связанное перечисление:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="be398-646">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="be398-647">значение для возможности доступа к расположению сборки, если сборка не является локальной.</span><span class="sxs-lookup"><span data-stu-id="be398-647">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="be398-648">для возможности вызова неуправляемого кода при создании экземпляра делегата.</span><span class="sxs-lookup"><span data-stu-id="be398-648">for the ability to call unmanaged code when creating an instance of a delegate.</span></span> <span data-ttu-id="be398-649">Связанное перечисление:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="be398-649">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="be398-650">для возможности вызова операций для всех членов типа.</span><span class="sxs-lookup"><span data-stu-id="be398-650">for the ability to invoke operations on all type members.</span></span> <span data-ttu-id="be398-651">Связанное перечисление:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="be398-651">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceAndUnwrap which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" Index="8" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="be398-652">Отображаемое имя сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-652">The display name of the assembly.</span></span> <span data-ttu-id="be398-653">См. раздел <see cref="P:System.Reflection.Assembly.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-653">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="be398-654">Полное имя запрошенного типа, включая пространство имен, но не сборку (см. описание свойства <see cref="P:System.Type.FullName" />).</span><span class="sxs-lookup"><span data-stu-id="be398-654">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="be398-655">Логическое значение, указывающее, следует ли учитывать регистр при поиске.</span><span class="sxs-lookup"><span data-stu-id="be398-655">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="be398-656">Сочетание битовых флагов, влияющих на поиск конструктора <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-656">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="be398-657">Если значение параметра <paramref name="bindingAttr" /> равно нулю, проводится поиск открытых конструкторов с учетом регистра.</span><span class="sxs-lookup"><span data-stu-id="be398-657">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="be398-658">Объект, позволяющий осуществлять привязку, приведение типов аргументов, вызов элементов, а также поиск объектов <see cref="T:System.Reflection.MemberInfo" /> с помощью отражения.</span><span class="sxs-lookup"><span data-stu-id="be398-658">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects using reflection.</span></span> <span data-ttu-id="be398-659">Если параметр <paramref name="binder" /> имеет значение null, то используется модуль привязки по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="be398-659">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="be398-660">Аргументы для передачи конструктору.</span><span class="sxs-lookup"><span data-stu-id="be398-660">The arguments to pass to the constructor.</span></span> <span data-ttu-id="be398-661">Массив аргументов должен соответствовать по числу, порядку и типу параметров вызываемому конструктору.</span><span class="sxs-lookup"><span data-stu-id="be398-661">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="be398-662">Если предпочтителен конструктор без параметров, то объект <paramref name="args" /> должен быть пустым массивом или значением NULL.</span><span class="sxs-lookup"><span data-stu-id="be398-662">If the parameterless constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="be398-663">Объект, зависящий от языка и региональных параметров, который используется для управления приведением типов.</span><span class="sxs-lookup"><span data-stu-id="be398-663">A culture-specific object used to govern the coercion of types.</span></span> <span data-ttu-id="be398-664">Если значение параметра <paramref name="culture" /> равно <see langword="null" />, для текущего потока используется объект <see langword="CultureInfo" />.</span><span class="sxs-lookup"><span data-stu-id="be398-664">If <paramref name="culture" /> is <see langword="null" />, the <see langword="CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="be398-665">Массив, состоящий из одного или нескольких атрибутов, которые могут участвовать в активации.</span><span class="sxs-lookup"><span data-stu-id="be398-665">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="be398-666">Обычно это массив, содержащий один объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />, определяющий URL-адрес, необходимый для активации удаленного объекта.</span><span class="sxs-lookup"><span data-stu-id="be398-666">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="be398-667">Этот параметр связан с объектами, активируемыми клиентом.</span><span class="sxs-lookup"><span data-stu-id="be398-667">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="be398-668">Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений.</span><span class="sxs-lookup"><span data-stu-id="be398-668">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="be398-669">Сейчас в распределенных приложениях следует использовать Windows Communication Foundation.</span><span class="sxs-lookup"><span data-stu-id="be398-669">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <param name="securityAttributes"><span data-ttu-id="be398-670">Сведения, используемые для авторизации создания <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-670">Information used to authorize creation of <paramref name="typeName" />.</span></span></param>
        <summary><span data-ttu-id="be398-671">Создает новый экземпляр заданного типа.</span><span class="sxs-lookup"><span data-stu-id="be398-671">Creates a new instance of the specified type.</span></span> <span data-ttu-id="be398-672">Параметры определяют имя типа, а также способ его поиска и создания.</span><span class="sxs-lookup"><span data-stu-id="be398-672">Parameters specify the name of the type, and how it is found and created.</span></span></summary>
        <returns><span data-ttu-id="be398-673">Экземпляр объекта, заданного параметром <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-673">An instance of the object specified by <paramref name="typeName" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-674">Это удобный метод, который сочетает <xref:System.AppDomain.CreateInstance%2A> и. <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="be398-674">This is a convenience method that combines <xref:System.AppDomain.CreateInstance%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="be398-675">См <xref:System.Reflection.AssemblyName> `assemblyName`. раздел для формата.</span><span class="sxs-lookup"><span data-stu-id="be398-675">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span> <span data-ttu-id="be398-676">`typeName`См. <xref:System.Type.FullName%2A?displayProperty=nameWithType> свойство в формате.</span><span class="sxs-lookup"><span data-stu-id="be398-676">See the <xref:System.Type.FullName%2A?displayProperty=nameWithType> property for the format of `typeName`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="be398-677">Если выполнить вызов с ранней привязкой к методу `M` объекта типа `T1` , возвращенного <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>методом, и этот метод выполняет вызов метода с ранней привязкой к методу объекта типа `T2` в сборке `C` , отличной от Текущая сборка или сборка, содержащая `T1`сборку `C` , загружается в текущий домен приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-677">If you make an early-bound call to a method `M` of an object of type `T1` that was returned by <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, and that method makes an early-bound call to a method of an object of type `T2` in an assembly `C` other than the current assembly or the assembly containing `T1`, assembly `C` is loaded into the current application domain.</span></span> <span data-ttu-id="be398-678">Эта загрузка происходит даже в том случае, если вызов `T1.M()` с ранней привязкой был сделан в теле <xref:System.Reflection.Emit.DynamicMethod>или в другом динамически создаваемом коде.</span><span class="sxs-lookup"><span data-stu-id="be398-678">This loading occurs even if the early-bound call to `T1.M()` was made in the body of a <xref:System.Reflection.Emit.DynamicMethod>, or in other dynamically generated code.</span></span> <span data-ttu-id="be398-679">Если текущий домен является доменом по умолчанию, `C` сборка не может быть выгружена до завершения процесса.</span><span class="sxs-lookup"><span data-stu-id="be398-679">If the current domain is the default domain, assembly `C` cannot be unloaded until the process ends.</span></span> <span data-ttu-id="be398-680">Если текущий домен позже попытается загрузить сборку `C`, может произойти сбой загрузки.</span><span class="sxs-lookup"><span data-stu-id="be398-680">If the current domain later attempts to load assembly `C`, the load might fail.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-681">В следующем примере демонстрируется использование `ignoreCase` параметра.</span><span class="sxs-lookup"><span data-stu-id="be398-681">The following sample demonstrates the use of the `ignoreCase` parameter.</span></span>  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-682">Значение параметра <paramref name="assemblyName" /> или <paramref name="typeName" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-682"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="be398-683">Соответствующий конструктор не найден.</span><span class="sxs-lookup"><span data-stu-id="be398-683">No matching constructor was found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="be398-684">Не удалось найти <paramref name="typename" /> в <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-684"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="be398-685">Не удалось найти <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-685"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="be398-686">Вызывающий объект не имеет разрешения на вызов этого конструктора.</span><span class="sxs-lookup"><span data-stu-id="be398-686">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="be398-687">Вызывающий объект не может предоставить атрибуты активации для объекта, который не является производным от <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="be398-687">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-688">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-688">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="be398-689">Сборка, определенная параметром <paramref name="assemblyName" />, является недопустимой.</span><span class="sxs-lookup"><span data-stu-id="be398-689"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="be398-690">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-690">-or-</span></span> 
<span data-ttu-id="be398-691">В настоящий момент загружена версия 2.0 среды CLR, а параметр <paramref name="assemblyName" /> был скомпилирован в более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="be398-691">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="be398-692">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</span><span class="sxs-lookup"><span data-stu-id="be398-692">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="be398-693">для возможности чтения файла, содержащего манифест сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-693">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="be398-694">Связанное перечисление:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="be398-694">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="be398-695">значение для возможности доступа к расположению сборки, если сборка не является локальной.</span><span class="sxs-lookup"><span data-stu-id="be398-695">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="be398-696">для загрузки сборки с свидетельством.</span><span class="sxs-lookup"><span data-stu-id="be398-696">to load an assembly with evidence.</span></span> <span data-ttu-id="be398-697">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="be398-697">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="be398-698">для возможности вызова операций для всех членов типа.</span><span class="sxs-lookup"><span data-stu-id="be398-698">for the ability to invoke operations on all type members.</span></span> <span data-ttu-id="be398-699">Связанное перечисление:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="be398-699">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="be398-700">Создает новый экземпляр заданного типа, определенного в указанном файле сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-700">Creates a new instance of a specified type defined in the specified assembly file.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="be398-701">Имя (включая путь) файла, который содержит сборку, определяющую запрошенный тип.</span><span class="sxs-lookup"><span data-stu-id="be398-701">The name, including the path, of a file that contains an assembly that defines the requested type.</span></span> <span data-ttu-id="be398-702">Сборка загружается с помощью метода <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />.</span><span class="sxs-lookup"><span data-stu-id="be398-702">The assembly is loaded using the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method.</span></span></param>
        <param name="typeName"><span data-ttu-id="be398-703">Полное имя запрошенного типа, включая пространство имен, но не сборку (см. описание свойства <see cref="P:System.Type.FullName" />).</span><span class="sxs-lookup"><span data-stu-id="be398-703">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <summary><span data-ttu-id="be398-704">Создает новый экземпляр заданного типа, определенного в указанном файле сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-704">Creates a new instance of the specified type defined in the specified assembly file.</span></span></summary>
        <returns><span data-ttu-id="be398-705">Объект, являющийся оболочкой для нового экземпляра, или значение <see langword="null" />, если <paramref name="typeName" /> не найден.</span><span class="sxs-lookup"><span data-stu-id="be398-705">An object that is a wrapper for the new instance, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span> <span data-ttu-id="be398-706">Необходимо распаковать возвращенное значение, чтобы получить доступ к реальному объекту.</span><span class="sxs-lookup"><span data-stu-id="be398-706">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-707">Вызывается конструктор без параметров `typeName` для метода.</span><span class="sxs-lookup"><span data-stu-id="be398-707">The parameterless constructor for `typeName` is invoked.</span></span>  
  
 <span data-ttu-id="be398-708">Дополнительные сведения см. в описании метода <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="be398-708">For more information, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="be398-709"><xref:System.AppDomain.CreateInstanceFrom%2A> Если метод используется для создания экземпляра в домене целевого приложения, отличном от домена приложения, из которого выполняется вызов, сборка загружается в целевой домен приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-709">When the <xref:System.AppDomain.CreateInstanceFrom%2A> method is used to create an instance in a target application domain, other than the application domain from which the call is made, the assembly is loaded in the target application domain.</span></span> <span data-ttu-id="be398-710">Однако если экземпляр не упакован в вызывающий домен приложения, использование неупакованного экземпляра в определенных случаях может привести к загрузке сборки в домен вызывающего приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-710">However, if the instance is unwrapped in the calling application domain, using the unwrapped instance in certain ways can cause the assembly to be loaded into the calling application domain.</span></span> <span data-ttu-id="be398-711">Например, после развернутого экземпляра можно запросить сведения о его типе, чтобы вызвать его методы с поздней привязкой.</span><span class="sxs-lookup"><span data-stu-id="be398-711">For example, after the instance is unwrapped, its type information might be requested, in order to call its methods late-bound.</span></span> <span data-ttu-id="be398-712">При загрузке сборки в домен вызывающего приложения могут возникать исключения.</span><span class="sxs-lookup"><span data-stu-id="be398-712">When the assembly is loaded into the calling application domain, exceptions can occur.</span></span>  
  
-   <span data-ttu-id="be398-713">Если другая версия той же сборки была ранее загружена в домен вызывающего приложения или если путь загрузки вызывающего домена приложения отличается от пути к целевому домену приложения, <xref:System.MissingMethodException> могут возникнуть исключения, например.</span><span class="sxs-lookup"><span data-stu-id="be398-713">If another version of the same assembly was previously loaded into the calling application domain, or if the load path of the calling application domain is different from that of the target application domain, exceptions such as <xref:System.MissingMethodException> can occur.</span></span>  
  
-   <span data-ttu-id="be398-714">Если вызывающий домен приложения выполняет вызовы с ранней привязкой к типу экземпляра <xref:System.InvalidCastException> , то при попытке приведения экземпляра может возникнуть исключение.</span><span class="sxs-lookup"><span data-stu-id="be398-714">If the calling application domain makes early-bound calls to the instance type, <xref:System.InvalidCastException> can be thrown when an attempt is made to cast the instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-715">В следующем примере показано, как использовать <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> перегрузку метода для создания экземпляра объекта в целевом домене приложения и вызова его методов.</span><span class="sxs-lookup"><span data-stu-id="be398-715">The following example shows how to use the <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> method overload to create an instance of an object in a target application domain and call its methods.</span></span>  
  
 <span data-ttu-id="be398-716">В примере определяется `MarshalableExample` класс, который можно маршалировать между границами домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-716">The example defines the `MarshalableExample` class, which can be marshaled across application domain boundaries.</span></span> <span data-ttu-id="be398-717">В этом примере выполняется сборка пути к выполняемой в данный момент сборке, создание целевого домена приложения и использование <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> перегрузки метода для загрузки сборки примера в целевой домен приложения и создания `MarshalableExample`экземпляра.</span><span class="sxs-lookup"><span data-stu-id="be398-717">The example builds a path to the currently executing assembly, creates a target application domain, and uses the <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> method overload to load the example assembly into the target application domain and create an instance of `MarshalableExample`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="be398-718">В этом примере путь является абсолютным, но относительный путь также будет работать, <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> поскольку метод используется для загрузки сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-718">The path is absolute in this example, but a relative path would also work because the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> method is used to load the assembly.</span></span>  
  
 <span data-ttu-id="be398-719">После распаковки маркера объекта в примере демонстрируются три способа использования объекта в целевом домене приложения:</span><span class="sxs-lookup"><span data-stu-id="be398-719">After unwrapping the object handle, the example demonstrates three ways to use an object in a target application domain:</span></span>  
  
-   <span data-ttu-id="be398-720">Вызов метода с поздним связыванием с помощью отражения.</span><span class="sxs-lookup"><span data-stu-id="be398-720">Invoking a method with late binding, using reflection.</span></span> <span data-ttu-id="be398-721">Для этого требуются сведения о типе, что приводит к загрузке сборки в домен приложения вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="be398-721">This requires type information, which causes the assembly to be loaded into the application domain of the caller.</span></span> <span data-ttu-id="be398-722">(В этом примере он уже загружен.)</span><span class="sxs-lookup"><span data-stu-id="be398-722">(In this example, it is already loaded.)</span></span>  
  
-   <span data-ttu-id="be398-723">Приведение объекта к интерфейсу, известному как вызывающему, так и вызываемому.</span><span class="sxs-lookup"><span data-stu-id="be398-723">Casting the object to an interface known to both the caller and the callee.</span></span> <span data-ttu-id="be398-724">Если интерфейс определен в вызывающей сборке или в третьей сборке, на которую ссылается вызывающий и вызываемый объект, то вызываемая сборка не загружается в домен приложения вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="be398-724">If the interface is defined in the calling assembly or in a third assembly referenced by both the caller and the callee, the called assembly is not loaded into the application domain of the caller.</span></span>  
  
-   <span data-ttu-id="be398-725">Использование объекта непосредственно, если его тип известен вызывающему объекту.</span><span class="sxs-lookup"><span data-stu-id="be398-725">Using the object directly when its type is known to the caller.</span></span> <span data-ttu-id="be398-726">Сборка должна быть загружена в домен приложения вызывающей стороны.</span><span class="sxs-lookup"><span data-stu-id="be398-726">The assembly must be loaded into the application domain of the caller.</span></span>  
  
 <span data-ttu-id="be398-727">Другой способ избежать загрузки вызываемой сборки в домен приложения вызывающего объекта заключается в том, чтобы вызывающий объект был производным от <xref:System.MarshalByRefObject> класса и был определен метод, который может выполняться в целевом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-727">Another way to avoid loading the called assembly into the application domain of the caller is for the caller to derive from the <xref:System.MarshalByRefObject> class and to define a method that can be run in the target application domain.</span></span> <span data-ttu-id="be398-728">Этот метод может использовать отражение для проверки целевой сборки, так как целевая сборка уже загружена в целевой домен приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-728">That method can use reflection to examine a target assembly, because the target assembly is already loaded into the target application domain.</span></span> <span data-ttu-id="be398-729">См. пример для <xref:System.AppDomain.DynamicDirectory%2A> свойства.</span><span class="sxs-lookup"><span data-stu-id="be398-729">See the example for the <xref:System.AppDomain.DynamicDirectory%2A> property.</span></span>  
  
 [!code-cpp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cpp/example.cpp#1)]
 [!code-csharp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cs/example.cs#1)]
 [!code-vb[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-730">Свойство <paramref name="assemblyFile" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-730"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="be398-731">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-731">-or-</span></span> 
 <span data-ttu-id="be398-732"><paramref name="typeName" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-732"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="be398-733">Файл <paramref name="assemblyFile" /> не найден.</span><span class="sxs-lookup"><span data-stu-id="be398-733"><paramref name="assemblyFile" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="be398-734"><paramref name="typeName" /> в сборке <paramref name="assemblyFile" /> не найден.</span><span class="sxs-lookup"><span data-stu-id="be398-734"><paramref name="typeName" /> was not found in <paramref name="assemblyFile" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-735">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-735">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="be398-736">Открытый конструктор без параметров не найден.</span><span class="sxs-lookup"><span data-stu-id="be398-736">No parameterless public constructor was found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="be398-737">Вызывающий код не имеет достаточных разрешений на вызов этого конструктора.</span><span class="sxs-lookup"><span data-stu-id="be398-737">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="be398-738"><paramref name="assemblyFile" /> не является допустимой сборкой.</span><span class="sxs-lookup"><span data-stu-id="be398-738"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="be398-739">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-739">-or-</span></span> 
<span data-ttu-id="be398-740">В настоящий момент загружена версия 2.0 среды CLR, а параметр <paramref name="assemblyFile" /> был скомпилирован в более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="be398-740">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="be398-741">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</span><span class="sxs-lookup"><span data-stu-id="be398-741">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="be398-742">Этот экземпляр имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-742">This instance is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="be398-743">для возможности чтения файла, содержащего манифест сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-743">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="be398-744">Связанное перечисление:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="be398-744">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="be398-745">значение для возможности доступа к расположению сборки, если сборка не является локальной.</span><span class="sxs-lookup"><span data-stu-id="be398-745">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="2" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="be398-746">Имя (включая путь) файла, который содержит сборку, определяющую запрошенный тип.</span><span class="sxs-lookup"><span data-stu-id="be398-746">The name, including the path, of a file that contains an assembly that defines the requested type.</span></span> <span data-ttu-id="be398-747">Сборка загружается с помощью метода <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />.</span><span class="sxs-lookup"><span data-stu-id="be398-747">The assembly is loaded using the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method.</span></span></param>
        <param name="typeName"><span data-ttu-id="be398-748">Полное имя запрошенного типа, включая пространство имен, но не сборку (см. описание свойства <see cref="P:System.Type.FullName" />).</span><span class="sxs-lookup"><span data-stu-id="be398-748">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="be398-749">Массив, состоящий из одного или нескольких атрибутов, которые могут участвовать в активации.</span><span class="sxs-lookup"><span data-stu-id="be398-749">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="be398-750">Обычно это массив, содержащий один объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />, определяющий URL-адрес, необходимый для активации удаленного объекта.</span><span class="sxs-lookup"><span data-stu-id="be398-750">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="be398-751">Этот параметр связан с объектами, активируемыми клиентом. Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений.</span><span class="sxs-lookup"><span data-stu-id="be398-751">This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="be398-752">Сейчас в распределенных приложениях следует использовать Windows Communication Foundation.</span><span class="sxs-lookup"><span data-stu-id="be398-752">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="be398-753">Создает новый экземпляр заданного типа, определенного в указанном файле сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-753">Creates a new instance of the specified type defined in the specified assembly file.</span></span></summary>
        <returns><span data-ttu-id="be398-754">Объект, являющийся оболочкой для нового экземпляра, или значение <see langword="null" />, если <paramref name="typeName" /> не найден.</span><span class="sxs-lookup"><span data-stu-id="be398-754">An object that is a wrapper for the new instance, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span> <span data-ttu-id="be398-755">Необходимо распаковать возвращенное значение, чтобы получить доступ к реальному объекту.</span><span class="sxs-lookup"><span data-stu-id="be398-755">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-756">Вызывается конструктор без параметров `typeName` для метода.</span><span class="sxs-lookup"><span data-stu-id="be398-756">The parameterless constructor for `typeName` is invoked.</span></span>  
  
 <span data-ttu-id="be398-757">Дополнительные сведения об этом методе см. в <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> описании метода.</span><span class="sxs-lookup"><span data-stu-id="be398-757">For more information about this method, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="be398-758"><xref:System.AppDomain.CreateInstanceFrom%2A> Если метод используется для создания экземпляра в домене целевого приложения, отличном от домена приложения, из которого выполняется вызов, сборка загружается в целевой домен приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-758">When the <xref:System.AppDomain.CreateInstanceFrom%2A> method is used to create an instance in a target application domain, other than the application domain from which the call is made, the assembly is loaded in the target application domain.</span></span> <span data-ttu-id="be398-759">Однако если экземпляр не упакован в вызывающий домен приложения, использование неупакованного экземпляра в определенных случаях может привести к загрузке сборки в домен вызывающего приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-759">However, if the instance is unwrapped in the calling application domain, using the unwrapped instance in certain ways can cause the assembly to be loaded into the calling application domain.</span></span> <span data-ttu-id="be398-760">Например, после развернутого экземпляра можно запросить сведения о его типе, чтобы вызвать его методы с поздней привязкой.</span><span class="sxs-lookup"><span data-stu-id="be398-760">For example, after the instance is unwrapped, its type information might be requested, in order to call its methods late-bound.</span></span> <span data-ttu-id="be398-761">При загрузке сборки в домен вызывающего приложения могут возникать исключения.</span><span class="sxs-lookup"><span data-stu-id="be398-761">When the assembly is loaded into the calling application domain, exceptions can occur.</span></span>  
  
-   <span data-ttu-id="be398-762">Если другая версия той же сборки была ранее загружена в домен вызывающего приложения или если путь загрузки вызывающего домена приложения отличается от пути к целевому домену приложения, <xref:System.MissingMethodException> могут возникнуть исключения, например.</span><span class="sxs-lookup"><span data-stu-id="be398-762">If another version of the same assembly was previously loaded into the calling application domain, or if the load path of the calling application domain is different from that of the target application domain, exceptions such as <xref:System.MissingMethodException> can occur.</span></span>  
  
-   <span data-ttu-id="be398-763">Если вызывающий домен приложения выполняет вызовы с ранней привязкой к типу экземпляра <xref:System.InvalidCastException> , то при попытке приведения экземпляра может возникнуть исключение.</span><span class="sxs-lookup"><span data-stu-id="be398-763">If the calling application domain makes early-bound calls to the instance type, <xref:System.InvalidCastException> can be thrown when an attempt is made to cast the instance.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-764">Свойство <paramref name="assemblyFile" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-764"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="be398-765">Файл <paramref name="assemblyFile" /> не найден.</span><span class="sxs-lookup"><span data-stu-id="be398-765"><paramref name="assemblyFile" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="be398-766">Не удалось найти <paramref name="typeName" /> в <paramref name="assemblyFile" />.</span><span class="sxs-lookup"><span data-stu-id="be398-766"><paramref name="typeName" /> was not found in <paramref name="assemblyFile" />.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="be398-767">Вызывающий объект не имеет достаточно разрешений для вызова этого конструктора.</span><span class="sxs-lookup"><span data-stu-id="be398-767">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="be398-768">Соответствующий общий конструктор не найден.</span><span class="sxs-lookup"><span data-stu-id="be398-768">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="be398-769">Вызывающий объект не может предоставить атрибуты активации для объекта, который не является производным от <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="be398-769">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-770">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-770">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="be398-771">Сборка, определенная параметром <paramref name="assemblyFile" />, является недопустимой.</span><span class="sxs-lookup"><span data-stu-id="be398-771"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="be398-772">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-772">-or-</span></span> 
<span data-ttu-id="be398-773">В настоящий момент загружена версия 2.0 среды CLR, а параметр <paramref name="assemblyFile" /> был скомпилирован в более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="be398-773">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="be398-774">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</span><span class="sxs-lookup"><span data-stu-id="be398-774">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="be398-775">Этот экземпляр имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-775">This instance is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="be398-776">для возможности чтения файла, содержащего манифест сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-776">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="be398-777">Связанное перечисление:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="be398-777">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="be398-778">значение для возможности доступа к расположению сборки, если сборка не является локальной.</span><span class="sxs-lookup"><span data-stu-id="be398-778">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="be398-779">Имя (включая путь) файла, который содержит сборку, определяющую запрошенный тип.</span><span class="sxs-lookup"><span data-stu-id="be398-779">The name, including the path, of a file that contains an assembly that defines the requested type.</span></span> <span data-ttu-id="be398-780">Сборка загружается с помощью метода <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />.</span><span class="sxs-lookup"><span data-stu-id="be398-780">The assembly is loaded using the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method.</span></span></param>
        <param name="typeName"><span data-ttu-id="be398-781">Полное имя запрошенного типа, включая пространство имен, но не сборку (см. описание свойства <see cref="P:System.Type.FullName" />).</span><span class="sxs-lookup"><span data-stu-id="be398-781">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="be398-782">Логическое значение, указывающее, следует ли учитывать регистр при поиске.</span><span class="sxs-lookup"><span data-stu-id="be398-782">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="be398-783">Сочетание битовых флагов, влияющих на поиск конструктора <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-783">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="be398-784">Если значение параметра <paramref name="bindingAttr" /> равно нулю, проводится поиск открытых конструкторов с учетом регистра.</span><span class="sxs-lookup"><span data-stu-id="be398-784">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="be398-785">Объект, который допускает привязку, приведение типов аргументов, вызов элементов и извлечение объектов <see cref="T:System.Reflection.MemberInfo" /> путем отражения.</span><span class="sxs-lookup"><span data-stu-id="be398-785">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects through reflection.</span></span> <span data-ttu-id="be398-786">Если значением параметра <paramref name="binder" /> является null, то используется средство связывания по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="be398-786">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="be398-787">Аргументы для передачи конструктору.</span><span class="sxs-lookup"><span data-stu-id="be398-787">The arguments to pass to the constructor.</span></span> <span data-ttu-id="be398-788">Массив аргументов должен соответствовать по числу, порядку и типу параметров вызываемому конструктору.</span><span class="sxs-lookup"><span data-stu-id="be398-788">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="be398-789">Если предпочтителен конструктор без параметров, то объект <paramref name="args" /> должен быть пустым массивом или значением NULL.</span><span class="sxs-lookup"><span data-stu-id="be398-789">If the parameterless constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="be398-790">Сведения о языке и региональных параметрах, которые влияют на приведение <paramref name="args" /> к формальным типам, объявленным для конструктора <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-790">Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="be398-791">Если параметр <paramref name="culture" /> имеет значение <see langword="null" />, для текущего потока используется объект <see cref="T:System.Globalization.CultureInfo" />.</span><span class="sxs-lookup"><span data-stu-id="be398-791">If <paramref name="culture" /> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="be398-792">Массив, состоящий из одного или нескольких атрибутов, которые могут участвовать в активации.</span><span class="sxs-lookup"><span data-stu-id="be398-792">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="be398-793">Обычно это массив, содержащий один объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />, определяющий URL-адрес, необходимый для активации удаленного объекта.</span><span class="sxs-lookup"><span data-stu-id="be398-793">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="be398-794">Этот параметр связан с объектами, активируемыми клиентом.</span><span class="sxs-lookup"><span data-stu-id="be398-794">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="be398-795">Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений.</span><span class="sxs-lookup"><span data-stu-id="be398-795">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="be398-796">Сейчас в распределенных приложениях следует использовать Windows Communication Foundation.</span><span class="sxs-lookup"><span data-stu-id="be398-796">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="be398-797">Создает новый экземпляр заданного типа, определенного в указанном файле сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-797">Creates a new instance of the specified type defined in the specified assembly file.</span></span></summary>
        <returns><span data-ttu-id="be398-798">Объект, являющийся оболочкой для нового экземпляра, или значение <see langword="null" />, если <paramref name="typeName" /> не найден.</span><span class="sxs-lookup"><span data-stu-id="be398-798">An object that is a wrapper for the new instance, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span> <span data-ttu-id="be398-799">Необходимо распаковать возвращенное значение, чтобы получить доступ к реальному объекту.</span><span class="sxs-lookup"><span data-stu-id="be398-799">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-800">Дополнительные сведения см. в описании метода <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="be398-800">For more information, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="be398-801"><xref:System.AppDomain.CreateInstanceFrom%2A> Если метод используется для создания экземпляра в домене целевого приложения, отличном от домена приложения, из которого выполняется вызов, сборка загружается в целевой домен приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-801">When the <xref:System.AppDomain.CreateInstanceFrom%2A> method is used to create an instance in a target application domain, other than the application domain from which the call is made, the assembly is loaded in the target application domain.</span></span> <span data-ttu-id="be398-802">Однако если экземпляр не упакован в вызывающий домен приложения, использование неупакованного экземпляра в определенных случаях может привести к загрузке сборки в домен вызывающего приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-802">However, if the instance is unwrapped in the calling application domain, using the unwrapped instance in certain ways can cause the assembly to be loaded into the calling application domain.</span></span> <span data-ttu-id="be398-803">Например, после развернутого экземпляра можно запросить сведения о его типе, чтобы вызвать его методы с поздней привязкой.</span><span class="sxs-lookup"><span data-stu-id="be398-803">For example, after the instance is unwrapped, its type information might be requested, in order to call its methods late-bound.</span></span> <span data-ttu-id="be398-804">При загрузке сборки в домен вызывающего приложения могут возникать исключения.</span><span class="sxs-lookup"><span data-stu-id="be398-804">When the assembly is loaded into the calling application domain, exceptions can occur.</span></span>  
  
-   <span data-ttu-id="be398-805">Если другая версия той же сборки была ранее загружена в домен вызывающего приложения или если путь загрузки вызывающего домена приложения отличается от пути к целевому домену приложения, <xref:System.MissingMethodException> могут возникнуть исключения, например.</span><span class="sxs-lookup"><span data-stu-id="be398-805">If another version of the same assembly was previously loaded into the calling application domain, or if the load path of the calling application domain is different from that of the target application domain, exceptions such as <xref:System.MissingMethodException> can occur.</span></span>  
  
-   <span data-ttu-id="be398-806">Если вызывающий домен приложения выполняет вызовы с ранней привязкой к типу экземпляра <xref:System.InvalidCastException> , то при попытке приведения экземпляра может возникнуть исключение.</span><span class="sxs-lookup"><span data-stu-id="be398-806">If the calling application domain makes early-bound calls to the instance type, <xref:System.InvalidCastException> can be thrown when an attempt is made to cast the instance.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-807"><paramref name="assemblyFile" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-807"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="be398-808">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-808">-or-</span></span> 
 <span data-ttu-id="be398-809"><paramref name="typeName" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-809"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="be398-810">Вызывающий объект не может предоставить атрибуты активации для объекта, который не является производным от <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="be398-810">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-811">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-811">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="be398-812">Не удалось найти <paramref name="assemblyFile" />.</span><span class="sxs-lookup"><span data-stu-id="be398-812"><paramref name="assemblyFile" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="be398-813"><paramref name="typeName" /> не найден в <paramref name="assemblyFile" />.</span><span class="sxs-lookup"><span data-stu-id="be398-813"><paramref name="typeName" /> was not found in <paramref name="assemblyFile" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="be398-814">Соответствующий общий конструктор не найден.</span><span class="sxs-lookup"><span data-stu-id="be398-814">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="be398-815">Вызывающий объект не имеет достаточно разрешений для вызова этого конструктора.</span><span class="sxs-lookup"><span data-stu-id="be398-815">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="be398-816"><paramref name="assemblyFile" /> не является допустимой сборкой.</span><span class="sxs-lookup"><span data-stu-id="be398-816"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="be398-817">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-817">-or-</span></span> 
 <span data-ttu-id="be398-818">Сборка <paramref name="assemblyFile" /> была скомпилирована в более поздней версии среды CLR, чем версия, загруженная в текущий момент.</span><span class="sxs-lookup"><span data-stu-id="be398-818"><paramref name="assemblyFile" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="be398-819">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</span><span class="sxs-lookup"><span data-stu-id="be398-819">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="be398-820">Этот экземпляр имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-820">This instance is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="be398-821">для возможности чтения файла, содержащего манифест сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-821">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="be398-822">Связанное перечисление:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="be398-822">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="be398-823">значение для возможности доступа к расположению сборки, если сборка не является локальной.</span><span class="sxs-lookup"><span data-stu-id="be398-823">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" Index="8" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="be398-824">Имя (включая путь) файла, который содержит сборку, определяющую запрошенный тип.</span><span class="sxs-lookup"><span data-stu-id="be398-824">The name, including the path, of a file that contains an assembly that defines the requested type.</span></span> <span data-ttu-id="be398-825">Сборка загружается с помощью метода <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />.</span><span class="sxs-lookup"><span data-stu-id="be398-825">The assembly is loaded using the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method.</span></span></param>
        <param name="typeName"><span data-ttu-id="be398-826">Полное имя запрошенного типа, включая пространство имен, но не сборку (см. описание свойства <see cref="P:System.Type.FullName" />).</span><span class="sxs-lookup"><span data-stu-id="be398-826">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="be398-827">Логическое значение, указывающее, следует ли учитывать регистр при поиске.</span><span class="sxs-lookup"><span data-stu-id="be398-827">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="be398-828">Сочетание битовых флагов, влияющих на поиск конструктора <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-828">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="be398-829">Если значение параметра <paramref name="bindingAttr" /> равно нулю, проводится поиск открытых конструкторов с учетом регистра.</span><span class="sxs-lookup"><span data-stu-id="be398-829">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="be398-830">Объект, который допускает привязку, приведение типов аргументов, вызов элементов и извлечение объектов <see cref="T:System.Reflection.MemberInfo" /> путем отражения.</span><span class="sxs-lookup"><span data-stu-id="be398-830">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects through reflection.</span></span> <span data-ttu-id="be398-831">Если значением параметра <paramref name="binder" /> является null, то используется средство связывания по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="be398-831">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="be398-832">Аргументы для передачи конструктору.</span><span class="sxs-lookup"><span data-stu-id="be398-832">The arguments to pass to the constructor.</span></span> <span data-ttu-id="be398-833">Массив аргументов должен соответствовать по числу, порядку и типу параметров вызываемому конструктору.</span><span class="sxs-lookup"><span data-stu-id="be398-833">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="be398-834">Если предпочтителен конструктор без параметров, то объект <paramref name="args" /> должен быть пустым массивом или значением NULL.</span><span class="sxs-lookup"><span data-stu-id="be398-834">If the parameterless constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="be398-835">Сведения о языке и региональных параметрах, которые влияют на приведение <paramref name="args" /> к формальным типам, объявленным для конструктора <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-835">Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="be398-836">Если параметр <paramref name="culture" /> имеет значение <see langword="null" />, для текущего потока используется объект <see cref="T:System.Globalization.CultureInfo" />.</span><span class="sxs-lookup"><span data-stu-id="be398-836">If <paramref name="culture" /> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="be398-837">Массив, состоящий из одного или нескольких атрибутов, которые могут участвовать в активации.</span><span class="sxs-lookup"><span data-stu-id="be398-837">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="be398-838">Обычно это массив, содержащий один объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />, определяющий URL-адрес, необходимый для активации удаленного объекта.</span><span class="sxs-lookup"><span data-stu-id="be398-838">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="be398-839">Этот параметр связан с объектами, активируемыми клиентом.</span><span class="sxs-lookup"><span data-stu-id="be398-839">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="be398-840">Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений.</span><span class="sxs-lookup"><span data-stu-id="be398-840">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="be398-841">Сейчас в распределенных приложениях следует использовать Windows Communication Foundation.</span><span class="sxs-lookup"><span data-stu-id="be398-841">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <param name="securityAttributes"><span data-ttu-id="be398-842">Сведения, используемые для авторизации создания <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-842">Information used to authorize creation of <paramref name="typeName" />.</span></span></param>
        <summary><span data-ttu-id="be398-843">Создает новый экземпляр заданного типа, определенного в указанном файле сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-843">Creates a new instance of the specified type defined in the specified assembly file.</span></span></summary>
        <returns><span data-ttu-id="be398-844">Объект, являющийся оболочкой для нового экземпляра, или значение <see langword="null" />, если <paramref name="typeName" /> не найден.</span><span class="sxs-lookup"><span data-stu-id="be398-844">An object that is a wrapper for the new instance, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span> <span data-ttu-id="be398-845">Необходимо распаковать возвращенное значение, чтобы получить доступ к реальному объекту.</span><span class="sxs-lookup"><span data-stu-id="be398-845">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-846">Дополнительные сведения об этом методе см. в <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> описании метода.</span><span class="sxs-lookup"><span data-stu-id="be398-846">For more information about this method, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="be398-847"><xref:System.AppDomain.CreateInstanceFrom%2A> Если метод используется для создания экземпляра в домене целевого приложения, отличном от домена приложения, из которого выполняется вызов, сборка загружается в целевой домен приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-847">When the <xref:System.AppDomain.CreateInstanceFrom%2A> method is used to create an instance in a target application domain, other than the application domain from which the call is made, the assembly is loaded in the target application domain.</span></span> <span data-ttu-id="be398-848">Однако если экземпляр не упакован в вызывающий домен приложения, использование неупакованного экземпляра в определенных случаях может привести к загрузке сборки в домен вызывающего приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-848">However, if the instance is unwrapped in the calling application domain, using the unwrapped instance in certain ways can cause the assembly to be loaded into the calling application domain.</span></span> <span data-ttu-id="be398-849">Например, после развернутого экземпляра можно запросить сведения о его типе, чтобы вызвать его методы с поздней привязкой.</span><span class="sxs-lookup"><span data-stu-id="be398-849">For example, after the instance is unwrapped, its type information might be requested, in order to call its methods late-bound.</span></span> <span data-ttu-id="be398-850">При загрузке сборки в домен вызывающего приложения могут возникать исключения.</span><span class="sxs-lookup"><span data-stu-id="be398-850">When the assembly is loaded into the calling application domain, exceptions can occur.</span></span>  
  
-   <span data-ttu-id="be398-851">Если другая версия той же сборки была ранее загружена в домен вызывающего приложения или если путь загрузки вызывающего домена приложения отличается от пути к целевому домену приложения, <xref:System.MissingMethodException> могут возникнуть исключения, например.</span><span class="sxs-lookup"><span data-stu-id="be398-851">If another version of the same assembly was previously loaded into the calling application domain, or if the load path of the calling application domain is different from that of the target application domain, exceptions such as <xref:System.MissingMethodException> can occur.</span></span>  
  
-   <span data-ttu-id="be398-852">Если вызывающий домен приложения выполняет вызовы с ранней привязкой к типу экземпляра <xref:System.InvalidCastException> , то при попытке приведения экземпляра может возникнуть исключение.</span><span class="sxs-lookup"><span data-stu-id="be398-852">If the calling application domain makes early-bound calls to the instance type, <xref:System.InvalidCastException> can be thrown when an attempt is made to cast the instance.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-853"><paramref name="assemblyFile" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-853"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="be398-854">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-854">-or-</span></span> 
 <span data-ttu-id="be398-855">Свойство <paramref name="typeName" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-855"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="be398-856">Вызывающий объект не может предоставить атрибуты активации для объекта, который не является производным от <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="be398-856">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span>  
  
<span data-ttu-id="be398-857">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-857">-or-</span></span> 
 <span data-ttu-id="be398-858"><paramref name="securityAttributes" /> не является <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-858"><paramref name="securityAttributes" /> is not <see langword="null" />.</span></span> <span data-ttu-id="be398-859">Если не включена политика разграничения доступа кода для кода предыдущей версии, <paramref name="securityAttributes" /> должно иметь значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-859">When legacy CAS policy is not enabled, <paramref name="securityAttributes" /> should be <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-860">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-860">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="be398-861">Не удалось найти <paramref name="assemblyFile" />.</span><span class="sxs-lookup"><span data-stu-id="be398-861"><paramref name="assemblyFile" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="be398-862"><paramref name="typeName" /> не найден в <paramref name="assemblyFile" />.</span><span class="sxs-lookup"><span data-stu-id="be398-862"><paramref name="typeName" /> was not found in <paramref name="assemblyFile" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="be398-863">Соответствующий общий конструктор не найден.</span><span class="sxs-lookup"><span data-stu-id="be398-863">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="be398-864">Вызывающий объект не имеет достаточно разрешений для вызова этого конструктора.</span><span class="sxs-lookup"><span data-stu-id="be398-864">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="be398-865"><paramref name="assemblyFile" /> не является допустимой сборкой.</span><span class="sxs-lookup"><span data-stu-id="be398-865"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="be398-866">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-866">-or-</span></span> 
<span data-ttu-id="be398-867">В настоящий момент загружена версия 2.0 среды CLR, а параметр <paramref name="assemblyFile" /> был скомпилирован в более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="be398-867">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="be398-868">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</span><span class="sxs-lookup"><span data-stu-id="be398-868">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="be398-869">Этот экземпляр имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-869">This instance is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="be398-870">для возможности чтения файла, содержащего манифест сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-870">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="be398-871">Связанное перечисление:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="be398-871">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="be398-872">значение для возможности доступа к расположению сборки, если сборка не является локальной.</span><span class="sxs-lookup"><span data-stu-id="be398-872">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="be398-873">для предоставления свидетельства.</span><span class="sxs-lookup"><span data-stu-id="be398-873">to provide evidence.</span></span> <span data-ttu-id="be398-874">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="be398-874">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFromAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="be398-875">Создает новый экземпляр заданного типа, определенного в указанном файле сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-875">Creates a new instance of a specified type defined in the specified assembly file.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String) As Object" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName);" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyFile As String, typeName As String) As Object" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyFile, System::String ^ typeName);" FrameworkAlternate="netcore-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="be398-876">Имя файла и путь сборки, которая определяет запрошенный тип.</span><span class="sxs-lookup"><span data-stu-id="be398-876">The file name and path of the assembly that defines the requested type.</span></span></param>
        <param name="assemblyFile">To be added.</param>
        <param name="typeName"><span data-ttu-id="be398-877">Полное имя запрошенного типа, включая пространство имен, но не сборку (см. описание свойства <see cref="P:System.Type.FullName" />).</span><span class="sxs-lookup"><span data-stu-id="be398-877">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <summary><span data-ttu-id="be398-878">Создает новый экземпляр заданного типа, определенного в указанном файле сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-878">Creates a new instance of the specified type defined in the specified assembly file.</span></span></summary>
        <returns><span data-ttu-id="be398-879">Запрашиваемый объект или значение <see langword="null" />, если объект <paramref name="typeName" /> не найден.</span><span class="sxs-lookup"><span data-stu-id="be398-879">The requested object, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-880">Это удобный метод, который сочетает <xref:System.AppDomain.CreateInstanceFrom%2A> и. <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="be398-880">This is a convenience method that combines <xref:System.AppDomain.CreateInstanceFrom%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="be398-881">Этот метод вызывает конструктор без параметров для `typeName`.</span><span class="sxs-lookup"><span data-stu-id="be398-881">This method calls the parameterless constructor for `typeName`.</span></span>  
  
 <span data-ttu-id="be398-882">Дополнительные сведения см. в описании метода <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="be398-882">For more information, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-883">Свойство <paramref name="assemblyName" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-883"><paramref name="assemblyName" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="be398-884">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-884">-or-</span></span> 
 <span data-ttu-id="be398-885"><paramref name="typeName" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-885"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-886">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-886">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="be398-887">Не удалось найти <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-887"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="be398-888">Не удалось найти <paramref name="typeName" /> в <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-888"><paramref name="typeName" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="be398-889">Открытый конструктор без параметров не найден.</span><span class="sxs-lookup"><span data-stu-id="be398-889">No parameterless public constructor was found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="be398-890">Вызывающий код не имеет достаточных разрешений на вызов этого конструктора.</span><span class="sxs-lookup"><span data-stu-id="be398-890">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="be398-891"><paramref name="assemblyName" /> не является допустимой сборкой.</span><span class="sxs-lookup"><span data-stu-id="be398-891"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="be398-892">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-892">-or-</span></span> 
<span data-ttu-id="be398-893">В настоящий момент загружена версия 2.0 среды CLR, а параметр <paramref name="assemblyName" /> был скомпилирован в более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="be398-893">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="be398-894">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</span><span class="sxs-lookup"><span data-stu-id="be398-894">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="be398-895">для возможности чтения файла, содержащего манифест сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-895">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="be398-896">Связанное перечисление:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="be398-896">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="be398-897">значение для возможности доступа к расположению сборки, если сборка не является локальной.</span><span class="sxs-lookup"><span data-stu-id="be398-897">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * obj[] -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName, activationAttributes)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName, object[] activationAttributes);" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, object[] activationAttributes) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyFile As String, typeName As String, activationAttributes As Object()) As Object" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" FrameworkAlternate="netcore-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="2" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="be398-898">Имя файла и путь сборки, которая определяет запрошенный тип.</span><span class="sxs-lookup"><span data-stu-id="be398-898">The file name and path of the assembly that defines the requested type.</span></span></param>
        <param name="assemblyFile">To be added.</param>
        <param name="typeName"><span data-ttu-id="be398-899">Полное имя запрошенного типа, включая пространство имен, но не сборку (см. описание свойства <see cref="P:System.Type.FullName" />).</span><span class="sxs-lookup"><span data-stu-id="be398-899">The fully qualified name of the requested type, including the namespace but not the assembly (see the <see cref="P:System.Type.FullName" /> property).</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="be398-900">Массив, состоящий из одного или нескольких атрибутов, которые могут участвовать в активации.</span><span class="sxs-lookup"><span data-stu-id="be398-900">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="be398-901">Обычно это массив, содержащий один объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />, определяющий URL-адрес, необходимый для активации удаленного объекта.</span><span class="sxs-lookup"><span data-stu-id="be398-901">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="be398-902">Этот параметр связан с объектами, активируемыми клиентом. Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений.</span><span class="sxs-lookup"><span data-stu-id="be398-902">This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="be398-903">Сейчас в распределенных приложениях следует использовать Windows Communication Foundation.</span><span class="sxs-lookup"><span data-stu-id="be398-903">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="be398-904">Создает новый экземпляр заданного типа, определенного в указанном файле сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-904">Creates a new instance of the specified type defined in the specified assembly file.</span></span></summary>
        <returns><span data-ttu-id="be398-905">Запрашиваемый объект или значение <see langword="null" />, если объект <paramref name="typeName" /> не найден.</span><span class="sxs-lookup"><span data-stu-id="be398-905">The requested object, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-906">Это удобный метод, который сочетает <xref:System.AppDomain.CreateInstanceFrom%2A> и. <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="be398-906">This is a convenience method that combines <xref:System.AppDomain.CreateInstanceFrom%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="be398-907">Этот метод вызывает конструктор без параметров для `typeName`.</span><span class="sxs-lookup"><span data-stu-id="be398-907">This method calls the parameterless constructor for `typeName`.</span></span>  
  
 <span data-ttu-id="be398-908">Дополнительные сведения об этом методе см. в <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> описании метода.</span><span class="sxs-lookup"><span data-stu-id="be398-908">For more information about this method, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-909"><paramref name="assemblyName" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-909"><paramref name="assemblyName" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="be398-910">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-910">-or-</span></span> 
 <span data-ttu-id="be398-911"><paramref name="typeName" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-911"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="be398-912">Вызывающий объект не может предоставить атрибуты активации для объекта, который не является производным от <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="be398-912">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-913">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-913">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="be398-914">Не удалось найти <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-914"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="be398-915">Не удалось найти <paramref name="typeName" /> в <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-915"><paramref name="typeName" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="be398-916">Открытый конструктор без параметров не найден.</span><span class="sxs-lookup"><span data-stu-id="be398-916">No parameterless public constructor was found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="be398-917">Вызывающий код не имеет достаточных разрешений на вызов этого конструктора.</span><span class="sxs-lookup"><span data-stu-id="be398-917">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="be398-918"><paramref name="assemblyName" /> не является допустимой сборкой.</span><span class="sxs-lookup"><span data-stu-id="be398-918"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="be398-919">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-919">-or-</span></span> 
<span data-ttu-id="be398-920">В настоящий момент загружена версия 2.0 среды CLR, а параметр <paramref name="assemblyName" /> был скомпилирован в более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="be398-920">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="be398-921">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</span><span class="sxs-lookup"><span data-stu-id="be398-921">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="be398-922">для возможности чтения файла, содержащего манифест сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-922">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="be398-923">Связанное перечисление:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="be398-923">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="be398-924">значение для возможности доступа к расположению сборки, если сборка не является локальной.</span><span class="sxs-lookup"><span data-stu-id="be398-924">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="be398-925">Имя файла и путь сборки, которая определяет запрошенный тип.</span><span class="sxs-lookup"><span data-stu-id="be398-925">The file name and path of the assembly that defines the requested type.</span></span></param>
        <param name="typeName"><span data-ttu-id="be398-926">Полное имя запрошенного типа, включая пространство имен, но не сборку (см. описание свойства <see cref="P:System.Type.FullName" />).</span><span class="sxs-lookup"><span data-stu-id="be398-926">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="be398-927">Логическое значение, указывающее, следует ли учитывать регистр при поиске.</span><span class="sxs-lookup"><span data-stu-id="be398-927">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="be398-928">Сочетание битовых флагов, влияющих на поиск конструктора <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-928">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="be398-929">Если значение параметра <paramref name="bindingAttr" /> равно нулю, проводится поиск открытых конструкторов с учетом регистра.</span><span class="sxs-lookup"><span data-stu-id="be398-929">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="be398-930">Объект, который допускает привязку, приведение типов аргументов, вызов элементов и извлечение объектов <see cref="T:System.Reflection.MemberInfo" /> путем отражения.</span><span class="sxs-lookup"><span data-stu-id="be398-930">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects through reflection.</span></span> <span data-ttu-id="be398-931">Если значением параметра <paramref name="binder" /> является null, то используется средство связывания по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="be398-931">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="be398-932">Аргументы для передачи конструктору.</span><span class="sxs-lookup"><span data-stu-id="be398-932">The arguments to pass to the constructor.</span></span> <span data-ttu-id="be398-933">Массив аргументов должен соответствовать по числу, порядку и типу параметров вызываемому конструктору.</span><span class="sxs-lookup"><span data-stu-id="be398-933">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="be398-934">Если предпочтителен конструктор без параметров, то объект <paramref name="args" /> должен быть пустым массивом или значением NULL.</span><span class="sxs-lookup"><span data-stu-id="be398-934">If the parameterless constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="be398-935">Сведения о языке и региональных параметрах, которые влияют на приведение <paramref name="args" /> к формальным типам, объявленным для конструктора <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-935">Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="be398-936">Если параметр <paramref name="culture" /> имеет значение <see langword="null" />, для текущего потока используется объект <see cref="T:System.Globalization.CultureInfo" />.</span><span class="sxs-lookup"><span data-stu-id="be398-936">If <paramref name="culture" /> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="be398-937">Массив, состоящий из одного или нескольких атрибутов, которые могут участвовать в активации.</span><span class="sxs-lookup"><span data-stu-id="be398-937">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="be398-938">Обычно это массив, содержащий один объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />, определяющий URL-адрес, необходимый для активации удаленного объекта.</span><span class="sxs-lookup"><span data-stu-id="be398-938">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="be398-939">Этот параметр связан с объектами, активируемыми клиентом.</span><span class="sxs-lookup"><span data-stu-id="be398-939">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="be398-940">Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений.</span><span class="sxs-lookup"><span data-stu-id="be398-940">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="be398-941">Сейчас в распределенных приложениях следует использовать Windows Communication Foundation.</span><span class="sxs-lookup"><span data-stu-id="be398-941">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="be398-942">Создает новый экземпляр заданного типа, определенного в заданном файле сборки, указывая, игнорируется ли регистр имени типа; атрибуты привязки и средство привязки, используемые для выбора создаваемого типа; аргументы конструктора; язык и региональные параметры; и атрибуты активации.</span><span class="sxs-lookup"><span data-stu-id="be398-942">Creates a new instance of the specified type defined in the specified assembly file, specifying whether the case of the type name is ignored; the binding attributes and the binder that are used to select the type to be created; the arguments of the constructor; the culture; and the activation attributes.</span></span></summary>
        <returns><span data-ttu-id="be398-943">Запрашиваемый объект или значение <see langword="null" />, если объект <paramref name="typeName" /> не найден.</span><span class="sxs-lookup"><span data-stu-id="be398-943">The requested object, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-944">Это удобный метод, который сочетает <xref:System.AppDomain.CreateInstanceFrom%2A> и. <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="be398-944">This is a convenience method that combines <xref:System.AppDomain.CreateInstanceFrom%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="be398-945">Дополнительные сведения об этом методе см. в <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> описании метода.</span><span class="sxs-lookup"><span data-stu-id="be398-945">For more information about this method, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-946"><paramref name="assemblyName" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-946"><paramref name="assemblyName" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="be398-947">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-947">-or-</span></span> 
 <span data-ttu-id="be398-948">Свойство <paramref name="typeName" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-948"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="be398-949">Вызывающий объект не может предоставить атрибуты активации для объекта, который не является производным от <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="be398-949">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-950">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-950">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="be398-951">Не удалось найти <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-951"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="be398-952"><paramref name="typeName" /> не найден в <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-952"><paramref name="typeName" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="be398-953">Соответствующий общий конструктор не найден.</span><span class="sxs-lookup"><span data-stu-id="be398-953">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="be398-954">Вызывающий объект не имеет достаточно разрешений для вызова этого конструктора.</span><span class="sxs-lookup"><span data-stu-id="be398-954">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="be398-955"><paramref name="assemblyName" /> не является допустимой сборкой.</span><span class="sxs-lookup"><span data-stu-id="be398-955"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="be398-956">-или-</span><span class="sxs-lookup"><span data-stu-id="be398-956">-or-</span></span> 
 <span data-ttu-id="be398-957">Сборка <paramref name="assemblyName" /> скомпилирована в более поздней версии среды CLR, чем версия, загруженная в текущий момент.</span><span class="sxs-lookup"><span data-stu-id="be398-957"><paramref name="assemblyName" /> was compiled with a later version of the common language runtime that the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="be398-958">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</span><span class="sxs-lookup"><span data-stu-id="be398-958">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="be398-959">для возможности чтения файла, содержащего манифест сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-959">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="be398-960">Связанное перечисление:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="be398-960">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="be398-961">значение для возможности доступа к расположению сборки, если сборка не является локальной.</span><span class="sxs-lookup"><span data-stu-id="be398-961">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFromAndUnwrap which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" Index="8" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="be398-962">Имя файла и путь сборки, которая определяет запрошенный тип.</span><span class="sxs-lookup"><span data-stu-id="be398-962">The file name and path of the assembly that defines the requested type.</span></span></param>
        <param name="typeName"><span data-ttu-id="be398-963">Полное имя запрошенного типа, включая пространство имен, но не сборку (см. описание свойства <see cref="P:System.Type.FullName" />).</span><span class="sxs-lookup"><span data-stu-id="be398-963">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="be398-964">Логическое значение, указывающее, следует ли учитывать регистр при поиске.</span><span class="sxs-lookup"><span data-stu-id="be398-964">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="be398-965">Сочетание битовых флагов, влияющих на поиск конструктора <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-965">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="be398-966">Если значение параметра <paramref name="bindingAttr" /> равно нулю, проводится поиск открытых конструкторов с учетом регистра.</span><span class="sxs-lookup"><span data-stu-id="be398-966">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="be398-967">Объект, который допускает привязку, приведение типов аргументов, вызов элементов и извлечение объектов <see cref="T:System.Reflection.MemberInfo" /> путем отражения.</span><span class="sxs-lookup"><span data-stu-id="be398-967">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects through reflection.</span></span> <span data-ttu-id="be398-968">Если значением параметра <paramref name="binder" /> является null, то используется средство связывания по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="be398-968">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="be398-969">Аргументы для передачи конструктору.</span><span class="sxs-lookup"><span data-stu-id="be398-969">The arguments to pass to the constructor.</span></span> <span data-ttu-id="be398-970">Массив аргументов должен соответствовать по числу, порядку и типу параметров вызываемому конструктору.</span><span class="sxs-lookup"><span data-stu-id="be398-970">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="be398-971">Если предпочтителен конструктор без параметров, то объект <paramref name="args" /> должен быть пустым массивом или значением NULL.</span><span class="sxs-lookup"><span data-stu-id="be398-971">If the parameterless constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="be398-972">Сведения о языке и региональных параметрах, которые влияют на приведение <paramref name="args" /> к формальным типам, объявленным для конструктора <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-972">Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="be398-973">Если параметр <paramref name="culture" /> имеет значение <see langword="null" />, для текущего потока используется объект <see cref="T:System.Globalization.CultureInfo" />.</span><span class="sxs-lookup"><span data-stu-id="be398-973">If <paramref name="culture" /> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="be398-974">Массив, состоящий из одного или нескольких атрибутов, которые могут участвовать в активации.</span><span class="sxs-lookup"><span data-stu-id="be398-974">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="be398-975">Обычно это массив, содержащий один объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />, определяющий URL-адрес, необходимый для активации удаленного объекта.</span><span class="sxs-lookup"><span data-stu-id="be398-975">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="be398-976">Этот параметр связан с объектами, активируемыми клиентом.</span><span class="sxs-lookup"><span data-stu-id="be398-976">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="be398-977">Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений.</span><span class="sxs-lookup"><span data-stu-id="be398-977">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="be398-978">Сейчас в распределенных приложениях следует использовать Windows Communication Foundation.</span><span class="sxs-lookup"><span data-stu-id="be398-978">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <param name="securityAttributes"><span data-ttu-id="be398-979">Сведения, используемые для авторизации создания <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-979">Information used to authorize creation of <paramref name="typeName" />.</span></span></param>
        <summary><span data-ttu-id="be398-980">Создает новый экземпляр заданного типа, определенного в указанном файле сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-980">Creates a new instance of the specified type defined in the specified assembly file.</span></span></summary>
        <returns><span data-ttu-id="be398-981">Запрашиваемый объект или значение <see langword="null" />, если объект <paramref name="typeName" /> не найден.</span><span class="sxs-lookup"><span data-stu-id="be398-981">The requested object, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-982">Это удобный метод, который сочетает <xref:System.AppDomain.CreateInstanceFrom%2A> и. <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="be398-982">This is a convenience method that combines <xref:System.AppDomain.CreateInstanceFrom%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="be398-983">Дополнительные сведения об этом методе см. в <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> описании метода.</span><span class="sxs-lookup"><span data-stu-id="be398-983">For more information about this method, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-984">Свойство <paramref name="assemblyName" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-984"><paramref name="assemblyName" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="be398-985">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-985">-or-</span></span> 
 <span data-ttu-id="be398-986">Свойство <paramref name="typeName" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-986"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="be398-987">Вызывающий объект не может предоставить атрибуты активации для объекта, который не является производным от <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="be398-987">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-988">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-988">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="be398-989">Не удалось найти <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-989"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="be398-990"><paramref name="typeName" /> не найден в <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-990"><paramref name="typeName" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="be398-991">Соответствующий общий конструктор не найден.</span><span class="sxs-lookup"><span data-stu-id="be398-991">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="be398-992">Вызывающий объект не имеет достаточно разрешений для вызова этого конструктора.</span><span class="sxs-lookup"><span data-stu-id="be398-992">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="be398-993"><paramref name="assemblyName" /> не является допустимой сборкой.</span><span class="sxs-lookup"><span data-stu-id="be398-993"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="be398-994">-или-</span><span class="sxs-lookup"><span data-stu-id="be398-994">-or-</span></span> 
<span data-ttu-id="be398-995">В настоящий момент загружена версия 2.0 среды CLR, а параметр <paramref name="assemblyName" /> был скомпилирован в более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="be398-995">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="be398-996">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</span><span class="sxs-lookup"><span data-stu-id="be398-996">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="be398-997">для возможности чтения файла, содержащего манифест сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-997">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="be398-998">Связанное перечисление:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="be398-998">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="be398-999">значение для возможности доступа к расположению сборки, если сборка не является локальной.</span><span class="sxs-lookup"><span data-stu-id="be398-999">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CurrentDomain { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.AppDomain CurrentDomain" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.CurrentDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentDomain As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property AppDomain ^ CurrentDomain { AppDomain ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDomain : AppDomain" Usage="System.AppDomain.CurrentDomain" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="be398-1000">Возвращает текущий домен приложения для текущего объекта <see cref="T:System.Threading.Thread" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1000">Gets the current application domain for the current <see cref="T:System.Threading.Thread" />.</span></span></summary>
        <value><span data-ttu-id="be398-1001">Текущий домен приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1001">The current application domain.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="be398-1002">В следующем примере кода создается новый домен приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1002">The following code example creates a new application domain.</span></span> <span data-ttu-id="be398-1003">Свойство используется для <xref:System.AppDomain> получения объекта, представляющего текущий домен приложения. <xref:System.AppDomain.CurrentDomain%2A></span><span class="sxs-lookup"><span data-stu-id="be398-1003">The <xref:System.AppDomain.CurrentDomain%2A> property is used to obtain an <xref:System.AppDomain> object that represents the current application domain.</span></span> <span data-ttu-id="be398-1004"><xref:System.AppDomain.FriendlyName%2A> Свойство предоставляет имя текущего домена приложения, которое затем отображается в командной строке.</span><span class="sxs-lookup"><span data-stu-id="be398-1004">The <xref:System.AppDomain.FriendlyName%2A> property provides the name of the current application domain, which is then displayed at the command line.</span></span>  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineDynamicAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="be398-1005">Определяет динамическую сборку в текущем домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1005">Defines a dynamic assembly in the current application domain.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="be398-1006">Уникальный идентификатор динамической сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1006">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="be398-1007">Режим доступа для динамической сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1007">The access mode for the dynamic assembly.</span></span></param>
        <summary><span data-ttu-id="be398-1008">Определяет динамическую сборку с указанным именем и режимом доступа.</span><span class="sxs-lookup"><span data-stu-id="be398-1008">Defines a dynamic assembly with the specified name and access mode.</span></span></summary>
        <returns><span data-ttu-id="be398-1009">Динамическая сборка с указанным именем и режимом доступа.</span><span class="sxs-lookup"><span data-stu-id="be398-1009">A dynamic assembly with the specified name and access mode.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-1010">Этот метод следует использовать только для определения динамической сборки в текущем домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1010">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="be398-1011">Дополнительные сведения см. в <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> разделе перегрузка метода.</span><span class="sxs-lookup"><span data-stu-id="be398-1011">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="be398-1012">Во время разработки кода, который создает динамические сборки, рекомендуется использовать перегрузку <xref:System.AppDomain.DefineDynamicAssembly%2A> метода, который задает свидетельство и разрешения, указать свидетельство, которое должна иметь динамическая сборка, и включить в <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> `refusedPermissions`.</span><span class="sxs-lookup"><span data-stu-id="be398-1012">During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="be398-1013"><xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> Включение `refusedPermissions`  в параметр гарантирует, что код MSIL будет проверен.</span><span class="sxs-lookup"><span data-stu-id="be398-1013">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="be398-1014">Ограничением этой методики является то, что оно <xref:System.Security.SecurityException> также вызывается при использовании с кодом, требующим полного доверия.</span><span class="sxs-lookup"><span data-stu-id="be398-1014">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-1015">В следующем примере демонстрируется <xref:System.AppDomain.DefineDynamicAssembly%2A> метод и <xref:System.AppDomain.AssemblyResolve> событие.</span><span class="sxs-lookup"><span data-stu-id="be398-1015">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="be398-1016">Для выполнения этого примера кода необходимо указать полное имя сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1016">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="be398-1017">Дополнительные сведения о получении полного имени сборки см. в разделе [имена сборок](~/docs/framework/app-domains/assembly-names.md).</span><span class="sxs-lookup"><span data-stu-id="be398-1017">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-1018"><paramref name="name" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1018"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be398-1019">Свойство <see langword="Name" /> параметра <paramref name="name" /> равно <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1019">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="be398-1020">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-1020">-or-</span></span> 
<span data-ttu-id="be398-1021">Значение свойства <see langword="Name" /> параметра <paramref name="name" /> начинается с пробела или содержит символ прямой (обратной) косой черты.</span><span class="sxs-lookup"><span data-stu-id="be398-1021">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-1022">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1022">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="be398-1023">Уникальный идентификатор динамической сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1023">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="be398-1024">Режим доступа для динамической сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1024">The access mode for the dynamic assembly.</span></span></param>
        <param name="assemblyAttributes"><span data-ttu-id="be398-1025">Перечислимый список атрибутов, которые будут применены к сборке, или значение <see langword="null" />, если атрибуты отсутствуют.</span><span class="sxs-lookup"><span data-stu-id="be398-1025">An enumerable list of attributes to be applied to the assembly, or <see langword="null" /> if there are no attributes.</span></span></param>
        <summary><span data-ttu-id="be398-1026">Определяет динамическую сборку с указанным именем, режимом доступа и настраиваемыми атрибутами.</span><span class="sxs-lookup"><span data-stu-id="be398-1026">Defines a dynamic assembly with the specified name, access mode, and custom attributes.</span></span></summary>
        <returns><span data-ttu-id="be398-1027">Динамическая сборка с указанным именем и возможностями.</span><span class="sxs-lookup"><span data-stu-id="be398-1027">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-1028">Используйте эту перегрузку метода, чтобы указать атрибуты, которые не работают должным образом, если они не применяются при создании динамической сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1028">Use this method overload to specify attributes that do not work correctly unless they are applied when a dynamic assembly is created.</span></span> <span data-ttu-id="be398-1029">Например, такие атрибуты безопасности, как <xref:System.Security.SecurityTransparentAttribute> и <xref:System.Security.SecurityCriticalAttribute> , работают неправильно, если они добавляются после создания динамической сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1029">For example, security attributes such as <xref:System.Security.SecurityTransparentAttribute> and <xref:System.Security.SecurityCriticalAttribute> do not work correctly if they are added after a dynamic assembly has been created.</span></span>  
  
 <span data-ttu-id="be398-1030">Этот метод следует использовать только для определения динамической сборки в текущем домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1030">This method should be used only to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="be398-1031">Дополнительные сведения об этом ограничении см. в <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> описании перегрузки метода.</span><span class="sxs-lookup"><span data-stu-id="be398-1031">For more information about this restriction, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
 <span data-ttu-id="be398-1032">Эта перегрузка метода появилась в [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].</span><span class="sxs-lookup"><span data-stu-id="be398-1032">This method overload is introduced in the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-1033">В следующем примере кода показано, как создать динамическую сборку, имеющую <xref:System.Security.SecurityTransparentAttribute>.</span><span class="sxs-lookup"><span data-stu-id="be398-1033">The following code sample shows how to create a dynamic assembly that has the <xref:System.Security.SecurityTransparentAttribute>.</span></span> <span data-ttu-id="be398-1034">Атрибут должен быть указан как элемент массива <xref:System.Reflection.Emit.CustomAttributeBuilder> объектов.</span><span class="sxs-lookup"><span data-stu-id="be398-1034">The attribute must be specified as an element of an array of <xref:System.Reflection.Emit.CustomAttributeBuilder> objects.</span></span>  
  
 <span data-ttu-id="be398-1035">Первым шагом в создании <xref:System.Reflection.Emit.CustomAttributeBuilder> является получение конструктора для атрибута.</span><span class="sxs-lookup"><span data-stu-id="be398-1035">The first step in creating the <xref:System.Reflection.Emit.CustomAttributeBuilder> is to obtain a constructor for the attribute.</span></span> <span data-ttu-id="be398-1036">Конструктор не имеет параметров, поэтому <xref:System.Type.GetConstructor%2A> метод вызывается с пустым <xref:System.Type> массивом объектов для представления типов параметров.</span><span class="sxs-lookup"><span data-stu-id="be398-1036">The constructor has no parameters, so the <xref:System.Type.GetConstructor%2A> method is called with an empty array of <xref:System.Type> objects to represent the types of the parameters.</span></span> <span data-ttu-id="be398-1037">Вторым шагом является передача результирующего <xref:System.Reflection.ConstructorInfo> объекта конструктору <xref:System.Reflection.Emit.CustomAttributeBuilder> класса, а также пустого массива типа <xref:System.Object> для представления аргументов.</span><span class="sxs-lookup"><span data-stu-id="be398-1037">The second step is to pass the resulting <xref:System.Reflection.ConstructorInfo> object to the constructor for the <xref:System.Reflection.Emit.CustomAttributeBuilder> class, together with an empty array of type <xref:System.Object> to represent the arguments.</span></span>  
  
 <span data-ttu-id="be398-1038">Полученный <xref:System.Reflection.Emit.CustomAttributeBuilder> результат затем передается <xref:System.AppDomain.DefineDynamicAssembly%2A> в метод как единственный элемент массива.</span><span class="sxs-lookup"><span data-stu-id="be398-1038">The resulting <xref:System.Reflection.Emit.CustomAttributeBuilder> is then passed to the <xref:System.AppDomain.DefineDynamicAssembly%2A> method as the only element of an array.</span></span>  
  
 <span data-ttu-id="be398-1039">В примере кода определяется модуль и тип в новой динамической сборке, а затем отображаются атрибуты сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1039">The example code defines a module and a type in the new dynamic assembly, and then displays the assembly's attributes.</span></span>  
  
 [!code-cpp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/cpp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cpp/source.cpp#1)]
 [!code-csharp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/csharp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cs/source.cs#1)]
 [!code-vb[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-1040"><paramref name="name" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1040"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be398-1041">Свойство <see langword="Name" /> параметра <paramref name="name" /> равно <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1041">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="be398-1042">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-1042">-or-</span></span> 
<span data-ttu-id="be398-1043">Значение свойства <see langword="Name" /> объекта <paramref name="name" /> начинается с пробела или содержит символ прямой (обратной) косой черты.</span><span class="sxs-lookup"><span data-stu-id="be398-1043">The <see langword="Name" /> property of <paramref name="name" /> starts with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-1044">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1044">The operation is attempted on an unloaded application domain.</span></span></exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, evidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="be398-1045">Уникальный идентификатор динамической сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1045">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="be398-1046">Режим, в котором будет осуществляться доступ к динамической сборке.</span><span class="sxs-lookup"><span data-stu-id="be398-1046">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="evidence"><span data-ttu-id="be398-1047">Свидетельство, предоставляемое для динамической сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1047">The evidence supplied for the dynamic assembly.</span></span> <span data-ttu-id="be398-1048">Используемое свидетельство является постоянным, как конечный набор свидетельств, используемых для разрешения политики.</span><span class="sxs-lookup"><span data-stu-id="be398-1048">The evidence is used unaltered as the final set of evidence used for policy resolution.</span></span></param>
        <summary><span data-ttu-id="be398-1049">Определяет динамическую сборку с помощью указанного имени, режима доступа и свидетельства.</span><span class="sxs-lookup"><span data-stu-id="be398-1049">Defines a dynamic assembly using the specified name, access mode, and evidence.</span></span></summary>
        <returns><span data-ttu-id="be398-1050">Динамическая сборка с указанным именем и возможностями.</span><span class="sxs-lookup"><span data-stu-id="be398-1050">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-1051">Только полностью доверенные вызывающие объекты могут `evidence` предоставлять их при определении <xref:System.Reflection.Assembly>динамического.</span><span class="sxs-lookup"><span data-stu-id="be398-1051">Only fully trusted callers can supply their `evidence` when defining a dynamic <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="be398-1052">Среда выполнения будет сопоставлять объект <xref:System.Security.Policy.Evidence> с помощью политики безопасности для определения предоставленных разрешений.</span><span class="sxs-lookup"><span data-stu-id="be398-1052">The runtime will map the <xref:System.Security.Policy.Evidence> through the security policy to determine the granted permissions.</span></span> <span data-ttu-id="be398-1053">Частично доверенные вызывающие объекты должны предоставлять `evidence`значение null.</span><span class="sxs-lookup"><span data-stu-id="be398-1053">Partially trusted callers must supply a null `evidence`.</span></span> <span data-ttu-id="be398-1054">Если `evidence` имеет `null`значение, среда выполнения копирует наборы разрешений, то есть текущие наборы Grant и DENY <xref:System.Reflection.Assembly> , от вызывающей стороны к динамически <xref:System.Reflection.Assembly> определяемому и помечает политику как разрешенную.</span><span class="sxs-lookup"><span data-stu-id="be398-1054">If `evidence` is `null`, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <xref:System.Reflection.Assembly> to the dynamic <xref:System.Reflection.Assembly> being defined and marks policy as resolved.</span></span>  
  
 <span data-ttu-id="be398-1055">Если динамический <xref:System.Reflection.Assembly> объект сохраняется на диске, последующие загрузки получают разрешения на основе политик, связанных с расположением, в <xref:System.Reflection.Assembly> котором был сохранен.</span><span class="sxs-lookup"><span data-stu-id="be398-1055">If the dynamic <xref:System.Reflection.Assembly> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <xref:System.Reflection.Assembly> was saved.</span></span>  
  
 <span data-ttu-id="be398-1056">Этот метод следует использовать только для определения динамической сборки в текущем домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1056">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="be398-1057">Дополнительные сведения см. в <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> разделе перегрузка метода.</span><span class="sxs-lookup"><span data-stu-id="be398-1057">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="be398-1058">Во время разработки кода, который создает динамические сборки, рекомендуется использовать перегрузку <xref:System.AppDomain.DefineDynamicAssembly%2A> метода, который задает свидетельство и разрешения, указать свидетельство, которое должна иметь динамическая сборка, и включить в <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> `refusedPermissions`.</span><span class="sxs-lookup"><span data-stu-id="be398-1058">During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="be398-1059"><xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> Включение `refusedPermissions`  в параметр гарантирует, что код MSIL будет проверен.</span><span class="sxs-lookup"><span data-stu-id="be398-1059">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="be398-1060">Ограничением этой методики является то, что оно <xref:System.Security.SecurityException> также вызывается при использовании с кодом, требующим полного доверия.</span><span class="sxs-lookup"><span data-stu-id="be398-1060">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-1061">В следующем примере демонстрируется <xref:System.AppDomain.DefineDynamicAssembly%2A> метод <xref:System.AppDomain.AssemblyResolve> и событие.</span><span class="sxs-lookup"><span data-stu-id="be398-1061">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and the <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="be398-1062">Во первых, в примере кода предпринимается попытка создать `MyDynamicType` экземпляр путем <xref:System.AppDomain.CreateInstance%2A> вызова метода с недопустимым именем сборки и перехватывается результирующее исключение.</span><span class="sxs-lookup"><span data-stu-id="be398-1062">First, the code example tries to create an instance of `MyDynamicType` by calling the <xref:System.AppDomain.CreateInstance%2A> method with an invalid assembly name, and catches the resulting exception.</span></span>  
  
 <span data-ttu-id="be398-1063">Затем в примере кода добавляется обработчик событий для <xref:System.AppDomain.AssemblyResolve> события и снова пытается создать`MyDynamicType`экземпляр.</span><span class="sxs-lookup"><span data-stu-id="be398-1063">The code example then adds an event handler for the <xref:System.AppDomain.AssemblyResolve> event, and again tries to create an instance of`MyDynamicType`.</span></span> <span data-ttu-id="be398-1064">Во время вызова <xref:System.AppDomain.CreateInstance%2A> <xref:System.AppDomain.AssemblyResolve> событие вызывается для недопустимой сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1064">During the call to <xref:System.AppDomain.CreateInstance%2A>, the <xref:System.AppDomain.AssemblyResolve> event is raised for the invalid assembly.</span></span> <span data-ttu-id="be398-1065">Обработчик событий создает динамическую сборку, содержащую тип с именем `MyDynamicType`, предоставляет тип конструктора без параметров и возвращает новую динамическую сборку.</span><span class="sxs-lookup"><span data-stu-id="be398-1065">The event handler creates a dynamic assembly that contains a type named `MyDynamicType`, gives the type a parameterless constructor, and returns the new dynamic assembly.</span></span> <span data-ttu-id="be398-1066">Вызов <xref:System.AppDomain.CreateInstance%2A> завершается успешно, а конструктор для `MyDynamicType` отображает сообщение в консоли.</span><span class="sxs-lookup"><span data-stu-id="be398-1066">The call to <xref:System.AppDomain.CreateInstance%2A> then finishes successfully, and the constructor for `MyDynamicType` displays a message at the console.</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-1067">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1067"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be398-1068">Свойство <see langword="Name" /> параметра <paramref name="name" /> равно <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1068">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="be398-1069">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-1069">-or-</span></span> 
<span data-ttu-id="be398-1070">Значение свойства <see langword="Name" /> параметра <paramref name="name" /> начинается с пробела или содержит символ прямой (обратной) косой черты.</span><span class="sxs-lookup"><span data-stu-id="be398-1070">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-1071">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1071">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="be398-1072">для загрузки сборки с свидетельством.</span><span class="sxs-lookup"><span data-stu-id="be398-1072">to load an assembly with evidence.</span></span> <span data-ttu-id="be398-1073">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1073">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="dir" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="be398-1074">Уникальный идентификатор динамической сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1074">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="be398-1075">Режим, в котором будет осуществляться доступ к динамической сборке.</span><span class="sxs-lookup"><span data-stu-id="be398-1075">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="dir"><span data-ttu-id="be398-1076">Имя папки, в которой будет сохранена сборка.</span><span class="sxs-lookup"><span data-stu-id="be398-1076">The name of the directory where the assembly will be saved.</span></span> <span data-ttu-id="be398-1077">Если параметр <paramref name="dir" /> имеет значение <see langword="null" />, по умолчанию используется текущий каталог.</span><span class="sxs-lookup"><span data-stu-id="be398-1077">If <paramref name="dir" /> is <see langword="null" />, the directory defaults to the current directory.</span></span></param>
        <summary><span data-ttu-id="be398-1078">Определяет динамическую сборку с помощью указанного имени, режима доступа и каталога хранения.</span><span class="sxs-lookup"><span data-stu-id="be398-1078">Defines a dynamic assembly using the specified name, access mode, and storage directory.</span></span></summary>
        <returns><span data-ttu-id="be398-1079">Динамическая сборка с указанным именем и возможностями.</span><span class="sxs-lookup"><span data-stu-id="be398-1079">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-1080">Этот метод следует использовать только для определения динамической сборки в текущем домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1080">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="be398-1081">Дополнительные сведения см. в <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> разделе перегрузка метода.</span><span class="sxs-lookup"><span data-stu-id="be398-1081">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="be398-1082">Во время разработки кода, который создает динамические сборки, рекомендуется использовать перегрузку <xref:System.AppDomain.DefineDynamicAssembly%2A> метода, который задает свидетельство и разрешения, указать свидетельство, которое должна иметь динамическая сборка, и включить в <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> `refusedPermissions`.</span><span class="sxs-lookup"><span data-stu-id="be398-1082">During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="be398-1083"><xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> Включение `refusedPermissions`  в параметр гарантирует, что код MSIL будет проверен.</span><span class="sxs-lookup"><span data-stu-id="be398-1083">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="be398-1084">Ограничением этой методики является то, что оно <xref:System.Security.SecurityException> также вызывается при использовании с кодом, требующим полного доверия.</span><span class="sxs-lookup"><span data-stu-id="be398-1084">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-1085">В следующем примере демонстрируется <xref:System.AppDomain.DefineDynamicAssembly%2A> метод и <xref:System.AppDomain.AssemblyResolve> событие.</span><span class="sxs-lookup"><span data-stu-id="be398-1085">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="be398-1086">Для выполнения этого примера кода необходимо указать полное имя сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1086">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="be398-1087">Дополнительные сведения о получении полного имени сборки см. в разделе [имена сборок](~/docs/framework/app-domains/assembly-names.md).</span><span class="sxs-lookup"><span data-stu-id="be398-1087">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-1088"><paramref name="name" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1088"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be398-1089">Свойство <see langword="Name" /> параметра <paramref name="name" /> равно <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1089">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="be398-1090">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-1090">-or-</span></span> 
<span data-ttu-id="be398-1091">Значение свойства <see langword="Name" /> параметра <paramref name="name" /> начинается с пробела или содержит символ прямой (обратной) косой черты.</span><span class="sxs-lookup"><span data-stu-id="be398-1091">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-1092">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1092">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes, System::Security::SecurityContextSource securityContextSource);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; * System.Security.SecurityContextSource -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, assemblyAttributes, securityContextSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" Index="3" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="be398-1093">Уникальный идентификатор динамической сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1093">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="be398-1094">Режим доступа для динамической сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1094">The access mode for the dynamic assembly.</span></span></param>
        <param name="assemblyAttributes"><span data-ttu-id="be398-1095">Перечислимый список атрибутов, которые будут применены к сборке, или значение <see langword="null" />, если атрибуты отсутствуют.</span><span class="sxs-lookup"><span data-stu-id="be398-1095">An enumerable list of attributes to be applied to the assembly, or <see langword="null" /> if there are no attributes.</span></span></param>
        <param name="securityContextSource"><span data-ttu-id="be398-1096">Источник контекста безопасности.</span><span class="sxs-lookup"><span data-stu-id="be398-1096">The source of the security context.</span></span></param>
        <summary><span data-ttu-id="be398-1097">Определяет динамическую сборку с помощью указанного имени, режима доступа и настраиваемых атрибутов, а также используя заданный источник для контекста безопасности.</span><span class="sxs-lookup"><span data-stu-id="be398-1097">Defines a dynamic assembly with the specified name, access mode, and custom attributes, and using the specified source for its security context.</span></span></summary>
        <returns><span data-ttu-id="be398-1098">Динамическая сборка с указанным именем и возможностями.</span><span class="sxs-lookup"><span data-stu-id="be398-1098">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-1099">Используйте эту перегрузку метода, чтобы указать атрибуты, которые не работают должным образом, если они не применяются при создании динамической сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1099">Use this method overload to specify attributes that do not work correctly unless they are applied when a dynamic assembly is created.</span></span> <span data-ttu-id="be398-1100">Например, такие атрибуты безопасности, как <xref:System.Security.SecurityTransparentAttribute> и <xref:System.Security.SecurityCriticalAttribute> , работают неправильно, если они добавляются после создания динамической сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1100">For example, security attributes such as <xref:System.Security.SecurityTransparentAttribute> and <xref:System.Security.SecurityCriticalAttribute> do not work correctly if they are added after a dynamic assembly has been created.</span></span>  
  
 <span data-ttu-id="be398-1101">Этот метод следует использовать только для определения динамической сборки в текущем домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1101">This method should be used only to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="be398-1102">Дополнительные сведения об этом ограничении см. в <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> описании перегрузки метода.</span><span class="sxs-lookup"><span data-stu-id="be398-1102">For more information about this restriction, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-1103">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1103"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be398-1104">Свойство <see langword="Name" /> параметра <paramref name="name" /> равно <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1104">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="be398-1105">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-1105">-or-</span></span> 
<span data-ttu-id="be398-1106">Значение свойства <see langword="Name" /> объекта <paramref name="name" /> начинается с пробела или содержит символ прямой (обратной) косой черты.</span><span class="sxs-lookup"><span data-stu-id="be398-1106">The <see langword="Name" /> property of <paramref name="name" /> starts with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-1107">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1107">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="be398-1108">Значение <paramref name="securityContextSource" /> не является одним из значений перечисления.</span><span class="sxs-lookup"><span data-stu-id="be398-1108">The value of <paramref name="securityContextSource" /> was not one of the enumeration values.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of DefineDynamicAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="dir" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="be398-1109">Уникальный идентификатор динамической сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1109">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="be398-1110">Режим, в котором будет осуществляться доступ к динамической сборке.</span><span class="sxs-lookup"><span data-stu-id="be398-1110">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="dir"><span data-ttu-id="be398-1111">Имя папки, в которой будет сохранена сборка.</span><span class="sxs-lookup"><span data-stu-id="be398-1111">The name of the directory where the assembly will be saved.</span></span> <span data-ttu-id="be398-1112">Если параметр <paramref name="dir" /> имеет значение <see langword="null" />, по умолчанию используется текущий каталог.</span><span class="sxs-lookup"><span data-stu-id="be398-1112">If <paramref name="dir" /> is <see langword="null" />, the directory defaults to the current directory.</span></span></param>
        <param name="evidence"><span data-ttu-id="be398-1113">Свидетельство, предоставляемое для динамической сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1113">The evidence supplied for the dynamic assembly.</span></span> <span data-ttu-id="be398-1114">Используемое свидетельство является постоянным, как конечный набор свидетельств, используемых для разрешения политики.</span><span class="sxs-lookup"><span data-stu-id="be398-1114">The evidence is used unaltered as the final set of evidence used for policy resolution.</span></span></param>
        <summary><span data-ttu-id="be398-1115">Определяет динамическую сборку с помощью указанного имени, режима доступа, каталога хранения и свидетельства.</span><span class="sxs-lookup"><span data-stu-id="be398-1115">Defines a dynamic assembly using the specified name, access mode, storage directory, and evidence.</span></span></summary>
        <returns><span data-ttu-id="be398-1116">Динамическая сборка с указанным именем и возможностями.</span><span class="sxs-lookup"><span data-stu-id="be398-1116">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-1117">Только полностью доверенные вызывающие объекты могут `evidence` предоставлять их при определении <xref:System.Reflection.Assembly>динамического.</span><span class="sxs-lookup"><span data-stu-id="be398-1117">Only fully trusted callers can supply their `evidence` when defining a dynamic <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="be398-1118">Среда выполнения будет сопоставлять объект <xref:System.Security.Policy.Evidence> с помощью политики безопасности для определения предоставленных разрешений.</span><span class="sxs-lookup"><span data-stu-id="be398-1118">The runtime will map the <xref:System.Security.Policy.Evidence> through the security policy to determine the granted permissions.</span></span> <span data-ttu-id="be398-1119">Частично доверенные вызывающие объекты должны предоставлять `evidence`значение null.</span><span class="sxs-lookup"><span data-stu-id="be398-1119">Partially trusted callers must supply a null `evidence`.</span></span> <span data-ttu-id="be398-1120">Если `evidence` имеет `null`значение, среда выполнения копирует наборы разрешений, то есть текущие наборы Grant и DENY <xref:System.Reflection.Assembly> , от вызывающей стороны к динамически <xref:System.Reflection.Assembly> определяемому и помечает политику как разрешенную.</span><span class="sxs-lookup"><span data-stu-id="be398-1120">If `evidence` is `null`, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <xref:System.Reflection.Assembly> to the dynamic <xref:System.Reflection.Assembly> being defined and marks policy as resolved.</span></span>  
  
 <span data-ttu-id="be398-1121">Если динамический <xref:System.Reflection.Assembly> объект сохраняется на диске, последующие загрузки получают разрешения на основе политик, связанных с расположением, в <xref:System.Reflection.Assembly> котором был сохранен.</span><span class="sxs-lookup"><span data-stu-id="be398-1121">If the dynamic <xref:System.Reflection.Assembly> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <xref:System.Reflection.Assembly> was saved.</span></span>  
  
 <span data-ttu-id="be398-1122">Этот метод следует использовать только для определения динамической сборки в текущем домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1122">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="be398-1123">Дополнительные сведения см. в <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> разделе перегрузка метода.</span><span class="sxs-lookup"><span data-stu-id="be398-1123">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="be398-1124">Во время разработки кода, который создает динамические сборки, рекомендуется использовать перегрузку <xref:System.AppDomain.DefineDynamicAssembly%2A> метода, который задает свидетельство и разрешения, указать свидетельство, которое должна иметь динамическая сборка, и включить в <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> `refusedPermissions`.</span><span class="sxs-lookup"><span data-stu-id="be398-1124">During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="be398-1125"><xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> Включение `refusedPermissions`  в параметр гарантирует, что код MSIL будет проверен.</span><span class="sxs-lookup"><span data-stu-id="be398-1125">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="be398-1126">Ограничением этой методики является то, что оно <xref:System.Security.SecurityException> также вызывается при использовании с кодом, требующим полного доверия.</span><span class="sxs-lookup"><span data-stu-id="be398-1126">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-1127">В следующем примере демонстрируется <xref:System.AppDomain.DefineDynamicAssembly%2A> метод и <xref:System.AppDomain.AssemblyResolve> событие.</span><span class="sxs-lookup"><span data-stu-id="be398-1127">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="be398-1128">Для выполнения этого примера кода необходимо указать полное имя сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1128">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="be398-1129">Дополнительные сведения о получении полного имени сборки см. в разделе [имена сборок](~/docs/framework/app-domains/assembly-names.md).</span><span class="sxs-lookup"><span data-stu-id="be398-1129">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-1130"><paramref name="name" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1130"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be398-1131">Свойство <see langword="Name" /> параметра <paramref name="name" /> равно <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1131">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="be398-1132">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-1132">-or-</span></span> 
<span data-ttu-id="be398-1133">Значение свойства <see langword="Name" /> параметра <paramref name="name" /> начинается с пробела или содержит символ прямой (обратной) косой черты.</span><span class="sxs-lookup"><span data-stu-id="be398-1133">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-1134">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1134">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="be398-1135">для загрузки сборки с свидетельством.</span><span class="sxs-lookup"><span data-stu-id="be398-1135">to load an assembly with evidence.</span></span> <span data-ttu-id="be398-1136">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1136">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="be398-1137">Уникальный идентификатор динамической сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1137">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="be398-1138">Режим, в котором будет осуществляться доступ к динамической сборке.</span><span class="sxs-lookup"><span data-stu-id="be398-1138">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="requiredPermissions"><span data-ttu-id="be398-1139">Запрос обязательных разрешений.</span><span class="sxs-lookup"><span data-stu-id="be398-1139">The required permissions request.</span></span></param>
        <param name="optionalPermissions"><span data-ttu-id="be398-1140">Запрос дополнительных разрешений.</span><span class="sxs-lookup"><span data-stu-id="be398-1140">The optional permissions request.</span></span></param>
        <param name="refusedPermissions"><span data-ttu-id="be398-1141">Запрос разрешений, в которых отказано.</span><span class="sxs-lookup"><span data-stu-id="be398-1141">The refused permissions request.</span></span></param>
        <summary><span data-ttu-id="be398-1142">Определяет динамическую сборку с помощью указанного имени, режима доступа и запросов разрешений.</span><span class="sxs-lookup"><span data-stu-id="be398-1142">Defines a dynamic assembly using the specified name, access mode, and permission requests.</span></span></summary>
        <returns><span data-ttu-id="be398-1143">Динамическая сборка с указанным именем и возможностями.</span><span class="sxs-lookup"><span data-stu-id="be398-1143">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-1144">Запросы разрешений, указанные для `requiredPermissions`, `optionalPermissions`и `refusedPermissions` , не используются, если только динамическая сборка не сохранена и не загружена в память.</span><span class="sxs-lookup"><span data-stu-id="be398-1144">The permission requests specified for `requiredPermissions`, `optionalPermissions`, and `refusedPermissions` are not used unless the dynamic assembly has been saved and reloaded into memory.</span></span> <span data-ttu-id="be398-1145">Чтобы указать запросы разрешений для временной сборки, которая никогда не сохранялась на диске, используйте перегрузку <xref:System.AppDomain.DefineDynamicAssembly%2A> метода, который указывает свидетельство, а также запрошенные разрешения, и <xref:System.Security.Policy.Evidence> укажите объект.</span><span class="sxs-lookup"><span data-stu-id="be398-1145">To specify permission requests for a transient assembly that is never saved to disk, use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence as well as requested permissions, and supply an <xref:System.Security.Policy.Evidence> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="be398-1146">Во время разработки кода, который создает динамические сборки, рекомендуется использовать перегрузку <xref:System.AppDomain.DefineDynamicAssembly%2A> метода, который задает свидетельство и разрешения, указать свидетельство, которое должна иметь динамическая сборка, и включить в <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> `refusedPermissions`.</span><span class="sxs-lookup"><span data-stu-id="be398-1146">During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="be398-1147"><xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> Включение `refusedPermissions`  в параметр гарантирует, что код MSIL будет проверен.</span><span class="sxs-lookup"><span data-stu-id="be398-1147">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="be398-1148">Ограничением этой методики является то, что оно <xref:System.Security.SecurityException> также вызывается при использовании с кодом, требующим полного доверия.</span><span class="sxs-lookup"><span data-stu-id="be398-1148">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
 <span data-ttu-id="be398-1149">Этот метод следует использовать только для определения динамической сборки в текущем домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1149">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="be398-1150">Дополнительные сведения см. в <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> разделе перегрузка метода.</span><span class="sxs-lookup"><span data-stu-id="be398-1150">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-1151">В следующем примере демонстрируется <xref:System.AppDomain.DefineDynamicAssembly%2A> метод и <xref:System.AppDomain.AssemblyResolve> событие.</span><span class="sxs-lookup"><span data-stu-id="be398-1151">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="be398-1152">Для выполнения этого примера кода необходимо указать полное имя сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1152">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="be398-1153">Дополнительные сведения о получении полного имени сборки см. в разделе [имена сборок](~/docs/framework/app-domains/assembly-names.md).</span><span class="sxs-lookup"><span data-stu-id="be398-1153">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-1154"><paramref name="name" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1154"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be398-1155">Свойство <see langword="Name" /> параметра <paramref name="name" /> равно <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1155">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="be398-1156">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-1156">-or-</span></span> 
<span data-ttu-id="be398-1157">Значение свойства <see langword="Name" /> параметра <paramref name="name" /> начинается с пробела или содержит символ прямой (обратной) косой черты.</span><span class="sxs-lookup"><span data-stu-id="be398-1157">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-1158">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1158">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, isSynchronized As Boolean, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * bool * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, isSynchronized, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="dir" Type="System.String" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="isSynchronized" Type="System.Boolean" Index="3" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" Index="4" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="be398-1159">Уникальный идентификатор динамической сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1159">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="be398-1160">Режим, в котором будет осуществляться доступ к динамической сборке.</span><span class="sxs-lookup"><span data-stu-id="be398-1160">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="dir"><span data-ttu-id="be398-1161">Имя каталога, в котором будет сохранена динамическая сборка.</span><span class="sxs-lookup"><span data-stu-id="be398-1161">The name of the directory where the dynamic assembly will be saved.</span></span> <span data-ttu-id="be398-1162">Если параметр <paramref name="dir" /> имеет значение <see langword="null" />, используется текущий каталог.</span><span class="sxs-lookup"><span data-stu-id="be398-1162">If <paramref name="dir" /> is <see langword="null" />, the current directory is used.</span></span></param>
        <param name="isSynchronized"><span data-ttu-id="be398-1163">Значение <see langword="true" />, чтобы синхронизировать создание модулей, типов и членов в динамической сборке, в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1163"><see langword="true" /> to synchronize the creation of modules, types, and members in the dynamic assembly; otherwise, <see langword="false" />.</span></span></param>
        <param name="assemblyAttributes"><span data-ttu-id="be398-1164">Перечислимый список атрибутов, которые будут применены к сборке, или значение <see langword="null" />, если атрибуты отсутствуют.</span><span class="sxs-lookup"><span data-stu-id="be398-1164">An enumerable list of attributes to be applied to the assembly, or <see langword="null" /> if there are no attributes.</span></span></param>
        <summary><span data-ttu-id="be398-1165">Определяет динамическую сборку с помощью указанного имени, режима доступа, каталога хранения и варианта синхронизации.</span><span class="sxs-lookup"><span data-stu-id="be398-1165">Defines a dynamic assembly using the specified name, access mode, storage directory, and synchronization option.</span></span></summary>
        <returns><span data-ttu-id="be398-1166">Динамическая сборка с указанным именем и возможностями.</span><span class="sxs-lookup"><span data-stu-id="be398-1166">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-1167">Используйте эту перегрузку метода, чтобы указать атрибуты, которые не работают должным образом, если они не применяются при создании динамической сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1167">Use this method overload to specify attributes that do not work correctly unless they are applied when a dynamic assembly is created.</span></span> <span data-ttu-id="be398-1168">Например, такие атрибуты безопасности, как <xref:System.Security.SecurityTransparentAttribute> и <xref:System.Security.SecurityCriticalAttribute> , работают неправильно, если они добавляются после создания динамической сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1168">For example, security attributes such as <xref:System.Security.SecurityTransparentAttribute> and <xref:System.Security.SecurityCriticalAttribute> do not work correctly if they are added after a dynamic assembly has been created.</span></span>  
  
 <span data-ttu-id="be398-1169">Если `isSynchronized` имеет `true`значение, то <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A> <xref:System.Reflection.Emit.AssemblyBuilder> <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A> <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A> <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A> будут синхронизированы <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A> следующие методы итогового результата:,,, , и. <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A></span><span class="sxs-lookup"><span data-stu-id="be398-1169">If `isSynchronized` is `true`, the following methods of the resulting <xref:System.Reflection.Emit.AssemblyBuilder> will be synchronized: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, and <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</span></span> <span data-ttu-id="be398-1170">Если два из этих методов вызываются в разных потоках, один из них будет заблокирован до завершения другого.</span><span class="sxs-lookup"><span data-stu-id="be398-1170">If two of these methods are called on different threads, one will block until the other is completed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-1171"><paramref name="name" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1171"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be398-1172">Свойство <see langword="Name" /> параметра <paramref name="name" /> равно <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1172">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="be398-1173">-или-</span><span class="sxs-lookup"><span data-stu-id="be398-1173">-or-</span></span> 
<span data-ttu-id="be398-1174">Значение свойства <see langword="Name" /> объекта <paramref name="name" /> начинается с пробела или содержит символ прямой (обратной) косой черты.</span><span class="sxs-lookup"><span data-stu-id="be398-1174">The <see langword="Name" /> property of <paramref name="name" /> starts with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-1175">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1175">The operation is attempted on an unloaded application domain.</span></span></exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, evidence, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="be398-1176">Уникальный идентификатор динамической сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1176">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="be398-1177">Режим, в котором будет осуществляться доступ к динамической сборке.</span><span class="sxs-lookup"><span data-stu-id="be398-1177">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="evidence"><span data-ttu-id="be398-1178">Свидетельство, предоставляемое для динамической сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1178">The evidence supplied for the dynamic assembly.</span></span> <span data-ttu-id="be398-1179">Используемое свидетельство является постоянным, как конечный набор свидетельств, используемых для разрешения политики.</span><span class="sxs-lookup"><span data-stu-id="be398-1179">The evidence is used unaltered as the final set of evidence used for policy resolution.</span></span></param>
        <param name="requiredPermissions"><span data-ttu-id="be398-1180">Запрос обязательных разрешений.</span><span class="sxs-lookup"><span data-stu-id="be398-1180">The required permissions request.</span></span></param>
        <param name="optionalPermissions"><span data-ttu-id="be398-1181">Запрос дополнительных разрешений.</span><span class="sxs-lookup"><span data-stu-id="be398-1181">The optional permissions request.</span></span></param>
        <param name="refusedPermissions"><span data-ttu-id="be398-1182">Запрос разрешений, в которых отказано.</span><span class="sxs-lookup"><span data-stu-id="be398-1182">The refused permissions request.</span></span></param>
        <summary><span data-ttu-id="be398-1183">Определяет динамическую сборку с помощью указанного имени, режима доступа, свидетельства и запросов разрешений.</span><span class="sxs-lookup"><span data-stu-id="be398-1183">Defines a dynamic assembly using the specified name, access mode, evidence, and permission requests.</span></span></summary>
        <returns><span data-ttu-id="be398-1184">Динамическая сборка с указанным именем и возможностями.</span><span class="sxs-lookup"><span data-stu-id="be398-1184">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-1185">Запросы разрешений, указанные для `requiredPermissions`, `optionalPermissions`и `refusedPermissions` , используются только в том `evidence` случае, если также указан параметр, или если динамическая сборка сохраняется и перегружается в память.</span><span class="sxs-lookup"><span data-stu-id="be398-1185">The permission requests specified for `requiredPermissions`, `optionalPermissions`, and `refusedPermissions` are used only if `evidence` is also supplied, or if the dynamic assembly is saved and reloaded into memory.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="be398-1186">Во время разработки кода, который создает динамические сборки, рекомендуется включить <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> в. `refusedPermissions`</span><span class="sxs-lookup"><span data-stu-id="be398-1186">During the development of code that emits dynamic assemblies, it is recommended that you include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="be398-1187"><xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> Включение `refusedPermissions`  в параметр гарантирует, что код MSIL будет проверен.</span><span class="sxs-lookup"><span data-stu-id="be398-1187">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="be398-1188">Ограничением этой методики является то, что оно <xref:System.Security.SecurityException> также вызывается при использовании с кодом, требующим полного доверия.</span><span class="sxs-lookup"><span data-stu-id="be398-1188">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
 <span data-ttu-id="be398-1189">Только полностью доверенные вызывающие объекты могут `evidence` предоставлять их при определении <xref:System.Reflection.Assembly>динамического.</span><span class="sxs-lookup"><span data-stu-id="be398-1189">Only fully trusted callers can supply their `evidence` when defining a dynamic <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="be398-1190">Среда выполнения будет сопоставлять объект <xref:System.Security.Policy.Evidence> с помощью политики безопасности для определения предоставленных разрешений.</span><span class="sxs-lookup"><span data-stu-id="be398-1190">The runtime will map the <xref:System.Security.Policy.Evidence> through the security policy to determine the granted permissions.</span></span> <span data-ttu-id="be398-1191">Частично доверенные вызывающие объекты должны предоставлять `evidence`значение null.</span><span class="sxs-lookup"><span data-stu-id="be398-1191">Partially trusted callers must supply a null `evidence`.</span></span> <span data-ttu-id="be398-1192">Если `evidence` имеет `null`значение, среда выполнения копирует наборы разрешений, то есть текущие наборы Grant и DENY <xref:System.Reflection.Assembly> , от вызывающей стороны к динамически <xref:System.Reflection.Assembly> определяемому и помечает политику как разрешенную.</span><span class="sxs-lookup"><span data-stu-id="be398-1192">If `evidence` is `null`, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <xref:System.Reflection.Assembly> to the dynamic <xref:System.Reflection.Assembly> being defined and marks policy as resolved.</span></span>  
  
 <span data-ttu-id="be398-1193">Если динамический <xref:System.Reflection.Assembly> объект сохраняется на диске, последующие загрузки получают разрешения на основе политик, связанных с расположением, в <xref:System.Reflection.Assembly> котором был сохранен.</span><span class="sxs-lookup"><span data-stu-id="be398-1193">If the dynamic <xref:System.Reflection.Assembly> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <xref:System.Reflection.Assembly> was saved.</span></span>  
  
 <span data-ttu-id="be398-1194">Этот метод следует использовать только для определения динамической сборки в текущем домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1194">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="be398-1195">Дополнительные сведения см. в <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> разделе перегрузка метода.</span><span class="sxs-lookup"><span data-stu-id="be398-1195">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-1196">В следующем примере демонстрируется <xref:System.AppDomain.DefineDynamicAssembly%2A> метод и <xref:System.AppDomain.AssemblyResolve> событие.</span><span class="sxs-lookup"><span data-stu-id="be398-1196">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="be398-1197">Для выполнения этого примера кода необходимо указать полное имя сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1197">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="be398-1198">Дополнительные сведения о получении полного имени сборки см. в разделе [имена сборок](~/docs/framework/app-domains/assembly-names.md).</span><span class="sxs-lookup"><span data-stu-id="be398-1198">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-1199">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1199"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be398-1200">Свойство <see langword="Name" /> параметра <paramref name="name" /> равно <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1200">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="be398-1201">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-1201">-or-</span></span> 
<span data-ttu-id="be398-1202">Значение свойства <see langword="Name" /> параметра <paramref name="name" /> начинается с пробела или содержит символ прямой (обратной) косой черты.</span><span class="sxs-lookup"><span data-stu-id="be398-1202">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-1203">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1203">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="be398-1204">для загрузки сборки с свидетельством.</span><span class="sxs-lookup"><span data-stu-id="be398-1204">to load an assembly with evidence.</span></span> <span data-ttu-id="be398-1205">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1205">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="dir" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="be398-1206">Уникальный идентификатор динамической сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1206">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="be398-1207">Режим, в котором будет осуществляться доступ к динамической сборке.</span><span class="sxs-lookup"><span data-stu-id="be398-1207">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="dir"><span data-ttu-id="be398-1208">Имя папки, в которой будет сохранена сборка.</span><span class="sxs-lookup"><span data-stu-id="be398-1208">The name of the directory where the assembly will be saved.</span></span> <span data-ttu-id="be398-1209">Если параметр <paramref name="dir" /> имеет значение <see langword="null" />, по умолчанию используется текущий каталог.</span><span class="sxs-lookup"><span data-stu-id="be398-1209">If <paramref name="dir" /> is <see langword="null" />, the directory defaults to the current directory.</span></span></param>
        <param name="requiredPermissions"><span data-ttu-id="be398-1210">Запрос обязательных разрешений.</span><span class="sxs-lookup"><span data-stu-id="be398-1210">The required permissions request.</span></span></param>
        <param name="optionalPermissions"><span data-ttu-id="be398-1211">Запрос дополнительных разрешений.</span><span class="sxs-lookup"><span data-stu-id="be398-1211">The optional permissions request.</span></span></param>
        <param name="refusedPermissions"><span data-ttu-id="be398-1212">Запрос разрешений, в которых отказано.</span><span class="sxs-lookup"><span data-stu-id="be398-1212">The refused permissions request.</span></span></param>
        <summary><span data-ttu-id="be398-1213">Определяет динамическую сборку с помощью указанного имени, режима доступа, каталога хранения и запросов разрешений.</span><span class="sxs-lookup"><span data-stu-id="be398-1213">Defines a dynamic assembly using the specified name, access mode, storage directory, and permission requests.</span></span></summary>
        <returns><span data-ttu-id="be398-1214">Динамическая сборка с указанным именем и возможностями.</span><span class="sxs-lookup"><span data-stu-id="be398-1214">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-1215">Запросы разрешений, указанные для `requiredPermissions`, `optionalPermissions`и `refusedPermissions` , не используются, если только динамическая сборка не сохранена и не загружена в память.</span><span class="sxs-lookup"><span data-stu-id="be398-1215">The permission requests specified for `requiredPermissions`, `optionalPermissions`, and `refusedPermissions` are not used unless the dynamic assembly has been saved and reloaded into memory.</span></span> <span data-ttu-id="be398-1216">Чтобы указать запросы разрешений для временной сборки, которая никогда не сохранялась на диске, используйте перегрузку <xref:System.AppDomain.DefineDynamicAssembly%2A> метода, который указывает свидетельство, а также запрошенные разрешения, и <xref:System.Security.Policy.Evidence> укажите объект.</span><span class="sxs-lookup"><span data-stu-id="be398-1216">To specify permission requests for a transient assembly that is never saved to disk, use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence as well as requested permissions, and supply an <xref:System.Security.Policy.Evidence> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="be398-1217">Во время разработки кода, который создает динамические сборки, рекомендуется использовать перегрузку <xref:System.AppDomain.DefineDynamicAssembly%2A> метода, который задает свидетельство и разрешения, указать свидетельство, которое должна иметь динамическая сборка, и включить в <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> `refusedPermissions`.</span><span class="sxs-lookup"><span data-stu-id="be398-1217">During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="be398-1218"><xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> Включение `refusedPermissions`  в параметр гарантирует, что код MSIL будет проверен.</span><span class="sxs-lookup"><span data-stu-id="be398-1218">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="be398-1219">Ограничением этой методики является то, что оно <xref:System.Security.SecurityException> также вызывается при использовании с кодом, требующим полного доверия.</span><span class="sxs-lookup"><span data-stu-id="be398-1219">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
 <span data-ttu-id="be398-1220">Этот метод следует использовать только для определения динамической сборки в текущем домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1220">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="be398-1221">Дополнительные сведения см. в <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> разделе перегрузка метода.</span><span class="sxs-lookup"><span data-stu-id="be398-1221">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-1222">В следующем примере демонстрируется <xref:System.AppDomain.DefineDynamicAssembly%2A> метод и <xref:System.AppDomain.AssemblyResolve> событие.</span><span class="sxs-lookup"><span data-stu-id="be398-1222">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="be398-1223">Для выполнения этого примера кода необходимо указать полное имя сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1223">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="be398-1224">Дополнительные сведения о получении полного имени сборки см. в разделе [имена сборок](~/docs/framework/app-domains/assembly-names.md).</span><span class="sxs-lookup"><span data-stu-id="be398-1224">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-1225">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1225"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be398-1226">Свойство <see langword="Name" /> параметра <paramref name="name" /> равно <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1226">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="be398-1227">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-1227">-or-</span></span> 
<span data-ttu-id="be398-1228">Значение свойства <see langword="Name" /> параметра <paramref name="name" /> начинается с пробела или содержит символ прямой (обратной) косой черты.</span><span class="sxs-lookup"><span data-stu-id="be398-1228">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-1229">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1229">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  Please see http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="dir" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="be398-1230">Уникальный идентификатор динамической сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1230">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="be398-1231">Режим, в котором будет осуществляться доступ к динамической сборке.</span><span class="sxs-lookup"><span data-stu-id="be398-1231">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="dir"><span data-ttu-id="be398-1232">Имя папки, в которой будет сохранена сборка.</span><span class="sxs-lookup"><span data-stu-id="be398-1232">The name of the directory where the assembly will be saved.</span></span> <span data-ttu-id="be398-1233">Если параметр <paramref name="dir" /> имеет значение <see langword="null" />, по умолчанию используется текущий каталог.</span><span class="sxs-lookup"><span data-stu-id="be398-1233">If <paramref name="dir" /> is <see langword="null" />, the directory defaults to the current directory.</span></span></param>
        <param name="evidence"><span data-ttu-id="be398-1234">Свидетельство, предоставляемое для динамической сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1234">The evidence supplied for the dynamic assembly.</span></span> <span data-ttu-id="be398-1235">Используемое свидетельство является постоянным, как конечный набор свидетельств, используемых для разрешения политики.</span><span class="sxs-lookup"><span data-stu-id="be398-1235">The evidence is used unaltered as the final set of evidence used for policy resolution.</span></span></param>
        <param name="requiredPermissions"><span data-ttu-id="be398-1236">Запрос обязательных разрешений.</span><span class="sxs-lookup"><span data-stu-id="be398-1236">The required permissions request.</span></span></param>
        <param name="optionalPermissions"><span data-ttu-id="be398-1237">Запрос дополнительных разрешений.</span><span class="sxs-lookup"><span data-stu-id="be398-1237">The optional permissions request.</span></span></param>
        <param name="refusedPermissions"><span data-ttu-id="be398-1238">Запрос разрешений, в которых отказано.</span><span class="sxs-lookup"><span data-stu-id="be398-1238">The refused permissions request.</span></span></param>
        <summary><span data-ttu-id="be398-1239">Определяет динамическую сборку с помощью указанного имени, режима доступа, каталога хранения, свидетельства и запросов разрешений.</span><span class="sxs-lookup"><span data-stu-id="be398-1239">Defines a dynamic assembly using the specified name, access mode, storage directory, evidence, and permission requests.</span></span></summary>
        <returns><span data-ttu-id="be398-1240">Динамическая сборка с указанным именем и возможностями.</span><span class="sxs-lookup"><span data-stu-id="be398-1240">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-1241">Запросы разрешений, указанные для `requiredPermissions`, `optionalPermissions`и `refusedPermissions` , используются только в том `evidence` случае, если также указан параметр, или если динамическая сборка сохраняется и перегружается в память.</span><span class="sxs-lookup"><span data-stu-id="be398-1241">The permission requests specified for `requiredPermissions`, `optionalPermissions`, and `refusedPermissions` are used only if `evidence` is also supplied, or if the dynamic assembly is saved and reloaded into memory.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="be398-1242">Во время разработки кода, который создает динамические сборки, рекомендуется включить <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> в. `refusedPermissions`</span><span class="sxs-lookup"><span data-stu-id="be398-1242">During the development of code that emits dynamic assemblies, it is recommended that you include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="be398-1243"><xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> Включение `refusedPermissions`  в параметр гарантирует, что код MSIL будет проверен.</span><span class="sxs-lookup"><span data-stu-id="be398-1243">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="be398-1244">Ограничением этой методики является то, что оно <xref:System.Security.SecurityException> также вызывается при использовании с кодом, требующим полного доверия.</span><span class="sxs-lookup"><span data-stu-id="be398-1244">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
 <span data-ttu-id="be398-1245">Только полностью доверенные вызывающие объекты могут `evidence` предоставлять их при определении <xref:System.Reflection.Assembly>динамического.</span><span class="sxs-lookup"><span data-stu-id="be398-1245">Only fully trusted callers can supply their `evidence` when defining a dynamic <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="be398-1246">Среда выполнения будет сопоставлять объект <xref:System.Security.Policy.Evidence> с помощью политики безопасности для определения предоставленных разрешений.</span><span class="sxs-lookup"><span data-stu-id="be398-1246">The runtime will map the <xref:System.Security.Policy.Evidence> through the security policy to determine the granted permissions.</span></span> <span data-ttu-id="be398-1247">Частично доверенные вызывающие объекты должны предоставлять `evidence`значение null.</span><span class="sxs-lookup"><span data-stu-id="be398-1247">Partially trusted callers must supply a null `evidence`.</span></span> <span data-ttu-id="be398-1248">Если `evidence` имеет `null`значение, среда выполнения копирует наборы разрешений, то есть текущие наборы Grant и DENY <xref:System.Reflection.Assembly> , от вызывающей стороны к динамически <xref:System.Reflection.Assembly> определяемому и помечает политику как разрешенную.</span><span class="sxs-lookup"><span data-stu-id="be398-1248">If `evidence` is `null`, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <xref:System.Reflection.Assembly> to the dynamic <xref:System.Reflection.Assembly> being defined and marks policy as resolved.</span></span>  
  
 <span data-ttu-id="be398-1249">Если динамический <xref:System.Reflection.Assembly> объект сохраняется на диске, последующие загрузки получают разрешения на основе политик, связанных с расположением, в <xref:System.Reflection.Assembly> котором был сохранен.</span><span class="sxs-lookup"><span data-stu-id="be398-1249">If the dynamic <xref:System.Reflection.Assembly> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <xref:System.Reflection.Assembly> was saved.</span></span>  
  
 <span data-ttu-id="be398-1250">Этот метод следует использовать только для определения динамической сборки в текущем домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1250">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="be398-1251">Дополнительные сведения см. в <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> разделе перегрузка метода.</span><span class="sxs-lookup"><span data-stu-id="be398-1251">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-1252">В следующем примере демонстрируется <xref:System.AppDomain.DefineDynamicAssembly%2A> метод и <xref:System.AppDomain.AssemblyResolve> событие.</span><span class="sxs-lookup"><span data-stu-id="be398-1252">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="be398-1253">Для выполнения этого примера кода необходимо указать полное имя сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1253">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="be398-1254">Дополнительные сведения о получении полного имени сборки см. в разделе [имена сборок](~/docs/framework/app-domains/assembly-names.md).</span><span class="sxs-lookup"><span data-stu-id="be398-1254">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-1255">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1255"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be398-1256">Свойство <see langword="Name" /> параметра <paramref name="name" /> равно <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1256">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="be398-1257">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-1257">-or-</span></span> 
<span data-ttu-id="be398-1258">Значение свойства <see langword="Name" /> параметра <paramref name="name" /> начинается с пробела или содержит символ прямой (обратной) косой черты.</span><span class="sxs-lookup"><span data-stu-id="be398-1258">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-1259">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1259">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="be398-1260">для загрузки сборки с свидетельством.</span><span class="sxs-lookup"><span data-stu-id="be398-1260">to load an assembly with evidence.</span></span> <span data-ttu-id="be398-1261">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1261">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions, isSynchronized)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="dir" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="isSynchronized" Type="System.Boolean" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="be398-1262">Уникальный идентификатор динамической сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1262">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="be398-1263">Режим, в котором будет осуществляться доступ к динамической сборке.</span><span class="sxs-lookup"><span data-stu-id="be398-1263">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="dir"><span data-ttu-id="be398-1264">Имя каталога, в котором будет сохранена динамическая сборка.</span><span class="sxs-lookup"><span data-stu-id="be398-1264">The name of the directory where the dynamic assembly will be saved.</span></span> <span data-ttu-id="be398-1265">Если значение параметра <paramref name="dir" /> равно <see langword="null" />, по умолчанию используется текущий каталог.</span><span class="sxs-lookup"><span data-stu-id="be398-1265">If <paramref name="dir" /> is <see langword="null" />, the directory defaults to the current directory.</span></span></param>
        <param name="evidence"><span data-ttu-id="be398-1266">Свидетельство, предоставляемое для динамической сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1266">The evidence supplied for the dynamic assembly.</span></span> <span data-ttu-id="be398-1267">Используемое свидетельство является постоянным, как конечный набор свидетельств, используемых для разрешения политики.</span><span class="sxs-lookup"><span data-stu-id="be398-1267">The evidence is used unaltered as the final set of evidence used for policy resolution.</span></span></param>
        <param name="requiredPermissions"><span data-ttu-id="be398-1268">Запрос обязательных разрешений.</span><span class="sxs-lookup"><span data-stu-id="be398-1268">The required permissions request.</span></span></param>
        <param name="optionalPermissions"><span data-ttu-id="be398-1269">Запрос дополнительных разрешений.</span><span class="sxs-lookup"><span data-stu-id="be398-1269">The optional permissions request.</span></span></param>
        <param name="refusedPermissions"><span data-ttu-id="be398-1270">Запрос разрешений, в которых отказано.</span><span class="sxs-lookup"><span data-stu-id="be398-1270">The refused permissions request.</span></span></param>
        <param name="isSynchronized"><span data-ttu-id="be398-1271"><see langword="true" />, чтобы синхронизировать создание модулей, типов и членов в динамической сборке, в противном случае — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1271"><see langword="true" /> to synchronize the creation of modules, types, and members in the dynamic assembly; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="be398-1272">Определяет динамическую сборку с помощью указанного имени, режима доступа, каталога хранения, свидетельства, запросов разрешений и параметра синхронизации.</span><span class="sxs-lookup"><span data-stu-id="be398-1272">Defines a dynamic assembly using the specified name, access mode, storage directory, evidence, permission requests, and synchronization option.</span></span></summary>
        <returns><span data-ttu-id="be398-1273">Динамическая сборка с указанным именем и возможностями.</span><span class="sxs-lookup"><span data-stu-id="be398-1273">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-1274">Запросы разрешений, указанные для `requiredPermissions`, `optionalPermissions`и `refusedPermissions` , используются только в том `evidence` случае, если также указан параметр, или если динамическая сборка сохраняется и перегружается в память.</span><span class="sxs-lookup"><span data-stu-id="be398-1274">The permission requests specified for `requiredPermissions`, `optionalPermissions`, and `refusedPermissions` are used only if `evidence` is also supplied, or if the dynamic assembly is saved and reloaded into memory.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="be398-1275">Во время разработки кода, который создает динамические сборки, рекомендуется включить <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> в. `refusedPermissions`</span><span class="sxs-lookup"><span data-stu-id="be398-1275">During the development of code that emits dynamic assemblies, it is recommended that you include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="be398-1276"><xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> Включение `refusedPermissions`  в параметр гарантирует, что код MSIL будет проверен.</span><span class="sxs-lookup"><span data-stu-id="be398-1276">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="be398-1277">Ограничением этой методики является то, что оно <xref:System.Security.SecurityException> также вызывается при использовании с кодом, требующим полного доверия.</span><span class="sxs-lookup"><span data-stu-id="be398-1277">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
 <span data-ttu-id="be398-1278">Только полностью доверенные вызывающие объекты могут предоставлять свои доказательства при определении <xref:System.Reflection.Assembly>динамического.</span><span class="sxs-lookup"><span data-stu-id="be398-1278">Only fully trusted callers can supply their evidence when defining a dynamic <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="be398-1279">Среда выполнения будет сопоставлять объект <xref:System.Security.Policy.Evidence> с помощью политики безопасности для определения предоставленных разрешений.</span><span class="sxs-lookup"><span data-stu-id="be398-1279">The runtime will map the <xref:System.Security.Policy.Evidence> through the security policy to determine the granted permissions.</span></span> <span data-ttu-id="be398-1280">Частично доверенные вызывающие объекты `null` должны предоставляться `evidence` для параметра.</span><span class="sxs-lookup"><span data-stu-id="be398-1280">Partially trusted callers must supply `null` for the `evidence` parameter.</span></span> <span data-ttu-id="be398-1281">Если `evidence` имеет `null`значение, среда выполнения копирует наборы разрешений, то есть текущие наборы Grant и DENY <xref:System.Reflection.Assembly> , от вызывающей стороны к динамически <xref:System.Reflection.Assembly> определяемому и помечает политику как разрешенную.</span><span class="sxs-lookup"><span data-stu-id="be398-1281">If `evidence` is `null`, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <xref:System.Reflection.Assembly> to the dynamic <xref:System.Reflection.Assembly> being defined and marks policy as resolved.</span></span>  
  
 <span data-ttu-id="be398-1282">Если динамический <xref:System.Reflection.Assembly> объект сохраняется на диске, последующие загрузки получают разрешения на основе политик, связанных с расположением, в <xref:System.Reflection.Assembly> котором был сохранен.</span><span class="sxs-lookup"><span data-stu-id="be398-1282">If the dynamic <xref:System.Reflection.Assembly> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <xref:System.Reflection.Assembly> was saved.</span></span>  
  
 <span data-ttu-id="be398-1283">Если `isSynchronized` имеет `true`значение, то <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A> <xref:System.Reflection.Emit.AssemblyBuilder> <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A> <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A> <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A> будут синхронизированы <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A> следующие методы итогового результата:,,, , и. <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A></span><span class="sxs-lookup"><span data-stu-id="be398-1283">If `isSynchronized` is `true`, the following methods of the resulting <xref:System.Reflection.Emit.AssemblyBuilder> will be synchronized: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, and <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</span></span> <span data-ttu-id="be398-1284">Если два из этих методов вызываются в разных потоках, один из них будет заблокирован до завершения другого.</span><span class="sxs-lookup"><span data-stu-id="be398-1284">If two of these methods are called on different threads, one will block until the other completes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-1285">В следующем примере демонстрируется <xref:System.AppDomain.DefineDynamicAssembly%2A> метод и <xref:System.AppDomain.AssemblyResolve> событие.</span><span class="sxs-lookup"><span data-stu-id="be398-1285">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="be398-1286">Для выполнения этого примера кода необходимо указать полное имя сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1286">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="be398-1287">Дополнительные сведения о получении полного имени сборки см. в разделе [имена сборок](~/docs/framework/app-domains/assembly-names.md).</span><span class="sxs-lookup"><span data-stu-id="be398-1287">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-1288">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1288"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be398-1289">Свойство <see langword="Name" /> параметра <paramref name="name" /> равно <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1289">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="be398-1290">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-1290">-or-</span></span> 
<span data-ttu-id="be398-1291">Значение свойства <see langword="Name" /> параметра <paramref name="name" /> начинается с пробела или содержит символ прямой (обратной) косой черты.</span><span class="sxs-lookup"><span data-stu-id="be398-1291">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-1292">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1292">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="be398-1293">для загрузки сборки с свидетельством.</span><span class="sxs-lookup"><span data-stu-id="be398-1293">to load an assembly with evidence.</span></span> <span data-ttu-id="be398-1294">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1294">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions, isSynchronized, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="dir" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" Index="5" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" Index="6" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="isSynchronized" Type="System.Boolean" Index="7" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" Index="8" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="be398-1295">Уникальный идентификатор динамической сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1295">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="be398-1296">Режим, в котором будет осуществляться доступ к динамической сборке.</span><span class="sxs-lookup"><span data-stu-id="be398-1296">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="dir"><span data-ttu-id="be398-1297">Имя каталога, в котором будет сохранена динамическая сборка.</span><span class="sxs-lookup"><span data-stu-id="be398-1297">The name of the directory where the dynamic assembly will be saved.</span></span> <span data-ttu-id="be398-1298">Если значением параметра <paramref name="dir" /> является <see langword="null" />, используется текущий каталог.</span><span class="sxs-lookup"><span data-stu-id="be398-1298">If <paramref name="dir" /> is <see langword="null" />, the current directory is used.</span></span></param>
        <param name="evidence"><span data-ttu-id="be398-1299">Свидетельство, предоставленное для динамической сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1299">The evidence that is supplied for the dynamic assembly.</span></span> <span data-ttu-id="be398-1300">Используемое свидетельство является постоянным, как конечный набор свидетельств, используемых для разрешения политики.</span><span class="sxs-lookup"><span data-stu-id="be398-1300">The evidence is used unaltered as the final set of evidence used for policy resolution.</span></span></param>
        <param name="requiredPermissions"><span data-ttu-id="be398-1301">Запрос обязательных разрешений.</span><span class="sxs-lookup"><span data-stu-id="be398-1301">The required permissions request.</span></span></param>
        <param name="optionalPermissions"><span data-ttu-id="be398-1302">Запрос дополнительных разрешений.</span><span class="sxs-lookup"><span data-stu-id="be398-1302">The optional permissions request.</span></span></param>
        <param name="refusedPermissions"><span data-ttu-id="be398-1303">Запрос разрешений, в которых отказано.</span><span class="sxs-lookup"><span data-stu-id="be398-1303">The refused permissions request.</span></span></param>
        <param name="isSynchronized"><span data-ttu-id="be398-1304">Значение <see langword="true" />, чтобы синхронизировать создание модулей, типов и членов в динамической сборке, в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1304"><see langword="true" /> to synchronize the creation of modules, types, and members in the dynamic assembly; otherwise, <see langword="false" />.</span></span></param>
        <param name="assemblyAttributes"><span data-ttu-id="be398-1305">Перечислимый список атрибутов, которые будут применены к сборке, или значение <see langword="null" />, если атрибуты отсутствуют.</span><span class="sxs-lookup"><span data-stu-id="be398-1305">An enumerable list of attributes to be applied to the assembly, or <see langword="null" /> if there are no attributes.</span></span></param>
        <summary><span data-ttu-id="be398-1306">Определяет динамическую сборку с помощью указанного имени, режима доступа, каталога хранения, свидетельства, запросов разрешений, параметра синхронизации и настраиваемых атрибутов.</span><span class="sxs-lookup"><span data-stu-id="be398-1306">Defines a dynamic assembly with the specified name, access mode, storage directory, evidence, permission requests, synchronization option, and custom attributes.</span></span></summary>
        <returns><span data-ttu-id="be398-1307">Динамическая сборка с указанным именем и возможностями.</span><span class="sxs-lookup"><span data-stu-id="be398-1307">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-1308">Используйте эту перегрузку метода, чтобы указать атрибуты, которые не работают должным образом, если они не применяются при создании динамической сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1308">Use this method overload to specify attributes that do not work correctly unless they are applied when a dynamic assembly is created.</span></span> <span data-ttu-id="be398-1309">Например, такие атрибуты безопасности, как <xref:System.Security.SecurityTransparentAttribute> и <xref:System.Security.SecurityCriticalAttribute> , работают неправильно, если они добавляются после создания динамической сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1309">For example, security attributes such as <xref:System.Security.SecurityTransparentAttribute> and <xref:System.Security.SecurityCriticalAttribute> do not work correctly if they are added after a dynamic assembly has been created.</span></span>  
  
 <span data-ttu-id="be398-1310">Запросы разрешений `requiredPermissions`, указанные для параметров, `optionalPermissions`и `refusedPermissions` , используются только в `evidence` том случае, если указан параметр или если динамическая сборка сохраняется и перегружается в память.</span><span class="sxs-lookup"><span data-stu-id="be398-1310">The permission requests specified for the `requiredPermissions`, `optionalPermissions`, and `refusedPermissions` parameters are used only if the `evidence` parameter is also supplied, or if the dynamic assembly is saved and reloaded into memory.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="be398-1311">При разработке кода, который создает динамические сборки, рекомендуется включить <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> флаг `refusedPermissions` в параметр.</span><span class="sxs-lookup"><span data-stu-id="be398-1311">When you develop code that emits dynamic assemblies, we recommend that you include the <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> flag in the `refusedPermissions` parameter.</span></span> <span data-ttu-id="be398-1312">Включение этого флага гарантирует, что будет выполнена проверка промежуточного языка Microsoft (MSIL).</span><span class="sxs-lookup"><span data-stu-id="be398-1312">The inclusion of this flag ensures that the Microsoft intermediate language (MSIL) will be verified.</span></span> <span data-ttu-id="be398-1313">Этот метод обнаруживает непреднамеренное создание непроверяемого кода, которое в противном случае трудно обнаружить.</span><span class="sxs-lookup"><span data-stu-id="be398-1313">This technique will detect the unintentional generation of unverifiable code, which otherwise is very difficult to detect.</span></span> <span data-ttu-id="be398-1314">Ограничением этой методики является то, что оно <xref:System.Security.SecurityException> также вызывает исключение при использовании с кодом, требующим полного доверия.</span><span class="sxs-lookup"><span data-stu-id="be398-1314">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when it is used with code that demands full trust.</span></span>  
  
 <span data-ttu-id="be398-1315">Только полностью доверенные вызывающие объекты могут предоставлять свидетельство при определении <xref:System.Reflection.Assembly>динамического.</span><span class="sxs-lookup"><span data-stu-id="be398-1315">Only fully trusted callers can supply evidence when defining a dynamic <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="be398-1316">Среда выполнения сопоставляет объект <xref:System.Security.Policy.Evidence> с помощью политики безопасности, чтобы определить предоставленные разрешения.</span><span class="sxs-lookup"><span data-stu-id="be398-1316">The runtime maps the <xref:System.Security.Policy.Evidence> through the security policy to determine the granted permissions.</span></span> <span data-ttu-id="be398-1317">Частично доверенные вызывающие объекты `null` должны предоставляться `evidence` для параметра.</span><span class="sxs-lookup"><span data-stu-id="be398-1317">Partially trusted callers must supply `null` for the `evidence` parameter.</span></span> <span data-ttu-id="be398-1318">Если `evidence` имеет `null`значение, среда выполнения копирует наборы разрешений (то есть текущий набор Grant и Deny) из сборки вызывающего объекта в определяемую динамическую сборку и помечает политику как разрешенную.</span><span class="sxs-lookup"><span data-stu-id="be398-1318">If `evidence` is `null`, the runtime copies the permission sets (that is, the current grant and deny sets) from the caller's assembly to the dynamic assembly that is being defined, and marks the policy as resolved.</span></span>  
  
 <span data-ttu-id="be398-1319">Если динамическая сборка сохраняется на диске, последующие загрузки будут получать разрешения на основе политик, связанных с расположением, в котором была сохранена динамическая сборка.</span><span class="sxs-lookup"><span data-stu-id="be398-1319">If the dynamic assembly is saved to disk, subsequent loads will get grants based on policies that are associated with the location where the dynamic assembly was saved.</span></span>  
  
 <span data-ttu-id="be398-1320">Если `isSynchronized` имеет `true`значение, то <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A> <xref:System.Reflection.Emit.AssemblyBuilder> <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A> <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A> <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A> будут синхронизированы <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A> следующие методы итогового результата:,,, , и. <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A></span><span class="sxs-lookup"><span data-stu-id="be398-1320">If `isSynchronized` is `true`, the following methods of the resulting <xref:System.Reflection.Emit.AssemblyBuilder> will be synchronized: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, and <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</span></span> <span data-ttu-id="be398-1321">Если два из этих методов вызываются в разных потоках, один из них будет заблокирован до завершения другого.</span><span class="sxs-lookup"><span data-stu-id="be398-1321">If two of these methods are called on different threads, one will block until the other is completed.</span></span>  
  
 <span data-ttu-id="be398-1322">Эта перегрузка метода появилась в [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].</span><span class="sxs-lookup"><span data-stu-id="be398-1322">This method overload is introduced in the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-1323">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1323"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be398-1324">Свойство <see langword="Name" /> параметра <paramref name="name" /> равно <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1324">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="be398-1325">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-1325">-or-</span></span> 
<span data-ttu-id="be398-1326">Значение свойства <see langword="Name" /> объекта <paramref name="name" /> начинается с пробела или содержит символ прямой (обратной) косой черты.</span><span class="sxs-lookup"><span data-stu-id="be398-1326">The <see langword="Name" /> property of <paramref name="name" /> starts with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-1327">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1327">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="be398-1328">для загрузки сборки с свидетельством.</span><span class="sxs-lookup"><span data-stu-id="be398-1328">to load an assembly with evidence.</span></span> <span data-ttu-id="be398-1329">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1329">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DoCallBack">
      <MemberSignature Language="C#" Value="public void DoCallBack (CrossAppDomainDelegate callBackDelegate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DoCallBack(class System.CrossAppDomainDelegate callBackDelegate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DoCallBack (callBackDelegate As CrossAppDomainDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DoCallBack(CrossAppDomainDelegate ^ callBackDelegate);" />
      <MemberSignature Language="F#" Value="abstract member DoCallBack : CrossAppDomainDelegate -&gt; unit&#xA;override this.DoCallBack : CrossAppDomainDelegate -&gt; unit" Usage="appDomain.DoCallBack callBackDelegate" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DoCallBack(System.CrossAppDomainDelegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBackDelegate" Type="System.CrossAppDomainDelegate" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="callBackDelegate"><span data-ttu-id="be398-1330">Делегат, определяющий вызываемый метод.</span><span class="sxs-lookup"><span data-stu-id="be398-1330">A delegate that specifies a method to call.</span></span></param>
        <summary><span data-ttu-id="be398-1331">Выполняет код в другом домене приложения, который определен заданным делегатом.</span><span class="sxs-lookup"><span data-stu-id="be398-1331">Executes the code in another application domain that is identified by the specified delegate.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-1332">`callBackDelegate`может задавать маршалирование по значению, <xref:System.MarshalByRefObject>или. <xref:System.ContextBoundObject></span><span class="sxs-lookup"><span data-stu-id="be398-1332">`callBackDelegate` can specify a marshal-by-value, <xref:System.MarshalByRefObject>, or <xref:System.ContextBoundObject>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-1333">В следующем примере демонстрируется использование статического <xref:System.AppDomain.DoCallBack%2A> метода.</span><span class="sxs-lookup"><span data-stu-id="be398-1333">The following sample demonstrates using a static <xref:System.AppDomain.DoCallBack%2A> method.</span></span>  
  
 [!code-cpp[AppDomain_DoCallBack#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_static.cpp#1)]
 [!code-csharp[AppDomain_DoCallBack#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_static.cs#1)]
 [!code-vb[AppDomain_DoCallBack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_static.vb#1)]  
  
 <span data-ttu-id="be398-1334">В следующем примере демонстрируется использование <xref:System.AppDomain.DoCallBack%2A> метода по значению.</span><span class="sxs-lookup"><span data-stu-id="be398-1334">The following sample demonstrates using the <xref:System.AppDomain.DoCallBack%2A> method by value.</span></span>  
  
 [!code-cpp[AppDomain_DoCallBack#2](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byval.cpp#2)]
 [!code-csharp[AppDomain_DoCallBack#2](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byval.cs#2)]
 [!code-vb[AppDomain_DoCallBack#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byval.vb#2)]  
  
 <span data-ttu-id="be398-1335">В следующем примере демонстрируется использование <xref:System.AppDomain.DoCallBack%2A> метода по ссылке.</span><span class="sxs-lookup"><span data-stu-id="be398-1335">The following sample demonstrates using the <xref:System.AppDomain.DoCallBack%2A> method by reference.</span></span>  
  
 [!code-cpp[AppDomain_DoCallBack#3](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byref.cpp#3)]
 [!code-csharp[AppDomain_DoCallBack#3](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byref.cs#3)]
 [!code-vb[AppDomain_DoCallBack#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byref.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-1336">Свойство <paramref name="callBackDelegate" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1336"><paramref name="callBackDelegate" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DomainManager">
      <MemberSignature Language="C#" Value="public AppDomainManager DomainManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainManager DomainManager" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DomainManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DomainManager As AppDomainManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainManager ^ DomainManager { AppDomainManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DomainManager : AppDomainManager" Usage="System.AppDomain.DomainManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomainManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="be398-1337">Возвращает диспетчер домена, предоставленный средой размещения при инициализации домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1337">Gets the domain manager that was provided by the host when the application domain was initialized.</span></span></summary>
        <value><span data-ttu-id="be398-1338">Объект, который представляет диспетчер домена, предоставленный средой размещения при инициализации домена приложения, или значение <see langword="null" />, если диспетчер домена не предоставлен.</span><span class="sxs-lookup"><span data-stu-id="be398-1338">An object that represents the domain manager provided by the host when the application domain was initialized, or <see langword="null" /> if no domain manager was provided.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-1339">Неуправляемый узел среды CLR может предоставить диспетчер домена.</span><span class="sxs-lookup"><span data-stu-id="be398-1339">An unmanaged host of the common language runtime (CLR) can provide a domain manager.</span></span> <span data-ttu-id="be398-1340">Диспетчер домена может принять участие в инициализации нового домена приложения и предоставить другие диспетчеры, например <xref:System.Security.HostSecurityManager>, которые участвуют в операциях домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1340">The domain manager can participate in initializing the new application domain and supply other managers, such as a <xref:System.Security.HostSecurityManager>, that participate in the operations of the application domain.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="be398-1341">Требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="be398-1341">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="be398-1342">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="be398-1342">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="DomainUnload">
      <MemberSignature Language="C#" Value="public event EventHandler DomainUnload;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DomainUnload" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.DomainUnload" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DomainUnload As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ DomainUnload;" />
      <MemberSignature Language="F#" Value="member this.DomainUnload : EventHandler " Usage="member this.DomainUnload : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.DomainUnload</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>remove: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="be398-1343">Происходит непосредственно перед выгрузкой объекта <see cref="T:System.AppDomain" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1343">Occurs when an <see cref="T:System.AppDomain" /> is about to be unloaded.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-1344"><xref:System.EventHandler> Делегат для этого события может выполнять любые действия завершения до выгрузки домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1344">The <xref:System.EventHandler> delegate for this event can perform any termination activities before the application domain is unloaded.</span></span>  
  
 <span data-ttu-id="be398-1345">Каждый домен приложения, который должен выполнять обработку при выгрузке, должен зарегистрировать обработчик событий для этого события.</span><span class="sxs-lookup"><span data-stu-id="be398-1345">Each application domain that needs to perform processing when it is unloaded should register an event handler for this event.</span></span> <span data-ttu-id="be398-1346">Не следует использовать общий обработчик событий, так как <xref:System.EventHandler> делегат не определяет домен, который выгружается.</span><span class="sxs-lookup"><span data-stu-id="be398-1346">A shared event handler should not be used, because the <xref:System.EventHandler> delegate does not identify the domain that is being unloaded.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="be398-1347">Это событие никогда не возникает в домене приложения по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="be398-1347">This event is never raised in the default application domain.</span></span>  
  
 <span data-ttu-id="be398-1348">Не следует делать предположения о потоке, на котором возникло событие.</span><span class="sxs-lookup"><span data-stu-id="be398-1348">Do not make assumptions about the thread the event is raised on.</span></span> <span data-ttu-id="be398-1349">Событие может быть вызвано в потоке, отличном от того, который <xref:System.AppDomain.Unload%2A> вызвал метод.</span><span class="sxs-lookup"><span data-stu-id="be398-1349">The event can be raised on a different thread than the one that called the <xref:System.AppDomain.Unload%2A> method.</span></span>  
  
 <span data-ttu-id="be398-1350">Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).</span><span class="sxs-lookup"><span data-stu-id="be398-1350">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicDirectory">
      <MemberSignature Language="C#" Value="public string DynamicDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DynamicDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DynamicDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DynamicDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DynamicDirectory : string" Usage="System.AppDomain.DynamicDirectory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.DynamicDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="be398-1351">Возвращает каталог, в котором распознаватель сборок производит поиск динамически созданных сборок.</span><span class="sxs-lookup"><span data-stu-id="be398-1351">Gets the directory that the assembly resolver uses to probe for dynamically created assemblies.</span></span></summary>
        <value><span data-ttu-id="be398-1352">Каталог, в котором распознаватель сборок производит поиск динамически созданных сборок.</span><span class="sxs-lookup"><span data-stu-id="be398-1352">The directory that the assembly resolver uses to probe for dynamically created assemblies.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-1353">Чтобы задать динамический каталог, назначьте путь <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> к базовому каталогу свойству <xref:System.AppDomainSetup> объекта, который будет использоваться для создания нового домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1353">To set the dynamic directory, assign a base directory path to the <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> property of the <xref:System.AppDomainSetup> object that will be used to create the new application domain.</span></span> <span data-ttu-id="be398-1354">Базовый путь к каталогу, который назначается свойству, изменяется добавлением подкаталога, простое имя которого является хэш-кодом строки, назначаемой <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> свойству, поэтому формат базового каталога — *Исходный путь* \\ . *хэш-код*.</span><span class="sxs-lookup"><span data-stu-id="be398-1354">The base directory path you assign to the property is modified by the addition of a subdirectory whose simple name is the hash code of the string you assign to the <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> property, so the format of the base directory is *original path*\\*hash code*.</span></span> <span data-ttu-id="be398-1355">Динамический каталог — это подкаталог этого базового каталога.</span><span class="sxs-lookup"><span data-stu-id="be398-1355">The dynamic directory is a subdirectory of this base directory.</span></span> <span data-ttu-id="be398-1356">Его простое имя является <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> значением свойства, поэтому его форматом является*имя приложения\*\*хэш-кода*\\ *исходного пути*\\.</span><span class="sxs-lookup"><span data-stu-id="be398-1356">Its simple name is the value of the <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> property, so its format is *original path*\\*hash code*\\*application name*.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-1357">В следующем примере создается домен приложения с каталогом для динамических сборок, выдается динамическая сборка и сохраняется в динамическом каталоге, а затем эта сборка загружается в новый домен приложения и используется.</span><span class="sxs-lookup"><span data-stu-id="be398-1357">The following example creates an application domain with a directory for dynamic assemblies, emits a dynamic assembly and stores it in the dynamic directory, and then loads the assembly into the new application domain and uses it.</span></span>  
  
 <span data-ttu-id="be398-1358">В примере создается <xref:System.AppDomainSetup> объект и <xref:System.AppDomainSetup.ApplicationName%2A> свойству присваивается значение example, а <xref:System.AppDomainSetup.DynamicBase%2A> свойству — значение "к:\динамикассемблидир".</span><span class="sxs-lookup"><span data-stu-id="be398-1358">The example creates an <xref:System.AppDomainSetup> object and sets its <xref:System.AppDomainSetup.ApplicationName%2A> property to "Example" and its <xref:System.AppDomainSetup.DynamicBase%2A> property to "C:\DynamicAssemblyDir".</span></span> <span data-ttu-id="be398-1359">Затем в примере отображается <xref:System.AppDomainSetup.DynamicBase%2A> свойство, чтобы показать, что хэш-код имени приложения был добавлен в качестве подкаталога изначально назначенного пути.</span><span class="sxs-lookup"><span data-stu-id="be398-1359">The example then displays the <xref:System.AppDomainSetup.DynamicBase%2A> property, to show that the hash code of the application name has been appended as a subdirectory of the path that was originally assigned.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="be398-1360">Базовый каталог в этом примере должен находиться за пределами пути поиска для примера приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1360">The base directory in this example is intended to be outside the probing path for the example application.</span></span> <span data-ttu-id="be398-1361">Не забудьте скомпилировать пример в другом расположении.</span><span class="sxs-lookup"><span data-stu-id="be398-1361">Be sure to compile the example in a different location.</span></span> <span data-ttu-id="be398-1362">При каждом запуске примера удалите базовый каталог и все его подкаталоги.</span><span class="sxs-lookup"><span data-stu-id="be398-1362">Delete the base directory and all its subdirectories each time you run the example.</span></span>  
  
 <span data-ttu-id="be398-1363">В примере создается новый домен приложения с помощью <xref:System.AppDomainSetup> объекта.</span><span class="sxs-lookup"><span data-stu-id="be398-1363">The example creates a new application domain, using the <xref:System.AppDomainSetup> object.</span></span> <span data-ttu-id="be398-1364">В примере <xref:System.AppDomain.DynamicDirectory%2A> свойство используется для получения имени каталога, чтобы он мог создать каталог.</span><span class="sxs-lookup"><span data-stu-id="be398-1364">The example uses the <xref:System.AppDomain.DynamicDirectory%2A> property to retrieve the name of the directory, so it can create the directory.</span></span> <span data-ttu-id="be398-1365">(В этом примере можно просто создать каталог путем сцепления исходного пути, хэш-кода имени приложения и имени приложения).</span><span class="sxs-lookup"><span data-stu-id="be398-1365">(The example could just as easily create the directory beforehand by concatenating the original path, the hash code of the application name, and the application name.)</span></span>  
  
 <span data-ttu-id="be398-1366">В примере имеется `GenerateDynamicAssembly` метод, создающий сборку с именем `DynamicHelloWorld.dll` и сохраняющий ее в динамическом каталоге нового домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1366">The example has a `GenerateDynamicAssembly` method that emits an assembly named `DynamicHelloWorld.dll` and stores it in the new application domain's dynamic directory.</span></span> <span data-ttu-id="be398-1367">Динамическая сборка содержит один тип `HelloWorld`, который имеет статический метод (`Shared` метод в Visual Basic) с именем `HelloFromAD`.</span><span class="sxs-lookup"><span data-stu-id="be398-1367">The dynamic assembly contains one type, `HelloWorld`, that has a static method (`Shared` method in Visual Basic) named `HelloFromAD`.</span></span> <span data-ttu-id="be398-1368">При вызове этого метода отображается имя домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1368">Calling this method displays the name of the application domain.</span></span>  
  
 <span data-ttu-id="be398-1369">Класс является производным от <xref:System.MarshalByRefObject>, поэтому в примере можно создать экземпляр класса в новом домене приложения и вызвать его `Test` метод. `Example`</span><span class="sxs-lookup"><span data-stu-id="be398-1369">The `Example` class derives from <xref:System.MarshalByRefObject>, so the example can create an instance of the class in the new application domain and call its `Test` method.</span></span> <span data-ttu-id="be398-1370">Метод загружает динамическую сборку по отображаемому имени и вызывает статический `HelloFromAD` метод. `Test`</span><span class="sxs-lookup"><span data-stu-id="be398-1370">The `Test` method loads the dynamic assembly by its display name and calls the static `HelloFromAD` method.</span></span>  
  
 <span data-ttu-id="be398-1371">Можно увидеть, что поиск в динамическом каталоге выполняется после обычных путей поиска путем написания кода для сборки с именем `DynamicHelloWorld.dll` и его компиляции в том же каталоге, что и этот пример.</span><span class="sxs-lookup"><span data-stu-id="be398-1371">You can show that the dynamic directory is searched after the normal probing paths by writing code for an assembly named `DynamicHelloWorld.dll` and compiling it in the same directory as this example.</span></span> <span data-ttu-id="be398-1372">Сборка должна иметь класс с именем `HelloWorld` и статическим методом с именем. `HelloFromAD`</span><span class="sxs-lookup"><span data-stu-id="be398-1372">The assembly must have a class named `HelloWorld` with a static method named `HelloFromAD`.</span></span> <span data-ttu-id="be398-1373">Этот метод не обязательно должен иметь те же функциональные возможности, что и в примере. Он может просто отобразить строку в консоли.</span><span class="sxs-lookup"><span data-stu-id="be398-1373">This method does not have to have the same functionality as the one in the example; it can simply display a string to the console.</span></span> <span data-ttu-id="be398-1374">Сборка также должна иметь <xref:System.Reflection.AssemblyVersionAttribute> атрибут, который устанавливает для его версии значение 1.0.0.0.</span><span class="sxs-lookup"><span data-stu-id="be398-1374">The assembly must also have an <xref:System.Reflection.AssemblyVersionAttribute> attribute that sets its version to 1.0.0.0.</span></span> <span data-ttu-id="be398-1375">При выполнении примера сборка, скомпилированная в текущем каталоге, обнаруживается до того, как будет выполнен поиск в динамическом каталоге.</span><span class="sxs-lookup"><span data-stu-id="be398-1375">When you run the example, the assembly you compiled in the current directory is found before the dynamic directory is searched.</span></span>  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-1376">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1376">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="be398-1377">для доступа к сведениям о пути.</span><span class="sxs-lookup"><span data-stu-id="be398-1377">for access to the path information.</span></span> <span data-ttu-id="be398-1378">Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1378">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Evidence" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Evidence As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::Evidence ^ Evidence { System::Security::Policy::Evidence ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Evidence : System.Security.Policy.Evidence" Usage="System.AppDomain.Evidence" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Security.IEvidenceFactory.Evidence</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="be398-1379">Получает <see cref="T:System.Security.Policy.Evidence" />, связанное с этим доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1379">Gets the <see cref="T:System.Security.Policy.Evidence" /> associated with this application domain.</span></span></summary>
        <value><span data-ttu-id="be398-1380">Свидетельство, связанное с данным доменом приложений.</span><span class="sxs-lookup"><span data-stu-id="be398-1380">The evidence associated with this application domain.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-1381">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1381">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="be398-1382">для загрузки сборки с свидетельством.</span><span class="sxs-lookup"><span data-stu-id="be398-1382">to load an assembly with evidence.</span></span> <span data-ttu-id="be398-1383">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1383">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span> <span data-ttu-id="be398-1384">Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1384">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="be398-1385">Выполняет сборку, содержащуюся в указанном файле.</span><span class="sxs-lookup"><span data-stu-id="be398-1385">Executes the assembly contained in the specified file.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string -&gt; int&#xA;override this.ExecuteAssembly : string -&gt; int" Usage="appDomain.ExecuteAssembly assemblyFile" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="be398-1386">Имя файла, содержащего сборку, которую необходимо выполнить.</span><span class="sxs-lookup"><span data-stu-id="be398-1386">The name of the file that contains the assembly to execute.</span></span></param>
        <summary><span data-ttu-id="be398-1387">Выполняет сборку, содержащуюся в указанном файле.</span><span class="sxs-lookup"><span data-stu-id="be398-1387">Executes the assembly contained in the specified file.</span></span></summary>
        <returns><span data-ttu-id="be398-1388">Значение, возвращаемое точкой входа сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1388">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-1389">Сборка начинает выполняться в точке входа, указанной в заголовке .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="be398-1389">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="be398-1390">Этот метод не создает новый процесс или домен приложения и не выполняет метод точки входа в новом потоке.</span><span class="sxs-lookup"><span data-stu-id="be398-1390">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="be398-1391">Этот метод загружает сборки с <xref:System.Reflection.Assembly.LoadFile%2A> помощью метода.</span><span class="sxs-lookup"><span data-stu-id="be398-1391">This method loads assemblies using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="be398-1392">Сборки также можно выполнять с помощью <xref:System.AppDomain.ExecuteAssemblyByName%2A> метода, который загружает сборки <xref:System.Reflection.Assembly.Load%2A> с помощью метода.</span><span class="sxs-lookup"><span data-stu-id="be398-1392">You can also execute assemblies using the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method, which loads assemblies using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
 <span data-ttu-id="be398-1393">Чтобы создать объект <xref:System.AppDomain> для загрузки и выполнения, <xref:System.AppDomain.CreateDomain%2A> используйте метод.</span><span class="sxs-lookup"><span data-stu-id="be398-1393">To create the <xref:System.AppDomain> to load and execute, use the <xref:System.AppDomain.CreateDomain%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-1394">В следующем примере демонстрируется использование одной из перегрузок <xref:System.AppDomain.ExecuteAssembly%2A> в двух разных доменах.</span><span class="sxs-lookup"><span data-stu-id="be398-1394">The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.</span></span>  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-1395"><paramref name="assemblyFile" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1395"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="be398-1396"><paramref name="assemblyFile" /> не найден.</span><span class="sxs-lookup"><span data-stu-id="be398-1396"><paramref name="assemblyFile" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="be398-1397"><paramref name="assemblyFile" /> не является допустимой сборкой.</span><span class="sxs-lookup"><span data-stu-id="be398-1397"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="be398-1398">-или-</span><span class="sxs-lookup"><span data-stu-id="be398-1398">-or-</span></span> 
<span data-ttu-id="be398-1399">Сейчас загружена среда CLR 2.0 или более поздней версии. Сборка <paramref name="assemblyFile" /> скомпилирована в более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="be398-1399">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-1400">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1400">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="be398-1401">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</span><span class="sxs-lookup"><span data-stu-id="be398-1401">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="be398-1402">Указанная сборка не имеет точку входа.</span><span class="sxs-lookup"><span data-stu-id="be398-1402">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="be398-1403">для доступа к чтению из файла или каталога, а также для доступа к данным в самом пути.</span><span class="sxs-lookup"><span data-stu-id="be398-1403">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="be398-1404">Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1404">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="be398-1405">для чтения URI, который не начинается с "file://".</span><span class="sxs-lookup"><span data-stu-id="be398-1405">for reading a URI that does not begin with "file://".</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="be398-1406">для выполнения консольного приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1406">to execute a console application.</span></span> <span data-ttu-id="be398-1407">Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1407">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string * System.Security.Policy.Evidence -&gt; int&#xA;override this.ExecuteAssembly : string * System.Security.Policy.Evidence -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="be398-1408">Имя файла, содержащего сборку, которую необходимо выполнить.</span><span class="sxs-lookup"><span data-stu-id="be398-1408">The name of the file that contains the assembly to execute.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="be398-1409">Свидетельство для загрузки сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1409">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="be398-1410">Выполняет сборку, содержащуюся в указанном файле, с использованием заданного свидетельства.</span><span class="sxs-lookup"><span data-stu-id="be398-1410">Executes the assembly contained in the specified file, using the specified evidence.</span></span></summary>
        <returns><span data-ttu-id="be398-1411">Значение, возвращаемое точкой входа сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1411">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-1412">Сборка начинает выполняться в точке входа, указанной в заголовке .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="be398-1412">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="be398-1413"><xref:System.AppDomain.ExecuteAssembly%2A> Метод не создает новый процесс или домен приложения и не выполняет метод точки входа в новом потоке.</span><span class="sxs-lookup"><span data-stu-id="be398-1413">The <xref:System.AppDomain.ExecuteAssembly%2A> method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="be398-1414">Этот метод загружает сборки с <xref:System.Reflection.Assembly.LoadFile%2A> помощью метода.</span><span class="sxs-lookup"><span data-stu-id="be398-1414">This method loads assemblies using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="be398-1415">Сборки также можно выполнять с помощью <xref:System.AppDomain.ExecuteAssemblyByName%2A> метода, который загружает сборки <xref:System.Reflection.Assembly.Load%2A> с помощью метода.</span><span class="sxs-lookup"><span data-stu-id="be398-1415">You can also execute assemblies using the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method, which loads assemblies using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-1416">В следующем примере демонстрируется использование одной из перегрузок <xref:System.AppDomain.ExecuteAssembly%2A> в двух разных доменах.</span><span class="sxs-lookup"><span data-stu-id="be398-1416">The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.</span></span>  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-1417">Свойство <paramref name="assemblyFile" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1417"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="be398-1418"><paramref name="assemblyFile" /> не найден.</span><span class="sxs-lookup"><span data-stu-id="be398-1418"><paramref name="assemblyFile" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="be398-1419"><paramref name="assemblyFile" /> не является допустимой сборкой.</span><span class="sxs-lookup"><span data-stu-id="be398-1419"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="be398-1420">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-1420">-or-</span></span> 
<span data-ttu-id="be398-1421">Сейчас загружена среда CLR 2.0 или более поздней версии. Сборка <paramref name="assemblyFile" /> скомпилирована в более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="be398-1421">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-1422">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1422">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="be398-1423">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</span><span class="sxs-lookup"><span data-stu-id="be398-1423">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="be398-1424">Указанная сборка не имеет точку входа.</span><span class="sxs-lookup"><span data-stu-id="be398-1424">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="be398-1425">для загрузки сборки с свидетельством.</span><span class="sxs-lookup"><span data-stu-id="be398-1425">to load an assembly with evidence.</span></span> <span data-ttu-id="be398-1426">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1426">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="be398-1427">для доступа к чтению из файла или каталога, а также для доступа к данным в самом пути.</span><span class="sxs-lookup"><span data-stu-id="be398-1427">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="be398-1428">Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1428">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="be398-1429">для чтения URI, который не начинается с "file://".</span><span class="sxs-lookup"><span data-stu-id="be398-1429">for reading a URI that does not begin with "file://".</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="be398-1430">для выполнения консольного приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1430">to execute a console application.</span></span> <span data-ttu-id="be398-1431">Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1431">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * string[] -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="be398-1432">Имя файла, содержащего сборку, которую необходимо выполнить.</span><span class="sxs-lookup"><span data-stu-id="be398-1432">The name of the file that contains the assembly to execute.</span></span></param>
        <param name="args"><span data-ttu-id="be398-1433">Аргументы, передаваемые в точку входа сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1433">The arguments to the entry point of the assembly.</span></span></param>
        <summary><span data-ttu-id="be398-1434">Выполняет сборку, содержащуюся в указанном файле, с использованием заданных аргументов.</span><span class="sxs-lookup"><span data-stu-id="be398-1434">Executes the assembly contained in the specified file, using the specified arguments.</span></span></summary>
        <returns><span data-ttu-id="be398-1435">Значение, возвращаемое точкой входа сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1435">The value that is returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-1436">Сборка начинает выполняться в точке входа, указанной в заголовке .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="be398-1436">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="be398-1437">Этот метод не создает новый процесс или домен приложения и не выполняет метод точки входа в новом потоке.</span><span class="sxs-lookup"><span data-stu-id="be398-1437">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="be398-1438">Этот метод загружает сборки с <xref:System.Reflection.Assembly.LoadFile%2A> помощью метода.</span><span class="sxs-lookup"><span data-stu-id="be398-1438">This method loads assemblies using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="be398-1439">Сборки также можно выполнять с помощью <xref:System.AppDomain.ExecuteAssemblyByName%2A> метода, который загружает сборки <xref:System.Reflection.Assembly.Load%2A> с помощью метода.</span><span class="sxs-lookup"><span data-stu-id="be398-1439">You can also execute assemblies using the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method, which loads assemblies using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-1440">В следующем примере демонстрируется использование одной из перегрузок <xref:System.AppDomain.ExecuteAssembly%2A> в двух разных доменах.</span><span class="sxs-lookup"><span data-stu-id="be398-1440">The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.</span></span>  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-1441">Свойство <paramref name="assemblyFile" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1441"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="be398-1442"><paramref name="assemblyFile" /> не найден.</span><span class="sxs-lookup"><span data-stu-id="be398-1442"><paramref name="assemblyFile" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="be398-1443"><paramref name="assemblyFile" /> не является допустимой сборкой.</span><span class="sxs-lookup"><span data-stu-id="be398-1443"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="be398-1444">-или-</span><span class="sxs-lookup"><span data-stu-id="be398-1444">-or-</span></span> 
 <span data-ttu-id="be398-1445"><paramref name="assemblyFile" /> была скомпилирована для версии среды CLR, которая является более поздней, чем версия, которая в настоящий момент загружена.</span><span class="sxs-lookup"><span data-stu-id="be398-1445"><paramref name="assemblyFile" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-1446">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1446">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="be398-1447">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</span><span class="sxs-lookup"><span data-stu-id="be398-1447">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="be398-1448">Указанная сборка не имеет точку входа.</span><span class="sxs-lookup"><span data-stu-id="be398-1448">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="be398-1449">для доступа к чтению из файла или каталога, а также для доступа к данным в самом пути.</span><span class="sxs-lookup"><span data-stu-id="be398-1449">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="be398-1450">Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1450">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="be398-1451">для чтения URI, который не начинается с "file://".</span><span class="sxs-lookup"><span data-stu-id="be398-1451">for reading a URI that does not begin with "file://".</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="be398-1452">для выполнения консольного приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1452">to execute a console application.</span></span> <span data-ttu-id="be398-1453">Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1453">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string * System.Security.Policy.Evidence * string[] -&gt; int&#xA;override this.ExecuteAssembly : string * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="be398-1454">Имя файла, содержащего сборку, которую необходимо выполнить.</span><span class="sxs-lookup"><span data-stu-id="be398-1454">The name of the file that contains the assembly to execute.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="be398-1455">Предоставленное свидетельство для сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1455">The supplied evidence for the assembly.</span></span></param>
        <param name="args"><span data-ttu-id="be398-1456">Аргументы, передаваемые в точку входа сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1456">The arguments to the entry point of the assembly.</span></span></param>
        <summary><span data-ttu-id="be398-1457">Выполняет сборку, содержащуюся в указанном файле, с использованием заданного свидетельства и аргументов.</span><span class="sxs-lookup"><span data-stu-id="be398-1457">Executes the assembly contained in the specified file, using the specified evidence and arguments.</span></span></summary>
        <returns><span data-ttu-id="be398-1458">Значение, возвращаемое точкой входа сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1458">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-1459">Сборка начинает выполняться в точке входа, указанной в заголовке .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="be398-1459">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="be398-1460">Этот метод не создает новый процесс или домен приложения и не выполняет метод точки входа в новом потоке.</span><span class="sxs-lookup"><span data-stu-id="be398-1460">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="be398-1461">Этот метод загружает сборки с <xref:System.Reflection.Assembly.LoadFile%2A> помощью метода.</span><span class="sxs-lookup"><span data-stu-id="be398-1461">This method loads assemblies using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="be398-1462">Сборки также можно выполнять с помощью <xref:System.AppDomain.ExecuteAssemblyByName%2A> метода, который загружает сборки <xref:System.Reflection.Assembly.Load%2A> с помощью метода.</span><span class="sxs-lookup"><span data-stu-id="be398-1462">You can also execute assemblies using the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method, which loads assemblies using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-1463">В следующем примере демонстрируется использование одной из перегрузок <xref:System.AppDomain.ExecuteAssembly%2A> в двух разных доменах.</span><span class="sxs-lookup"><span data-stu-id="be398-1463">The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.</span></span>  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-1464">Свойство <paramref name="assemblyFile" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1464"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="be398-1465"><paramref name="assemblyFile" /> не найден.</span><span class="sxs-lookup"><span data-stu-id="be398-1465"><paramref name="assemblyFile" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="be398-1466"><paramref name="assemblyFile" /> не является допустимой сборкой.</span><span class="sxs-lookup"><span data-stu-id="be398-1466"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="be398-1467">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-1467">-or-</span></span> 
<span data-ttu-id="be398-1468">Сейчас загружена среда CLR 2.0 или более поздней версии. Сборка <paramref name="assemblyFile" /> скомпилирована в более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="be398-1468">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-1469">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1469">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="be398-1470">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</span><span class="sxs-lookup"><span data-stu-id="be398-1470">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="be398-1471"><paramref name="assemblySecurity" /> не является <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1471"><paramref name="assemblySecurity" /> is not <see langword="null" />.</span></span> <span data-ttu-id="be398-1472">Если не включена политика разграничения доступа кода для кода предыдущей версии, <paramref name="assemblySecurity" /> должно иметь значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1472">When legacy CAS policy is not enabled, <paramref name="assemblySecurity" /> should be <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="be398-1473">Указанная сборка не имеет точку входа.</span><span class="sxs-lookup"><span data-stu-id="be398-1473">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="be398-1474">для загрузки сборки с свидетельством.</span><span class="sxs-lookup"><span data-stu-id="be398-1474">to load an assembly with evidence.</span></span> <span data-ttu-id="be398-1475">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1475">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="be398-1476">для доступа к чтению из файла или каталога, а также для доступа к данным в самом пути.</span><span class="sxs-lookup"><span data-stu-id="be398-1476">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="be398-1477">Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1477">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="be398-1478">для чтения URI, который не начинается с "file://".</span><span class="sxs-lookup"><span data-stu-id="be398-1478">for reading a URI that does not begin with "file://".</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="be398-1479">для выполнения консольного приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1479">to execute a console application.</span></span> <span data-ttu-id="be398-1480">Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1480">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * string[] * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, args, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="be398-1481">Имя файла, содержащего сборку, которую необходимо выполнить.</span><span class="sxs-lookup"><span data-stu-id="be398-1481">The name of the file that contains the assembly to execute.</span></span></param>
        <param name="args"><span data-ttu-id="be398-1482">Аргументы, передаваемые в точку входа сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1482">The arguments to the entry point of the assembly.</span></span></param>
        <param name="hashValue"><span data-ttu-id="be398-1483">Представляет значение вычисляемого хэш-кода.</span><span class="sxs-lookup"><span data-stu-id="be398-1483">Represents the value of the computed hash code.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="be398-1484">Представляет алгоритм хэширования, используемый манифестом сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1484">Represents the hash algorithm used by the assembly manifest.</span></span></param>
        <summary><span data-ttu-id="be398-1485">Выполняет сборку, содержащуюся в указанном файле, с использованием заданных аргументов, хэш-значения и хэш-алгоритма.</span><span class="sxs-lookup"><span data-stu-id="be398-1485">Executes the assembly contained in the specified file, using the specified arguments, hash value, and hash algorithm.</span></span></summary>
        <returns><span data-ttu-id="be398-1486">Значение, возвращаемое точкой входа сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1486">The value that is returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-1487">Сборка начинает выполняться в точке входа, указанной в заголовке .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="be398-1487">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="be398-1488">Этот метод не создает новый процесс или домен приложения и не выполняет метод точки входа в новом потоке.</span><span class="sxs-lookup"><span data-stu-id="be398-1488">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="be398-1489">Этот метод загружает сборки с <xref:System.Reflection.Assembly.LoadFile%2A> помощью метода.</span><span class="sxs-lookup"><span data-stu-id="be398-1489">This method loads assemblies using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="be398-1490">Сборки также можно выполнять с помощью <xref:System.AppDomain.ExecuteAssemblyByName%2A> метода, который загружает сборки <xref:System.Reflection.Assembly.Load%2A> с помощью метода.</span><span class="sxs-lookup"><span data-stu-id="be398-1490">You can also execute assemblies using the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method, which loads assemblies using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-1491">В следующем примере демонстрируется использование одной из перегрузок <xref:System.AppDomain.ExecuteAssembly%2A> в двух разных доменах.</span><span class="sxs-lookup"><span data-stu-id="be398-1491">The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.</span></span>  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-1492">Свойство <paramref name="assemblyFile" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1492"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="be398-1493"><paramref name="assemblyFile" /> не найден.</span><span class="sxs-lookup"><span data-stu-id="be398-1493"><paramref name="assemblyFile" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="be398-1494"><paramref name="assemblyFile" /> не является допустимой сборкой.</span><span class="sxs-lookup"><span data-stu-id="be398-1494"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="be398-1495">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-1495">-or-</span></span> 
 <span data-ttu-id="be398-1496"><paramref name="assemblyFile" /> была скомпилирована для версии среды CLR, которая является более поздней, чем версия, которая в настоящий момент загружена.</span><span class="sxs-lookup"><span data-stu-id="be398-1496"><paramref name="assemblyFile" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-1497">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1497">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="be398-1498">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</span><span class="sxs-lookup"><span data-stu-id="be398-1498">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="be398-1499">Указанная сборка не имеет точку входа.</span><span class="sxs-lookup"><span data-stu-id="be398-1499">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="be398-1500">для доступа к чтению из файла или каталога, а также для доступа к данным в самом пути.</span><span class="sxs-lookup"><span data-stu-id="be398-1500">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="be398-1501">Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1501">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="be398-1502">для чтения URI, который не начинается с "file://".</span><span class="sxs-lookup"><span data-stu-id="be398-1502">for reading a URI that does not begin with "file://".</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="be398-1503">для выполнения консольного приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1503">to execute a console application.</span></span> <span data-ttu-id="be398-1504">Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1504">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * System.Security.Policy.Evidence * string[] * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity, args, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashValue" Type="System.Byte[]" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="be398-1505">Имя файла, содержащего сборку, которую необходимо выполнить.</span><span class="sxs-lookup"><span data-stu-id="be398-1505">The name of the file that contains the assembly to execute.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="be398-1506">Предоставленное свидетельство для сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1506">The supplied evidence for the assembly.</span></span></param>
        <param name="args"><span data-ttu-id="be398-1507">Аргументы, передаваемые в точку входа сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1507">The arguments to the entry point of the assembly.</span></span></param>
        <param name="hashValue"><span data-ttu-id="be398-1508">Представляет значение вычисляемого хэш-кода.</span><span class="sxs-lookup"><span data-stu-id="be398-1508">Represents the value of the computed hash code.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="be398-1509">Представляет хэш-алгоритм, используемый манифестом сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1509">Represents the hash algorithm used by the assembly manifest.</span></span></param>
        <summary><span data-ttu-id="be398-1510">Выполняет сборку, содержащуюся в указанном файле, с использованием заданного свидетельства, аргументов, хэш-значения и хэш-алгоритма.</span><span class="sxs-lookup"><span data-stu-id="be398-1510">Executes the assembly contained in the specified file, using the specified evidence, arguments, hash value, and hash algorithm.</span></span></summary>
        <returns><span data-ttu-id="be398-1511">Значение, возвращаемое точкой входа сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1511">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-1512">Сборка начинает выполняться в точке входа, указанной в заголовке .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="be398-1512">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="be398-1513">Этот метод не создает новый процесс или домен приложения и не выполняет метод точки входа в новом потоке.</span><span class="sxs-lookup"><span data-stu-id="be398-1513">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="be398-1514">Этот метод загружает сборки с <xref:System.Reflection.Assembly.LoadFile%2A> помощью метода.</span><span class="sxs-lookup"><span data-stu-id="be398-1514">This method loads assemblies using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="be398-1515">Сборки также можно выполнять с помощью <xref:System.AppDomain.ExecuteAssemblyByName%2A> метода, который загружает сборки <xref:System.Reflection.Assembly.Load%2A> с помощью метода.</span><span class="sxs-lookup"><span data-stu-id="be398-1515">You can also execute assemblies using the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method, which loads assemblies using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-1516">В следующем примере демонстрируется использование одной из перегрузок <xref:System.AppDomain.ExecuteAssembly%2A> в двух разных доменах.</span><span class="sxs-lookup"><span data-stu-id="be398-1516">The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.</span></span>  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-1517">Свойство <paramref name="assemblyFile" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1517"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="be398-1518"><paramref name="assemblyFile" /> не найден.</span><span class="sxs-lookup"><span data-stu-id="be398-1518"><paramref name="assemblyFile" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="be398-1519"><paramref name="assemblyFile" /> не является допустимой сборкой.</span><span class="sxs-lookup"><span data-stu-id="be398-1519"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="be398-1520">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-1520">-or-</span></span> 
<span data-ttu-id="be398-1521">Сейчас загружена среда CLR 2.0 или более поздней версии. Сборка <paramref name="assemblyFile" /> скомпилирована в более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="be398-1521">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-1522">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1522">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="be398-1523">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</span><span class="sxs-lookup"><span data-stu-id="be398-1523">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="be398-1524"><paramref name="assemblySecurity" /> не является <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1524"><paramref name="assemblySecurity" /> is not <see langword="null" />.</span></span> <span data-ttu-id="be398-1525">Если не включена политика разграничения доступа кода для кода предыдущей версии, <paramref name="assemblySecurity" /> должно иметь значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1525">When legacy CAS policy is not enabled, <paramref name="assemblySecurity" /> should be <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="be398-1526">Указанная сборка не имеет точку входа.</span><span class="sxs-lookup"><span data-stu-id="be398-1526">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="be398-1527">для загрузки сборки с свидетельством.</span><span class="sxs-lookup"><span data-stu-id="be398-1527">to load an assembly with evidence.</span></span> <span data-ttu-id="be398-1528">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1528">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="be398-1529">для доступа к чтению из файла или каталога, а также для доступа к данным в самом пути.</span><span class="sxs-lookup"><span data-stu-id="be398-1529">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="be398-1530">Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1530">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="be398-1531">для чтения URI, который не начинается с "file://".</span><span class="sxs-lookup"><span data-stu-id="be398-1531">for reading a URI that does not begin with "file://".</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="be398-1532">для выполнения консольного приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1532">to execute a console application.</span></span> <span data-ttu-id="be398-1533">Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1533">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssemblyByName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="be398-1534">Выполняет сборку.</span><span class="sxs-lookup"><span data-stu-id="be398-1534">Executes an assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string -&gt; int" Usage="appDomain.ExecuteAssemblyByName assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="be398-1535">Отображаемое имя сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1535">The display name of the assembly.</span></span> <span data-ttu-id="be398-1536">См. раздел <see cref="P:System.Reflection.Assembly.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1536">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <summary><span data-ttu-id="be398-1537">Выполняет сборку, определенную ее отображаемым именем.</span><span class="sxs-lookup"><span data-stu-id="be398-1537">Executes an assembly given its display name.</span></span></summary>
        <returns><span data-ttu-id="be398-1538">Значение, возвращаемое точкой входа сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1538">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-1539">Метод обеспечивает аналогичные функции <xref:System.AppDomain.ExecuteAssembly%2A> для метода, но указывает сборку по отображаемому имени или <xref:System.Reflection.AssemblyName> , а не по расположению файла. <xref:System.AppDomain.ExecuteAssemblyByName%2A></span><span class="sxs-lookup"><span data-stu-id="be398-1539">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method provides similar functionality to the <xref:System.AppDomain.ExecuteAssembly%2A> method, but specifies the assembly by display name or <xref:System.Reflection.AssemblyName> rather than by file location.</span></span> <span data-ttu-id="be398-1540">Таким образом <xref:System.AppDomain.ExecuteAssemblyByName%2A> , загружает сборки <xref:System.Reflection.Assembly.Load%2A> с помощью <xref:System.Reflection.Assembly.LoadFile%2A> метода, а не с помощью метода.</span><span class="sxs-lookup"><span data-stu-id="be398-1540">Therefore, <xref:System.AppDomain.ExecuteAssemblyByName%2A> loads assemblies with the <xref:System.Reflection.Assembly.Load%2A> method rather than with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="be398-1541">Сборка начинает выполняться в точке входа, указанной в заголовке .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="be398-1541">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="be398-1542">Этот метод не создает новый процесс или домен приложения и не выполняет метод точки входа в новом потоке.</span><span class="sxs-lookup"><span data-stu-id="be398-1542">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="be398-1543">Чтобы создать объект <xref:System.AppDomain> для загрузки и выполнения, <xref:System.AppDomain.CreateDomain%2A> используйте метод.</span><span class="sxs-lookup"><span data-stu-id="be398-1543">To create the <xref:System.AppDomain> to load and execute, use the <xref:System.AppDomain.CreateDomain%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-1544">Свойство <paramref name="assemblyName" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1544"><paramref name="assemblyName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="be398-1545">Сборка, заданная параметром <paramref name="assemblyName" />, не найдена.</span><span class="sxs-lookup"><span data-stu-id="be398-1545">The assembly specified by <paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="be398-1546">Сборка, заданная параметром <paramref name="assemblyName" />, не является допустимой сборкой.</span><span class="sxs-lookup"><span data-stu-id="be398-1546">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="be398-1547">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-1547">-or-</span></span> 
<span data-ttu-id="be398-1548">Сейчас загружена среда CLR 2.0 или более поздней версии. Сборка <paramref name="assemblyName" /> скомпилирована в более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="be398-1548">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-1549">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1549">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="be398-1550">Сборка, заданная параметром <paramref name="assemblyName" />, найдена, но загрузить ее не удалось.</span><span class="sxs-lookup"><span data-stu-id="be398-1550">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="be398-1551">Указанная сборка не имеет точку входа.</span><span class="sxs-lookup"><span data-stu-id="be398-1551">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="be398-1552">для доступа к чтению из файла или каталога, для доступа к сведениям в самом пути, а также для перенаправления отображаемого имени в путь.</span><span class="sxs-lookup"><span data-stu-id="be398-1552">for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</span></span> <span data-ttu-id="be398-1553">Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1553">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="be398-1554">для доступа к веб-сайту, когда отображаемое имя перенаправляется на URL-адрес.</span><span class="sxs-lookup"><span data-stu-id="be398-1554">for access to a Web site, when a display name is redirected to a URL.</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="be398-1555">для выполнения консольного приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1555">to execute a console application.</span></span> <span data-ttu-id="be398-1556">Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1556">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : System.Reflection.AssemblyName * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-2.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="be398-1557">Объект <see cref="T:System.Reflection.AssemblyName" />, представляющий имя сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1557">An <see cref="T:System.Reflection.AssemblyName" /> object representing the name of the assembly.</span></span></param>
        <param name="args"><span data-ttu-id="be398-1558">Аргументы командной строки для передачи при запуске процесса.</span><span class="sxs-lookup"><span data-stu-id="be398-1558">Command-line arguments to pass when starting the process.</span></span></param>
        <summary><span data-ttu-id="be398-1559">Выполняет сборку с заданным <see cref="T:System.Reflection.AssemblyName" /> с использованием заданных аргументов.</span><span class="sxs-lookup"><span data-stu-id="be398-1559">Executes the assembly given an <see cref="T:System.Reflection.AssemblyName" />, using the specified arguments.</span></span></summary>
        <returns><span data-ttu-id="be398-1560">Значение, возвращаемое точкой входа сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1560">The value that is returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-1561">Метод обеспечивает аналогичные функции <xref:System.AppDomain.ExecuteAssembly%2A> для метода, но указывает сборку по отображаемому имени или <xref:System.Reflection.AssemblyName> , а не по расположению файла. <xref:System.AppDomain.ExecuteAssemblyByName%2A></span><span class="sxs-lookup"><span data-stu-id="be398-1561">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method provides similar functionality to the <xref:System.AppDomain.ExecuteAssembly%2A> method, but specifies the assembly by display name or <xref:System.Reflection.AssemblyName> rather than by file location.</span></span> <span data-ttu-id="be398-1562">Таким образом <xref:System.AppDomain.ExecuteAssemblyByName%2A> , загружает сборки <xref:System.Reflection.Assembly.Load%2A> с помощью <xref:System.Reflection.Assembly.LoadFile%2A> метода, а не с помощью метода.</span><span class="sxs-lookup"><span data-stu-id="be398-1562">Therefore, <xref:System.AppDomain.ExecuteAssemblyByName%2A> loads assemblies with the <xref:System.Reflection.Assembly.Load%2A> method rather than with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="be398-1563">Сборка начинает выполняться в точке входа, указанной в заголовке .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="be398-1563">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="be398-1564">Этот метод не создает новый процесс или домен приложения и не выполняет метод точки входа в новом потоке.</span><span class="sxs-lookup"><span data-stu-id="be398-1564">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="be398-1565">Сборка, заданная параметром <paramref name="assemblyName" />, не найдена.</span><span class="sxs-lookup"><span data-stu-id="be398-1565">The assembly specified by <paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="be398-1566">Сборка, заданная параметром <paramref name="assemblyName" /> найдена, но ее невозможно загрузить.</span><span class="sxs-lookup"><span data-stu-id="be398-1566">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="be398-1567">Сборка, заданная параметром <paramref name="assemblyName" />, недопустимая.</span><span class="sxs-lookup"><span data-stu-id="be398-1567">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="be398-1568">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-1568">-or-</span></span> 
 <span data-ttu-id="be398-1569"><paramref name="assemblyName" /> была скомпилирована для версии среды CLR, которая является более поздней, чем версия, которая в настоящий момент загружена.</span><span class="sxs-lookup"><span data-stu-id="be398-1569"><paramref name="assemblyName" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-1570">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1570">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="be398-1571">Указанная сборка не имеет точку входа.</span><span class="sxs-lookup"><span data-stu-id="be398-1571">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="be398-1572">для доступа к чтению из файла или каталога, для доступа к сведениям в самом пути, а также для перенаправления отображаемого имени в путь.</span><span class="sxs-lookup"><span data-stu-id="be398-1572">for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</span></span> <span data-ttu-id="be398-1573">Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1573">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="be398-1574">для доступа к веб-сайту, когда отображаемое имя перенаправляется на URL-адрес.</span><span class="sxs-lookup"><span data-stu-id="be398-1574">for access to a Web site, when a display name is redirected to a URL.</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="be398-1575">для выполнения консольного приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1575">to execute a console application.</span></span> <span data-ttu-id="be398-1576">Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1576">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * System.Security.Policy.Evidence -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="be398-1577">Отображаемое имя сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1577">The display name of the assembly.</span></span> <span data-ttu-id="be398-1578">См. раздел <see cref="P:System.Reflection.Assembly.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1578">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="be398-1579">Свидетельство для загрузки сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1579">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="be398-1580">Выполняет сборку с заданным отображаемым именем с использованием заданного свидетельства.</span><span class="sxs-lookup"><span data-stu-id="be398-1580">Executes an assembly given its display name, using the specified evidence.</span></span></summary>
        <returns><span data-ttu-id="be398-1581">Значение, возвращаемое точкой входа сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1581">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-1582">Метод обеспечивает аналогичные функции <xref:System.AppDomain.ExecuteAssembly%2A> для метода, но указывает сборку по отображаемому имени или <xref:System.Reflection.AssemblyName> , а не по расположению файла. <xref:System.AppDomain.ExecuteAssemblyByName%2A></span><span class="sxs-lookup"><span data-stu-id="be398-1582">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method provides similar functionality to the <xref:System.AppDomain.ExecuteAssembly%2A> method, but specifies the assembly by display name or <xref:System.Reflection.AssemblyName> rather than by file location.</span></span> <span data-ttu-id="be398-1583">Таким образом <xref:System.AppDomain.ExecuteAssemblyByName%2A> , загружает сборки <xref:System.Reflection.Assembly.Load%2A> с помощью <xref:System.Reflection.Assembly.LoadFile%2A> метода, а не с помощью метода.</span><span class="sxs-lookup"><span data-stu-id="be398-1583">Therefore, <xref:System.AppDomain.ExecuteAssemblyByName%2A> loads assemblies with the <xref:System.Reflection.Assembly.Load%2A> method rather than with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="be398-1584">Сборка начинает выполняться в точке входа, указанной в заголовке .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="be398-1584">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="be398-1585"><xref:System.AppDomain.ExecuteAssemblyByName%2A> Метод не создает новый процесс или домен приложения и не выполняет метод точки входа в новом потоке.</span><span class="sxs-lookup"><span data-stu-id="be398-1585">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="be398-1586">При использовании <xref:System.AppDomain.ExecuteAssemblyByName%2A> метода <xref:System.Security.Policy.Evidence> с параметром объединяются части свидетельств.</span><span class="sxs-lookup"><span data-stu-id="be398-1586">When you use the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="be398-1587">Части свидетельства, предоставленные в качестве аргумента методу, <xref:System.AppDomain.ExecuteAssemblyByName%2A> заменяют части свидетельств, предоставляемые загрузчиком.</span><span class="sxs-lookup"><span data-stu-id="be398-1587">Pieces of evidence supplied as an argument to the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-1588">Свойство <paramref name="assemblyName" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1588"><paramref name="assemblyName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="be398-1589">Сборка, заданная параметром <paramref name="assemblyName" />, не найдена.</span><span class="sxs-lookup"><span data-stu-id="be398-1589">The assembly specified by <paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="be398-1590">Сборка, заданная параметром <paramref name="assemblyName" /> найдена, но ее невозможно загрузить.</span><span class="sxs-lookup"><span data-stu-id="be398-1590">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="be398-1591">Сборка, заданная параметром <paramref name="assemblyName" />, недопустимая.</span><span class="sxs-lookup"><span data-stu-id="be398-1591">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="be398-1592">-или-</span><span class="sxs-lookup"><span data-stu-id="be398-1592">-or-</span></span> 
<span data-ttu-id="be398-1593">Сейчас загружена среда CLR 2.0 или более поздней версии. Сборка <paramref name="assemblyName" /> скомпилирована в более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="be398-1593">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-1594">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1594">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="be398-1595">Указанная сборка не имеет точку входа.</span><span class="sxs-lookup"><span data-stu-id="be398-1595">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="be398-1596">для доступа к чтению из файла или каталога, для доступа к сведениям в самом пути, а также для перенаправления отображаемого имени в путь.</span><span class="sxs-lookup"><span data-stu-id="be398-1596">for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</span></span> <span data-ttu-id="be398-1597">Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1597">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="be398-1598">для загрузки сборки с свидетельством.</span><span class="sxs-lookup"><span data-stu-id="be398-1598">to load an assembly with evidence.</span></span> <span data-ttu-id="be398-1599">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1599">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="be398-1600">для доступа к веб-сайту, когда отображаемое имя перенаправляется на URL-адрес.</span><span class="sxs-lookup"><span data-stu-id="be398-1600">for access to a Web site, when a display name is redirected to a URL.</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="be398-1601">для выполнения консольного приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1601">to execute a console application.</span></span> <span data-ttu-id="be398-1602">Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1602">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-2.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="be398-1603">Отображаемое имя сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1603">The display name of the assembly.</span></span> <span data-ttu-id="be398-1604">См. раздел <see cref="P:System.Reflection.Assembly.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1604">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="args"><span data-ttu-id="be398-1605">Аргументы командной строки для передачи при запуске процесса.</span><span class="sxs-lookup"><span data-stu-id="be398-1605">Command-line arguments to pass when starting the process.</span></span></param>
        <summary><span data-ttu-id="be398-1606">Выполняет сборку с заданным отображаемым именем с использованием заданных аргументов.</span><span class="sxs-lookup"><span data-stu-id="be398-1606">Executes the assembly given its display name, using the specified arguments.</span></span></summary>
        <returns><span data-ttu-id="be398-1607">Значение, возвращаемое точкой входа сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1607">The value that is returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-1608">Метод обеспечивает аналогичные функции <xref:System.AppDomain.ExecuteAssembly%2A> для метода, но указывает сборку по отображаемому имени или <xref:System.Reflection.AssemblyName> , а не по расположению файла. <xref:System.AppDomain.ExecuteAssemblyByName%2A></span><span class="sxs-lookup"><span data-stu-id="be398-1608">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method provides similar functionality to the <xref:System.AppDomain.ExecuteAssembly%2A> method, but specifies the assembly by display name or <xref:System.Reflection.AssemblyName> rather than by file location.</span></span> <span data-ttu-id="be398-1609">Таким образом <xref:System.AppDomain.ExecuteAssemblyByName%2A> , загружает сборки <xref:System.Reflection.Assembly.Load%2A> с помощью <xref:System.Reflection.Assembly.LoadFile%2A> метода, а не с помощью метода.</span><span class="sxs-lookup"><span data-stu-id="be398-1609">Therefore, <xref:System.AppDomain.ExecuteAssemblyByName%2A> loads assemblies with the <xref:System.Reflection.Assembly.Load%2A> method rather than with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="be398-1610">Сборка начинает выполняться в точке входа, указанной в заголовке .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="be398-1610">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="be398-1611">Этот метод не создает новый процесс или домен приложения и не выполняет метод точки входа в новом потоке.</span><span class="sxs-lookup"><span data-stu-id="be398-1611">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-1612">Свойство <paramref name="assemblyName" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1612"><paramref name="assemblyName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="be398-1613">Сборка, заданная параметром <paramref name="assemblyName" />, не найдена.</span><span class="sxs-lookup"><span data-stu-id="be398-1613">The assembly specified by <paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="be398-1614">Сборка, заданная параметром <paramref name="assemblyName" /> найдена, но ее невозможно загрузить.</span><span class="sxs-lookup"><span data-stu-id="be398-1614">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="be398-1615">Сборка, заданная параметром <paramref name="assemblyName" />, недопустимая.</span><span class="sxs-lookup"><span data-stu-id="be398-1615">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="be398-1616">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-1616">-or-</span></span> 
 <span data-ttu-id="be398-1617"><paramref name="assemblyName" /> была скомпилирована для версии среды CLR, которая является более поздней, чем версия, которая в настоящий момент загружена.</span><span class="sxs-lookup"><span data-stu-id="be398-1617"><paramref name="assemblyName" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-1618">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1618">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="be398-1619">Указанная сборка не имеет точку входа.</span><span class="sxs-lookup"><span data-stu-id="be398-1619">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="be398-1620">для доступа к чтению из файла или каталога, для доступа к сведениям в самом пути, а также для перенаправления отображаемого имени в путь.</span><span class="sxs-lookup"><span data-stu-id="be398-1620">for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</span></span> <span data-ttu-id="be398-1621">Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1621">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="be398-1622">для доступа к веб-сайту, когда отображаемое имя перенаправляется на URL-адрес.</span><span class="sxs-lookup"><span data-stu-id="be398-1622">for access to a Web site, when a display name is redirected to a URL.</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="be398-1623">для выполнения консольного приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1623">to execute a console application.</span></span> <span data-ttu-id="be398-1624">Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1624">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : System.Reflection.AssemblyName * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="be398-1625">Объект <see cref="T:System.Reflection.AssemblyName" />, представляющий имя сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1625">An <see cref="T:System.Reflection.AssemblyName" /> object representing the name of the assembly.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="be398-1626">Свидетельство для загрузки сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1626">Evidence for loading the assembly.</span></span></param>
        <param name="args"><span data-ttu-id="be398-1627">Аргументы командной строки для передачи при запуске процесса.</span><span class="sxs-lookup"><span data-stu-id="be398-1627">Command-line arguments to pass when starting the process.</span></span></param>
        <summary><span data-ttu-id="be398-1628">Выполняет сборку с заданным <see cref="T:System.Reflection.AssemblyName" /> с использованием заданного свидетельства и аргументов.</span><span class="sxs-lookup"><span data-stu-id="be398-1628">Executes the assembly given an <see cref="T:System.Reflection.AssemblyName" />, using the specified evidence and arguments.</span></span></summary>
        <returns><span data-ttu-id="be398-1629">Значение, возвращаемое точкой входа сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1629">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-1630">Метод обеспечивает аналогичные функции <xref:System.AppDomain.ExecuteAssembly%2A> для метода, но указывает сборку по отображаемому имени или <xref:System.Reflection.AssemblyName> , а не по расположению файла. <xref:System.AppDomain.ExecuteAssemblyByName%2A></span><span class="sxs-lookup"><span data-stu-id="be398-1630">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method provides similar functionality to the <xref:System.AppDomain.ExecuteAssembly%2A> method, but specifies the assembly by display name or <xref:System.Reflection.AssemblyName> rather than by file location.</span></span> <span data-ttu-id="be398-1631">Таким образом <xref:System.AppDomain.ExecuteAssemblyByName%2A> , загружает сборки <xref:System.Reflection.Assembly.Load%2A> с помощью <xref:System.Reflection.Assembly.LoadFile%2A> метода, а не с помощью метода.</span><span class="sxs-lookup"><span data-stu-id="be398-1631">Therefore, <xref:System.AppDomain.ExecuteAssemblyByName%2A> loads assemblies with the <xref:System.Reflection.Assembly.Load%2A> method rather than with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="be398-1632">Сборка начинает выполняться в точке входа, указанной в заголовке .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="be398-1632">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="be398-1633">Этот метод не создает новый процесс или домен приложения и не выполняет метод точки входа в новом потоке.</span><span class="sxs-lookup"><span data-stu-id="be398-1633">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="be398-1634">При использовании <xref:System.AppDomain.ExecuteAssemblyByName%2A> метода <xref:System.Security.Policy.Evidence> с параметром объединяются части свидетельств.</span><span class="sxs-lookup"><span data-stu-id="be398-1634">When you use the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="be398-1635">Части свидетельства, предоставленные в качестве аргумента методу, <xref:System.AppDomain.ExecuteAssemblyByName%2A> заменяют части свидетельств, предоставляемые загрузчиком.</span><span class="sxs-lookup"><span data-stu-id="be398-1635">Pieces of evidence supplied as an argument to the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="be398-1636">Сборка, заданная параметром <paramref name="assemblyName" />, не найдена.</span><span class="sxs-lookup"><span data-stu-id="be398-1636">The assembly specified by <paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="be398-1637">Сборка, заданная параметром <paramref name="assemblyName" /> найдена, но ее невозможно загрузить.</span><span class="sxs-lookup"><span data-stu-id="be398-1637">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="be398-1638">Сборка, заданная параметром <paramref name="assemblyName" />, недопустимая.</span><span class="sxs-lookup"><span data-stu-id="be398-1638">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="be398-1639">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-1639">-or-</span></span> 
<span data-ttu-id="be398-1640">Сейчас загружена среда CLR 2.0 или более поздней версии. Сборка <paramref name="assemblyName" /> скомпилирована в более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="be398-1640">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-1641">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1641">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="be398-1642"><paramref name="assemblySecurity" /> не является <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1642"><paramref name="assemblySecurity" /> is not <see langword="null" />.</span></span> <span data-ttu-id="be398-1643">Если не включена политика разграничения доступа кода для кода предыдущей версии, <paramref name="assemblySecurity" /> должно иметь значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1643">When legacy CAS policy is not enabled, <paramref name="assemblySecurity" /> should be <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="be398-1644">Указанная сборка не имеет точку входа.</span><span class="sxs-lookup"><span data-stu-id="be398-1644">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="be398-1645">для доступа к чтению из файла или каталога, для доступа к сведениям в самом пути, а также для перенаправления отображаемого имени в путь.</span><span class="sxs-lookup"><span data-stu-id="be398-1645">for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</span></span> <span data-ttu-id="be398-1646">Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1646">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="be398-1647">для загрузки сборки с свидетельством.</span><span class="sxs-lookup"><span data-stu-id="be398-1647">to load an assembly with evidence.</span></span> <span data-ttu-id="be398-1648">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1648">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="be398-1649">для доступа к веб-сайту, когда отображаемое имя перенаправляется на URL-адрес.</span><span class="sxs-lookup"><span data-stu-id="be398-1649">for access to a Web site, when a display name is redirected to a URL.</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="be398-1650">для выполнения консольного приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1650">to execute a console application.</span></span> <span data-ttu-id="be398-1651">Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1651">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="be398-1652">Отображаемое имя сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1652">The display name of the assembly.</span></span> <span data-ttu-id="be398-1653">См. раздел <see cref="P:System.Reflection.Assembly.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1653">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="be398-1654">Свидетельство для загрузки сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1654">Evidence for loading the assembly.</span></span></param>
        <param name="args"><span data-ttu-id="be398-1655">Аргументы командной строки для передачи при запуске процесса.</span><span class="sxs-lookup"><span data-stu-id="be398-1655">Command-line arguments to pass when starting the process.</span></span></param>
        <summary><span data-ttu-id="be398-1656">Выполняет сборку с заданным отображаемым именем с использованием заданного свидетельства и аргументов.</span><span class="sxs-lookup"><span data-stu-id="be398-1656">Executes the assembly given its display name, using the specified evidence and arguments.</span></span></summary>
        <returns><span data-ttu-id="be398-1657">Значение, возвращаемое точкой входа сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1657">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-1658">Метод обеспечивает аналогичные функции <xref:System.AppDomain.ExecuteAssembly%2A> для метода, но указывает сборку по отображаемому имени или <xref:System.Reflection.AssemblyName> , а не по расположению файла. <xref:System.AppDomain.ExecuteAssemblyByName%2A></span><span class="sxs-lookup"><span data-stu-id="be398-1658">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method provides similar functionality to the <xref:System.AppDomain.ExecuteAssembly%2A> method, but specifies the assembly by display name or <xref:System.Reflection.AssemblyName> rather than by file location.</span></span> <span data-ttu-id="be398-1659">Таким образом <xref:System.AppDomain.ExecuteAssemblyByName%2A> , загружает сборки <xref:System.Reflection.Assembly.Load%2A> с помощью <xref:System.Reflection.Assembly.LoadFile%2A> метода, а не с помощью метода.</span><span class="sxs-lookup"><span data-stu-id="be398-1659">Therefore, <xref:System.AppDomain.ExecuteAssemblyByName%2A> loads assemblies with the <xref:System.Reflection.Assembly.Load%2A> method rather than with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="be398-1660">Сборка начинает выполняться в точке входа, указанной в заголовке .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="be398-1660">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="be398-1661">Этот метод не создает новый процесс или домен приложения и не выполняет метод точки входа в новом потоке.</span><span class="sxs-lookup"><span data-stu-id="be398-1661">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="be398-1662">При использовании <xref:System.AppDomain.ExecuteAssemblyByName%2A> метода <xref:System.Security.Policy.Evidence> с параметром объединяются части свидетельств.</span><span class="sxs-lookup"><span data-stu-id="be398-1662">When you use the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="be398-1663">Части свидетельства, предоставленные в качестве аргумента методу, <xref:System.AppDomain.ExecuteAssemblyByName%2A> заменяют части свидетельств, предоставляемые загрузчиком.</span><span class="sxs-lookup"><span data-stu-id="be398-1663">Pieces of evidence supplied as an argument to the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-1664">Свойство <paramref name="assemblyName" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1664"><paramref name="assemblyName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="be398-1665">Сборка, заданная параметром <paramref name="assemblyName" />, не найдена.</span><span class="sxs-lookup"><span data-stu-id="be398-1665">The assembly specified by <paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="be398-1666">Сборка, заданная параметром <paramref name="assemblyName" /> найдена, но ее невозможно загрузить.</span><span class="sxs-lookup"><span data-stu-id="be398-1666">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="be398-1667">Сборка, заданная параметром <paramref name="assemblyName" />, недопустимая.</span><span class="sxs-lookup"><span data-stu-id="be398-1667">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="be398-1668">-или-</span><span class="sxs-lookup"><span data-stu-id="be398-1668">-or-</span></span> 
<span data-ttu-id="be398-1669">Сейчас загружена среда CLR 2.0 или более поздней версии. Сборка <paramref name="assemblyName" /> скомпилирована в более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="be398-1669">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-1670">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1670">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="be398-1671"><paramref name="assemblySecurity" /> не является <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1671"><paramref name="assemblySecurity" /> is not <see langword="null" />.</span></span> <span data-ttu-id="be398-1672">Если не включена политика разграничения доступа кода для кода предыдущей версии, <paramref name="assemblySecurity" /> должно иметь значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1672">When legacy CAS policy is not enabled, <paramref name="assemblySecurity" /> should be <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="be398-1673">Указанная сборка не имеет точку входа.</span><span class="sxs-lookup"><span data-stu-id="be398-1673">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="be398-1674">для доступа к чтению из файла или каталога, для доступа к сведениям в самом пути, а также для перенаправления отображаемого имени в путь.</span><span class="sxs-lookup"><span data-stu-id="be398-1674">for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</span></span> <span data-ttu-id="be398-1675">Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1675">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="be398-1676">для загрузки сборки с свидетельством.</span><span class="sxs-lookup"><span data-stu-id="be398-1676">to load an assembly with evidence.</span></span> <span data-ttu-id="be398-1677">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1677">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="be398-1678">для доступа к веб-сайту, когда отображаемое имя перенаправляется на URL-адрес.</span><span class="sxs-lookup"><span data-stu-id="be398-1678">for access to a Web site, when a display name is redirected to a URL.</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="be398-1679">для выполнения консольного приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1679">to execute a console application.</span></span> <span data-ttu-id="be398-1680">Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1680">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="FirstChanceException">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.FirstChanceException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FirstChanceException As EventHandler(Of FirstChanceExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Runtime::ExceptionServices::FirstChanceExceptionEventArgs ^&gt; ^ FirstChanceException;" />
      <MemberSignature Language="F#" Value="member this.FirstChanceException : EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; " Usage="member this.FirstChanceException : System.EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="be398-1681">Происходит при создании исключения в управляемом коде, перед тем как среда выполнения ищет стек вызовов для обработчика исключений в домене приложений.</span><span class="sxs-lookup"><span data-stu-id="be398-1681">Occurs when an exception is thrown in managed code, before the runtime searches the call stack for an exception handler in the application domain.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-1682">Это событие является только уведомлением.</span><span class="sxs-lookup"><span data-stu-id="be398-1682">This event is only a notification.</span></span> <span data-ttu-id="be398-1683">Обработка этого события не обрабатывает исключение или влияет на последующую обработку исключений каким бы то ни было образом.</span><span class="sxs-lookup"><span data-stu-id="be398-1683">Handling this event does not handle the exception or affect subsequent exception handling in any way.</span></span> <span data-ttu-id="be398-1684">После того как событие вызвано и были вызваны обработчики событий, среда CLR начинает поиск обработчика для исключения.</span><span class="sxs-lookup"><span data-stu-id="be398-1684">After the event has been raised and event handlers have been invoked, the common language runtime (CLR) begins to search for a handler for the exception.</span></span> <span data-ttu-id="be398-1685"><xref:System.AppDomain.FirstChanceException>предоставляет домен приложения с первой возможностью проверить любое управляемое исключение.</span><span class="sxs-lookup"><span data-stu-id="be398-1685"><xref:System.AppDomain.FirstChanceException> provides the application domain with a first chance to examine any managed exception.</span></span>  
  
 <span data-ttu-id="be398-1686">Событие может быть обработано для каждого домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1686">The event can be handled per application domain.</span></span> <span data-ttu-id="be398-1687">Если поток проходит через несколько доменов приложений во время выполнения вызова, событие возникает в каждом домене приложения, который зарегистрировал обработчик событий, прежде чем среда CLR начнет поиск соответствующего обработчика исключений в этом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1687">If a thread passes through multiple application domains while executing a call, the event is raised in each application domain that has registered an event handler, before the CLR begins searching for a matching exception handler in that application domain.</span></span> <span data-ttu-id="be398-1688">После обработки события выполняется поиск соответствующего обработчика исключений в этом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1688">After the event has been handled, a search is made for a matching exception handler in that application domain.</span></span> <span data-ttu-id="be398-1689">Если ничего не найдено, событие возникает в следующем домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1689">If none is found, the event is raised in the next application domain.</span></span>  
  
 <span data-ttu-id="be398-1690">Все исключения, происходящие в обработчике событий для <xref:System.AppDomain.FirstChanceException> события, должны быть обработаны.</span><span class="sxs-lookup"><span data-stu-id="be398-1690">You must handle all exceptions that occur in the event handler for the <xref:System.AppDomain.FirstChanceException> event.</span></span> <span data-ttu-id="be398-1691"><xref:System.AppDomain.FirstChanceException> В противном случае вызывается рекурсивно.</span><span class="sxs-lookup"><span data-stu-id="be398-1691">Otherwise, <xref:System.AppDomain.FirstChanceException> is raised recursively.</span></span> <span data-ttu-id="be398-1692">Это может привести к переполнению стека и завершению работы приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1692">This could result in a stack overflow and termination of the application.</span></span> <span data-ttu-id="be398-1693">Рекомендуется реализовать обработчики событий для этого события в виде областей ограниченного выполнения (CER), чтобы исключения, связанные с инфраструктурой, такие как нехваткой памяти или переполнение стека, не влияли на виртуальную машину, пока не будет уведомление об исключении. обрабатывается.</span><span class="sxs-lookup"><span data-stu-id="be398-1693">We recommend that you implement event handlers for this event as constrained execution regions (CERs), to keep infrastructure-related exceptions such as out-of-memory or stack overflow from affecting the virtual machine while the exception notification is being processed.</span></span>  
  
 <span data-ttu-id="be398-1694">Это событие не вызывается для исключений, которые указывают на повреждение состояния процесса, например нарушения прав доступа, если только обработчик событий не является критически важным для безопасности <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> и имеет атрибут.</span><span class="sxs-lookup"><span data-stu-id="be398-1694">This event is not raised for exceptions that indicate corruption of process state, such as access violations, unless the event handler is security-critical and has the <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> attribute.</span></span>  
  
 <span data-ttu-id="be398-1695">Среда CLR приостанавливает прерывание потока во время обработки этого события уведомления.</span><span class="sxs-lookup"><span data-stu-id="be398-1695">The common language runtime suspends thread aborts while this notification event is being handled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-1696">В следующем примере создается ряд доменов приложений с именем `AD0` `AD3`с `Worker` использованием объекта в каждом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1696">The following example creates a series of application domains named `AD0` through `AD3`, with a `Worker` object in each application domain.</span></span> <span data-ttu-id="be398-1697">Каждый `Worker` объект имеет ссылку `Worker` на объект в следующем `Worker` домене приложения, за исключением объекта в последнем домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1697">Each `Worker` object has a reference to the `Worker` object in the next application domain, except for the `Worker` in the last application domain.</span></span> <span data-ttu-id="be398-1698">Событие обрабатывается во всех доменах приложений, за исключением  `AD1` .  <xref:System.AppDomain.FirstChanceException></span><span class="sxs-lookup"><span data-stu-id="be398-1698">The <xref:System.AppDomain.FirstChanceException> event is handled in all application domains except `AD1`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="be398-1699">В дополнение к этому примеру, в котором демонстрируются уведомления о первичных исключениях в нескольких доменах приложений, можно найти простые варианты использования, [чтобы получать уведомления о первых исключениях](~/docs/framework/app-domains/how-to-receive-first-chance-exception-notifications.md).</span><span class="sxs-lookup"><span data-stu-id="be398-1699">In addition to this example, which demonstrates first-chance exception notifications in multiple application domains, you can find simple use cases in [How to: Receive First-Chance Exception Notifications](~/docs/framework/app-domains/how-to-receive-first-chance-exception-notifications.md).</span></span>  
  
 <span data-ttu-id="be398-1700">После создания доменов приложений домен приложения по умолчанию вызывает `TestException` метод для первого домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1700">When the application domains have been created, the default application domain calls the `TestException` method for the first application domain.</span></span> <span data-ttu-id="be398-1701">Каждый `Worker` объект `Worker` вызывает метод для следующего домена приложения до тех пор, пока не будет создано исключение, которое обрабатывается или необработанным. `TestException`</span><span class="sxs-lookup"><span data-stu-id="be398-1701">Each `Worker` object calls the `TestException` method for the next application domain, until the last `Worker` throws an exception that is either handled or unhandled.</span></span> <span data-ttu-id="be398-1702">Таким же, текущий поток проходит через все домены приложений и `TestException` добавляется в стек в каждом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1702">Thus, the current thread passes through all the application domains, and `TestException` is added to the stack in each application domain.</span></span>  
  
 <span data-ttu-id="be398-1703">Когда последний `Worker` объект обрабатывает исключение <xref:System.AppDomain.FirstChanceException> , событие возникает только в последнем домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1703">When the last `Worker` object handles the exception, the <xref:System.AppDomain.FirstChanceException> event is raised only in the last application domain.</span></span> <span data-ttu-id="be398-1704">Другие домены приложений никогда не получают возможность обработки исключения, поэтому событие не возникает.</span><span class="sxs-lookup"><span data-stu-id="be398-1704">The other application domains never get a chance to handle the exception, so the event is not raised.</span></span>  
  
 <span data-ttu-id="be398-1705">Когда последний `Worker` объект не обрабатывает исключение <xref:System.AppDomain.FirstChanceException> , событие возникает в каждом домене приложения с обработчиком событий.</span><span class="sxs-lookup"><span data-stu-id="be398-1705">When the last `Worker` object does not handle the exception, the <xref:System.AppDomain.FirstChanceException> event is raised in each application domain that has an event handler.</span></span> <span data-ttu-id="be398-1706">После завершения каждого обработчика событий стек продолжит работать до тех пор, пока исключение не будет перехвачено доменом приложения по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="be398-1706">After each event handler has finished, the stack continues to unwind until the exception is caught by the default application domain.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="be398-1707">Чтобы увидеть, как растет отображение стека по мере того, как событие порождается ближе к домену приложения `e.Exception.Message` по `e.Exception` умолчанию `FirstChanceHandler` , измените на в обработчиках событий.</span><span class="sxs-lookup"><span data-stu-id="be398-1707">To see how the stack display grows as the event is raised closer and closer to the default application domain, change `e.Exception.Message` to `e.Exception` in the `FirstChanceHandler` event handlers.</span></span> <span data-ttu-id="be398-1708">Обратите внимание `TestException` , что когда вызывается через границы домена приложения, он появляется дважды: один раз для прокси-сервера и один раз для заглушки.</span><span class="sxs-lookup"><span data-stu-id="be398-1708">Notice that when `TestException` is called across application domain boundaries, it appears twice: once for the proxy and once for the stub.</span></span>  
  
 [!code-csharp[System.AppDomain.FirstChanceException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/cs/example.cs#1)]
 [!code-vb[System.AppDomain.FirstChanceException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="be398-1709">Требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="be398-1709">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="be398-1710">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="be398-1710">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="T:System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs" />
        <altmember cref="E:System.AppDomain.UnhandledException" />
        <related type="Article" href="https://msdn.microsoft.com/library/66f002b8-a97d-4a6e-a503-2cec01689113"><span data-ttu-id="be398-1711">Практическое руководство. Получение уведомлений о первом этапе обработки исключений</span><span class="sxs-lookup"><span data-stu-id="be398-1711">How to: Receive First-Chance Exception Notifications</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FriendlyName">
      <MemberSignature Language="C#" Value="public string FriendlyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FriendlyName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.FriendlyName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FriendlyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FriendlyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FriendlyName : string" Usage="System.AppDomain.FriendlyName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.FriendlyName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="be398-1712">Возвращает понятное имя этого домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1712">Gets the friendly name of this application domain.</span></span></summary>
        <value><span data-ttu-id="be398-1713">Понятное имя этого домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1713">The friendly name of this application domain.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-1714">Понятное имя домена приложения по умолчанию — имя исполняемого файла процесса.</span><span class="sxs-lookup"><span data-stu-id="be398-1714">The friendly name of the default application domain is the file name of the process executable.</span></span> <span data-ttu-id="be398-1715">Например, если исполняемый файл, используемый для запуска процесса, `"c:\MyAppDirectory\MyAssembly.exe"`—, понятное имя домена приложения по умолчанию `"MyAssembly.exe"`—.</span><span class="sxs-lookup"><span data-stu-id="be398-1715">For example, if the executable used to start the process is `"c:\MyAppDirectory\MyAssembly.exe"`, the friendly name of the default application domain is `"MyAssembly.exe"`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-1716">В следующем примере кода <xref:System.AppDomain.FriendlyName%2A> свойство используется для получения понятного имени текущего домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1716">The following code example uses the <xref:System.AppDomain.FriendlyName%2A> property to get the friendly name of the current application domain.</span></span> <span data-ttu-id="be398-1717">Для домена приложения по умолчанию понятное имя — это имя исполняемого файла приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1717">For the default application domain, the friendly name is the name of the application's executable file.</span></span> <span data-ttu-id="be398-1718">В примере кода также отображаются дополнительные сведения о домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1718">The code example also displays additional information about the application domain.</span></span>  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-1719">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1719">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] GetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly[] GetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Assembly ^&gt; ^ GetAssemblies();" />
      <MemberSignature Language="F#" Value="abstract member GetAssemblies : unit -&gt; System.Reflection.Assembly[]&#xA;override this.GetAssemblies : unit -&gt; System.Reflection.Assembly[]" Usage="appDomain.GetAssemblies " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetAssemblies</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="be398-1720">Возвращает сборки, которые были загружены в контекст выполнения этого домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1720">Gets the assemblies that have been loaded into the execution context of this application domain.</span></span></summary>
        <returns><span data-ttu-id="be398-1721">Массив сборок в этом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1721">An array of assemblies in this application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="be398-1722">В следующем примере кода <xref:System.AppDomain.GetAssemblies%2A> метод используется для получения списка всех сборок, загруженных в домен приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1722">The following code example uses the <xref:System.AppDomain.GetAssemblies%2A> method to get a list of all assemblies that have been loaded into the application domain.</span></span> <span data-ttu-id="be398-1723">Затем сборки отображаются в консоли.</span><span class="sxs-lookup"><span data-stu-id="be398-1723">The assemblies are then displayed to the console.</span></span>  
  
 <span data-ttu-id="be398-1724">Чтобы запустить этот пример кода, необходимо создать сборку с именем `CustomLibrary.dll`или изменить имя сборки, которая передается <xref:System.AppDomain.GetAssemblies%2A> в метод.</span><span class="sxs-lookup"><span data-stu-id="be398-1724">To run this code example, you need to create an assembly named `CustomLibrary.dll`, or change the assembly name that is passed to the <xref:System.AppDomain.GetAssemblies%2A> method.</span></span>  
  
 [!code-cpp[ADGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetAssemblies/CPP/adgetassemblies.cpp#1)]
 [!code-csharp[ADGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetAssemblies/CS/adgetassemblies.cs#1)]
 [!code-vb[ADGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetAssemblies/VB/adgetassemblies.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-1725">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1725">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentThreadId">
      <MemberSignature Language="C#" Value="public static int GetCurrentThreadId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentThreadId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetCurrentThreadId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentThreadId () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentThreadId();" />
      <MemberSignature Language="F#" Value="static member GetCurrentThreadId : unit -&gt; int" Usage="System.AppDomain.GetCurrentThreadId " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.'")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.  https://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="be398-1726">Получает текущий идентификатор потока.</span><span class="sxs-lookup"><span data-stu-id="be398-1726">Gets the current thread identifier.</span></span></summary>
        <returns><span data-ttu-id="be398-1727">32-битовое целое число со знаком, являющееся идентификатором текущего потока.</span><span class="sxs-lookup"><span data-stu-id="be398-1727">A 32-bit signed integer that is the identifier of the current thread.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-1728"><xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> Используйте свойство, которое является стабильным, даже если .NET Framework размещается в среде, поддерживающей волокна (то есть в облегченных потоках).</span><span class="sxs-lookup"><span data-stu-id="be398-1728">Use the <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> property, which is stable even when the .NET Framework is hosted by an environment that supports fibers (that is, lightweight threads).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="be398-1729">для вызова этого метода.</span><span class="sxs-lookup"><span data-stu-id="be398-1729">to call this method.</span></span> <span data-ttu-id="be398-1730">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1730">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span> <span data-ttu-id="be398-1731">Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1731">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span></permission>
        <altmember cref="T:System.Int32" />
        <altmember cref="P:System.Threading.Thread.ManagedThreadId" />
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public object GetData (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetData(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetData(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetData (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetData(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetData : string -&gt; obj&#xA;override this.GetData : string -&gt; obj" Usage="appDomain.GetData name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetData(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="be398-1732">Имя предопределенного свойства домена приложения или имя определенного вами свойства домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1732">The name of a predefined application domain property, or the name of an application domain property you have defined.</span></span></param>
        <summary><span data-ttu-id="be398-1733">Возвращает значение, сохраненное в текущем домене приложения для заданного имени.</span><span class="sxs-lookup"><span data-stu-id="be398-1733">Gets the value stored in the current application domain for the specified name.</span></span></summary>
        <returns><span data-ttu-id="be398-1734">Значение свойства <paramref name="name" /> или значение <see langword="null" />, если это свойство не существует.</span><span class="sxs-lookup"><span data-stu-id="be398-1734">The value of the <paramref name="name" /> property, or <see langword="null" /> if the property does not exist.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-1735">Этот метод используется для получения значения записи во внутреннем кэше пар "имя — данные", описывающих свойства данного экземпляра <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="be398-1735">Use this method to retrieve the value of an entry in an internal cache of name-data pairs that describe properties of this instance of <xref:System.AppDomain>.</span></span> <span data-ttu-id="be398-1736">Обратите внимание, что `name` при сравнении с именем пар "ключ-значение" учитывается регистр.</span><span class="sxs-lookup"><span data-stu-id="be398-1736">Note that the comparison of `name` with the name of key-value pairs is case-sensitive.</span></span>  
  
 <span data-ttu-id="be398-1737">Кэш автоматически содержит стандартные системные записи, которые вставляются при создании домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1737">The cache automatically contains predefined system entries that are inserted when the application domain is created.</span></span> <span data-ttu-id="be398-1738">Можно проверить их значения с помощью <xref:System.AppDomain.GetData%2A> метода или эквивалентных <xref:System.AppDomainSetup> свойств.</span><span class="sxs-lookup"><span data-stu-id="be398-1738">You can inspect their values with the <xref:System.AppDomain.GetData%2A> method, or the equivalent <xref:System.AppDomainSetup> properties.</span></span>  
  
 <span data-ttu-id="be398-1739">Можно вставить или изменить пользовательские пары имя-данные с <xref:System.AppDomain.SetData%2A> помощью метода и проверить их значения <xref:System.AppDomain.GetData%2A> с помощью метода.</span><span class="sxs-lookup"><span data-stu-id="be398-1739">You can insert or modify your own user defined name-data pairs with the <xref:System.AppDomain.SetData%2A> method and inspect their values with the <xref:System.AppDomain.GetData%2A> method.</span></span>  
  
 <span data-ttu-id="be398-1740">В следующей таблице описаны `name` все стандартные системные записи и соответствующие <xref:System.AppDomainSetup> свойства.</span><span class="sxs-lookup"><span data-stu-id="be398-1740">The following table describes the `name` of each predefined system entry and its corresponding <xref:System.AppDomainSetup> property.</span></span>  
  
|<span data-ttu-id="be398-1741">Значение "имя"</span><span class="sxs-lookup"><span data-stu-id="be398-1741">Value of 'name'</span></span>|<span data-ttu-id="be398-1742">Свойство.</span><span class="sxs-lookup"><span data-stu-id="be398-1742">Property</span></span>|  
|---------------------|--------------|  
|<span data-ttu-id="be398-1743">AppBase</span><span class="sxs-lookup"><span data-stu-id="be398-1743">"APPBASE"</span></span>|<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="be398-1744">"APP_CONFIG_FILE"</span><span class="sxs-lookup"><span data-stu-id="be398-1744">"APP_CONFIG_FILE"</span></span>|<xref:System.AppDomainSetup.ConfigurationFile%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="be398-1745">"APP_LAUNCH_URL"</span><span class="sxs-lookup"><span data-stu-id="be398-1745">"APP_LAUNCH_URL"</span></span>|<span data-ttu-id="be398-1746">(нет свойства)</span><span class="sxs-lookup"><span data-stu-id="be398-1746">(no property)</span></span><br /><br /> <span data-ttu-id="be398-1747">"APP_LAUNCH_URL" представляет URL-адрес, изначально запрошенный пользователем, перед любым перенаправлением.</span><span class="sxs-lookup"><span data-stu-id="be398-1747">"APP_LAUNCH_URL" represents the URL originally requested by the user, before any redirection.</span></span> <span data-ttu-id="be398-1748">Он доступен только в том случае, если приложение запущено с браузером, например Internet Explorer.</span><span class="sxs-lookup"><span data-stu-id="be398-1748">It is available only when the application has been launched with a browser such as Internet Explorer.</span></span> <span data-ttu-id="be398-1749">Не все браузеры предоставляют это значение.</span><span class="sxs-lookup"><span data-stu-id="be398-1749">Not all browsers provide this value.</span></span>|  
|<span data-ttu-id="be398-1750">"APP_NAME"</span><span class="sxs-lookup"><span data-stu-id="be398-1750">"APP_NAME"</span></span>|<xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="be398-1751">"BINPATH_PROBE_ONLY"</span><span class="sxs-lookup"><span data-stu-id="be398-1751">"BINPATH_PROBE_ONLY"</span></span>|<xref:System.AppDomainSetup.PrivateBinPathProbe%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="be398-1752">"CACHE_BASE"</span><span class="sxs-lookup"><span data-stu-id="be398-1752">"CACHE_BASE"</span></span>|<xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="be398-1753">"CODE_DOWNLOAD_DISABLED"</span><span class="sxs-lookup"><span data-stu-id="be398-1753">"CODE_DOWNLOAD_DISABLED"</span></span>|<xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="be398-1754">"DEV_PATH"</span><span class="sxs-lookup"><span data-stu-id="be398-1754">"DEV_PATH"</span></span>|<span data-ttu-id="be398-1755">(нет свойства)</span><span class="sxs-lookup"><span data-stu-id="be398-1755">(no property)</span></span>|  
|<span data-ttu-id="be398-1756">"DISALLOW_APP"</span><span class="sxs-lookup"><span data-stu-id="be398-1756">"DISALLOW_APP"</span></span>|<xref:System.AppDomainSetup.DisallowPublisherPolicy%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="be398-1757">"DISALLOW_APP_BASE_PROBING"</span><span class="sxs-lookup"><span data-stu-id="be398-1757">"DISALLOW_APP_BASE_PROBING"</span></span>|<xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="be398-1758">"DISALLOW_APP_REDIRECTS"</span><span class="sxs-lookup"><span data-stu-id="be398-1758">"DISALLOW_APP_REDIRECTS"</span></span>|<xref:System.AppDomainSetup.DisallowBindingRedirects%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="be398-1759">"DYNAMIC_BASE"</span><span class="sxs-lookup"><span data-stu-id="be398-1759">"DYNAMIC_BASE"</span></span>|<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="be398-1760">"FORCE_CACHE_INSTALL"</span><span class="sxs-lookup"><span data-stu-id="be398-1760">"FORCE_CACHE_INSTALL"</span></span>|<xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="be398-1761">"LICENSE_FILE" или строка для конкретного приложения</span><span class="sxs-lookup"><span data-stu-id="be398-1761">"LICENSE_FILE", or an application-specific string</span></span>|<xref:System.AppDomainSetup.LicenseFile%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="be398-1762">"LOADER_OPTIMIZATION"</span><span class="sxs-lookup"><span data-stu-id="be398-1762">"LOADER_OPTIMIZATION"</span></span>|<xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="be398-1763">"LOCATION_URI"</span><span class="sxs-lookup"><span data-stu-id="be398-1763">"LOCATION_URI"</span></span>|<span data-ttu-id="be398-1764">(нет свойства)</span><span class="sxs-lookup"><span data-stu-id="be398-1764">(no property)</span></span>|  
|<span data-ttu-id="be398-1765">"PRIVATE_BINPATH"</span><span class="sxs-lookup"><span data-stu-id="be398-1765">"PRIVATE_BINPATH"</span></span>|<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="be398-1766">"REGEX_DEFAULT_MATCH_TIMEOUT"</span><span class="sxs-lookup"><span data-stu-id="be398-1766">"REGEX_DEFAULT_MATCH_TIMEOUT"</span></span>|<xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A?displayProperty=nameWithType><br /><br /> <span data-ttu-id="be398-1767">"REGEX_DEFAULT_MATCH_TIMEOUT" не является системной записью, и ее значение можно задать, вызвав <xref:System.AppDomain.SetData%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="be398-1767">"REGEX_DEFAULT_MATCH_TIMEOUT" is not a system entry, and its value can be set by calling the <xref:System.AppDomain.SetData%2A> method.</span></span>|  
|<span data-ttu-id="be398-1768">"SHADOW_COPY_DIRS"</span><span class="sxs-lookup"><span data-stu-id="be398-1768">"SHADOW_COPY_DIRS"</span></span>|<xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType>|  
  
   
  
## Examples  
 <span data-ttu-id="be398-1769">В следующем примере создается новый домен приложения, задается предоставляемое системой значение для домена и добавляется новая пара значений для домена.</span><span class="sxs-lookup"><span data-stu-id="be398-1769">The following example creates a new application domain, sets a system-provided value for the domain, and adds a new value pair for the domain.</span></span> <span data-ttu-id="be398-1770">В примере демонстрируется использование <xref:System.AppDomain.GetData%2A> метода для извлечения данных из этих пар значений и их отображения в консоли.</span><span class="sxs-lookup"><span data-stu-id="be398-1770">The example then demonstrates how to use the <xref:System.AppDomain.GetData%2A> method to retrieve the data from these value pairs and display them to the console.</span></span>  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-1771">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1771"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-1772">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1772">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="be398-1773">значение для доступа к сведениям в самом пути, если свойство применяется к пути.</span><span class="sxs-lookup"><span data-stu-id="be398-1773">for access to the information in the path itself, if the property applies to a path.</span></span> <span data-ttu-id="be398-1774">Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1774">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <altmember cref="M:System.AppDomain.SetData(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="appDomain.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="be398-1775">Возвращает тип текущего экземпляра.</span><span class="sxs-lookup"><span data-stu-id="be398-1775">Gets the type of the current instance.</span></span></summary>
        <returns><span data-ttu-id="be398-1776">Тип текущего экземпляра.</span><span class="sxs-lookup"><span data-stu-id="be398-1776">The type of the current instance.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.AppDomain.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="be398-1777">Возвращает целое число, однозначно идентифицирующее домен приложения в процессе.</span><span class="sxs-lookup"><span data-stu-id="be398-1777">Gets an integer that uniquely identifies the application domain within the process.</span></span></summary>
        <value><span data-ttu-id="be398-1778">Целое число, идентифицирующее домен приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1778">An integer that identifies the application domain.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="be398-1779">В следующем примере кода создается второй домен приложения и отображаются сведения о домене по умолчанию и новом домене.</span><span class="sxs-lookup"><span data-stu-id="be398-1779">The following code example creates a second application domain and displays information about the default domain and the new domain.</span></span>  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeLifetimeService">
      <MemberSignature Language="C#" Value="public override object InitializeLifetimeService ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InitializeLifetimeService() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.InitializeLifetimeService" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function InitializeLifetimeService () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ InitializeLifetimeService();" />
      <MemberSignature Language="F#" Value="override this.InitializeLifetimeService : unit -&gt; obj" Usage="appDomain.InitializeLifetimeService " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.InitializeLifetimeService</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="be398-1780">Предоставляет объекту <see cref="T:System.AppDomain" /> бесконечное время существования, предотвращая создание аренды.</span><span class="sxs-lookup"><span data-stu-id="be398-1780">Gives the <see cref="T:System.AppDomain" /> an infinite lifetime by preventing a lease from being created.</span></span></summary>
        <returns><span data-ttu-id="be398-1781">Всегда <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1781">Always <see langword="null" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-1782">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1782">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="be398-1783">требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="be398-1783">requires full trust for the immediate caller.</span></span> <span data-ttu-id="be398-1784">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="be398-1784">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="IsCompatibilitySwitchSet">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; IsCompatibilitySwitchSet (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; IsCompatibilitySwitchSet(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsCompatibilitySwitchSet (value As String) As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;bool&gt; IsCompatibilitySwitchSet(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsCompatibilitySwitchSet : string -&gt; Nullable&lt;bool&gt;" Usage="appDomain.IsCompatibilitySwitchSet value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="be398-1785">Проверяемый переключатель совместимости.</span><span class="sxs-lookup"><span data-stu-id="be398-1785">The compatibility switch to test.</span></span></param>
        <summary><span data-ttu-id="be398-1786">Получает логическое значение, допускающее значения NULL, которое указывает, установлены ли какие-либо переключатели совместимости и, если установлены, установлен ли заданный переключатель совместимости.</span><span class="sxs-lookup"><span data-stu-id="be398-1786">Gets a nullable Boolean value that indicates whether any compatibility switches are set, and if so, whether the specified compatibility switch is set.</span></span></summary>
        <returns><span data-ttu-id="be398-1787">Пустая ссылка (<see langword="Nothing" /> в Visual Basic), если переключатели совместимости не установлены; в противном случае логическое значение, указывающее, установлен ли переключатель совместимости, заданный параметром <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1787">A null reference (<see langword="Nothing" /> in Visual Basic) if no compatibility switches are set; otherwise, a Boolean value that indicates whether the compatibility switch that is specified by <paramref name="value" /> is set.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-1788">Этот метод проверяет, установлен ли указанный параметр совместимости для текущего домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1788">This method tests whether the specified compatibility switch has been set for the current application domain.</span></span> <span data-ttu-id="be398-1789">Параметры совместимости обычно восстанавливают поведение (например, способ сортировки строк), которое изменилось между версиями .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="be398-1789">Compatibility switches typically restore a behavior (such as the way strings are sorted) that was changed between versions of the .NET Framework.</span></span>  <span data-ttu-id="be398-1790">Они задаются путем вызова <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=nameWithType> метода перед созданием домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1790">They are set by calling the <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=nameWithType> method before creating an application domain.</span></span>  
  
 <span data-ttu-id="be398-1791">В следующей таблице приведены примеры параметров совместимости, которые можно задать для восстановления поведения более ранних версий .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="be398-1791">The following table provides examples of compatibility switches that can be set to restore the behavior of earlier versions of the .NET Framework.</span></span>  
  
|<span data-ttu-id="be398-1792">Параметр</span><span class="sxs-lookup"><span data-stu-id="be398-1792">Switch</span></span>|<span data-ttu-id="be398-1793">Значение</span><span class="sxs-lookup"><span data-stu-id="be398-1793">Meaning</span></span>|  
|------------|-------------|  
|<span data-ttu-id="be398-1794">"NetFx40_LegacySecurityPolicy"</span><span class="sxs-lookup"><span data-stu-id="be398-1794">"NetFx40_LegacySecurityPolicy"</span></span>|<span data-ttu-id="be398-1795">Управление доступом для кода (CAS) для [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] включено в этом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1795">Code access security (CAS) for the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] is enabled in this application domain.</span></span> <span data-ttu-id="be398-1796">См. элемент NetFx40_LegacySecurityPolicy. [ &lt;&gt; ](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)</span><span class="sxs-lookup"><span data-stu-id="be398-1796">See [&lt;NetFx40_LegacySecurityPolicy&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</span></span>|  
|<span data-ttu-id="be398-1797">"NetFx40_Legacy20SortingBehavior"</span><span class="sxs-lookup"><span data-stu-id="be398-1797">"NetFx40_Legacy20SortingBehavior"</span></span>|<span data-ttu-id="be398-1798">Значения сортировки строк по умолчанию [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] для включены в этом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1798">String sorting defaults for the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] are enabled in this application domain.</span></span> <span data-ttu-id="be398-1799">Для его успешного выполнения требуется установка sort00001000. dll.</span><span class="sxs-lookup"><span data-stu-id="be398-1799">Its success requires sort00001000.dll to be installed.</span></span> <span data-ttu-id="be398-1800">См. элемент компатсортнлсверсион. [ &lt;&gt; ](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md)</span><span class="sxs-lookup"><span data-stu-id="be398-1800">See [&lt;CompatSortNLSVersion&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md).</span></span>|  
|<span data-ttu-id="be398-1801">"NetFx40_Legacy40SortingBehavior"</span><span class="sxs-lookup"><span data-stu-id="be398-1801">"NetFx40_Legacy40SortingBehavior"</span></span>|<span data-ttu-id="be398-1802">Значения сортировки строк по умолчанию [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]для и Юникод 5,0 включены в этом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1802">String sorting defaults for the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]and Unicode 5.0 are enabled in this application domain.</span></span> <span data-ttu-id="be398-1803">Для его успешного выполнения требуется установка sort00060101. dll.</span><span class="sxs-lookup"><span data-stu-id="be398-1803">Its success requires sort00060101.dll to be installed.</span></span>|  
|<span data-ttu-id="be398-1804">"NetFx40_TimeSpanLegacyFormatMode"</span><span class="sxs-lookup"><span data-stu-id="be398-1804">"NetFx40_TimeSpanLegacyFormatMode"</span></span>|<span data-ttu-id="be398-1805"><xref:System.TimeSpan>поведение [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] форматирования в этом домене приложения включено.</span><span class="sxs-lookup"><span data-stu-id="be398-1805"><xref:System.TimeSpan> formatting behavior for the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] is enabled in this application domain.</span></span>  <span data-ttu-id="be398-1806"><xref:System.TimeSpan> См [ &lt;.&gt; элемент TimeSpan_LegacyFormatMode](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md) и раздел "восстановление устаревшего форматирования TimeSpan" раздела.</span><span class="sxs-lookup"><span data-stu-id="be398-1806">See [&lt;TimeSpan_LegacyFormatMode&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md) and the "Restoring Legacy TimeSpan Formatting" section of the <xref:System.TimeSpan> topic.</span></span>|  
|<span data-ttu-id="be398-1807">UseRandomizedStringHashAlgorithm</span><span class="sxs-lookup"><span data-stu-id="be398-1807">"UseRandomizedStringHashAlgorithm"</span></span>|<span data-ttu-id="be398-1808">Среда выполнения вычисляет хэш-коды для строк на уровне каждого приложения вместо использования единого алгоритма хэширования, который создает согласованный хэш-код между доменами приложений.</span><span class="sxs-lookup"><span data-stu-id="be398-1808">The runtime calculates hash codes for strings on a per application domain basis instead of using a single hashing algorithm that produces a consistent hash code across application domains.</span></span> <span data-ttu-id="be398-1809">См. элемент UseRandomizedStringHashAlgorithm. [ &lt;&gt; ](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)</span><span class="sxs-lookup"><span data-stu-id="be398-1809">See [&lt;UseRandomizedStringHashAlgorithm&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md).</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})" />
      </Docs>
    </Member>
    <Member MemberName="IsDefaultAppDomain">
      <MemberSignature Language="C#" Value="public bool IsDefaultAppDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsDefaultAppDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsDefaultAppDomain" />
      <MemberSignature Language="VB.NET" Value="Public Function IsDefaultAppDomain () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsDefaultAppDomain();" />
      <MemberSignature Language="F#" Value="member this.IsDefaultAppDomain : unit -&gt; bool" Usage="appDomain.IsDefaultAppDomain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="be398-1810">Возвращает значение, указывающее, является ли домен приложения используемым по умолчанию доменом для процесса.</span><span class="sxs-lookup"><span data-stu-id="be398-1810">Returns a value that indicates whether the application domain is the default application domain for the process.</span></span></summary>
        <returns><span data-ttu-id="be398-1811"><see langword="true" />, если текущий объект <see cref="T:System.AppDomain" /> представляет используемый по умолчанию домен приложения для процесса, в противном случае — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1811"><see langword="true" /> if the current <see cref="T:System.AppDomain" /> object represents the default application domain for the process; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-1812">Каждый управляемый процесс имеет домен приложения по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="be398-1812">Every managed process has a default application domain.</span></span> <span data-ttu-id="be398-1813">Выполнение начинается в домене по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="be398-1813">Execution begins in the default domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-1814">В следующем примере кода создается второй домен приложения и отображаются сведения о домене по умолчанию и новом домене.</span><span class="sxs-lookup"><span data-stu-id="be398-1814">The following code example creates a second application domain and displays information about the default domain and the new domain.</span></span>  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFinalizingForUnload">
      <MemberSignature Language="C#" Value="public bool IsFinalizingForUnload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsFinalizingForUnload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsFinalizingForUnload" />
      <MemberSignature Language="VB.NET" Value="Public Function IsFinalizingForUnload () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsFinalizingForUnload();" />
      <MemberSignature Language="F#" Value="member this.IsFinalizingForUnload : unit -&gt; bool" Usage="appDomain.IsFinalizingForUnload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="be398-1815">Определяет, выгружен ли этот домен приложения, и были ли закрыты средой CLR объекты, которые он содержал.</span><span class="sxs-lookup"><span data-stu-id="be398-1815">Indicates whether this application domain is unloading, and the objects it contains are being finalized by the common language runtime.</span></span></summary>
        <returns><span data-ttu-id="be398-1816">Значение <see langword="true" />, если этот домен приложения выгружен, и среда CLR начала вызов методов завершения, в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1816"><see langword="true" /> if this application domain is unloading and the common language runtime has started invoking finalizers; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-1817">Метод финализации для объекта предоставляет возможность выполнять все необходимые операции очистки до того, как объект будет удален сборщиком мусора.</span><span class="sxs-lookup"><span data-stu-id="be398-1817">The finalization method for an object provides you an opportunity to perform any necessary cleanup operations before the object is garbage collected.</span></span> <span data-ttu-id="be398-1818">После завершения объект доступен, но находится в недопустимом состоянии и поэтому непригоден для использования.</span><span class="sxs-lookup"><span data-stu-id="be398-1818">After finalization, the object is accessible but in an invalid state and therefore unusable.</span></span> <span data-ttu-id="be398-1819">Со временем сборка мусора завершается и освобождает объект.</span><span class="sxs-lookup"><span data-stu-id="be398-1819">Eventually, garbage collection completes and reclaims the object.</span></span>  
  
 <span data-ttu-id="be398-1820">Метод финализации объекта вызывается в одной из следующих ситуаций: во время сборки мусора, при завершении работы среды CLR или при выгрузке домена приложения, содержащего этот объект.</span><span class="sxs-lookup"><span data-stu-id="be398-1820">An object's finalization method is called in one of the following situations: during garbage collection, when the common language runtime is shutting down, or when the application domain that contains the object is unloaded.</span></span> <span data-ttu-id="be398-1821">Метод возвращает `true` только в последнем случае, он не возвращает `true` результат завершения из процедуры сборки мусора или из среды CLR. <xref:System.AppDomain.IsFinalizingForUnload%2A></span><span class="sxs-lookup"><span data-stu-id="be398-1821">The <xref:System.AppDomain.IsFinalizingForUnload%2A> method returns `true` only in the last case; it does not return `true` if finalization results from routine garbage collection or from CLR shutdown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="be398-1822">Чтобы определить, вызвано ли завершение средой CLR, используйте <xref:System.Environment.HasShutdownStarted%2A?displayProperty=nameWithType> свойство.</span><span class="sxs-lookup"><span data-stu-id="be398-1822">To determine whether finalization is due to CLR shutdown, use the <xref:System.Environment.HasShutdownStarted%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="be398-1823">Он возвращает `true` значение, если завершение вызвано выгрузкой домена приложения или завершением работы среды CLR.</span><span class="sxs-lookup"><span data-stu-id="be398-1823">It returns `true` if finalization is due to an application domain being unloaded or to the CLR shutting down.</span></span>  
  
 <span data-ttu-id="be398-1824">При выполнении метода завершения во время выгрузки домена может потребоваться доступ к другому объекту, на который ссылается статическое поле, и метод финализации.</span><span class="sxs-lookup"><span data-stu-id="be398-1824">While executing in your finalization method during domain unloading, you might want to access another object that is referenced by a static field and has a finalization method.</span></span> <span data-ttu-id="be398-1825">Однако вы не можете надежно сделать это, так как объект, к которому можно получить доступ, уже был завершен.</span><span class="sxs-lookup"><span data-stu-id="be398-1825">However, you cannot reliably do so because the accessed object might already have been finalized.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="be398-1826">Исключением из <xref:System.Console> этого правила является класс, который содержит статические поля, ссылающиеся на объекты потока, но реализуется особым образом, что позволяет всегда записывать в системную консоль даже во время выгрузки домена или завершения работы системы.</span><span class="sxs-lookup"><span data-stu-id="be398-1826">An exception to this rule is the <xref:System.Console> class, which contains static fields that reference stream objects, but is implemented specially so you can always write to the system console, even during domain unloading or system shutdown.</span></span>  
  
 <span data-ttu-id="be398-1827">Используйте этот метод в методе финализации объекта, чтобы определить, выгружается ли домен приложения, содержащий объект.</span><span class="sxs-lookup"><span data-stu-id="be398-1827">Use this method in an object's finalization method to determine whether the application domain that contains the object is unloading.</span></span> <span data-ttu-id="be398-1828">В этом случае нельзя надежно получить доступ к любому объекту, у которого есть метод финализации, и на который ссылается статическое поле.</span><span class="sxs-lookup"><span data-stu-id="be398-1828">If that is the case, you cannot reliably access any object that has a finalization method and is referenced by a static field.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Environment.HasShutdownStarted" />
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsFullyTrusted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFullyTrusted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFullyTrusted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFullyTrusted : bool" Usage="System.AppDomain.IsFullyTrusted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="be398-1829">Получает значение, указывающее, выполняются ли сборки, загруженные в текущий домен приложения, с полным доверием.</span><span class="sxs-lookup"><span data-stu-id="be398-1829">Gets a value that indicates whether assemblies that are loaded into the current application domain execute with full trust.</span></span></summary>
        <value><span data-ttu-id="be398-1830">Значение <see langword="true" />, если сборки, загруженные в текущий домен приложения, выполняются с полным доверием; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1830"><see langword="true" /> if assemblies that are loaded into the current application domain execute with full trust; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-1831">Этот метод всегда возвращается `true` для домена приложения по умолчанию приложения, которое выполняется на рабочем столе.</span><span class="sxs-lookup"><span data-stu-id="be398-1831">This method always returns `true` for the default application domain of an application that runs on the desktop.</span></span> <span data-ttu-id="be398-1832">Он возвращает `false` для изолированного домена приложения, созданного <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> с помощью перегрузки метода, если разрешения, предоставленные домену приложения, эквивалентны полному доверию.</span><span class="sxs-lookup"><span data-stu-id="be398-1832">It returns `false` for a sandboxed application domain that was created by using the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> method overload, unless the permissions that are granted to the application domain are equivalent to full trust.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-1833">В следующем примере демонстрируется <xref:System.AppDomain.IsFullyTrusted%2A> свойство <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> и свойство с полностью доверенными и частично доверенными доменами приложений.</span><span class="sxs-lookup"><span data-stu-id="be398-1833">The following example demonstrates the <xref:System.AppDomain.IsFullyTrusted%2A> property and the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> property with fully trusted and partially trusted application domains.</span></span> <span data-ttu-id="be398-1834">Полностью доверенный домен приложения — это домен приложения по умолчанию для приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1834">The fully trusted application domain is the default application domain for the application.</span></span> <span data-ttu-id="be398-1835">Частично доверенный домен приложения создается с помощью <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> перегрузки метода.</span><span class="sxs-lookup"><span data-stu-id="be398-1835">The partially trusted application domain is created by using the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> method overload.</span></span>  
  
 <span data-ttu-id="be398-1836">В примере используется `Worker` класс, производный от <xref:System.MarshalByRefObject>, поэтому он может быть маршалирован через границы домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1836">The example uses a `Worker` class that derives from <xref:System.MarshalByRefObject>, so it can be marshaled across application domain boundaries.</span></span> <span data-ttu-id="be398-1837">В примере создается `Worker` объект в домене приложения по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="be398-1837">The example creates a `Worker` object in the default application domain.</span></span> <span data-ttu-id="be398-1838">Затем он вызывает `TestIsFullyTrusted` метод для вывода значения свойства для домена приложения и для двух сборок, загружаемых в домен приложения: mscorlib, который является частью .NET Framework, и примером сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1838">It then calls the `TestIsFullyTrusted` method to display the property value for the application domain and for two assemblies that are loaded into the application domain: mscorlib, which is part of the .NET Framework, and the example assembly.</span></span> <span data-ttu-id="be398-1839">Домен приложения является полностью доверенным, поэтому обе сборки являются полностью доверенными.</span><span class="sxs-lookup"><span data-stu-id="be398-1839">The application domain is fully trusted, so both assemblies are fully trusted.</span></span>  
  
 <span data-ttu-id="be398-1840">В примере создается другой `Worker` объект в изолированном домене приложения, который снова `TestIsFullyTrusted` вызывает метод.</span><span class="sxs-lookup"><span data-stu-id="be398-1840">The example creates another `Worker` object in a sandboxed application domain and again calls the `TestIsFullyTrusted` method.</span></span> <span data-ttu-id="be398-1841">Mscorlib всегда является доверенным, даже в домене приложения с частичным доверием, но пример сборки является частично доверенным.</span><span class="sxs-lookup"><span data-stu-id="be398-1841">Mscorlib is always trusted, even in a partially trusted application domain, but the example assembly is partially trusted.</span></span>  
  
 [!code-csharp[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/cs/example.cs#1)]
 [!code-vb[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHomogenous">
      <MemberSignature Language="C#" Value="public bool IsHomogenous { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHomogenous" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsHomogenous" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHomogenous As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHomogenous { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsHomogenous : bool" Usage="System.AppDomain.IsHomogenous" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="be398-1842">Возвращает значение, указывающее, имеет ли текущий домен приложения набор разрешений, которые предоставляются всем сборкам, загружаемым в домен приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1842">Gets a value that indicates whether the current application domain has a set of permissions that is granted to all assemblies that are loaded into the application domain.</span></span></summary>
        <value><span data-ttu-id="be398-1843">Значение <see langword="true" />, если текущий домен приложения имеет однородный набор разрешений; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1843"><see langword="true" /> if the current application domain has a homogenous set of permissions; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-1844">Это свойство возвращает `true` для доменов изолированных приложений, созданных с <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> помощью перегрузки метода.</span><span class="sxs-lookup"><span data-stu-id="be398-1844">This property returns `true` for sandboxed application domains that were created by using the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="be398-1845">Изолированные домены приложений имеют однородный набор разрешений. то есть один и тот же набор разрешений предоставляется всем частично доверенным сборкам, загруженным в домен приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1845">Sandboxed application domains have a homogenous set of permissions; that is, the same set of permissions is granted to all partially trusted assemblies that are loaded into the application domain.</span></span> <span data-ttu-id="be398-1846">Домен изолированного приложения, при необходимости, имеет список сборок со строгими именами, которые исключены из этого набора разрешений, а выполняются с полным доверием.</span><span class="sxs-lookup"><span data-stu-id="be398-1846">A sandboxed application domain optionally has a list of strong-named assemblies that are exempt from this permission set, and instead run with full trust.</span></span>  
  
 <span data-ttu-id="be398-1847">Полностью доверенный код может использовать <xref:System.AppDomain.PermissionSet%2A> свойство для определения однородного набора разрешений изолированного домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1847">Fully trusted code can use the <xref:System.AppDomain.PermissionSet%2A> property to determine the homogenous grant set of a sandboxed application domain.</span></span>  
  
 <span data-ttu-id="be398-1848">Это свойство также возвращается `true` для домена приложения по умолчанию для классического приложения, так как этот домен приложения предоставляет полное доверие всем сборкам.</span><span class="sxs-lookup"><span data-stu-id="be398-1848">This property also returns `true` for the default application domain of a desktop application, because that application domain grants full trust to all assemblies.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomain.PermissionSet" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="be398-1849">Загружает сборку <see cref="T:System.Reflection.Assembly" /> в этот домен приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1849">Loads an <see cref="T:System.Reflection.Assembly" /> into this application domain.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] -&gt; System.Reflection.Assembly" Usage="appDomain.Load rawAssembly" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly"><span data-ttu-id="be398-1850">Массив типа <see langword="byte" />, который является образом в формате COFF, содержащим порожденную сборку.</span><span class="sxs-lookup"><span data-stu-id="be398-1850">An array of type <see langword="byte" /> that is a COFF-based image containing an emitted assembly.</span></span></param>
        <summary><span data-ttu-id="be398-1851">Загружает объект <see cref="T:System.Reflection.Assembly" /> с образом в формате COFF, содержащим созданный объект <see cref="T:System.Reflection.Assembly" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1851">Loads the <see cref="T:System.Reflection.Assembly" /> with a common object file format (COFF) based image containing an emitted <see cref="T:System.Reflection.Assembly" />.</span></span></summary>
        <returns><span data-ttu-id="be398-1852">Загруженная сборка.</span><span class="sxs-lookup"><span data-stu-id="be398-1852">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-1853">Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], уровень доверия сборки, загружаемой с помощью этого метода, совпадает с уровнем доверия домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1853">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the trust level of an assembly that is loaded by using this method is the same as the trust level of the application domain.</span></span>  
  
 <span data-ttu-id="be398-1854">Этот метод следует использовать только для загрузки сборки в текущий домен приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1854">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="be398-1855">Этот метод предоставляется для удобства взаимодействия вызывающих методов, которые не могут вызывать статический <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="be398-1855">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="be398-1856">Чтобы загрузить сборки в другие домены приложений, используйте такой метод, <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>как.</span><span class="sxs-lookup"><span data-stu-id="be398-1856">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="be398-1857">Сведения, общие для всех перегрузок этого метода, см. в <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> разделе перегрузка метода.</span><span class="sxs-lookup"><span data-stu-id="be398-1857">For information that is common to all overloads of this method, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-1858">В следующем примере демонстрируется использование загрузки необработанной сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1858">The following sample demonstrates the use of loading a raw assembly.</span></span>  
  
 <span data-ttu-id="be398-1859">Для выполнения этого примера кода необходимо указать полное имя сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1859">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="be398-1860">Дополнительные сведения о получении полного имени сборки см. в разделе [имена сборок](~/docs/framework/app-domains/assembly-names.md).</span><span class="sxs-lookup"><span data-stu-id="be398-1860">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-1861">Свойство <paramref name="rawAssembly" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1861"><paramref name="rawAssembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="be398-1862"><paramref name="rawAssembly" /> не является допустимой сборкой.</span><span class="sxs-lookup"><span data-stu-id="be398-1862"><paramref name="rawAssembly" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="be398-1863">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-1863">-or-</span></span> 
<span data-ttu-id="be398-1864">Сейчас загружена среда CLR 2.0 или более поздней версии. Сборка <paramref name="rawAssembly" /> скомпилирована в более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="be398-1864">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-1865">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1865">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="be398-1866">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</span><span class="sxs-lookup"><span data-stu-id="be398-1866">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="be398-1867">для доступа к чтению из файла или каталога, а также для доступа к данным в самом пути.</span><span class="sxs-lookup"><span data-stu-id="be398-1867">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="be398-1868">Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1868">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly&#xA;override this.Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="appDomain.Load assemblyRef" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef"><span data-ttu-id="be398-1869">Объект, который описывает сборку, подлежащую загрузке.</span><span class="sxs-lookup"><span data-stu-id="be398-1869">An object that describes the assembly to load.</span></span></param>
        <summary><span data-ttu-id="be398-1870">Загружает сборку <see cref="T:System.Reflection.Assembly" />, заданную ее именем <see cref="T:System.Reflection.AssemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1870">Loads an <see cref="T:System.Reflection.Assembly" /> given its <see cref="T:System.Reflection.AssemblyName" />.</span></span></summary>
        <returns><span data-ttu-id="be398-1871">Загруженная сборка.</span><span class="sxs-lookup"><span data-stu-id="be398-1871">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-1872">Этот метод следует использовать только для загрузки сборки в текущий домен приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1872">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="be398-1873">Этот метод предоставляется для удобства взаимодействия вызывающих методов, которые не могут вызывать статический <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="be398-1873">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="be398-1874">Чтобы загрузить сборки в другие домены приложений, используйте такой метод, <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>как.</span><span class="sxs-lookup"><span data-stu-id="be398-1874">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="be398-1875">Если версия запрошенной сборки уже загружена, этот метод возвращает загруженную сборку, даже если запрошена другая версия.</span><span class="sxs-lookup"><span data-stu-id="be398-1875">If a version of the requested assembly is already loaded, this method returns the loaded assembly, even if a different version is requested.</span></span>  
  
 <span data-ttu-id="be398-1876">Не рекомендуется указывать частичное имя сборки `assemblyRef` для.</span><span class="sxs-lookup"><span data-stu-id="be398-1876">Supplying a partial assembly name for `assemblyRef` is not recommended.</span></span> <span data-ttu-id="be398-1877">(Частичное имя пропускает один или несколько языков и региональных параметров, версии или маркера открытого ключа.</span><span class="sxs-lookup"><span data-stu-id="be398-1877">(A partial name omits one or more of culture, version, or public key token.</span></span> <span data-ttu-id="be398-1878">Для перегрузок, принимающих строку вместо <xref:System.Reflection.AssemblyName> объекта, "MyAssembly, Version = 1.0.0.0" — это пример частичного имени, а "MyAssembly, Version = 1.0.0.0, культура = нейтральный, PublicKeyToken = 18ab3442da84b47" — пример полного имени.) Использование частичных имен отрицательно сказывается на производительности.</span><span class="sxs-lookup"><span data-stu-id="be398-1878">For overloads that take a string instead of an <xref:System.Reflection.AssemblyName> object, "MyAssembly, Version=1.0.0.0" is an example of a partial name and "MyAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=18ab3442da84b47" is an example of a full name.) Using partial names has a negative effect on performance.</span></span> <span data-ttu-id="be398-1879">Кроме того, частичное имя сборки может загружать сборку из глобального кэша сборок только в том случае, если имеется точная копия сборки в базовом каталоге приложения (<xref:System.AppDomain.BaseDirectory%2A> или <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>).</span><span class="sxs-lookup"><span data-stu-id="be398-1879">In addition, a partial assembly name can load an assembly from the global assembly cache only if there is an exact copy of the assembly in the application base directory (<xref:System.AppDomain.BaseDirectory%2A> or <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>).</span></span>  
  
 <span data-ttu-id="be398-1880">Если текущий <xref:System.AppDomain> объект представляет домен `A`приложения, а <xref:System.AppDomain.Load%2A> метод вызывается из домена `B`приложения, сборка загружается в оба домена приложений.</span><span class="sxs-lookup"><span data-stu-id="be398-1880">If the current <xref:System.AppDomain> object represents application domain `A`, and the <xref:System.AppDomain.Load%2A> method is called from application domain `B`, the assembly is loaded into both application domains.</span></span> <span data-ttu-id="be398-1881">Например, следующий код загружается `MyAssembly` в новый домен `ChildDomain` приложения, а также в домен приложения, в котором выполняется код:</span><span class="sxs-lookup"><span data-stu-id="be398-1881">For example, the following code loads `MyAssembly` into the new application domain `ChildDomain` and also into the application domain where the code executes:</span></span>  
  
 [!code-cpp[System.AppDomain.Load#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.load/cpp/source.cpp#1)]
 [!code-csharp[System.AppDomain.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.load/cs/source.cs#1)]
 [!code-vb[System.AppDomain.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.load/vb/source.vb#1)]  
  
 <span data-ttu-id="be398-1882">Сборка загружается в оба домена, <xref:System.Reflection.Assembly> поскольку не является производной <xref:System.MarshalByRefObject>от, и поэтому возвращаемое значение <xref:System.AppDomain.Load%2A> метода не может быть упаковано.</span><span class="sxs-lookup"><span data-stu-id="be398-1882">The assembly is loaded into both domains because <xref:System.Reflection.Assembly> does not derive from <xref:System.MarshalByRefObject>, and therefore the return value of the <xref:System.AppDomain.Load%2A> method cannot be marshaled.</span></span> <span data-ttu-id="be398-1883">Вместо этого среда CLR пытается загрузить сборку в вызывающий домен приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1883">Instead, the common language runtime tries to load the assembly into the calling application domain.</span></span> <span data-ttu-id="be398-1884">Сборки, загруженные в два домена приложений, могут отличаться, если параметры пути для двух доменов приложений различаются.</span><span class="sxs-lookup"><span data-stu-id="be398-1884">The assemblies that are loaded into the two application domains might be different if the path settings for the two application domains are different.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="be398-1885">Если заданы <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> и <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> свойство, и свойство, при первой попытке загрузки сборки используется отображаемое имя (включая версию, культуру и т. д., которое возвращается свойством). <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="be398-1885">If both the <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> property and the <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> property are set, the first attempt to load the assembly uses the display name (including version, culture, and so on, as returned by the <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> property).</span></span> <span data-ttu-id="be398-1886">Если файл не найден, <xref:System.Reflection.AssemblyName.CodeBase%2A> свойство используется для поиска сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1886">If the file is not found, the <xref:System.Reflection.AssemblyName.CodeBase%2A> property is used to search for the assembly.</span></span> <span data-ttu-id="be398-1887">Если сборка найдена с помощью <xref:System.Reflection.AssemblyName.CodeBase%2A>, отображаемое имя сопоставляется с сборкой.</span><span class="sxs-lookup"><span data-stu-id="be398-1887">If the assembly is found using <xref:System.Reflection.AssemblyName.CodeBase%2A>, the display name is matched against the assembly.</span></span> <span data-ttu-id="be398-1888">Если совпадение не удается, <xref:System.IO.FileLoadException> создается исключение.</span><span class="sxs-lookup"><span data-stu-id="be398-1888">If the match fails, a <xref:System.IO.FileLoadException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-1889">Свойство <paramref name="assemblyRef" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1889"><paramref name="assemblyRef" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="be398-1890"><paramref name="assemblyRef" /> не найден.</span><span class="sxs-lookup"><span data-stu-id="be398-1890"><paramref name="assemblyRef" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="be398-1891"><paramref name="assemblyRef" /> не является допустимой сборкой.</span><span class="sxs-lookup"><span data-stu-id="be398-1891"><paramref name="assemblyRef" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="be398-1892">-или-</span><span class="sxs-lookup"><span data-stu-id="be398-1892">-or-</span></span> 
<span data-ttu-id="be398-1893">Сейчас загружена среда CLR 2.0 или более поздней версии. Сборка <paramref name="assemblyRef" /> скомпилирована в более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="be398-1893">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyRef" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-1894">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1894">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="be398-1895">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</span><span class="sxs-lookup"><span data-stu-id="be398-1895">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="be398-1896">для доступа к чтению из файла или каталога, а также для доступа к данным в самом пути.</span><span class="sxs-lookup"><span data-stu-id="be398-1896">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="be398-1897">Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1897">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="abstract member Load : string -&gt; System.Reflection.Assembly&#xA;override this.Load : string -&gt; System.Reflection.Assembly" Usage="appDomain.Load assemblyString" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString"><span data-ttu-id="be398-1898">Отображаемое имя сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1898">The display name of the assembly.</span></span> <span data-ttu-id="be398-1899">См. раздел <see cref="P:System.Reflection.Assembly.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1899">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <summary><span data-ttu-id="be398-1900">Загружает сборку <see cref="T:System.Reflection.Assembly" />, заданную ее отображаемым именем.</span><span class="sxs-lookup"><span data-stu-id="be398-1900">Loads an <see cref="T:System.Reflection.Assembly" /> given its display name.</span></span></summary>
        <returns><span data-ttu-id="be398-1901">Загруженная сборка.</span><span class="sxs-lookup"><span data-stu-id="be398-1901">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-1902">Этот метод следует использовать только для загрузки сборки в текущий домен приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1902">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="be398-1903">Этот метод предоставляется для удобства взаимодействия вызывающих методов, которые не могут вызывать статический <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="be398-1903">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="be398-1904">Чтобы загрузить сборки в другие домены приложений, используйте такой метод, <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>как.</span><span class="sxs-lookup"><span data-stu-id="be398-1904">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="be398-1905">Сведения, общие для всех перегрузок этого метода, см. в <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> разделе перегрузка метода.</span><span class="sxs-lookup"><span data-stu-id="be398-1905">For information that is common to all overloads of this method, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-1906"><paramref name="assemblyString" /> равно <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="be398-1906"><paramref name="assemblyString" /> is <see langword="null" /></span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="be398-1907"><paramref name="assemblyString" /> не найден.</span><span class="sxs-lookup"><span data-stu-id="be398-1907"><paramref name="assemblyString" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="be398-1908"><paramref name="assemblyString" /> не является допустимой сборкой.</span><span class="sxs-lookup"><span data-stu-id="be398-1908"><paramref name="assemblyString" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="be398-1909">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-1909">-or-</span></span> 
<span data-ttu-id="be398-1910">Сейчас загружена среда CLR 2.0 или более поздней версии. Сборка <paramref name="assemblyString" /> скомпилирована в более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="be398-1910">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyString" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-1911">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1911">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="be398-1912">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</span><span class="sxs-lookup"><span data-stu-id="be398-1912">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="be398-1913">для доступа к чтению из файла или каталога, а также для доступа к данным в самом пути.</span><span class="sxs-lookup"><span data-stu-id="be398-1913">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="be398-1914">Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1914">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="be398-1915">значение для возможности доступа к расположению сборки, если сборка не является локальной.</span><span class="sxs-lookup"><span data-stu-id="be398-1915">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] * byte[] -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] * byte[] -&gt; System.Reflection.Assembly" Usage="appDomain.Load (rawAssembly, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly"><span data-ttu-id="be398-1916">Массив типа <see langword="byte" />, который является образом в формате COFF, содержащим порожденную сборку.</span><span class="sxs-lookup"><span data-stu-id="be398-1916">An array of type <see langword="byte" /> that is a COFF-based image containing an emitted assembly.</span></span></param>
        <param name="rawSymbolStore"><span data-ttu-id="be398-1917">Массив типа <see langword="byte" />, содержащий необработанные байты, которые представляют символы для сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1917">An array of type <see langword="byte" /> containing the raw bytes representing the symbols for the assembly.</span></span></param>
        <summary><span data-ttu-id="be398-1918">Загружает объект <see cref="T:System.Reflection.Assembly" /> с образом в формате COFF, содержащим порожденный объект <see cref="T:System.Reflection.Assembly" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1918">Loads the <see cref="T:System.Reflection.Assembly" /> with a common object file format (COFF) based image containing an emitted <see cref="T:System.Reflection.Assembly" />.</span></span> <span data-ttu-id="be398-1919">Загружаются также необработанные байты, представляющие символы для <see cref="T:System.Reflection.Assembly" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1919">The raw bytes representing the symbols for the <see cref="T:System.Reflection.Assembly" /> are also loaded.</span></span></summary>
        <returns><span data-ttu-id="be398-1920">Загруженная сборка.</span><span class="sxs-lookup"><span data-stu-id="be398-1920">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-1921">Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], уровень доверия сборки, загружаемой с помощью этого метода, совпадает с уровнем доверия домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1921">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the trust level of an assembly that is loaded by using this method is the same as the trust level of the application domain.</span></span>  
  
 <span data-ttu-id="be398-1922">Этот метод следует использовать только для загрузки сборки в текущий домен приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1922">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="be398-1923">Этот метод предоставляется для удобства взаимодействия вызывающих методов, которые не могут вызывать статический <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="be398-1923">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="be398-1924">Чтобы загрузить сборки в другие домены приложений, используйте такой метод, <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>как.</span><span class="sxs-lookup"><span data-stu-id="be398-1924">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="be398-1925">Сведения, общие для всех перегрузок этого метода, см. в <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> разделе перегрузка метода.</span><span class="sxs-lookup"><span data-stu-id="be398-1925">For information that is common to all overloads of this method, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-1926">В следующем примере демонстрируется использование загрузки необработанной сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1926">The following sample demonstrates the use of loading a raw assembly.</span></span>  
  
 <span data-ttu-id="be398-1927">Для выполнения этого примера кода необходимо указать полное имя сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1927">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="be398-1928">Дополнительные сведения о получении полного имени сборки см. в разделе [имена сборок](~/docs/framework/app-domains/assembly-names.md).</span><span class="sxs-lookup"><span data-stu-id="be398-1928">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-1929"><paramref name="rawAssembly" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1929"><paramref name="rawAssembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="be398-1930"><paramref name="rawAssembly" /> не является допустимой сборкой.</span><span class="sxs-lookup"><span data-stu-id="be398-1930"><paramref name="rawAssembly" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="be398-1931">-или-</span><span class="sxs-lookup"><span data-stu-id="be398-1931">-or-</span></span> 
<span data-ttu-id="be398-1932">Сейчас загружена среда CLR 2.0 или более поздней версии. Сборка <paramref name="rawAssembly" /> скомпилирована в более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="be398-1932">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-1933">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1933">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="be398-1934">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</span><span class="sxs-lookup"><span data-stu-id="be398-1934">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="be398-1935">для чтения URI, который не начинается с "file://".</span><span class="sxs-lookup"><span data-stu-id="be398-1935">for reading a URI that does not begin with "file://".</span></span></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="be398-1936">для доступа к чтению из файла или каталога, а также для доступа к данным в самом пути.</span><span class="sxs-lookup"><span data-stu-id="be398-1936">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="be398-1937">Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1937">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (assemblyRef, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyRef"><span data-ttu-id="be398-1938">Объект, который описывает сборку, подлежащую загрузке.</span><span class="sxs-lookup"><span data-stu-id="be398-1938">An object that describes the assembly to load.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="be398-1939">Свидетельство для загрузки сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1939">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="be398-1940">Загружает сборку <see cref="T:System.Reflection.Assembly" />, заданную ее именем <see cref="T:System.Reflection.AssemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1940">Loads an <see cref="T:System.Reflection.Assembly" /> given its <see cref="T:System.Reflection.AssemblyName" />.</span></span></summary>
        <returns><span data-ttu-id="be398-1941">Загруженная сборка.</span><span class="sxs-lookup"><span data-stu-id="be398-1941">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-1942">Этот метод следует использовать только для загрузки сборки в текущий домен приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1942">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="be398-1943">Этот метод предоставляется для удобства взаимодействия вызывающих методов, которые не могут вызывать статический <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="be398-1943">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="be398-1944">Чтобы загрузить сборки в другие домены приложений, используйте такой метод, <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>как.</span><span class="sxs-lookup"><span data-stu-id="be398-1944">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="be398-1945">Сведения, общие для всех перегрузок этого метода, см. в <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> разделе перегрузка метода.</span><span class="sxs-lookup"><span data-stu-id="be398-1945">For information that is common to all overloads of this method, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-1946"><paramref name="assemblyRef" /> равно <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="be398-1946"><paramref name="assemblyRef" /> is <see langword="null" /></span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="be398-1947"><paramref name="assemblyRef" /> не найден.</span><span class="sxs-lookup"><span data-stu-id="be398-1947"><paramref name="assemblyRef" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="be398-1948"><paramref name="assemblyRef" /> не является допустимой сборкой.</span><span class="sxs-lookup"><span data-stu-id="be398-1948"><paramref name="assemblyRef" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="be398-1949">-или-</span><span class="sxs-lookup"><span data-stu-id="be398-1949">-or-</span></span> 
<span data-ttu-id="be398-1950">Сейчас загружена среда CLR 2.0 или более поздней версии. Сборка <paramref name="assemblyRef" /> скомпилирована в более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="be398-1950">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyRef" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-1951">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1951">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="be398-1952">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</span><span class="sxs-lookup"><span data-stu-id="be398-1952">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="be398-1953">для доступа к чтению из файла или каталога, а также для доступа к данным в самом пути.</span><span class="sxs-lookup"><span data-stu-id="be398-1953">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="be398-1954">Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1954">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="be398-1955">для загрузки сборки с свидетельством.</span><span class="sxs-lookup"><span data-stu-id="be398-1955">to load an assembly with evidence.</span></span> <span data-ttu-id="be398-1956">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1956">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="be398-1957">для чтения пути, который не имеет вид "file://", "\\\унк\дир\\" или "c:\\".</span><span class="sxs-lookup"><span data-stu-id="be398-1957">for reading a path that is not in the form "file://" or "\\\UNC\dir\\" or "c:\\".</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (assemblyString, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyString"><span data-ttu-id="be398-1958">Отображаемое имя сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1958">The display name of the assembly.</span></span> <span data-ttu-id="be398-1959">См. раздел <see cref="P:System.Reflection.Assembly.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1959">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="be398-1960">Свидетельство для загрузки сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1960">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="be398-1961">Загружает сборку <see cref="T:System.Reflection.Assembly" />, заданную ее отображаемым именем.</span><span class="sxs-lookup"><span data-stu-id="be398-1961">Loads an <see cref="T:System.Reflection.Assembly" /> given its display name.</span></span></summary>
        <returns><span data-ttu-id="be398-1962">Загруженная сборка.</span><span class="sxs-lookup"><span data-stu-id="be398-1962">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-1963">Этот метод следует использовать только для загрузки сборки в текущий домен приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1963">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="be398-1964">Этот метод предоставляется для удобства взаимодействия вызывающих методов, которые не могут вызывать статический <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="be398-1964">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="be398-1965">Чтобы загрузить сборки в другие домены приложений, используйте такой метод, <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>как.</span><span class="sxs-lookup"><span data-stu-id="be398-1965">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="be398-1966">Сведения, общие для всех перегрузок этого метода, см. в <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> разделе перегрузка метода.</span><span class="sxs-lookup"><span data-stu-id="be398-1966">For information that is common to all overloads of this method, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-1967"><paramref name="assemblyString" /> равно <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="be398-1967"><paramref name="assemblyString" /> is <see langword="null" /></span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="be398-1968"><paramref name="assemblyString" /> не найден.</span><span class="sxs-lookup"><span data-stu-id="be398-1968"><paramref name="assemblyString" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="be398-1969"><paramref name="assemblyString" /> не является допустимой сборкой.</span><span class="sxs-lookup"><span data-stu-id="be398-1969"><paramref name="assemblyString" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="be398-1970">- или -</span><span class="sxs-lookup"><span data-stu-id="be398-1970">-or-</span></span> 
<span data-ttu-id="be398-1971">Сейчас загружена среда CLR 2.0 или более поздней версии. Сборка <paramref name="assemblyString" /> скомпилирована в более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="be398-1971">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyString" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-1972">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1972">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="be398-1973">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</span><span class="sxs-lookup"><span data-stu-id="be398-1973">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="be398-1974">для загрузки сборки с свидетельством.</span><span class="sxs-lookup"><span data-stu-id="be398-1974">to load an assembly with evidence.</span></span> <span data-ttu-id="be398-1975">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1975">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="be398-1976">для доступа к чтению из файла или каталога, а также для доступа к данным в самом пути.</span><span class="sxs-lookup"><span data-stu-id="be398-1976">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="be398-1977">Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1977">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="be398-1978">для чтения пути, который не имеет вид "file://", "\\\унк\дир\\" или "c:\\".</span><span class="sxs-lookup"><span data-stu-id="be398-1978">for reading a path that is not in the form "file://" or "\\\UNC\dir\\" or "c:\\".</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte(), securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (rawAssembly, rawSymbolStore, securityEvidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="rawAssembly"><span data-ttu-id="be398-1979">Массив типа <see langword="byte" />, который является образом в формате COFF, содержащим порожденную сборку.</span><span class="sxs-lookup"><span data-stu-id="be398-1979">An array of type <see langword="byte" /> that is a COFF-based image containing an emitted assembly.</span></span></param>
        <param name="rawSymbolStore"><span data-ttu-id="be398-1980">Массив типа <see langword="byte" />, содержащий необработанные байты, которые представляют символы для сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1980">An array of type <see langword="byte" /> containing the raw bytes representing the symbols for the assembly.</span></span></param>
        <param name="securityEvidence"><span data-ttu-id="be398-1981">Свидетельство для загрузки сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1981">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="be398-1982">Загружает объект <see cref="T:System.Reflection.Assembly" /> с образом в формате COFF, содержащим порожденный объект <see cref="T:System.Reflection.Assembly" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1982">Loads the <see cref="T:System.Reflection.Assembly" /> with a common object file format (COFF) based image containing an emitted <see cref="T:System.Reflection.Assembly" />.</span></span> <span data-ttu-id="be398-1983">Загружаются также необработанные байты, представляющие символы для <see cref="T:System.Reflection.Assembly" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1983">The raw bytes representing the symbols for the <see cref="T:System.Reflection.Assembly" /> are also loaded.</span></span></summary>
        <returns><span data-ttu-id="be398-1984">Загруженная сборка.</span><span class="sxs-lookup"><span data-stu-id="be398-1984">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-1985">Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], уровень доверия сборки, загружаемой с помощью этого метода, совпадает с уровнем доверия домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1985">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the trust level of an assembly that is loaded by using this method is the same as the trust level of the application domain.</span></span>  
  
 <span data-ttu-id="be398-1986">Этот метод следует использовать только для загрузки сборки в текущий домен приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1986">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="be398-1987">Этот метод предоставляется для удобства взаимодействия вызывающих методов, которые не могут вызывать статический <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="be398-1987">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="be398-1988">Чтобы загрузить сборки в другие домены приложений, используйте такой метод, <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>как.</span><span class="sxs-lookup"><span data-stu-id="be398-1988">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="be398-1989">Сведения, общие для всех перегрузок этого метода, см. в <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> разделе перегрузка метода.</span><span class="sxs-lookup"><span data-stu-id="be398-1989">For information that is common to all overloads of this method, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-1990">В следующем примере демонстрируется использование загрузки необработанной сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1990">The following sample demonstrates the use of loading a raw assembly.</span></span>  
  
 <span data-ttu-id="be398-1991">Для выполнения этого примера кода необходимо указать полное имя сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-1991">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="be398-1992">Дополнительные сведения о получении полного имени сборки см. в разделе [имена сборок](~/docs/framework/app-domains/assembly-names.md).</span><span class="sxs-lookup"><span data-stu-id="be398-1992">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-1993"><paramref name="rawAssembly" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1993"><paramref name="rawAssembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="be398-1994"><paramref name="rawAssembly" /> не является допустимой сборкой.</span><span class="sxs-lookup"><span data-stu-id="be398-1994"><paramref name="rawAssembly" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="be398-1995">-или-</span><span class="sxs-lookup"><span data-stu-id="be398-1995">-or-</span></span> 
<span data-ttu-id="be398-1996">Сейчас загружена среда CLR 2.0 или более поздней версии. Сборка <paramref name="rawAssembly" /> скомпилирована в более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="be398-1996">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-1997">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-1997">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="be398-1998">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</span><span class="sxs-lookup"><span data-stu-id="be398-1998">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="be398-1999"><paramref name="securityEvidence" /> не является <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-1999"><paramref name="securityEvidence" /> is not <see langword="null" />.</span></span> <span data-ttu-id="be398-2000">Если не включена политика разграничения доступа кода для кода предыдущей версии, <paramref name="securityEvidence" /> должно иметь значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-2000">When legacy CAS policy is not enabled, <paramref name="securityEvidence" /> should be <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="be398-2001">для предоставления свидетельства.</span><span class="sxs-lookup"><span data-stu-id="be398-2001">to provide evidence.</span></span> <span data-ttu-id="be398-2002">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="be398-2002">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span> <span data-ttu-id="be398-2003">Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span><span class="sxs-lookup"><span data-stu-id="be398-2003">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="be398-2004">для доступа к чтению из файла или каталога, а также для доступа к данным в самом пути.</span><span class="sxs-lookup"><span data-stu-id="be398-2004">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="be398-2005">Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="be398-2005">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="be398-2006">для чтения пути, который не имеет вид "file://", "\\\унк\дир\\" или "c:\\".</span><span class="sxs-lookup"><span data-stu-id="be398-2006">for reading a path that is not in the form "file://" or "\\\UNC\dir\\" or "c:\\".</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringIsEnabled">
      <MemberSignature Language="C#" Value="public static bool MonitoringIsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MonitoringIsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringIsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property MonitoringIsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MonitoringIsEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringIsEnabled : bool with get, set" Usage="System.AppDomain.MonitoringIsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="be398-2007">Получает или задает значение, указывающее, включен ли мониторинг ЦП и памяти доменов приложений для текущего процесса.</span><span class="sxs-lookup"><span data-stu-id="be398-2007">Gets or sets a value that indicates whether CPU and memory monitoring of application domains is enabled for the current process.</span></span> <span data-ttu-id="be398-2008">После того, как мониторинг для процесса включен, отключить его невозможно.</span><span class="sxs-lookup"><span data-stu-id="be398-2008">Once monitoring is enabled for a process, it cannot be disabled.</span></span></summary>
        <value><span data-ttu-id="be398-2009">Значение <see langword="true" />, если мониторинг включен; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="be398-2009"><see langword="true" /> if monitoring is enabled; otherwise <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-2010">Это `static` свойство (`Shared` свойство в Visual Basic) управляет мониторингом ЦП и памяти для всех доменов приложений в процессе.</span><span class="sxs-lookup"><span data-stu-id="be398-2010">This `static` property (`Shared` property in Visual Basic) controls CPU and memory monitoring of all the application domains in the process.</span></span>  
  
 <span data-ttu-id="be398-2011">При попытке установить это свойство в `false` <xref:System.ArgumentException> значение возникает исключение, даже если текущим значением свойства является `false`.</span><span class="sxs-lookup"><span data-stu-id="be398-2011">If you attempt to set this property to `false`, a <xref:System.ArgumentException> exception is thrown, even if the current value of the property is `false`.</span></span>  
  
 <span data-ttu-id="be398-2012">После <xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>включения мониторинга можно использовать свойства экземпляра, <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A>, <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A>и <xref:System.AppDomain.MonitoringTotalProcessorTime%2A> для мониторинга использования ЦП и памяти отдельными доменами приложений.</span><span class="sxs-lookup"><span data-stu-id="be398-2012">Once monitoring is enabled, you can use the <xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>, <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A>, <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A>, and <xref:System.AppDomain.MonitoringTotalProcessorTime%2A> instance properties to monitor CPU and memory use of individual application domains.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="be398-2013">Текущий процесс попытался присвоить значение <see langword="false" /> этому свойству.</span><span class="sxs-lookup"><span data-stu-id="be398-2013">The current process attempted to assign the value <see langword="false" /> to this property.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="be398-2014">Требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="be398-2014">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="be398-2015">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="be398-2015">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315"><span data-ttu-id="be398-2016">Отслеживание ресурсов домена приложения</span><span class="sxs-lookup"><span data-stu-id="be398-2016">Application Domain Resource Monitoring</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/02119ab6-1e91-448e-97ad-e7b2e5c4bbbd"><span data-ttu-id="be398-2017">&lt;аппдомаинресаурцемониторинг&gt; , элемент</span><span class="sxs-lookup"><span data-stu-id="be398-2017">&lt;appdomainResourceMonitoring&gt; Element</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringSurvivedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringSurvivedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringSurvivedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringSurvivedMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringSurvivedMemorySize : int64" Usage="System.AppDomain.MonitoringSurvivedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="be398-2018">Возвращает количество байтов, оставшихся после последнего сбора, и про которые известно, что на них ссылается текущий домен приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-2018">Gets the number of bytes that survived the last collection and that are known to be referenced by the current application domain.</span></span></summary>
        <value><span data-ttu-id="be398-2019">Количество оставшихся байтов.</span><span class="sxs-lookup"><span data-stu-id="be398-2019">The number of surviving bytes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-2020">Статистика обновляется при каждом сборе мусора.</span><span class="sxs-lookup"><span data-stu-id="be398-2020">The statistics are updated with each garbage collection.</span></span> <span data-ttu-id="be398-2021">Однако они гарантированно будут точными только после полной блокирующей коллекции. то есть коллекция, включающая все поколения и останавливающая работу приложения во время сбора.</span><span class="sxs-lookup"><span data-stu-id="be398-2021">However, they are guaranteed to be accurate only after a full, blocking collection; that is, a collection that includes all generations and that stops the application while collection occurs.</span></span> <span data-ttu-id="be398-2022">Например, <xref:System.GC.Collect?displayProperty=nameWithType> перегрузка метода выполняет полную блокированную коллекцию.</span><span class="sxs-lookup"><span data-stu-id="be398-2022">For example, the <xref:System.GC.Collect?displayProperty=nameWithType> method overload performs a full, blocking collection.</span></span> <span data-ttu-id="be398-2023">(Параллельная коллекция выполняется в фоновом режиме и не блокирует приложение.)</span><span class="sxs-lookup"><span data-stu-id="be398-2023">(Concurrent collection occurs in the background and does not block the application.)</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="be398-2024">Для свойства <see langword="static" /> (<see langword="Shared" /> в Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> задано значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="be398-2024">The <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> property is set to <see langword="false" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="be398-2025">Требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="be398-2025">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="be398-2026">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="be398-2026">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315"><span data-ttu-id="be398-2027">Отслеживание ресурсов домена приложения</span><span class="sxs-lookup"><span data-stu-id="be398-2027">Application Domain Resource Monitoring</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedProcessMemorySize">
      <MemberSignature Language="C#" Value="public static long MonitoringSurvivedProcessMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MonitoringSurvivedProcessMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long MonitoringSurvivedProcessMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringSurvivedProcessMemorySize : int64" Usage="System.AppDomain.MonitoringSurvivedProcessMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="be398-2028">Получает общее количество байтов, оставшихся после последнего сбора для всех доменов приложений в процессе.</span><span class="sxs-lookup"><span data-stu-id="be398-2028">Gets the total bytes that survived from the last collection for all application domains in the process.</span></span></summary>
        <value><span data-ttu-id="be398-2029">Общее количество оставшихся байтов для процесса.</span><span class="sxs-lookup"><span data-stu-id="be398-2029">The total number of surviving bytes for the process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-2030">После полной блокирующей коллекции это число представляет число байтов, которые в настоящий момент удерживаются в настоящее время в управляемых кучах.</span><span class="sxs-lookup"><span data-stu-id="be398-2030">After a full, blocking collection, this number represents the number of bytes currently held live on managed heaps.</span></span> <span data-ttu-id="be398-2031">Оно должно быть близко к числу, <xref:System.GC.GetTotalMemory%2A> сообщаемому методом.</span><span class="sxs-lookup"><span data-stu-id="be398-2031">It should be close to the number reported by the <xref:System.GC.GetTotalMemory%2A> method.</span></span> <span data-ttu-id="be398-2032">После эфемерной коллекции это число представляет число байтов, которые в настоящее время удерживаются в режиме эфемерного поколения.</span><span class="sxs-lookup"><span data-stu-id="be398-2032">After an ephemeral collection, this number represents the number of bytes currently held live in ephemeral generations.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="be398-2033">Для свойства <see langword="static" /> (<see langword="Shared" /> в Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> задано значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="be398-2033">The <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> property is set to <see langword="false" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="be398-2034">Требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="be398-2034">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="be398-2035">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="be398-2035">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315"><span data-ttu-id="be398-2036">Отслеживание ресурсов домена приложения</span><span class="sxs-lookup"><span data-stu-id="be398-2036">Application Domain Resource Monitoring</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalAllocatedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringTotalAllocatedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalAllocatedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringTotalAllocatedMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringTotalAllocatedMemorySize : int64" Usage="System.AppDomain.MonitoringTotalAllocatedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="be398-2037">Получает общий размер в байтах для всех операций выделения памяти, выполненных доменом приложения с момента его создания, без вычитания собранной памяти.</span><span class="sxs-lookup"><span data-stu-id="be398-2037">Gets the total size, in bytes, of all memory allocations that have been made by the application domain since it was created, without subtracting memory that has been collected.</span></span></summary>
        <value><span data-ttu-id="be398-2038">Общий размер для всех операций выделения памяти.</span><span class="sxs-lookup"><span data-stu-id="be398-2038">The total size of all memory allocations.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="be398-2039">Для свойства <see langword="static" /> (<see langword="Shared" /> в Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> задано значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="be398-2039">The <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> property is set to <see langword="false" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="be398-2040">Требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="be398-2040">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="be398-2041">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="be398-2041">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315"><span data-ttu-id="be398-2042">Отслеживание ресурсов домена приложения</span><span class="sxs-lookup"><span data-stu-id="be398-2042">Application Domain Resource Monitoring</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan MonitoringTotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MonitoringTotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MonitoringTotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringTotalProcessorTime : TimeSpan" Usage="System.AppDomain.MonitoringTotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="be398-2043">Получает общее процессорное время, использованное всеми потоками при выполнении в текущем домене приложения с момента запуска процесса.</span><span class="sxs-lookup"><span data-stu-id="be398-2043">Gets the total processor time that has been used by all threads while executing in the current application domain, since the process started.</span></span></summary>
        <value><span data-ttu-id="be398-2044">Общее процессорное время для текущего домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-2044">Total processor time for the current application domain.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-2045">Общее время, которое сообщается за доменом приложения, включает время, затраченное на выполнение каждого потока процесса в этом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-2045">The total time that is reported for an application domain includes the time each thread in the process spent executing in that application domain.</span></span>  
  
 <span data-ttu-id="be398-2046">Поток, который вызывает неуправляемый код, по-прежнему связан с доменом приложения, и время процессора, затраченное на выполнение неуправляемого кода, сообщается о домене приложения, в котором был сделан вызов.</span><span class="sxs-lookup"><span data-stu-id="be398-2046">A thread that calls into unmanaged code is still associated with an application domain, and the processor time spent executing the unmanaged code is reported for the application domain where the call was made.</span></span>  
  
 <span data-ttu-id="be398-2047">Если поток заблокирован или находится в режиме ожидания, он не потребляет процессорное время.</span><span class="sxs-lookup"><span data-stu-id="be398-2047">When a thread is blocked or sleeping, it does not consume processor time.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="be398-2048">Для свойства <see langword="static" /> (<see langword="Shared" /> в Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> задано значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="be398-2048">The <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> property is set to <see langword="false" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="be398-2049">Требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="be398-2049">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="be398-2050">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="be398-2050">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315"><span data-ttu-id="be398-2051">Отслеживание ресурсов домена приложения</span><span class="sxs-lookup"><span data-stu-id="be398-2051">Application Domain Resource Monitoring</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.PermissionSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::PermissionSet ^ PermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PermissionSet : System.Security.PermissionSet" Usage="System.AppDomain.PermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="be398-2052">Получает набор разрешений изолированного домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-2052">Gets the permission set of a sandboxed application domain.</span></span></summary>
        <value><span data-ttu-id="be398-2053">Набор разрешений изолированного домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-2053">The permission set of the sandboxed application domain.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-2054">Изолированные домены приложений, созданные с помощью <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> перегруженной версии метода, имеют однородный набор разрешений, то есть один и тот же набор разрешений предоставляется всем частично доверенным сборкам, загруженным в домен приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-2054">Sandboxed application domains that were created by using the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> method overload have a homogenous set of permissions; that is, the same set of permissions is granted to all partially trusted assemblies that are loaded into the application domain.</span></span> <span data-ttu-id="be398-2055">Домен изолированного приложения, при необходимости, имеет список сборок со строгими именами, которые исключены из этого набора разрешений, а выполняются с полным доверием.</span><span class="sxs-lookup"><span data-stu-id="be398-2055">A sandboxed application domain optionally has a list of strong-named assemblies that are exempt from this permission set, and instead run with full trust.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="be398-2056">Требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="be398-2056">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="be398-2057">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="be398-2057">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="P:System.AppDomain.IsHomogenous" />
      </Docs>
    </Member>
    <Member MemberName="ProcessExit">
      <MemberSignature Language="C#" Value="public event EventHandler ProcessExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ProcessExit" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ProcessExit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ProcessExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ ProcessExit;" />
      <MemberSignature Language="F#" Value="member this.ProcessExit : EventHandler " Usage="member this.ProcessExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ProcessExit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>remove: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="be398-2058">Происходит при завершении работы родительского процесса домена приложения по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="be398-2058">Occurs when the default application domain's parent process exits.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-2059"><xref:System.EventHandler> Для этого события можно выполнять завершающие действия, такие как закрытие файлов, освобождение хранилища и т. д. до завершения процесса.</span><span class="sxs-lookup"><span data-stu-id="be398-2059">The <xref:System.EventHandler> for this event can perform termination activities, such as closing files, releasing storage and so on, before the process ends.</span></span>  
  
 <span data-ttu-id="be398-2060">Начиная с версии .NET Framework 2,0, это событие возникает в каждом домене приложения, который регистрирует обработчик событий.</span><span class="sxs-lookup"><span data-stu-id="be398-2060">Beginning with the .NET Framework version 2.0, this event is raised in each application domain that registers an event handler.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="be398-2061">В .NET Framework общее время выполнения всех <xref:System.AppDomain.ProcessExit> обработчиков событий ограничено, так как общее время выполнения всех методов завершения ограничено при завершении процесса.</span><span class="sxs-lookup"><span data-stu-id="be398-2061">In .NET Framework, the total execution time of all <xref:System.AppDomain.ProcessExit> event handlers is limited, just as the total execution time of all finalizers is limited at process shutdown.</span></span> <span data-ttu-id="be398-2062">Значение по умолчанию — две секунды.</span><span class="sxs-lookup"><span data-stu-id="be398-2062">The default is two seconds.</span></span> <span data-ttu-id="be398-2063">Неуправляемый узел может изменить это время выполнения, вызвав метод [ICLRPolicyManager:: setTimeout](~/docs/framework/unmanaged-api/hosting/iclrpolicymanager-settimeout-method.md) со значением перечисления [OPR_ProcessExit](~/docs/framework/unmanaged-api/hosting/eclroperation-enumeration.md) .</span><span class="sxs-lookup"><span data-stu-id="be398-2063">An unmanaged host can change this execution time by calling the [ICLRPolicyManager::SetTimeout](~/docs/framework/unmanaged-api/hosting/iclrpolicymanager-settimeout-method.md) method with the [OPR_ProcessExit](~/docs/framework/unmanaged-api/hosting/eclroperation-enumeration.md) enumeration value.</span></span> <span data-ttu-id="be398-2064">Это ограничение времени не существует в .NET Core.</span><span class="sxs-lookup"><span data-stu-id="be398-2064">This time limit does not exist in .NET Core.</span></span>  
  
 <span data-ttu-id="be398-2065">В .NET Framework версиях 1,0 и 1,1 это событие возникает только в домене приложения по умолчанию и только в том случае, если обработчик событий зарегистрирован в домене приложения по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="be398-2065">In the .NET Framework versions 1.0 and 1.1, this event is raised only in the default application domain, and only if an event handler is registered in the default application domain.</span></span>  
  
 <span data-ttu-id="be398-2066">Чтобы зарегистрировать обработчик событий для этого события, необходимо иметь необходимые разрешения или <xref:System.Security.SecurityException> исключение.</span><span class="sxs-lookup"><span data-stu-id="be398-2066">To register an event handler for this event, you must have the required permissions, or a <xref:System.Security.SecurityException> is thrown.</span></span>  
  
 <span data-ttu-id="be398-2067">Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).</span><span class="sxs-lookup"><span data-stu-id="be398-2067">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyAssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ReflectionOnlyAssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReflectionOnlyAssemblyResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event ResolveEventHandler ^ ReflectionOnlyAssemblyResolve;" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnlyAssemblyResolve : ResolveEventHandler " Usage="member this.ReflectionOnlyAssemblyResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="be398-2068">Происходит, когда разрешение сборки завершается неудачей в контексте, поддерживающем только отражение.</span><span class="sxs-lookup"><span data-stu-id="be398-2068">Occurs when the resolution of an assembly fails in the reflection-only context.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-2069">В контексте, предназначенном только для отражения, зависимости не разрешаются автоматически.</span><span class="sxs-lookup"><span data-stu-id="be398-2069">In the reflection-only context, dependencies are not resolved automatically.</span></span> <span data-ttu-id="be398-2070">Они должны быть предварительно загружены или возвращены обработчиком для этого события.</span><span class="sxs-lookup"><span data-stu-id="be398-2070">They must be preloaded or returned by the handler for this event.</span></span> <span data-ttu-id="be398-2071">Это событие возникает, когда сборка имеет зависимость, которая еще не загружена в контекст, предназначенный только для отражения.</span><span class="sxs-lookup"><span data-stu-id="be398-2071">This event is raised when an assembly has a dependency that is not already loaded into the reflection-only context.</span></span> <span data-ttu-id="be398-2072">Отсутствующая зависимость задается <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> свойством.</span><span class="sxs-lookup"><span data-stu-id="be398-2072">The missing dependency is specified by the <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="be398-2073"><xref:System.ResolveEventHandler> Для этого события должно возвращаться сборка, которая удовлетворяет зависимости.</span><span class="sxs-lookup"><span data-stu-id="be398-2073">The <xref:System.ResolveEventHandler> for this event must return an assembly that satisfies the dependency.</span></span> <span data-ttu-id="be398-2074">Возвращаемая сборка должна быть загружена в контекст, предназначенный только для отражения.</span><span class="sxs-lookup"><span data-stu-id="be398-2074">The assembly that is returned must be loaded into the reflection-only context.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="be398-2075">Это событие возникает только для отсутствующих зависимостей сборки, которую вы загружаете в контекст только для отражения (например, с помощью <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> метода).</span><span class="sxs-lookup"><span data-stu-id="be398-2075">This event is raised only for missing dependencies of the assembly that you are loading into the reflection-only context (for example, by using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> method).</span></span> <span data-ttu-id="be398-2076">Если загружаемая сборка не найдена, она не вызывается.</span><span class="sxs-lookup"><span data-stu-id="be398-2076">It is not raised if the assembly that you are loading cannot be found.</span></span>  
  
 <span data-ttu-id="be398-2077">Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> , свойство возвращает сборку, которая запросила загрузку сборки, которую не удалось разрешить.</span><span class="sxs-lookup"><span data-stu-id="be398-2077">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> property returns the assembly that requested the assembly load that could not be resolved.</span></span> <span data-ttu-id="be398-2078">Знание идентификации запрашивающей сборки может быть полезно при определении правильной версии зависимости, если доступна более чем одна версия.</span><span class="sxs-lookup"><span data-stu-id="be398-2078">Knowing the identity of the requesting assembly might be useful in identifying the correct version of the dependency, if more than one version is available.</span></span> <span data-ttu-id="be398-2079">Для получения дополнительной информации см. <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="be398-2079">For more information, see <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="be398-2080">Для этого события <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> свойство возвращает имя сборки перед применением политики.</span><span class="sxs-lookup"><span data-stu-id="be398-2080">For this event, the <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> property returns the assembly name before policy is applied.</span></span>  
  
 <span data-ttu-id="be398-2081">Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).</span><span class="sxs-lookup"><span data-stu-id="be398-2081">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="be398-2082">требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="be398-2082">requires full trust for the immediate caller.</span></span> <span data-ttu-id="be398-2083">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="be398-2083">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] ReflectionOnlyGetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly[] ReflectionOnlyGetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ReflectionOnlyGetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function ReflectionOnlyGetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Assembly ^&gt; ^ ReflectionOnlyGetAssemblies();" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnlyGetAssemblies : unit -&gt; System.Reflection.Assembly[]" Usage="appDomain.ReflectionOnlyGetAssemblies " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="be398-2084">Возвращает сборки, которые были загружены в контекст, поддерживающий только отражение домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-2084">Returns the assemblies that have been loaded into the reflection-only context of the application domain.</span></span></summary>
        <returns><span data-ttu-id="be398-2085">Массив объектов <see cref="T:System.Reflection.Assembly" />, представляющих сборки, которые были загружены в контекст домена приложения, поддерживающий только отражение.</span><span class="sxs-lookup"><span data-stu-id="be398-2085">An array of <see cref="T:System.Reflection.Assembly" /> objects that represent the assemblies loaded into the reflection-only context of the application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-2086">Этот метод возвращает сборки, которые были загружены в контекст, предназначенный только для отражения.</span><span class="sxs-lookup"><span data-stu-id="be398-2086">This method returns the assemblies that have been loaded into the reflection-only context.</span></span> <span data-ttu-id="be398-2087">Чтобы получить сборки, которые были загружены для выполнения, используйте <xref:System.AppDomain.GetAssemblies%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="be398-2087">To get the assemblies that have been loaded for execution, use the <xref:System.AppDomain.GetAssemblies%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-2088">В следующем примере кода сборка System. dll загружается в контекст выполнения, а затем в контекст, предназначенный только для отражения.</span><span class="sxs-lookup"><span data-stu-id="be398-2088">The following code example loads the System.dll assembly into the execution context and then into the reflection-only context.</span></span> <span data-ttu-id="be398-2089">Методы <xref:System.AppDomain.GetAssemblies%2A> и <xref:System.AppDomain.ReflectionOnlyGetAssemblies%2A>  используются для вывода сборок, загруженных в каждый контекст.</span><span class="sxs-lookup"><span data-stu-id="be398-2089">The <xref:System.AppDomain.GetAssemblies%2A> and <xref:System.AppDomain.ReflectionOnlyGetAssemblies%2A> methods are used to display the assemblies loaded into each context.</span></span>  
  
 [!code-cpp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CPP/reflectiononly.cpp#1)]
 [!code-csharp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CS/reflectiononly.cs#1)]
 [!code-vb[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/VB/reflectiononly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-2090">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-2090">An operation is attempted on an unloaded application domain.</span></span></exception>
        <altmember cref="M:System.AppDomain.GetAssemblies" />
      </Docs>
    </Member>
    <Member MemberName="RelativeSearchPath">
      <MemberSignature Language="C#" Value="public string RelativeSearchPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RelativeSearchPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.RelativeSearchPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RelativeSearchPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RelativeSearchPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RelativeSearchPath : string" Usage="System.AppDomain.RelativeSearchPath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.RelativeSearchPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="be398-2091">Возвращает путь, к каталогу, находящемуся в базовом каталоге, где распознаватель сборок будет производить поиск закрытых сборок.</span><span class="sxs-lookup"><span data-stu-id="be398-2091">Gets the path under the base directory where the assembly resolver should probe for private assemblies.</span></span></summary>
        <value><span data-ttu-id="be398-2092">Путь, к каталогу, находящемуся в базовом каталоге, где распознаватель сборок будет производить поиск закрытых сборок.</span><span class="sxs-lookup"><span data-stu-id="be398-2092">The path under the base directory where the assembly resolver should probe for private assemblies.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-2093">Закрытые сборки развертываются в той же структуре каталогов, что и приложение.</span><span class="sxs-lookup"><span data-stu-id="be398-2093">Private assemblies are deployed in the same directory structure as the application.</span></span> <span data-ttu-id="be398-2094">Если путь <xref:System.AppDomain.RelativeSearchPath%2A> <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>, указанный свойством, не является недопустимым, он игнорируется.</span><span class="sxs-lookup"><span data-stu-id="be398-2094">If the path specified by the <xref:System.AppDomain.RelativeSearchPath%2A> property is not under <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>, it is ignored.</span></span>  
  
 <span data-ttu-id="be398-2095">Это свойство возвращает значение, заданное <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>с помощью.</span><span class="sxs-lookup"><span data-stu-id="be398-2095">This property returns the value set using <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-2096">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-2096">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="be398-2097">для доступа к сведениям о пути.</span><span class="sxs-lookup"><span data-stu-id="be398-2097">for access to the path information.</span></span> <span data-ttu-id="be398-2098">Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="be398-2098">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <altmember cref="P:System.AppDomainSetup.PrivateBinPath" />
      </Docs>
    </Member>
    <Member MemberName="ResourceResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ResourceResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ResourceResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ResourceResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResourceResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ ResourceResolve;" />
      <MemberSignature Language="F#" Value="member this.ResourceResolve : ResolveEventHandler " Usage="member this.ResourceResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ResourceResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="be398-2099">происходит, когда разрешение ресурса завершается неудачей, из-за того, что он не является допустимым связанным или внедренным ресурсом в сборке.</span><span class="sxs-lookup"><span data-stu-id="be398-2099">Occurs when the resolution of a resource fails because the resource is not a valid linked or embedded resource in the assembly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-2100"><xref:System.ResolveEventHandler> Для этого события можно попытаться выбрать сборку, содержащую ресурс, и вернуть ее.</span><span class="sxs-lookup"><span data-stu-id="be398-2100">The <xref:System.ResolveEventHandler> for this event can attempt to locate the assembly containing the resource and return it.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="be398-2101">Это событие не возникает, если разрешение завершается неудачей, так как не удается найти файл для допустимого связанного ресурса.</span><span class="sxs-lookup"><span data-stu-id="be398-2101">This event is not raised if resolution fails because no file can be found for a valid linked resource.</span></span> <span data-ttu-id="be398-2102">Он вызывается, если не удается найти поток ресурсов манифеста, но он не вызывается, если не удается найти отдельный ключ ресурса.</span><span class="sxs-lookup"><span data-stu-id="be398-2102">It is raised if a manifest resource stream cannot be found, but it is not raised if an individual resource key cannot be found.</span></span>  
  
 <span data-ttu-id="be398-2103">Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> , свойство содержит сборку, которая запросила ресурс.</span><span class="sxs-lookup"><span data-stu-id="be398-2103">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> property contains the assembly that requested the resource.</span></span> <span data-ttu-id="be398-2104">Для получения дополнительной информации см. <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="be398-2104">For more information, see <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="be398-2105">Чтобы зарегистрировать обработчик событий для этого события, необходимо иметь необходимые разрешения или <xref:System.Security.SecurityException> исключение.</span><span class="sxs-lookup"><span data-stu-id="be398-2105">To register an event handler for this event, you must have the required permissions, or a <xref:System.Security.SecurityException> is thrown.</span></span>  
  
 <span data-ttu-id="be398-2106">Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).</span><span class="sxs-lookup"><span data-stu-id="be398-2106">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="be398-2107">требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="be398-2107">requires full trust for the immediate caller.</span></span> <span data-ttu-id="be398-2108">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="be398-2108">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="SetAppDomainPolicy">
      <MemberSignature Language="C#" Value="public void SetAppDomainPolicy (System.Security.Policy.PolicyLevel domainPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAppDomainPolicy(class System.Security.Policy.PolicyLevel domainPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAppDomainPolicy (domainPolicy As PolicyLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAppDomainPolicy(System::Security::Policy::PolicyLevel ^ domainPolicy);" />
      <MemberSignature Language="F#" Value="member this.SetAppDomainPolicy : System.Security.Policy.PolicyLevel -&gt; unit" Usage="appDomain.SetAppDomainPolicy domainPolicy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domainPolicy" Type="System.Security.Policy.PolicyLevel" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="domainPolicy"><span data-ttu-id="be398-2109">Уровень политики безопасности.</span><span class="sxs-lookup"><span data-stu-id="be398-2109">The security policy level.</span></span></param>
        <summary><span data-ttu-id="be398-2110">Устанавливает уровень политики безопасности для этого домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-2110">Establishes the security policy level for this application domain.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-2111">Вызывайте этот метод перед загрузкой сборки в <xref:System.AppDomain> , чтобы политика безопасности действовала.</span><span class="sxs-lookup"><span data-stu-id="be398-2111">Call this method before an assembly is loaded into the <xref:System.AppDomain> in order for the security policy to have effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-2112">В следующем примере демонстрируется использование <xref:System.AppDomain.SetAppDomainPolicy%2A> метода для задания уровня политики безопасности домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-2112">The following example demonstrates how to use the <xref:System.AppDomain.SetAppDomainPolicy%2A> method to set the security policy level of an application domain.</span></span>  
  
 [!code-cpp[ADSetAppDomainPolicy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetAppDomainPolicy/CPP/adsetappdomainpolicy.cpp#1)]
 [!code-csharp[ADSetAppDomainPolicy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetAppDomainPolicy/CS/adsetappdomainpolicy.cs#1)]
 [!code-vb[ADSetAppDomainPolicy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetAppDomainPolicy/VB/adsetappdomainpolicy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-2113">Свойство <paramref name="domainPolicy" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-2113"><paramref name="domainPolicy" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Security.Policy.PolicyException"><span data-ttu-id="be398-2114">Установленный уровень политики безопасности.</span><span class="sxs-lookup"><span data-stu-id="be398-2114">The security policy level has already been set.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-2115">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-2115">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="be398-2116">требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="be398-2116">requires full trust for the immediate caller.</span></span> <span data-ttu-id="be398-2117">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="be398-2117">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SetCachePath">
      <MemberSignature Language="C#" Value="public void SetCachePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetCachePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetCachePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCachePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetCachePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member SetCachePath : string -&gt; unit&#xA;override this.SetCachePath : string -&gt; unit" Usage="appDomain.SetCachePath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetCachePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.SetCachePath")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.SetCachePath has been deprecated. Please investigate the use of AppDomainSetup.CachePath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("AppDomain.SetCachePath has been deprecated. Please investigate the use of AppDomainSetup.CachePath instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="be398-2118">Полный путь к расположению теневых копий.</span><span class="sxs-lookup"><span data-stu-id="be398-2118">The fully qualified path to the shadow copy location.</span></span></param>
        <summary><span data-ttu-id="be398-2119">Устанавливает заданный путь каталога в качестве места, куда копируются теневые сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-2119">Establishes the specified directory path as the location where assemblies are shadow copied.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-2120">Если <xref:System.AppDomainSetup.ApplicationName%2A> свойство не задано, путь кэша пропускается.</span><span class="sxs-lookup"><span data-stu-id="be398-2120">The cache path is ignored if the <xref:System.AppDomainSetup.ApplicationName%2A> property is not set.</span></span> <span data-ttu-id="be398-2121">См. свойство <xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="be398-2121">See the <xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="be398-2122">Дополнительные сведения о теневом копировании см. в разделе [теневое копирование сборок](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span><span class="sxs-lookup"><span data-stu-id="be398-2122">For more information on shadow copying see [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-2123">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-2123">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="be398-2124">требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="be398-2124">requires full trust for the immediate caller.</span></span> <span data-ttu-id="be398-2125">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="be398-2125">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md"><span data-ttu-id="be398-2126">Теневое копирование сборок</span><span class="sxs-lookup"><span data-stu-id="be398-2126">Shadow Copying Assemblies</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetData">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="be398-2127">Присваивает значение свойству домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-2127">Assigns a value to an application domain property.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetData(string name, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetData(System::String ^ name, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="abstract member SetData : string * obj -&gt; unit&#xA;override this.SetData : string * obj -&gt; unit" Usage="appDomain.SetData (name, data)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetData(System.String,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="be398-2128">Имя пользовательского свойства домена приложения для создания или изменения.</span><span class="sxs-lookup"><span data-stu-id="be398-2128">The name of a user-defined application domain property to create or change.</span></span></param>
        <param name="data"><span data-ttu-id="be398-2129">Значение свойства.</span><span class="sxs-lookup"><span data-stu-id="be398-2129">The value of the property.</span></span></param>
        <summary><span data-ttu-id="be398-2130">Устанавливает заданное значение для свойства указанного домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-2130">Assigns the specified value to the specified application domain property.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-2131">Этот метод используется для вставки записи или изменения значения записи во внутреннем кэше пар имя-данные, описывающих свойства этого экземпляра <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="be398-2131">Use this method to insert an entry, or modify the value of an entry in an internal cache of name-data pairs that describe properties of this instance of <xref:System.AppDomain>.</span></span>  
  
 <span data-ttu-id="be398-2132">Кэш автоматически содержит стандартные системные записи, которые вставляются при создании домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-2132">The cache automatically contains predefined system entries that are inserted when the application domain is created.</span></span> <span data-ttu-id="be398-2133">Нельзя вставлять или изменять системные записи с помощью этого метода.</span><span class="sxs-lookup"><span data-stu-id="be398-2133">You cannot insert or modify system entries with this method.</span></span> <span data-ttu-id="be398-2134">Вызов метода, который пытается изменить системную запись, не имеет результата; метод не создает исключение.</span><span class="sxs-lookup"><span data-stu-id="be398-2134">A method call that attempts to modify a system entry has no effect; the method does not throw an exception.</span></span> <span data-ttu-id="be398-2135">Можно проверить значения системных записей с помощью <xref:System.AppDomain.GetData%2A> метода или эквивалентных <xref:System.AppDomainSetup> свойств, описанных в разделе <xref:System.AppDomain.GetData%2A>.</span><span class="sxs-lookup"><span data-stu-id="be398-2135">You can inspect the values of system entries with the <xref:System.AppDomain.GetData%2A> method, or the equivalent <xref:System.AppDomainSetup> properties described in <xref:System.AppDomain.GetData%2A>.</span></span>  
  
 <span data-ttu-id="be398-2136">Этот метод можно вызвать, чтобы задать значение интервала времени ожидания по умолчанию для оценки шаблонов регулярных выражений, указав "REGEX_DEFAULT_MATCH_TIMEOUT" в качестве значения `name` аргумента <xref:System.TimeSpan> и значение, представляющее время ожидания. интервал в качестве значения `data` аргумента.</span><span class="sxs-lookup"><span data-stu-id="be398-2136">You can call this method to set the value of the default timeout interval for evaluating regular expression patterns by supply "REGEX_DEFAULT_MATCH_TIMEOUT" as the value of the `name` argument and a <xref:System.TimeSpan> value that represents the timeout interval as the value of the `data` argument.</span></span> <span data-ttu-id="be398-2137">Можно также вставить или изменить пользовательские пары имя-данные с помощью этого метода и проверить их значения с помощью <xref:System.AppDomain.GetData%2A> метода.</span><span class="sxs-lookup"><span data-stu-id="be398-2137">You can also insert or modify your own user defined name-data pairs with this method and inspect their values with the <xref:System.AppDomain.GetData%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-2138">В следующем примере показано, как использовать <xref:System.AppDomain.SetData%28System.String%2CSystem.Object%29> метод для создания новой пары значений.</span><span class="sxs-lookup"><span data-stu-id="be398-2138">The following example demonstrates how to use the <xref:System.AppDomain.SetData%28System.String%2CSystem.Object%29> method to create a new value pair.</span></span> <span data-ttu-id="be398-2139">Затем в примере используется <xref:System.AppDomain.GetData%2A> метод для получения значения и его отображения в консоли.</span><span class="sxs-lookup"><span data-stu-id="be398-2139">The example then uses the <xref:System.AppDomain.GetData%2A> method to retrieve the value, and displays it to the console.</span></span>  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-2140">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-2140">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="be398-2141">требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="be398-2141">requires full trust for the immediate caller.</span></span> <span data-ttu-id="be398-2142">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="be398-2142">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.AppDomain.GetData(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data, System.Security.IPermission permission);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetData(string name, object data, class System.Security.IPermission permission) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object, permission As IPermission)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetData(System::String ^ name, System::Object ^ data, System::Security::IPermission ^ permission);" />
      <MemberSignature Language="F#" Value="member this.SetData : string * obj * System.Security.IPermission -&gt; unit" Usage="appDomain.SetData (name, data, permission)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="data" Type="System.Object" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="permission" Type="System.Security.IPermission" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="be398-2143">Имя пользовательского свойства домена приложения, которое требуется создать или изменить.</span><span class="sxs-lookup"><span data-stu-id="be398-2143">The name of a user-defined application domain property to create or change.</span></span></param>
        <param name="data"><span data-ttu-id="be398-2144">Значение свойства.</span><span class="sxs-lookup"><span data-stu-id="be398-2144">The value of the property.</span></span></param>
        <param name="permission"><span data-ttu-id="be398-2145">Разрешение, которое нужно запросить у вызывающего кода при извлечении свойства.</span><span class="sxs-lookup"><span data-stu-id="be398-2145">The permission to demand of the caller when the property is retrieved.</span></span></param>
        <summary><span data-ttu-id="be398-2146">Присваивает заданное значение заданному свойству домена приложения с заданными разрешениями, которые нужно запросить у вызывающего кода при извлечении свойства.</span><span class="sxs-lookup"><span data-stu-id="be398-2146">Assigns the specified value to the specified application domain property, with a specified permission to demand of the caller when the property is retrieved.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-2147">Этот метод используется для вставки или изменения собственных пользовательских записей во внутреннем кэше пар имен и данных, описывающих свойства домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-2147">Use this method to insert or modify your own user-defined entries in an internal cache of name/data pairs that describe properties of the application domain.</span></span> <span data-ttu-id="be398-2148">При вставке записи можно указать требование разрешения, которое будет применяться при извлечении записи. Кроме того, можно вызвать этот метод, чтобы задать значение интервала времени ожидания по умолчанию для оценки шаблонов регулярных выражений, указав "REGEX_DEFAULT_MATCH_TIMEOUT" в качестве значения `name` аргумента <xref:System.TimeSpan> и значение, представляющее интервал времени ожидания в качестве значения `data` аргумента.</span><span class="sxs-lookup"><span data-stu-id="be398-2148">When you insert an entry, you can specify a permission demand to enforce when the entry is retrieved.In addition, you can call this method to set the value of the default timeout interval for evaluating regular expression patterns by supply "REGEX_DEFAULT_MATCH_TIMEOUT" as the value of the `name` argument and a <xref:System.TimeSpan> value that represents the timeout interval as the value of the `data` argument.</span></span>  
  
 <span data-ttu-id="be398-2149">Этот метод нельзя использовать для назначения запроса безопасности строке свойства, определяемой системой.</span><span class="sxs-lookup"><span data-stu-id="be398-2149">You cannot use this method to assign a security demand to a system-defined property string.</span></span>  
  
 <span data-ttu-id="be398-2150">Кэш автоматически содержит стандартные системные записи, которые вставляются при создании домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-2150">The cache automatically contains predefined system entries that are inserted when the application domain is created.</span></span> <span data-ttu-id="be398-2151">Нельзя вставлять или изменять системные записи с помощью этого метода.</span><span class="sxs-lookup"><span data-stu-id="be398-2151">You cannot insert or modify system entries with this method.</span></span> <span data-ttu-id="be398-2152">Вызов метода, который пытается изменить системную запись, не имеет результата; метод не создает исключение.</span><span class="sxs-lookup"><span data-stu-id="be398-2152">A method call that attempts to modify a system entry has no effect; the method does not throw an exception.</span></span> <span data-ttu-id="be398-2153">Значения системных записей можно проверить с помощью <xref:System.AppDomain.GetData%2A> метода или эквивалентных <xref:System.AppDomainSetup> свойств, описанных в разделе "Примечания" для <xref:System.AppDomain.GetData%2A> метода.</span><span class="sxs-lookup"><span data-stu-id="be398-2153">You can inspect the values of system entries with the <xref:System.AppDomain.GetData%2A> method or the equivalent <xref:System.AppDomainSetup> properties described in the Remarks section for the <xref:System.AppDomain.GetData%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-2154">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-2154"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="be398-2155"><paramref name="name" /> задает определяемую системой строку свойства, и <paramref name="permission" /> не равно <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-2155"><paramref name="name" /> specifies a system-defined property string and <paramref name="permission" /> is not <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="be398-2156">требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="be398-2156">requires full trust for the immediate caller.</span></span> <span data-ttu-id="be398-2157">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="be398-2157">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SetDynamicBase">
      <MemberSignature Language="C#" Value="public void SetDynamicBase (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDynamicBase(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetDynamicBase(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetDynamicBase (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetDynamicBase(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetDynamicBase : string -&gt; unit" Usage="appDomain.SetDynamicBase path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.DynamicBase")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.SetDynamicBase has been deprecated. Please investigate the use of AppDomainSetup.DynamicBase instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("AppDomain.SetDynamicBase has been deprecated. Please investigate the use of AppDomainSetup.DynamicBase instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="be398-2158">Полный путь, который является базовым каталогом для подкаталогов, в которых хранятся динамические сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-2158">The fully qualified path that is the base directory for subdirectories where dynamic assemblies are stored.</span></span></param>
        <summary><span data-ttu-id="be398-2159">Устанавливает заданный путь каталога в качестве базового каталога для подкаталогов, в которых сохраняются и становятся доступными динамически созданные файлы.</span><span class="sxs-lookup"><span data-stu-id="be398-2159">Establishes the specified directory path as the base directory for subdirectories where dynamically generated files are stored and accessed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-2160">Этот метод задает <xref:System.AppDomainSetup.DynamicBase%2A> свойство внутреннего <xref:System.AppDomainSetup> объекта, связанного с данным экземпляром.</span><span class="sxs-lookup"><span data-stu-id="be398-2160">This method sets the <xref:System.AppDomainSetup.DynamicBase%2A> property of the internal <xref:System.AppDomainSetup> associated with this instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-2161">Теперь этот метод устарел и не должен использоваться для новой разработки.</span><span class="sxs-lookup"><span data-stu-id="be398-2161">This method is now obsolete, and should not be used for new development.</span></span> <span data-ttu-id="be398-2162">В следующем примере показано, как использовать неустаревшую альтернативу, <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> свойство.</span><span class="sxs-lookup"><span data-stu-id="be398-2162">The following example shows how to use the non-obsolete alternative, the <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="be398-2163">Описание этого примера см. в <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> описании свойства <xref:System.AppDomain.DynamicDirectory%2A> или свойства.</span><span class="sxs-lookup"><span data-stu-id="be398-2163">For an explanation of this example, see the <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> property or the <xref:System.AppDomain.DynamicDirectory%2A> property.</span></span>  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-2164">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-2164">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="be398-2165">требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="be398-2165">requires full trust for the immediate caller.</span></span> <span data-ttu-id="be398-2166">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="be398-2166">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="P:System.AppDomainSetup.DynamicBase" />
      </Docs>
    </Member>
    <Member MemberName="SetPrincipalPolicy">
      <MemberSignature Language="C#" Value="public void SetPrincipalPolicy (System.Security.Principal.PrincipalPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPrincipalPolicy(valuetype System.Security.Principal.PrincipalPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPrincipalPolicy (policy As PrincipalPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPrincipalPolicy(System::Security::Principal::PrincipalPolicy policy);" />
      <MemberSignature Language="F#" Value="member this.SetPrincipalPolicy : System.Security.Principal.PrincipalPolicy -&gt; unit" Usage="appDomain.SetPrincipalPolicy policy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Principal.PrincipalPolicy" />
      </Parameters>
      <Docs>
        <param name="policy"><span data-ttu-id="be398-2167">Одно из значений <see cref="T:System.Security.Principal.PrincipalPolicy" />, определяющее тип объекта-участника, который необходимо подключить к потоку.</span><span class="sxs-lookup"><span data-stu-id="be398-2167">One of the <see cref="T:System.Security.Principal.PrincipalPolicy" /> values that specifies the type of the principal object to attach to threads.</span></span></param>
        <summary><span data-ttu-id="be398-2168">Указывает, как участники и объекты удостоверений должны присоединяться к потоку, если поток пытается выполнить привязку к участнику при выполнении в этом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-2168">Specifies how principal and identity objects should be attached to a thread if the thread attempts to bind to a principal while executing in this application domain.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-2169">Установка этого значения будет действовать только в <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> том случае, если она задана перед использованием свойства.</span><span class="sxs-lookup"><span data-stu-id="be398-2169">Setting this value will only be effective if you set it before using the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="be398-2170"><xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> Например, если задать для данного участника (например, универсальный субъект), а затем <xref:System.AppDomain.SetPrincipalPolicy%2A> использовать <xref:System.Security.Principal.PrincipalPolicy.WindowsPrincipal>метод для установки значения <xref:System.Security.Principal.PrincipalPolicy> , текущий участник останется универсальным.</span><span class="sxs-lookup"><span data-stu-id="be398-2170">For example, if you set <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> to a given principal (for example, a generic principal) and then use the <xref:System.AppDomain.SetPrincipalPolicy%2A> method to set the <xref:System.Security.Principal.PrincipalPolicy> to <xref:System.Security.Principal.PrincipalPolicy.WindowsPrincipal>, the current principal will remain the generic principal.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-2171">В следующем примере показано воздействие на потоки с использованием <xref:System.AppDomain.SetPrincipalPolicy%2A> метода для изменения основной политики домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-2171">The following example shows the effect on threads of using the <xref:System.AppDomain.SetPrincipalPolicy%2A> method to change the principal policy of the application domain.</span></span> <span data-ttu-id="be398-2172">Он также показывает результат использования <xref:System.AppDomain.SetThreadPrincipal%2A> метода для изменения субъекта, доступного для присоединения к потокам в домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-2172">It also shows the effect of using the <xref:System.AppDomain.SetThreadPrincipal%2A> method to change the principal that is available for attaching to threads in the application domain.</span></span>  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-2173">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-2173">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="be398-2174">для возможности управления объектом Principal.</span><span class="sxs-lookup"><span data-stu-id="be398-2174">for ability to manipulate the principal object.</span></span> <span data-ttu-id="be398-2175">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</span><span class="sxs-lookup"><span data-stu-id="be398-2175">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</span></span> <span data-ttu-id="be398-2176">Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span><span class="sxs-lookup"><span data-stu-id="be398-2176">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyFiles">
      <MemberSignature Language="C#" Value="public void SetShadowCopyFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetShadowCopyFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyFiles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetShadowCopyFiles();" />
      <MemberSignature Language="F#" Value="member this.SetShadowCopyFiles : unit -&gt; unit" Usage="appDomain.SetShadowCopyFiles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyFiles")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyFiles has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyFiles instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyFiles has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyFiles instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="be398-2177">Включает теневое копирование.</span><span class="sxs-lookup"><span data-stu-id="be398-2177">Turns on shadow copying.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-2178">Дополнительные сведения о теневом копировании см. в разделе [теневое копирование сборок](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span><span class="sxs-lookup"><span data-stu-id="be398-2178">For more information on shadow copying, see [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-2179">Теперь этот метод устарел и не должен использоваться для новой разработки.</span><span class="sxs-lookup"><span data-stu-id="be398-2179">This method is now obsolete, and should not be used for new development.</span></span>  
  
 [!code-cpp[adproperties#1](~/samples/snippets/cpp/VS_Snippets_CLR/adproperties/CPP/adproperties.cpp#1)]
 [!code-csharp[adproperties#1](~/samples/snippets/csharp/VS_Snippets_CLR/adproperties/CS/adproperties.cs#1)]
 [!code-vb[adproperties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/adproperties/VB/adproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-2180">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-2180">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="be398-2181">требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="be398-2181">requires full trust for the immediate caller.</span></span> <span data-ttu-id="be398-2182">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="be398-2182">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md"><span data-ttu-id="be398-2183">Теневое копирование сборок</span><span class="sxs-lookup"><span data-stu-id="be398-2183">Shadow Copying Assemblies</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyPath">
      <MemberSignature Language="C#" Value="public void SetShadowCopyPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetShadowCopyPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyPath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetShadowCopyPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member SetShadowCopyPath : string -&gt; unit&#xA;override this.SetShadowCopyPath : string -&gt; unit" Usage="appDomain.SetShadowCopyPath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetShadowCopyPath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="be398-2184">Список имен каталогов, разделенных знаком точки с запятой.</span><span class="sxs-lookup"><span data-stu-id="be398-2184">A list of directory names, where each name is separated by a semicolon.</span></span></param>
        <summary><span data-ttu-id="be398-2185">Устанавливает заданный путь каталога в качестве места для теневого копирования сборок.</span><span class="sxs-lookup"><span data-stu-id="be398-2185">Establishes the specified directory path as the location of assemblies to be shadow copied.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-2186">По умолчанию теневая копия включает все сборки, найденные с помощью зондирования.</span><span class="sxs-lookup"><span data-stu-id="be398-2186">By default, a shadow copy includes all assemblies found through probing.</span></span> <span data-ttu-id="be398-2187">Метод разрешает теневое копирование сборок в каталогах, заданных параметром  `path` .  <xref:System.AppDomain.SetShadowCopyPath%2A></span><span class="sxs-lookup"><span data-stu-id="be398-2187">The <xref:System.AppDomain.SetShadowCopyPath%2A> method restricts the shadow copy to the assemblies in the directories specified by `path`.</span></span>  
  
 <span data-ttu-id="be398-2188"><xref:System.AppDomain.SetShadowCopyPath%2A> Метод не указывает дополнительные каталоги для поиска сборок.</span><span class="sxs-lookup"><span data-stu-id="be398-2188">The <xref:System.AppDomain.SetShadowCopyPath%2A> method does not specify additional directories to be searched for assemblies.</span></span> <span data-ttu-id="be398-2189">Сборки, предназначенные для теневого копирования, должны уже находиться в пути поиска, например в <xref:System.AppDomain.BaseDirectory%2A>разделе.</span><span class="sxs-lookup"><span data-stu-id="be398-2189">Assemblies to be shadow-copied must already be located in the search path, for example under <xref:System.AppDomain.BaseDirectory%2A>.</span></span> <span data-ttu-id="be398-2190"><xref:System.AppDomain.SetShadowCopyPath%2A> Метод указывает, какие пути поиска могут быть скопированы при теневом копировании.</span><span class="sxs-lookup"><span data-stu-id="be398-2190">The <xref:System.AppDomain.SetShadowCopyPath%2A> method specifies which search paths are eligible to be shadow-copied.</span></span>  
  
 <span data-ttu-id="be398-2191">Этот метод задает <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> свойство внутреннего <xref:System.AppDomainSetup> объекта, связанного с данным экземпляром.</span><span class="sxs-lookup"><span data-stu-id="be398-2191">This method sets the <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> property of the internal <xref:System.AppDomainSetup> associated with this instance.</span></span>  
  
 <span data-ttu-id="be398-2192">Дополнительные сведения о теневом копировании см. в разделе [теневое копирование сборок](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span><span class="sxs-lookup"><span data-stu-id="be398-2192">For more information on shadow copying, see [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-2193">Теперь этот метод устарел и не должен использоваться для новой разработки.</span><span class="sxs-lookup"><span data-stu-id="be398-2193">This method is now obsolete, and should not be used for new development.</span></span>  
  
 [!code-cpp[ADShadowCopy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADShadowCopy/CPP/adshadowcopy.cpp#1)]
 [!code-csharp[ADShadowCopy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADShadowCopy/CS/adshadowcopy.cs#1)]
 [!code-vb[ADShadowCopy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADShadowCopy/VB/adshadowcopy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-2194">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-2194">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="be398-2195">требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="be398-2195">requires full trust for the immediate caller.</span></span> <span data-ttu-id="be398-2196">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="be398-2196">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md"><span data-ttu-id="be398-2197">Теневое копирование сборок</span><span class="sxs-lookup"><span data-stu-id="be398-2197">Shadow Copying Assemblies</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetThreadPrincipal">
      <MemberSignature Language="C#" Value="public void SetThreadPrincipal (System.Security.Principal.IPrincipal principal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetThreadPrincipal(class System.Security.Principal.IPrincipal principal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetThreadPrincipal (principal As IPrincipal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetThreadPrincipal(System::Security::Principal::IPrincipal ^ principal);" />
      <MemberSignature Language="F#" Value="member this.SetThreadPrincipal : System.Security.Principal.IPrincipal -&gt; unit" Usage="appDomain.SetThreadPrincipal principal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Principal.IPrincipal" />
      </Parameters>
      <Docs>
        <param name="principal"><span data-ttu-id="be398-2198">Объект-участник, который необходимо присоединить к потоку.</span><span class="sxs-lookup"><span data-stu-id="be398-2198">The principal object to attach to threads.</span></span></param>
        <summary><span data-ttu-id="be398-2199">Задает объект-участник по умолчанию, который необходимо присоединять к потокам, в случае если они пытаются выполнить привязку к объекту-участнику во время выполнения в этом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-2199">Sets the default principal object to be attached to threads if they attempt to bind to a principal while executing in this application domain.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="be398-2200">В следующем примере показан результат использования <xref:System.AppDomain.SetThreadPrincipal%2A> метода для изменения субъекта, доступного для присоединения к потокам, которые выполняются в домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-2200">The following example shows the effect of using the <xref:System.AppDomain.SetThreadPrincipal%2A> method to change the principal that is available for attaching to threads that are executing in the application domain.</span></span> <span data-ttu-id="be398-2201">Он также показывает воздействие на потоки с использованием <xref:System.AppDomain.SetPrincipalPolicy%2A> метода для изменения основной политики домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-2201">It also shows the effect on threads of using the <xref:System.AppDomain.SetPrincipalPolicy%2A> method to change the principal policy of the application domain.</span></span>  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-2202">Свойство <paramref name="principal" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-2202"><paramref name="principal" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Security.Policy.PolicyException"><span data-ttu-id="be398-2203">Установленный объект-участник потока.</span><span class="sxs-lookup"><span data-stu-id="be398-2203">The thread principal has already been set.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-2204">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-2204">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="be398-2205">для возможности управления объектом Principal.</span><span class="sxs-lookup"><span data-stu-id="be398-2205">for ability to manipulate the principal object.</span></span> <span data-ttu-id="be398-2206">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</span><span class="sxs-lookup"><span data-stu-id="be398-2206">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</span></span> <span data-ttu-id="be398-2207">Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span><span class="sxs-lookup"><span data-stu-id="be398-2207">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SetupInformation">
      <MemberSignature Language="C#" Value="public AppDomainSetup SetupInformation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainSetup SetupInformation" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.SetupInformation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SetupInformation As AppDomainSetup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainSetup ^ SetupInformation { AppDomainSetup ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SetupInformation : AppDomainSetup" Usage="System.AppDomain.SetupInformation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainSetup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="be398-2208">Возвращает сведения о конфигурации домена приложения для этого экземпляра.</span><span class="sxs-lookup"><span data-stu-id="be398-2208">Gets the application domain configuration information for this instance.</span></span></summary>
        <value><span data-ttu-id="be398-2209">Сведения об инициализации домена приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-2209">The application domain initialization information.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-2210">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-2210">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public bool ShadowCopyFiles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ShadowCopyFiles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShadowCopyFiles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyFiles : bool" Usage="System.AppDomain.ShadowCopyFiles" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.ShadowCopyFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="be398-2211">Возвращает указание на то, настроен ли домен приложения для теневого копирования файлов.</span><span class="sxs-lookup"><span data-stu-id="be398-2211">Gets an indication whether the application domain is configured to shadow copy files.</span></span></summary>
        <value><span data-ttu-id="be398-2212">Значение <see langword="true" />, если домен приложения настроен для теневого копирования файлов; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="be398-2212"><see langword="true" /> if the application domain is configured to shadow copy files; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-2213">Дополнительные сведения см. в <xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType> разделе и [теневое копирование сборок](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span><span class="sxs-lookup"><span data-stu-id="be398-2213">For more information, see <xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType> and [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-2214">Предпринята попытка выполнения операции с выгруженным доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-2214">The operation is attempted on an unloaded application domain.</span></span></exception>
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md"><span data-ttu-id="be398-2215">Теневое копирование сборок</span><span class="sxs-lookup"><span data-stu-id="be398-2215">Shadow Copying Assemblies</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _AppDomain.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _AppDomain.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = _AppDomain::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="rgszNames" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="cNames" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="rgDispId" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="riid"><span data-ttu-id="be398-2216">Зарезервировано для будущего использования.</span><span class="sxs-lookup"><span data-stu-id="be398-2216">Reserved for future use.</span></span> <span data-ttu-id="be398-2217">Должно быть равным IID_NULL.</span><span class="sxs-lookup"><span data-stu-id="be398-2217">Must be IID_NULL.</span></span></param>
        <param name="rgszNames"><span data-ttu-id="be398-2218">Переданный массив имен, которые необходимо сопоставить.</span><span class="sxs-lookup"><span data-stu-id="be398-2218">Passed-in array of names to be mapped.</span></span></param>
        <param name="cNames"><span data-ttu-id="be398-2219">Количество сопоставляемых имен.</span><span class="sxs-lookup"><span data-stu-id="be398-2219">Count of the names to be mapped.</span></span></param>
        <param name="lcid"><span data-ttu-id="be398-2220">Контекст языкового стандарта для интерпретации имен.</span><span class="sxs-lookup"><span data-stu-id="be398-2220">The locale context in which to interpret the names.</span></span></param>
        <param name="rgDispId"><span data-ttu-id="be398-2221">Массив, зарезервированный вызывающим объектом, куда помещаются идентификаторы, соответствующие именам.</span><span class="sxs-lookup"><span data-stu-id="be398-2221">Caller-allocated array which receives the IDs corresponding to the names.</span></span></param>
        <summary><span data-ttu-id="be398-2222">Сопоставляет набор имен соответствующему набору идентификаторов диспетчеризации.</span><span class="sxs-lookup"><span data-stu-id="be398-2222">Maps a set of names to a corresponding set of dispatch identifiers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-2223">Этот метод предназначен для доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</span><span class="sxs-lookup"><span data-stu-id="be398-2223">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="be398-2224">Дополнительные сведения о `IDispatch::GetIDsOfNames`см. в библиотеке MSDN.</span><span class="sxs-lookup"><span data-stu-id="be398-2224">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="be398-2225">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="be398-2225">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _AppDomain.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = _AppDomain::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iTInfo"><span data-ttu-id="be398-2226">Возвращаемые сведения о типе.</span><span class="sxs-lookup"><span data-stu-id="be398-2226">The type information to return.</span></span></param>
        <param name="lcid"><span data-ttu-id="be398-2227">Идентификатор языкового стандарта для сведений о типе.</span><span class="sxs-lookup"><span data-stu-id="be398-2227">The locale identifier for the type information.</span></span></param>
        <param name="ppTInfo"><span data-ttu-id="be398-2228">Получает указатель на объект с запрошенными сведениями о типе.</span><span class="sxs-lookup"><span data-stu-id="be398-2228">Receives a pointer to the requested type information object.</span></span></param>
        <summary><span data-ttu-id="be398-2229">Возвращает сведения о типе объекта, которые затем могут использоваться для получения сведений о типе интерфейса.</span><span class="sxs-lookup"><span data-stu-id="be398-2229">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-2230">Этот метод предназначен для доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</span><span class="sxs-lookup"><span data-stu-id="be398-2230">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="be398-2231">Дополнительные сведения о `IDispatch::GetTypeInfo`см. в библиотеке MSDN.</span><span class="sxs-lookup"><span data-stu-id="be398-2231">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="be398-2232">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="be398-2232">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _AppDomain.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = _AppDomain::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pcTInfo"><span data-ttu-id="be398-2233">Указатель, по которому записывается число предоставляемых объектом интерфейсов, предназначенных для получения сведений о типе.</span><span class="sxs-lookup"><span data-stu-id="be398-2233">Points to a location that receives the number of type information interfaces provided by the object.</span></span></param>
        <summary><span data-ttu-id="be398-2234">Возвращает количество предоставляемых объектом интерфейсов для доступа к сведениям о типе (0 или 1).</span><span class="sxs-lookup"><span data-stu-id="be398-2234">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-2235">Этот метод предназначен для доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</span><span class="sxs-lookup"><span data-stu-id="be398-2235">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="be398-2236">Дополнительные сведения о `IDispatch::GetTypeInfoCount`см. в библиотеке MSDN.</span><span class="sxs-lookup"><span data-stu-id="be398-2236">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="be398-2237">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="be398-2237">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.Invoke">
      <MemberSignature Language="C#" Value="void _AppDomain.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _AppDomain.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = _AppDomain::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="wFlags" Type="System.Int16" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pDispParams" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pVarResult" Type="System.IntPtr" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="puArgErr" Type="System.IntPtr" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dispIdMember"><span data-ttu-id="be398-2238">Идентифицирует член.</span><span class="sxs-lookup"><span data-stu-id="be398-2238">Identifies the member.</span></span></param>
        <param name="riid"><span data-ttu-id="be398-2239">Зарезервировано для будущего использования.</span><span class="sxs-lookup"><span data-stu-id="be398-2239">Reserved for future use.</span></span> <span data-ttu-id="be398-2240">Должно быть равным IID_NULL.</span><span class="sxs-lookup"><span data-stu-id="be398-2240">Must be IID_NULL.</span></span></param>
        <param name="lcid"><span data-ttu-id="be398-2241">Контекст языкового стандарта, в котором следует интерпретировать аргументы.</span><span class="sxs-lookup"><span data-stu-id="be398-2241">The locale context in which to interpret arguments.</span></span></param>
        <param name="wFlags"><span data-ttu-id="be398-2242">Флаги, описывающие контекст вызова.</span><span class="sxs-lookup"><span data-stu-id="be398-2242">Flags describing the context of the call.</span></span></param>
        <param name="pDispParams"><span data-ttu-id="be398-2243">Указатель на структуру, содержащую массив аргументов, массив DISPID для именованных аргументов, а также счетчики количества элементов в массивах.</span><span class="sxs-lookup"><span data-stu-id="be398-2243">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span></span></param>
        <param name="pVarResult"><span data-ttu-id="be398-2244">Указатель, по которому будет сохранен результат.</span><span class="sxs-lookup"><span data-stu-id="be398-2244">Pointer to the location where the result is to be stored.</span></span></param>
        <param name="pExcepInfo"><span data-ttu-id="be398-2245">Указатель на структуру, содержащую сведения об исключении.</span><span class="sxs-lookup"><span data-stu-id="be398-2245">Pointer to a structure that contains exception information.</span></span></param>
        <param name="puArgErr"><span data-ttu-id="be398-2246">Индекс первого аргумента, вызвавшего ошибку.</span><span class="sxs-lookup"><span data-stu-id="be398-2246">The index of the first argument that has an error.</span></span></param>
        <summary><span data-ttu-id="be398-2247">Предоставляет доступ к открытым свойствам и методам объекта.</span><span class="sxs-lookup"><span data-stu-id="be398-2247">Provides access to properties and methods exposed by an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-2248">Этот метод предназначен для доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</span><span class="sxs-lookup"><span data-stu-id="be398-2248">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="be398-2249">Дополнительные сведения о `IDispatch::Invoke`см. в библиотеке MSDN.</span><span class="sxs-lookup"><span data-stu-id="be398-2249">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="be398-2250">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="be398-2250">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="appDomain.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="be398-2251">Получает строку, включающую понятное имя домена приложения и политики контекста.</span><span class="sxs-lookup"><span data-stu-id="be398-2251">Obtains a string representation that includes the friendly name of the application domain and any context policies.</span></span></summary>
        <returns><span data-ttu-id="be398-2252">Строка, полученная путем сцепления литеральной строки "Name:", понятного имени домена приложения и либо строкового представления политик контекста, либо строки "Политики контекста отсутствуют".</span><span class="sxs-lookup"><span data-stu-id="be398-2252">A string formed by concatenating the literal string "Name:", the friendly name of the application domain, and either string representations of the context policies or the string "There are no context policies."</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="be398-2253">В следующем примере кода выводится возвращаемое значение <xref:System.AppDomain.ToString%2A> метода.</span><span class="sxs-lookup"><span data-stu-id="be398-2253">The following code example displays the return value of the <xref:System.AppDomain.ToString%2A> method.</span></span>  
  
 [!code-cpp[ADToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADToString/CPP/adtostring.cpp#1)]
 [!code-csharp[ADToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADToString/CS/adtostring.cs#1)]
 [!code-vb[ADToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADToString/VB/adtostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="be398-2254">Домен приложения, представленный текущим <see cref="T:System.AppDomain" />, выгружен.</span><span class="sxs-lookup"><span data-stu-id="be398-2254">The application domain represented by the current <see cref="T:System.AppDomain" /> has been unloaded.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TypeResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler TypeResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler TypeResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.TypeResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TypeResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ TypeResolve;" />
      <MemberSignature Language="F#" Value="member this.TypeResolve : ResolveEventHandler " Usage="member this.TypeResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.TypeResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="be398-2255">Происходит, когда разрешении типа завершается неудачей.</span><span class="sxs-lookup"><span data-stu-id="be398-2255">Occurs when the resolution of a type fails.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-2256">Это <xref:System.AppDomain.TypeResolve> событие возникает, когда среде CLR не удается определить сборку, которая может создать запрошенный тип.</span><span class="sxs-lookup"><span data-stu-id="be398-2256">The <xref:System.AppDomain.TypeResolve> event occurs when the common language runtime is unable to determine the assembly that can create the requested type.</span></span> <span data-ttu-id="be398-2257">Это может произойти, если тип определен в динамической сборке или тип не определен в динамической сборке, но среда выполнения не знает, в какой сборке определен тип.</span><span class="sxs-lookup"><span data-stu-id="be398-2257">This can occur if the type is defined in a dynamic assembly, or the type is not defined in a dynamic assembly but the runtime does not know which assembly the type is defined in.</span></span> <span data-ttu-id="be398-2258">Вторая ситуация может возникнуть при <xref:System.Type.GetType%2A?displayProperty=nameWithType> вызове с именем типа, которое не дополнено именем сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-2258">The latter situation can occur when <xref:System.Type.GetType%2A?displayProperty=nameWithType> is called with a type name that is not qualified with the assembly name.</span></span>  
  
 <span data-ttu-id="be398-2259"><xref:System.ResolveEventHandler> Для этого события можно попытаться выполнить поиск и создать тип.</span><span class="sxs-lookup"><span data-stu-id="be398-2259">The <xref:System.ResolveEventHandler> for this event can attempt to locate and create the type.</span></span>  
  
 <span data-ttu-id="be398-2260">Однако <xref:System.AppDomain.TypeResolve> событие не происходит, если среда выполнения знает, что невозможно найти тип в определенных сборках.</span><span class="sxs-lookup"><span data-stu-id="be398-2260">However, the <xref:System.AppDomain.TypeResolve> event does not occur if the runtime knows it is not possible to find a type in certain assemblies.</span></span> <span data-ttu-id="be398-2261">Например, это событие не происходит, если тип не найден в статической сборке, так как среда выполнения знает типы, которые нельзя динамически добавить в статические сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-2261">For example, this event does not occur if the type is not found in a static assembly because the runtime knows types cannot be added dynamically to static assemblies.</span></span>  
  
 <span data-ttu-id="be398-2262">Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> , свойство содержит сборку, которая запросила тип.</span><span class="sxs-lookup"><span data-stu-id="be398-2262">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> property contains the assembly that requested the type.</span></span> <span data-ttu-id="be398-2263">Для получения дополнительной информации см. <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="be398-2263">For more information, see <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="be398-2264">Чтобы зарегистрировать обработчик событий для этого события, необходимо иметь необходимые разрешения или <xref:System.Security.SecurityException> исключение.</span><span class="sxs-lookup"><span data-stu-id="be398-2264">To register an event handler for this event, you must have the required permissions, or a <xref:System.Security.SecurityException> is thrown.</span></span>  
  
 <span data-ttu-id="be398-2265">Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).</span><span class="sxs-lookup"><span data-stu-id="be398-2265">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-2266">В следующем примере демонстрируется <xref:System.AppDomain.TypeResolve> событие.</span><span class="sxs-lookup"><span data-stu-id="be398-2266">The following sample demonstrates the <xref:System.AppDomain.TypeResolve> event.</span></span>  
  
 <span data-ttu-id="be398-2267">Для выполнения этого примера кода необходимо указать полное имя сборки.</span><span class="sxs-lookup"><span data-stu-id="be398-2267">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="be398-2268">Дополнительные сведения о получении полного имени сборки см. в разделе [имена сборок](~/docs/framework/app-domains/assembly-names.md).</span><span class="sxs-lookup"><span data-stu-id="be398-2268">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_TypeResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_TypeResolve/CPP/typeresolve.cpp#1)]
 [!code-csharp[AppDomain_TypeResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_TypeResolve/CS/typeresolve.cs#1)]
 [!code-vb[AppDomain_TypeResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_TypeResolve/VB/typeresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="be398-2269">требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="be398-2269">requires full trust for the immediate caller.</span></span> <span data-ttu-id="be398-2270">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="be398-2270">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="UnhandledException">
      <MemberSignature Language="C#" Value="public event UnhandledExceptionEventHandler UnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.UnhandledExceptionEventHandler UnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.UnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UnhandledException As UnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event UnhandledExceptionEventHandler ^ UnhandledException;" />
      <MemberSignature Language="F#" Value="member this.UnhandledException : UnhandledExceptionEventHandler " Usage="member this.UnhandledException : System.UnhandledExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.UnhandledException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="be398-2271">Происходит, если выброшенное исключение остается не перехваченным.</span><span class="sxs-lookup"><span data-stu-id="be398-2271">Occurs when an exception is not caught.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-2272">Это событие предоставляет уведомление о неперехваченных исключениях.</span><span class="sxs-lookup"><span data-stu-id="be398-2272">This event provides notification of uncaught exceptions.</span></span> <span data-ttu-id="be398-2273">Он позволяет приложению регистрировать сведения об исключении до того, как системный обработчик по умолчанию сообщит пользователю об исключении и завершит работу приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-2273">It allows the application to log information about the exception before the system default handler reports the exception to the user and terminates the application.</span></span> <span data-ttu-id="be398-2274">Если доступны достаточные сведения о состоянии приложения, можно выполнить другие действия, такие как сохранение данных программы для последующего восстановления.</span><span class="sxs-lookup"><span data-stu-id="be398-2274">If sufficient information about the state of the application is available, other actions may be undertaken - such as saving program data for later recovery.</span></span> <span data-ttu-id="be398-2275">Рекомендуется соблюдать осторожность, так как данные программы могут быть повреждены, если исключения не обрабатываются.</span><span class="sxs-lookup"><span data-stu-id="be398-2275">Caution is advised, because program data can become corrupted when exceptions are not handled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="be398-2276">В .NET Framework версиях 1,0 и 1,1 перед вызовом этого события пользователю сообщается о параметрах завершения и отладки приложения, а не после.</span><span class="sxs-lookup"><span data-stu-id="be398-2276">In the .NET Framework versions 1.0 and 1.1, application termination and debugging options are reported to the user before this event is raised, rather than after.</span></span>  
  
 <span data-ttu-id="be398-2277">Это событие может быть обработано в любом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-2277">This event can be handled in any application domain.</span></span> <span data-ttu-id="be398-2278">Однако это событие не обязательно возникает в домене приложения, где возникло исключение.</span><span class="sxs-lookup"><span data-stu-id="be398-2278">However, the event is not necessarily raised in the application domain where the exception occurred.</span></span> <span data-ttu-id="be398-2279">Исключение не обрабатывается, только если весь стек потока был развернут без поиска соответствующего обработчика исключений, поэтому первое место, в котором может быть создано событие, находится в домене приложения, в котором был создан поток.</span><span class="sxs-lookup"><span data-stu-id="be398-2279">An exception is unhandled only if the entire stack for the thread has been unwound without finding an applicable exception handler, so the first place the event can be raised is in the application domain where the thread originated.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="be398-2280">В .NET Framework версиях 1,0 и 1,1 это событие возникает только для домена приложения по умолчанию, созданного системой при запуске приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-2280">In the .NET Framework versions 1.0 and 1.1, this event occurs only for the default application domain that is created by the system when an application is started.</span></span> <span data-ttu-id="be398-2281">Если приложение создает дополнительные домены приложений, то указание делегата для этого события в этих доменах приложений не действует.</span><span class="sxs-lookup"><span data-stu-id="be398-2281">If an application creates additional application domains, specifying a delegate for this event in those applications domains has no effect.</span></span>  
  
 <span data-ttu-id="be398-2282"><xref:System.AppDomain.UnhandledException> Если событие обрабатывается в домене приложения по умолчанию, оно вызывается для любого необработанного исключения в любом потоке независимо от домена приложения, в котором запущен поток.</span><span class="sxs-lookup"><span data-stu-id="be398-2282">If the <xref:System.AppDomain.UnhandledException> event is handled in the default application domain, it is raised there for any unhandled exception in any thread, no matter what application domain the thread started in.</span></span> <span data-ttu-id="be398-2283">Если поток запущен в домене приложения с обработчиком событий для <xref:System.AppDomain.UnhandledException>, событие возникает в этом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-2283">If the thread started in an application domain that has an event handler for <xref:System.AppDomain.UnhandledException>, the event is raised in that application domain.</span></span> <span data-ttu-id="be398-2284">Если этот домен приложения не является доменом приложения по умолчанию и в домене приложения по умолчанию есть обработчик событий, событие возникает в обоих доменах приложений.</span><span class="sxs-lookup"><span data-stu-id="be398-2284">If that application domain is not the default application domain, and there is also an event handler in the default application domain, the event is raised in both application domains.</span></span>  
  
 <span data-ttu-id="be398-2285">Например, предположим, что поток начинается в домене приложения "AD1", вызывает метод в домене приложения "AD2" и вызывает метод в домене приложения "AD3", где он создает исключение.</span><span class="sxs-lookup"><span data-stu-id="be398-2285">For example, suppose a thread starts in application domain "AD1", calls a method in application domain "AD2", and from there calls a method in application domain "AD3", where it throws an exception.</span></span> <span data-ttu-id="be398-2286">Первым доменом приложения, в котором <xref:System.AppDomain.UnhandledException> может быть вызвано событие, является «AD1».</span><span class="sxs-lookup"><span data-stu-id="be398-2286">The first application domain in which the <xref:System.AppDomain.UnhandledException> event can be raised is "AD1".</span></span> <span data-ttu-id="be398-2287">Если этот домен приложения не является доменом приложения по умолчанию, это событие также может возникнуть в домене приложения по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="be398-2287">If that application domain is not the default application domain, the event can also be raised in the default application domain.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="be398-2288">Среда CLR приостанавливает прерывания потока, пока выполняются обработчики событий для <xref:System.AppDomain.UnhandledException> события.</span><span class="sxs-lookup"><span data-stu-id="be398-2288">The common language runtime suspends thread aborts while event handlers for the <xref:System.AppDomain.UnhandledException> event are executing.</span></span>  
  
 <span data-ttu-id="be398-2289">Если обработчик событий имеет <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> атрибут с соответствующими флагами, обработчик событий обрабатывается как область ограниченного выполнения.</span><span class="sxs-lookup"><span data-stu-id="be398-2289">If the event handler has a <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attribute with the appropriate flags, the event handler is treated as a constrained execution region.</span></span>  
  
 <span data-ttu-id="be398-2290">Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], это событие не вызывается для исключений, которые повреждают состояние процесса, например, переполняет стек или нарушения прав доступа, если только обработчик событий не является критически важным для безопасности и <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> имеет атрибут.</span><span class="sxs-lookup"><span data-stu-id="be398-2290">Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], this event is not raised for exceptions that corrupt the state of the process, such as stack overflows or access violations, unless the event handler is security-critical and has the <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> attribute.</span></span>  
  
 <span data-ttu-id="be398-2291">В .NET Framework версиях 1,0 и 1,1 необработанное исключение, возникающее в потоке, отличном от основного потока приложения, перехватывается средой выполнения и, следовательно, не приводит к завершению работы приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-2291">In the .NET Framework versions 1.0 and 1.1, an unhandled exception that occurs in a thread other than the main application thread is caught by the runtime and therefore does not cause the application to terminate.</span></span> <span data-ttu-id="be398-2292">Таким же <xref:System.AppDomain.UnhandledException> , событие может быть вызвано без завершения работы приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-2292">Thus, it is possible for the <xref:System.AppDomain.UnhandledException> event to be raised without the application terminating.</span></span> <span data-ttu-id="be398-2293">Начиная с .NET Framework версии 2,0 эта позиция необработанных исключений в дочерних потоках была удалена, так как в совокупной эффективности такие сбои, включая снижение производительности, повреждение данных и зависаний, все, что было сложно см.</span><span class="sxs-lookup"><span data-stu-id="be398-2293">Starting with the .NET Framework version 2.0, this backstop for unhandled exceptions in child threads was removed, because the cumulative effect of such silent failures included performance degradation, corrupted data, and lockups, all of which were difficult to debug.</span></span> <span data-ttu-id="be398-2294">Дополнительные сведения, в том числе список случаев, когда среда выполнения не завершает работу, см. [в разделе исключения в управляемых потоках](~/docs/standard/threading/exceptions-in-managed-threads.md).</span><span class="sxs-lookup"><span data-stu-id="be398-2294">For more information, including a list of cases in which the runtime does not terminate, see [Exceptions in Managed Threads](~/docs/standard/threading/exceptions-in-managed-threads.md).</span></span>  
  
 <span data-ttu-id="be398-2295">Чтобы зарегистрировать обработчик событий для этого события, необходимо иметь необходимые разрешения или <xref:System.Security.SecurityException> исключение.</span><span class="sxs-lookup"><span data-stu-id="be398-2295">To register an event handler for this event, you must have the required permissions, or a <xref:System.Security.SecurityException> is thrown.</span></span>  
  
 <span data-ttu-id="be398-2296">Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).</span><span class="sxs-lookup"><span data-stu-id="be398-2296">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
## <a name="other-events-for-unhandled-exceptions"></a><span data-ttu-id="be398-2297">Другие события для необработанных исключений</span><span class="sxs-lookup"><span data-stu-id="be398-2297">Other Events for Unhandled Exceptions</span></span>  
 <span data-ttu-id="be398-2298">Для некоторых моделей приложений <xref:System.AppDomain.UnhandledException> событие может быть вытеснено другими событиями, если необработанное исключение возникает в основном потоке приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-2298">For certain application models, the <xref:System.AppDomain.UnhandledException> event can be preempted by other events if the unhandled exception occurs in the main application thread.</span></span>  
  
 <span data-ttu-id="be398-2299">В приложениях, использующих Windows Forms, необработанные исключения в основном потоке приложения <xref:System.Windows.Forms.Application.ThreadException?displayProperty=nameWithType> приводят к возникновению события.</span><span class="sxs-lookup"><span data-stu-id="be398-2299">In applications that use Windows Forms, unhandled exceptions in the main application thread cause the <xref:System.Windows.Forms.Application.ThreadException?displayProperty=nameWithType> event to be raised.</span></span> <span data-ttu-id="be398-2300">Если это событие обрабатывается, поведение по умолчанию заключается в том, что необработанное исключение не завершает работу приложения, хотя приложение остается в неизвестном состоянии.</span><span class="sxs-lookup"><span data-stu-id="be398-2300">If this event is handled, the default behavior is that the unhandled exception does not terminate the application, although the application is left in an unknown state.</span></span> <span data-ttu-id="be398-2301">В этом случае <xref:System.AppDomain.UnhandledException> событие не возникает.</span><span class="sxs-lookup"><span data-stu-id="be398-2301">In that case, the <xref:System.AppDomain.UnhandledException> event is not raised.</span></span> <span data-ttu-id="be398-2302">Это поведение можно изменить с помощью файла конфигурации приложения или с помощью <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=nameWithType> метода, чтобы изменить <xref:System.Windows.Forms.UnhandledExceptionMode.ThrowException?displayProperty=nameWithType> режим <xref:System.Windows.Forms.Application.ThreadException> до подключения обработчика событий.</span><span class="sxs-lookup"><span data-stu-id="be398-2302">This behavior can be changed by using the application configuration file, or by using the <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=nameWithType> method to change the mode to <xref:System.Windows.Forms.UnhandledExceptionMode.ThrowException?displayProperty=nameWithType> before the <xref:System.Windows.Forms.Application.ThreadException> event handler is hooked up.</span></span> <span data-ttu-id="be398-2303">Это относится только к основному потоку приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-2303">This applies only to the main application thread.</span></span> <span data-ttu-id="be398-2304"><xref:System.AppDomain.UnhandledException> Событие вызывается для необработанных исключений, вызванных в других потоках.</span><span class="sxs-lookup"><span data-stu-id="be398-2304">The <xref:System.AppDomain.UnhandledException> event is raised for unhandled exceptions thrown in other threads.</span></span>  
  
 <span data-ttu-id="be398-2305">Начиная с Microsoft Visual Studio 2005 платформа приложений Visual Basic предоставляет еще одно событие для необработанных исключений в основном потоке приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-2305">Starting with Microsoft Visual Studio 2005, the Visual Basic application framework provides another event for unhandled exceptions in the main application thread.</span></span> <span data-ttu-id="be398-2306">См. <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=nameWithType> событие.</span><span class="sxs-lookup"><span data-stu-id="be398-2306">See the <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="be398-2307">Это событие содержит объект аргументов события с тем же именем, что и объект аргументов события <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>, используемый, но с разными свойствами.</span><span class="sxs-lookup"><span data-stu-id="be398-2307">This event has an event arguments object with the same name as the event arguments object used by <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>, but with different properties.</span></span> <span data-ttu-id="be398-2308">В частности, этот объект аргументов события имеет <xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A> свойство, позволяющее продолжить выполнение приложения, игнорируя необработанное исключение (и продолжая работу приложения в неизвестном состоянии).</span><span class="sxs-lookup"><span data-stu-id="be398-2308">In particular, this event arguments object has an <xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A> property that allows the application to continue running, ignoring the unhandled exception (and leaving the application in an unknown state).</span></span> <span data-ttu-id="be398-2309">В этом случае <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> событие не возникает.</span><span class="sxs-lookup"><span data-stu-id="be398-2309">In that case, the <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> event is not raised.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-2310">В следующем примере демонстрируется <xref:System.AppDomain.UnhandledException> событие.</span><span class="sxs-lookup"><span data-stu-id="be398-2310">The following example demonstrates the <xref:System.AppDomain.UnhandledException> event.</span></span> <span data-ttu-id="be398-2311">Он определяет обработчик `MyHandler`событий, который вызывается при каждом возникновении необработанного исключения в домене приложения по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="be398-2311">It defines an event handler, `MyHandler`, that is invoked whenever an unhandled exception is thrown in the default application domain.</span></span> <span data-ttu-id="be398-2312">Затем он создает два исключения.</span><span class="sxs-lookup"><span data-stu-id="be398-2312">It then throws two exceptions.</span></span> <span data-ttu-id="be398-2313">Первый обрабатывается блоком **try/catch** .</span><span class="sxs-lookup"><span data-stu-id="be398-2313">The first is handled by a **try/catch** block.</span></span> <span data-ttu-id="be398-2314">Второй — необработанный и вызывает `MyHandle` подпрограммы до завершения работы приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-2314">The second is unhandled and invokes the `MyHandle` routine before the application terminates.</span></span>  
  
 [!code-cpp[AppDomain_UnhandledException#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_UnhandledException/CPP/unhandledexception.cpp#1)]
 [!code-csharp[AppDomain_UnhandledException#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_UnhandledException/CS/unhandledexception.cs#1)]
 [!code-vb[AppDomain_UnhandledException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_UnhandledException/VB/unhandledexception.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="be398-2315">требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="be398-2315">requires full trust for the immediate caller.</span></span> <span data-ttu-id="be398-2316">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="be398-2316">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public static void Unload (AppDomain domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Unload(class System.AppDomain domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Unload(System.AppDomain)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Unload (domain As AppDomain)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unload(AppDomain ^ domain);" />
      <MemberSignature Language="F#" Value="static member Unload : AppDomain -&gt; unit" Usage="System.AppDomain.Unload domain" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptAppDomain, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
      </Parameters>
      <Docs>
        <param name="domain"><span data-ttu-id="be398-2317">Домен приложения, который нужно выгрузить.</span><span class="sxs-lookup"><span data-stu-id="be398-2317">An application domain to unload.</span></span></param>
        <summary><span data-ttu-id="be398-2318">Выгружает заданный домен приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-2318">Unloads the specified application domain.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="be398-2319">В .NET Framework версии 2,0 существует поток, предназначенный для выгрузки доменов приложений.</span><span class="sxs-lookup"><span data-stu-id="be398-2319">In the .NET Framework version 2.0 there is a thread dedicated to unloading application domains.</span></span> <span data-ttu-id="be398-2320">Это повышает надежность, особенно при размещении .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="be398-2320">This improves reliability, especially when the .NET Framework is hosted.</span></span> <span data-ttu-id="be398-2321">При вызове <xref:System.AppDomain.Unload%2A>потока целевой домен помечается для выгрузки.</span><span class="sxs-lookup"><span data-stu-id="be398-2321">When a thread calls <xref:System.AppDomain.Unload%2A>, the target domain is marked for unloading.</span></span> <span data-ttu-id="be398-2322">Выделенный поток пытается выгрузить домен, и все потоки в этом домене будут прерваны.</span><span class="sxs-lookup"><span data-stu-id="be398-2322">The dedicated thread attempts to unload the domain, and all threads in the domain are aborted.</span></span> <span data-ttu-id="be398-2323">Если поток не прерывается, например, так как он выполняет неуправляемый код или `finally` выполняется блок, то по истечении определенного периода <xref:System.CannotUnloadAppDomainException> времени в потоке, который был изначально вызван <xref:System.AppDomain.Unload%2A>.</span><span class="sxs-lookup"><span data-stu-id="be398-2323">If a thread does not abort, for example because it is executing unmanaged code, or because it is executing a `finally` block, then after a period of time a <xref:System.CannotUnloadAppDomainException> is thrown in the thread that originally called <xref:System.AppDomain.Unload%2A>.</span></span> <span data-ttu-id="be398-2324">Если поток, который не удалось завершить в конце концов, завершается, целевой домен не выгружается.</span><span class="sxs-lookup"><span data-stu-id="be398-2324">If the thread that could not be aborted eventually ends, the target domain is not unloaded.</span></span> <span data-ttu-id="be398-2325">Таким словами, в .NET Framework версии 2,0 `domain` не гарантируется выгрузка, так как может быть невозможно завершить выполнение потоков.</span><span class="sxs-lookup"><span data-stu-id="be398-2325">Thus, in the .NET Framework version 2.0 `domain` is not guaranteed to unload, because it might not be possible to terminate executing threads.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="be398-2326">В некоторых случаях вызов <xref:System.AppDomain.Unload%2A> вызывает немедленный <xref:System.CannotUnloadAppDomainException>, например, если он вызывается методом завершения.</span><span class="sxs-lookup"><span data-stu-id="be398-2326">In some cases, calling <xref:System.AppDomain.Unload%2A> causes an immediate <xref:System.CannotUnloadAppDomainException>, for example if it is called in a finalizer.</span></span>  
  
 <span data-ttu-id="be398-2327">Потоки в `domain` завершаются <xref:System.Threading.Thread.Abort%2A> с помощью <xref:System.Threading.ThreadAbortException> метода, который создает исключение в потоке.</span><span class="sxs-lookup"><span data-stu-id="be398-2327">The threads in `domain` are terminated using the <xref:System.Threading.Thread.Abort%2A> method, which throws a <xref:System.Threading.ThreadAbortException> in the thread.</span></span> <span data-ttu-id="be398-2328">Хотя поток должен завершаться немедленно, он может продолжать выполнение в течение непредсказуемого времени в `finally` предложении.</span><span class="sxs-lookup"><span data-stu-id="be398-2328">Although the thread should terminate promptly, it can continue executing for an unpredictable amount of time in a `finally` clause.</span></span>  
  
## <a name="version-compatibility"></a><span data-ttu-id="be398-2329">Совместимость версий</span><span class="sxs-lookup"><span data-stu-id="be398-2329">Version Compatibility</span></span>  
 <span data-ttu-id="be398-2330">В .NET Framework версии 1,0 и 1,1, если поток, вызывающий <xref:System.AppDomain.Unload%2A> выполнение, выполняется `domain`в, для выполнения операции выгрузки запускается другой поток.</span><span class="sxs-lookup"><span data-stu-id="be398-2330">In the .NET Framework version 1.0 and 1.1 if the thread that calls <xref:System.AppDomain.Unload%2A> is running in `domain`, another thread is started to perform the unload operation.</span></span> <span data-ttu-id="be398-2331">Если `domain` не удается выгрузить, в <xref:System.CannotUnloadAppDomainException> этом потоке создается исключение, а не в исходный поток, вызвавший <xref:System.AppDomain.Unload%2A>.</span><span class="sxs-lookup"><span data-stu-id="be398-2331">If `domain` cannot be unloaded, a <xref:System.CannotUnloadAppDomainException> is thrown in that thread, not in the original thread that called <xref:System.AppDomain.Unload%2A>.</span></span> <span data-ttu-id="be398-2332">Однако если поток, вызывающий <xref:System.AppDomain.Unload%2A> , работает вне `domain`, этот поток получает исключение.</span><span class="sxs-lookup"><span data-stu-id="be398-2332">However, if the thread that calls <xref:System.AppDomain.Unload%2A> is running outside `domain`, that thread receives the exception.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="be398-2333">В следующем примере кода показано, как выгрузить домен приложения.</span><span class="sxs-lookup"><span data-stu-id="be398-2333">The following code example shows how to unload an application domain.</span></span>  
  
 [!code-cpp[ADUnload#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADUnload/CPP/adunload.cpp#1)]
 [!code-csharp[ADUnload#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADUnload/CS/adunload.cs#1)]
 [!code-vb[ADUnload#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADUnload/VB/adunload.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="be398-2334">Свойство <paramref name="domain" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="be398-2334"><paramref name="domain" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.CannotUnloadAppDomainException"><span data-ttu-id="be398-2335">Домен, определенный параметром <paramref name="domain" />, не может быть выгружен.</span><span class="sxs-lookup"><span data-stu-id="be398-2335"><paramref name="domain" /> could not be unloaded.</span></span></exception>
        <exception cref="T:System.Exception"><span data-ttu-id="be398-2336">Во время выполнения выгрузки произошла ошибка.</span><span class="sxs-lookup"><span data-stu-id="be398-2336">An error occurred during the unload process.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="be398-2337">для добавления обработчика событий для этого события.</span><span class="sxs-lookup"><span data-stu-id="be398-2337">to add an event handler for this event.</span></span> <span data-ttu-id="be398-2338">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />.</span><span class="sxs-lookup"><span data-stu-id="be398-2338">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />.</span></span> <span data-ttu-id="be398-2339">Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span><span class="sxs-lookup"><span data-stu-id="be398-2339">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span></permission>
      </Docs>
    </Member>
  </Members>
</Type>
