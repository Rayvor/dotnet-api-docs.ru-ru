<Type Name="AppDomain" FullName="System.AppDomain">
  <Metadata><Meta Name="ms.openlocfilehash" Value="71ac22eb5f5b1028a67b3e702ff50ec9c5b81519" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75044485" /></Metadata><TypeSignature Language="C#" Value="public sealed class AppDomain : MarshalByRefObject, _AppDomain, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit AppDomain extends System.MarshalByRefObject implements class System._AppDomain, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.AppDomain" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AppDomain&#xA;Inherits MarshalByRefObject&#xA;Implements _AppDomain, IEvidenceFactory" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppDomain sealed : MarshalByRefObject, _AppDomain, System::Security::IEvidenceFactory" />
  <TypeSignature Language="F#" Value="type AppDomain = class&#xA;    inherit MarshalByRefObject&#xA;    interface _AppDomain&#xA;    interface IEvidenceFactory" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System._AppDomain</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System._AppDomain))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет домен приложения, являющийся изолированной средой, в которой выполняются приложения. Этот класс не наследуется.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Домены приложений, представленные <xref:System.AppDomain> объектами, обеспечивают границы изоляции, выгрузки и безопасности для исполнения управляемого кода.  
  
-   Используйте домены приложений для изоляции задач, которые могут привести к завершению процесса. Если состояние <xref:System.AppDomain>, которое исполняет задачу, станет нестабильным, <xref:System.AppDomain> можно выгрузить, не влияя на процесс. Это важно, когда процесс должен выполняться в течение длительных периодов без перезапуска. Домены приложений могут использоваться для изоляции задач, которые не должны совместно использовать данные.  
  
-   Если сборка загружается в домен приложения по умолчанию, она не может быть выгружена из памяти во время работы процесса. Тем не менее, если открыть второй домен приложения для загрузки и выполнения этой сборки, при выгрузке этого домена приложений выгрузится и сборка. Используйте этот метод, чтобы минимизировать рабочий набор длительно выполняемых процессов, которые периодически используют большие библиотеки DLL.  
  
 > [!NOTE]
 >  В .NET Core реализация <xref:System.AppDomain> ограничена конструкцией и не обеспечивает изоляцию, выгрузку или границы безопасности. Для .NET Core существует ровно один <xref:System.AppDomain>. Изоляция и выгрузка предоставляются с помощью <xref:System.Runtime.Loader.AssemblyLoadContext>. Границы безопасности предоставляются границами процессов и соответствующими методиками удаленного взаимодействия.
 
 Несколько доменов приложений могут выполняться в одном процессе; однако нет однозначного соответствия между потоками и доменами приложений. Несколько потоков могут принадлежать к одному домену приложения, и, хотя поток и не ограничен одним доменом приложения, в каждый заданный момент времени поток выполняется в одном домене приложения.  
  
 Домены приложений создаются с помощью метода <xref:System.AppDomain.CreateDomain%2A>. <xref:System.AppDomain> экземпляры используются для загрузки и выполнения сборок (<xref:System.Reflection.Assembly>). Если <xref:System.AppDomain> больше не используется, его можно выгрузить.  
  
 Класс <xref:System.AppDomain> реализует набор событий, позволяющих приложениям реагировать при загрузке сборки, при выгрузке домена приложения или при возникновении необработанного исключения.  
  
 Дополнительные сведения об использовании доменов приложений см. в разделе [домены приложений](~/docs/framework/app-domains/application-domains.md).  
  
 Этот класс реализует интерфейсы <xref:System.MarshalByRefObject>, <xref:System._AppDomain>и <xref:System.Security.IEvidenceFactory>.  
  
 Никогда не следует создавать обертку для удаленного взаимодействия для объекта <xref:System.AppDomain>. Это может опубликовать удаленную ссылку на этот <xref:System.AppDomain>, предоставляя методы, такие как <xref:System.AppDomain.CreateInstance%2A>, для удаленного доступа и эффективного уничтожения управления доступом для кода для этого <xref:System.AppDomain>. Вредоносные клиенты, подключающиеся к удаленной <xref:System.AppDomain>, могут получить доступ к любому ресурсу, к которому у <xref:System.AppDomain> есть доступ. Не создавайте оболочки, поддерживающие удаленное взаимодействие, для любого типа, который расширяет <xref:System.MarshalByRefObject> и реализует методы, которые могут использоваться вредоносными клиентами для обхода системы безопасности.  
  
> [!CAUTION]
>  Значение по умолчанию для свойства <xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType> — `false`. Этот параметр небезопасен для служб. Чтобы службы не загружали частично доверенный код, задайте для этого свойства значение `true`.  
  
   
  
## Examples  
 В этом примере показано, как создать новый <xref:System.AppDomain>, создать экземпляр типа в этом новом <xref:System.AppDomain>и взаимодействовать с объектом этого типа. Кроме того, в этом примере показано, как выгрузить <xref:System.AppDomain> вызывающий сбор мусора для объекта.  
  
 [!code-cpp[AppDomainX#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainX/cpp/AppDomainX.cpp#1)]
 [!code-csharp[AppDomainX#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainX/cs/AppDomainX.cs#1)]
 [!code-vb[AppDomainX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainX/VB/AppDomainX.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/07ea8438-7a34-49f0-a7e8-3d6ff7e4a482">Как настроить домен приложения</related>
    <related type="Article" href="https://msdn.microsoft.com/library/ba1fa43e-49f5-47d9-bd7f-3024af16f4ba">Как создать домен приложения</related>
    <related type="Article" href="https://msdn.microsoft.com/library/1432aa2d-bd83-4346-bf3b-a1b7920e2aa9">Практическое руководство. Загрузка сборок в домен приложения</related>
    <related type="Article" href="https://msdn.microsoft.com/library/f356116d-e415-4f7c-a332-6e6a60227192">Практическое руководство. Выгрузка домена приложения</related>
  </Docs>
  <Members>
    <Member MemberName="ActivationContext">
      <MemberSignature Language="C#" Value="public ActivationContext ActivationContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ActivationContext ActivationContext" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ActivationContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActivationContext As ActivationContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ActivationContext ^ ActivationContext { ActivationContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ActivationContext : ActivationContext" Usage="System.AppDomain.ActivationContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ActivationContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает контекст активации по умолчанию для текущего домена приложения.</summary>
        <value>Объект, представляющий контекст активации для текущего домена приложения, или значение <see langword="null" />, если этот домен не имеет контекста активации.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="AppendPrivatePath">
      <MemberSignature Language="C#" Value="public void AppendPrivatePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendPrivatePath(string path) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.AppendPrivatePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendPrivatePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendPrivatePath(System::String ^ path);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.AppendPrivatePath : string -&gt; unit" Usage="appDomain.AppendPrivatePath path" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AppendPrivatePath(string path) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AppendPrivatePath(System::String ^ path);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member AppendPrivatePath : string -&gt; unit&#xA;override this.AppendPrivatePath : string -&gt; unit" Usage="appDomain.AppendPrivatePath path" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.AppendPrivatePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Имя каталога, который следует добавить в закрытый путь.</param>
        <summary>Добавляет указанное имя каталога к закрытому списку путей.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Использовать это свойство не рекомендуется, так как оно может изменить путь поиска для сборок после того, как они уже были загружены. Вместо этого следует использовать свойство <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.  
  
 Частный путь или относительный путь поиска — это путь относительно базового каталога, в котором арбитр сборок проверяет наличие закрытых сборок.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationIdentity">
      <MemberSignature Language="C#" Value="public ApplicationIdentity ApplicationIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ApplicationIdentity ApplicationIdentity" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationIdentity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationIdentity As ApplicationIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ApplicationIdentity ^ ApplicationIdentity { ApplicationIdentity ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationIdentity : ApplicationIdentity" Usage="System.AppDomain.ApplicationIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ApplicationIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает удостоверение приложения в данном домене приложения.</summary>
        <value>Объект, идентифицирующий приложение в данном домене приложения.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationTrust" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationTrust As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::ApplicationTrust ^ ApplicationTrust { System::Security::Policy::ApplicationTrust ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationTrust : System.Security.Policy.ApplicationTrust" Usage="System.AppDomain.ApplicationTrust" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает информацию, описывающую разрешения, предоставленные приложению, и то, имеет ли приложение уровень доверия, позволяющий ему выполняться.</summary>
        <value>Объект, инкапсулирующий сведения о разрешениях и доверии для приложения в домене приложения.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplyPolicy">
      <MemberSignature Language="C#" Value="public string ApplyPolicy (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ApplyPolicy(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ApplyPolicy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyPolicy (assemblyName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ApplyPolicy(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.ApplyPolicy : string -&gt; string" Usage="appDomain.ApplyPolicy assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Отображаемое имя сборки в форме, заданной свойством <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <summary>Возвращает отображаемое имя сборки после применения политики.</summary>
        <returns>Строка, содержащая отображаемое имя сборки после применения политики.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.AppDomain.ApplyPolicy%2A> принимает отображаемое имя сборки и возвращает отображаемое имя после применения политики. Это полезно, если необходимо загрузить сборку с помощью политики, так как контекст только для отражения не применяет политику.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyLoad">
      <MemberSignature Language="C#" Value="public event AssemblyLoadEventHandler AssemblyLoad;" />
      <MemberSignature Language="ILAsm" Value=".event class System.AssemblyLoadEventHandler AssemblyLoad" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyLoad" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyLoad As AssemblyLoadEventHandler " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event AssemblyLoadEventHandler ^ AssemblyLoad;" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.AssemblyLoad : AssemblyLoadEventHandler " Usage="member this.AssemblyLoad : System.AssemblyLoadEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event AssemblyLoadEventHandler ^ AssemblyLoad;" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Event AssemblyLoad As AssemblyLoadEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyLoad</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AssemblyLoadEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>происходит, когда загружена сборка.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Делегат <xref:System.AssemblyLoadEventHandler> для этого события указывает, какая сборка была загружена.  
  
 Чтобы зарегистрировать обработчик событий для этого события, необходимо иметь необходимые разрешения или исключение <xref:System.Security.SecurityException>.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере демонстрируется событие <xref:System.AppDomain.AssemblyLoad>.  
  
 Для выполнения этого примера кода необходимо указать полное имя сборки. Дополнительные сведения о получении полного имени сборки см. в разделе [имена сборок](~/docs/standard/assembly/names.md).  
  
 [!code-cpp[AppDomain_AssemblyLoad#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CPP/assemblyload.cpp#1)]
 [!code-csharp[AppDomain_AssemblyLoad#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CS/assemblyload.cs#1)]
 [!code-vb[AppDomain_AssemblyLoad#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_AssemblyLoad/VB/assemblyload.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="AssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler AssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler AssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event ResolveEventHandler ^ AssemblyResolve;" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.AssemblyResolve : ResolveEventHandler " Usage="member this.AssemblyResolve : System.ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ AssemblyResolve;" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>происходит, когда разрешение сборки завершается неудачей.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для получения сборки, указанной свойством <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType>, или для возврата значения NULL, если сборка не распознана, отвечает <xref:System.ResolveEventHandler> этого события. Сборка должна быть загружена в контекст выполнения; при загрузке в контекст, предназначенный только для отражения, нагрузка, вызвавшая это событие, завершается ошибкой.  
  
 Рекомендации по использованию этого события см. в разделе [разрешение загрузки сборок](~/docs/standard/assembly/resolve-loads.md).  
  
 Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]свойство <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> возвращает сборку, которая запросила загрузку сборки, которую не удалось разрешить. Например, загрузчику может быть невозможно загрузить зависимость запрашивающей сборки, так как запрашивающая сборка и ее зависимость не находятся в пути поиска. Знание идентификации запрашивающей сборки может оказаться полезным при поиске зависимости или при определении правильной версии, если доступна более чем одна версия зависимости. Для получения дополнительной информации см. <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
> [!IMPORTANT]
>  Начиная с [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], событие <xref:System.ResolveEventHandler> вызывается для всех сборок, включая сборки ресурсов. В более ранних версиях событие не было вызвано для сборок ресурсов. Если операционная система локализована, обработчик может вызываться несколько раз: один раз для каждого языка и региональных параметров в цепочке резервов.  
  
 Для этого события свойство <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> возвращает имя сборки перед применением политики.  
  
> [!IMPORTANT]
>  Если для этого события зарегистрировано более одного обработчика событий, обработчики событий вызываются по порядку, пока обработчик событий не вернет значение, которое не `null`. Последующие обработчики событий игнорируются.
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере демонстрируется событие <xref:System.AppDomain.AssemblyResolve>.  
  
 Для выполнения этого примера кода необходимо указать полное имя сборки. Дополнительные сведения о получении полного имени сборки см. в разделе [имена сборок](~/docs/standard/assembly/names.md).  
  
 [!code-cpp[AssemblyResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyResolve/CPP/assemblyresolve.cpp#1)]
 [!code-csharp[AssemblyResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyResolve/CS/assemblyresolve.cs#1)]
 [!code-vb[AssemblyResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyResolve/VB/assemblyresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
        <related type="Article" href="https://msdn.microsoft.com/library/5099e549-f4fd-49fb-a290-549edd456c6a">разрешение загрузки сборок</related>
      </Docs>
    </Member>
    <Member MemberName="BaseDirectory">
      <MemberSignature Language="C#" Value="public string BaseDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.BaseDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ BaseDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseDirectory : string" Usage="System.AppDomain.BaseDirectory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.BaseDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает базовый каталог, в котором распознаватель сборок производит поиск.</summary>
        <value>Базовый каталог, в котором распознаватель сборок производит поиск.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство соответствует свойству <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>. Его также можно получить с помощью метода <xref:System.AppDomain.GetData%2A> со строкой "APPBASE".  
  
   
  
## Examples  
 В следующем примере кода создается новый домен приложения с указанием базового каталога, который будет использоваться при поиске сборок для загрузки в домен. Затем в примере используется свойство <xref:System.AppDomain.BaseDirectory%2A> для получения пути к базовому каталогу для вывода на консоль.  
  
 [!code-cpp[ADSetup#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetup/CPP/adsetup.cpp#1)]
 [!code-csharp[ADSetup#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetup/CS/adsetup.cs#1)]
 [!code-vb[ADSetup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetup/VB/adsetup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям в самом пути, в том числе если путь имеет формат "file://" или \\\Унк\дир или "c:\\". Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="P:System.AppDomainSetup.ApplicationBase" />
      </Docs>
    </Member>
    <Member MemberName="ClearPrivatePath">
      <MemberSignature Language="C#" Value="public void ClearPrivatePath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearPrivatePath() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearPrivatePath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearPrivatePath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearPrivatePath();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.ClearPrivatePath : unit -&gt; unit" Usage="appDomain.ClearPrivatePath " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearPrivatePath() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearPrivatePath();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member ClearPrivatePath : unit -&gt; unit&#xA;override this.ClearPrivatePath : unit -&gt; unit" Usage="appDomain.ClearPrivatePath " FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearPrivatePath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Сбрасывает путь, указывающий на размещение закрытых сборок, присваивая ему пустую строку ("").</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Частный путь — это путь относительно базового каталога, который среда CLR ищет для поиска закрытых сборок.  
  
 Для получения дополнительной информации см. <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать метод <xref:System.AppDomain.ClearPrivatePath%2A> для удаления всех записей из списка закрытых путей для поиска при загрузке сборок.  
  
 Теперь этот метод устарел и не должен использоваться для новой разработки.  
  
 [!code-cpp[ADClearPrivatePath#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADClearPrivatePath/CPP/adclearprivatepath.cpp#1)]
 [!code-csharp[ADClearPrivatePath#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADClearPrivatePath/CS/adclearprivatepath.cs#1)]
 [!code-vb[ADClearPrivatePath#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADClearPrivatePath/VB/adclearprivatepath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="F:System.String.Empty" />
      </Docs>
    </Member>
    <Member MemberName="ClearShadowCopyPath">
      <MemberSignature Language="C#" Value="public void ClearShadowCopyPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearShadowCopyPath() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearShadowCopyPath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearShadowCopyPath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearShadowCopyPath();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.ClearShadowCopyPath : unit -&gt; unit" Usage="appDomain.ClearShadowCopyPath " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearShadowCopyPath() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearShadowCopyPath();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member ClearShadowCopyPath : unit -&gt; unit&#xA;override this.ClearShadowCopyPath : unit -&gt; unit" Usage="appDomain.ClearShadowCopyPath " FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearShadowCopyPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("AppDomain.ClearShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("AppDomain.ClearShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("AppDomain.ClearShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Сбрасывает список каталогов, содержащих теневые копии сборок, присваивая ему пустую строку ("").</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Путь к теневой копии представляет собой список каталогов, в которых хранятся теневые копии сборок.  
  
 Дополнительные сведения см. в разделе <xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType> и [теневое копирование сборок](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="F:System.String.Empty" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Теневое копирование сборок</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateComInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает новый экземпляр заданного типа COM.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateComInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateComInstanceFrom (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Имя файла, содержащего сборку, определяющую запрошенный тип.</param>
        <param name="typeName">Имя запрошенного типа.</param>
        <summary>Создает новый экземпляр заданного типа COM. Параметры задают имя файла сборки, содержащей этот тип, и имя типа.</summary>
        <returns>Объект, являющийся оболочкой для нового экземпляра, заданного параметром <paramref name="typeName" />. Необходимо распаковать возвращенное значение, чтобы получить доступ к реальному объекту.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для удаленного создания объектов без необходимости загрузки типа локально.  
  
 Чтобы получить доступ к реальному объекту, возвращаемое значение должно быть распаковано.  
  
 Атрибут <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> со значением `true` должен применяться явно или по умолчанию к типу COM для этого метода, чтобы создать экземпляр этого типа. в противном случае выдается <xref:System.TypeLoadException>.  
  
   
  
## Examples  
 В следующем примере демонстрируется  
  
 [!code-cpp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CPP/createcominstancefrom.cpp#1)]
 [!code-csharp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CS/createcominstancefrom.cs#1)]
 [!code-vb[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/VB/createcominstancefrom.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="assemblyName" /> или <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">Невозможно загрузить тип.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <exception cref="T:System.MissingMethodException">Открытый конструктор без параметров не найден.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" /> не найден.</exception>
        <exception cref="T:System.MemberAccessException"><paramref name="typeName" /> является абстрактным классом.  
  
-или- 
Этот элемент был вызван при помощи механизма позднего связывания.</exception>
        <exception cref="T:System.NotSupportedException">Вызывающий код не может предоставить атрибуты активации для объекта, не являющегося наследником <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="assemblyName" /> является пустой строкой ("").</exception>
        <exception cref="T:System.BadImageFormatException">Тип <paramref name="assemblyName" /> не является допустимой сборкой.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль были загружены дважды с двумя разными свидетельствами.</exception>
        <exception cref="T:System.NullReferenceException">Указанный объект COM равен <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">для возможности чтения файла, содержащего манифест сборки. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">значение для возможности доступа к расположению сборки, если сборка не является локальной.</permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyFile, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyFile, string typeName, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyFile As String, typeName As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.CreateComInstanceFrom : string * string * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateComInstanceFrom (assemblyFile, typeName, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="hashValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Имя файла, содержащего сборку, определяющую запрошенный тип.</param>
        <param name="typeName">Имя запрошенного типа.</param>
        <param name="hashValue">Представляет значение вычисляемого хэш-кода.</param>
        <param name="hashAlgorithm">Представляет алгоритм хэширования, используемый манифестом сборки.</param>
        <summary>Создает новый экземпляр заданного типа COM. Параметры задают имя файла сборки, содержащей этот тип, и имя типа.</summary>
        <returns>Объект, являющийся оболочкой для нового экземпляра, заданного параметром <paramref name="typeName" />. Необходимо распаковать возвращенное значение, чтобы получить доступ к реальному объекту.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для удаленного создания объектов без необходимости загрузки типа локально.  
  
 Чтобы получить доступ к реальному объекту, возвращаемое значение должно быть распаковано.  
  
 Атрибут <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> со значением `true` должен применяться явно или по умолчанию к типу COM для этого метода, чтобы создать экземпляр этого типа. в противном случае выдается <xref:System.TypeLoadException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="assemblyName" /> или <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">Невозможно загрузить тип.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <exception cref="T:System.MissingMethodException">Открытый конструктор без параметров не найден.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" /> не найден.</exception>
        <exception cref="T:System.MemberAccessException"><paramref name="typeName" /> является абстрактным классом.  
  
-или- 
Этот элемент был вызван при помощи механизма позднего связывания.</exception>
        <exception cref="T:System.NotSupportedException">Вызывающий код не может предоставить атрибуты активации для объекта, не являющегося наследником <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyFile" /> является пустой строкой ("").</exception>
        <exception cref="T:System.BadImageFormatException">Тип <paramref name="assemblyFile" /> не является допустимой сборкой.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль были загружены дважды с двумя разными свидетельствами.</exception>
        <exception cref="T:System.NullReferenceException">Указанный объект COM равен <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">для возможности чтения файла, содержащего манифест сборки. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">значение для возможности доступа к расположению сборки, если сборка не является локальной.</permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDomain">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает новый домен приложения.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string -&gt; AppDomain" Usage="System.AppDomain.CreateDomain friendlyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Понятное имя домена.</param>
        <summary>Создает новый домен приложения с заданным именем.</summary>
        <returns>Вновь созданный домен приложения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр `friendlyName` предназначен для того, чтобы обозначать домен способом, который имеет смысл для человека. Эта строка должна быть подходящей для вывода в пользовательских интерфейсах.  
  
 Эта перегрузка метода использует сведения о <xref:System.AppDomainSetup> из домена приложения по умолчанию.  
  
   
  
## Examples  
 В следующем примере показано, как создать домен, используя одну из перегрузок <xref:System.AppDomain.CreateDomain%2A>.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="friendlyName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Метод не поддерживается в .NET Core.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для предоставления свидетельства. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="P:System.AppDomain.FriendlyName" />
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Понятное имя домена. Это понятное имя может отображаться в пользовательском интерфейсе для определения домена. Для получения дополнительной информации см. <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Свидетельство, идентифицирующее код, который выполняется в домене приложения. Передайте значение <see langword="null" /> для использования свидетельства текущего домена приложения.</param>
        <summary>Создает новый домен приложения с заданным именем с помощью предоставленного свидетельства.</summary>
        <returns>Вновь созданный домен приложения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка метода использует сведения о <xref:System.AppDomainSetup> из домена приложения по умолчанию.  
  
 Если `securityInfo` не указан, используется свидетельство из текущего домена приложения.  
  
> [!IMPORTANT]
>  Не используйте эту перегрузку метода для создания изолированных доменов приложений. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], свидетельство, предоставляемое для `securityInfo`, больше не влияет на набор прав домена приложения. Используйте перегрузку метода <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> для создания доменов изолированных приложений.  
  
   
  
## Examples  
 В следующем примере показано, как создать домен, используя одну из перегрузок <xref:System.AppDomain.CreateDomain%2A>.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="friendlyName" /> имеет значение <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для предоставления свидетельства. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * AppDomainSetup -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, info)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="info" Type="System.AppDomainSetup" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Понятное имя домена. Это понятное имя может отображаться в пользовательском интерфейсе для определения домена. Для получения дополнительной информации см. <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Свидетельство, идентифицирующее код, который выполняется в домене приложения. Передайте значение <see langword="null" /> для использования свидетельства текущего домена приложения.</param>
        <param name="info">Объект, в котором содержатся сведения об инициализации домена приложения.</param>
        <summary>Создает новый домен приложения с использованием заданного имени, свидетельства и сведений об установке домена приложения.</summary>
        <returns>Вновь созданный домен приложения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `info` не указан, эта перегрузка метода использует сведения о <xref:System.AppDomainSetup> из домена приложения по умолчанию.  
  
 Если `securityInfo` не указан, используется свидетельство из текущего домена приложения.  
  
> [!IMPORTANT]
>  Не используйте эту перегрузку метода для создания изолированных доменов приложений. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], свидетельство, предоставляемое для `securityInfo`, больше не влияет на набор прав домена приложения. Используйте перегрузку метода <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> для создания доменов изолированных приложений.  
  
   
  
## Examples  
 В следующем примере показано, как создать домен, используя одну из перегрузок <xref:System.AppDomain.CreateDomain%2A>.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="friendlyName" /> имеет значение <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для предоставления свидетельства. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info, System.Security.PermissionSet grantSet, params System.Security.Policy.StrongName[] fullTrustAssemblies);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info, class System.Security.PermissionSet grantSet, class System.Security.Policy.StrongName[] fullTrustAssemblies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup, grantSet As PermissionSet, ParamArray fullTrustAssemblies As StrongName()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info, System::Security::PermissionSet ^ grantSet, ... cli::array &lt;System::Security::Policy::StrongName ^&gt; ^ fullTrustAssemblies);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * AppDomainSetup * System.Security.PermissionSet * System.Security.Policy.StrongName[] -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, info, grantSet, fullTrustAssemblies)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="info" Type="System.AppDomainSetup" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="grantSet" Type="System.Security.PermissionSet" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="fullTrustAssemblies" Type="System.Security.Policy.StrongName[]" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="friendlyName">Понятное имя домена. Это понятное имя может отображаться в пользовательском интерфейсе для определения домена. Дополнительные сведения см. в описании <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Свидетельство, идентифицирующее код, который выполняется в домене приложения. Передайте значение <see langword="null" /> для использования свидетельства текущего домена приложения.</param>
        <param name="info">Объект, в котором содержатся сведения об инициализации домена приложения.</param>
        <param name="grantSet">Используемый по умолчанию набор разрешений, которые предоставляются всем сборкам, загружаемым в новый домен приложения, не имеющих специальных разрешений.</param>
        <param name="fullTrustAssemblies">Массив строгих имен, представляющих сборки, которые будут считаться обладающими полным доверием в новом домене приложения.</param>
        <summary>Создает новый домен приложения с использованием заданного имени, свидетельства, сведений об установке домена приложения, используемого по умолчанию набора разрешений и массива сборок с полным доверием.</summary>
        <returns>Вновь созданный домен приложения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Необходимо задать свойство <xref:System.AppDomainSetup.ApplicationBase%2A> объекта <xref:System.AppDomainSetup>, предоставленного для `info`. В противном случае возникнет исключение.  
  
 Если `securityInfo` не указан, используется свидетельство из текущего домена приложения.  
  
 Сведения, предоставляемые для `grantSet` и `fullTrustAssemblies`, используются для создания объекта <xref:System.Security.Policy.ApplicationTrust> для нового домена приложения.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="friendlyName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Домен приложения равен <see langword="null" />.  
  
-или- 
Свойство <see cref="P:System.AppDomainSetup.ApplicationBase" /> не задано в объекте <see cref="T:System.AppDomainSetup" />, который предоставляется для <paramref name="info" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">возможность создания домена приложения и управления им. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />. Действие безопасности: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * string * string * bool -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, appBasePath, appRelativeSearchPath, shadowCopyFiles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="appBasePath" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Понятное имя домена. Это понятное имя может отображаться в пользовательском интерфейсе для определения домена. Для получения дополнительной информации см. <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Свидетельство, идентифицирующее код, который выполняется в домене приложения. Передайте значение <see langword="null" /> для использования свидетельства текущего домена приложения.</param>
        <param name="appBasePath">Базовый каталог, в котором распознаватель сборок производит поиск. Для получения дополнительной информации см. <see cref="P:System.AppDomain.BaseDirectory" />.</param>
        <param name="appRelativeSearchPath">Путь, соответствующий базовому каталогу, в котором распознаватель сборок будет производить поиск закрытых сборок. Для получения дополнительной информации см. <see cref="P:System.AppDomain.RelativeSearchPath" />.</param>
        <param name="shadowCopyFiles">Если <see langword="true" />, теневая копия сборки загружается в этот домен приложения.</param>
        <summary>Создает новый домен приложения с заданным именем с использованием свидетельства, пути к базовой папке приложения, относительного пути поиска и параметра, указывающего, должна ли загружаться теневая копия сборки в домен приложения.</summary>
        <returns>Вновь созданный домен приложения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `securityInfo` не указан, используется свидетельство из текущего домена приложения.  
  
 Дополнительные сведения о теневом копировании см. в разделе <xref:System.AppDomain.ShadowCopyFiles%2A> и [теневое копирование сборок](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
> [!IMPORTANT]
>  Не используйте эту перегрузку метода для создания изолированных доменов приложений. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], свидетельство, предоставляемое для `securityInfo`, больше не влияет на набор прав домена приложения. Используйте перегрузку метода <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> для создания доменов изолированных приложений.  
  
   
  
## Examples  
 В следующем примере показано, как создать домен, используя одну из перегрузок <xref:System.AppDomain.CreateDomain%2A>.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="friendlyName" /> имеет значение <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для предоставления свидетельства. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer adInit, string[] adInitArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, class System.AppDomainInitializer adInit, string[] adInitArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean, adInit As AppDomainInitializer, adInitArgs As String()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer ^ adInit, cli::array &lt;System::String ^&gt; ^ adInitArgs);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * string * string * bool * AppDomainInitializer * string[] -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, appBasePath, appRelativeSearchPath, shadowCopyFiles, adInit, adInitArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="appBasePath" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="adInit" Type="System.AppDomainInitializer" Index="5" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="adInitArgs" Type="System.String[]" Index="6" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Понятное имя домена. Это понятное имя может отображаться в пользовательском интерфейсе для определения домена. Для получения дополнительной информации см. <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Свидетельство, идентифицирующее код, который выполняется в домене приложения. Передайте значение <see langword="null" /> для использования свидетельства текущего домена приложения.</param>
        <param name="appBasePath">Базовый каталог, в котором распознаватель сборок производит поиск. Для получения дополнительной информации см. <see cref="P:System.AppDomain.BaseDirectory" />.</param>
        <param name="appRelativeSearchPath">Путь, соответствующий базовому каталогу, в котором распознаватель сборок будет производить поиск закрытых сборок. Для получения дополнительной информации см. <see cref="P:System.AppDomain.RelativeSearchPath" />.</param>
        <param name="shadowCopyFiles">Значение <see langword="true" /> для загрузки теневой копии сборки в этот домен приложения.</param>
        <param name="adInit">Делегат <see cref="T:System.AppDomainInitializer" />, представляющий метод обратного вызова, вызываемый при инициализации нового объекта <see cref="T:System.AppDomain" />.</param>
        <param name="adInitArgs">Массив строковых аргументов, передаваемый методу обратного вызова, представленному объектом <paramref name="adInit" />, когда инициализируется новый объект <see cref="T:System.AppDomain" />.</param>
        <summary>Создает новый домен приложения с заданным именем с использованием свидетельства, пути к базовой папке приложения, относительного пути поиска и параметра, указывающего, должна ли загружаться теневая копия сборки в домен приложения. Задает метод обратного вызова, вызываемый, когда инициализируется домен приложения, и массив строковых аргументов для передачи методу обратного вызова.</summary>
        <returns>Вновь созданный домен приложения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод, представленный `adInit`, выполняется в контексте только что созданного домена приложения.  
  
 Если `securityInfo` не указан, используется свидетельство из текущего домена приложения.  
  
 Дополнительные сведения о теневом копировании см. в разделе <xref:System.AppDomain.ShadowCopyFiles%2A> и [теневое копирование сборок](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
> [!IMPORTANT]
>  Не используйте эту перегрузку метода для создания изолированных доменов приложений. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], свидетельство, предоставляемое для `securityInfo`, больше не влияет на набор прав домена приложения. Используйте перегрузку метода <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> для создания доменов изолированных приложений.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="friendlyName" /> имеет значение <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для предоставления свидетельства. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает новый экземпляр заданного типа, определенного в указанной сборке.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName);" FrameworkAlternate="netcore-3.0;netcore-3.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName)" FrameworkAlternate="netcore-3.0;netcore-3.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Отображаемое имя сборки. См. <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Полное имя запрошенного типа, включая пространство имен, но не сборку, возвращаемое свойством <see cref="P:System.Type.FullName" />.</param>
        <summary>Создает новый экземпляр заданного типа, определенного в указанной сборке.</summary>
        <returns>Объект, являющийся оболочкой для нового экземпляра, заданного параметром <paramref name="typeName" />. Необходимо распаковать возвращенное значение, чтобы получить доступ к реальному объекту.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывает конструктор без параметров для `typeName`.  
  
 См. раздел <xref:System.Reflection.AssemblyName> для формата `assemblyName`.  
  
 Попытка вызвать <xref:System.AppDomain.CreateInstance%2A> в домене целевого приложения, который не является текущим доменом приложения, приведет к успешной загрузке сборки в целевом домене приложения. Поскольку <xref:System.Reflection.Assembly> не <xref:System.MarshalByRefObject>, когда этот метод пытается вернуть <xref:System.Reflection.Assembly> для загруженной сборки в текущий домен приложения, среда CLR будет пытаться загрузить сборку в текущий домен приложения, и загрузка может завершиться ошибкой. Сборка, загруженная в текущий домен приложения, может отличаться от сборки, которая была загружена первой, если параметры пути для двух доменов приложений различаются.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="assemblyName" /> или <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">Тип <paramref name="assemblyName" /> не является допустимой сборкой.  
  
-или- 
В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyName" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль были загружены дважды с двумя разными свидетельствами.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл <paramref name="assemblyName" /> не найден.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий код не имеет разрешения на вызов этого конструктора.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий общий конструктор не найден.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" /> в сборке <paramref name="assemblyName" /> не найден.</exception>
        <exception cref="T:System.NullReferenceException">Данный экземпляр имеет значение <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к чтению из файла или каталога, а также для доступа к данным в самом пути. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">значение для возможности доступа к расположению сборки, если сборка не является локальной.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности вызова неуправляемого кода при создании экземпляра делегата. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" FrameworkAlternate="netcore-3.0;netcore-3.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, activationAttributes)" FrameworkAlternate="netcore-3.0;netcore-3.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, activationAttributes)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="2" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Отображаемое имя сборки. См. <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Полное имя запрошенного типа, включая пространство имен, но не сборку, возвращаемое свойством <see cref="P:System.Type.FullName" />.</param>
        <param name="activationAttributes">Массив атрибутов, которые могут участвовать в активации. Обычно это массив, содержащий один объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />, определяющий URL-адрес, необходимый для активации удаленного объекта.  
  
Этот параметр связан с объектами, активируемыми клиентом. Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений. Сейчас в распределенных приложениях следует использовать Windows Communication Foundation.</param>
        <summary>Создает новый экземпляр заданного типа, определенного в указанной сборке. Параметр определяет массив атрибутов активации.</summary>
        <returns>Объект, являющийся оболочкой для нового экземпляра, заданного параметром <paramref name="typeName" />. Необходимо распаковать возвращенное значение, чтобы получить доступ к реальному объекту.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывает конструктор без параметров для `typeName`.  
  
 См. раздел <xref:System.Reflection.AssemblyName> для формата `assemblyName`.  
  
 Попытка вызвать <xref:System.AppDomain.CreateInstance%2A> в домене целевого приложения, который не является текущим доменом приложения, приведет к успешной загрузке сборки в целевом домене приложения. Поскольку <xref:System.Reflection.Assembly> не <xref:System.MarshalByRefObject>, когда этот метод пытается вернуть <xref:System.Reflection.Assembly> для загруженной сборки в текущий домен приложения, среда CLR будет пытаться загрузить сборку в текущий домен приложения, и загрузка может завершиться ошибкой. Сборка, загруженная в текущий домен приложения, может отличаться от сборки, которая была загружена первой, если параметры пути для двух доменов приложений различаются.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="assemblyName" /> или <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">Тип <paramref name="assemblyName" /> не является допустимой сборкой.  
  
-или- 
В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyName" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль были загружены дважды с двумя разными свидетельствами.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл <paramref name="assemblyName" /> не найден.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий код не имеет разрешения на вызов этого конструктора.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий общий конструктор не найден.</exception>
        <exception cref="T:System.NotSupportedException">Вызывающий код не может предоставить атрибуты активации для объекта, не являющегося наследником <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" /> в сборке <paramref name="assemblyName" /> не найден.</exception>
        <exception cref="T:System.NullReferenceException">Данный экземпляр имеет значение <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">для возможности чтения файла, содержащего манифест сборки. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">значение для возможности доступа к расположению сборки, если сборка не является локальной.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности вызова неуправляемого кода при создании экземпляра делегата. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">для возможности вызова операций для всех членов типа. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Отображаемое имя сборки. См. <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Полное имя запрошенного типа, включая пространство имен, но не сборку, возвращаемое свойством <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Логическое значение, указывающее, следует ли учитывать регистр при поиске.</param>
        <param name="bindingAttr">Сочетание битовых флагов (от нуля и более), влияющих на поиск конструктора <paramref name="typeName" />. Если значение параметра <paramref name="bindingAttr" /> равно нулю, проводится поиск открытых конструкторов с учетом регистра.</param>
        <param name="binder">Объект, позволяющий осуществлять привязку, приведение типов аргументов, вызов элементов, а также поиск объектов <see cref="T:System.Reflection.MemberInfo" /> с помощью отражения. Если значением параметра <paramref name="binder" /> является null, то используется средство связывания по умолчанию.</param>
        <param name="args">Аргументы для передачи конструктору. Массив аргументов должен соответствовать по числу, порядку и типу параметров вызываемому конструктору. Если предпочтителен конструктор без параметров, то объект <paramref name="args" /> должен быть пустым массивом или значением NULL.</param>
        <param name="culture">Сведения о языке и региональных параметрах, которые влияют на приведение <paramref name="args" /> к формальным типам, объявленным для конструктора <paramref name="typeName" />. Если значение параметра <paramref name="culture" /> равно <see langword="null" />, для текущего потока используется объект <see cref="T:System.Globalization.CultureInfo" />.</param>
        <param name="activationAttributes">Массив атрибутов, которые могут участвовать в активации. Обычно это массив, содержащий один объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />, определяющий URL-адрес, необходимый для активации удаленного объекта.  
  
Этот параметр связан с объектами, активируемыми клиентом. Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений. Сейчас в распределенных приложениях следует использовать Windows Communication Foundation.</param>
        <summary>Создает новый экземпляр заданного типа, определенного в указанной сборке. Параметры определяют средство связывания, флаги привязки, аргументы конструктора, сведения, связанные с языком и региональными параметрами, используемые для интерпретации аргументов, и необязательные атрибуты активации.</summary>
        <returns>Объект, являющийся оболочкой для нового экземпляра, заданного параметром <paramref name="typeName" />. Необходимо распаковать возвращенное значение, чтобы получить доступ к реальному объекту.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 См. раздел <xref:System.Reflection.AssemblyName> для формата `assemblyName`.  
  
 Попытка вызвать <xref:System.AppDomain.CreateInstance%2A> в домене целевого приложения, который не является текущим доменом приложения, приведет к успешной загрузке сборки в целевом домене приложения. Поскольку <xref:System.Reflection.Assembly> не <xref:System.MarshalByRefObject>, когда этот метод пытается вернуть <xref:System.Reflection.Assembly> для загруженной сборки в текущий домен приложения, среда CLR будет пытаться загрузить сборку в текущий домен приложения, и загрузка может завершиться ошибкой. Сборка, загруженная в текущий домен приложения, может отличаться от сборки, которая была загружена первой, если параметры пути для двух доменов приложений различаются.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="assemblyName" /> или <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">Тип <paramref name="assemblyName" /> не является допустимой сборкой.  
  
-или- 
 Сборка <paramref name="assemblyName" /> была скомпилирована в более поздней версии среды CLR, чем версия, загруженная в текущий момент.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль были загружены дважды с двумя разными свидетельствами.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл <paramref name="assemblyName" /> не найден.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий код не имеет разрешения на вызов этого конструктора.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий конструктор не найден.</exception>
        <exception cref="T:System.NotSupportedException">Вызывающий код не может предоставить атрибуты активации для объекта, не являющегося наследником <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" /> в сборке <paramref name="assemblyName" /> не найден.</exception>
        <exception cref="T:System.NullReferenceException">Данный экземпляр имеет значение <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">для возможности чтения файла, содержащего манифест сборки. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">значение для возможности доступа к расположению сборки, если сборка не является локальной.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности вызова неуправляемого кода при создании экземпляра делегата. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">для возможности вызова операций для всех членов типа. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" Index="8" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Отображаемое имя сборки. См. <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Полное имя запрошенного типа, включая пространство имен, но не сборку, возвращаемое свойством <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Логическое значение, указывающее, следует ли учитывать регистр при поиске.</param>
        <param name="bindingAttr">Сочетание битовых флагов (от нуля и более), влияющих на поиск конструктора <paramref name="typeName" />. Если значение параметра <paramref name="bindingAttr" /> равно нулю, проводится поиск открытых конструкторов с учетом регистра.</param>
        <param name="binder">Объект, позволяющий осуществлять привязку, приведение типов аргументов, вызов элементов, а также поиск объектов <see cref="T:System.Reflection.MemberInfo" /> с помощью отражения. Если значением параметра <paramref name="binder" /> является null, то используется средство связывания по умолчанию.</param>
        <param name="args">Аргументы для передачи конструктору. Массив аргументов должен соответствовать по числу, порядку и типу параметров вызываемому конструктору. Если предпочтителен конструктор без параметров, то объект <paramref name="args" /> должен быть пустым массивом или значением NULL.</param>
        <param name="culture">Сведения о языке и региональных параметрах, которые влияют на приведение <paramref name="args" /> к формальным типам, объявленным для конструктора <paramref name="typeName" />. Если значение параметра <paramref name="culture" /> равно <see langword="null" />, для текущего потока используется объект <see cref="T:System.Globalization.CultureInfo" />.</param>
        <param name="activationAttributes">Массив атрибутов, которые могут участвовать в активации. Обычно это массив, содержащий один объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />, определяющий URL-адрес, необходимый для активации удаленного объекта.  
  
Этот параметр связан с объектами, активируемыми клиентом. Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений. Сейчас в распределенных приложениях следует использовать Windows Communication Foundation.</param>
        <param name="securityAttributes">Сведения, используемые для авторизации создания <paramref name="typeName" />.</param>
        <summary>Создает новый экземпляр заданного типа, определенного в указанной сборке. Параметры определяют средство связывания, флаги привязки, аргументы конструктора, сведения, связанные с языком и региональными параметрами, используемые для интерпретации аргументов, атрибуты активации и авторизацию для создания типа.</summary>
        <returns>Объект, являющийся оболочкой для нового экземпляра, заданного параметром <paramref name="typeName" />. Необходимо распаковать возвращенное значение, чтобы получить доступ к реальному объекту.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 См. раздел <xref:System.Reflection.AssemblyName> для формата `assemblyName`.  
  
 Попытка вызвать <xref:System.AppDomain.CreateInstance%2A> в домене целевого приложения, который не является текущим доменом приложения, приведет к успешной загрузке сборки в целевом домене приложения. Поскольку <xref:System.Reflection.Assembly> не <xref:System.MarshalByRefObject>, когда этот метод пытается вернуть <xref:System.Reflection.Assembly> для загруженной сборки в текущий домен приложения, среда CLR будет пытаться загрузить сборку в текущий домен приложения, и загрузка может завершиться ошибкой. Сборка, загруженная в текущий домен приложения, может отличаться от сборки, которая была загружена первой, если параметры пути для двух доменов приложений различаются.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="assemblyName" /> или <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">Тип <paramref name="assemblyName" /> не является допустимой сборкой.  
  
-или- 
В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyName" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль были загружены дважды с двумя разными свидетельствами.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл <paramref name="assemblyName" /> не найден.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий код не имеет разрешения на вызов этого конструктора.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий конструктор не найден.</exception>
        <exception cref="T:System.NotSupportedException">Вызывающий код не может предоставить атрибуты активации для объекта, не являющегося наследником <see cref="T:System.MarshalByRefObject" />.  
  
-или- 
 Значение <paramref name="securityAttributes" /> не <see langword="null" />. Когда устаревшие политики разграничения доступа кода не включены, <paramref name="securityAttributes" /> должен равняться <see langword="null." />.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" /> в сборке <paramref name="assemblyName" /> не найден.</exception>
        <exception cref="T:System.NullReferenceException">Данный экземпляр имеет значение <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">для возможности чтения файла, содержащего манифест сборки. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">значение для возможности доступа к расположению сборки, если сборка не является локальной.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для предоставления свидетельства. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">для возможности вызова операций для всех членов типа. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает новый экземпляр заданного типа.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Отображаемое имя сборки. См. <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Полное имя запрошенного типа, включая пространство имен, но не сборку, возвращаемое свойством <see cref="P:System.Type.FullName" />.</param>
        <summary>Создает новый экземпляр заданного типа. Параметры задают сборку, где определен тип, и имя типа.</summary>
        <returns>Экземпляр объекта, заданного параметром <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это удобный метод, объединяющий <xref:System.AppDomain.CreateInstance%2A> и <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>. Этот метод вызывает конструктор без параметров для `typeName`.  
  
 См. раздел <xref:System.Reflection.AssemblyName> для формата `assemblyName`. Формат `typeName`см. в свойстве <xref:System.Type.FullName%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Если выполнить вызов метода с ранней привязкой к методу `M` объекта типа `T1`, возвращенного <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, и этот метод выполняет вызов метода с ранней привязкой к методу объекта типа `T2` в сборке `C`, отличной от текущей сборки или сборки, содержащей `T1`, сборка `C` загружается в текущий домен приложения. Эта загрузка происходит даже в том случае, если вызов раннего связывания `T1.M()` был выполнен в тексте <xref:System.Reflection.Emit.DynamicMethod>или в другом динамически создаваемом коде. Если текущий домен является доменом по умолчанию, то сборка `C` не может быть выгружена до завершения процесса. Если текущий домен позже пытается загрузить сборку `C`, может произойти сбой загрузки.  
  
   
  
## Examples  
 В следующем примере кода показан самый простой способ выполнения кода в другом домене приложения. В примере определяется класс с именем `Worker`, наследуемый от <xref:System.MarshalByRefObject>. Класс `Worker` определяет метод, который отображает имя домена приложения, в котором оно выполняется. В примере создаются экземпляры `Worker` в домене приложения по умолчанию и в новом домене приложения.  
  
> [!NOTE]
>  Сборка, содержащая `Worker`, должна быть загружена в оба домена приложений, но может загружать другие сборки, существующие только в новом домене приложения.  
  
 [!code-cpp[CreateInstanceAndUnwrap2#1](~/samples/snippets/cpp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cpp/source.cpp#1)]
 [!code-csharp[CreateInstanceAndUnwrap2#1](~/samples/snippets/csharp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cs/source.cs#1)]
 [!code-vb[CreateInstanceAndUnwrap2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CreateInstanceAndUnwrap2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="assemblyName" /> или <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий общий конструктор не найден.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" /> в сборке <paramref name="assemblyName" /> не найден.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл <paramref name="assemblyName" /> не найден.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий код не имеет разрешения на вызов этого конструктора.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <exception cref="T:System.BadImageFormatException">Тип <paramref name="assemblyName" /> не является допустимой сборкой.  
  
-или- 
В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyName" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль были загружены дважды с двумя разными свидетельствами.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">для возможности чтения файла, содержащего манифест сборки, или при создании типа из модуля, отличного от файла манифеста. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">значение для возможности доступа к расположению сборки, если сборка не является локальной.</permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * obj[] -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="2" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Отображаемое имя сборки. См. <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Полное имя запрошенного типа, включая пространство имен, но не сборку, возвращаемое свойством <see cref="P:System.Type.FullName" />.</param>
        <param name="activationAttributes">Массив атрибутов, которые могут участвовать в активации. Обычно это массив, содержащий один объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />, определяющий URL-адрес, необходимый для активации удаленного объекта.  
  
Этот параметр связан с объектами, активируемыми клиентом. Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений. Сейчас в распределенных приложениях следует использовать Windows Communication Foundation.</param>
        <summary>Создает новый экземпляр заданного типа. Параметры задают сборку, где определен тип, имя типа и массив атрибутов активации.</summary>
        <returns>Экземпляр объекта, заданного параметром <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это удобный метод, объединяющий <xref:System.AppDomain.CreateInstance%2A> и <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>. Этот метод вызывает конструктор без параметров для `typeName`.  
  
 См. раздел <xref:System.Reflection.AssemblyName> для формата `assemblyName`. Формат `typeName`см. в свойстве <xref:System.Type.FullName%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Если выполнить вызов метода с ранней привязкой к методу `M` объекта типа `T1`, возвращенного <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, и этот метод выполняет вызов метода с ранней привязкой к методу объекта типа `T2` в сборке `C`, отличной от текущей сборки или сборки, содержащей `T1`, сборка `C` загружается в текущий домен приложения. Эта загрузка происходит даже в том случае, если вызов раннего связывания `T1.M()` был выполнен в тексте <xref:System.Reflection.Emit.DynamicMethod>или в другом динамически создаваемом коде. Если текущий домен является доменом по умолчанию, то сборка `C` не может быть выгружена до завершения процесса. Если текущий домен позже пытается загрузить сборку `C`, может произойти сбой загрузки.  
  
   
  
## Examples  
 [!code-cpp[ADDyno#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="assemblyName" /> или <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий общий конструктор не найден.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" /> в сборке <paramref name="assemblyName" /> не найден.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл <paramref name="assemblyName" /> не найден.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий код не имеет разрешения на вызов этого конструктора.</exception>
        <exception cref="T:System.NotSupportedException">Вызывающий код не может предоставить атрибуты активации для объекта, не являющегося наследником <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <exception cref="T:System.BadImageFormatException">Тип <paramref name="assemblyName" /> не является допустимой сборкой.  
  
-или- 
В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyName" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль были загружены дважды с двумя разными свидетельствами.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">для возможности чтения файла, содержащего манифест сборки. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">значение для возможности доступа к расположению сборки, если сборка не является локальной.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности вызова неуправляемого кода при создании экземпляра делегата. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">для возможности вызова операций для всех членов типа. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Отображаемое имя сборки. См. <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Полное имя запрошенного типа, включая пространство имен, но не сборку, возвращаемое свойством <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Логическое значение, указывающее, следует ли учитывать регистр при поиске.</param>
        <param name="bindingAttr">Сочетание битовых флагов (от нуля и более), влияющих на поиск конструктора <paramref name="typeName" />. Если значение параметра <paramref name="bindingAttr" /> равно нулю, проводится поиск открытых конструкторов с учетом регистра.</param>
        <param name="binder">Объект, позволяющий осуществлять привязку, приведение типов аргументов, вызов элементов, а также поиск объектов <see cref="T:System.Reflection.MemberInfo" /> с помощью отражения. Если значением параметра <paramref name="binder" /> является null, то используется средство связывания по умолчанию.</param>
        <param name="args">Аргументы для передачи конструктору. Массив аргументов должен соответствовать по числу, порядку и типу параметров вызываемому конструктору. Если предпочтителен конструктор без параметров, то объект <paramref name="args" /> должен быть пустым массивом или значением NULL.</param>
        <param name="culture">Объект, зависящий от языка и региональных параметров, который используется для управления приведением типов. Если значение параметра <paramref name="culture" /> равно <see langword="null" />, для текущего потока используется объект <see langword="CultureInfo" />.</param>
        <param name="activationAttributes">Массив атрибутов, которые могут участвовать в активации. Как правило, массив, который содержит единственный объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />. который определяет URL-адрес, необходимый для активации удаленного объекта.  
  
Этот параметр связан с объектами, активируемыми клиентом. Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений. Сейчас в распределенных приложениях следует использовать Windows Communication Foundation.</param>
        <summary>Создает новый экземпляр заданного типа, определенного в заданной сборке, указывая, игнорируется ли регистр имени типа; атрибуты привязки и средство привязки, используемые для выбора создаваемого типа; аргументы конструктора; язык и региональные параметры; и атрибуты активации.</summary>
        <returns>Экземпляр объекта, заданного параметром <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это удобный метод, объединяющий <xref:System.AppDomain.CreateInstance%2A> и <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 См. раздел <xref:System.Reflection.AssemblyName> для формата `assemblyName`. Формат `typeName`см. в свойстве <xref:System.Type.FullName%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Если выполнить вызов метода с ранней привязкой к методу `M` объекта типа `T1`, возвращенного <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, и этот метод выполняет вызов метода с ранней привязкой к методу объекта типа `T2` в сборке `C`, отличной от текущей сборки или сборки, содержащей `T1`, сборка `C` загружается в текущий домен приложения. Эта загрузка происходит даже в том случае, если вызов раннего связывания `T1.M()` был выполнен в тексте <xref:System.Reflection.Emit.DynamicMethod>или в другом динамически создаваемом коде. Если текущий домен является доменом по умолчанию, то сборка `C` не может быть выгружена до завершения процесса. Если текущий домен позже пытается загрузить сборку `C`, может произойти сбой загрузки.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование параметра `ignoreCase`.  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="assemblyName" /> или <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий конструктор не найден.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" /> в сборке <paramref name="assemblyName" /> не найден.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл <paramref name="assemblyName" /> не найден.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий код не имеет разрешения на вызов этого конструктора.</exception>
        <exception cref="T:System.NotSupportedException">Вызывающий код не может предоставить атрибуты активации для объекта, не являющегося наследником <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <exception cref="T:System.BadImageFormatException">Тип <paramref name="assemblyName" /> не является допустимой сборкой.  
  
-или- 
 Сборка <paramref name="assemblyName" /> была скомпилирована в более поздней версии среды CLR, чем версия, загруженная в текущий момент.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль были загружены дважды с двумя разными свидетельствами.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">для возможности чтения файла, содержащего манифест сборки. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">значение для возможности доступа к расположению сборки, если сборка не является локальной.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности вызова неуправляемого кода при создании экземпляра делегата. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">для возможности вызова операций для всех членов типа. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceAndUnwrap which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" Index="8" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Отображаемое имя сборки. См. <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Полное имя запрошенного типа, включая пространство имен, но не сборку, возвращаемое свойством <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Логическое значение, указывающее, следует ли учитывать регистр при поиске.</param>
        <param name="bindingAttr">Сочетание битовых флагов (от нуля и более), влияющих на поиск конструктора <paramref name="typeName" />. Если значение параметра <paramref name="bindingAttr" /> равно нулю, проводится поиск открытых конструкторов с учетом регистра.</param>
        <param name="binder">Объект, позволяющий осуществлять привязку, приведение типов аргументов, вызов элементов, а также поиск объектов <see cref="T:System.Reflection.MemberInfo" /> с помощью отражения. Если значением параметра <paramref name="binder" /> является null, то используется средство связывания по умолчанию.</param>
        <param name="args">Аргументы для передачи конструктору. Массив аргументов должен соответствовать по числу, порядку и типу параметров вызываемому конструктору. Если предпочтителен конструктор без параметров, то объект <paramref name="args" /> должен быть пустым массивом или значением NULL.</param>
        <param name="culture">Объект, зависящий от языка и региональных параметров, который используется для управления приведением типов. Если значение параметра <paramref name="culture" /> равно <see langword="null" />, для текущего потока используется объект <see langword="CultureInfo" />.</param>
        <param name="activationAttributes">Массив атрибутов, которые могут участвовать в активации. Обычно это массив, содержащий один объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />, определяющий URL-адрес, необходимый для активации удаленного объекта.  
  
Этот параметр связан с объектами, активируемыми клиентом. Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений. Сейчас в распределенных приложениях следует использовать Windows Communication Foundation.</param>
        <param name="securityAttributes">Сведения, используемые для авторизации создания <paramref name="typeName" />.</param>
        <summary>Создает новый экземпляр заданного типа. Параметры определяют имя типа, а также способ его поиска и создания.</summary>
        <returns>Экземпляр объекта, заданного параметром <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это удобный метод, объединяющий <xref:System.AppDomain.CreateInstance%2A> и <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 См. раздел <xref:System.Reflection.AssemblyName> для формата `assemblyName`. Формат `typeName`см. в свойстве <xref:System.Type.FullName%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Если выполнить вызов метода с ранней привязкой к методу `M` объекта типа `T1`, возвращенного <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, и этот метод выполняет вызов метода с ранней привязкой к методу объекта типа `T2` в сборке `C`, отличной от текущей сборки или сборки, содержащей `T1`, сборка `C` загружается в текущий домен приложения. Эта загрузка происходит даже в том случае, если вызов раннего связывания `T1.M()` был выполнен в тексте <xref:System.Reflection.Emit.DynamicMethod>или в другом динамически создаваемом коде. Если текущий домен является доменом по умолчанию, то сборка `C` не может быть выгружена до завершения процесса. Если текущий домен позже пытается загрузить сборку `C`, может произойти сбой загрузки.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование параметра `ignoreCase`.  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="assemblyName" /> или <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий конструктор не найден.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" /> в сборке <paramref name="assemblyName" /> не найден.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл <paramref name="assemblyName" /> не найден.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий код не имеет разрешения на вызов этого конструктора.</exception>
        <exception cref="T:System.NotSupportedException">Вызывающий код не может предоставить атрибуты активации для объекта, не являющегося наследником <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <exception cref="T:System.BadImageFormatException">Тип <paramref name="assemblyName" /> не является допустимой сборкой.  
  
-или- 
В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyName" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль были загружены дважды с двумя разными свидетельствами.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">для возможности чтения файла, содержащего манифест сборки. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">значение для возможности доступа к расположению сборки, если сборка не является локальной.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для загрузки сборки с свидетельством. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">для возможности вызова операций для всех членов типа. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает новый экземпляр заданного типа, определенного в указанном файле сборки.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName);" FrameworkAlternate="netcore-3.0;netcore-3.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName)" FrameworkAlternate="netcore-3.0;netcore-3.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Имя (включая путь) файла, который содержит сборку, определяющую запрошенный тип. Сборка загружается с помощью метода <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />.</param>
        <param name="typeName">Полное имя запрошенного типа, включая пространство имен, но не сборку, возвращаемое свойством <see cref="P:System.Type.FullName" />.</param>
        <summary>Создает новый экземпляр заданного типа, определенного в указанном файле сборки.</summary>
        <returns>Объект, являющийся оболочкой для нового экземпляра, или значение <see langword="null" />, если <paramref name="typeName" /> не найден. Необходимо распаковать возвращенное значение, чтобы получить доступ к реальному объекту.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызывается конструктор без параметров для `typeName`.  
  
 Дополнительные сведения см. в описании метода <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.  
  
 Если метод <xref:System.AppDomain.CreateInstanceFrom%2A> используется для создания экземпляра в целевом домене приложения, отличном от домена приложения, из которого выполняется вызов, сборка загружается в целевой домен приложения. Однако если экземпляр не упакован в вызывающий домен приложения, использование неупакованного экземпляра в определенных случаях может привести к загрузке сборки в домен вызывающего приложения. Например, после развернутого экземпляра можно запросить сведения о его типе, чтобы вызвать его методы с поздней привязкой. При загрузке сборки в домен вызывающего приложения могут возникать исключения.  
  
-   Если другая версия той же сборки была ранее загружена в вызывающий домен приложения или если путь загрузки вызывающего домена приложения отличается от пути к целевому домену приложения, могут возникнуть исключения, такие как <xref:System.MissingMethodException>.  
  
-   Если вызывающий домен приложения выполняет вызовы к типу экземпляра с ранней привязкой, <xref:System.InvalidCastException> могут быть вызваны при попытке привести экземпляр.  
  
   
  
## Examples  
 В следующем примере показано, как использовать перегрузку метода <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> для создания экземпляра объекта в целевом домене приложения и вызова его методов.  
  
 В примере определяется класс `MarshalableExample`, который можно маршалировать между границами домена приложения. В этом примере выполняется сборка пути к выполняемой в данный момент сборке, создание целевого домена приложения и использование перегрузки метода <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> для загрузки сборки примера в целевой домен приложения и создания экземпляра `MarshalableExample`.  
  
> [!NOTE]
>  В этом примере путь является абсолютным, но относительный путь также будет работать, поскольку для загрузки сборки используется метод <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>.  
  
 После распаковки маркера объекта в примере демонстрируются три способа использования объекта в целевом домене приложения:  
  
-   Вызов метода с поздним связыванием с помощью отражения. Для этого требуются сведения о типе, что приводит к загрузке сборки в домен приложения вызывающего объекта. (В этом примере он уже загружен.)  
  
-   Приведение объекта к интерфейсу, известному как вызывающему, так и вызываемому. Если интерфейс определен в вызывающей сборке или в третьей сборке, на которую ссылается вызывающий и вызываемый объект, то вызываемая сборка не загружается в домен приложения вызывающего объекта.  
  
-   Использование объекта непосредственно, если его тип известен вызывающему объекту. Сборка должна быть загружена в домен приложения вызывающей стороны.  
  
 Другой способ избежать загрузки вызываемой сборки в домен приложения вызывающего объекта заключается в том, чтобы вызывающий объект был производным от класса <xref:System.MarshalByRefObject> и был определен метод, который может выполняться в целевом домене приложения. Этот метод может использовать отражение для проверки целевой сборки, так как целевая сборка уже загружена в целевой домен приложения. См. пример для свойства <xref:System.AppDomain.DynamicDirectory%2A>.  
  
 [!code-cpp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cpp/example.cpp#1)]
 [!code-csharp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cs/example.cs#1)]
 [!code-vb[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="assemblyFile" /> имеет значение <see langword="null" />.  
  
-или- 
 Свойство <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл <paramref name="assemblyFile" /> не найден.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" /> в сборке <paramref name="assemblyFile" /> не найден.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <exception cref="T:System.MissingMethodException">Открытый конструктор без параметров не найден.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий код не имеет достаточных разрешений на вызов этого конструктора.</exception>
        <exception cref="T:System.BadImageFormatException">Тип <paramref name="assemblyFile" /> не является допустимой сборкой.  
  
-или- 
В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyFile" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль были загружены дважды с двумя разными свидетельствами.</exception>
        <exception cref="T:System.NullReferenceException">Данный экземпляр имеет значение <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">для возможности чтения файла, содержащего манифест сборки. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">значение для возможности доступа к расположению сборки, если сборка не является локальной.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" FrameworkAlternate="netcore-3.0;netcore-3.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, activationAttributes)" FrameworkAlternate="netcore-3.0;netcore-3.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, activationAttributes)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="2" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Имя (включая путь) файла, который содержит сборку, определяющую запрошенный тип. Сборка загружается с помощью метода <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />.</param>
        <param name="typeName">Полное имя запрошенного типа, включая пространство имен, но не сборку, возвращаемое свойством <see cref="P:System.Type.FullName" />.</param>
        <param name="activationAttributes">Массив атрибутов, которые могут участвовать в активации. Обычно это массив, содержащий один объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />, определяющий URL-адрес, необходимый для активации удаленного объекта.  
  
Этот параметр связан с объектами, активируемыми клиентом. Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений. Сейчас в распределенных приложениях следует использовать Windows Communication Foundation.</param>
        <summary>Создает новый экземпляр заданного типа, определенного в указанном файле сборки.</summary>
        <returns>Объект, являющийся оболочкой для нового экземпляра, или значение <see langword="null" />, если <paramref name="typeName" /> не найден. Необходимо распаковать возвращенное значение, чтобы получить доступ к реальному объекту.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызывается конструктор без параметров для `typeName`.  
  
 Дополнительные сведения об этом методе см. в описании метода <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.  
  
 Если метод <xref:System.AppDomain.CreateInstanceFrom%2A> используется для создания экземпляра в целевом домене приложения, отличном от домена приложения, из которого выполняется вызов, сборка загружается в целевой домен приложения. Однако если экземпляр не упакован в вызывающий домен приложения, использование неупакованного экземпляра в определенных случаях может привести к загрузке сборки в домен вызывающего приложения. Например, после развернутого экземпляра можно запросить сведения о его типе, чтобы вызвать его методы с поздней привязкой. При загрузке сборки в домен вызывающего приложения могут возникать исключения.  
  
-   Если другая версия той же сборки была ранее загружена в вызывающий домен приложения или если путь загрузки вызывающего домена приложения отличается от пути к целевому домену приложения, могут возникнуть исключения, такие как <xref:System.MissingMethodException>.  
  
-   Если вызывающий домен приложения выполняет вызовы к типу экземпляра с ранней привязкой, <xref:System.InvalidCastException> могут быть вызваны при попытке привести экземпляр.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="assemblyFile" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл <paramref name="assemblyFile" /> не найден.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" /> в сборке <paramref name="assemblyFile" /> не найден.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий код не имеет достаточных разрешений на вызов этого конструктора.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий общий конструктор не найден.</exception>
        <exception cref="T:System.NotSupportedException">Вызывающий код не может предоставить атрибуты активации для объекта, не являющегося наследником <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <exception cref="T:System.BadImageFormatException">Тип <paramref name="assemblyFile" /> не является допустимой сборкой.  
  
-или- 
В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyFile" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль были загружены дважды с двумя разными свидетельствами.</exception>
        <exception cref="T:System.NullReferenceException">Данный экземпляр имеет значение <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">для возможности чтения файла, содержащего манифест сборки. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">значение для возможности доступа к расположению сборки, если сборка не является локальной.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Имя (включая путь) файла, который содержит сборку, определяющую запрошенный тип. Сборка загружается с помощью метода <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />.</param>
        <param name="typeName">Полное имя запрошенного типа, включая пространство имен, но не сборку, возвращаемое свойством <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Логическое значение, указывающее, следует ли учитывать регистр при поиске.</param>
        <param name="bindingAttr">Сочетание битовых флагов (от нуля и более), влияющих на поиск конструктора <paramref name="typeName" />. Если значение параметра <paramref name="bindingAttr" /> равно нулю, проводится поиск открытых конструкторов с учетом регистра.</param>
        <param name="binder">Объект, который допускает привязку, приведение типов аргументов, вызов элементов и извлечение объектов <see cref="T:System.Reflection.MemberInfo" /> путем отражения. Если значением параметра <paramref name="binder" /> является null, то используется средство связывания по умолчанию.</param>
        <param name="args">Аргументы для передачи конструктору. Массив аргументов должен соответствовать по числу, порядку и типу параметров вызываемому конструктору. Если предпочтителен конструктор без параметров, то объект <paramref name="args" /> должен быть пустым массивом или значением NULL.</param>
        <param name="culture">Сведения о языке и региональных параметрах, которые влияют на приведение <paramref name="args" /> к формальным типам, объявленным для конструктора <paramref name="typeName" />. Если значение параметра <paramref name="culture" /> равно <see langword="null" />, для текущего потока используется объект <see cref="T:System.Globalization.CultureInfo" />.</param>
        <param name="activationAttributes">Массив атрибутов, которые могут участвовать в активации. Обычно это массив, содержащий один объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />, определяющий URL-адрес, необходимый для активации удаленного объекта.  
  
Этот параметр связан с объектами, активируемыми клиентом. Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений. Сейчас в распределенных приложениях следует использовать Windows Communication Foundation.</param>
        <summary>Создает новый экземпляр заданного типа, определенного в указанном файле сборки.</summary>
        <returns>Объект, являющийся оболочкой для нового экземпляра, или значение <see langword="null" />, если <paramref name="typeName" /> не найден. Необходимо распаковать возвращенное значение, чтобы получить доступ к реальному объекту.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения см. в описании метода <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.  
  
 Если метод <xref:System.AppDomain.CreateInstanceFrom%2A> используется для создания экземпляра в целевом домене приложения, отличном от домена приложения, из которого выполняется вызов, сборка загружается в целевой домен приложения. Однако если экземпляр не упакован в вызывающий домен приложения, использование неупакованного экземпляра в определенных случаях может привести к загрузке сборки в домен вызывающего приложения. Например, после развернутого экземпляра можно запросить сведения о его типе, чтобы вызвать его методы с поздней привязкой. При загрузке сборки в домен вызывающего приложения могут возникать исключения.  
  
-   Если другая версия той же сборки была ранее загружена в вызывающий домен приложения или если путь загрузки вызывающего домена приложения отличается от пути к целевому домену приложения, могут возникнуть исключения, такие как <xref:System.MissingMethodException>.  
  
-   Если вызывающий домен приложения выполняет вызовы к типу экземпляра с ранней привязкой, <xref:System.InvalidCastException> могут быть вызваны при попытке привести экземпляр.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="assemblyFile" /> имеет значение <see langword="null" />.  
  
-или- 
 Свойство <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Вызывающий код не может предоставить атрибуты активации для объекта, не являющегося наследником <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл <paramref name="assemblyFile" /> не найден.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" /> в сборке <paramref name="assemblyFile" /> не найден.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий общий конструктор не найден.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий код не имеет достаточных разрешений на вызов этого конструктора.</exception>
        <exception cref="T:System.BadImageFormatException">Тип <paramref name="assemblyFile" /> не является допустимой сборкой.  
  
-или- 
 Сборка <paramref name="assemblyFile" /> была скомпилирована в более поздней версии среды CLR, чем версия, загруженная в текущий момент.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль были загружены дважды с двумя разными свидетельствами.</exception>
        <exception cref="T:System.NullReferenceException">Данный экземпляр имеет значение <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">для возможности чтения файла, содержащего манифест сборки. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">значение для возможности доступа к расположению сборки, если сборка не является локальной.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" Index="8" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Имя (включая путь) файла, который содержит сборку, определяющую запрошенный тип. Сборка загружается с помощью метода <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />.</param>
        <param name="typeName">Полное имя запрошенного типа, включая пространство имен, но не сборку, возвращаемое свойством <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Логическое значение, указывающее, следует ли учитывать регистр при поиске.</param>
        <param name="bindingAttr">Сочетание битовых флагов (от нуля и более), влияющих на поиск конструктора <paramref name="typeName" />. Если значение параметра <paramref name="bindingAttr" /> равно нулю, проводится поиск открытых конструкторов с учетом регистра.</param>
        <param name="binder">Объект, который допускает привязку, приведение типов аргументов, вызов элементов и извлечение объектов <see cref="T:System.Reflection.MemberInfo" /> путем отражения. Если значением параметра <paramref name="binder" /> является null, то используется средство связывания по умолчанию.</param>
        <param name="args">Аргументы для передачи конструктору. Массив аргументов должен соответствовать по числу, порядку и типу параметров вызываемому конструктору. Если предпочтителен конструктор без параметров, то объект <paramref name="args" /> должен быть пустым массивом или значением NULL.</param>
        <param name="culture">Сведения о языке и региональных параметрах, которые влияют на приведение <paramref name="args" /> к формальным типам, объявленным для конструктора <paramref name="typeName" />. Если значение параметра <paramref name="culture" /> равно <see langword="null" />, для текущего потока используется объект <see cref="T:System.Globalization.CultureInfo" />.</param>
        <param name="activationAttributes">Массив атрибутов, которые могут участвовать в активации. Обычно это массив, содержащий один объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />, определяющий URL-адрес, необходимый для активации удаленного объекта.  
  
Этот параметр связан с объектами, активируемыми клиентом. Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений. Сейчас в распределенных приложениях следует использовать Windows Communication Foundation.</param>
        <param name="securityAttributes">Сведения, используемые для авторизации создания <paramref name="typeName" />.</param>
        <summary>Создает новый экземпляр заданного типа, определенного в указанном файле сборки.</summary>
        <returns>Объект, являющийся оболочкой для нового экземпляра, или значение <see langword="null" />, если <paramref name="typeName" /> не найден. Необходимо распаковать возвращенное значение, чтобы получить доступ к реальному объекту.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения об этом методе см. в описании метода <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.  
  
 Если метод <xref:System.AppDomain.CreateInstanceFrom%2A> используется для создания экземпляра в целевом домене приложения, отличном от домена приложения, из которого выполняется вызов, сборка загружается в целевой домен приложения. Однако если экземпляр не упакован в вызывающий домен приложения, использование неупакованного экземпляра в определенных случаях может привести к загрузке сборки в домен вызывающего приложения. Например, после развернутого экземпляра можно запросить сведения о его типе, чтобы вызвать его методы с поздней привязкой. При загрузке сборки в домен вызывающего приложения могут возникать исключения.  
  
-   Если другая версия той же сборки была ранее загружена в вызывающий домен приложения или если путь загрузки вызывающего домена приложения отличается от пути к целевому домену приложения, могут возникнуть исключения, такие как <xref:System.MissingMethodException>.  
  
-   Если вызывающий домен приложения выполняет вызовы к типу экземпляра с ранней привязкой, <xref:System.InvalidCastException> могут быть вызваны при попытке привести экземпляр.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="assemblyFile" /> имеет значение <see langword="null" />.  
  
-или- 
 Свойство <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Вызывающий код не может предоставить атрибуты активации для объекта, не являющегося наследником <see cref="T:System.MarshalByRefObject" />.  
  
-или- 
 Значение <paramref name="securityAttributes" /> не <see langword="null" />. Когда устаревшие политики разграничения доступа кода не включены, <paramref name="securityAttributes" /> должен равняться <see langword="null" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл <paramref name="assemblyFile" /> не найден.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" /> в сборке <paramref name="assemblyFile" /> не найден.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий общий конструктор не найден.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий код не имеет достаточных разрешений на вызов этого конструктора.</exception>
        <exception cref="T:System.BadImageFormatException">Тип <paramref name="assemblyFile" /> не является допустимой сборкой.  
  
-или- 
В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyFile" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль были загружены дважды с двумя разными свидетельствами.</exception>
        <exception cref="T:System.NullReferenceException">Данный экземпляр имеет значение <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">для возможности чтения файла, содержащего манифест сборки. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">значение для возможности доступа к расположению сборки, если сборка не является локальной.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для предоставления свидетельства. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFromAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает новый экземпляр заданного типа, определенного в указанном файле сборки.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName);" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyFile As String, typeName As String) As Object" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyFile, System::String ^ typeName);" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyFile, typeName)" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String) As Object" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Имя файла и путь сборки, в которой определен запрошенный тип.</param>
        <param name="assemblyFile">To be added.</param>
        <param name="typeName">Полное имя запрошенного типа, включая пространство имен, но не сборку, возвращаемое свойством <see cref="P:System.Type.FullName" />.</param>
        <summary>Создает новый экземпляр заданного типа, определенного в указанном файле сборки.</summary>
        <returns>Запрашиваемый объект или значение <see langword="null" />, если тип <paramref name="typeName" /> не найден.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это удобный метод, объединяющий <xref:System.AppDomain.CreateInstanceFrom%2A> и <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>. Этот метод вызывает конструктор без параметров для `typeName`.  
  
 Дополнительные сведения см. в описании метода <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="assemblyName" /> имеет значение <see langword="null" />.  
  
-или- 
 Свойство <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл <paramref name="assemblyName" /> не найден.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" /> в сборке <paramref name="assemblyName" /> не найден.</exception>
        <exception cref="T:System.MissingMethodException">Открытый конструктор без параметров не найден.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий код не имеет достаточных разрешений на вызов этого конструктора.</exception>
        <exception cref="T:System.BadImageFormatException">Тип <paramref name="assemblyName" /> не является допустимой сборкой.  
  
-или- 
В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyName" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль были загружены дважды с двумя разными свидетельствами.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">для возможности чтения файла, содержащего манифест сборки. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">значение для возможности доступа к расположению сборки, если сборка не является локальной.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName, object[] activationAttributes);" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, object[] activationAttributes) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyFile As String, typeName As String, activationAttributes As Object()) As Object" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * obj[] -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyFile, typeName, activationAttributes)" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * obj[] -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName, activationAttributes)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="2" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Имя файла и путь сборки, в которой определен запрошенный тип.</param>
        <param name="assemblyFile">To be added.</param>
        <param name="typeName">Полное имя запрошенного типа, включая пространство имен, но не сборку (см. описание свойства <see cref="P:System.Type.FullName" />).</param>
        <param name="activationAttributes">Массив атрибутов, которые могут участвовать в активации. Обычно это массив, содержащий один объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />, определяющий URL-адрес, необходимый для активации удаленного объекта.  
  
Этот параметр связан с объектами, активируемыми клиентом. Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений. Сейчас в распределенных приложениях следует использовать Windows Communication Foundation.</param>
        <summary>Создает новый экземпляр заданного типа, определенного в указанном файле сборки.</summary>
        <returns>Запрашиваемый объект или значение <see langword="null" />, если тип <paramref name="typeName" /> не найден.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это удобный метод, объединяющий <xref:System.AppDomain.CreateInstanceFrom%2A> и <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>. Этот метод вызывает конструктор без параметров для `typeName`.  
  
 Дополнительные сведения об этом методе см. в описании метода <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="assemblyName" /> имеет значение <see langword="null" />.  
  
-или- 
 Свойство <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Вызывающий код не может предоставить атрибуты активации для объекта, не являющегося наследником <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл <paramref name="assemblyName" /> не найден.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" /> в сборке <paramref name="assemblyName" /> не найден.</exception>
        <exception cref="T:System.MissingMethodException">Открытый конструктор без параметров не найден.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий код не имеет достаточных разрешений на вызов этого конструктора.</exception>
        <exception cref="T:System.BadImageFormatException">Тип <paramref name="assemblyName" /> не является допустимой сборкой.  
  
-или- 
В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyName" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль были загружены дважды с двумя разными свидетельствами.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">для возможности чтения файла, содержащего манифест сборки. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">значение для возможности доступа к расположению сборки, если сборка не является локальной.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Имя файла и путь сборки, в которой определен запрошенный тип.</param>
        <param name="typeName">Полное имя запрошенного типа, включая пространство имен, но не сборку, возвращаемое свойством <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Логическое значение, указывающее, следует ли учитывать регистр при поиске.</param>
        <param name="bindingAttr">Сочетание битовых флагов (от нуля и более), влияющих на поиск конструктора <paramref name="typeName" />. Если значение параметра <paramref name="bindingAttr" /> равно нулю, проводится поиск открытых конструкторов с учетом регистра.</param>
        <param name="binder">Объект, который допускает привязку, приведение типов аргументов, вызов элементов и извлечение объектов <see cref="T:System.Reflection.MemberInfo" /> путем отражения. Если значением параметра <paramref name="binder" /> является null, то используется средство связывания по умолчанию.</param>
        <param name="args">Аргументы для передачи конструктору. Массив аргументов должен соответствовать по числу, порядку и типу параметров вызываемому конструктору. Если предпочтителен конструктор без параметров, то объект <paramref name="args" /> должен быть пустым массивом или значением NULL.</param>
        <param name="culture">Сведения о языке и региональных параметрах, которые влияют на приведение <paramref name="args" /> к формальным типам, объявленным для конструктора <paramref name="typeName" />. Если значение параметра <paramref name="culture" /> равно <see langword="null" />, для текущего потока используется объект <see cref="T:System.Globalization.CultureInfo" />.</param>
        <param name="activationAttributes">Массив атрибутов, которые могут участвовать в активации. Обычно это массив, содержащий один объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />, определяющий URL-адрес, необходимый для активации удаленного объекта.  
  
Этот параметр связан с объектами, активируемыми клиентом. Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений. Сейчас в распределенных приложениях следует использовать Windows Communication Foundation.</param>
        <summary>Создает новый экземпляр заданного типа, определенного в заданном файле сборки, указывая, игнорируется ли регистр имени типа; атрибуты привязки и средство привязки, используемые для выбора создаваемого типа; аргументы конструктора; язык и региональные параметры; и атрибуты активации.</summary>
        <returns>Запрашиваемый объект или значение <see langword="null" />, если тип <paramref name="typeName" /> не найден.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это удобный метод, объединяющий <xref:System.AppDomain.CreateInstanceFrom%2A> и <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Дополнительные сведения об этом методе см. в описании метода <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="assemblyName" /> имеет значение <see langword="null" />.  
  
-или- 
 Свойство <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Вызывающий код не может предоставить атрибуты активации для объекта, не являющегося наследником <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл <paramref name="assemblyName" /> не найден.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" /> в сборке <paramref name="assemblyName" /> не найден.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий общий конструктор не найден.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий код не имеет достаточных разрешений на вызов этого конструктора.</exception>
        <exception cref="T:System.BadImageFormatException">Тип <paramref name="assemblyName" /> не является допустимой сборкой.  
  
-или- 
 Сборка <paramref name="assemblyName" /> скомпилирована в более поздней версии среды CLR, чем версия, загруженная в текущий момент.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль были загружены дважды с двумя разными свидетельствами.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">для возможности чтения файла, содержащего манифест сборки. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">значение для возможности доступа к расположению сборки, если сборка не является локальной.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFromAndUnwrap which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" Index="8" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Имя файла и путь сборки, в которой определен запрошенный тип.</param>
        <param name="typeName">Полное имя запрошенного типа, включая пространство имен, но не сборку, возвращаемое свойством <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Логическое значение, указывающее, следует ли учитывать регистр при поиске.</param>
        <param name="bindingAttr">Сочетание битовых флагов (от нуля и более), влияющих на поиск конструктора <paramref name="typeName" />. Если значение параметра <paramref name="bindingAttr" /> равно нулю, проводится поиск открытых конструкторов с учетом регистра.</param>
        <param name="binder">Объект, который допускает привязку, приведение типов аргументов, вызов элементов и извлечение объектов <see cref="T:System.Reflection.MemberInfo" /> путем отражения. Если значением параметра <paramref name="binder" /> является null, то используется средство связывания по умолчанию.</param>
        <param name="args">Аргументы для передачи конструктору. Массив аргументов должен соответствовать по числу, порядку и типу параметров вызываемому конструктору. Если предпочтителен конструктор без параметров, то объект <paramref name="args" /> должен быть пустым массивом или значением NULL.</param>
        <param name="culture">Сведения о языке и региональных параметрах, которые влияют на приведение <paramref name="args" /> к формальным типам, объявленным для конструктора <paramref name="typeName" />. Если значение параметра <paramref name="culture" /> равно <see langword="null" />, для текущего потока используется объект <see cref="T:System.Globalization.CultureInfo" />.</param>
        <param name="activationAttributes">Массив атрибутов, которые могут участвовать в активации. Обычно это массив, содержащий один объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />, определяющий URL-адрес, необходимый для активации удаленного объекта.  
  
Этот параметр связан с объектами, активируемыми клиентом. Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений. Сейчас в распределенных приложениях следует использовать Windows Communication Foundation.</param>
        <param name="securityAttributes">Сведения, используемые для авторизации создания <paramref name="typeName" />.</param>
        <summary>Создает новый экземпляр заданного типа, определенного в указанном файле сборки.</summary>
        <returns>Запрашиваемый объект или значение <see langword="null" />, если тип <paramref name="typeName" /> не найден.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это удобный метод, объединяющий <xref:System.AppDomain.CreateInstanceFrom%2A> и <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Дополнительные сведения об этом методе см. в описании метода <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="assemblyName" /> имеет значение <see langword="null" />.  
  
-или- 
 Свойство <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Вызывающий код не может предоставить атрибуты активации для объекта, не являющегося наследником <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл <paramref name="assemblyName" /> не найден.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" /> в сборке <paramref name="assemblyName" /> не найден.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий общий конструктор не найден.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий код не имеет достаточных разрешений на вызов этого конструктора.</exception>
        <exception cref="T:System.BadImageFormatException">Тип <paramref name="assemblyName" /> не является допустимой сборкой.  
  
-или- 
В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyName" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль были загружены дважды с двумя разными свидетельствами.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">для возможности чтения файла, содержащего манифест сборки. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">значение для возможности доступа к расположению сборки, если сборка не является локальной.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CurrentDomain { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.AppDomain CurrentDomain" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.CurrentDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentDomain As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property AppDomain ^ CurrentDomain { AppDomain ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDomain : AppDomain" Usage="System.AppDomain.CurrentDomain" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает текущий домен приложения для текущего объекта <see cref="T:System.Threading.Thread" />.</summary>
        <value>Текущий домен приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода создается новый домен приложения. Свойство <xref:System.AppDomain.CurrentDomain%2A> используется для получения объекта <xref:System.AppDomain>, представляющего текущий домен приложения. Свойство <xref:System.AppDomain.FriendlyName%2A> предоставляет имя текущего домена приложения, которое затем отображается в командной строке.  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineDynamicAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Определяет динамическую сборку в текущем домене приложения.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access) cil managed" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access)" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Уникальный идентификатор динамической сборки.</param>
        <param name="access">Режим доступа для динамической сборки.</param>
        <summary>Определяет динамическую сборку с указанным именем и режимом доступа.</summary>
        <returns>Динамическая сборка с указанным именем и режимом доступа.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод следует использовать только для определения динамической сборки в текущем домене приложения. Дополнительные сведения см. в описании перегрузки метода <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>.  
  
> [!NOTE]
>  Во время разработки кода, который создает динамические сборки, рекомендуется использовать перегрузку метода <xref:System.AppDomain.DefineDynamicAssembly%2A>, который задает свидетельство и разрешения, указать свидетельство, которое должно иметь динамическую сборку, и включить <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> в `refusedPermissions`. Включение <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> в параметр `refusedPermissions` гарантирует проверку MSIL. Ограничением этой методики является то, что при использовании с кодом, требующим полного доверия, также возникает <xref:System.Security.SecurityException>.  
  
   
  
## Examples  
 В следующем примере демонстрируется метод <xref:System.AppDomain.DefineDynamicAssembly%2A> и событие <xref:System.AppDomain.AssemblyResolve>.  
  
 Для выполнения этого примера кода необходимо указать полное имя сборки. Дополнительные сведения о получении полного имени сборки см. в разделе [имена сборок](~/docs/standard/assembly/names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Свойству <see langword="Name" /> объекта <paramref name="name" /> присвоено значение <see langword="null" />.  
  
-или- 
Значение свойства <see langword="Name" /> параметра <paramref name="name" /> начинается с пробела или содержит символ прямой (обратной) косой черты.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Уникальный идентификатор динамической сборки.</param>
        <param name="access">Режим доступа для динамической сборки.</param>
        <param name="assemblyAttributes">Перечислимый список атрибутов, которые будут применены к сборке, или значение <see langword="null" />, если атрибуты отсутствуют.</param>
        <summary>Определяет динамическую сборку с указанным именем, режимом доступа и настраиваемыми атрибутами.</summary>
        <returns>Динамическая сборка с указанным именем и возможностями.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку метода, чтобы указать атрибуты, которые не работают должным образом, если они не применяются при создании динамической сборки. Например, такие атрибуты безопасности, как <xref:System.Security.SecurityTransparentAttribute> и <xref:System.Security.SecurityCriticalAttribute>, не работают правильно, если они добавляются после создания динамической сборки.  
  
 Этот метод следует использовать только для определения динамической сборки в текущем домене приложения. Дополнительные сведения об этом ограничении см. в описании перегрузки метода <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>.  
  
 Эта перегрузка метода появилась в [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].  
  
   
  
## Examples  
 В следующем примере кода показано, как создать динамическую сборку с <xref:System.Security.SecurityTransparentAttribute>. Атрибут должен быть указан как элемент массива <xref:System.Reflection.Emit.CustomAttributeBuilder> объектов.  
  
 Первым шагом при создании <xref:System.Reflection.Emit.CustomAttributeBuilder> является получение конструктора для атрибута. Конструктор не имеет параметров, поэтому метод <xref:System.Type.GetConstructor%2A> вызывается с пустым массивом <xref:System.Type> объектов для представления типов параметров. Вторым шагом является передача результирующего объекта <xref:System.Reflection.ConstructorInfo> конструктору класса <xref:System.Reflection.Emit.CustomAttributeBuilder>, а также пустого массива типа <xref:System.Object> для представления аргументов.  
  
 Полученный <xref:System.Reflection.Emit.CustomAttributeBuilder> затем передается в метод <xref:System.AppDomain.DefineDynamicAssembly%2A> как единственный элемент массива.  
  
 В примере кода определяется модуль и тип в новой динамической сборке, а затем отображаются атрибуты сборки.  
  
 [!code-cpp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/cpp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cpp/source.cpp#1)]
 [!code-csharp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/csharp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cs/source.cs#1)]
 [!code-vb[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Свойству <see langword="Name" /> объекта <paramref name="name" /> присвоено значение <see langword="null" />.  
  
-или- 
Значение свойства <see langword="Name" /> объекта <paramref name="name" /> начинается с пробела или содержит символ прямой (обратной) косой черты.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, evidence)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence) cil managed" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, evidence)" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Уникальный идентификатор динамической сборки.</param>
        <param name="access">Режим, в котором будет осуществляться доступ к динамической сборке.</param>
        <param name="evidence">Свидетельство, предоставляемое для динамической сборки. Используемое свидетельство является постоянным, как конечный набор свидетельств, используемых для разрешения политики.</param>
        <summary>Определяет динамическую сборку с помощью указанного имени, режима доступа и свидетельства.</summary>
        <returns>Динамическая сборка с указанным именем и возможностями.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Только полностью доверенные вызывающие объекты могут предоставлять свои `evidence` при определении динамического <xref:System.Reflection.Assembly>. Среда выполнения будет сопоставлять <xref:System.Security.Policy.Evidence> с помощью политики безопасности для определения предоставленных разрешений. Частично доверенные вызывающие объекты должны предоставлять `evidence`null. Если `evidence` `null`, среда выполнения копирует наборы разрешений, то есть текущие наборы Grant и Deny, из <xref:System.Reflection.Assembly> вызывающей стороны в динамически определяемый <xref:System.Reflection.Assembly> и помечает политику как разрешенную.  
  
 Если динамическое <xref:System.Reflection.Assembly> сохраняется на диске, последующие загрузки получают разрешения на основе политик, связанных с расположением, в котором была сохранена <xref:System.Reflection.Assembly>.  
  
 Этот метод следует использовать только для определения динамической сборки в текущем домене приложения. Дополнительные сведения см. в описании перегрузки метода <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>.  
  
> [!NOTE]
>  Во время разработки кода, который создает динамические сборки, рекомендуется использовать перегрузку метода <xref:System.AppDomain.DefineDynamicAssembly%2A>, который задает свидетельство и разрешения, указать свидетельство, которое должно иметь динамическую сборку, и включить <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> в `refusedPermissions`. Включение <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> в параметр `refusedPermissions` гарантирует проверку MSIL. Ограничением этой методики является то, что при использовании с кодом, требующим полного доверия, также возникает <xref:System.Security.SecurityException>.  
  
   
  
## Examples  
 В следующем примере демонстрируется метод <xref:System.AppDomain.DefineDynamicAssembly%2A> и событие <xref:System.AppDomain.AssemblyResolve>.  
  
 Во первых, пример кода пытается создать экземпляр `MyDynamicType` путем вызова метода <xref:System.AppDomain.CreateInstance%2A> с недопустимым именем сборки и перехватывает результирующее исключение.  
  
 Затем в примере кода добавляется обработчик событий для события <xref:System.AppDomain.AssemblyResolve> и снова пытается создать экземпляр`MyDynamicType`. Во время вызова <xref:System.AppDomain.CreateInstance%2A>для недопустимой сборки возникает событие <xref:System.AppDomain.AssemblyResolve>. Обработчик событий создает динамическую сборку, содержащую тип с именем `MyDynamicType`, присваивает типу конструктор без параметров и возвращает новую динамическую сборку. Вызов <xref:System.AppDomain.CreateInstance%2A> успешно завершается, и конструктор для `MyDynamicType` отображает сообщение в консоли.  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Свойству <see langword="Name" /> объекта <paramref name="name" /> присвоено значение <see langword="null" />.  
  
-или- 
Значение свойства <see langword="Name" /> параметра <paramref name="name" /> начинается с пробела или содержит символ прямой (обратной) косой черты.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для загрузки сборки с свидетельством. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir) cil managed" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir)" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="dir" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Уникальный идентификатор динамической сборки.</param>
        <param name="access">Режим, в котором будет осуществляться доступ к динамической сборке.</param>
        <param name="dir">Имя папки, в которой будет сохранена сборка. Если значение параметра <paramref name="dir" /> равно <see langword="null" />, по умолчанию используется текущий каталог.</param>
        <summary>Определяет динамическую сборку с помощью указанного имени, режима доступа и каталога хранения.</summary>
        <returns>Динамическая сборка с указанным именем и возможностями.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод следует использовать только для определения динамической сборки в текущем домене приложения. Дополнительные сведения см. в описании перегрузки метода <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>.  
  
> [!NOTE]
>  Во время разработки кода, который создает динамические сборки, рекомендуется использовать перегрузку метода <xref:System.AppDomain.DefineDynamicAssembly%2A>, который задает свидетельство и разрешения, указать свидетельство, которое должно иметь динамическую сборку, и включить <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> в `refusedPermissions`. Включение <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> в параметр `refusedPermissions` гарантирует проверку MSIL. Ограничением этой методики является то, что при использовании с кодом, требующим полного доверия, также возникает <xref:System.Security.SecurityException>.  
  
   
  
## Examples  
 В следующем примере демонстрируется метод <xref:System.AppDomain.DefineDynamicAssembly%2A> и событие <xref:System.AppDomain.AssemblyResolve>.  
  
 Для выполнения этого примера кода необходимо указать полное имя сборки. Дополнительные сведения о получении полного имени сборки см. в разделе [имена сборок](~/docs/standard/assembly/names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Свойству <see langword="Name" /> объекта <paramref name="name" /> присвоено значение <see langword="null" />.  
  
-или- 
Значение свойства <see langword="Name" /> параметра <paramref name="name" /> начинается с пробела или содержит символ прямой (обратной) косой черты.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes, System::Security::SecurityContextSource securityContextSource);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; * System.Security.SecurityContextSource -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, assemblyAttributes, securityContextSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" Index="3" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Уникальный идентификатор динамической сборки.</param>
        <param name="access">Режим доступа для динамической сборки.</param>
        <param name="assemblyAttributes">Перечислимый список атрибутов, которые будут применены к сборке, или значение <see langword="null" />, если атрибуты отсутствуют.</param>
        <param name="securityContextSource">Источник контекста безопасности.</param>
        <summary>Определяет динамическую сборку с помощью указанного имени, режима доступа и настраиваемых атрибутов, а также используя заданный источник для контекста безопасности.</summary>
        <returns>Динамическая сборка с указанным именем и возможностями.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку метода, чтобы указать атрибуты, которые не работают должным образом, если они не применяются при создании динамической сборки. Например, такие атрибуты безопасности, как <xref:System.Security.SecurityTransparentAttribute> и <xref:System.Security.SecurityCriticalAttribute>, не работают правильно, если они добавляются после создания динамической сборки.  
  
 Этот метод следует использовать только для определения динамической сборки в текущем домене приложения. Дополнительные сведения об этом ограничении см. в описании перегрузки метода <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Свойству <see langword="Name" /> объекта <paramref name="name" /> присвоено значение <see langword="null" />.  
  
-или- 
Значение свойства <see langword="Name" /> объекта <paramref name="name" /> начинается с пробела или содержит символ прямой (обратной) косой черты.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="securityContextSource" /> не является одним из значений перечисления.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence) cil managed" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence)" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of DefineDynamicAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="dir" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Уникальный идентификатор динамической сборки.</param>
        <param name="access">Режим, в котором будет осуществляться доступ к динамической сборке.</param>
        <param name="dir">Имя папки, в которой будет сохранена сборка. Если значение параметра <paramref name="dir" /> равно <see langword="null" />, по умолчанию используется текущий каталог.</param>
        <param name="evidence">Свидетельство, предоставляемое для динамической сборки. Используемое свидетельство является постоянным, как конечный набор свидетельств, используемых для разрешения политики.</param>
        <summary>Определяет динамическую сборку с помощью указанного имени, режима доступа, каталога хранения и свидетельства.</summary>
        <returns>Динамическая сборка с указанным именем и возможностями.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Только полностью доверенные вызывающие объекты могут предоставлять свои `evidence` при определении динамического <xref:System.Reflection.Assembly>. Среда выполнения будет сопоставлять <xref:System.Security.Policy.Evidence> с помощью политики безопасности для определения предоставленных разрешений. Частично доверенные вызывающие объекты должны предоставлять `evidence`null. Если `evidence` `null`, среда выполнения копирует наборы разрешений, то есть текущие наборы Grant и Deny, из <xref:System.Reflection.Assembly> вызывающей стороны в динамически определяемый <xref:System.Reflection.Assembly> и помечает политику как разрешенную.  
  
 Если динамическое <xref:System.Reflection.Assembly> сохраняется на диске, последующие загрузки получают разрешения на основе политик, связанных с расположением, в котором была сохранена <xref:System.Reflection.Assembly>.  
  
 Этот метод следует использовать только для определения динамической сборки в текущем домене приложения. Дополнительные сведения см. в описании перегрузки метода <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>.  
  
> [!NOTE]
>  Во время разработки кода, который создает динамические сборки, рекомендуется использовать перегрузку метода <xref:System.AppDomain.DefineDynamicAssembly%2A>, который задает свидетельство и разрешения, указать свидетельство, которое должно иметь динамическую сборку, и включить <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> в `refusedPermissions`. Включение <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> в параметр `refusedPermissions` гарантирует проверку MSIL. Ограничением этой методики является то, что при использовании с кодом, требующим полного доверия, также возникает <xref:System.Security.SecurityException>.  
  
   
  
## Examples  
 В следующем примере демонстрируется метод <xref:System.AppDomain.DefineDynamicAssembly%2A> и событие <xref:System.AppDomain.AssemblyResolve>.  
  
 Для выполнения этого примера кода необходимо указать полное имя сборки. Дополнительные сведения о получении полного имени сборки см. в разделе [имена сборок](~/docs/standard/assembly/names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Свойству <see langword="Name" /> объекта <paramref name="name" /> присвоено значение <see langword="null" />.  
  
-или- 
Значение свойства <see langword="Name" /> параметра <paramref name="name" /> начинается с пробела или содержит символ прямой (обратной) косой черты.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для загрузки сборки с свидетельством. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, requiredPermissions, optionalPermissions, refusedPermissions)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, requiredPermissions, optionalPermissions, refusedPermissions)" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Уникальный идентификатор динамической сборки.</param>
        <param name="access">Режим, в котором будет осуществляться доступ к динамической сборке.</param>
        <param name="requiredPermissions">Запрос обязательных разрешений.</param>
        <param name="optionalPermissions">Запрос дополнительных разрешений.</param>
        <param name="refusedPermissions">Запрос разрешений, в которых отказано.</param>
        <summary>Определяет динамическую сборку с помощью указанного имени, режима доступа и запросов разрешений.</summary>
        <returns>Динамическая сборка с указанным именем и возможностями.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Запросы разрешений, заданные для `requiredPermissions`, `optionalPermissions`и `refusedPermissions`, не используются, если только динамическая сборка не сохранена и не загружена в память. Чтобы указать запросы разрешений для временной сборки, которая никогда не сохранялась на диске, используйте перегрузку метода <xref:System.AppDomain.DefineDynamicAssembly%2A>, который указывает свидетельство, а также запрошенные разрешения, и укажите объект <xref:System.Security.Policy.Evidence>.  
  
> [!NOTE]
>  Во время разработки кода, который создает динамические сборки, рекомендуется использовать перегрузку метода <xref:System.AppDomain.DefineDynamicAssembly%2A>, который задает свидетельство и разрешения, указать свидетельство, которое должно иметь динамическую сборку, и включить <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> в `refusedPermissions`. Включение <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> в параметр `refusedPermissions` гарантирует проверку MSIL. Ограничением этой методики является то, что при использовании с кодом, требующим полного доверия, также возникает <xref:System.Security.SecurityException>.  
  
 Этот метод следует использовать только для определения динамической сборки в текущем домене приложения. Дополнительные сведения см. в описании перегрузки метода <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>.  
  
   
  
## Examples  
 В следующем примере демонстрируется метод <xref:System.AppDomain.DefineDynamicAssembly%2A> и событие <xref:System.AppDomain.AssemblyResolve>.  
  
 Для выполнения этого примера кода необходимо указать полное имя сборки. Дополнительные сведения о получении полного имени сборки см. в разделе [имена сборок](~/docs/standard/assembly/names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Свойству <see langword="Name" /> объекта <paramref name="name" /> присвоено значение <see langword="null" />.  
  
-или- 
Значение свойства <see langword="Name" /> параметра <paramref name="name" /> начинается с пробела или содержит символ прямой (обратной) косой черты.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, isSynchronized As Boolean, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * bool * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, isSynchronized, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="dir" Type="System.String" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="isSynchronized" Type="System.Boolean" Index="3" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" Index="4" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Уникальный идентификатор динамической сборки.</param>
        <param name="access">Режим, в котором будет осуществляться доступ к динамической сборке.</param>
        <param name="dir">Имя каталога, в котором будет сохранена динамическая сборка. Если значением параметра <paramref name="dir" /> является <see langword="null" />, используется текущий каталог.</param>
        <param name="isSynchronized"><see langword="true" />, чтобы синхронизировать создание модулей, типов и членов в динамической сборке, в противном случае — <see langword="false" />.</param>
        <param name="assemblyAttributes">Перечислимый список атрибутов, которые будут применены к сборке, или значение <see langword="null" />, если атрибуты отсутствуют.</param>
        <summary>Определяет динамическую сборку с помощью указанного имени, режима доступа, каталога хранения и варианта синхронизации.</summary>
        <returns>Динамическая сборка с указанным именем и возможностями.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку метода, чтобы указать атрибуты, которые не работают должным образом, если они не применяются при создании динамической сборки. Например, такие атрибуты безопасности, как <xref:System.Security.SecurityTransparentAttribute> и <xref:System.Security.SecurityCriticalAttribute>, не работают правильно, если они добавляются после создания динамической сборки.  
  
 Если `isSynchronized` `true`, то будут синхронизированы следующие методы итогового <xref:System.Reflection.Emit.AssemblyBuilder>: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>и <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>. Если два из этих методов вызываются в разных потоках, один из них будет заблокирован до завершения другого.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Свойству <see langword="Name" /> объекта <paramref name="name" /> присвоено значение <see langword="null" />.  
  
-или- 
Значение свойства <see langword="Name" /> объекта <paramref name="name" /> начинается с пробела или содержит символ прямой (обратной) косой черты.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, evidence, requiredPermissions, optionalPermissions, refusedPermissions)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, evidence, requiredPermissions, optionalPermissions, refusedPermissions)" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Уникальный идентификатор динамической сборки.</param>
        <param name="access">Режим, в котором будет осуществляться доступ к динамической сборке.</param>
        <param name="evidence">Свидетельство, предоставляемое для динамической сборки. Используемое свидетельство является постоянным, как конечный набор свидетельств, используемых для разрешения политики.</param>
        <param name="requiredPermissions">Запрос обязательных разрешений.</param>
        <param name="optionalPermissions">Запрос дополнительных разрешений.</param>
        <param name="refusedPermissions">Запрос разрешений, в которых отказано.</param>
        <summary>Определяет динамическую сборку с помощью указанного имени, режима доступа, свидетельства и запросов разрешений.</summary>
        <returns>Динамическая сборка с указанным именем и возможностями.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Запросы разрешений, заданные для `requiredPermissions`, `optionalPermissions`и `refusedPermissions`, используются только в том случае, если также предоставляется `evidence` или если динамическая сборка сохраняется и перегружается в память.  
  
> [!NOTE]
>  Во время разработки кода, который создает динамические сборки, рекомендуется включить <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> в `refusedPermissions`. Включение <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> в параметр `refusedPermissions` гарантирует проверку MSIL. Ограничением этой методики является то, что при использовании с кодом, требующим полного доверия, также возникает <xref:System.Security.SecurityException>.  
  
 Только полностью доверенные вызывающие объекты могут предоставлять свои `evidence` при определении динамического <xref:System.Reflection.Assembly>. Среда выполнения будет сопоставлять <xref:System.Security.Policy.Evidence> с помощью политики безопасности для определения предоставленных разрешений. Частично доверенные вызывающие объекты должны предоставлять `evidence`null. Если `evidence` `null`, среда выполнения копирует наборы разрешений, то есть текущие наборы Grant и Deny, из <xref:System.Reflection.Assembly> вызывающей стороны в динамически определяемый <xref:System.Reflection.Assembly> и помечает политику как разрешенную.  
  
 Если динамическое <xref:System.Reflection.Assembly> сохраняется на диске, последующие загрузки получают разрешения на основе политик, связанных с расположением, в котором была сохранена <xref:System.Reflection.Assembly>.  
  
 Этот метод следует использовать только для определения динамической сборки в текущем домене приложения. Дополнительные сведения см. в описании перегрузки метода <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>.  
  
   
  
## Examples  
 В следующем примере демонстрируется метод <xref:System.AppDomain.DefineDynamicAssembly%2A> и событие <xref:System.AppDomain.AssemblyResolve>.  
  
 Для выполнения этого примера кода необходимо указать полное имя сборки. Дополнительные сведения о получении полного имени сборки см. в разделе [имена сборок](~/docs/standard/assembly/names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Свойству <see langword="Name" /> объекта <paramref name="name" /> присвоено значение <see langword="null" />.  
  
-или- 
Значение свойства <see langword="Name" /> параметра <paramref name="name" /> начинается с пробела или содержит символ прямой (обратной) косой черты.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для загрузки сборки с свидетельством. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, requiredPermissions, optionalPermissions, refusedPermissions)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, requiredPermissions, optionalPermissions, refusedPermissions)" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="dir" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Уникальный идентификатор динамической сборки.</param>
        <param name="access">Режим, в котором будет осуществляться доступ к динамической сборке.</param>
        <param name="dir">Имя папки, в которой будет сохранена сборка. Если значение параметра <paramref name="dir" /> равно <see langword="null" />, по умолчанию используется текущий каталог.</param>
        <param name="requiredPermissions">Запрос обязательных разрешений.</param>
        <param name="optionalPermissions">Запрос дополнительных разрешений.</param>
        <param name="refusedPermissions">Запрос разрешений, в которых отказано.</param>
        <summary>Определяет динамическую сборку с помощью указанного имени, режима доступа, каталога хранения и запросов разрешений.</summary>
        <returns>Динамическая сборка с указанным именем и возможностями.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Запросы разрешений, заданные для `requiredPermissions`, `optionalPermissions`и `refusedPermissions`, не используются, если только динамическая сборка не сохранена и не загружена в память. Чтобы указать запросы разрешений для временной сборки, которая никогда не сохранялась на диске, используйте перегрузку метода <xref:System.AppDomain.DefineDynamicAssembly%2A>, который указывает свидетельство, а также запрошенные разрешения, и укажите объект <xref:System.Security.Policy.Evidence>.  
  
> [!NOTE]
>  Во время разработки кода, который создает динамические сборки, рекомендуется использовать перегрузку метода <xref:System.AppDomain.DefineDynamicAssembly%2A>, который задает свидетельство и разрешения, указать свидетельство, которое должно иметь динамическую сборку, и включить <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> в `refusedPermissions`. Включение <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> в параметр `refusedPermissions` гарантирует проверку MSIL. Ограничением этой методики является то, что при использовании с кодом, требующим полного доверия, также возникает <xref:System.Security.SecurityException>.  
  
 Этот метод следует использовать только для определения динамической сборки в текущем домене приложения. Дополнительные сведения см. в описании перегрузки метода <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>.  
  
   
  
## Examples  
 В следующем примере демонстрируется метод <xref:System.AppDomain.DefineDynamicAssembly%2A> и событие <xref:System.AppDomain.AssemblyResolve>.  
  
 Для выполнения этого примера кода необходимо указать полное имя сборки. Дополнительные сведения о получении полного имени сборки см. в разделе [имена сборок](~/docs/standard/assembly/names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Свойству <see langword="Name" /> объекта <paramref name="name" /> присвоено значение <see langword="null" />.  
  
-или- 
Значение свойства <see langword="Name" /> параметра <paramref name="name" /> начинается с пробела или содержит символ прямой (обратной) косой черты.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions)" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  Please see http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="dir" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Уникальный идентификатор динамической сборки.</param>
        <param name="access">Режим, в котором будет осуществляться доступ к динамической сборке.</param>
        <param name="dir">Имя папки, в которой будет сохранена сборка. Если значение параметра <paramref name="dir" /> равно <see langword="null" />, по умолчанию используется текущий каталог.</param>
        <param name="evidence">Свидетельство, предоставляемое для динамической сборки. Используемое свидетельство является постоянным, как конечный набор свидетельств, используемых для разрешения политики.</param>
        <param name="requiredPermissions">Запрос обязательных разрешений.</param>
        <param name="optionalPermissions">Запрос дополнительных разрешений.</param>
        <param name="refusedPermissions">Запрос разрешений, в которых отказано.</param>
        <summary>Определяет динамическую сборку с помощью указанного имени, режима доступа, каталога хранения, свидетельства и запросов разрешений.</summary>
        <returns>Динамическая сборка с указанным именем и возможностями.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Запросы разрешений, заданные для `requiredPermissions`, `optionalPermissions`и `refusedPermissions`, используются только в том случае, если также предоставляется `evidence` или если динамическая сборка сохраняется и перегружается в память.  
  
> [!NOTE]
>  Во время разработки кода, который создает динамические сборки, рекомендуется включить <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> в `refusedPermissions`. Включение <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> в параметр `refusedPermissions` гарантирует проверку MSIL. Ограничением этой методики является то, что при использовании с кодом, требующим полного доверия, также возникает <xref:System.Security.SecurityException>.  
  
 Только полностью доверенные вызывающие объекты могут предоставлять свои `evidence` при определении динамического <xref:System.Reflection.Assembly>. Среда выполнения будет сопоставлять <xref:System.Security.Policy.Evidence> с помощью политики безопасности для определения предоставленных разрешений. Частично доверенные вызывающие объекты должны предоставлять `evidence`null. Если `evidence` `null`, среда выполнения копирует наборы разрешений, то есть текущие наборы Grant и Deny, из <xref:System.Reflection.Assembly> вызывающей стороны в динамически определяемый <xref:System.Reflection.Assembly> и помечает политику как разрешенную.  
  
 Если динамическое <xref:System.Reflection.Assembly> сохраняется на диске, последующие загрузки получают разрешения на основе политик, связанных с расположением, в котором была сохранена <xref:System.Reflection.Assembly>.  
  
 Этот метод следует использовать только для определения динамической сборки в текущем домене приложения. Дополнительные сведения см. в описании перегрузки метода <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>.  
  
   
  
## Examples  
 В следующем примере демонстрируется метод <xref:System.AppDomain.DefineDynamicAssembly%2A> и событие <xref:System.AppDomain.AssemblyResolve>.  
  
 Для выполнения этого примера кода необходимо указать полное имя сборки. Дополнительные сведения о получении полного имени сборки см. в разделе [имена сборок](~/docs/standard/assembly/names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Свойству <see langword="Name" /> объекта <paramref name="name" /> присвоено значение <see langword="null" />.  
  
-или- 
Значение свойства <see langword="Name" /> параметра <paramref name="name" /> начинается с пробела или содержит символ прямой (обратной) косой черты.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для загрузки сборки с свидетельством. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions, isSynchronized)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized) cil managed" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions, isSynchronized)" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="dir" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="isSynchronized" Type="System.Boolean" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Уникальный идентификатор динамической сборки.</param>
        <param name="access">Режим, в котором будет осуществляться доступ к динамической сборке.</param>
        <param name="dir">Имя каталога, в котором будет сохранена динамическая сборка. Если значение параметра <paramref name="dir" /> равно <see langword="null" />, по умолчанию используется текущий каталог.</param>
        <param name="evidence">Свидетельство, предоставляемое для динамической сборки. Используемое свидетельство является постоянным, как конечный набор свидетельств, используемых для разрешения политики.</param>
        <param name="requiredPermissions">Запрос обязательных разрешений.</param>
        <param name="optionalPermissions">Запрос дополнительных разрешений.</param>
        <param name="refusedPermissions">Запрос разрешений, в которых отказано.</param>
        <param name="isSynchronized"><see langword="true" />, чтобы синхронизировать создание модулей, типов и членов в динамической сборке, в противном случае — <see langword="false" />.</param>
        <summary>Определяет динамическую сборку с помощью указанного имени, режима доступа, каталога хранения, свидетельства, запросов разрешений и параметра синхронизации.</summary>
        <returns>Динамическая сборка с указанным именем и возможностями.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Запросы разрешений, заданные для `requiredPermissions`, `optionalPermissions`и `refusedPermissions`, используются только в том случае, если также предоставляется `evidence` или если динамическая сборка сохраняется и перегружается в память.  
  
> [!NOTE]
>  Во время разработки кода, который создает динамические сборки, рекомендуется включить <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> в `refusedPermissions`. Включение <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> в параметр `refusedPermissions` гарантирует проверку MSIL. Ограничением этой методики является то, что при использовании с кодом, требующим полного доверия, также возникает <xref:System.Security.SecurityException>.  
  
 Только полностью доверенные вызывающие объекты могут предоставлять свои доказательства при определении динамического <xref:System.Reflection.Assembly>. Среда выполнения будет сопоставлять <xref:System.Security.Policy.Evidence> с помощью политики безопасности для определения предоставленных разрешений. Частично доверенные вызывающие объекты должны предоставлять `null` для параметра `evidence`. Если `evidence` `null`, среда выполнения копирует наборы разрешений, то есть текущие наборы Grant и Deny, из <xref:System.Reflection.Assembly> вызывающей стороны в динамически определяемый <xref:System.Reflection.Assembly> и помечает политику как разрешенную.  
  
 Если динамическое <xref:System.Reflection.Assembly> сохраняется на диске, последующие загрузки получают разрешения на основе политик, связанных с расположением, в котором была сохранена <xref:System.Reflection.Assembly>.  
  
 Если `isSynchronized` `true`, то будут синхронизированы следующие методы итогового <xref:System.Reflection.Emit.AssemblyBuilder>: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>и <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>. Если два из этих методов вызываются в разных потоках, один из них будет заблокирован до завершения другого.  
  
   
  
## Examples  
 В следующем примере демонстрируется метод <xref:System.AppDomain.DefineDynamicAssembly%2A> и событие <xref:System.AppDomain.AssemblyResolve>.  
  
 Для выполнения этого примера кода необходимо указать полное имя сборки. Дополнительные сведения о получении полного имени сборки см. в разделе [имена сборок](~/docs/standard/assembly/names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Свойству <see langword="Name" /> объекта <paramref name="name" /> присвоено значение <see langword="null" />.  
  
-или- 
Значение свойства <see langword="Name" /> параметра <paramref name="name" /> начинается с пробела или содержит символ прямой (обратной) косой черты.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для загрузки сборки с свидетельством. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions, isSynchronized, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="dir" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" Index="5" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" Index="6" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="isSynchronized" Type="System.Boolean" Index="7" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" Index="8" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Уникальный идентификатор динамической сборки.</param>
        <param name="access">Режим, в котором будет осуществляться доступ к динамической сборке.</param>
        <param name="dir">Имя каталога, в котором будет сохранена динамическая сборка. Если значением параметра <paramref name="dir" /> является <see langword="null" />, используется текущий каталог.</param>
        <param name="evidence">Свидетельство, предоставленное для динамической сборки. Используемое свидетельство является постоянным, как конечный набор свидетельств, используемых для разрешения политики.</param>
        <param name="requiredPermissions">Запрос обязательных разрешений.</param>
        <param name="optionalPermissions">Запрос дополнительных разрешений.</param>
        <param name="refusedPermissions">Запрос разрешений, в которых отказано.</param>
        <param name="isSynchronized"><see langword="true" />, чтобы синхронизировать создание модулей, типов и членов в динамической сборке, в противном случае — <see langword="false" />.</param>
        <param name="assemblyAttributes">Перечислимый список атрибутов, которые будут применены к сборке, или значение <see langword="null" />, если атрибуты отсутствуют.</param>
        <summary>Определяет динамическую сборку с помощью указанного имени, режима доступа, каталога хранения, свидетельства, запросов разрешений, параметра синхронизации и настраиваемых атрибутов.</summary>
        <returns>Динамическая сборка с указанным именем и возможностями.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку метода, чтобы указать атрибуты, которые не работают должным образом, если они не применяются при создании динамической сборки. Например, такие атрибуты безопасности, как <xref:System.Security.SecurityTransparentAttribute> и <xref:System.Security.SecurityCriticalAttribute>, не работают правильно, если они добавляются после создания динамической сборки.  
  
 Запросы разрешений, заданные для параметров `requiredPermissions`, `optionalPermissions`и `refusedPermissions`, используются только в том случае, если также указан параметр `evidence` или если динамическая сборка сохраняется и перегружается в память.  
  
> [!NOTE]
>  При разработке кода, который создает динамические сборки, рекомендуется включить флаг <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> в параметр `refusedPermissions`. Включение этого флага гарантирует, что будет выполнена проверка промежуточного языка Microsoft (MSIL). Этот метод обнаруживает непреднамеренное создание непроверяемого кода, которое в противном случае трудно обнаружить. Ограничение этой методики заключается в том, что при использовании с кодом, требующим полного доверия, также возникает <xref:System.Security.SecurityException>.  
  
 Только полностью доверенные вызывающие объекты могут предоставлять свидетельство при определении динамического <xref:System.Reflection.Assembly>. Среда выполнения сопоставляет <xref:System.Security.Policy.Evidence> с помощью политики безопасности, чтобы определить предоставленные разрешения. Частично доверенные вызывающие объекты должны предоставлять `null` для параметра `evidence`. Если `evidence` имеет `null`, среда выполнения копирует наборы разрешений (т. е. Текущее значение Grant и Deny Sets) из сборки вызывающего объекта в определяемую динамическую сборку и помечает политику как разрешенную.  
  
 Если динамическая сборка сохраняется на диске, последующие загрузки будут получать разрешения на основе политик, связанных с расположением, в котором была сохранена динамическая сборка.  
  
 Если `isSynchronized` `true`, то будут синхронизированы следующие методы итогового <xref:System.Reflection.Emit.AssemblyBuilder>: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>и <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>. Если два из этих методов вызываются в разных потоках, один из них будет заблокирован до завершения другого.  
  
 Эта перегрузка метода появилась в [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Свойству <see langword="Name" /> объекта <paramref name="name" /> присвоено значение <see langword="null" />.  
  
-или- 
Значение свойства <see langword="Name" /> объекта <paramref name="name" /> начинается с пробела или содержит символ прямой (обратной) косой черты.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для загрузки сборки с свидетельством. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DoCallBack">
      <MemberSignature Language="C#" Value="public void DoCallBack (CrossAppDomainDelegate callBackDelegate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DoCallBack(class System.CrossAppDomainDelegate callBackDelegate) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DoCallBack (callBackDelegate As CrossAppDomainDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DoCallBack(CrossAppDomainDelegate ^ callBackDelegate);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member DoCallBack : CrossAppDomainDelegate -&gt; unit&#xA;override this.DoCallBack : CrossAppDomainDelegate -&gt; unit" Usage="appDomain.DoCallBack callBackDelegate" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DoCallBack(class System.CrossAppDomainDelegate callBackDelegate) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DoCallBack(CrossAppDomainDelegate ^ callBackDelegate);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.DoCallBack : CrossAppDomainDelegate -&gt; unit" Usage="appDomain.DoCallBack callBackDelegate" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DoCallBack(System.CrossAppDomainDelegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBackDelegate" Type="System.CrossAppDomainDelegate" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="callBackDelegate">Делегат, определяющий вызываемый метод.</param>
        <summary>Выполняет код в другом домене приложения, который определен заданным делегатом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `callBackDelegate` может указывать маршалирование по значению, <xref:System.MarshalByRefObject>или <xref:System.ContextBoundObject>.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование статического метода <xref:System.AppDomain.DoCallBack%2A>.  
  
 [!code-cpp[AppDomain_DoCallBack#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_static.cpp#1)]
 [!code-csharp[AppDomain_DoCallBack#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_static.cs#1)]
 [!code-vb[AppDomain_DoCallBack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_static.vb#1)]  
  
 В следующем примере демонстрируется использование метода <xref:System.AppDomain.DoCallBack%2A> по значению.  
  
 [!code-cpp[AppDomain_DoCallBack#2](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byval.cpp#2)]
 [!code-csharp[AppDomain_DoCallBack#2](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byval.cs#2)]
 [!code-vb[AppDomain_DoCallBack#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byval.vb#2)]  
  
 В следующем примере демонстрируется использование метода <xref:System.AppDomain.DoCallBack%2A> по ссылке.  
  
 [!code-cpp[AppDomain_DoCallBack#3](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byref.cpp#3)]
 [!code-csharp[AppDomain_DoCallBack#3](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byref.cs#3)]
 [!code-vb[AppDomain_DoCallBack#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byref.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="callBackDelegate" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DomainManager">
      <MemberSignature Language="C#" Value="public AppDomainManager DomainManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainManager DomainManager" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DomainManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DomainManager As AppDomainManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainManager ^ DomainManager { AppDomainManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DomainManager : AppDomainManager" Usage="System.AppDomain.DomainManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomainManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает диспетчер домена, предоставленный средой размещения при инициализации домена приложения.</summary>
        <value>Объект, который представляет диспетчер домена, предоставленный средой размещения при инициализации домена приложения, или значение <see langword="null" />, если диспетчер домена не предоставлен.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Неуправляемый узел среды CLR может предоставить диспетчер домена. Диспетчер домена может принять участие в инициализации нового домена приложения и предоставить другие диспетчеры, например <xref:System.Security.HostSecurityManager>, которые участвуют в операциях домена приложения.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="DomainUnload">
      <MemberSignature Language="C#" Value="public event EventHandler DomainUnload;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DomainUnload" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.DomainUnload" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DomainUnload As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DomainUnload;" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.DomainUnload : EventHandler " Usage="member this.DomainUnload : System.EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ DomainUnload;" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.DomainUnload</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>remove: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит непосредственно перед выгрузкой объекта <see cref="T:System.AppDomain" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Делегат <xref:System.EventHandler> для этого события может выполнять любые действия завершения до выгрузки домена приложения.  
  
 Каждый домен приложения, который должен выполнять обработку при выгрузке, должен зарегистрировать обработчик событий для этого события. Не следует использовать общий обработчик событий, так как делегат <xref:System.EventHandler> не определяет выгружается домен.  
  
> [!NOTE]
>  Это событие никогда не возникает в домене приложения по умолчанию.  
  
 Не следует делать предположения о потоке, на котором возникло событие. Событие может быть вызвано в потоке, отличном от того, который вызвал метод <xref:System.AppDomain.Unload%2A>.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicDirectory">
      <MemberSignature Language="C#" Value="public string DynamicDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DynamicDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DynamicDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DynamicDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DynamicDirectory : string" Usage="System.AppDomain.DynamicDirectory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.DynamicDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает каталог, в котором распознаватель сборок производит поиск динамически созданных сборок.</summary>
        <value>Каталог, в котором распознаватель сборок производит поиск динамически созданных сборок.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы задать динамический каталог, назначьте путь к базовому каталогу свойству <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> объекта <xref:System.AppDomainSetup>, который будет использоваться для создания нового домена приложения. Базовый путь к каталогу, присвоенный свойству, изменяется добавлением подкаталога, простое имя которого является хэш-кодом строки, назначаемой свойству <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType>, поэтому формат базового каталога является *исходным путем*\\*хэш-кода*. Динамический каталог — это подкаталог этого базового каталога. Его простое имя — это значение свойства <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType>, поэтому его формат является *исходным путем*\\*хэш-кода*\\*имени приложения*.  
  
   
  
## Examples  
 В следующем примере создается домен приложения с каталогом для динамических сборок, выдается динамическая сборка и сохраняется в динамическом каталоге, а затем эта сборка загружается в новый домен приложения и используется.  
  
 В примере создается объект <xref:System.AppDomainSetup> и свойству <xref:System.AppDomainSetup.ApplicationName%2A> присваивается значение example, а свойству <xref:System.AppDomainSetup.DynamicBase%2A> — значение "К:\динамикассемблидир". Затем в примере отображается свойство <xref:System.AppDomainSetup.DynamicBase%2A>, чтобы показать, что хэш-код имени приложения добавлен в качестве подкаталога изначально назначенного пути.  
  
> [!NOTE]
>  Базовый каталог в этом примере должен находиться за пределами пути поиска для примера приложения. Не забудьте скомпилировать пример в другом расположении. При каждом запуске примера удалите базовый каталог и все его подкаталоги.  
  
 В примере создается новый домен приложения с помощью объекта <xref:System.AppDomainSetup>. В примере используется свойство <xref:System.AppDomain.DynamicDirectory%2A> для получения имени каталога, чтобы он мог создать каталог. (В этом примере можно просто создать каталог путем сцепления исходного пути, хэш-кода имени приложения и имени приложения).  
  
 В примере имеется метод `GenerateDynamicAssembly`, который создает сборку с именем `DynamicHelloWorld.dll` и сохраняет ее в динамическом каталоге нового домена приложения. Динамическая сборка содержит один тип, `HelloWorld`, имеющий статический метод (`Shared` метод в Visual Basic) с именем `HelloFromAD`. При вызове этого метода отображается имя домена приложения.  
  
 Класс `Example` является производным от <xref:System.MarshalByRefObject>, поэтому в примере можно создать экземпляр класса в новом домене приложения и вызвать его метод `Test`. Метод `Test` загружает динамическую сборку по отображаемому имени и вызывает статический метод `HelloFromAD`.  
  
 Можно увидеть, что поиск в динамическом каталоге выполняется после обычных путей поиска путем написания кода для сборки с именем `DynamicHelloWorld.dll` и компиляции его в том же каталоге, что и этот пример. Сборка должна иметь класс с именем `HelloWorld` со статическим методом с именем `HelloFromAD`. Этот метод не обязательно должен иметь те же функциональные возможности, что и в примере. Он может просто отобразить строку в консоли. Сборка также должна иметь атрибут <xref:System.Reflection.AssemblyVersionAttribute>, который задает для его версии значение 1.0.0.0. При выполнении примера сборка, скомпилированная в текущем каталоге, обнаруживается до того, как будет выполнен поиск в динамическом каталоге.  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям о пути. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Evidence" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Evidence As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::Evidence ^ Evidence { System::Security::Policy::Evidence ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Evidence : System.Security.Policy.Evidence" Usage="System.AppDomain.Evidence" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Security.IEvidenceFactory.Evidence</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает <see cref="T:System.Security.Policy.Evidence" />, связанное с этим доменом приложения.</summary>
        <value>Свидетельство, связанное с данным доменом приложений.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для загрузки сборки с свидетельством. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />. Действие безопасности: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет сборку, содержащуюся в указанном файле.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string -&gt; int" Usage="appDomain.ExecuteAssembly assemblyFile" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string -&gt; int&#xA;override this.ExecuteAssembly : string -&gt; int" Usage="appDomain.ExecuteAssembly assemblyFile" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Имя файла, содержащего сборку, которую необходимо выполнить.</param>
        <summary>Выполняет сборку, содержащуюся в указанном файле.</summary>
        <returns>Значение, возвращаемое точкой входа сборки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сборка начинает выполняться в точке входа, указанной в заголовке .NET Framework.  
  
 Этот метод не создает новый процесс или домен приложения и не выполняет метод точки входа в новом потоке.  
  
 Этот метод загружает сборки с помощью метода <xref:System.Reflection.Assembly.LoadFile%2A>. Сборки также можно выполнять с помощью метода <xref:System.AppDomain.ExecuteAssemblyByName%2A>, который загружает сборки с помощью метода <xref:System.Reflection.Assembly.Load%2A>.  
  
 Чтобы создать <xref:System.AppDomain> для загрузки и выполнения, используйте метод <xref:System.AppDomain.CreateDomain%2A>.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование одной из перегрузок <xref:System.AppDomain.ExecuteAssembly%2A> в двух разных доменах.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="assemblyFile" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" /> не найден.</exception>
        <exception cref="T:System.BadImageFormatException">Тип <paramref name="assemblyFile" /> не является допустимой сборкой.  
  
-или- 
В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyFile" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль были загружены дважды с двумя разными свидетельствами.</exception>
        <exception cref="T:System.MissingMethodException">Указанная сборка не имеет точки входа.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к чтению из файла или каталога, а также для доступа к данным в самом пути. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">для чтения URI, который не начинается с "file://".</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">для выполнения консольного приложения. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string * System.Security.Policy.Evidence -&gt; int&#xA;override this.ExecuteAssembly : string * System.Security.Policy.Evidence -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * System.Security.Policy.Evidence -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Имя файла, содержащего сборку, которую необходимо выполнить.</param>
        <param name="assemblySecurity">Свидетельство для загрузки сборки.</param>
        <summary>Выполняет сборку, содержащуюся в указанном файле, с использованием заданного свидетельства.</summary>
        <returns>Значение, возвращаемое точкой входа сборки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сборка начинает выполняться в точке входа, указанной в заголовке .NET Framework.  
  
 Метод <xref:System.AppDomain.ExecuteAssembly%2A> не создает новый процесс или домен приложения и не выполняет метод точки входа в новом потоке.  
  
 Этот метод загружает сборки с помощью метода <xref:System.Reflection.Assembly.LoadFile%2A>. Сборки также можно выполнять с помощью метода <xref:System.AppDomain.ExecuteAssemblyByName%2A>, который загружает сборки с помощью метода <xref:System.Reflection.Assembly.Load%2A>.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование одной из перегрузок <xref:System.AppDomain.ExecuteAssembly%2A> в двух разных доменах.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="assemblyFile" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" /> не найден.</exception>
        <exception cref="T:System.BadImageFormatException">Тип <paramref name="assemblyFile" /> не является допустимой сборкой.  
  
-или- 
В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyFile" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль были загружены дважды с двумя разными свидетельствами.</exception>
        <exception cref="T:System.MissingMethodException">Указанная сборка не имеет точки входа.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для загрузки сборки с свидетельством. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к чтению из файла или каталога, а также для доступа к данным в самом пути. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">для чтения URI, который не начинается с "file://".</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">для выполнения консольного приложения. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * string[] -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Имя файла, содержащего сборку, которую необходимо выполнить.</param>
        <param name="args">Аргументы, передаваемые в точку входа сборки.</param>
        <summary>Выполняет сборку, содержащуюся в указанном файле, с использованием заданных аргументов.</summary>
        <returns>Значение, возвращаемое точкой входа сборки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сборка начинает выполняться в точке входа, указанной в заголовке .NET Framework.  
  
 Этот метод не создает новый процесс или домен приложения и не выполняет метод точки входа в новом потоке.  
  
 Этот метод загружает сборки с помощью метода <xref:System.Reflection.Assembly.LoadFile%2A>. Сборки также можно выполнять с помощью метода <xref:System.AppDomain.ExecuteAssemblyByName%2A>, который загружает сборки с помощью метода <xref:System.Reflection.Assembly.Load%2A>.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование одной из перегрузок <xref:System.AppDomain.ExecuteAssembly%2A> в двух разных доменах.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="assemblyFile" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" /> не найден.</exception>
        <exception cref="T:System.BadImageFormatException">Тип <paramref name="assemblyFile" /> не является допустимой сборкой.  
  
-или- 
 Сборка <paramref name="assemblyFile" /> была скомпилирована в более поздней версии среды CLR, чем версия, загруженная в текущий момент.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль были загружены дважды с двумя разными свидетельствами.</exception>
        <exception cref="T:System.MissingMethodException">Указанная сборка не имеет точки входа.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к чтению из файла или каталога, а также для доступа к данным в самом пути. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">для чтения URI, который не начинается с "file://".</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">для выполнения консольного приложения. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string * System.Security.Policy.Evidence * string[] -&gt; int&#xA;override this.ExecuteAssembly : string * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity, args)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity, args)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Имя файла, содержащего сборку, которую необходимо выполнить.</param>
        <param name="assemblySecurity">Предоставленное свидетельство для сборки.</param>
        <param name="args">Аргументы, передаваемые в точку входа сборки.</param>
        <summary>Выполняет сборку, содержащуюся в указанном файле, с использованием заданного свидетельства и аргументов.</summary>
        <returns>Значение, возвращаемое точкой входа сборки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сборка начинает выполняться в точке входа, указанной в заголовке .NET Framework.  
  
 Этот метод не создает новый процесс или домен приложения и не выполняет метод точки входа в новом потоке.  
  
 Этот метод загружает сборки с помощью метода <xref:System.Reflection.Assembly.LoadFile%2A>. Сборки также можно выполнять с помощью метода <xref:System.AppDomain.ExecuteAssemblyByName%2A>, который загружает сборки с помощью метода <xref:System.Reflection.Assembly.Load%2A>.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование одной из перегрузок <xref:System.AppDomain.ExecuteAssembly%2A> в двух разных доменах.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="assemblyFile" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" /> не найден.</exception>
        <exception cref="T:System.BadImageFormatException">Тип <paramref name="assemblyFile" /> не является допустимой сборкой.  
  
-или- 
В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyFile" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль были загружены дважды с двумя разными свидетельствами.</exception>
        <exception cref="T:System.NotSupportedException">Значение <paramref name="assemblySecurity" /> не <see langword="null" />. Когда устаревшие политики разграничения доступа кода не включены, <paramref name="assemblySecurity" /> должен равняться <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Указанная сборка не имеет точки входа.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для загрузки сборки с свидетельством. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к чтению из файла или каталога, а также для доступа к данным в самом пути. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">для чтения URI, который не начинается с "file://".</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">для выполнения консольного приложения. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * string[] * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, args, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Имя файла, содержащего сборку, которую необходимо выполнить.</param>
        <param name="args">Аргументы, передаваемые в точку входа сборки.</param>
        <param name="hashValue">Представляет значение вычисляемого хэш-кода.</param>
        <param name="hashAlgorithm">Представляет алгоритм хэширования, используемый манифестом сборки.</param>
        <summary>Выполняет сборку, содержащуюся в указанном файле, с использованием заданных аргументов, хэш-значения и хэш-алгоритма.</summary>
        <returns>Значение, возвращаемое точкой входа сборки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сборка начинает выполняться в точке входа, указанной в заголовке .NET Framework.  
  
 Этот метод не создает новый процесс или домен приложения и не выполняет метод точки входа в новом потоке.  
  
 Этот метод загружает сборки с помощью метода <xref:System.Reflection.Assembly.LoadFile%2A>. Сборки также можно выполнять с помощью метода <xref:System.AppDomain.ExecuteAssemblyByName%2A>, который загружает сборки с помощью метода <xref:System.Reflection.Assembly.Load%2A>.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование одной из перегрузок <xref:System.AppDomain.ExecuteAssembly%2A> в двух разных доменах.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="assemblyFile" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" /> не найден.</exception>
        <exception cref="T:System.BadImageFormatException">Тип <paramref name="assemblyFile" /> не является допустимой сборкой.  
  
-или- 
 Сборка <paramref name="assemblyFile" /> была скомпилирована в более поздней версии среды CLR, чем версия, загруженная в текущий момент.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль были загружены дважды с двумя разными свидетельствами.</exception>
        <exception cref="T:System.MissingMethodException">Указанная сборка не имеет точки входа.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к чтению из файла или каталога, а также для доступа к данным в самом пути. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">для чтения URI, который не начинается с "file://".</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">для выполнения консольного приложения. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * System.Security.Policy.Evidence * string[] * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity, args, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashValue" Type="System.Byte[]" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Имя файла, содержащего сборку, которую необходимо выполнить.</param>
        <param name="assemblySecurity">Предоставленное свидетельство для сборки.</param>
        <param name="args">Аргументы, передаваемые в точку входа сборки.</param>
        <param name="hashValue">Представляет значение вычисляемого хэш-кода.</param>
        <param name="hashAlgorithm">Представляет алгоритм хэширования, используемый манифестом сборки.</param>
        <summary>Выполняет сборку, содержащуюся в указанном файле, с использованием заданного свидетельства, аргументов, хэш-значения и хэш-алгоритма.</summary>
        <returns>Значение, возвращаемое точкой входа сборки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сборка начинает выполняться в точке входа, указанной в заголовке .NET Framework.  
  
 Этот метод не создает новый процесс или домен приложения и не выполняет метод точки входа в новом потоке.  
  
 Этот метод загружает сборки с помощью метода <xref:System.Reflection.Assembly.LoadFile%2A>. Сборки также можно выполнять с помощью метода <xref:System.AppDomain.ExecuteAssemblyByName%2A>, который загружает сборки с помощью метода <xref:System.Reflection.Assembly.Load%2A>.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование одной из перегрузок <xref:System.AppDomain.ExecuteAssembly%2A> в двух разных доменах.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="assemblyFile" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" /> не найден.</exception>
        <exception cref="T:System.BadImageFormatException">Тип <paramref name="assemblyFile" /> не является допустимой сборкой.  
  
-или- 
В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyFile" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль были загружены дважды с двумя разными свидетельствами.</exception>
        <exception cref="T:System.NotSupportedException">Значение <paramref name="assemblySecurity" /> не <see langword="null" />. Когда устаревшие политики разграничения доступа кода не включены, <paramref name="assemblySecurity" /> должен равняться <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Указанная сборка не имеет точки входа.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для загрузки сборки с свидетельством. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к чтению из файла или каталога, а также для доступа к данным в самом пути. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">для чтения URI, который не начинается с "file://".</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">для выполнения консольного приложения. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssemblyByName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет сборку.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string -&gt; int" Usage="appDomain.ExecuteAssemblyByName assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Отображаемое имя сборки. См. <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <summary>Выполняет сборку, определенную ее отображаемым именем.</summary>
        <returns>Значение, возвращаемое точкой входа сборки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.AppDomain.ExecuteAssemblyByName%2A> предоставляет аналогичные функции методу <xref:System.AppDomain.ExecuteAssembly%2A>, но указывает сборку по отображаемому имени или <xref:System.Reflection.AssemblyName>, а не по расположению файла. Таким образом, <xref:System.AppDomain.ExecuteAssemblyByName%2A> загружает сборки с помощью метода <xref:System.Reflection.Assembly.Load%2A>, а не метода <xref:System.Reflection.Assembly.LoadFile%2A>.  
  
 Сборка начинает выполняться в точке входа, указанной в заголовке .NET Framework.  
  
 Этот метод не создает новый процесс или домен приложения и не выполняет метод точки входа в новом потоке.  
  
 Чтобы создать <xref:System.AppDomain> для загрузки и выполнения, используйте метод <xref:System.AppDomain.CreateDomain%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="assemblyName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Сборка, заданная параметром <paramref name="assemblyName" />, не найдена.</exception>
        <exception cref="T:System.BadImageFormatException">Сборка, заданная параметром <paramref name="assemblyName" />, недопустимая.  
  
-или- 
В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyName" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка, заданная параметром <paramref name="assemblyName" />, найдена, но загрузить ее не удалось.</exception>
        <exception cref="T:System.MissingMethodException">Указанная сборка не имеет точки входа.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к чтению из файла или каталога, для доступа к сведениям в самом пути, а также для перенаправления отображаемого имени в путь. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">для доступа к веб-сайту, когда отображаемое имя перенаправляется на URL-адрес.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">для выполнения консольного приложения. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : System.Reflection.AssemblyName * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-2.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">Объект <see cref="T:System.Reflection.AssemblyName" />, представляющий имя сборки.</param>
        <param name="args">Аргументы командной строки для передачи при запуске процесса.</param>
        <summary>Выполняет сборку с заданным <see cref="T:System.Reflection.AssemblyName" />, используя указанные аргументы.</summary>
        <returns>Значение, возвращаемое точкой входа сборки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.AppDomain.ExecuteAssemblyByName%2A> предоставляет аналогичные функции методу <xref:System.AppDomain.ExecuteAssembly%2A>, но указывает сборку по отображаемому имени или <xref:System.Reflection.AssemblyName>, а не по расположению файла. Таким образом, <xref:System.AppDomain.ExecuteAssemblyByName%2A> загружает сборки с помощью метода <xref:System.Reflection.Assembly.Load%2A>, а не метода <xref:System.Reflection.Assembly.LoadFile%2A>.  
  
 Сборка начинает выполняться в точке входа, указанной в заголовке .NET Framework.  
  
 Этот метод не создает новый процесс или домен приложения и не выполняет метод точки входа в новом потоке.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Сборка, заданная параметром <paramref name="assemblyName" />, не найдена.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка, заданная параметром <paramref name="assemblyName" />, найдена, но загрузить ее не удалось.</exception>
        <exception cref="T:System.BadImageFormatException">Сборка, заданная параметром <paramref name="assemblyName" />, недопустимая.  
  
-или- 
 Сборка <paramref name="assemblyName" /> была скомпилирована в более поздней версии среды CLR, чем версия, загруженная в текущий момент.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <exception cref="T:System.MissingMethodException">Указанная сборка не имеет точки входа.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к чтению из файла или каталога, для доступа к сведениям в самом пути, а также для перенаправления отображаемого имени в путь. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">для доступа к веб-сайту, когда отображаемое имя перенаправляется на URL-адрес.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">для выполнения консольного приложения. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * System.Security.Policy.Evidence -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Отображаемое имя сборки. См. <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="assemblySecurity">Свидетельство для загрузки сборки.</param>
        <summary>Выполняет сборку с заданным отображаемым именем с использованием заданного свидетельства.</summary>
        <returns>Значение, возвращаемое точкой входа сборки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.AppDomain.ExecuteAssemblyByName%2A> предоставляет аналогичные функции методу <xref:System.AppDomain.ExecuteAssembly%2A>, но указывает сборку по отображаемому имени или <xref:System.Reflection.AssemblyName>, а не по расположению файла. Таким образом, <xref:System.AppDomain.ExecuteAssemblyByName%2A> загружает сборки с помощью метода <xref:System.Reflection.Assembly.Load%2A>, а не метода <xref:System.Reflection.Assembly.LoadFile%2A>.  
  
 Сборка начинает выполняться в точке входа, указанной в заголовке .NET Framework.  
  
 Метод <xref:System.AppDomain.ExecuteAssemblyByName%2A> не создает новый процесс или домен приложения и не выполняет метод точки входа в новом потоке.  
  
> [!NOTE]
>  При использовании метода <xref:System.AppDomain.ExecuteAssemblyByName%2A> с параметром <xref:System.Security.Policy.Evidence> объединяются части свидетельств. Части свидетельства, предоставленные в качестве аргумента методу <xref:System.AppDomain.ExecuteAssemblyByName%2A>, заменяют части свидетельств, предоставляемые загрузчиком.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="assemblyName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Сборка, заданная параметром <paramref name="assemblyName" />, не найдена.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка, заданная параметром <paramref name="assemblyName" />, найдена, но загрузить ее не удалось.</exception>
        <exception cref="T:System.BadImageFormatException">Сборка, заданная параметром <paramref name="assemblyName" />, недопустимая.  
  
-или- 
В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyName" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <exception cref="T:System.MissingMethodException">Указанная сборка не имеет точки входа.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к чтению из файла или каталога, для доступа к сведениям в самом пути, а также для перенаправления отображаемого имени в путь. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для загрузки сборки с свидетельством. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Net.WebPermission">для доступа к веб-сайту, когда отображаемое имя перенаправляется на URL-адрес.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">для выполнения консольного приложения. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-2.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">Отображаемое имя сборки. См. <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="args">Аргументы командной строки для передачи при запуске процесса.</param>
        <summary>Выполняет сборку с заданным отображаемым именем с использованием заданных аргументов.</summary>
        <returns>Значение, возвращаемое точкой входа сборки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.AppDomain.ExecuteAssemblyByName%2A> предоставляет аналогичные функции методу <xref:System.AppDomain.ExecuteAssembly%2A>, но указывает сборку по отображаемому имени или <xref:System.Reflection.AssemblyName>, а не по расположению файла. Таким образом, <xref:System.AppDomain.ExecuteAssemblyByName%2A> загружает сборки с помощью метода <xref:System.Reflection.Assembly.Load%2A>, а не метода <xref:System.Reflection.Assembly.LoadFile%2A>.  
  
 Сборка начинает выполняться в точке входа, указанной в заголовке .NET Framework.  
  
 Этот метод не создает новый процесс или домен приложения и не выполняет метод точки входа в новом потоке.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="assemblyName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Сборка, заданная параметром <paramref name="assemblyName" />, не найдена.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка, заданная параметром <paramref name="assemblyName" />, найдена, но загрузить ее не удалось.</exception>
        <exception cref="T:System.BadImageFormatException">Сборка, заданная параметром <paramref name="assemblyName" />, недопустимая.  
  
-или- 
 Сборка <paramref name="assemblyName" /> была скомпилирована в более поздней версии среды CLR, чем версия, загруженная в текущий момент.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <exception cref="T:System.MissingMethodException">Указанная сборка не имеет точки входа.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к чтению из файла или каталога, для доступа к сведениям в самом пути, а также для перенаправления отображаемого имени в путь. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">для доступа к веб-сайту, когда отображаемое имя перенаправляется на URL-адрес.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">для выполнения консольного приложения. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : System.Reflection.AssemblyName * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">Объект <see cref="T:System.Reflection.AssemblyName" />, представляющий имя сборки.</param>
        <param name="assemblySecurity">Свидетельство для загрузки сборки.</param>
        <param name="args">Аргументы командной строки для передачи при запуске процесса.</param>
        <summary>Выполняет сборку с заданным <see cref="T:System.Reflection.AssemblyName" /> с использованием заданного свидетельства и аргументов.</summary>
        <returns>Значение, возвращаемое точкой входа сборки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.AppDomain.ExecuteAssemblyByName%2A> предоставляет аналогичные функции методу <xref:System.AppDomain.ExecuteAssembly%2A>, но указывает сборку по отображаемому имени или <xref:System.Reflection.AssemblyName>, а не по расположению файла. Таким образом, <xref:System.AppDomain.ExecuteAssemblyByName%2A> загружает сборки с помощью метода <xref:System.Reflection.Assembly.Load%2A>, а не метода <xref:System.Reflection.Assembly.LoadFile%2A>.  
  
 Сборка начинает выполняться в точке входа, указанной в заголовке .NET Framework.  
  
 Этот метод не создает новый процесс или домен приложения и не выполняет метод точки входа в новом потоке.  
  
> [!NOTE]
>  При использовании метода <xref:System.AppDomain.ExecuteAssemblyByName%2A> с параметром <xref:System.Security.Policy.Evidence> объединяются части свидетельств. Части свидетельства, предоставленные в качестве аргумента методу <xref:System.AppDomain.ExecuteAssemblyByName%2A>, заменяют части свидетельств, предоставляемые загрузчиком.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Сборка, заданная параметром <paramref name="assemblyName" />, не найдена.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка, заданная параметром <paramref name="assemblyName" />, найдена, но загрузить ее не удалось.</exception>
        <exception cref="T:System.BadImageFormatException">Сборка, заданная параметром <paramref name="assemblyName" />, недопустимая.  
  
-или- 
В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyName" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <exception cref="T:System.NotSupportedException">Значение <paramref name="assemblySecurity" /> не <see langword="null" />. Когда устаревшие политики разграничения доступа кода не включены, <paramref name="assemblySecurity" /> должен равняться <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Указанная сборка не имеет точки входа.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к чтению из файла или каталога, для доступа к сведениям в самом пути, а также для перенаправления отображаемого имени в путь. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для загрузки сборки с свидетельством. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Net.WebPermission">для доступа к веб-сайту, когда отображаемое имя перенаправляется на URL-адрес.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">для выполнения консольного приложения. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">Отображаемое имя сборки. См. <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="assemblySecurity">Свидетельство для загрузки сборки.</param>
        <param name="args">Аргументы командной строки для передачи при запуске процесса.</param>
        <summary>Выполняет сборку с заданным отображаемым именем с использованием заданного свидетельства и аргументов.</summary>
        <returns>Значение, возвращаемое точкой входа сборки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.AppDomain.ExecuteAssemblyByName%2A> предоставляет аналогичные функции методу <xref:System.AppDomain.ExecuteAssembly%2A>, но указывает сборку по отображаемому имени или <xref:System.Reflection.AssemblyName>, а не по расположению файла. Таким образом, <xref:System.AppDomain.ExecuteAssemblyByName%2A> загружает сборки с помощью метода <xref:System.Reflection.Assembly.Load%2A>, а не метода <xref:System.Reflection.Assembly.LoadFile%2A>.  
  
 Сборка начинает выполняться в точке входа, указанной в заголовке .NET Framework.  
  
 Этот метод не создает новый процесс или домен приложения и не выполняет метод точки входа в новом потоке.  
  
> [!NOTE]
>  При использовании метода <xref:System.AppDomain.ExecuteAssemblyByName%2A> с параметром <xref:System.Security.Policy.Evidence> объединяются части свидетельств. Части свидетельства, предоставленные в качестве аргумента методу <xref:System.AppDomain.ExecuteAssemblyByName%2A>, заменяют части свидетельств, предоставляемые загрузчиком.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="assemblyName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Сборка, заданная параметром <paramref name="assemblyName" />, не найдена.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка, заданная параметром <paramref name="assemblyName" />, найдена, но загрузить ее не удалось.</exception>
        <exception cref="T:System.BadImageFormatException">Сборка, заданная параметром <paramref name="assemblyName" />, недопустимая.  
  
-или- 
В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyName" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <exception cref="T:System.NotSupportedException">Значение <paramref name="assemblySecurity" /> не <see langword="null" />. Когда устаревшие политики разграничения доступа кода не включены, <paramref name="assemblySecurity" /> должен равняться <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Указанная сборка не имеет точки входа.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к чтению из файла или каталога, для доступа к сведениям в самом пути, а также для перенаправления отображаемого имени в путь. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для загрузки сборки с свидетельством. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Net.WebPermission">для доступа к веб-сайту, когда отображаемое имя перенаправляется на URL-адрес.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">для выполнения консольного приложения. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="FirstChanceException">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.FirstChanceException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FirstChanceException As EventHandler(Of FirstChanceExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Runtime::ExceptionServices::FirstChanceExceptionEventArgs ^&gt; ^ FirstChanceException;" />
      <MemberSignature Language="F#" Value="member this.FirstChanceException : EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; " Usage="member this.FirstChanceException : System.EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при создании исключения в управляемом коде, перед тем как среда выполнения ищет стек вызовов для обработчика исключений в домене приложений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие является только уведомлением. Обработка этого события не обрабатывает исключение или влияет на последующую обработку исключений каким бы то ни было образом. После того как событие вызвано и были вызваны обработчики событий, среда CLR начинает поиск обработчика для исключения. <xref:System.AppDomain.FirstChanceException> предоставляет домен приложения первой возможностью исследовать любое управляемое исключение.  
  
 Событие может быть обработано для каждого домена приложения. Если поток проходит через несколько доменов приложений во время выполнения вызова, событие возникает в каждом домене приложения, который зарегистрировал обработчик событий, прежде чем среда CLR начнет поиск соответствующего обработчика исключений в этом домене приложения. После обработки события выполняется поиск соответствующего обработчика исключений в этом домене приложения. Если ничего не найдено, событие возникает в следующем домене приложения.  
  
 Необходимо выполнить обработку всех исключений, происходящих в обработчике событий для события <xref:System.AppDomain.FirstChanceException>. В противном случае <xref:System.AppDomain.FirstChanceException> вызывается рекурсивно. Это может привести к переполнению стека и завершению работы приложения. Рекомендуется реализовать обработчики событий для этого события в виде областей ограниченного выполнения (CER), чтобы исключения, связанные с инфраструктурой, такие как нехваткой памяти или переполнение стека, не влияли на виртуальную машину, пока не будет уведомление об исключении. обрабатывается.  
  
 Это событие не вызывается для исключений, которые указывают на повреждение состояния процесса, например нарушения прав доступа, если только обработчик событий не является критически важным для безопасности и имеет атрибут <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>.  
  
 Среда CLR приостанавливает прерывание потока во время обработки этого события уведомления.  
  
   
  
## Examples  
 В следующем примере создается ряд доменов приложений с именем `AD0` через `AD3`с объектом `Worker` в каждом домене приложения. Каждый объект `Worker` имеет ссылку на объект `Worker` в следующем домене приложения, за исключением `Worker` в последнем домене приложения. Событие <xref:System.AppDomain.FirstChanceException> обрабатывается во всех доменах приложений, кроме `AD1`.  
  
> [!NOTE]
>  В дополнение к этому примеру, в котором демонстрируются уведомления о первичных исключениях в нескольких доменах приложений, можно найти простые варианты использования, [чтобы получать уведомления о первых исключениях](~/docs/framework/app-domains/how-to-receive-first-chance-exception-notifications.md).  
  
 После создания доменов приложений домен приложения по умолчанию вызывает метод `TestException` для первого домена приложения. Каждый объект `Worker` вызывает метод `TestException` для следующего домена приложения до тех пор, пока последний `Worker` не выдаст исключение, которое либо обработано, либо не обрабатывается. Таким же, текущий поток проходит через все домены приложений, а `TestException` добавляется в стек в каждом домене приложения.  
  
 Когда в последнем объекте `Worker` обрабатывается исключение, событие <xref:System.AppDomain.FirstChanceException> возникает только в последнем домене приложения. Другие домены приложений никогда не получают возможность обработки исключения, поэтому событие не возникает.  
  
 Когда последний объект `Worker` не обрабатывает исключение, событие <xref:System.AppDomain.FirstChanceException> возникает в каждом домене приложения с обработчиком событий. После завершения каждого обработчика событий стек продолжит работать до тех пор, пока исключение не будет перехвачено доменом приложения по умолчанию.  
  
> [!NOTE]
>  Чтобы увидеть, как растет отображение стека по мере того, как событие порождается ближе к домену приложения по умолчанию, измените `e.Exception.Message` на `e.Exception` в обработчике `FirstChanceHandler` событий. Обратите внимание, что когда `TestException` вызывается через границы домена приложения, он появляется дважды: один раз для прокси-сервера и один раз для заглушки.  
  
 [!code-csharp[System.AppDomain.FirstChanceException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/cs/example.cs#1)]
 [!code-vb[System.AppDomain.FirstChanceException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="T:System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs" />
        <altmember cref="E:System.AppDomain.UnhandledException" />
        <related type="Article" href="https://msdn.microsoft.com/library/66f002b8-a97d-4a6e-a503-2cec01689113">Практическое руководство. Получение уведомлений о первом этапе обработки исключений</related>
      </Docs>
    </Member>
    <Member MemberName="FriendlyName">
      <MemberSignature Language="C#" Value="public string FriendlyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FriendlyName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.FriendlyName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FriendlyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FriendlyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FriendlyName : string" Usage="System.AppDomain.FriendlyName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.FriendlyName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает понятное имя этого домена приложения.</summary>
        <value>Понятное имя этого домена приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Понятное имя домена приложения по умолчанию — имя исполняемого файла процесса. Например, если исполняемый файл, используемый для запуска процесса, `"c:\MyAppDirectory\MyAssembly.exe"`, понятное имя домена приложения по умолчанию — `"MyAssembly.exe"`.  
  
   
  
## Examples  
 В следующем примере кода свойство <xref:System.AppDomain.FriendlyName%2A> используется для получения понятного имени текущего домена приложения. Для домена приложения по умолчанию понятное имя — это имя исполняемого файла приложения. В примере кода также отображаются дополнительные сведения о домене приложения.  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] GetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly[] GetAssemblies() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Assembly ^&gt; ^ GetAssemblies();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.GetAssemblies : unit -&gt; System.Reflection.Assembly[]" Usage="appDomain.GetAssemblies " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly[] GetAssemblies() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Assembly ^&gt; ^ GetAssemblies();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetAssemblies : unit -&gt; System.Reflection.Assembly[]&#xA;override this.GetAssemblies : unit -&gt; System.Reflection.Assembly[]" Usage="appDomain.GetAssemblies " FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetAssemblies</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает сборки, которые были загружены в контекст выполнения этого домена приложения.</summary>
        <returns>Массив сборок в этом домене приложения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода используется метод <xref:System.AppDomain.GetAssemblies%2A> для получения списка всех сборок, загруженных в домен приложения. Затем сборки отображаются в консоли.  
  
 Чтобы запустить этот пример кода, необходимо создать сборку с именем `CustomLibrary.dll`или изменить имя сборки, которая передается методу <xref:System.AppDomain.GetAssemblies%2A>.  
  
 [!code-cpp[ADGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetAssemblies/CPP/adgetassemblies.cpp#1)]
 [!code-csharp[ADGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetAssemblies/CS/adgetassemblies.cs#1)]
 [!code-vb[ADGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetAssemblies/VB/adgetassemblies.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentThreadId">
      <MemberSignature Language="C#" Value="public static int GetCurrentThreadId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentThreadId() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetCurrentThreadId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentThreadId () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentThreadId();" />
      <MemberSignature Language="F#" Value="static member GetCurrentThreadId : unit -&gt; int" Usage="System.AppDomain.GetCurrentThreadId " />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;kernel32.dll&quot; as &quot;GetCurrentThreadId&quot; winapi)int32 GetCurrentThreadId() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.'")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.  https://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.  https://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает текущий идентификатор потока.</summary>
        <returns>32-битовое целое число со знаком, являющееся идентификатором текущего потока.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте свойство <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType>, которое является стабильным, даже если .NET Framework размещается в среде, поддерживающей волокна (то есть в облегченных потоках).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для вызова этого метода. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />. Действие безопасности: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
        <altmember cref="T:System.Int32" />
        <altmember cref="P:System.Threading.Thread.ManagedThreadId" />
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public object GetData (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetData(string name) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetData(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetData (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetData(System::String ^ name);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.GetData : string -&gt; obj" Usage="appDomain.GetData name" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetData(string name) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetData(System::String ^ name);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetData : string -&gt; obj&#xA;override this.GetData : string -&gt; obj" Usage="appDomain.GetData name" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetData(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Имя предопределенного свойства домена приложения или имя определенного вами свойства домена приложения.</param>
        <summary>Возвращает значение, сохраненное в текущем домене приложения для заданного имени.</summary>
        <returns>Значение свойства <paramref name="name" /> или значение <see langword="null" />, если это свойство не существует.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется для получения значения записи во внутреннем кэше пар "имя-данные", описывающих свойства данного экземпляра <xref:System.AppDomain>. Обратите внимание, что при сравнении `name` с именем пар "ключ-значение" учитывается регистр.  
  
 Кэш автоматически содержит стандартные системные записи, которые вставляются при создании домена приложения. Можно проверить их значения с помощью метода <xref:System.AppDomain.GetData%2A> или эквивалентного <xref:System.AppDomainSetup> свойств.  
  
 Можно вставить или изменить пользовательские пары имя-данные с помощью метода <xref:System.AppDomain.SetData%2A> и проверить их значения с помощью метода <xref:System.AppDomain.GetData%2A>.  
  
 В следующей таблице описаны `name` для каждой предопределенной системной записи и соответствующего свойства <xref:System.AppDomainSetup>.  
  
|Значение "имя"|Свойство|  
|---------------------|--------------|  
|AppBase|<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>|  
|"APP_CONFIG_FILE"|<xref:System.AppDomainSetup.ConfigurationFile%2A?displayProperty=nameWithType>|  
|"APP_LAUNCH_URL"|(нет свойства)<br /><br /> "APP_LAUNCH_URL" представляет URL-адрес, изначально запрошенный пользователем, перед любым перенаправлением. Он доступен только в том случае, если приложение запущено с браузером, например Internet Explorer. Не все браузеры предоставляют это значение.|  
|"APP_NAME"|<xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType>|  
|"BINPATH_PROBE_ONLY"|<xref:System.AppDomainSetup.PrivateBinPathProbe%2A?displayProperty=nameWithType>|  
|"CACHE_BASE"|<xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType>|  
|"CODE_DOWNLOAD_DISABLED"|<xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType>|  
|"DEV_PATH"|(нет свойства)|  
|"DISALLOW_APP"|<xref:System.AppDomainSetup.DisallowPublisherPolicy%2A?displayProperty=nameWithType>|  
|"DISALLOW_APP_BASE_PROBING"|<xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A?displayProperty=nameWithType>|  
|"DISALLOW_APP_REDIRECTS"|<xref:System.AppDomainSetup.DisallowBindingRedirects%2A?displayProperty=nameWithType>|  
|"DYNAMIC_BASE"|<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType>|  
|"FORCE_CACHE_INSTALL"|<xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType>|  
|"LICENSE_FILE" или строка для конкретного приложения|<xref:System.AppDomainSetup.LicenseFile%2A?displayProperty=nameWithType>|  
|"LOADER_OPTIMIZATION"|<xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=nameWithType>|  
|"LOCATION_URI"|(нет свойства)|  
|"PRIVATE_BINPATH"|<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>|  
|"REGEX_DEFAULT_MATCH_TIMEOUT"|<xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A?displayProperty=nameWithType><br /><br /> "REGEX_DEFAULT_MATCH_TIMEOUT" не является системной записью, и ее значение можно задать, вызвав метод <xref:System.AppDomain.SetData%2A>.|  
|"SHADOW_COPY_DIRS"|<xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType>|  
  
   
  
## Examples  
 В следующем примере создается новый домен приложения, задается предоставляемое системой значение для домена и добавляется новая пара значений для домена. В примере демонстрируется использование метода <xref:System.AppDomain.GetData%2A> для получения данных из этих пар значений и их отображения в консоли.  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">значение для доступа к сведениям в самом пути, если свойство применяется к пути. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="M:System.AppDomain.SetData(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="appDomain.GetType " />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" FrameworkAlternate="netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" FrameworkAlternate="netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает тип текущего экземпляра.</summary>
        <returns>Тип текущего экземпляра.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.AppDomain.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает целое число, однозначно идентифицирующее домен приложения в процессе.</summary>
        <value>Целое число, идентифицирующее домен приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода создается второй домен приложения и отображаются сведения о домене по умолчанию и новом домене.  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeLifetimeService">
      <MemberSignature Language="C#" Value="public override object InitializeLifetimeService ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InitializeLifetimeService() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.InitializeLifetimeService" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function InitializeLifetimeService () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ InitializeLifetimeService();" />
      <MemberSignature Language="F#" Value="override this.InitializeLifetimeService : unit -&gt; obj" Usage="appDomain.InitializeLifetimeService " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.InitializeLifetimeService</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Предоставляет объекту <see cref="T:System.AppDomain" /> бесконечное время существования путем предотвращения ограничения времени его существования.</summary>
        <returns>Всегда <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsCompatibilitySwitchSet">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; IsCompatibilitySwitchSet (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; IsCompatibilitySwitchSet(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsCompatibilitySwitchSet (value As String) As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;bool&gt; IsCompatibilitySwitchSet(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsCompatibilitySwitchSet : string -&gt; Nullable&lt;bool&gt;" Usage="appDomain.IsCompatibilitySwitchSet value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Проверяемый переключатель совместимости.</param>
        <summary>Получает логическое значение, допускающее значения NULL, которое указывает, установлены ли какие-либо переключатели совместимости и, если установлены, установлен ли заданный переключатель совместимости.</summary>
        <returns>Пустая ссылка (<see langword="Nothing" /> в Visual Basic), если переключатели совместимости не установлены; в противном случае логическое значение, указывающее, установлен ли переключатель совместимости, заданный параметром <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод проверяет, установлен ли указанный параметр совместимости для текущего домена приложения. Параметры совместимости обычно восстанавливают поведение (например, способ сортировки строк), которое изменилось между версиями .NET Framework.  Они задаются путем вызова метода <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=nameWithType> перед созданием домена приложения.  
  
 В следующей таблице приведены примеры параметров совместимости, которые можно задать для восстановления поведения более ранних версий .NET Framework.  
  
|Параметр|Значение|  
|------------|-------------|  
|"NetFx40_LegacySecurityPolicy"|Управление доступом для кода (CAS) для [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] включено в этом домене приложения. См. раздел [&lt;NetFx40_LegacySecurityPolicy&gt; element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).|  
|"NetFx40_Legacy20SortingBehavior"|Значения сортировки строк по умолчанию для [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] включены в этом домене приложения. Для его успешного выполнения требуется установка sort00001000. dll. См. раздел [&lt;компатсортнлсверсион&gt; element](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md).|  
|"NetFx40_Legacy40SortingBehavior"|Значения сортировки строк по умолчанию для [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]и Юникод 5,0 включены в этом домене приложения. Для его успешного выполнения требуется установка sort00060101. dll.|  
|"NetFx40_TimeSpanLegacyFormatMode"|поведение форматирования <xref:System.TimeSpan> для [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] включено в этом домене приложения.  См. раздел [&lt;TimeSpan_LegacyFormatMode&gt;](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md) и "восстановление прежних версий форматирования TimeSpan" раздела <xref:System.TimeSpan>.|  
|UseRandomizedStringHashAlgorithm|Среда выполнения вычисляет хэш-коды для строк на уровне каждого приложения вместо использования единого алгоритма хэширования, который создает согласованный хэш-код между доменами приложений. См. раздел [&lt;UseRandomizedStringHashAlgorithm&gt; element](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md).|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})" />
      </Docs>
    </Member>
    <Member MemberName="IsDefaultAppDomain">
      <MemberSignature Language="C#" Value="public bool IsDefaultAppDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsDefaultAppDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsDefaultAppDomain" />
      <MemberSignature Language="VB.NET" Value="Public Function IsDefaultAppDomain () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsDefaultAppDomain();" />
      <MemberSignature Language="F#" Value="member this.IsDefaultAppDomain : unit -&gt; bool" Usage="appDomain.IsDefaultAppDomain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, является ли домен приложения используемым по умолчанию доменом для процесса.</summary>
        <returns><see langword="true" />, если текущий объект <see cref="T:System.AppDomain" /> представляет используемый по умолчанию домен приложения для процесса, в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждый управляемый процесс имеет домен приложения по умолчанию. Выполнение начинается в домене по умолчанию.  
  
   
  
## Examples  
 В следующем примере кода создается второй домен приложения и отображаются сведения о домене по умолчанию и новом домене.  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFinalizingForUnload">
      <MemberSignature Language="C#" Value="public bool IsFinalizingForUnload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsFinalizingForUnload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsFinalizingForUnload" />
      <MemberSignature Language="VB.NET" Value="Public Function IsFinalizingForUnload () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsFinalizingForUnload();" />
      <MemberSignature Language="F#" Value="member this.IsFinalizingForUnload : unit -&gt; bool" Usage="appDomain.IsFinalizingForUnload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Определяет, выгружен ли этот домен приложения, и были ли закрыты средой CLR объекты, которые он содержал.</summary>
        <returns><see langword="true" />, если этот домен приложения выгружен, и среда CLR начала вызов методов завершения, в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод финализации для объекта предоставляет возможность выполнять все необходимые операции очистки до того, как объект будет удален сборщиком мусора. После завершения объект доступен, но находится в недопустимом состоянии и поэтому непригоден для использования. Со временем сборка мусора завершается и освобождает объект.  
  
 Метод финализации объекта вызывается в одной из следующих ситуаций: во время сборки мусора, при завершении работы среды CLR или при выгрузке домена приложения, содержащего этот объект. Метод <xref:System.AppDomain.IsFinalizingForUnload%2A> возвращает `true` только в последнем случае; Он не возвращает `true`, если окончательная сборка мусора выполняется из подпрограмм или из среды CLR.  
  
> [!NOTE]
>  Чтобы определить, вызвано ли завершение средой CLR, используйте свойство <xref:System.Environment.HasShutdownStarted%2A?displayProperty=nameWithType>. Он возвращает `true`, если завершение вызвано выгрузкой домена приложения или завершением работы CLR.  
  
 При выполнении метода завершения во время выгрузки домена может потребоваться доступ к другому объекту, на который ссылается статическое поле, и метод финализации. Однако вы не можете надежно сделать это, так как объект, к которому можно получить доступ, уже был завершен.  
  
> [!NOTE]
>  Исключением из этого правила является класс <xref:System.Console>, который содержит статические поля, ссылающиеся на объекты потока, но реализуется особым образом, что позволяет всегда выполнять запись в системную консоль даже во время выгрузки домена или завершения работы системы.  
  
 Используйте этот метод в методе финализации объекта, чтобы определить, выгружается ли домен приложения, содержащий объект. В этом случае нельзя надежно получить доступ к любому объекту, у которого есть метод финализации, и на который ссылается статическое поле.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Environment.HasShutdownStarted" />
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsFullyTrusted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFullyTrusted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFullyTrusted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFullyTrusted : bool" Usage="System.AppDomain.IsFullyTrusted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, выполняются ли сборки, загруженные в текущий домен приложения, с полным доверием.</summary>
        <value>Значение <see langword="true" />, если сборки, загруженные в текущий домен приложения, выполняются с полным доверием; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод всегда возвращает `true` для домена приложения по умолчанию приложения, которое выполняется на рабочем столе. Он возвращает `false` для домена изолированного приложения, созданного с помощью перегрузки метода <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType>, если только разрешения, предоставленные домену приложения, эквивалентны полному доверию.  
  
   
  
## Examples  
 В следующем примере демонстрируется свойство <xref:System.AppDomain.IsFullyTrusted%2A> и свойство <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> с полностью доверенными и частично доверенными доменами приложений. Полностью доверенный домен приложения — это домен приложения по умолчанию для приложения. Домен приложения с частичным доверием создается с помощью перегрузки метода <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType>.  
  
 В примере используется класс `Worker`, производный от <xref:System.MarshalByRefObject>, поэтому его можно маршалировать через границы домена приложения. В примере создается объект `Worker` в домене приложения по умолчанию. Затем он вызывает метод `TestIsFullyTrusted` для вывода значения свойства для домена приложения и для двух сборок, которые загружаются в домен приложения: mscorlib, который является частью .NET Framework, и примера сборки. Домен приложения является полностью доверенным, поэтому обе сборки являются полностью доверенными.  
  
 В примере создается другой объект `Worker` в изолированном домене приложения и снова вызывается метод `TestIsFullyTrusted`. Mscorlib всегда является доверенным, даже в домене приложения с частичным доверием, но пример сборки является частично доверенным.  
  
 [!code-csharp[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/cs/example.cs#1)]
 [!code-vb[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHomogenous">
      <MemberSignature Language="C#" Value="public bool IsHomogenous { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHomogenous" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsHomogenous" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHomogenous As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHomogenous { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsHomogenous : bool" Usage="System.AppDomain.IsHomogenous" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, имеет ли текущий домен приложения набор разрешений, которые предоставляются всем сборкам, загружаемым в домен приложения.</summary>
        <value>Значение <see langword="true" />, если текущий домен приложения имеет однородный набор разрешений; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство возвращает `true` для доменов изолированных приложений, созданных с помощью перегрузки метода <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType>. Изолированные домены приложений имеют однородный набор разрешений. то есть один и тот же набор разрешений предоставляется всем частично доверенным сборкам, загруженным в домен приложения. Домен изолированного приложения, при необходимости, имеет список сборок со строгими именами, которые исключены из этого набора разрешений, а выполняются с полным доверием.  
  
 Полностью доверенный код может использовать свойство <xref:System.AppDomain.PermissionSet%2A>, чтобы определить однородный набор разрешений изолированного домена приложения.  
  
 Это свойство также возвращает `true` для домена приложения по умолчанию для классического приложения, так как этот домен приложения предоставляет полное доверие всем сборкам.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomain.PermissionSet" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Загружает сборку <see cref="T:System.Reflection.Assembly" /> в этот домен приложения.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.Load : byte[] -&gt; System.Reflection.Assembly" Usage="appDomain.Load rawAssembly" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] -&gt; System.Reflection.Assembly" Usage="appDomain.Load rawAssembly" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Массив типа <see langword="byte" />, который является образом в формате COFF, содержащим порожденную сборку.</param>
        <summary>Загружает объект <see cref="T:System.Reflection.Assembly" /> с образом в формате COFF, содержащим созданный объект <see cref="T:System.Reflection.Assembly" />.</summary>
        <returns>Загруженная сборка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], уровень доверия сборки, загружаемой с помощью этого метода, совпадает с уровнем доверия домена приложения.  
  
 Этот метод следует использовать только для загрузки сборки в текущий домен приложения. Этот метод предоставляется для удобства взаимодействия вызывающих методов, которые не могут вызывать статический метод <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>. Чтобы загрузить сборки в другие домены приложений, используйте такой метод, как <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Сведения, общие для всех перегрузок этого метода, см. в описании перегрузки метода <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование загрузки необработанной сборки.  
  
 Для выполнения этого примера кода необходимо указать полное имя сборки. Дополнительные сведения о получении полного имени сборки см. в разделе [имена сборок](~/docs/standard/assembly/names.md).  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="rawAssembly" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">Тип <paramref name="rawAssembly" /> не является допустимой сборкой.  
  
-или- 
В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="rawAssembly" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль были загружены дважды с двумя разными свидетельствами.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к чтению из файла или каталога, а также для доступа к данным в самом пути. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="appDomain.Load assemblyRef" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly&#xA;override this.Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="appDomain.Load assemblyRef" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">Объект, который описывает сборку, подлежащую загрузке.</param>
        <summary>Загружает сборку <see cref="T:System.Reflection.Assembly" />, заданную ее именем <see cref="T:System.Reflection.AssemblyName" />.</summary>
        <returns>Загруженная сборка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод следует использовать только для загрузки сборки в текущий домен приложения. Этот метод предоставляется для удобства взаимодействия вызывающих методов, которые не могут вызывать статический метод <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>. Чтобы загрузить сборки в другие домены приложений, используйте такой метод, как <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Если версия запрошенной сборки уже загружена, этот метод возвращает загруженную сборку, даже если запрошена другая версия.  
  
 Не рекомендуется указывать частичное имя сборки для `assemblyRef`. (Частичное имя пропускает один или несколько языков и региональных параметров, версии или маркера открытого ключа. Для перегрузок, принимающих строку вместо объекта <xref:System.Reflection.AssemblyName>, "MyAssembly, Version = 1.0.0.0" — это пример частичного имени, а "MyAssembly, Version = 1.0.0.0, культура = Neutral, PublicKeyToken = 18ab3442da84b47" — пример полного имени.) Использование частичных имен отрицательно сказывается на производительности. Кроме того, частичное имя сборки может загружать сборку из глобального кэша сборок только в том случае, если в базовом каталоге приложения имеется точная копия сборки (<xref:System.AppDomain.BaseDirectory%2A> или <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>).  
  
 Если текущий объект <xref:System.AppDomain> представляет домен приложения `A`, а метод <xref:System.AppDomain.Load%2A> вызывается из `B`домена приложения, сборка загружается в оба домена приложений. Например, следующий код загружает `MyAssembly` в новый домен приложения `ChildDomain`, а также в домен приложения, в котором выполняется код:  
  
 [!code-cpp[System.AppDomain.Load#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.load/cpp/source.cpp#1)]
 [!code-csharp[System.AppDomain.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.load/cs/source.cs#1)]
 [!code-vb[System.AppDomain.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.load/vb/source.vb#1)]  
  
 Сборка загружается в оба домена, так как <xref:System.Reflection.Assembly> не являются производными от <xref:System.MarshalByRefObject>и поэтому возвращаемое значение метода <xref:System.AppDomain.Load%2A> не может быть упаковано. Вместо этого среда CLR пытается загрузить сборку в вызывающий домен приложения. Сборки, загруженные в два домена приложений, могут отличаться, если параметры пути для двух доменов приложений различаются.  
  
> [!NOTE]
>  Если заданы и свойство <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType>, и свойство <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType>, первая попытка загрузки сборки использует отображаемое имя (включая версию, культуру и т. д.), возвращенное свойством <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType>). Если файл не найден, для поиска сборки используется свойство <xref:System.Reflection.AssemblyName.CodeBase%2A>. Если сборка найдена с помощью <xref:System.Reflection.AssemblyName.CodeBase%2A>, отображаемое имя сопоставляется со сборкой. Если сопоставление завершается неудачей, выдается <xref:System.IO.FileLoadException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="assemblyRef" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyRef" /> не найден.</exception>
        <exception cref="T:System.BadImageFormatException">Тип <paramref name="assemblyRef" /> не является допустимой сборкой.  
  
-или- 
В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyRef" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль были загружены дважды с двумя разными свидетельствами.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к чтению из файла или каталога, а также для доступа к данным в самом пути. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly Load(string assemblyString) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ Load(System::String ^ assemblyString);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.Load : string -&gt; System.Reflection.Assembly" Usage="appDomain.Load assemblyString" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member Load : string -&gt; System.Reflection.Assembly&#xA;override this.Load : string -&gt; System.Reflection.Assembly" Usage="appDomain.Load assemblyString" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">Отображаемое имя сборки. См. <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <summary>Загружает сборку <see cref="T:System.Reflection.Assembly" />, заданную ее отображаемым именем.</summary>
        <returns>Загруженная сборка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод следует использовать только для загрузки сборки в текущий домен приложения. Этот метод предоставляется для удобства взаимодействия вызывающих методов, которые не могут вызывать статический метод <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>. Чтобы загрузить сборки в другие домены приложений, используйте такой метод, как <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Сведения, общие для всех перегрузок этого метода, см. в описании перегрузки метода <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyString" /> равно <see langword="null" /></exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyString" /> не найден.</exception>
        <exception cref="T:System.BadImageFormatException">Тип <paramref name="assemblyString" /> не является допустимой сборкой.  
  
-или- 
В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyString" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль были загружены дважды с двумя разными свидетельствами.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к чтению из файла или каталога, а также для доступа к данным в самом пути. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">значение для возможности доступа к расположению сборки, если сборка не является локальной.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.Load : byte[] * byte[] -&gt; System.Reflection.Assembly" Usage="appDomain.Load (rawAssembly, rawSymbolStore)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] * byte[] -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] * byte[] -&gt; System.Reflection.Assembly" Usage="appDomain.Load (rawAssembly, rawSymbolStore)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Массив типа <see langword="byte" />, который является образом в формате COFF, содержащим порожденную сборку.</param>
        <param name="rawSymbolStore">Массив типа <see langword="byte" />, содержащий необработанные байты, которые представляют символы для сборки.</param>
        <summary>Загружает объект <see cref="T:System.Reflection.Assembly" /> с образом в формате COFF, содержащим созданный объект <see cref="T:System.Reflection.Assembly" />. Загружаются также необработанные байты, представляющие символы для <see cref="T:System.Reflection.Assembly" />.</summary>
        <returns>Загруженная сборка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], уровень доверия сборки, загружаемой с помощью этого метода, совпадает с уровнем доверия домена приложения.  
  
 Этот метод следует использовать только для загрузки сборки в текущий домен приложения. Этот метод предоставляется для удобства взаимодействия вызывающих методов, которые не могут вызывать статический метод <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>. Чтобы загрузить сборки в другие домены приложений, используйте такой метод, как <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Сведения, общие для всех перегрузок этого метода, см. в описании перегрузки метода <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование загрузки необработанной сборки.  
  
 Для выполнения этого примера кода необходимо указать полное имя сборки. Дополнительные сведения о получении полного имени сборки см. в разделе [имена сборок](~/docs/standard/assembly/names.md).  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="rawAssembly" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">Тип <paramref name="rawAssembly" /> не является допустимой сборкой.  
  
-или- 
В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="rawAssembly" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль были загружены дважды с двумя разными свидетельствами.</exception>
        <permission cref="T:System.Net.WebPermission">для чтения URI, который не начинается с "file://".</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к чтению из файла или каталога, а также для доступа к данным в самом пути. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef, System::Security::Policy::Evidence ^ assemblySecurity);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (assemblyRef, assemblySecurity)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef, System::Security::Policy::Evidence ^ assemblySecurity);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (assemblyRef, assemblySecurity)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">Объект, который описывает сборку, подлежащую загрузке.</param>
        <param name="assemblySecurity">Свидетельство для загрузки сборки.</param>
        <summary>Загружает сборку <see cref="T:System.Reflection.Assembly" />, заданную ее именем <see cref="T:System.Reflection.AssemblyName" />.</summary>
        <returns>Загруженная сборка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод следует использовать только для загрузки сборки в текущий домен приложения. Этот метод предоставляется для удобства взаимодействия вызывающих методов, которые не могут вызывать статический метод <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>. Чтобы загрузить сборки в другие домены приложений, используйте такой метод, как <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Сведения, общие для всех перегрузок этого метода, см. в описании перегрузки метода <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyRef" /> равно <see langword="null" /></exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyRef" /> не найден.</exception>
        <exception cref="T:System.BadImageFormatException">Тип <paramref name="assemblyRef" /> не является допустимой сборкой.  
  
-или- 
В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyRef" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль были загружены дважды с двумя разными свидетельствами.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к чтению из файла или каталога, а также для доступа к данным в самом пути. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для загрузки сборки с свидетельством. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Net.WebPermission">для чтения пути, который не имеет формат "file://" или "\\\Унк\дир\\" или "c:\\".</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString, System::Security::Policy::Evidence ^ assemblySecurity);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (assemblyString, assemblySecurity)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ Load(System::String ^ assemblyString, System::Security::Policy::Evidence ^ assemblySecurity);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (assemblyString, assemblySecurity)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyString">Отображаемое имя сборки. См. <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="assemblySecurity">Свидетельство для загрузки сборки.</param>
        <summary>Загружает сборку <see cref="T:System.Reflection.Assembly" />, заданную ее отображаемым именем.</summary>
        <returns>Загруженная сборка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод следует использовать только для загрузки сборки в текущий домен приложения. Этот метод предоставляется для удобства взаимодействия вызывающих методов, которые не могут вызывать статический метод <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>. Чтобы загрузить сборки в другие домены приложений, используйте такой метод, как <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Сведения, общие для всех перегрузок этого метода, см. в описании перегрузки метода <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyString" /> равно <see langword="null" /></exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyString" /> не найден.</exception>
        <exception cref="T:System.BadImageFormatException">Тип <paramref name="assemblyString" /> не является допустимой сборкой.  
  
-или- 
В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyString" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль были загружены дважды с двумя разными свидетельствами.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для загрузки сборки с свидетельством. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к чтению из файла или каталога, а также для доступа к данным в самом пути. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">для чтения пути, который не имеет формат "file://" или "\\\Унк\дир\\" или "c:\\".</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte(), securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::Policy::Evidence ^ securityEvidence);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (rawAssembly, rawSymbolStore, securityEvidence)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::Policy::Evidence ^ securityEvidence);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (rawAssembly, rawSymbolStore, securityEvidence)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Массив типа <see langword="byte" />, который является образом в формате COFF, содержащим порожденную сборку.</param>
        <param name="rawSymbolStore">Массив типа <see langword="byte" />, содержащий необработанные байты, которые представляют символы для сборки.</param>
        <param name="securityEvidence">Свидетельство для загрузки сборки.</param>
        <summary>Загружает объект <see cref="T:System.Reflection.Assembly" /> с образом в формате COFF, содержащим созданный объект <see cref="T:System.Reflection.Assembly" />. Загружаются также необработанные байты, представляющие символы для <see cref="T:System.Reflection.Assembly" />.</summary>
        <returns>Загруженная сборка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], уровень доверия сборки, загружаемой с помощью этого метода, совпадает с уровнем доверия домена приложения.  
  
 Этот метод следует использовать только для загрузки сборки в текущий домен приложения. Этот метод предоставляется для удобства взаимодействия вызывающих методов, которые не могут вызывать статический метод <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>. Чтобы загрузить сборки в другие домены приложений, используйте такой метод, как <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Сведения, общие для всех перегрузок этого метода, см. в описании перегрузки метода <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование загрузки необработанной сборки.  
  
 Для выполнения этого примера кода необходимо указать полное имя сборки. Дополнительные сведения о получении полного имени сборки см. в разделе [имена сборок](~/docs/standard/assembly/names.md).  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="rawAssembly" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">Тип <paramref name="rawAssembly" /> не является допустимой сборкой.  
  
-или- 
В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="rawAssembly" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль были загружены дважды с двумя разными свидетельствами.</exception>
        <exception cref="T:System.NotSupportedException">Значение <paramref name="securityEvidence" /> не <see langword="null" />. Когда устаревшие политики разграничения доступа кода не включены, <paramref name="securityEvidence" /> должен равняться <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для предоставления свидетельства. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />. Действие безопасности: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к чтению из файла или каталога, а также для доступа к данным в самом пути. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">для чтения пути, который не имеет формат "file://" или "\\\Унк\дир\\" или "c:\\".</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringIsEnabled">
      <MemberSignature Language="C#" Value="public static bool MonitoringIsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MonitoringIsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringIsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property MonitoringIsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MonitoringIsEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringIsEnabled : bool with get, set" Usage="System.AppDomain.MonitoringIsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, включен ли мониторинг ЦП и памяти доменов приложений для текущего процесса. После того, как мониторинг для процесса включен, отключить его невозможно.</summary>
        <value>Значение<see langword="true" /> , если мониторинг включен; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство `static` (`Shared` свойство в Visual Basic) управляет мониторингом ЦП и памяти для всех доменов приложений в процессе.  
  
 При попытке установить это свойство в значение `false`возникает исключение <xref:System.ArgumentException>, даже если текущее значение свойства равно `false`.  
  
 После включения мониторинга можно использовать свойства экземпляра <xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>, <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A>, <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A>и <xref:System.AppDomain.MonitoringTotalProcessorTime%2A>, чтобы отслеживать использование ЦП и памяти отдельными доменами приложений.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Текущий процесс предпринял попытку присвоить значение <see langword="false" /> этому свойству.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315">Отслеживание ресурсов домена приложения</related>
        <related type="Article" href="https://msdn.microsoft.com/library/02119ab6-1e91-448e-97ad-e7b2e5c4bbbd">&lt;Аппдомаинресаурцемониторинг&gt; элемент</related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringSurvivedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringSurvivedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringSurvivedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringSurvivedMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringSurvivedMemorySize : int64" Usage="System.AppDomain.MonitoringSurvivedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает количество байтов, оставшихся после последнего сбора, и про которые известно, что на них ссылается текущий домен приложения.</summary>
        <value>Количество оставшихся байтов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Статистика обновляется при каждом сборе мусора. Однако они гарантированно будут точными только после полной блокирующей коллекции. то есть коллекция, включающая все поколения и останавливающая работу приложения во время сбора. Например, перегрузка метода <xref:System.GC.Collect?displayProperty=nameWithType> выполняет полную блокированную коллекцию. (Параллельная коллекция выполняется в фоновом режиме и не блокирует приложение.)  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Свойство <see langword="static" /> (<see langword="Shared" /> в Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> установлено равным <see langword="false" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315">Отслеживание ресурсов домена приложения</related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedProcessMemorySize">
      <MemberSignature Language="C#" Value="public static long MonitoringSurvivedProcessMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MonitoringSurvivedProcessMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long MonitoringSurvivedProcessMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringSurvivedProcessMemorySize : int64" Usage="System.AppDomain.MonitoringSurvivedProcessMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает общее количество байтов, оставшихся после последнего сбора для всех доменов приложений в процессе.</summary>
        <value>Общее количество оставшихся байтов для процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 После полной блокирующей коллекции это число представляет число байтов, которые в настоящий момент удерживаются в настоящее время в управляемых кучах. Оно должно близко к числу, полученному методом <xref:System.GC.GetTotalMemory%2A>. После эфемерной коллекции это число представляет число байтов, которые в настоящее время удерживаются в режиме эфемерного поколения.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Свойство <see langword="static" /> (<see langword="Shared" /> в Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> установлено равным <see langword="false" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315">Отслеживание ресурсов домена приложения</related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalAllocatedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringTotalAllocatedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalAllocatedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringTotalAllocatedMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringTotalAllocatedMemorySize : int64" Usage="System.AppDomain.MonitoringTotalAllocatedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает общий размер в байтах для всех операций выделения памяти, выполненных доменом приложения с момента его создания, без вычитания собранной памяти.</summary>
        <value>Общий размер для всех операций выделения памяти.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Свойство <see langword="static" /> (<see langword="Shared" /> в Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> установлено равным <see langword="false" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315">Отслеживание ресурсов домена приложения</related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan MonitoringTotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MonitoringTotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MonitoringTotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringTotalProcessorTime : TimeSpan" Usage="System.AppDomain.MonitoringTotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает общее процессорное время, использованное всеми потоками при выполнении в текущем домене приложения с момента запуска процесса.</summary>
        <value>Общее процессорное время для текущего домена приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Общее время, которое сообщается за доменом приложения, включает время, затраченное на выполнение каждого потока процесса в этом домене приложения.  
  
 Поток, который вызывает неуправляемый код, по-прежнему связан с доменом приложения, и время процессора, затраченное на выполнение неуправляемого кода, сообщается о домене приложения, в котором был сделан вызов.  
  
 Если поток заблокирован или находится в режиме ожидания, он не потребляет процессорное время.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Свойство <see langword="static" /> (<see langword="Shared" /> в Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> установлено равным <see langword="false" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315">Отслеживание ресурсов домена приложения</related>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.PermissionSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::PermissionSet ^ PermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PermissionSet : System.Security.PermissionSet" Usage="System.AppDomain.PermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает набор разрешений изолированного домена приложения.</summary>
        <value>Набор разрешений изолированного домена приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Изолированные домены приложений, созданные с помощью перегрузки метода <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType>, имеют однородный набор разрешений. то есть один и тот же набор разрешений предоставляется всем частично доверенным сборкам, загруженным в домен приложения. Домен изолированного приложения, при необходимости, имеет список сборок со строгими именами, которые исключены из этого набора разрешений, а выполняются с полным доверием.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="P:System.AppDomain.IsHomogenous" />
      </Docs>
    </Member>
    <Member MemberName="ProcessExit">
      <MemberSignature Language="C#" Value="public event EventHandler ProcessExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ProcessExit" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ProcessExit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ProcessExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ProcessExit;" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.ProcessExit : EventHandler " Usage="member this.ProcessExit : System.EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ ProcessExit;" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ProcessExit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>remove: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при завершении работы родительского процесса домена приложения по умолчанию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EventHandler> для этого события может выполнять завершающие действия, такие как закрытие файлов, освобождение хранилища и т. д. до завершения процесса.  
  
 Начиная с версии .NET Framework 2,0, это событие возникает в каждом домене приложения, который регистрирует обработчик событий.  
  
> [!NOTE]
>  В .NET Framework общее время выполнения всех обработчиков событий <xref:System.AppDomain.ProcessExit> ограничено, так как общее время выполнения всех методов завершения ограничено при завершении процесса. Значение по умолчанию — две секунды. Неуправляемый узел может изменить это время выполнения, вызвав метод [ICLRPolicyManager:: setTimeout](~/docs/framework/unmanaged-api/hosting/iclrpolicymanager-settimeout-method.md) со значением перечисления [OPR_ProcessExit](~/docs/framework/unmanaged-api/hosting/eclroperation-enumeration.md) . Это ограничение времени не существует в .NET Core.  
  
 В .NET Framework версиях 1,0 и 1,1 это событие возникает только в домене приложения по умолчанию и только в том случае, если обработчик событий зарегистрирован в домене приложения по умолчанию.  
  
 Чтобы зарегистрировать обработчик событий для этого события, необходимо иметь необходимые разрешения или исключение <xref:System.Security.SecurityException>.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyAssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ReflectionOnlyAssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReflectionOnlyAssemblyResolve As ResolveEventHandler " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event ResolveEventHandler ^ ReflectionOnlyAssemblyResolve;" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnlyAssemblyResolve : ResolveEventHandler " Usage="member this.ReflectionOnlyAssemblyResolve : System.ResolveEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event ReflectionOnlyAssemblyResolve As ResolveEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда разрешение сборки завершается неудачей в контексте, поддерживающем только отражение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В контексте, предназначенном только для отражения, зависимости не разрешаются автоматически. Они должны быть предварительно загружены или возвращены обработчиком для этого события. Это событие возникает, когда сборка имеет зависимость, которая еще не загружена в контекст, предназначенный только для отражения. Отсутствующая зависимость задается свойством <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType>. <xref:System.ResolveEventHandler> для этого события должно возвращать сборку, удовлетворяющую зависимости. Возвращаемая сборка должна быть загружена в контекст, предназначенный только для отражения.  
  
> [!IMPORTANT]
>  Это событие возникает только для отсутствующих зависимостей сборки, которую вы загружаете в контекст только для отражения (например, с помощью метода <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType>). Если загружаемая сборка не найдена, она не вызывается.  
  
 Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]свойство <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> возвращает сборку, которая запросила загрузку сборки, которую не удалось разрешить. Знание идентификации запрашивающей сборки может быть полезно при определении правильной версии зависимости, если доступна более чем одна версия. Для получения дополнительной информации см. <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
 Для этого события свойство <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> возвращает имя сборки перед применением политики.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] ReflectionOnlyGetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly[] ReflectionOnlyGetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ReflectionOnlyGetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function ReflectionOnlyGetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Assembly ^&gt; ^ ReflectionOnlyGetAssemblies();" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnlyGetAssemblies : unit -&gt; System.Reflection.Assembly[]" Usage="appDomain.ReflectionOnlyGetAssemblies " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает сборки, которые были загружены в контекст, поддерживающий только отражение домена приложения.</summary>
        <returns>Массив объектов <see cref="T:System.Reflection.Assembly" />, представляющих сборки, которые были загружены в контекст домена приложения, поддерживающий только отражение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает сборки, которые были загружены в контекст, предназначенный только для отражения. Чтобы получить сборки, которые были загружены для выполнения, используйте метод <xref:System.AppDomain.GetAssemblies%2A>.  
  
   
  
## Examples  
 В следующем примере кода сборка System. dll загружается в контекст выполнения, а затем в контекст, предназначенный только для отражения. Методы <xref:System.AppDomain.GetAssemblies%2A> и <xref:System.AppDomain.ReflectionOnlyGetAssemblies%2A> используются для вывода сборок, загруженных в каждый контекст.  
  
 [!code-cpp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CPP/reflectiononly.cpp#1)]
 [!code-csharp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CS/reflectiononly.cs#1)]
 [!code-vb[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/VB/reflectiononly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <altmember cref="M:System.AppDomain.GetAssemblies" />
      </Docs>
    </Member>
    <Member MemberName="RelativeSearchPath">
      <MemberSignature Language="C#" Value="public string RelativeSearchPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RelativeSearchPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.RelativeSearchPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RelativeSearchPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RelativeSearchPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RelativeSearchPath : string" Usage="System.AppDomain.RelativeSearchPath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.RelativeSearchPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает путь, к каталогу, находящемуся в базовом каталоге, где распознаватель сборок будет производить поиск закрытых сборок.</summary>
        <value>Путь, к каталогу, находящемуся в базовом каталоге, где распознаватель сборок будет производить поиск закрытых сборок.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Закрытые сборки развертываются в той же структуре каталогов, что и приложение. Если путь, указанный свойством <xref:System.AppDomain.RelativeSearchPath%2A>, не находится в разделе <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>, он игнорируется.  
  
 Это свойство возвращает значение, заданное с помощью <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям о пути. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="P:System.AppDomainSetup.PrivateBinPath" />
      </Docs>
    </Member>
    <Member MemberName="ResourceResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ResourceResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ResourceResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ResourceResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResourceResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event ResolveEventHandler ^ ResourceResolve;" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.ResourceResolve : ResolveEventHandler " Usage="member this.ResourceResolve : System.ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ ResourceResolve;" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ResourceResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>происходит, когда разрешение ресурса завершается неудачей, из-за того, что он не является допустимым связанным или внедренным ресурсом в сборке.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ResolveEventHandler> для этого события может попытаться выбрать сборку, содержащую ресурс, и вернуть ее.  
  
> [!IMPORTANT]
>  Это событие не возникает, если разрешение завершается неудачей, так как не удается найти файл для допустимого связанного ресурса. Он вызывается, если не удается найти поток ресурсов манифеста, но он не вызывается, если не удается найти отдельный ключ ресурса.  
  
 Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], свойство <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> содержит сборку, которая запросила ресурс. Для получения дополнительной информации см. <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
 Чтобы зарегистрировать обработчик событий для этого события, необходимо иметь необходимые разрешения или исключение <xref:System.Security.SecurityException>.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="SetAppDomainPolicy">
      <MemberSignature Language="C#" Value="public void SetAppDomainPolicy (System.Security.Policy.PolicyLevel domainPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetAppDomainPolicy(class System.Security.Policy.PolicyLevel domainPolicy) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAppDomainPolicy (domainPolicy As PolicyLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetAppDomainPolicy(System::Security::Policy::PolicyLevel ^ domainPolicy);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="abstract member SetAppDomainPolicy : System.Security.Policy.PolicyLevel -&gt; unit&#xA;override this.SetAppDomainPolicy : System.Security.Policy.PolicyLevel -&gt; unit" Usage="appDomain.SetAppDomainPolicy domainPolicy" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAppDomainPolicy(class System.Security.Policy.PolicyLevel domainPolicy) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAppDomainPolicy(System::Security::Policy::PolicyLevel ^ domainPolicy);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.SetAppDomainPolicy : System.Security.Policy.PolicyLevel -&gt; unit" Usage="appDomain.SetAppDomainPolicy domainPolicy" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domainPolicy" Type="System.Security.Policy.PolicyLevel" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="domainPolicy">Уровень политики безопасности.</param>
        <summary>Устанавливает уровень политики безопасности для этого домена приложения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите этот метод перед загрузкой сборки в <xref:System.AppDomain>, чтобы политика безопасности действовала.  
  
   
  
## Examples  
 В следующем примере показано, как использовать метод <xref:System.AppDomain.SetAppDomainPolicy%2A> для задания уровня политики безопасности домена приложения.  
  
 [!code-cpp[ADSetAppDomainPolicy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetAppDomainPolicy/CPP/adsetappdomainpolicy.cpp#1)]
 [!code-csharp[ADSetAppDomainPolicy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetAppDomainPolicy/CS/adsetappdomainpolicy.cs#1)]
 [!code-vb[ADSetAppDomainPolicy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetAppDomainPolicy/VB/adsetappdomainpolicy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="domainPolicy" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Security.Policy.PolicyException">Установленный уровень политики безопасности.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetCachePath">
      <MemberSignature Language="C#" Value="public void SetCachePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCachePath(string path) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetCachePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCachePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCachePath(System::String ^ path);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.SetCachePath : string -&gt; unit" Usage="appDomain.SetCachePath path" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetCachePath(string path) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetCachePath(System::String ^ path);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member SetCachePath : string -&gt; unit&#xA;override this.SetCachePath : string -&gt; unit" Usage="appDomain.SetCachePath path" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetCachePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.SetCachePath")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("AppDomain.SetCachePath has been deprecated. Please investigate the use of AppDomainSetup.CachePath instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("AppDomain.SetCachePath has been deprecated. Please investigate the use of AppDomainSetup.CachePath instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("AppDomain.SetCachePath has been deprecated. Please investigate the use of AppDomainSetup.CachePath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Полный путь для размещения теневых копий.</param>
        <summary>Устанавливает заданный путь каталога в качестве места, куда копируются теневые сборки.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Путь к кэшу игнорируется, если не задано свойство <xref:System.AppDomainSetup.ApplicationName%2A>. См. свойство <xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType>.  
  
 Дополнительные сведения о теневом копировании см. в разделе [теневое копирование сборок](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Теневое копирование сборок</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetData">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Присваивает значение свойству домена приложения.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetData(string name, object data) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetData(System::String ^ name, System::Object ^ data);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.SetData : string * obj -&gt; unit" Usage="appDomain.SetData (name, data)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetData(string name, object data) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetData(System::String ^ name, System::Object ^ data);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member SetData : string * obj -&gt; unit&#xA;override this.SetData : string * obj -&gt; unit" Usage="appDomain.SetData (name, data)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetData(System.String,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Имя пользовательского свойства домена приложения, которое требуется создать или изменить.</param>
        <param name="data">Значение свойства.</param>
        <summary>Устанавливает заданное значение для свойства указанного домена приложения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется для вставки записи или изменения значения записи во внутреннем кэше пар имя-данные, описывающих свойства данного экземпляра <xref:System.AppDomain>.  
  
 Кэш автоматически содержит стандартные системные записи, которые вставляются при создании домена приложения. Нельзя вставлять или изменять системные записи с помощью этого метода. Вызов метода, который пытается изменить системную запись, не имеет результата; метод не создает исключение. Можно проверить значения системных записей с помощью метода <xref:System.AppDomain.GetData%2A> или эквивалентных <xref:System.AppDomainSetup> свойств, описанных в <xref:System.AppDomain.GetData%2A>.  
  
 Этот метод можно вызвать, чтобы задать значение интервала времени ожидания по умолчанию для оценки шаблонов регулярных выражений, указав "REGEX_DEFAULT_MATCH_TIMEOUT" в качестве значения аргумента `name` и <xref:System.TimeSpan> значение, представляющее интервал времени ожидания в качестве значения аргумента `data`. Можно также вставить или изменить пользовательские пары имя-данные с помощью этого метода и проверить их значения с помощью метода <xref:System.AppDomain.GetData%2A>.  
  
   
  
## Examples  
 В следующем примере показано, как использовать метод <xref:System.AppDomain.SetData%28System.String%2CSystem.Object%29> для создания новой пары значений. Затем в примере используется метод <xref:System.AppDomain.GetData%2A> для получения значения и его отображения в консоли.  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="M:System.AppDomain.GetData(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data, System.Security.IPermission permission);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetData(string name, object data, class System.Security.IPermission permission) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object, permission As IPermission)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetData(System::String ^ name, System::Object ^ data, System::Security::IPermission ^ permission);" />
      <MemberSignature Language="F#" Value="member this.SetData : string * obj * System.Security.IPermission -&gt; unit" Usage="appDomain.SetData (name, data, permission)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="data" Type="System.Object" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="permission" Type="System.Security.IPermission" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Имя пользовательского свойства домена приложения, которое требуется создать или изменить.</param>
        <param name="data">Значение свойства.</param>
        <param name="permission">Разрешение, которое нужно запросить у вызывающего кода при извлечении свойства.</param>
        <summary>Присваивает заданное значение заданному свойству домена приложения с заданными разрешениями, которые нужно запросить у вызывающего кода при извлечении свойства.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется для вставки или изменения собственных пользовательских записей во внутреннем кэше пар имен и данных, описывающих свойства домена приложения. При вставке записи можно указать требование разрешения, которое будет применяться при извлечении записи. Кроме того, можно вызвать этот метод, чтобы задать значение интервала времени ожидания по умолчанию для оценки шаблонов регулярных выражений, указав "REGEX_DEFAULT_MATCH_TIMEOUT" в качестве значения аргумента `name` и <xref:System.TimeSpan> значение, представляющее интервал времени ожидания в качестве значения аргумента `data`.  
  
 Этот метод нельзя использовать для назначения запроса безопасности строке свойства, определяемой системой.  
  
 Кэш автоматически содержит стандартные системные записи, которые вставляются при создании домена приложения. Нельзя вставлять или изменять системные записи с помощью этого метода. Вызов метода, который пытается изменить системную запись, не имеет результата; метод не создает исключение. Значения системных записей можно проверить с помощью метода <xref:System.AppDomain.GetData%2A> или эквивалентного <xref:System.AppDomainSetup> свойств, описанных в разделе "Примечания" для метода <xref:System.AppDomain.GetData%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="name" /> задает определяемую системой строку свойства, и <paramref name="permission" /> не равно <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetDynamicBase">
      <MemberSignature Language="C#" Value="public void SetDynamicBase (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDynamicBase(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetDynamicBase(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetDynamicBase (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetDynamicBase(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetDynamicBase : string -&gt; unit" Usage="appDomain.SetDynamicBase path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.DynamicBase")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("AppDomain.SetDynamicBase has been deprecated. Please investigate the use of AppDomainSetup.DynamicBase instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("AppDomain.SetDynamicBase has been deprecated. Please investigate the use of AppDomainSetup.DynamicBase instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("AppDomain.SetDynamicBase has been deprecated. Please investigate the use of AppDomainSetup.DynamicBase instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Полный путь, который является базовым каталогом для подкаталогов, в которых хранятся динамические сборки.</param>
        <summary>Устанавливает заданный путь каталога в качестве базового каталога для подкаталогов, в которых сохраняются и становятся доступными динамически созданные файлы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод задает свойство <xref:System.AppDomainSetup.DynamicBase%2A> внутреннего <xref:System.AppDomainSetup>, связанного с этим экземпляром.  
  
   
  
## Examples  
 Теперь этот метод устарел и не должен использоваться для новой разработки. В следующем примере показано, как использовать неустаревшую альтернативу, свойство <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType>. Описание этого примера см. в описании свойства <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> или свойства <xref:System.AppDomain.DynamicDirectory%2A>.  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="P:System.AppDomainSetup.DynamicBase" />
      </Docs>
    </Member>
    <Member MemberName="SetPrincipalPolicy">
      <MemberSignature Language="C#" Value="public void SetPrincipalPolicy (System.Security.Principal.PrincipalPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPrincipalPolicy(valuetype System.Security.Principal.PrincipalPolicy policy) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPrincipalPolicy (policy As PrincipalPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPrincipalPolicy(System::Security::Principal::PrincipalPolicy policy);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.SetPrincipalPolicy : System.Security.Principal.PrincipalPolicy -&gt; unit" Usage="appDomain.SetPrincipalPolicy policy" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetPrincipalPolicy(valuetype System.Security.Principal.PrincipalPolicy policy) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetPrincipalPolicy(System::Security::Principal::PrincipalPolicy policy);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="abstract member SetPrincipalPolicy : System.Security.Principal.PrincipalPolicy -&gt; unit&#xA;override this.SetPrincipalPolicy : System.Security.Principal.PrincipalPolicy -&gt; unit" Usage="appDomain.SetPrincipalPolicy policy" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Principal.PrincipalPolicy" />
      </Parameters>
      <Docs>
        <param name="policy">Одно из значений <see cref="T:System.Security.Principal.PrincipalPolicy" />, определяющее тип объекта-участника для подключения к потоку.</param>
        <summary>Указывает, как участники и объекты удостоверений должны присоединяться к потоку, если поток пытается выполнить привязку к участнику при выполнении в этом домене приложения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Установка этого значения будет эффективна только в том случае, если она задана перед использованием свойства <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>. Например, если задать <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> для определенного субъекта (например, универсального субъекта), а затем использовать метод <xref:System.AppDomain.SetPrincipalPolicy%2A> для установки <xref:System.Security.Principal.PrincipalPolicy> <xref:System.Security.Principal.PrincipalPolicy.WindowsPrincipal>, текущий участник останется универсальным участником.  
  
   
  
## Examples  
 В следующем примере показано воздействие на потоки с использованием метода <xref:System.AppDomain.SetPrincipalPolicy%2A> для изменения основной политики домена приложения. Он также показывает результат использования метода <xref:System.AppDomain.SetThreadPrincipal%2A> для изменения субъекта, доступного для присоединения к потокам в домене приложения.  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности управления объектом Principal. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />. Действие безопасности: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyFiles">
      <MemberSignature Language="C#" Value="public void SetShadowCopyFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetShadowCopyFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyFiles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetShadowCopyFiles();" />
      <MemberSignature Language="F#" Value="member this.SetShadowCopyFiles : unit -&gt; unit" Usage="appDomain.SetShadowCopyFiles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyFiles")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyFiles has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyFiles instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyFiles has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyFiles instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyFiles has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyFiles instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Включает теневое копирование.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения о теневом копировании см. в разделе [теневое копирование сборок](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
   
  
## Examples  
 Теперь этот метод устарел и не должен использоваться для новой разработки.  
  
 [!code-cpp[adproperties#1](~/samples/snippets/cpp/VS_Snippets_CLR/adproperties/CPP/adproperties.cpp#1)]
 [!code-csharp[adproperties#1](~/samples/snippets/csharp/VS_Snippets_CLR/adproperties/CS/adproperties.cs#1)]
 [!code-vb[adproperties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/adproperties/VB/adproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Теневое копирование сборок</related>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyPath">
      <MemberSignature Language="C#" Value="public void SetShadowCopyPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetShadowCopyPath(string path) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyPath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetShadowCopyPath(System::String ^ path);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.SetShadowCopyPath : string -&gt; unit" Usage="appDomain.SetShadowCopyPath path" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetShadowCopyPath(string path) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetShadowCopyPath(System::String ^ path);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member SetShadowCopyPath : string -&gt; unit&#xA;override this.SetShadowCopyPath : string -&gt; unit" Usage="appDomain.SetShadowCopyPath path" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetShadowCopyPath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Список имен каталогов, разделенных знаком точки с запятой.</param>
        <summary>Устанавливает заданный путь каталога в качестве места, куда копируются теневые сборки.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию теневая копия включает все сборки, найденные с помощью зондирования. Метод <xref:System.AppDomain.SetShadowCopyPath%2A> ограничивают теневую копию сборками в каталогах, указанных в параметре `path`.  
  
 Метод <xref:System.AppDomain.SetShadowCopyPath%2A> не указывает дополнительные каталоги для поиска сборок. Сборки, предназначенные для теневого копирования, должны уже находиться в пути поиска, например в разделе <xref:System.AppDomain.BaseDirectory%2A>. Метод <xref:System.AppDomain.SetShadowCopyPath%2A> указывает, какие пути поиска могут быть скопированы при теневом копировании.  
  
 Этот метод задает свойство <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> внутреннего <xref:System.AppDomainSetup>, связанного с этим экземпляром.  
  
 Дополнительные сведения о теневом копировании см. в разделе [теневое копирование сборок](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
   
  
## Examples  
 Теперь этот метод устарел и не должен использоваться для новой разработки.  
  
 [!code-cpp[ADShadowCopy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADShadowCopy/CPP/adshadowcopy.cpp#1)]
 [!code-csharp[ADShadowCopy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADShadowCopy/CS/adshadowcopy.cs#1)]
 [!code-vb[ADShadowCopy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADShadowCopy/VB/adshadowcopy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Теневое копирование сборок</related>
      </Docs>
    </Member>
    <Member MemberName="SetThreadPrincipal">
      <MemberSignature Language="C#" Value="public void SetThreadPrincipal (System.Security.Principal.IPrincipal principal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetThreadPrincipal(class System.Security.Principal.IPrincipal principal) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetThreadPrincipal (principal As IPrincipal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetThreadPrincipal(System::Security::Principal::IPrincipal ^ principal);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.SetThreadPrincipal : System.Security.Principal.IPrincipal -&gt; unit" Usage="appDomain.SetThreadPrincipal principal" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetThreadPrincipal(class System.Security.Principal.IPrincipal principal) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetThreadPrincipal(System::Security::Principal::IPrincipal ^ principal);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="abstract member SetThreadPrincipal : System.Security.Principal.IPrincipal -&gt; unit&#xA;override this.SetThreadPrincipal : System.Security.Principal.IPrincipal -&gt; unit" Usage="appDomain.SetThreadPrincipal principal" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Principal.IPrincipal" />
      </Parameters>
      <Docs>
        <param name="principal">Объект-участник, который необходимо подключить к потоку.</param>
        <summary>Задает объект-участник по умолчанию, который необходимо присоединять к потокам, в случае если они пытаются выполнить привязку к объекту-участнику во время выполнения в этом домене приложения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере показан результат использования метода <xref:System.AppDomain.SetThreadPrincipal%2A> для изменения субъекта, доступного для присоединения к потокам, которые выполняются в домене приложения. Он также показывает воздействие на потоки с использованием метода <xref:System.AppDomain.SetPrincipalPolicy%2A> для изменения основной политики домена приложения.  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="principal" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Security.Policy.PolicyException">Установленный объект-участник потока.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности управления объектом Principal. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />. Действие безопасности: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetupInformation">
      <MemberSignature Language="C#" Value="public AppDomainSetup SetupInformation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainSetup SetupInformation" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.SetupInformation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SetupInformation As AppDomainSetup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainSetup ^ SetupInformation { AppDomainSetup ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SetupInformation : AppDomainSetup" Usage="System.AppDomain.SetupInformation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainSetup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает сведения о конфигурации домена приложения для этого экземпляра.</summary>
        <value>Сведения об инициализации домена приложения.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public bool ShadowCopyFiles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ShadowCopyFiles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShadowCopyFiles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyFiles : bool" Usage="System.AppDomain.ShadowCopyFiles" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.ShadowCopyFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает указание на то, настроен ли домен приложения для теневого копирования файлов.</summary>
        <value><see langword="true" />, если домен приложения настроен для теневого копирования файлов; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения см. в разделе <xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType> и [теневое копирование сборок](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Теневое копирование сборок</related>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _AppDomain.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _AppDomain.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = _AppDomain::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="rgszNames" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="cNames" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="rgDispId" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="riid">Зарезервировано для будущего использования. Должно быть равным IID_NULL.</param>
        <param name="rgszNames">Переданный массив имен, которые необходимо сопоставить.</param>
        <param name="cNames">Количество сопоставляемых имен.</param>
        <param name="lcid">Контекст языкового стандарта для интерпретации имен.</param>
        <param name="rgDispId">Массив, зарезервированный вызывающим объектом, куда помещаются идентификаторы, соответствующие именам.</param>
        <summary>Сопоставляет набор имен соответствующему набору идентификаторов диспетчеризации.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предназначен для доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода. Дополнительные сведения о `IDispatch::GetIDsOfNames`см. в библиотеке MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _AppDomain.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = _AppDomain::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Возвращаемые сведения о типе.</param>
        <param name="lcid">Идентификатор языкового стандарта для сведений о типе.</param>
        <param name="ppTInfo">Получает указатель на объект с запрошенными сведениями о типе.</param>
        <summary>Возвращает сведения о типе объекта, которые затем могут использоваться для получения сведений о типе интерфейса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предназначен для доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода. Дополнительные сведения о `IDispatch::GetTypeInfo`см. в библиотеке MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _AppDomain.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = _AppDomain::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Указатель, по которому записывается число предоставляемых объектом интерфейсов, предназначенных для получения сведений о типе.</param>
        <summary>Возвращает количество предоставляемых объектом интерфейсов для доступа к сведениям о типе (0 или 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предназначен для доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода. Дополнительные сведения о `IDispatch::GetTypeInfoCount`см. в библиотеке MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.Invoke">
      <MemberSignature Language="C#" Value="void _AppDomain.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _AppDomain.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = _AppDomain::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="wFlags" Type="System.Int16" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pDispParams" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pVarResult" Type="System.IntPtr" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="puArgErr" Type="System.IntPtr" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Идентифицирует член.</param>
        <param name="riid">Зарезервировано для будущего использования. Должно быть равным IID_NULL.</param>
        <param name="lcid">Контекст языкового стандарта, в котором следует интерпретировать аргументы.</param>
        <param name="wFlags">Флаги, описывающие контекст вызова.</param>
        <param name="pDispParams">Указатель на структуру, содержащую массив аргументов, массив DISPID для именованных аргументов, а также счетчики количества элементов в массивах.</param>
        <param name="pVarResult">Указатель, по которому будет сохранен результат.</param>
        <param name="pExcepInfo">Указатель на структуру, содержащую сведения об исключении.</param>
        <param name="puArgErr">Индекс первого аргумента, вызвавшего ошибку.</param>
        <summary>Предоставляет доступ к открытым свойствам и методам объекта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предназначен для доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода. Дополнительные сведения о `IDispatch::Invoke`см. в библиотеке MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="appDomain.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает строку, включающую понятное имя домена приложения и политики контекста.</summary>
        <returns>Строка, полученная путем сцепления литеральной строки "Name:", понятного имени домена приложения и либо строкового представления политик контекста, либо строки "Политики контекста отсутствуют".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода выводится возвращаемое значение метода <xref:System.AppDomain.ToString%2A>.  
  
 [!code-cpp[ADToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADToString/CPP/adtostring.cpp#1)]
 [!code-csharp[ADToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADToString/CS/adtostring.cs#1)]
 [!code-vb[ADToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADToString/VB/adtostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Домен приложения, представленный текущим <see cref="T:System.AppDomain" />, выгружен.</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler TypeResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler TypeResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.TypeResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TypeResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event ResolveEventHandler ^ TypeResolve;" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.TypeResolve : ResolveEventHandler " Usage="member this.TypeResolve : System.ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ TypeResolve;" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.TypeResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>происходит, когда разрешении типа завершается неудачей.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Событие <xref:System.AppDomain.TypeResolve> возникает, когда среде CLR не удается определить сборку, которая может создать запрошенный тип. Это может произойти, если тип определен в динамической сборке или тип не определен в динамической сборке, но среда выполнения не знает, в какой сборке определен тип. Вторая ситуация может возникать, когда <xref:System.Type.GetType%2A?displayProperty=nameWithType> вызывается с именем типа, которое не дополнено именем сборки.  
  
 <xref:System.ResolveEventHandler> для этого события может попытаться нахождение и создание типа.  
  
 Однако событие <xref:System.AppDomain.TypeResolve> не происходит, если среда выполнения знает, что невозможно найти тип в определенных сборках. Например, это событие не происходит, если тип не найден в статической сборке, так как среда выполнения знает типы, которые нельзя динамически добавить в статические сборки.  
  
 Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], свойство <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> содержит сборку, которая запросила тип. Для получения дополнительной информации см. <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
 Чтобы зарегистрировать обработчик событий для этого события, необходимо иметь необходимые разрешения или исключение <xref:System.Security.SecurityException>.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере демонстрируется событие <xref:System.AppDomain.TypeResolve>.  
  
 Для выполнения этого примера кода необходимо указать полное имя сборки. Дополнительные сведения о получении полного имени сборки см. в разделе [имена сборок](~/docs/standard/assembly/names.md).  
  
 [!code-cpp[AppDomain_TypeResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_TypeResolve/CPP/typeresolve.cpp#1)]
 [!code-csharp[AppDomain_TypeResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_TypeResolve/CS/typeresolve.cs#1)]
 [!code-vb[AppDomain_TypeResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_TypeResolve/VB/typeresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="UnhandledException">
      <MemberSignature Language="C#" Value="public event UnhandledExceptionEventHandler UnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.UnhandledExceptionEventHandler UnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.UnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UnhandledException As UnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event UnhandledExceptionEventHandler ^ UnhandledException;" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.UnhandledException : UnhandledExceptionEventHandler " Usage="member this.UnhandledException : System.UnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event UnhandledExceptionEventHandler ^ UnhandledException;" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.UnhandledException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>происходит, если выброшенное исключение остается не перехваченным.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие предоставляет уведомление о неперехваченных исключениях. Он позволяет приложению регистрировать сведения об исключении до того, как системный обработчик по умолчанию сообщит пользователю об исключении и завершит работу приложения. Если доступны достаточные сведения о состоянии приложения, можно выполнить другие действия, такие как сохранение данных программы для последующего восстановления. Рекомендуется соблюдать осторожность, так как данные программы могут быть повреждены, если исключения не обрабатываются.  
  
> [!NOTE]
>  В .NET Framework версиях 1,0 и 1,1 перед вызовом этого события пользователю сообщается о параметрах завершения и отладки приложения, а не после.  
  
 Это событие может быть обработано в любом домене приложения. Однако это событие не обязательно возникает в домене приложения, где возникло исключение. Исключение не обрабатывается, только если весь стек потока был развернут без поиска соответствующего обработчика исключений, поэтому первое место, в котором может быть создано событие, находится в домене приложения, в котором был создан поток.  
  
> [!NOTE]
>  В .NET Framework версиях 1,0 и 1,1 это событие возникает только для домена приложения по умолчанию, созданного системой при запуске приложения. Если приложение создает дополнительные домены приложений, то указание делегата для этого события в этих доменах приложений не действует.  
  
 Если событие <xref:System.AppDomain.UnhandledException> обрабатывается в домене приложения по умолчанию, оно вызывается для любого необработанного исключения в любом потоке независимо от домена приложения, в котором запущен поток. Если поток запущен в домене приложения с обработчиком событий для <xref:System.AppDomain.UnhandledException>, событие возникает в этом домене приложения. Если этот домен приложения не является доменом приложения по умолчанию и в домене приложения по умолчанию есть обработчик событий, событие возникает в обоих доменах приложений.  
  
 Например, предположим, что поток начинается в домене приложения "AD1", вызывает метод в домене приложения "AD2" и вызывает метод в домене приложения "AD3", где он создает исключение. Первый домен приложения, в котором может быть вызвано событие <xref:System.AppDomain.UnhandledException>, — это "AD1". Если этот домен приложения не является доменом приложения по умолчанию, это событие также может возникнуть в домене приложения по умолчанию.  
  
> [!NOTE]
>  Среда CLR приостанавливает прерывания потока, пока выполняются обработчики событий для события <xref:System.AppDomain.UnhandledException>.  
  
 Если обработчик событий имеет атрибут <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> с соответствующими флагами, обработчик событий обрабатывается как область ограниченного выполнения.  
  
 Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]это событие не вызывается для исключений, которые повреждают состояние процесса, например, переполняет стек или нарушения прав доступа, если только обработчик событий не является критически важным для безопасности и имеет атрибут <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>.  
  
 В .NET Framework версиях 1,0 и 1,1 необработанное исключение, возникающее в потоке, отличном от основного потока приложения, перехватывается средой выполнения и, следовательно, не приводит к завершению работы приложения. Таким же причиной может быть вызов события <xref:System.AppDomain.UnhandledException> без завершения работы приложения. Начиная с .NET Framework версии 2,0 эта позиция необработанных исключений в дочерних потоках была удалена, так как в совокупной эффективности такие сбои, включая снижение производительности, повреждение данных и зависаний, все, что было сложно см. Дополнительные сведения, в том числе список случаев, когда среда выполнения не завершает работу, см. [в разделе исключения в управляемых потоках](~/docs/standard/threading/exceptions-in-managed-threads.md).  
  
 Чтобы зарегистрировать обработчик событий для этого события, необходимо иметь необходимые разрешения или исключение <xref:System.Security.SecurityException>.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
## <a name="other-events-for-unhandled-exceptions"></a>Другие события для необработанных исключений  
 Для некоторых моделей приложений событие <xref:System.AppDomain.UnhandledException> может быть вытеснено другими событиями, если необработанное исключение возникает в основном потоке приложения.  
  
 В приложениях, использующих Windows Forms, необработанные исключения в основном потоке приложения приводят к возникновению события <xref:System.Windows.Forms.Application.ThreadException?displayProperty=nameWithType>. Если это событие обрабатывается, поведение по умолчанию заключается в том, что необработанное исключение не завершает работу приложения, хотя приложение остается в неизвестном состоянии. В этом случае событие <xref:System.AppDomain.UnhandledException> не возникает. Это поведение можно изменить с помощью файла конфигурации приложения или с помощью метода <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=nameWithType>, чтобы изменить режим на <xref:System.Windows.Forms.UnhandledExceptionMode.ThrowException?displayProperty=nameWithType> перед подключением обработчика <xref:System.Windows.Forms.Application.ThreadException> событий. Это относится только к основному потоку приложения. Событие <xref:System.AppDomain.UnhandledException> вызывается для необработанных исключений, вызванных в других потоках.  
  
 Начиная с Microsoft Visual Studio 2005 платформа приложений Visual Basic предоставляет еще одно событие для необработанных исключений в основном потоке приложения. См. событие <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=nameWithType>. Это событие содержит объект аргументов события с тем же именем, что и объект аргументов события, используемый <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>, но с разными свойствами. В частности, этот объект аргументов события имеет свойство <xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A>, позволяющее продолжить выполнение приложения, игнорируя необработанное исключение (и выполняя приложение в неизвестном состоянии). В этом случае событие <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> не возникает.  
  
   
  
## Examples  
 В следующем примере демонстрируется событие <xref:System.AppDomain.UnhandledException>. Он определяет обработчик событий, `MyHandler`, который вызывается всякий раз, когда в домене приложения по умолчанию возникает необработанное исключение. Затем он создает два исключения. Первый обрабатывается блоком **try/catch** . Вторая не обработана и вызывает `MyHandle` подпрограммы до завершения работы приложения.  
  
 [!code-cpp[AppDomain_UnhandledException#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_UnhandledException/CPP/unhandledexception.cpp#1)]
 [!code-csharp[AppDomain_UnhandledException#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_UnhandledException/CS/unhandledexception.cs#1)]
 [!code-vb[AppDomain_UnhandledException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_UnhandledException/VB/unhandledexception.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public static void Unload (AppDomain domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Unload(class System.AppDomain domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Unload(System.AppDomain)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Unload (domain As AppDomain)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unload(AppDomain ^ domain);" />
      <MemberSignature Language="F#" Value="static member Unload : AppDomain -&gt; unit" Usage="System.AppDomain.Unload domain" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptAppDomain, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
      </Parameters>
      <Docs>
        <param name="domain">Домен приложения, который подлежит выгрузке.</param>
        <summary>Выгружает заданный домен приложения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В .NET Framework версии 2,0 существует поток, предназначенный для выгрузки доменов приложений. Это повышает надежность, особенно при размещении .NET Framework. Когда поток вызывает <xref:System.AppDomain.Unload%2A>, целевой домен помечается для выгрузки. Выделенный поток пытается выгрузить домен, и все потоки в этом домене будут прерваны. Если поток не прерывается, например, так как он выполняет неуправляемый код или выполняется блок `finally`, то по истечении некоторого времени в потоке, вызвавшем <xref:System.AppDomain.Unload%2A>, будет создано <xref:System.CannotUnloadAppDomainException>. Если поток, который не удалось завершить в конце концов, завершается, целевой домен не выгружается. Поэтому в .NET Framework версии 2,0 `domain` не гарантируется выгрузка, так как это может привести к невозможности завершения выполняющихся потоков.  
  
> [!NOTE]
>  В некоторых случаях вызов <xref:System.AppDomain.Unload%2A> вызывает немедленный <xref:System.CannotUnloadAppDomainException>, например, если он вызывается методом завершения.  
  
 Потоки в `domain` завершаются с помощью метода <xref:System.Threading.Thread.Abort%2A>, который создает в потоке <xref:System.Threading.ThreadAbortException>. Хотя поток должен завершаться немедленно, он может продолжать выполнение в течение непредсказуемого времени в предложении `finally`.  
  
## <a name="version-compatibility"></a>Совместимость версий  
 В .NET Framework версии 1,0 и 1,1, если поток, вызывающий <xref:System.AppDomain.Unload%2A>, выполняется в `domain`, для выполнения операции выгрузки запускается другой поток. Если не удается выгрузить `domain`, в этом потоке создается <xref:System.CannotUnloadAppDomainException>, а не в исходный поток, вызвавший <xref:System.AppDomain.Unload%2A>. Однако если поток, вызывающий <xref:System.AppDomain.Unload%2A>, работает вне `domain`, этот поток получает исключение.  
  
   
  
## Examples  
 В следующем примере кода показано, как выгрузить домен приложения.  
  
 [!code-cpp[ADUnload#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADUnload/CPP/adunload.cpp#1)]
 [!code-csharp[ADUnload#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADUnload/CS/adunload.cs#1)]
 [!code-vb[ADUnload#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADUnload/VB/adunload.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="domain" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.CannotUnloadAppDomainException">Домен, определенный параметром <paramref name="domain" />, не может быть выгружен.</exception>
        <exception cref="T:System.Exception">Во время выполнения выгрузки произошла ошибка.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для добавления обработчика событий для этого события. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />. Действие безопасности: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
  </Members>
</Type>
