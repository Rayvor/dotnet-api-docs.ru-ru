<Type Name="SecureString" FullName="System.Security.SecureString">
  <Metadata><Meta Name="ms.openlocfilehash" Value="96bc424553b906350ab42e30474aa7eb58c02455" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70688466" /></Metadata><TypeSignature Language="C#" Value="public sealed class SecureString : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed SecureString extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Security.SecureString" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class SecureString&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class SecureString sealed : IDisposable" />
  <TypeSignature Language="F#" Value="type SecureString = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Security.SecureString</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Представляет текст, который должен оставаться конфиденциальным, например, путем его удаления из памяти компьютера, если он больше не нужен. Этот класс не наследуется.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  

> [!IMPORTANT]
>  Мы не рекомендуем использовать `SecureString` класс для новой разработки. Дополнительные сведения см. в разделе [SecureString не следует использовать](https://github.com/dotnet/platform-compat/blob/master/docs/DE0001.md) в GitHub.

 <xref:System.Security.SecureString>— это строковый тип, предоставляющий меру безопасности. Он пытается избежать сохранения потенциально конфиденциальных строк в памяти процесса в виде обычного текста.  (Дополнительные сведения об ограничениях см. в разделе [насколько безопасным является SecureString?](#HowSecure) ) Значение экземпляра <xref:System.Security.SecureString> автоматически защищается с помощью механизма, поддерживаемого базовой платформой при инициализации экземпляра или при изменении значения. Приложение может преобразовать экземпляр в неизменяемый и предотвратить дальнейшее изменение, вызвав <xref:System.Security.SecureString.MakeReadOnly%2A> метод.  
  
 Максимальная длина <xref:System.Security.SecureString> экземпляра — 65 536 символов.  
  
> [!IMPORTANT]
>  Этот тип реализует интерфейс <xref:System.IDisposable>. После завершения использования экземпляра типа его следует удалить прямо или косвенно. Чтобы сделать это прямо, вызовите его метод <xref:System.IDisposable.Dispose%2A> в блоке `try`/`catch`. Чтобы сделать это косвенно, используйте языковые конструкции, такие как `using` (в C#) или `Using` (в Visual Basic). Дополнительные сведения см. в разделе "Использование объекта, реализующего IDisposable" в статье об интерфейсе <xref:System.IDisposable>.  
  
 <xref:System.Security.SecureString> Класс и его члены не видимы для com. Для получения дополнительной информации см. <xref:System.Runtime.InteropServices.ComVisibleAttribute>.  
  
 Содержание  
  
 [String и SecureString](#vsString)   
 [Операции SecureString](#Ops)   
 [SecureString и Interop](#interop)   
 [Насколько безопасным является SecureString?](#HowSecure)  
  
<a name="vsString"></a>   
## <a name="string-versus-securestring"></a>Строка и SecureString  
 Экземпляр <xref:System.String?displayProperty=nameWithType> класса является неизменяемым и, когда он больше не нужен, не может быть запланированным программным путем для сборки мусора, т. е. экземпляр доступен только для чтения после его создания, и невозможно предсказать, когда экземпляр будет удалено из памяти компьютера. Поскольку <xref:System.String?displayProperty=nameWithType> экземпляры являются неизменяемыми, операции, которые могут изменить существующий экземпляр, фактически создают его копию для обработки. Следовательно, если <xref:System.String> объект содержит конфиденциальные сведения, такие как пароль, номер кредитной карты или персональные данные, существует риск, что данные можно было бы раскрывать после использования, так как приложение не может удалить данные из памяти компьютера. .  
  
 <xref:System.Security.SecureString> Объект похож <xref:System.String>  на объект в том, что он имеет текстовое значение. Однако значение <xref:System.Security.SecureString> объекта закрепляется в памяти, может использовать механизм защиты, такой как шифрование, предоставляемый базовой операционной системой, может быть изменен до тех пор, пока приложение не пометит его как доступное только для чтения и может быть удалено из памяти компьютера. либо приложением, вызывающим <xref:System.Security.SecureString.Dispose%2A> метод, либо сборщиком мусора .NET Framework.  
  
 Сведения об ограничениях <xref:System.Security.SecureString> класса см. в разделе [Безопасная защита](#HowSecure) с помощью SecureString.  
  
 [К началу](#top)  
  
<a name="Ops"></a>   
## <a name="securestring-operations"></a>Операции SecureString  
 <xref:System.Security.SecureString> Класс включает члены, которые позволяют выполнять следующие действия:  
  
 Создание экземпляра <xref:System.Security.SecureString> объекта  
 Экземпляр <xref:System.Security.SecureString> объекта создается путем вызова его конструктора без параметров.  
  
 Добавление символов в <xref:System.Security.SecureString> объект  
 Можно добавить один символ за раз <xref:System.Security.SecureString> в объект, вызвав его <xref:System.Security.SecureString.AppendChar%2A> метод или <xref:System.Security.SecureString.InsertAt%2A> .  
  
> [!IMPORTANT]
>  Объект не должен быть создан <xref:System.String>из, так как конфиденциальные данные уже подчиняются последствиям сохраняемости памяти для неизменяемого <xref:System.String> класса. <xref:System.Security.SecureString> Лучший способ создания <xref:System.Security.SecureString> объекта — из неуправляемого источника «символ-время», такого <xref:System.Console.ReadKey%2A?displayProperty=nameWithType> как метод.  
  
 Удаление символов из <xref:System.Security.SecureString> объекта  
 Можно заменить отдельный символ, вызвав <xref:System.Security.SecureString.SetAt%2A> метод, удалив отдельный символ, <xref:System.Security.SecureString.RemoveAt%2A> вызвав метод, или <xref:System.Security.SecureString> удалить все символы из экземпляра, вызвав <xref:System.Security.SecureString.Clear%2A> метод.  
  
 <xref:System.Security.SecureString> Сделать объект доступным только для чтения  
 Определив строку, <xref:System.Security.SecureString> которую представляет объект, вызовите его <xref:System.Security.SecureString.MakeReadOnly%2A> метод, чтобы сделать строку доступной только для чтения.  
  
 Получение сведений об <xref:System.Security.SecureString> объекте  
 Класс содержит только два члена, которые предоставляют сведения о строке: его <xref:System.Security.SecureString.Length%2A> свойство, которое указывает число единиц кода в кодировке UTF16, в строке, и <xref:System.Security.SecureString.IsReadOnly%2A>метод, который указывает, является ли экземпляр <xref:System.Security.SecureString> только для чтения.  
  
 Освобождение памяти, выделенной для <xref:System.Security.SecureString> экземпляра  
 Поскольку <xref:System.Security.SecureString> <xref:System.Security.SecureString.Dispose%2A> реализует интерфейс, вы освобождаете его память путем вызова метода. <xref:System.IDisposable>  
  
 Класс не имеет членов, которые проверяют, сравнивают или преобразуют значение  <xref:System.Security.SecureString> .  <xref:System.Security.SecureString> Отсутствие таких членов помогает защитить значение экземпляра от случайной или злонамеренной уязвимости. Используйте соответствующие члены <xref:System.Runtime.InteropServices.Marshal?displayProperty=nameWithType> класса, такие <xref:System.Runtime.InteropServices.Marshal.SecureStringToBSTR%2A> как метод, для <xref:System.Security.SecureString> управления значением объекта.  
  
 Библиотека классов .NET Framework обычно использует <xref:System.Security.SecureString> экземпляры следующими способами.  
  
-   Для предоставления сведений о паролях процессу с помощью <xref:System.Diagnostics.ProcessStartInfo> структуры или путем вызова перегрузки <xref:System.Diagnostics.Process.Start%2A?displayProperty=nameWithType> метода, имеющего параметр типа <xref:System.Security.SecureString>.  
  
-   Для предоставления сведений о сетевом пароле <xref:System.Net.NetworkCredential> путем вызова конструктора класса с параметром типа <xref:System.Security.SecureString> или с помощью <xref:System.Net.NetworkCredential.SecurePassword%2A?displayProperty=nameWithType> свойства.  
  
-   Для предоставления сведений о паролях для SQL Server проверки подлинности путем вызова <xref:System.Data.SqlClient.SqlCredential.%23ctor%2A?displayProperty=nameWithType> конструктора или получения значения <xref:System.Data.SqlClient.SqlCredential.Password%2A?displayProperty=nameWithType> свойства.  
  
-   Передать строку в неуправляемый код. Дополнительные сведения см. в разделе [SecureString и Interop](#interop) .  
  
 [К началу](#top)  
  
<a name="interop"></a>   
## <a name="securestring-and-interop"></a>SecureString и Interop  
 Поскольку операционная система не поддерживает <xref:System.Security.SecureString>непосредственно, необходимо преобразовать значение <xref:System.Security.SecureString> объекта в требуемый строковый тип перед передачей строки в собственный метод.  <xref:System.Runtime.InteropServices.Marshal> Класс имеет пять методов, которые делают это:  
  
-   <xref:System.Runtime.InteropServices.Marshal.SecureStringToBSTR%2A?displayProperty=nameWithType>, который преобразует <xref:System.Security.SecureString> строковое значение в двоичную строку (BSTR), распознанную com.  
  
-   <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A?displayProperty=nameWithType>и <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A?displayProperty=nameWithType>, который <xref:System.Security.SecureString> копирует строковое значение в строку ANSI в неуправляемой памяти.  
  
-   <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A?displayProperty=nameWithType>и <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A?displayProperty=nameWithType>, который <xref:System.Security.SecureString> копирует строковое значение в строку Юникода в неуправляемой памяти.  
  
 Каждый из этих методов создает в неуправляемой памяти строку в виде открытого текста. Разработчику необходимо обнулить и освободить память, как только она больше не нужна. Каждое преобразование строки и методы выделения памяти имеют соответствующий метод для обнуления и освобождения выделенной памяти:  
  
|Метод выделения и преобразования|Ноль и бесплатный метод|  
|--------------------------------------|--------------------------|  
|<xref:System.Runtime.InteropServices.Marshal.SecureStringToBSTR%2A?displayProperty=nameWithType>|<xref:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR%2A?displayProperty=nameWithType>|  
|<xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A?displayProperty=nameWithType>|<xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A?displayProperty=nameWithType>|  
|<xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A?displayProperty=nameWithType>|<xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A?displayProperty=nameWithType>|  
|<xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A?displayProperty=nameWithType>|<xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A?displayProperty=nameWithType>|  
|<xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A?displayProperty=nameWithType>|<xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A?displayProperty=nameWithType>|  
  
 [К началу](#top)  
  
<a name="HowSecure"></a>   
## <a name="how-secure-is-securestring"></a>Насколько безопасным является SecureString?  
 При правильном создании <xref:System.Security.SecureString> экземпляр обеспечивает дополнительную защиту данных, <xref:System.String>чем. При создании строки на основе символа источника <xref:System.String> времени создает несколько промежуточных данных в памяти, <xref:System.Security.SecureString> тогда как создает только один экземпляр.  Сборка мусора объектов не является детерминированной. <xref:System.String> Кроме того, поскольку память не закреплена, сборщик мусора будет создавать дополнительные копии <xref:System.String> значений при перемещении и сжатии памяти. В отличие от этого, память, выделенная для <xref:System.Security.SecureString> объекта, закреплена, и эту память можно освободить путем <xref:System.Security.SecureString.Dispose%2A> вызова метода.  
  
 Хотя данные, хранящиеся <xref:System.Security.SecureString> в экземпляре, более безопасны, чем <xref:System.String> данные, хранящиеся в экземпляре, существуют значительные <xref:System.Security.SecureString> ограничения на степень защиты экземпляра. Сюда входит следующее.  
  
 Platform  
 В операционной системе Windows содержимое <xref:System.Security.SecureString> массива внутренних символов экземпляра шифруется. Тем не менее, из-за отсутствия API или проблем с управлением ключами шифрование недоступно на всех платформах. Из-за этой зависимости <xref:System.Security.SecureString> от платформы не шифрует внутреннее хранилище на платформе, отличной от Windows. Для обеспечения дополнительной защиты на этих платформах используются другие методы.
  
 Длительность  
 Даже если <xref:System.Security.SecureString> реализация может использовать преимущества шифрования, простой текст, назначенный <xref:System.Security.SecureString> экземпляру, может быть представлен в различные моменты времени:  
  
-   Поскольку в Windows не предусмотрена Безопасная реализация строк на уровне операционной системы, .NET Framework по-прежнему необходимо преобразовать защищенное строковое значение в его текстовое представление, чтобы использовать его.  
  
-   Всякий раз, когда значение защищенной строки изменяется такими методами <xref:System.Security.SecureString.AppendChar%2A> , <xref:System.Security.SecureString.RemoveAt%2A>как или, оно должно быть расшифровано (то есть преобразовано обратно в обычный текст), изменено, а затем снова зашифровано.  
  
-   Если безопасная строка используется в вызове взаимодействия, ее необходимо преобразовать в строку ANSI, строку в Юникоде или двоичную строку (BSTR). Дополнительные сведения см. в разделе [SecureString и Interop](#interop) .  
  
 Интервал времени, для которого <xref:System.Security.SecureString> предоставляется значение экземпляра, просто сокращается в сравнении <xref:System.String> с классом.  
  
 Хранение и использование  
 В <xref:System.Security.SecureString> общем, класс определяет механизм хранения для строковых значений, которые должны быть защищены или сохранены в конфиденциальном виде. Однако за пределами самого .NET Framework механизм использования не поддерживается <xref:System.Security.SecureString>. Это означает, что безопасная строка должна быть преобразована в пригодную для использования форму (обычно это форма с открытым текстом), которую можно распознать целевым объектом, а расшифровка и преобразование должны происходить в пространстве пользователя.  
  
 В целом <xref:System.Security.SecureString> , является более безопасным <xref:System.String> , чем потому, что он ограничивает раскрытие конфиденциальных строковых данных. Однако эти строки могут по-прежнему предоставляться любому процессу или операции, имеющей доступ к необработанной памяти, например к вредоносному процессу, выполняемому на главном компьютере, дампу процесса или файлу подкачки, видимому пользователю. Вместо использования <xref:System.Security.SecureString> для защиты паролей рекомендуется использовать непрозрачный маркер для учетных данных, хранящихся за пределами процесса.  
  
 [К началу](#top)  
  
   
  
## Examples  
 В следующем примере показано, <xref:System.Security.SecureString> как использовать для защиты пароля пользователя, чтобы использовать его в качестве учетных данных для запуска нового процесса.  
  
 [!code-csharp[System.Security.SecureString.Ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.SecureString.Ctor/cs/ctor4.cs#4)]
 [!code-vb[System.Security.SecureString.Ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.SecureString.Ctor/vb/ctor4.vb#4)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Runtime.InteropServices.ComVisibleAttribute" />
    <altmember cref="T:System.Runtime.InteropServices.Marshal" />
    <altmember cref="T:System.Runtime.ConstrainedExecution.CriticalFinalizerObject" />
    <altmember cref="T:System.IDisposable" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Security.SecureString" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SecureString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecureString.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SecureString();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Security.SecureString" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере используется конструктор по умолчанию (без параметров) для создания экземпляра нового <xref:System.Security.SecureString> объекта. Затем вызывается <xref:System.Security.SecureString.AppendChar%2A> метод для добавления в него массива символов.  
  
 [!code-cpp[System.Security.SecureString.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.SecureString.Ctor/cpp/Ctor2.cpp#2)]
 [!code-csharp[System.Security.SecureString.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.SecureString.Ctor/cs/Ctor2.cs#2)]
 [!code-vb[System.Security.SecureString.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.SecureString.Ctor/vb/ctor2.vb#2)]  
  
 В следующем примере создается <xref:System.Security.SecureString> объект на основе значения <xref:System.String> объекта.  
  
 [!code-cpp[System.Security.SecureString.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.SecureString.Ctor/cpp/Ctor3.cpp#3)]
 [!code-csharp[System.Security.SecureString.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.SecureString.Ctor/cs/Ctor3.cs#3)]
 [!code-vb[System.Security.SecureString.Ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.SecureString.Ctor/vb/Ctor3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Произошла ошибка при защите значения этого экземпляра или снятии с него защиты.</exception>
        <exception cref="T:System.NotSupportedException">Эта операция не поддерживается этой платформой.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SecureString (char* value, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecureString.#ctor(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SecureString(char* value, int length);" />
      <MemberSignature Language="F#" Value="new System.Security.SecureString : nativeptr&lt;char&gt; * int -&gt; System.Security.SecureString" Usage="new System.Security.SecureString (value, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Указатель на массив объектов <see cref="T:System.Char" />.</param>
        <param name="length">Число элементов массива <paramref name="value" />, включаемых в новый экземпляр.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Security.SecureString" /> из подмассива объектов <see cref="T:System.Char" />.  
  
Этот конструктор несовместим с CLS. CLS-совместимая альтернатива — <see cref="M:System.Security.SecureString.#ctor" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор инициализирует новый <xref:System.Security.SecureString> объект до количества символов в `value` указанном параметре `length`. Затем значение шифруется.  
  
 В C#этот конструктор определяется только в контексте ненадежного кода.  
  
   
  
## Examples  
 В следующем примере создается экземпляр нового <xref:System.Security.SecureString> объекта путем передачи его конструктора указателя на массив символов.  
  
 [!code-cpp[System.Security.SecureString.Ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.security.securestring.ctor2/cpp/ctor1.cpp#1)]
 [!code-csharp[System.Security.SecureString.Ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.security.securestring.ctor2/cs/ctor1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="value" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length" /> меньше нуля или больше 65 536.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Произошла ошибка при защите значения этой защищенной строки или снятии с него защиты.</exception>
        <exception cref="T:System.NotSupportedException">Эта операция не поддерживается этой платформой.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="AppendChar">
      <MemberSignature Language="C#" Value="public void AppendChar (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendChar(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecureString.AppendChar(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendChar (c As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendChar(char c);" />
      <MemberSignature Language="F#" Value="member this.AppendChar : char -&gt; unit" Usage="secureString.AppendChar c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptions</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Знак, добавляемый к защищенной строке.</param>
        <summary>Добавляет знак в конец текущей защищенной строки.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если в реализации используется механизм защиты, например шифрование, то значение этой защищенной строки, если таковое имеется, не защищено; `c` добавляется, а затем новое значение защищенной строки повторно защищается.  
  
   
  
## Examples  
 В следующем <xref:System.Security.SecureString.AppendChar%2A>примере показано <xref:System.Security.SecureString.InsertAt%2A> <xref:System.Security.SecureString.Clear%2A> <xref:System.Security.SecureString.SetAt%2A>, как методы,, <xref:System.Security.SecureString> , и влияют на значение объекта. <xref:System.Security.SecureString.RemoveAt%2A>  
  
 [!code-cpp[SecureString.xAt#1](~/samples/snippets/cpp/VS_Snippets_CLR/SecureString.xAt/CPP/SecureString.xAt.cpp#1)]
 [!code-csharp[SecureString.xAt#1](~/samples/snippets/csharp/VS_Snippets_CLR/SecureString.xAt/CS/xat.cs#1)]
 [!code-vb[SecureString.xAt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SecureString.xAt/VB/xat.vb#1)]  
  
 В следующем примере показано, <xref:System.Security.SecureString.AppendChar%2A> как можно использовать методы и <xref:System.Security.SecureString.RemoveAt%2A> для получения символов в пароле.  
  
 [!code-cpp[SecureString.xChar#1](~/samples/snippets/cpp/VS_Snippets_CLR/SecureString.xChar/CPP/SecureString.xChar.cpp#1)]
 [!code-csharp[SecureString.xChar#1](~/samples/snippets/csharp/VS_Snippets_CLR/SecureString.xChar/CS/xchar.cs#1)]
 [!code-vb[SecureString.xChar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SecureString.xChar/VB/xchar.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Защищенная строка уже удалена.</exception>
        <exception cref="T:System.InvalidOperationException">Данная защищенная строка доступна только для чтения.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">При выполнении этой операции длина защищенной строки превысит 65 536 символов.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Произошла ошибка при защите значения этой защищенной строки или снятии с него защиты.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecureString.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="secureString.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет значение текущей защищенной строки.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объем памяти компьютера, который содержит значение этой защищенной строки, равен нулю, а длина значения этой защищенной строки равна нулю.  
  
   
  
## Examples  
 В следующем <xref:System.Security.SecureString.AppendChar%2A>примере показано <xref:System.Security.SecureString.InsertAt%2A> <xref:System.Security.SecureString.Clear%2A> <xref:System.Security.SecureString.SetAt%2A>, как методы,, <xref:System.Security.SecureString> , и влияют на значение объекта. <xref:System.Security.SecureString.RemoveAt%2A>  
  
 [!code-cpp[SecureString.xAt#1](~/samples/snippets/cpp/VS_Snippets_CLR/SecureString.xAt/CPP/SecureString.xAt.cpp#1)]
 [!code-csharp[SecureString.xAt#1](~/samples/snippets/csharp/VS_Snippets_CLR/SecureString.xAt/CS/xat.cs#1)]
 [!code-vb[SecureString.xAt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SecureString.xAt/VB/xat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Защищенная строка уже удалена.</exception>
        <exception cref="T:System.InvalidOperationException">Данная защищенная строка доступна только для чтения.</exception>
        <altmember cref="P:System.Security.SecureString.Length" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public System.Security.SecureString Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.SecureString Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecureString.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Function Copy () As SecureString" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::SecureString ^ Copy();" />
      <MemberSignature Language="F#" Value="member this.Copy : unit -&gt; System.Security.SecureString" Usage="secureString.Copy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.SecureString</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает копию текущей защищенной строки.</summary>
        <returns>Копия этой защищенной строки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если экземпляр <xref:System.Security.SecureString> объекта помечен атрибутом только для чтения, копия этого экземпляра не будет доступна только для чтения.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Защищенная строка уже удалена.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Произошла ошибка при защите значения этой защищенной строки или снятии с него защиты.</exception>
        <altmember cref="M:System.Security.SecureString.MakeReadOnly" />
        <altmember cref="M:System.Security.SecureString.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecureString.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="secureString.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает все ресурсы, используемые текущим объектом <see cref="T:System.Security.SecureString" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод записывает двоичные нули в выделенную память, содержащую значение этого <xref:System.Security.SecureString> объекта, а затем освобождает выделенную память. <xref:System.Security.SecureString.Dispose%2A>  
  
 Дополнительные сведения см. в разделе [Сборка мусора](~/docs/standard/garbage-collection/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertAt">
      <MemberSignature Language="C#" Value="public void InsertAt (int index, char c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertAt(int32 index, char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecureString.InsertAt(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertAt (index As Integer, c As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertAt(int index, char c);" />
      <MemberSignature Language="F#" Value="member this.InsertAt : int * char -&gt; unit" Usage="secureString.InsertAt (index, c)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptions</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="index">Индекс позиции вставки параметра <paramref name="c" />.</param>
        <param name="c">Вставляемый знак.</param>
        <summary>Вставляет знак в заданную индексом позицию защищенной строки.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Индекс отсчитывается от нуля; Первый символ в этой защищенной строке находится в нулевой позиции индекса.  
  
 Если в реализации используется механизм защиты, например шифрование, то значение защищенной строки (если таковое имеется) не защищается; `c` вставляется по указанной позиции индекса; затем новое значение защищается повторно. Метод возвращает те же результаты, <xref:System.Security.SecureString.AppendChar%2A> что и метод, который вставляет символ в конце `index` защищенной строки <xref:System.Security.SecureString.InsertAt%2A> , если параметр имеет значение длины данного экземпляра. <xref:System.Security.SecureString.InsertAt%2A>  
  
   
  
## Examples  
 В следующем <xref:System.Security.SecureString.AppendChar%2A>примере показано <xref:System.Security.SecureString.InsertAt%2A> <xref:System.Security.SecureString.Clear%2A> <xref:System.Security.SecureString.SetAt%2A>, как методы,, <xref:System.Security.SecureString> , и влияют на значение объекта. <xref:System.Security.SecureString.RemoveAt%2A>  
  
 [!code-cpp[SecureString.xAt#1](~/samples/snippets/cpp/VS_Snippets_CLR/SecureString.xAt/CPP/SecureString.xAt.cpp#1)]
 [!code-csharp[SecureString.xAt#1](~/samples/snippets/csharp/VS_Snippets_CLR/SecureString.xAt/CS/xat.cs#1)]
 [!code-vb[SecureString.xAt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SecureString.xAt/VB/xat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Защищенная строка уже удалена.</exception>
        <exception cref="T:System.InvalidOperationException">Данная защищенная строка доступна только для чтения.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="index" /> менее нуля или более длины защищенной строки.  
  
- или - 
При выполнении этой операции длина защищенной строки превысит 65 536 символов.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Произошла ошибка при защите значения этой защищенной строки или снятии с него защиты.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecureString.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Function IsReadOnly () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsReadOnly();" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : unit -&gt; bool" Usage="secureString.IsReadOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Указывает, что защищенная строка доступна только для чтения.</summary>
        <returns>Значение <see langword="true" />, если защищенная строка доступна только для чтения; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 После того как экземпляр <xref:System.Security.SecureString> помечается как доступный только <xref:System.Security.SecureString.MakeReadOnly%2A> для чтения методом, любая попытка изменить значение экземпляра приведет к возникновению <xref:System.InvalidOperationException>исключения. Используйте метод, чтобы проверить, доступен <xref:System.Security.SecureString> ли объект только для чтения, прежде чем пытаться изменить его. <xref:System.Security.SecureString.IsReadOnly%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Защищенная строка уже удалена.</exception>
        <altmember cref="M:System.Security.SecureString.MakeReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Security.SecureString.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.Security.SecureString.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает количество символов в текущей защищенной строке.</summary>
        <value>Количество объектов <see cref="T:System.Char" /> в этой защищенной строке.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.SecureString.Length%2A> Свойство возвращает <xref:System.Char>  количество объектов в данном экземпляре, а не число символов Юникода. Символ Юникода может быть представлен более чем одним <xref:System.Char> объектом.  
  
 Максимальная длина <xref:System.Security.SecureString> экземпляра — 65 536 символов.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Защищенная строка уже удалена.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeReadOnly">
      <MemberSignature Language="C#" Value="public void MakeReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MakeReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecureString.MakeReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Sub MakeReadOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MakeReadOnly();" />
      <MemberSignature Language="F#" Value="member this.MakeReadOnly : unit -&gt; unit" Usage="secureString.MakeReadOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Делает текстовое значение этой защищенной строки доступным только для чтения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.SecureString> Инициализируйте текстовое значение экземпляра класса <xref:System.Security.SecureString.%23ctor%2A> с помощью конструкторов и <xref:System.Security.SecureString.Clear%2A>измените <xref:System.Security.SecureString.SetAt%2A>значение с помощью методов, <xref:System.Security.SecureString.RemoveAt%2A>,, <xref:System.Security.SecureString.InsertAt%2A>и <xref:System.Security.SecureString.AppendChar%2A> .  
  
 После внесения окончательных изменений используйте <xref:System.Security.SecureString.MakeReadOnly%2A> метод, чтобы сделать значение экземпляра неизменяемым (только для чтения). Если значение помечено как доступное только для чтения, дальнейшая попытка его изменения приведет <xref:System.InvalidOperationException>к возникновению исключения.  
  
 Результат вызова <xref:System.Security.SecureString.MakeReadOnly%2A> является постоянным, <xref:System.Security.SecureString> так как класс не предоставляет средств для повторного изменения защищенной строки. Используйте метод, чтобы проверить <xref:System.Security.SecureString> , доступен ли экземпляр только для чтения. <xref:System.Security.SecureString.IsReadOnly%2A>  
  
   
  
## Examples  
 В следующем примере показано, <xref:System.Security.SecureString.AppendChar%2A> как можно использовать методы и <xref:System.Security.SecureString.RemoveAt%2A> для получения символов в пароле. После сбора пароль становится доступен только для чтения.  
  
 [!code-cpp[SecureString.xChar#1](~/samples/snippets/cpp/VS_Snippets_CLR/SecureString.xChar/CPP/SecureString.xChar.cpp#1)]
 [!code-csharp[SecureString.xChar#1](~/samples/snippets/csharp/VS_Snippets_CLR/SecureString.xChar/CS/xchar.cs#1)]
 [!code-vb[SecureString.xChar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SecureString.xChar/VB/xchar.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Защищенная строка уже удалена.</exception>
        <altmember cref="M:System.Security.SecureString.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecureString.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAt(int index);" />
      <MemberSignature Language="F#" Value="member this.RemoveAt : int -&gt; unit" Usage="secureString.RemoveAt index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptions</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Индекс знака в защищенной строке.</param>
        <summary>Удаляет из защищенной строки знак, расположенный по указанному индексу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Индекс отсчитывается от нуля; Первый символ в этом экземпляре находится в нулевой позиции индекса.  
  
 Если в реализации используется механизм защиты, например шифрование, то значение этой защищенной строки, если таковое имеется, не защищено; символ в указанной позиции индекса удаляется; Затем новое значение защищается повторно.  
  
   
  
## Examples  
 В следующем <xref:System.Security.SecureString.AppendChar%2A>примере показано <xref:System.Security.SecureString.InsertAt%2A> <xref:System.Security.SecureString.Clear%2A> <xref:System.Security.SecureString.SetAt%2A>, как методы,, <xref:System.Security.SecureString> , и влияют на значение объекта. <xref:System.Security.SecureString.RemoveAt%2A>  
  
 [!code-cpp[SecureString.xAt#1](~/samples/snippets/cpp/VS_Snippets_CLR/SecureString.xAt/CPP/SecureString.xAt.cpp#1)]
 [!code-csharp[SecureString.xAt#1](~/samples/snippets/csharp/VS_Snippets_CLR/SecureString.xAt/CS/xat.cs#1)]
 [!code-vb[SecureString.xAt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SecureString.xAt/VB/xat.vb#1)]  
  
 В следующем примере показано, <xref:System.Security.SecureString.AppendChar%2A> как можно использовать методы и <xref:System.Security.SecureString.RemoveAt%2A> для получения символов в пароле.  
  
 [!code-cpp[SecureString.xChar#1](~/samples/snippets/cpp/VS_Snippets_CLR/SecureString.xChar/CPP/SecureString.xChar.cpp#1)]
 [!code-csharp[SecureString.xChar#1](~/samples/snippets/csharp/VS_Snippets_CLR/SecureString.xChar/CS/xchar.cs#1)]
 [!code-vb[SecureString.xChar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SecureString.xChar/VB/xchar.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Защищенная строка уже удалена.</exception>
        <exception cref="T:System.InvalidOperationException">Данная защищенная строка доступна только для чтения.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="index" /> меньше нуля или больше или равно длине данной защищенной строки.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Произошла ошибка при защите значения этой защищенной строки или снятии с него защиты.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAt">
      <MemberSignature Language="C#" Value="public void SetAt (int index, char c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAt(int32 index, char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecureString.SetAt(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAt (index As Integer, c As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAt(int index, char c);" />
      <MemberSignature Language="F#" Value="member this.SetAt : int * char -&gt; unit" Usage="secureString.SetAt (index, c)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptions</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="index">Индекс имеющегося знака в защищенной строке.</param>
        <param name="c">Знак, заменяющий имеющийся знак.</param>
        <summary>Заменяет расположенный по указанному индексу знак другим знаком.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Индекс отсчитывается от нуля; Первый символ в этом экземпляре находится в нулевой позиции индекса.  
  
 Если в реализации используется механизм защиты, например шифрование, то значение защищенной строки (если таковое имеется) не защищается; `c` присваивается указанной позиции индекса; затем новое значение защищается повторно.  
  
   
  
## Examples  
 В следующем <xref:System.Security.SecureString.AppendChar%2A>примере показано <xref:System.Security.SecureString.InsertAt%2A> <xref:System.Security.SecureString.Clear%2A> <xref:System.Security.SecureString.SetAt%2A>, как методы,, <xref:System.Security.SecureString> , и влияют на значение объекта. <xref:System.Security.SecureString.RemoveAt%2A>  
  
 [!code-cpp[SecureString.xAt#1](~/samples/snippets/cpp/VS_Snippets_CLR/SecureString.xAt/CPP/SecureString.xAt.cpp#1)]
 [!code-csharp[SecureString.xAt#1](~/samples/snippets/csharp/VS_Snippets_CLR/SecureString.xAt/CS/xat.cs#1)]
 [!code-vb[SecureString.xAt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SecureString.xAt/VB/xat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Защищенная строка уже удалена.</exception>
        <exception cref="T:System.InvalidOperationException">Данная защищенная строка доступна только для чтения.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="index" /> меньше нуля или больше или равно длине данной защищенной строки.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Произошла ошибка при защите значения этой защищенной строки или снятии с него защиты.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
