<Type Name="ValueSerializer" FullName="System.Windows.Markup.ValueSerializer">
  <Metadata><Meta Name="ms.openlocfilehash" Value="65a7488a614c640ae3cdd3cf8bb8adf47c3ea15d" /><Meta Name="ms.sourcegitcommit" Value="2767b5903996fbd7e2b81eda1114dfc9d0d9db63" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="05/02/2019" /><Meta Name="ms.locfileid" Value="64994689" /></Metadata><TypeSignature Language="C#" Value="public abstract class ValueSerializer" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract ValueSerializer extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Markup.ValueSerializer" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ValueSerializer" />
  <TypeSignature Language="C++ CLI" Value="public ref class ValueSerializer abstract" />
  <TypeSignature Language="F#" Value="type ValueSerializer = class" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.Runtime.CompilerServices.TypeForwardedFrom("WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Абстрактный класс, который определяет поведение преобразования сериализации из представления объекта.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Строка, возвращаемая преобразователем для сериализации, должна быть меньше потери, а преобразователь должен всегда возвращать одну и ту же строку для определенного значения.  Если преобразователь типов (производный <xref:System.ComponentModel.TypeConverter>от) не соответствует этим требованиям в своих `ConvertTo` реализациях для вывода строк, необходимо объявить пользовательское <xref:System.Windows.Markup.ValueSerializer> . Либо должен соответствовать требованиям, либо null <xref:System.Windows.Markup.ValueSerializer> должен быть связан с типом. <xref:System.Windows.Markup.ValueSerializer> Объект <xref:System.Windows.Markup.ValueSerializer> связан с типом путем <xref:System.Windows.Markup.ValueSerializerAttribute> применения атрибута.  
  
 Значение NULL <xref:System.Windows.Markup.ValueSerializer> указывает, что преобразователь типов должен игнорироваться при преобразовании преобразования в строку из графа объектов.  
  
> [!IMPORTANT]
>  Реализация метода <xref:System.Windows.Markup.ValueSerializer> должна избегать возникновения исключений. Все исключения, которые вызываются, могут привести к завершению сериализации.  
  
 <xref:System.Windows.Markup.IValueSerializerContext>для и его API-интерфейсы <xref:System.ComponentModel.ITypeDescriptorContext> аналогичен для <xref:System.ComponentModel.TypeConverter>. <xref:System.Windows.Markup.ValueSerializer> <xref:System.Windows.Markup.IValueSerializerContext> Фактически<xref:System.ComponentModel.ITypeDescriptorContext>наследует. При вызове API производного класса вызывающий (обычно процесс сериализатора) передает контекст, который может предоставлять определенные службы. <xref:System.Windows.Markup.ValueSerializer> Из- <xref:System.Windows.Markup.ValueSerializer> за общего руководства, которое не должно вызывать исключения. Сбой возврата определенной службы из контекста не должен вызывать исключения.  
  
 В предыдущих версиях .NET Framework этот класс существовал в сборке, относящейся к WPF, WindowsBase. В [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]параметрнаходитсявсборкеSystem .XAML.<xref:System.Windows.Markup.ValueSerializer> Для получения дополнительной информации см. [Types Migrated from WPF to System.Xaml](~/docs/framework/xaml-services/types-migrated-from-wpf-to-system-xaml.md).  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Xaml.XamlXmlWriter" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ValueSerializer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ValueSerializer();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.Markup.ValueSerializer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Тело этого конструктора пусто; <xref:System.Windows.Markup.ValueSerializer> класс не содержит значений, требующих инициализации.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanConvertFromString">
      <MemberSignature Language="C#" Value="public virtual bool CanConvertFromString (string value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanConvertFromString(string value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.CanConvertFromString(System.String,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanConvertFromString (value As String, context As IValueSerializerContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanConvertFromString(System::String ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member CanConvertFromString : string * System.Windows.Markup.IValueSerializerContext -&gt; bool&#xA;override this.CanConvertFromString : string * System.Windows.Markup.IValueSerializerContext -&gt; bool" Usage="valueSerializer.CanConvertFromString (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netframework-4.8" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" Index="1" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="value">Строка, для которой требуется проверить возможность преобразования.</param>
        <param name="context">Контекстная информация, используемая при выполнении преобразования.</param>
        <summary>При переопределении в производном классе определяет, может ли указанный класс <see cref="T:System.String" /> быть преобразован в экземпляр типа, который поддерживается реализацией класса <see cref="T:System.Windows.Markup.ValueSerializer" />.</summary>
        <returns>Значение <see langword="true" />, если значение можно преобразовать; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Базовая реализация всегда возвращает значение `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanConvertToString">
      <MemberSignature Language="C#" Value="public virtual bool CanConvertToString (object value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanConvertToString(object value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.CanConvertToString(System.Object,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanConvertToString (value As Object, context As IValueSerializerContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanConvertToString(System::Object ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member CanConvertToString : obj * System.Windows.Markup.IValueSerializerContext -&gt; bool&#xA;override this.CanConvertToString : obj * System.Windows.Markup.IValueSerializerContext -&gt; bool" Usage="valueSerializer.CanConvertToString (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.8" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" Index="1" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="value">Объект, для которого необходимо проверить возможность преобразования.</param>
        <param name="context">Контекстная информация, используемая при выполнении преобразования.</param>
        <summary>Если переопределено в производном классе, определяет, можно ли преобразовать указанный объект в <see cref="T:System.String" />.</summary>
        <returns>Значение <see langword="true" />, если <paramref name="value" /> можно преобразовать в <see cref="T:System.String" />; в противном случае — значение <see langword="false." /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Базовая реализация всегда возвращает значение `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertFromString">
      <MemberSignature Language="C#" Value="public virtual object ConvertFromString (string value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ConvertFromString(string value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.ConvertFromString(System.String,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ConvertFromString (value As String, context As IValueSerializerContext) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ConvertFromString(System::String ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member ConvertFromString : string * System.Windows.Markup.IValueSerializerContext -&gt; obj&#xA;override this.ConvertFromString : string * System.Windows.Markup.IValueSerializerContext -&gt; obj" Usage="valueSerializer.ConvertFromString (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netframework-4.8" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" Index="1" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="value">Преобразуемая строка.</param>
        <param name="context">Контекстная информация, используемая при выполнении преобразования.</param>
        <summary>При переопределении в производном классе преобразует <see cref="T:System.String" /> в экземпляр типа, который поддерживает реализация <see cref="T:System.Windows.Markup.ValueSerializer" />.</summary>
        <returns>Новый экземпляр типа, который поддерживает реализация <see cref="T:System.Windows.Markup.ValueSerializer" />, на основе предоставленного <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Базовая реализация всегда создает исключение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="value" /> невозможно преобразовать.</exception>
        <block subset="none" type="overrides"><para>Избегайте возникновения исключений из реализаций. См. раздел <see cref="T:System.Windows.Markup.ValueSerializer" />.</para></block>
      </Docs>
    </Member>
    <Member MemberName="ConvertToString">
      <MemberSignature Language="C#" Value="public virtual string ConvertToString (object value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ConvertToString(object value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.ConvertToString(System.Object,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ConvertToString (value As Object, context As IValueSerializerContext) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ConvertToString(System::Object ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member ConvertToString : obj * System.Windows.Markup.IValueSerializerContext -&gt; string&#xA;override this.ConvertToString : obj * System.Windows.Markup.IValueSerializerContext -&gt; string" Usage="valueSerializer.ConvertToString (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.8" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" Index="1" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="value">Объект, преобразуемый в строку.</param>
        <param name="context">Контекстная информация, используемая при выполнении преобразования.</param>
        <summary>Если переопределено в производном классе, преобразует указанный объект в <see cref="T:System.String" />.</summary>
        <returns>Представление строки указанного объекта.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Базовая реализация всегда создает исключение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="value" /> невозможно преобразовать.</exception>
        <block subset="none" type="overrides"><para>Избегайте возникновения исключений из реализаций. См. раздел <see cref="T:System.Windows.Markup.ValueSerializer" />.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetConvertFromException">
      <MemberSignature Language="C#" Value="protected Exception GetConvertFromException (object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Exception GetConvertFromException(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetConvertFromException(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetConvertFromException (value As Object) As Exception" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Exception ^ GetConvertFromException(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.GetConvertFromException : obj -&gt; Exception" Usage="valueSerializer.GetConvertFromException value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="value">Объект, который не удалось преобразовать.</param>
        <summary>Возвращает исключение, возникающее, если преобразование не может быть выполнено.</summary>
        <returns>Объект <see cref="T:System.Exception" /> для исключения, которое необходимо создать, если невозможно выполнить преобразование <see langword="ConvertFrom" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Фактическое `throw` ключевое слово не вызывается этим методом, поэтому типичное использование — `throw GetConvertFromException` (с предоставленными параметрами).  
  
 Возвращается <xref:System.InvalidOperationException>конкретное исключение `value` , в котором передано сообщение об исключении. Шаблон для использования такой же, как и для служебных программ <xref:System.ComponentModel.TypeConverter>исключений в.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConvertToException">
      <MemberSignature Language="C#" Value="protected Exception GetConvertToException (object value, Type destinationType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Exception GetConvertToException(object value, class System.Type destinationType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetConvertToException(System.Object,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetConvertToException (value As Object, destinationType As Type) As Exception" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Exception ^ GetConvertToException(System::Object ^ value, Type ^ destinationType);" />
      <MemberSignature Language="F#" Value="member this.GetConvertToException : obj * Type -&gt; Exception" Usage="valueSerializer.GetConvertToException (value, destinationType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.8" />
        <Parameter Name="destinationType" Type="System.Type" Index="1" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="value">Объект, который не удалось преобразовать.</param>
        <param name="destinationType">Тип, представляющий тип, в который осуществлялось преобразование.</param>
        <summary>Возвращает исключение, возникающее, если преобразование не может быть выполнено.</summary>
        <returns>Объект <see cref="T:System.Exception" /> для исключения, которое необходимо создать, если невозможно выполнить преобразование <see langword="ConvertTo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Само `throw` ключевое слово не вызывается этим методом, поэтому обычно используется `throw GetConvertToException` (с `value` предоставленным параметром).  
  
 Возвращается <xref:System.InvalidOperationException>конкретное исключение `value` , в котором передано сообщение об исключении. Шаблон для использования такой же, как и для служебных программ <xref:System.ComponentModel.TypeConverter>исключений в.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSerializerFor">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает <see cref="T:System.Windows.Markup.ValueSerializer" /> для объекта.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSerializerFor">
      <MemberSignature Language="C#" Value="public static System.Windows.Markup.ValueSerializer GetSerializerFor (System.ComponentModel.PropertyDescriptor descriptor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Markup.ValueSerializer GetSerializerFor(class System.ComponentModel.PropertyDescriptor descriptor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.ComponentModel.PropertyDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSerializerFor (descriptor As PropertyDescriptor) As ValueSerializer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Markup::ValueSerializer ^ GetSerializerFor(System::ComponentModel::PropertyDescriptor ^ descriptor);" />
      <MemberSignature Language="F#" Value="static member GetSerializerFor : System.ComponentModel.PropertyDescriptor -&gt; System.Windows.Markup.ValueSerializer" Usage="System.Windows.Markup.ValueSerializer.GetSerializerFor descriptor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.ValueSerializer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descriptor" Type="System.ComponentModel.PropertyDescriptor" Index="0" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="descriptor">Дескриптор свойства CLR сериализуемого свойства.</param>
        <summary>Получает класс <see cref="T:System.Windows.Markup.ValueSerializer" />, объявленный для свойства, путем передачи свойству дескриптора свойства среды CLR.</summary>
        <returns>Сериализатор, связанный с заданным свойством. Может возвращать значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для свойства или для типа, используемого в качестве значения свойства, указывается путем <xref:System.Windows.Markup.ValueSerializerAttribute> применения атрибута к объявлению свойства или типа. <xref:System.Windows.Markup.ValueSerializer> Метод — это служебный метод, считывающий сведения о системе типов CLR и возвращающий новый <xref:System.Windows.Markup.ValueSerializer> класс на основе атрибута, если он найден в свойстве, или значение, если оно найдено в типе свойства. <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%2A> `null`может возвращаться, если такой сериализатор не существует. `null`также может возвращаться, если тип или свойство преднамеренно имеет атрибут со значением <xref:System.Windows.Markup.ValueSerializerAttribute>null.  
  
 Другой <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%2A> поддерживаемый режим Возвращает внутренний `Convert` <xref:System.Windows.Markup.ValueSerializer> `TypeConverterValueSerializer` класс, который представляет собой реализацию, которая заключает в оболочку <xref:System.ComponentModel.TypeConverter> и преобразует методы в `Convert*String` методы (например, <xref:System.ComponentModel.TypeConverter.ConvertTo%2A?displayProperty=nameWithType>вызывается с входными данными <xref:System.String> типа и преобразуется в. <xref:System.Windows.Markup.ValueSerializer.ConvertToString%2A> Это делается только в тех случаях, когда выполняются все перечисленные ниже условия.  
  
-   Объект <xref:System.ComponentModel.TypeConverterAttribute> находится в соответствующем свойстве или в соответствующем типе свойства.  
  
-   Указанное <xref:System.ComponentModel.TypeConverter> значение может быть успешно создано.  
  
-   Возвращает значение для <xref:System.String> , называемое ссылкой на тип. <xref:System.ComponentModel.TypeConverter.ConvertTo%2A?displayProperty=nameWithType> `true` <xref:System.ComponentModel.TypeConverter>  
  
-   Возвращает значение для <xref:System.String> , называемое ссылкой на тип. <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A?displayProperty=nameWithType> `true` <xref:System.ComponentModel.TypeConverter>  
  
-   Возвращает значение для <xref:System.String> , называемое ссылкой на тип. <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A?displayProperty=nameWithType> `true` <xref:System.ComponentModel.TypeConverter>  
  
> [!NOTE]
>  Ниже приведены особые случаи: <xref:System.DateTime> типы <xref:System.Windows.Markup.DateTimeValueSerializer>возвращают; типы возвращают внутренний, но функциональный`StringValueSerializer`сериализатор (). <xref:System.String>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="descriptor" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSerializerFor">
      <MemberSignature Language="C#" Value="public static System.Windows.Markup.ValueSerializer GetSerializerFor (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Markup.ValueSerializer GetSerializerFor(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Markup::ValueSerializer ^ GetSerializerFor(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetSerializerFor : Type -&gt; System.Windows.Markup.ValueSerializer" Usage="System.Windows.Markup.ValueSerializer.GetSerializerFor type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.ValueSerializer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="type">Тип, для которого требуется получить <see cref="T:System.Windows.Markup.ValueSerializer" />.</param>
        <summary>Получает <see cref="T:System.Windows.Markup.ValueSerializer" />, объявленный для заданного типа.</summary>
        <returns>Сериализатор, связанный с заданным типом. Может возвращать значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Тип для типа указывается путем <xref:System.Windows.Markup.ValueSerializerAttribute> применения атрибута к объявлению типа. <xref:System.Windows.Markup.ValueSerializer> Метод — это служебный метод, считывающий сведения о системе типов CLR и возвращающий новый <xref:System.Windows.Markup.ValueSerializer> класс на основе атрибута, если он найден в указанном. `type` <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%2A> `null`может возвращаться, если такой сериализатор не существует. `null`также может возвращаться, если тип намеренно имеет атрибут со значением <xref:System.Windows.Markup.ValueSerializerAttribute>null.  
  
 Другой <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%2A> поддерживаемый режим Возвращает внутренний `Convert` <xref:System.Windows.Markup.ValueSerializer> `TypeConverterValueSerializer` класс, который представляет собой реализацию, которая заключает в оболочку <xref:System.ComponentModel.TypeConverter> и преобразует методы в `Convert*String` методы (например, <xref:System.ComponentModel.TypeConverter.ConvertTo%2A?displayProperty=nameWithType>вызывается с входными данными <xref:System.String> типа и преобразуется в. <xref:System.Windows.Markup.ValueSerializer.ConvertToString%2A> Это делается только в тех случаях, когда выполняются все перечисленные ниже условия.  
  
-   Объект <xref:System.ComponentModel.TypeConverterAttribute> найден в `type`.  
  
-   Указанное <xref:System.ComponentModel.TypeConverter> значение может быть успешно создано.  
  
-   Возвращает значение для <xref:System.String> , называемое ссылкой на тип. <xref:System.ComponentModel.TypeConverter.ConvertTo%2A?displayProperty=nameWithType> `true` <xref:System.ComponentModel.TypeConverter>  
  
-   Возвращает значение для <xref:System.String> , называемое ссылкой на тип. <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A?displayProperty=nameWithType> `true` <xref:System.ComponentModel.TypeConverter>  
  
-   Возвращает значение для <xref:System.String> , называемое ссылкой на тип. <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A?displayProperty=nameWithType> `true` <xref:System.ComponentModel.TypeConverter>  
  
> [!NOTE]
>  Ниже приведены особые случаи: <xref:System.DateTime> типы <xref:System.Windows.Markup.DateTimeValueSerializer>возвращают; типы возвращают внутренний, но функциональный`StringValueSerializer`сериализатор (). <xref:System.String>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> — <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSerializerFor">
      <MemberSignature Language="C#" Value="public static System.Windows.Markup.ValueSerializer GetSerializerFor (System.ComponentModel.PropertyDescriptor descriptor, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Markup.ValueSerializer GetSerializerFor(class System.ComponentModel.PropertyDescriptor descriptor, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.ComponentModel.PropertyDescriptor,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSerializerFor (descriptor As PropertyDescriptor, context As IValueSerializerContext) As ValueSerializer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Markup::ValueSerializer ^ GetSerializerFor(System::ComponentModel::PropertyDescriptor ^ descriptor, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="static member GetSerializerFor : System.ComponentModel.PropertyDescriptor * System.Windows.Markup.IValueSerializerContext -&gt; System.Windows.Markup.ValueSerializer" Usage="System.Windows.Markup.ValueSerializer.GetSerializerFor (descriptor, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.ValueSerializer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descriptor" Type="System.ComponentModel.PropertyDescriptor" Index="0" FrameworkAlternate="netframework-4.8" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" Index="1" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="descriptor">Дескриптор сериализуемого свойства.</param>
        <param name="context">Контекстная информация, используемая при выполнении преобразования.</param>
        <summary>Получает <see cref="T:System.Windows.Markup.ValueSerializer" />, объявленный для заданного свойства с использованием заданного контекста.</summary>
        <returns>Сериализатор, связанный с заданным свойством.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вместо того чтобы полагаться исключительно на атрибуты, переданные в системе типов CLR, эта `context` перегрузка использует в качестве службы и вызывает <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType>реализацию службы. Реализация обычно также полагается `descriptor`на, но может реализовать специальное поведение для определенных контекстов. <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType>  
  
 Этот метод должен вызываться, когда вызывающий объект имеет <xref:System.Windows.Markup.IValueSerializerContext> доступ из службы.  Это обеспечит правильность <xref:System.Windows.Markup.ValueSerializer> возврата для конкретного контекста.  
  
 Если `null` контекст возвращается `descriptor` <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType> в соответствии с указанным параметром или если контекст `null`указан, то поведение идентично вызову <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%28System.ComponentModel.PropertyDescriptor%29> перегрузки.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="descriptor" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSerializerFor">
      <MemberSignature Language="C#" Value="public static System.Windows.Markup.ValueSerializer GetSerializerFor (Type type, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Markup.ValueSerializer GetSerializerFor(class System.Type type, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.Type,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Markup::ValueSerializer ^ GetSerializerFor(Type ^ type, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="static member GetSerializerFor : Type * System.Windows.Markup.IValueSerializerContext -&gt; System.Windows.Markup.ValueSerializer" Usage="System.Windows.Markup.ValueSerializer.GetSerializerFor (type, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.ValueSerializer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netframework-4.8" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" Index="1" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="type">Тип, для которого требуется получить <see cref="T:System.Windows.Markup.ValueSerializer" />.</param>
        <param name="context">Контекстная информация, используемая при выполнении преобразования.</param>
        <summary>Получает <see cref="T:System.Windows.Markup.ValueSerializer" />, объявленный для заданного типа с использованием заданного контекста.</summary>
        <returns>Сериализатор, связанный с заданным типом.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вместо того чтобы полагаться исключительно на атрибуты, переданные в системе типов CLR, эта `context` перегрузка использует в качестве службы и вызывает <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType>реализацию службы. Реализация обычно также полагается `type`на, но может реализовать специальное поведение для определенных контекстов. <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType>  
  
 Этот метод должен вызываться, когда вызывающий объект имеет <xref:System.Windows.Markup.IValueSerializerContext> доступ из службы. Это обеспечит правильность <xref:System.Windows.Markup.ValueSerializer> возврата для конкретного контекста.  
  
 Если `null` контекст возвращается `type` <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType> в соответствии с указанным параметром или если контекст `null`указан, то поведение идентично вызову <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%28System.Type%29> перегрузки.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="type" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeReferences">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Type&gt; TypeReferences (object value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; TypeReferences(object value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.TypeReferences(System.Object,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TypeReferences (value As Object, context As IValueSerializerContext) As IEnumerable(Of Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ TypeReferences(System::Object ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member TypeReferences : obj * System.Windows.Markup.IValueSerializerContext -&gt; seq&lt;Type&gt;&#xA;override this.TypeReferences : obj * System.Windows.Markup.IValueSerializerContext -&gt; seq&lt;Type&gt;" Usage="valueSerializer.TypeReferences (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.8" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" Index="1" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="value">Сериализуемое значение.</param>
        <param name="context">Контекстная информация, используемая при выполнении преобразования.</param>
        <summary>Получает перечисление типов, на которые ссылается <see cref="T:System.Windows.Markup.ValueSerializer" />.</summary>
        <returns>Типы, преобразуемые данным сериализатором.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Все типы, <xref:System.Windows.Markup.ValueSerializer> преобразованные в, должны включаться в возвращаемое перечисление.  Это позволяет сериализатору убедиться, что у десериализатора достаточно сведений о типах, которые преобразует этот сериализатор.  
  
 Переопределение этого метода является расширенным сценарием. Переопределение необходимо только в том случае, если вы реализуете систему, в которой связи свойств системы типов CLR, доступные для контекста схемы XAML, не сообщают о достаточной информации.  
  
## <a name="wpf-usage-notes"></a>Примечания об использовании WPF  
 Система свойств реализует сериализатор внутренних значений, переопределяющий <xref:System.Windows.Markup.ValueSerializer.TypeReferences%2A> , так как свойство зависимостей имеет концепцию, которая может добавлять владельцев. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]выражения также имеют специальную внутреннюю обработку.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>