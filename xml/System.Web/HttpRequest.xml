<Type Name="HttpRequest" FullName="System.Web.HttpRequest">
  <Metadata><Meta Name="ms.openlocfilehash" Value="79d762b094635d901ba4a46af071aeadad824302" /><Meta Name="ms.sourcegitcommit" Value="10aa513a7461eb2abbf8d1e35d2a045d4e5a9be7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="07/09/2019" /><Meta Name="ms.locfileid" Value="67664483" /></Metadata><TypeSignature Language="C#" Value="public sealed class HttpRequest" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpRequest extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpRequest" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpRequest" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpRequest sealed" />
  <TypeSignature Language="F#" Value="type HttpRequest = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Разрешает ASP.NET считывать HTTP-значения, отправленные клиентом во время веб-запроса.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Методы и свойства <xref:System.Web.HttpRequest> предоставляются через `Request` свойства <xref:System.Web.HttpApplication>, <xref:System.Web.HttpContext>, <xref:System.Web.UI.Page>, и <xref:System.Web.UI.UserControl> классы.  
  
 Для доступа к данным из <xref:System.Web.HttpRequest.QueryString%2A>, <xref:System.Web.HttpRequest.Form%2A>, <xref:System.Web.HttpRequest.Cookies%2A>, или <xref:System.Web.HttpRequest.ServerVariables%2A> коллекций, можно написать `Request["key"]`, как показано в примере для <xref:System.Web.HttpRequest.QueryString%2A> свойство.  
  
> [!NOTE]
>  Поддержка Юникода <xref:System.Web.HttpRequest> члены класса требуются службы IIS версии 6.0 или более поздней версии.  
  
   
  
## Examples  
 Следующие примеры доступа <xref:System.Web.HttpRequest> экземпляра для текущего запроса с помощью <xref:System.Web.UI.Page.Request%2A> свойство <xref:System.Web.UI.Page> класса.  
  
 Можно использовать упрощенный синтаксис для доступа к данным из <xref:System.Web.HttpRequest.QueryString%2A>, <xref:System.Web.HttpRequest.Form%2A>, <xref:System.Web.HttpRequest.Cookies%2A>, или <xref:System.Web.HttpRequest.ServerVariables%2A> коллекций. Можно написать `Request["key"]`.  
  
 Первый пример показывает способ получения значения строки запроса, при загрузке страницы.  
  
```csharp  
public partial class AddToCart : Page  
{  
    protected void Page_Load(object sender, EventArgs e)  
    {  
        string rawId = Request["ProductID"];  
        int productId;  
        if (!String.IsNullOrEmpty(rawId) && int.TryParse(rawId, out productId))  
        {  
            using (ShoppingCartActions usersShoppingCart = new ShoppingCartActions())  
            {  
                usersShoppingCart.AddToCart(productId);  
            }  
        }  
        else  
        {  
            throw new Exception("Tried to call AddToCart.aspx without setting a ProductId.");  
        }  
        Response.Redirect("ShoppingCart.aspx");  
    }  
}  
```  
  
```vb  
Public Class AddToCart  
    Inherits Page  
  
    Protected Sub Page_Load(ByVal sender As Object, ByVal e As EventArgs) Handles Me.Load  
        Dim rawId = Request("ProductID")  
        Dim productId As Integer  
        If Not String.IsNullOrEmpty(rawId) And Integer.TryParse(rawId, productId) Then  
            Using usersShoppingCart As New ShoppingCartActions()  
                usersShoppingCart.AddToCart(productId)  
            End Using  
  
        Else  
            Throw New Exception("Tried to call AddToCart.aspx without setting a ProductId.")  
        End If  
        Response.Redirect("ShoppingCart.aspx")  
    End Sub  
End Class  
```  
  
 Далее примере показано, как проверить, если запрос проходит аутентификацию и получить исходный URL-адрес.  
  
```csharp  
public partial class RestrictedPage : Page  
{  
    protected void Page_Load(object sender, EventArgs e)  
    {  
        if (!Request.IsAuthenticated)  
        {  
            var rawUrl = Request.RawUrl;  
            Response.Redirect("/Account/Login?ru=" + Server.HtmlEncode(rawUrl));  
        }  
    }  
}  
```  
  
```vb  
Public Class RestrictedPage  
    Inherits Page  
  
    Protected Sub Page_Load(ByVal sender As Object, ByVal e As EventArgs) Handles Me.Load  
        If Not Request.IsAuthenticated Then  
            Dim rawUrl = Request.RawUrl  
            Response.Redirect("/Account/Login?ru=" + Server.HtmlEncode(rawUrl))  
        End If  
    End Sub  
End Class  
```  
  
 Проект Visual Studio Web сайта с исходным кодом доступен на следующей странице в этом разделе: [Скачайте](https://go.microsoft.com/fwlink/?LinkID=191455).  
  
 В этом примере используется <xref:System.IO.StreamWriter> класс для записи значения нескольких <xref:System.Web.HttpRequest> свойств в файл класса. Для свойств, которые являются типом string значения, так как они записаны в файл в кодировке HTML. Зацикливаются свойства, которые представляют собой наборы, и каждая пара ключ/значение, содержащимися в них записываются в файл.  
  
> [!IMPORTANT]
>  В этом примере имеется текстовое поле, принимающее вводимые пользователем данные, что является потенциальной угрозой безопасности. По умолчанию данные, вводимые пользователем на веб-страницах ASP.NET, проверяются на наличие скриптов и HTML-элементов. Дополнительные сведения см. в разделе [Общие сведения об использовании сценариев](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.HttpRequest_Sample1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_Sample1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpRequest (string filename, string url, string queryString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string filename, string url, string queryString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.#ctor(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (filename As String, url As String, queryString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpRequest(System::String ^ filename, System::String ^ url, System::String ^ queryString);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpRequest : string * string * string -&gt; System.Web.HttpRequest" Usage="new System.Web.HttpRequest (filename, url, queryString)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="queryString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Имя файла, связанного с запросом.</param>
        <param name="url">Сведения о URL-адресе текущего запроса.</param>
        <param name="queryString">Вся строка запроса, отправленная с запросом (все, что после <c>'?'</c>).</param>
        <summary>Инициализирует объект <see cref="T:System.Web.HttpRequest" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Необходимо создать собственный экземпляр <xref:System.Web.HttpRequest> класса. Методы и свойства <xref:System.Web.HttpRequest> предоставляются через `Request` свойство <xref:System.Web.HttpApplication>, <xref:System.Web.HttpContext>, <xref:System.Web.UI.Page>, и <xref:System.Web.UI.UserControl> классы.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="httpRequest.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Принудительно завершает основное подключение TCP, из-за чего любой ВВОД-ВЫВОД дает сбой. Этот метод можно использовать в ответ на атаку со стороны вредоносного HTTP-клиента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод является поточно ориентированной. Любой поток может вызвать в любое время.  
  
 Этот метод может использоваться только в режиме интеграции с. Если ее можно вызвать в классическом режиме, создается исключение. Чтобы определить режим конвейера, используйте <xref:System.Web.HttpRuntime.UsingIntegratedPipeline%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptTypes">
      <MemberSignature Language="C#" Value="public string[] AcceptTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] AcceptTypes" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.AcceptTypes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AcceptTypes As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ AcceptTypes { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AcceptTypes : string[]" Usage="System.Web.HttpRequest.AcceptTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает строковый массив типов приема MIME, поддерживаемых клиентом.</summary>
        <value>Строковый массив типов, поддерживаемых клиентами и использующих MIME.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода захватывает несколько значений, возвращенных <xref:System.Web.HttpRequest.AcceptTypes%2A> свойство в объектной переменной и записывает номер и имя каждого значения в отдельную строку вывода НТТР.  
  
 [!code-csharp[Classic HttpRequest.AcceptTypes Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.AcceptTypes Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.AcceptTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.AcceptTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AnonymousID">
      <MemberSignature Language="C#" Value="public string AnonymousID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AnonymousID" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.AnonymousID" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AnonymousID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AnonymousID { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AnonymousID : string" Usage="System.Web.HttpRequest.AnonymousID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает анонимный идентификатор для пользователя, если представлен.</summary>
        <value>Строка представляет идентификатор текущего анонимного пользователя.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest.AnonymousID%2A> Свойство назначает долгоживущий уникальный идентификатор для пользователя без проверки подлинности, который может использоваться для отслеживания пользователя или назначить свойства профиля этого пользователя без сохранения данных в `Session` объекта. По умолчанию <xref:System.Web.HttpRequest.AnonymousID%2A> свойство отслеживается с помощью файла cookie, но его можно установить равным использовать URI при <xref:System.Web.Configuration.SessionStateSection.Cookieless%2A> атрибут в разделе конфигурации анонимная идентификация может принимать значение <xref:System.Web.HttpCookieMode.UseUri>, <xref:System.Web.HttpCookieMode.UseDeviceProfile>, или <xref:System.Web.HttpCookieMode.AutoDetect> значение. Куки-файл необходимо очистить явным образом в том случае, если больше не требуется доступные, например когда анонимный пользователь проходит проверку подлинности.  
  
 Анонимная идентификация используется, когда требуется для идентификации сущности, которые не проходят проверку подлинности, и когда требуется авторизация. Дополнительные сведения см. в разделе [anonymousIdentification элемент (схема параметров ASP.NET)](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/91ka2e6a(v=vs.100))  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Web.HttpRequest.AnonymousID%2A> свойства путем обработки <xref:System.Web.Security.AnonymousIdentificationModule.Creating> событий в файле Global.asax. В этом примере состоит из двух частей:  
  
-   Метод в файле Global.asax, который обрабатывает <xref:System.Web.Security.AnonymousIdentificationModule.Creating> событий.  
  
-   Страница веб-форм.  
  
 Первая часть в примере кода показано задание <xref:System.Web.HttpRequest.AnonymousID%2A> свойства путем обработки <xref:System.Web.Security.AnonymousIdentificationModule.Creating> событий в файле Global.asax. Метод, который называется `AnonymousIdentification_Creating` задает <xref:System.Web.HttpRequest.AnonymousID%2A> свойства при создании анонимного идентификатора.  
  
 [!code-csharp[System.Web.HttpRequest_AnonymousID#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_AnonymousID/CS/global_asax.cs#2)]
 [!code-vb[System.Web.HttpRequest_AnonymousID#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_AnonymousID/vb/global_asax.vb#2)]  
  
 Вторая часть в примере кода показано, как для отображения новых <xref:System.Web.HttpRequest.AnonymousID%2A> , созданный путем `AnonymousIdentification_Creating` обработчик событий в предыдущем примере.  
  
 [!code-aspx-csharp[System.Web.HttpRequest_AnonymousID#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_AnonymousID/CS/anonid_cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_AnonymousID#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_AnonymousID/vb/anonid_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.IsAuthenticated" />
        <altmember cref="E:System.Web.Security.AnonymousIdentificationModule.Creating" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/91ka2e6a(v=vs.100)">Элемент anonymousIdentification (схема параметров ASP.NET)</related>
      </Docs>
    </Member>
    <Member MemberName="ApplicationPath">
      <MemberSignature Language="C#" Value="public string ApplicationPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationPath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ApplicationPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationPath : string" Usage="System.Web.HttpRequest.ApplicationPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает виртуальный путь к корневому каталогу приложения ASP.NET на сервере.</summary>
        <value>Виртуальный путь текущего приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство используется для формирования URL-адреса, относительно корня приложения со страницы или веб-элемента управления пользователя, который не находится в корневом каталоге. Благодаря этому страницы и общие элементы управления, которые существуют на разных уровнях структуры каталогов, чтобы использовать тот же код для связи с ресурсами с фиксированными расположениями в приложении.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.IO.StreamWriter.Write%2A> метод для HTML-кодирования и затем записать значение <xref:System.Web.HttpRequest.ApplicationPath%2A> свойство в текстовый файл. Данный пример кода является частью большего примера для <xref:System.Web.HttpRequest> класса. Предполагается наличие <xref:System.IO.StreamWriter> объект с именем `sw`.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#2)]
 [!code-vb[System.Web.HttpRequest_Sample1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#2)]  
  
 В следующем примере используется <xref:System.Web.HttpRequest.ApplicationPath%2A> свойства программно составить путь к ресурсу, который находится в фиксированное расположение в приложении. Страница, на который ссылается на ресурс нет необходимости находиться в том же каталоге, что и ресурс.  
  
 [!code-aspx-csharp[System.Web.HttpRequest.ApplicationPath#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.ApplicationPath/CS/ApplicationPath.aspx#2)]
 [!code-aspx-vb[System.Web.HttpRequest.ApplicationPath#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.ApplicationPath/VB/ApplicationPath.aspx#2)]  
  
 При выполнении этого примера веб-приложения с именем WebSite1, `/WebSite1` будет отображаться как значение <xref:System.Web.HttpRequest.ApplicationPath%2A> свойство и `/WebSite1/images/Image1.gif` будет отображаться как полный путь к изображению.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppRelativeCurrentExecutionFilePath">
      <MemberSignature Language="C#" Value="public string AppRelativeCurrentExecutionFilePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppRelativeCurrentExecutionFilePath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AppRelativeCurrentExecutionFilePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppRelativeCurrentExecutionFilePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AppRelativeCurrentExecutionFilePath : string" Usage="System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает виртуальный путь корня приложения и делает его относительным, используя тильду (\~) для корня приложения (как в "\~/page.aspx").</summary>
        <value>Виртуальный путь корня приложения для текущего запроса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Оно используется для предоставления данных URL-адрес, будет оставаться одинаковым, даже если приложение не меняет расположение. Это позволяет один и тот же код сопоставления URL-адрес для использования в тестовой среде и в конечной среде развертывания, или для использования копии веб-приложений в разных доменах.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath%2A> свойство, чтобы задать URL-адрес <xref:System.Web.UI.WebControls.Image> элемента управления к изображению в том же каталоге, что и страница. Открыть эту страницу на разных уровнях структуры каталогов, чтобы увидеть полученный в результате <xref:System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath%2A> значения свойств.  
  
 [!code-aspx-csharp[System.Web.HttpRequest.AppRelativeCurrentExecutionPath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.AppRelativeCurrentExecutionPath/CS/AppRelativeCurrentExecutionPathCS.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest.AppRelativeCurrentExecutionPath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.AppRelativeCurrentExecutionPath/VB/AppRelativeCurrentExecutionPathVB.aspx#1)]  
  
 В следующем примере используется <xref:System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath%2A> свойство программно задать путь к ресурсу, исходя из текущего пути страницы.  
  
 [!code-aspx-csharp[System.Web.HttpRequest.ApplicationPath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.ApplicationPath/CS/apprelativecurrentexecutionfilepath.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest.ApplicationPath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.ApplicationPath/VB/apprelativecurrentexecutionfilepath.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BinaryRead">
      <MemberSignature Language="C#" Value="public byte[] BinaryRead (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] BinaryRead(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.BinaryRead(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function BinaryRead (count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ BinaryRead(int count);" />
      <MemberSignature Language="F#" Value="member this.BinaryRead : int -&gt; byte[]" Usage="httpRequest.BinaryRead count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">Количество байтов, чтение которых необходимо выполнить.</param>
        <summary>Выполняет чтение двоичного кода заданного числа байтов, содержащихся в текущем потоке входящих данных.</summary>
        <returns>Массив байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest.BinaryRead%2A> Метод предоставляется для совместимости с ASP.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> имеет значение 0.  
  
-или- 
 <paramref name="count" /> больше, чем доступное число байтов.</exception>
      </Docs>
    </Member>
    <Member MemberName="Browser">
      <MemberSignature Language="C#" Value="public System.Web.HttpBrowserCapabilities Browser { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpBrowserCapabilities Browser" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Browser" />
      <MemberSignature Language="VB.NET" Value="Public Property Browser As HttpBrowserCapabilities" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpBrowserCapabilities ^ Browser { System::Web::HttpBrowserCapabilities ^ get(); void set(System::Web::HttpBrowserCapabilities ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Browser : System.Web.HttpBrowserCapabilities with get, set" Usage="System.Web.HttpRequest.Browser" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpBrowserCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает сведения о возможностях запрашивающего браузера на клиентской стороне.</summary>
        <value>Объект <see cref="T:System.Web.HttpBrowserCapabilities" />, содержащий список возможностей клиентского браузера.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода отправляет список возможностей браузера обратно клиенту в HTML-страницы.  
  
 [!code-csharp[Classic HttpRequest.Browser Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Browser Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Browser Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Browser Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.ClientTarget" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="P:System.Web.HttpRequest.UserAgent" />
        <related type="Article" href="https://msdn.microsoft.com/library/143d14d6-9d12-4d4b-ae60-f00e0eb6938f">Серверные элементы управления ASP.NET и возможностей браузера</related>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificate">
      <MemberSignature Language="C#" Value="public System.Web.HttpClientCertificate ClientCertificate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpClientCertificate ClientCertificate" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ClientCertificate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientCertificate As HttpClientCertificate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpClientCertificate ^ ClientCertificate { System::Web::HttpClientCertificate ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientCertificate : System.Web.HttpClientCertificate" Usage="System.Web.HttpRequest.ClientCertificate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpClientCertificate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает сертификат безопасности клиента, отправившего текущий запрос.</summary>
        <value>Объект <see cref="T:System.Web.HttpClientCertificate" />, содержащий сведения о параметрах сертификата безопасности клиента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода параметры сертификата клиента отправляются обратно клиенту в HTML-страницы.  
  
 [!code-csharp[Classic HttpRequest.ClientCertificate Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ClientCertificate Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ClientCertificate Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ClientCertificate Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding ContentEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding ContentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ContentEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ ContentEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentEncoding : System.Text.Encoding with get, set" Usage="System.Web.HttpRequest.ContentEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает набор знаков объекта.</summary>
        <value>Объект <see cref="T:System.Text.Encoding" />, представляющий набор знаков клиента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Кодировка содержимого по умолчанию можно указать в [глобализации элемент (схема параметров ASP.NET)](https://msdn.microsoft.com/library/e2dffc8e-ebd2-439b-a2fd-e3ac5e620da7) файла конфигурации. Если кодировка содержимого задается на клиент, переопределяются параметры конфигурации по умолчанию.  
  
   
  
## Examples  
 В следующем примере кода присваивается значение, представляющее описание текущей кодировки HTTP строковой переменной.  
  
 [!code-csharp[Classic HttpRequest.ContentEncoding Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ContentEncoding Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ContentEncoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ContentEncoding Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentLength">
      <MemberSignature Language="C#" Value="public int ContentLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ContentLength" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ContentLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ContentLength { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentLength : int" Usage="System.Web.HttpRequest.ContentLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает длину отправленного клиентом содержимого в байтах.</summary>
        <value>Длина отправленного клиентом содержимого в байтах.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода присваивается значение, представляющее длину содержимого входящего запроса к целочисленной переменной.  
  
 [!code-csharp[Classic HttpRequest.ContentLength Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ContentLength Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ContentLength Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ContentLength Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string with get, set" Usage="System.Web.HttpRequest.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает тип MIME содержимого входящего запроса.</summary>
        <value>Строка, представляющая тип MIME содержимого входящего запроса, например "text/html". Дополнительные типы MIME включают "audio.wav", "image/gif" и "application/pdf".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода присваивается значение, представляющее тип содержимого входящего запроса в переменную строки.  
  
 [!code-csharp[Classic HttpRequest.ContentType Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ContentType Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ContentType Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ContentType Example/VB/source.vb#1)]  
  
 Пример выходных данных, могут быть созданы на этот код.  
  
 `GET`  
  
 `127.0.0.1`  
  
 `127.0.0.1`  
  
 `GET`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cookies">
      <MemberSignature Language="C#" Value="public System.Web.HttpCookieCollection Cookies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCookieCollection Cookies" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Cookies" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cookies As HttpCookieCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpCookieCollection ^ Cookies { System::Web::HttpCookieCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cookies : System.Web.HttpCookieCollection" Usage="System.Web.HttpRequest.Cookies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCookieCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает коллекцию файлов Cookie, отправленных клиентом.</summary>
        <value>Объект <see cref="T:System.Web.HttpCookieCollection" />, представляющий переменные cookie клиента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET включает два встроенных файлов cookie. Коллекции осуществляется через <xref:System.Web.HttpRequest.Cookies%2A> коллекцию <xref:System.Web.HttpRequest> содержит файлы cookie, переданные клиентом на сервер в `Cookie` заголовка. Коллекции осуществляется через <xref:System.Web.HttpResponse.Cookies%2A> коллекцию <xref:System.Web.HttpResponse> содержит новых куки-файлов создана на сервере и передаются клиенту в `Set-Cookie` заголовка.  
  
> [!NOTE]
>  После добавления файла cookie с помощью <xref:System.Web.HttpResponse.Cookies%2A?displayProperty=nameWithType> коллекции, куки-файл доступен сразу же в <xref:System.Web.HttpRequest.Cookies%2A?displayProperty=nameWithType> коллекции, даже если ответ не был отправлен клиенту.  
  
   
  
## Examples  
 В следующем примере кода перебирает все файлы cookie, отправленные клиентом и отправляет имя, дату окончания срока действия, параметр безопасности и значения каждого файла cookie в выходные данные НТТР.  
  
 [!code-csharp[Classic HttpRequest.Cookies Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Cookies Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Cookies Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Cookies Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpRequest.ValidateInput" />
        <altmember cref="P:System.Web.HttpRequest.Form" />
        <altmember cref="P:System.Web.HttpRequest.QueryString" />
      </Docs>
    </Member>
    <Member MemberName="CurrentExecutionFilePath">
      <MemberSignature Language="C#" Value="public string CurrentExecutionFilePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CurrentExecutionFilePath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.CurrentExecutionFilePath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentExecutionFilePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CurrentExecutionFilePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentExecutionFilePath : string" Usage="System.Web.HttpRequest.CurrentExecutionFilePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает виртуальный путь текущего запроса.</summary>
        <value>Виртуальный путь текущего запроса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest.CurrentExecutionFilePath%2A> Возвращает путь к файлу на настоящий момент обработчик страницы. Для сценариев перенаправления, с использованием <xref:System.Web.HttpServerUtility.Execute%2A> и <xref:System.Web.HttpServerUtility.Transfer%2A> методы, это означает, что <xref:System.Web.HttpRequest.CurrentExecutionFilePath%2A> свойство возвращает путь к странице, перенаправляется (дочернюю страницу). Тем не менее, когда клиент перенаправляется на другую страницу <xref:System.Web.HttpRequest.FilePath%2A> свойство возвращает путь к исходной странице.  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Web.HttpUtility.HtmlEncode%2A> метод для HTML-кодирование значение <xref:System.Web.HttpRequest.CurrentExecutionFilePath%2A> свойство и <xref:System.IO.TextWriter.WriteLine%2A> метод для записи в файл закодированное значение. Данный пример кода является частью большего примера для <xref:System.Web.HttpRequest> класса.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#2)]
 [!code-vb[System.Web.HttpRequest_Sample1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.FilePath" />
        <altmember cref="P:System.Web.HttpRequest.Path" />
        <altmember cref="P:System.Web.HttpRequest.PathInfo" />
        <altmember cref="M:System.Web.HttpServerUtility.Execute(System.String)" />
        <altmember cref="M:System.Web.HttpServerUtility.Transfer(System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentExecutionFilePathExtension">
      <MemberSignature Language="C#" Value="public string CurrentExecutionFilePathExtension { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CurrentExecutionFilePathExtension" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.CurrentExecutionFilePathExtension" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentExecutionFilePathExtension As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CurrentExecutionFilePathExtension { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentExecutionFilePathExtension : string" Usage="System.Web.HttpRequest.CurrentExecutionFilePathExtension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает расширение имени файла, заданного в свойстве <see cref="P:System.Web.HttpRequest.CurrentExecutionFilePath" />.</summary>
        <value>Расширение имени файла, заданного в свойстве <see cref="P:System.Web.HttpRequest.CurrentExecutionFilePath" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FilePath">
      <MemberSignature Language="C#" Value="public string FilePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FilePath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.FilePath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FilePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FilePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FilePath : string" Usage="System.Web.HttpRequest.FilePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает виртуальный путь текущего запроса.</summary>
        <value>Виртуальный путь текущего запроса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest.FilePath%2A> Свойство не включает <xref:System.Web.HttpRequest.PathInfo%2A> трейлер. Например, URL-адрес `http://www.contoso.com/virdir/page.html/tail`, <xref:System.Web.HttpRequest.FilePath%2A> значение — /virdir/page.html.  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Web.HttpUtility.HtmlEncode%2A> метод для HTML-кодирование значение <xref:System.Web.HttpRequest.FilePath%2A> свойство и <xref:System.IO.TextWriter.WriteLine%2A> метод для записи в файл закодированное значение. Данный пример кода является частью большего примера для <xref:System.Web.HttpRequest> класса.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#2)]
 [!code-vb[System.Web.HttpRequest_Sample1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.PathInfo" />
        <altmember cref="P:System.Web.HttpRequest.Path" />
      </Docs>
    </Member>
    <Member MemberName="Files">
      <MemberSignature Language="C#" Value="public System.Web.HttpFileCollection Files { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpFileCollection Files" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Files" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Files As HttpFileCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpFileCollection ^ Files { System::Web::HttpFileCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Files : System.Web.HttpFileCollection" Usage="System.Web.HttpRequest.Files" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpFileCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает коллекцию загруженных с клиента файлов (составной формат MIME).</summary>
        <value>Объект <see cref="T:System.Web.HttpFileCollection" />, представляющий коллекцию файлов, загруженных с клиента. Элементы объекта <see cref="T:System.Web.HttpFileCollection" /> типа <see cref="T:System.Web.HttpPostedFile" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сбор файлов заполняется только при HTTP-запрос `Content-Type` значение — «multipart/form-data».  
  
   
  
## Examples  
 В следующем примере кода отображает имена всех файлов в <xref:System.Web.HttpRequest.Files%2A> коллекции.  
  
 [!code-csharp[Classic HttpRequest.Files Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Files Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Files Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Files Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public System.IO.Stream Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream Filter" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ Filter { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Filter : System.IO.Stream with get, set" Usage="System.Web.HttpRequest.Filter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает фильтр, используемый при считывании текущего потока входных данных.</summary>
        <value>Объект <see cref="T:System.IO.Stream" />, используемый в качестве фильтра.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода создается два новых класса, `QQQ1` и `QQQ2` этот фильтр <xref:System.Web.HttpRequest.InputStream%2A>. Поместите эти классы в файле Global.asax в каталоге приложения ASP.NET, таким образом, чтобы все входные данные для всех веб-страниц ASP.NET в приложении будут фильтроваться.  
  
 [!code-aspx-csharp[System.Web.HttpRequest.Filter#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.Filter/CS/systemwebhttprequestfilter.cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest.Filter#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.Filter/VB/systemwebhttprequestfilter.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Указан недопустимый <see cref="T:System.IO.Stream" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Form">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Form { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Form" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Form" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Form As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Form { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Form : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpRequest.Form" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает коллекцию переменных формы.</summary>
        <value><see cref="T:System.Collections.Specialized.NameValueCollection" /> представляющий коллекцию переменных формы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest.Form%2A> Свойство заполняется при HTTP-запрос `Content-Type` значение — «application/x-www-формы-urlencoded» или «multipart/form-data».  
  
   
  
## Examples  
 В следующем примере показано, как считывать значения в коллекции формы, отправленные из браузера. Каждая пара "имя значение" в коллекции представляет элемент управления в форме и его значение.  
  
 [!code-csharp[Classic HttpRequest.Form Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Form Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Form Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Form Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpRequest.ValidateInput" />
        <altmember cref="P:System.Web.HttpRequest.Cookies" />
        <altmember cref="P:System.Web.HttpRequest.QueryString" />
      </Docs>
    </Member>
    <Member MemberName="GetBufferedInputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetBufferedInputStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetBufferedInputStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.GetBufferedInputStream" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBufferedInputStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetBufferedInputStream();" />
      <MemberSignature Language="F#" Value="member this.GetBufferedInputStream : unit -&gt; System.IO.Stream" Usage="httpRequest.GetBufferedInputStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает объект <see cref="T:System.IO.Stream" />, который можно использовать для чтения тела входящего объекта HTTP.</summary>
        <returns>Объект <see cref="T:System.IO.Stream" />, который можно использовать для чтения тела входящего объекта HTTP.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод идентичен методу <xref:System.Web.HttpRequest.GetBufferlessInputStream%2A> за исключением того, что он также копирует байты, которые считываются внутреннего хранилища, используемого ASP.NET для заполнения <xref:System.Web.HttpRequest.Form%2A>, <xref:System.Web.HttpRequest.Files%2A>, и <xref:System.Web.HttpRequest.InputStream%2A> свойства. Поскольку эти сведения хранятся, нижеследующий код, такой как страницы веб-форм ASP.NET (aspx-файлы), запускается успешно. С методом <xref:System.Web.HttpRequest.GetBufferlessInputStream%2A> это не так.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Тело сущности запроса уже загружено и проанализировано. Примеры свойств, которые приводят к тому, что тело сущности загружается и синтаксически анализируется: 
– свойство <see cref="P:System.Web.HttpRequest.Form" />;  
  
– свойство <see cref="P:System.Web.HttpRequest.Files" />;  
  
– свойство <see cref="P:System.Web.HttpRequest.InputStream" />;  
  
– метод <see cref="M:System.Web.HttpRequest.GetBufferlessInputStream" />.  
  
Во избежание этого исключения сначала вызовите метод <see cref="P:System.Web.HttpRequest.ReadEntityBodyMode" />. Это исключение также вызывается, если клиент отключается во время чтения тела сущности.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBufferlessInputStream">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает объект <see cref="T:System.IO.Stream" />, который можно использовать для чтения тела входящего объекта HTTP.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBufferlessInputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetBufferlessInputStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetBufferlessInputStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.GetBufferlessInputStream" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBufferlessInputStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetBufferlessInputStream();" />
      <MemberSignature Language="F#" Value="member this.GetBufferlessInputStream : unit -&gt; System.IO.Stream" Usage="httpRequest.GetBufferlessInputStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает объект <see cref="T:System.IO.Stream" />, который можно использовать для чтения тела входящего объекта HTTP.</summary>
        <returns>Объект <see cref="T:System.IO.Stream" />, который можно использовать для чтения тела входящего объекта HTTP.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод обеспечивает является альтернативой использованию <xref:System.Web.HttpRequest.InputStream%2A> свойство. <xref:System.Web.HttpRequest.InputStream%2A> Свойство ожидает, пока не был получен запрос целиком перед возвращением <xref:System.IO.Stream> объекта. Напротив <xref:System.Web.HttpRequest.GetBufferlessInputStream%2A> возвращает метод <xref:System.IO.Stream> объекта немедленно. Можно использовать метод, чтобы начать обработку тела сущности, прежде чем будут получены все содержимое тела.  
  
 Тело сущности (или часть его запросы и был получен) возвращается только в том случае, если вы используете объект возвращаемый этим методом для чтения потока путем вызова методов, таких как <xref:System.IO.Stream.Read%2A> метод. Используйте параметры типа <xref:System.IO.Stream.Read%2A> метод, чтобы задать для чтения тела сущности.  
  
 <xref:System.IO.Stream> Объект, возвращаемый этим методом, ASP.NET поддерживает синхронные и асинхронные методы для чтения. <xref:System.IO.Stream> Объект реализует интерфейс <xref:System.IO.Stream.BeginRead%2A> и <xref:System.IO.Stream.EndRead%2A> методы. Асинхронные методы используются для асинхронного чтения сущности запроса в виде фрагментов, хотя ASP.NET освобождает текущий поток между каждой итерации цикла асинхронного чтения.  
  
 Этот метод может быть полезен, если запрос передает большой файл, и вы хотите начать доступа к содержимому файла до завершения загрузки. Тем не менее вам следует использовать только этот метод для сценариев, где вы хотите контролировать обработку тела сущности. Это означает, что нельзя использовать этот метод из ASPX-странице, поскольку, при запуске страницы ASPX, тело сущности уже было считано.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Тело сущности запроса уже загружено и проанализировано. Примеры свойств, которые приводят к тому, что тело сущности загружается и синтаксически анализируется: 
-   <see cref="P:System.Web.HttpRequest.Form" />  
  
-   <see cref="P:System.Web.HttpRequest.InputStream" />  
  
-   <see cref="P:System.Web.HttpRequest.Files" />  
  
-   <see cref="M:System.Web.HttpRequest.GetBufferedInputStream" />  
  
Во избежание этого исключения сначала вызовите метод <see cref="P:System.Web.HttpRequest.ReadEntityBodyMode" />. Это исключение также вызывается, если клиент отключается во время чтения тела сущности.</exception>
        <altmember cref="M:System.Web.HttpRequest.GetBufferedInputStream" />
      </Docs>
    </Member>
    <Member MemberName="GetBufferlessInputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetBufferlessInputStream (bool disableMaxRequestLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetBufferlessInputStream(bool disableMaxRequestLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.GetBufferlessInputStream(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBufferlessInputStream (disableMaxRequestLength As Boolean) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetBufferlessInputStream(bool disableMaxRequestLength);" />
      <MemberSignature Language="F#" Value="member this.GetBufferlessInputStream : bool -&gt; System.IO.Stream" Usage="httpRequest.GetBufferlessInputStream disableMaxRequestLength" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disableMaxRequestLength" Type="System.Boolean" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="disableMaxRequestLength">Значение <see langword="true" />, чтобы отключить ограничение длины запроса; в противном случае — значение <see langword="false" />.</param>
        <summary>Получает объект <see cref="T:System.IO.Stream" />, который может использоваться для чтения входящего тела сущности HTTP, дополнительно отменяя задаваемое в свойстве <see cref="P:System.Web.Configuration.HttpRuntimeSection.MaxRequestLength" /> ограничение на длину запроса.</summary>
        <returns>Объект <see cref="T:System.IO.Stream" />, который можно использовать для чтения тела входящего объекта HTTP.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения об этом методе см. в разделе <xref:System.Web.HttpRequest.GetBufferlessInputStream> перегрузки.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Тело сущности запроса уже загружено и проанализировано. Примеры свойств, которые приводят к тому, что тело сущности загружается и синтаксически анализируется: 
– свойство <see cref="P:System.Web.HttpRequest.Form" />;  
  
– свойство <see cref="P:System.Web.HttpRequest.Files" />;  
  
– свойство <see cref="P:System.Web.HttpRequest.InputStream" />;  
  
– метод <see cref="M:System.Web.HttpRequest.GetBufferedInputStream" />.  
  
Во избежание этого исключения сначала вызовите метод <see cref="P:System.Web.HttpRequest.ReadEntityBodyMode" />. Это исключение также вызывается, если клиент отключается во время чтения тела сущности.</exception>
        <altmember cref="M:System.Web.HttpRequest.GetBufferedInputStream" />
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Headers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Headers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Headers As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Headers { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Headers : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpRequest.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает коллекцию заголовков НТТР.</summary>
        <value>Коллекция <see cref="T:System.Collections.Specialized.NameValueCollection" /> заголовков.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Список всех возможных заголовки, см. в разделе [полей заголовка запроса](https://go.microsoft.com/fwlink/?LinkId=73147) на веб-узле W3C.  
  
   
  
## Examples  
 В следующем примере кода отображает имена и значения всех заголовков в HTTP-запроса.  
  
 [!code-csharp[Classic HttpRequest.Headers Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Headers Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Headers Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Headers Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HttpChannelBinding">
      <MemberSignature Language="C#" Value="public System.Security.Authentication.ExtendedProtection.ChannelBinding HttpChannelBinding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Authentication.ExtendedProtection.ChannelBinding HttpChannelBinding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.HttpChannelBinding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HttpChannelBinding As ChannelBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Authentication::ExtendedProtection::ChannelBinding ^ HttpChannelBinding { System::Security::Authentication::ExtendedProtection::ChannelBinding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HttpChannelBinding : System.Security.Authentication.ExtendedProtection.ChannelBinding" Usage="System.Web.HttpRequest.HttpChannelBinding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.ExtendedProtection.ChannelBinding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> текущего экземпляра <see cref="T:System.Web.HttpWorkerRequest" />.</summary>
        <value>Объект <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> текущего экземпляра <see cref="T:System.Web.HttpWorkerRequest" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Текущий объект <see cref="T:System.Web.HttpWorkerRequest" /> не является объектом класса <see langword="System.Web.Hosting.IIS7WorkerRequest" /> или <see langword="System.Web.Hosting.ISAPIWorkerRequestInProc" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="HttpMethod">
      <MemberSignature Language="C#" Value="public string HttpMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HttpMethod" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.HttpMethod" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HttpMethod As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ HttpMethod { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HttpMethod : string" Usage="System.Web.HttpRequest.HttpMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает метод передачи данных НТТР (например, <see langword="GET" />, <see langword="POST" /> или <see langword="HEAD" />), используемый клиентом.</summary>
        <value>Метод передачи данных HTTP, используемый клиентом.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода используется <xref:System.Web.HttpUtility.HtmlEncode%2A> метод для HTML-кодирование значение <xref:System.Web.HttpRequest.HttpMethod%2A> свойство и <xref:System.IO.TextWriter.WriteLine%2A> метод для записи в файл закодированное значение. Данный пример кода является частью большего примера для <xref:System.Web.HttpRequest> класса.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#7)]
 [!code-vb[System.Web.HttpRequest_Sample1#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#7)]  
  
 Пример выходных данных, созданным этот код.  
  
 `GET`  
  
 `127.0.0.1`  
  
 `127.0.0.1`  
  
 `GET`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream InputStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream InputStream" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.InputStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InputStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ InputStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InputStream : System.IO.Stream" Usage="System.Web.HttpRequest.InputStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает содержимое входящего объекта НТТР.</summary>
        <value>Объект <see cref="T:System.IO.Stream" />, представляющий входящее содержимое НТТР.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода копируется <xref:System.Web.HttpRequest.InputStream%2A> в строку.  
  
 [!code-csharp[Classic HttpRequest.InputStream Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.InputStream Example/cs/source.aspx#1)]
 [!code-vb[Classic HttpRequest.InputStream Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.InputStream Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="InsertEntityBody">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Предоставляет управляемую оболочку для метода IIS, которая помещает тело HTTP-запроса в память.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest.InsertEntityBody%2A> Перегрузок метода предоставления управляемого доступа к IIS 7 `IHttpRequest::InsertEntityBody` метод. Метод IIS помещает тело сущности запроса HTTP (данных, которая отправлена клиентом) в память. Это полезно, поскольку IIS не сохраняет копию сущности запроса после его считывания. <xref:System.Web.HttpRequest.InsertEntityBody%2A> Методы создания копии данных объекта запроса HTTP и сделать его доступным в службах IIS для пользовательской обработки.  
  
> [!NOTE]
>  <xref:System.Web.HttpRequest.InsertEntityBody%2A> Перегрузки метода работы только на IIS 7.0 или более поздней версии, так как `IHttpRequest::InsertEntityBody` метод добавлен в IIS 7.0.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="InsertEntityBody">
      <MemberSignature Language="C#" Value="public void InsertEntityBody ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertEntityBody() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.InsertEntityBody" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertEntityBody ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertEntityBody();" />
      <MemberSignature Language="F#" Value="member this.InsertEntityBody : unit -&gt; unit" Usage="httpRequest.InsertEntityBody " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Предоставляет службам IIS копию тела HTTP-запроса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 IIS не сохраняет копию запроса после его считывания. Таким образом рекомендуется, только обработчик HTTP-запрос должен прочитать сущности запроса.  
  
 <xref:System.Web.HttpRequest.InsertEntityBody%2A?displayProperty=nameWithType> Перегрузку метода предоставляет службам IIS копию сущности запроса, если она была ранее считана с ASP.NET. Эта перегрузка метода может использоваться для случаев, когда ASP.NET прочитал запрос сущности, и вы хотите повторно использовать существующие данные запроса.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Метод был вызван для версии IIS более ранней, чем IIS 7.0.</exception>
        <permission cref="T:System.Web.AspNetHostingPermission">для работы в размещенной среде. Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Связанное перечисление: <see cref="F:System.Web.AspNetHostingPermissionLevel.High" /></permission>
      </Docs>
    </Member>
    <Member MemberName="InsertEntityBody">
      <MemberSignature Language="C#" Value="public void InsertEntityBody (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertEntityBody(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.InsertEntityBody(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertEntityBody (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertEntityBody(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.InsertEntityBody : byte[] * int * int -&gt; unit" Usage="httpRequest.InsertEntityBody (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив, который содержит данные запроса.</param>
        <param name="offset">Отсчитываемая от нуля позиция в параметре <paramref name="buffer" />, с которой начинается хранение данных запроса.</param>
        <param name="count">Число байтов, читаемых из массива <paramref name="buffer" />.</param>
        <summary>Предоставляет службам IIS копию тела HTTP-запроса и сведения об объекте запроса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 IIS не сохраняет копию запроса после его считывания. Таким образом рекомендуется, только обработчик HTTP-запрос должен прочитать сущности запроса.  
  
 <xref:System.Web.HttpRequest.InsertEntityBody%2A?displayProperty=nameWithType> Перегрузка метода полезна, если вы хотите выполнять пользовательскую обработку, таких как вставка текста другую сущность в памяти.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Метод был вызван для версии IIS более ранней, чем IIS 7.0.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> или <paramref name="count" /> является отрицательным значением.</exception>
        <exception cref="T:System.ArgumentException">Число элементов в <paramref name="count" /> превышает доступное пространство в <paramref name="buffer" /> при заданном значении <paramref name="offset" />.</exception>
        <permission cref="T:System.Web.AspNetHostingPermission">для работы в размещенной на сервере среде. Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Связанное перечисление: <see cref="F:System.Web.AspNetHostingPermissionLevel.High" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsAuthenticated">
      <MemberSignature Language="C#" Value="public bool IsAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.IsAuthenticated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAuthenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAuthenticated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAuthenticated : bool" Usage="System.Web.HttpRequest.IsAuthenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, позволяющее определить, прошел ли запрос проверку подлинности.</summary>
        <value>Если проверка подлинности для запроса выполнена, значение <see langword="true" />, в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода используется <xref:System.Web.HttpRequest.IsAuthenticated%2A> свойства, чтобы определить, прошел ли текущий запрос. Если он не прошел проверку подлинности, запрос перенаправляется на другую страницу, где пользователи могут ввести свои учетные данные в веб-приложения. Это распространенная методика, используемая в страницу по умолчанию для приложения.  
  
 [!code-csharp[System.Web.HttpRequest_Sample3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample3/CS/isauthenticatedcs.aspx#1)]
 [!code-vb[System.Web.HttpRequest_Sample3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample3/VB/isauthenticatedvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLocal">
      <MemberSignature Language="C#" Value="public bool IsLocal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLocal" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.IsLocal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLocal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLocal { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLocal : bool" Usage="System.Web.HttpRequest.IsLocal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, которое указывает, был ли запрос отправлен с локального компьютера.</summary>
        <value><see langword="true" />, если запрос с локального компьютера; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest.IsLocal%2A> Возвращает `true` Если IP-адрес инициатора запроса 127.0.0.1 или IP-адрес запроса совпадает с IP-адрес сервера.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSecureConnection">
      <MemberSignature Language="C#" Value="public bool IsSecureConnection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecureConnection" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.IsSecureConnection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSecureConnection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSecureConnection { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecureConnection : bool" Usage="System.Web.HttpRequest.IsSecureConnection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, определяющее, используются ли сокеты безопасности (т. е. HTTPS) в соединении HTTP.</summary>
        <value>Значение <see langword="true" />, если соединение является SSL-соединением, в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода определяется ли <xref:System.Web.HttpRequest.IsSecureConnection%2A> свойство имеет значение false. Если это так, <xref:System.Web.HttpResponse.SuppressContent%2A> задано значение true, чтобы остановить отправку ответа.  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsesuppresscontentcs.aspx#3)]
 [!code-vb[System.Web.HttpResponse_Sample5#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsesuppresscontentvb.aspx#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public string this[string key] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(key As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ default[System::String ^] { System::String ^ get(System::String ^ key); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : string" Usage="System.Web.HttpRequest.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Имя извлекаемого члена коллекции.</param>
        <summary>Получает указанный объект из коллекций <see cref="P:System.Web.HttpRequest.QueryString" />, <see cref="P:System.Web.HttpRequest.Form" />, <see cref="P:System.Web.HttpRequest.Cookies" /> или <see cref="P:System.Web.HttpRequest.ServerVariables" />.</summary>
        <value>Член коллекции <see cref="P:System.Web.HttpRequest.QueryString" />, <see cref="P:System.Web.HttpRequest.Form" />, <see cref="P:System.Web.HttpRequest.Cookies" /> или <see cref="P:System.Web.HttpRequest.ServerVariables" />, заданный с помощью параметра <paramref name="key" />. Если определенный <paramref name="key" /> не найден, тогда возвращается <see langword="null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LogonUserIdentity">
      <MemberSignature Language="C#" Value="public System.Security.Principal.WindowsIdentity LogonUserIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.WindowsIdentity LogonUserIdentity" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.LogonUserIdentity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogonUserIdentity As WindowsIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::WindowsIdentity ^ LogonUserIdentity { System::Security::Principal::WindowsIdentity ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogonUserIdentity : System.Security.Principal.WindowsIdentity" Usage="System.Web.HttpRequest.LogonUserIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.WindowsIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает тип <see cref="T:System.Security.Principal.WindowsIdentity" /> для текущего пользователя.</summary>
        <value>Объект <see cref="T:System.Security.Principal.WindowsIdentity" /> для текущих параметров проверки подлинности Microsoft IIS.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest.LogonUserIdentity%2A> Свойство предоставляет свойства и методы <xref:System.Security.Principal.WindowsIdentity> для подключенного пользователя в Microsoft Internet Information Services (IIS). Экземпляр <xref:System.Security.Principal.WindowsIdentity> класс, который предоставляется командлетом <xref:System.Web.HttpRequest.LogonUserIdentity%2A> отслеживает маркер запроса IIS и предоставляет удобный доступ к этот маркер для текущего HTTP-запроса, обрабатываемого в среде ASP.NET. Экземпляр <xref:System.Security.Principal.WindowsIdentity> класс создается автоматически, поэтому его не требуется создавать до Чтобы получить доступ к его методам и свойствам.  
  
   
  
## Examples  
 В следующем примере кода показано, как получить <xref:System.Web.HttpRequest.LogonUserIdentity%2A> свойства для текущего пользователя и запись значений каждого элемента в текстовом файле. Этот код можно поместить на странице ASP.NET, который ссылается формы `ACTION` атрибута.  
  
 [!code-aspx-csharp[System.Web.HttpRequest_LogonUserIdentity#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_LogonUserIdentity/CS/logonuseridentity_cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_LogonUserIdentity#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_LogonUserIdentity/VB/logonuseridentity_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Веб-приложение работает в режиме интеграции с IIS 7, а событие <see cref="E:System.Web.HttpApplication.PostAuthenticateRequest" /> еще не произошло.</exception>
      </Docs>
    </Member>
    <Member MemberName="MapImageCoordinates">
      <MemberSignature Language="C#" Value="public int[] MapImageCoordinates (string imageFieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32[] MapImageCoordinates(string imageFieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.MapImageCoordinates(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapImageCoordinates (imageFieldName As String) As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;int&gt; ^ MapImageCoordinates(System::String ^ imageFieldName);" />
      <MemberSignature Language="F#" Value="member this.MapImageCoordinates : string -&gt; int[]" Usage="httpRequest.MapImageCoordinates imageFieldName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="imageFieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="imageFieldName">Имя сопоставления изображения формы.</param>
        <summary>Сопоставляет параметр входящей формы полей рисунков с соответствующими значениями координат x и y.</summary>
        <returns>Двухмерный массив целочисленных значений.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MapPath">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Сопоставляет виртуальный путь в запрашиваемом URL-адресе с физическим путем на сервере для текущего запроса.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.MapPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPath (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MapPath(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="member this.MapPath : string -&gt; string" Usage="httpRequest.MapPath virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Виртуальный путь (абсолютный или относительный) для текущего запроса.</param>
        <summary>Сопоставляет указанный виртуальный путь с физическим путем.</summary>
        <returns>Физический путь на сервере, заданный параметром <paramref name="virtualPath" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <xref:System.Web.HttpRequest.MapPath%2A> Свойство потенциально содержит важные сведения о среде размещения. Возвращаемое значение не должно отображаться для пользователей.  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Web.HttpRequest.MapPath%2A> способа преобразовать виртуальный путь с полным физическим путем на сервере. В этом примере состоит из двух частей:  
  
-   Страницы ASPX сопоставляет путь, считывает файл и отображает результаты операции считывания.  
  
-   Класс `UpperCaseFilterStream`, который изменяет все символы, передать его в верхний регистр.  
  
 В первой части примера показано, как преобразовать виртуальный путь в полный физический путь с помощью <xref:System.Web.HttpRequest.MapPath%2A> метод. Затем передается этот физический путь <xref:System.IO.StreamReader> объект, который получает содержимое файла. <xref:System.Web.HttpResponse.Write%2A> Затем вызывается метод для отображения содержимого файла на странице. <xref:System.Web.HttpResponse.Filter%2A> Свойство используется для присоединения фильтр в поток ответа, который делает текст, отображаемый на странице все прописные.  
  
 [!code-aspx-csharp[System.Web.HttpRequest_Samples2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/CS/requestsamples2cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_Samples2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/VB/requestsamples2vb.aspx#1)]  
  
 Во второй части примера показан класс, наследуемый от <xref:System.IO.Stream> и преобразует все символы в поток в верхний регистр. Используйте этот код в `App_Code` папку для приложения.  
  
 [!code-csharp[System.Web.HttpRequest_Samples2#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/CS/responsefilter.cs#2)]
 [!code-vb[System.Web.HttpRequest_Samples2#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/VB/responsefilter.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Объект <see cref="T:System.Web.HttpContext" /> для текущего запроса не задан.</exception>
      </Docs>
    </Member>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string virtualPath, string baseVirtualDir, bool allowCrossAppMapping);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string virtualPath, string baseVirtualDir, bool allowCrossAppMapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.MapPath(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPath (virtualPath As String, baseVirtualDir As String, allowCrossAppMapping As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MapPath(System::String ^ virtualPath, System::String ^ baseVirtualDir, bool allowCrossAppMapping);" />
      <MemberSignature Language="F#" Value="member this.MapPath : string * string * bool -&gt; string" Usage="httpRequest.MapPath (virtualPath, baseVirtualDir, allowCrossAppMapping)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="baseVirtualDir" Type="System.String" />
        <Parameter Name="allowCrossAppMapping" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Виртуальный путь (абсолютный или относительный) для текущего запроса.</param>
        <param name="baseVirtualDir">Виртуальный путь к базовому каталогу, используемый для относительного разрешения.</param>
        <param name="allowCrossAppMapping"><see langword="true" /> для указания, что <paramref name="virtualPath" /> может принадлежать другому приложению; в противном случае — <see langword="false" />.</param>
        <summary>Сопоставляет указанный виртуальный путь с физическим путем.</summary>
        <returns>Физический путь на сервере.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <xref:System.Web.HttpRequest.MapPath%2A> Свойство потенциально содержит важные сведения о среде размещения. Возвращаемое значение не должно отображаться для пользователей.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Параметр <paramref name="allowCrossMapping" /> имеет значение <see langword="false" />, а параметр <paramref name="virtualPath" /> относится к другому приложению.

- или - 
Объект <see cref="T:System.Web.HttpContext" /> для текущего запроса не задан.</exception>
      </Docs>
    </Member>
    <Member MemberName="MapRawImageCoordinates">
      <MemberSignature Language="C#" Value="public double[] MapRawImageCoordinates (string imageFieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64[] MapRawImageCoordinates(string imageFieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.MapRawImageCoordinates(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapRawImageCoordinates (imageFieldName As String) As Double()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;double&gt; ^ MapRawImageCoordinates(System::String ^ imageFieldName);" />
      <MemberSignature Language="F#" Value="member this.MapRawImageCoordinates : string -&gt; double[]" Usage="httpRequest.MapRawImageCoordinates imageFieldName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="imageFieldName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="imageFieldName">Имя поля изображения.</param>
        <summary>Сопоставляет параметр входящей формы полей изображений с соответствующими значениями координат X и Y.</summary>
        <returns>Значения координат x и y.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Params">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Params { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Params" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Params" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Params As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Params { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Params : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpRequest.Params" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объединенную коллекцию элементов <see cref="P:System.Web.HttpRequest.QueryString" />, <see cref="P:System.Web.HttpRequest.Form" />, <see cref="P:System.Web.HttpRequest.Cookies" /> и <see cref="P:System.Web.HttpRequest.ServerVariables" />.</summary>
        <value>Объект <see cref="T:System.Collections.Specialized.NameValueCollection" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Пары "имя значение" добавляемый в коллекцию, в следующем порядке:  
  
1.  Параметры строки запроса.  
  
2.  Поля формы.  
  
3.  Файлы cookie.  
  
4.  Переменные сервера.  
  
   
  
## Examples  
 В следующем примере кода показано, как выполнить цикл по <xref:System.Web.HttpRequest.Params%2A> свойство для страницы и способ отображения каждая пара ключ/значение.  
  
 [!code-aspx-csharp[System.Web.HttpRequest.Params#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.Params/CS/requestparamscs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest.Params#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.Params/VB/requestparamsvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Path" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Path : string" Usage="System.Web.HttpRequest.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает виртуальный путь текущего запроса.</summary>
        <value>Виртуальный путь текущего запроса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest.Path%2A> Является объединением <xref:System.Web.HttpRequest.FilePath%2A> и <xref:System.Web.HttpRequest.PathInfo%2A> трейлер. Например, URL-адрес `http://www.contoso.com/virdir/page.html/tail`, <xref:System.Web.HttpRequest.Path%2A> является /virdir/page.html/tail.  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Web.HttpUtility.HtmlEncode%2A> метод для HTML-кодирование значение <xref:System.Web.HttpRequest.Path%2A> свойство и <xref:System.IO.TextWriter.WriteLine%2A> метод для записи в файл закодированное значение. Данный пример кода является частью большего примера для <xref:System.Web.HttpRequest> класса.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#2)]
 [!code-vb[System.Web.HttpRequest_Sample1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.FilePath" />
        <altmember cref="P:System.Web.HttpRequest.PathInfo" />
      </Docs>
    </Member>
    <Member MemberName="PathInfo">
      <MemberSignature Language="C#" Value="public string PathInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PathInfo" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.PathInfo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PathInfo As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PathInfo { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PathInfo : string" Usage="System.Web.HttpRequest.PathInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает дополнительные сведения о пути к ресурсу с расширением URL-адреса.</summary>
        <value>Дополнительные сведения о пути к ресурсу.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 URL-адреса `http://www.contoso.com/virdir/page.html/tail`, <xref:System.Web.HttpRequest.PathInfo%2A> значение будет/tail.  
  
   
  
## Examples  
 В следующем примере кода определяется ли <xref:System.Web.HttpRequest.PathInfo%2A> свойство содержит пустую строку. В этом случае <xref:System.IO.StreamWriter.Write%2A> метод записывает строку, определяющую это в файл. Если это не так, <xref:System.Web.HttpUtility.HtmlEncode%2A> метода HTML кодирует значение <xref:System.Web.HttpRequest.PathInfo%2A> свойство и <xref:System.IO.TextWriter.WriteLine%2A> метод записывает закодированное значение в файл. Данный пример кода является частью большего примера для <xref:System.Web.HttpRequest> класса.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#4)]
 [!code-vb[System.Web.HttpRequest_Sample1#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.Path" />
        <altmember cref="P:System.Web.HttpRequest.FilePath" />
      </Docs>
    </Member>
    <Member MemberName="PhysicalApplicationPath">
      <MemberSignature Language="C#" Value="public string PhysicalApplicationPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PhysicalApplicationPath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.PhysicalApplicationPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PhysicalApplicationPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PhysicalApplicationPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PhysicalApplicationPath : string" Usage="System.Web.HttpRequest.PhysicalApplicationPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает физический путь в файловой системе к корневой папке приложения, выполняющегося в данный момент на сервере.</summary>
        <value>Физический путь в файловой системе к корневому каталогу текущего приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода используется <xref:System.Web.HttpUtility.HtmlEncode%2A> метод для HTML-кодирование значение <xref:System.Web.HttpRequest.PhysicalApplicationPath%2A> свойство и <xref:System.IO.TextWriter.WriteLine%2A> метод для записи в файл закодированное значение. Данный пример кода является частью большего примера для <xref:System.Web.HttpRequest> класса.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#5)]
 [!code-vb[System.Web.HttpRequest_Sample1#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PhysicalPath">
      <MemberSignature Language="C#" Value="public string PhysicalPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PhysicalPath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.PhysicalPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PhysicalPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PhysicalPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PhysicalPath : string" Usage="System.Web.HttpRequest.PhysicalPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает физический путь в файловой системе, соответствующий запрашиваемому URL-адресу.</summary>
        <value>Путь в файловой системе для текущего запроса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В сценарии перенаправления с помощью <xref:System.Web.HttpServerUtility.Execute%2A> и <xref:System.Web.HttpServerUtility.Transfer%2A>, <xref:System.Web.HttpRequest.PhysicalPath%2A> свойство возвращает путь к исходной странице. Чтобы найти физический путь к текущей выполняемой страницы использование <xref:System.Web.HttpRequest.MapPath%2A> метод с помощью входного аргумента в качестве <xref:System.Web.HttpRequest.CurrentExecutionFilePath%2A> свойство.  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Web.HttpUtility.HtmlEncode%2A> метод для HTML-кодирование значение <xref:System.Web.HttpRequest.PhysicalPath%2A> свойство и <xref:System.IO.TextWriter.WriteLine%2A> метод для записи в файл закодированное значение. Данный пример кода является частью большего примера для <xref:System.Web.HttpRequest> класса.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#5)]
 [!code-vb[System.Web.HttpRequest_Sample1#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpRequest.MapPath(System.String)" />
        <altmember cref="P:System.Web.HttpRequest.CurrentExecutionFilePath" />
      </Docs>
    </Member>
    <Member MemberName="QueryString">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection QueryString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection QueryString" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.QueryString" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property QueryString As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ QueryString { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.QueryString : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpRequest.QueryString" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает коллекцию переменных строки запроса HTTP.</summary>
        <value>Переменные строки запроса, отправленные клиентом. Ключи и значения декодируются с помощью URL-адресов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода показаны два способа получить значение переменной строки запроса с именем «fullname». В каждом случае, если URL-адрес `http://www.contoso.com/default.aspx?fullname=Fadi%20Fakhouri`, то возвращаемое значение равно «Фэди Фахури», так как `%20` является URL-адрес декодирована в символ пробела. Если URL-адрес не имеет `fullname` запрос строковый идентификатор, то возвращаемое значение должно быть `null`.  
  
 Первая часть кода ищет ключ «fullname» только в строке запроса; Вторая строка ищет ключ «fullname» во всех коллекцию HTTP-запросов. Дополнительные сведения о строке, см. в разделе <xref:System.Web.HttpRequest.Item%2A>.  
  
```csharp  
string fullname1 = Request.QueryString["fullname"];  
string fullname2 = Request["fullname"];  
  
```  
  
```vb  
Dim fullname1 As String = Request.QueryString("fullname")  
Dim fullname2 As String = Request("fullname")  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpRequest.ValidateInput" />
        <altmember cref="P:System.Web.HttpRequest.Form" />
        <altmember cref="P:System.Web.HttpRequest.Cookies" />
      </Docs>
    </Member>
    <Member MemberName="RawUrl">
      <MemberSignature Language="C#" Value="public string RawUrl { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RawUrl" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.RawUrl" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RawUrl As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RawUrl { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RawUrl : string" Usage="System.Web.HttpRequest.RawUrl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает исходный URL-адрес текущего запроса.</summary>
        <value>Исходный URL-адрес текущего запроса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Исходный URL-адрес определяется как часть URL-адрес следующие сведения о домене. В строке URL-адрес `http://www.contoso.com/articles/recent.aspx`, исходный URL-адрес является /articles/recent.aspx. Исходный URL-адрес включает строку запроса, при его наличии.  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Web.HttpUtility.HtmlEncode%2A> метод для HTML-кодирование значение <xref:System.Web.HttpRequest.RawUrl%2A> свойство и <xref:System.IO.TextWriter.WriteLine%2A> метод для записи в файл закодированное значение. Данный пример кода является частью большего примера для <xref:System.Web.HttpRequest> класса.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#5)]
 [!code-vb[System.Web.HttpRequest_Sample1#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadEntityBodyMode">
      <MemberSignature Language="C#" Value="public System.Web.ReadEntityBodyMode ReadEntityBodyMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.ReadEntityBodyMode ReadEntityBodyMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ReadEntityBodyMode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadEntityBodyMode As ReadEntityBodyMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::ReadEntityBodyMode ReadEntityBodyMode { System::Web::ReadEntityBodyMode get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadEntityBodyMode : System.Web.ReadEntityBodyMode" Usage="System.Web.HttpRequest.ReadEntityBodyMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ReadEntityBodyMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, прочитано ли тело сущности запроса, и, если да, как оно было прочитано.</summary>
        <value>Значение, указывающее, как было прочитано тело запроса сущности, или указывающее, что оно не было прочитано.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется для предотвращения исключение, которое возникает, если тело сущности уже считано, и предпринята попытка прочитать его, используя несовместимый метод. Методы и свойства для чтения тела сущности запроса следующие:  
  
-   Свойство <xref:System.Web.HttpRequest.Form%2A>.  
  
-   Свойство <xref:System.Web.HttpRequest.Files%2A>.  
  
-   Свойство <xref:System.Web.HttpRequest.InputStream%2A>.  
  
-   метод <xref:System.Web.HttpRequest.GetBufferedInputStream%2A> ;  
  
-   метод <xref:System.Web.HttpRequest.GetBufferlessInputStream%2A> ;  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestContext">
      <MemberSignature Language="C#" Value="public System.Web.Routing.RequestContext RequestContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Routing.RequestContext RequestContext" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.RequestContext" />
      <MemberSignature Language="VB.NET" Value="Public Property RequestContext As RequestContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Routing::RequestContext ^ RequestContext { System::Web::Routing::RequestContext ^ get(); void set(System::Web::Routing::RequestContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RequestContext : System.Web.Routing.RequestContext with get, set" Usage="System.Web.HttpRequest.RequestContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.Routing.RequestContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает экземпляр <see cref="T:System.Web.Routing.RequestContext" /> текущего запроса.</summary>
        <value>Экземпляр <see cref="T:System.Web.Routing.RequestContext" /> текущего запроса. Для немаршрутизируемых запросов возвращается пустой объект <see cref="T:System.Web.Routing.RequestContext" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство предоставляет доступ к <xref:System.Web.Routing.RouteData> объект для текущего запроса. Дополнительные сведения о маршрутизации ASP.NET см. в разделе. [Маршрутизация ASP.NET](https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/b2decba4-2400-491c-8907-89a7b9e0874c">Пошаговое руководство. С помощью ASP.NET, маршрутизации в приложениях Web Forms</related>
        <related type="Article" href="https://msdn.microsoft.com/library/dc88e6ba-470c-4b20-b644-35874cfd781d">Практическое руководство. Параметры доступа к URL-адреса в маршрутизируемой странице</related>
      </Docs>
    </Member>
    <Member MemberName="RequestType">
      <MemberSignature Language="C#" Value="public string RequestType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RequestType" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.RequestType" />
      <MemberSignature Language="VB.NET" Value="Public Property RequestType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RequestType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RequestType : string with get, set" Usage="System.Web.HttpRequest.RequestType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает метод передачи данных НТТР (<see langword="GET" /> или <see langword="POST" />), используемый клиентом.</summary>
        <value>Строка, представляющая тип вызова HTTP, отправленного клиентом.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода используется <xref:System.Web.HttpUtility.HtmlEncode%2A> метод для HTML-кодирование значение <xref:System.Web.HttpRequest.RequestType%2A> свойство и <xref:System.IO.TextWriter.WriteLine%2A> метод для записи в файл закодированное значение. Данный пример кода является частью большего примера для <xref:System.Web.HttpRequest> класса.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#7)]
 [!code-vb[System.Web.HttpRequest_Sample1#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveAs">
      <MemberSignature Language="C#" Value="public void SaveAs (string filename, bool includeHeaders);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SaveAs(string filename, bool includeHeaders) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.SaveAs(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveAs (filename As String, includeHeaders As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SaveAs(System::String ^ filename, bool includeHeaders);" />
      <MemberSignature Language="F#" Value="member this.SaveAs : string * bool -&gt; unit" Usage="httpRequest.SaveAs (filename, includeHeaders)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="includeHeaders" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filename">Путь к физическому диску.</param>
        <param name="includeHeaders">Логическое значение, указывающее, должен ли заголовок НТТР сохраняться на диске.</param>
        <summary>Сохраняет HTTP-запрос на диске.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сохранение содержимого запроса на диск может быть полезно при отладке.  
  
   
  
## Examples  
 В следующем примере кода вызывается <xref:System.Web.HttpRequest.SaveAs%2A> метод при загрузке страницы. Вызов указывает, что запрос был сохранен как текстовый файл в каталоге, где идентификатор процесса ASP.NET были предоставлены разрешения на запись, и что все данные заголовка, включенное в запрос включен в файл.  
  
 [!code-csharp[System.Web.HttpRequest_Sample6#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample6/cs/requestsample6cs.aspx#1)]
 [!code-vb[System.Web.HttpRequest_Sample6#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample6/vb/requestsample6vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Свойству <see cref="P:System.Web.Configuration.HttpRuntimeSection.RequireRootedSaveAsPath" /> объекта <see cref="T:System.Web.Configuration.HttpRuntimeSection" /> задается значение <see langword="true" />, но параметр <paramref name="filename" /> не содержит абсолютный путь.</exception>
      </Docs>
    </Member>
    <Member MemberName="ServerVariables">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection ServerVariables { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection ServerVariables" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ServerVariables" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ServerVariables As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ ServerVariables { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ServerVariables : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpRequest.ServerVariables" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает коллекцию переменных веб-сервера.</summary>
        <value><see cref="T:System.Collections.Specialized.NameValueCollection" /> переменных сервера.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Список переменных сервера, поддерживаемых службами IIS, см. в разделе [переменные сервера IIS](https://go.microsoft.com/fwlink/?LinkId=52471).  
  
   
  
## Examples  
 В следующем примере кода отображает имена и значения всех именованных переменных сервера.  
  
 [!code-csharp[Classic HttpRequest.ServerVariables Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ServerVariables Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ServerVariables Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ServerVariables Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TimedOutToken">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationToken TimedOutToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.CancellationToken TimedOutToken" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.TimedOutToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TimedOutToken As CancellationToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::CancellationToken TimedOutToken { System::Threading::CancellationToken get(); };" />
      <MemberSignature Language="F#" Value="member this.TimedOutToken : System.Threading.CancellationToken" Usage="System.Web.HttpRequest.TimedOutToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Threading.CancellationToken" />, задействуемый при истечении времени ожидания запроса.</summary>
        <value>Токен отмены.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Период ожидания можно указать в файле Web.config (см. в разделе <xref:System.Web.Configuration.HttpRuntimeSection.ExecutionTimeout%2A?displayProperty=nameWithType>) или программно (см. в разделе <xref:System.Web.HttpServerUtility.ScriptTimeout%2A?displayProperty=nameWithType>). Период ожидания измеряется с момента запрос поступает в. Если действует 110 секунд времени ожидания по умолчанию, токен отмены будет обработки не ранее 110 секунд после начала обработки запроса. Вы можете изменить <xref:System.Web.HttpServerUtility.ScriptTimeout%2A?displayProperty=nameWithType> значение свойства, и как долго этот маркер не ожидало еще, будут соблюдаться новое значение времени ожидания.  
  
 В настоящее время маркер только предоставляет 15-секундной детализацией, т.е. Если значение времени ожидания составляет 110 секунд, маркер будет обеспечивать совместимость, иногда от 110 до 125 секунд после начала обработки запроса. Гранулярность может измениться в будущем.  
  
 Несмотря на то, что это свойство является поточно ориентированной, существуют ограничения на его использование. Для получения дополнительной информации см. <xref:System.Web.HttpResponse.ClientDisconnectedToken%2A?displayProperty=nameWithType>.  
  
 Это свойство не имеет смысла, если обработка запроса WebSockets начата.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TlsTokenBindingInfo">
      <MemberSignature Language="C#" Value="public System.Web.ITlsTokenBindingInfo TlsTokenBindingInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.ITlsTokenBindingInfo TlsTokenBindingInfo" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.TlsTokenBindingInfo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TlsTokenBindingInfo As ITlsTokenBindingInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::ITlsTokenBindingInfo ^ TlsTokenBindingInfo { System::Web::ITlsTokenBindingInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TlsTokenBindingInfo : System.Web.ITlsTokenBindingInfo" Usage="System.Web.HttpRequest.TlsTokenBindingInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ITlsTokenBindingInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает сведения о привязке токена TLS. Свойство позволяет приложениям извлекать сведения о токенах из входящих HTTP-запросов для расширенных возможностей аутентификации.</summary>
        <value>Маркер привязки для текущего соединения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство возвращает `null` на платформах, отличных от Windows 10.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TotalBytes">
      <MemberSignature Language="C#" Value="public int TotalBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TotalBytes" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.TotalBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalBytes As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int TotalBytes { int get(); };" />
      <MemberSignature Language="F#" Value="member this.TotalBytes : int" Usage="System.Web.HttpRequest.TotalBytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает число байтов в текущем потоке входящих данных.</summary>
        <value>Возвращает число байтов потока входящих данных.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода определяется ли <xref:System.Web.HttpRequest.TotalBytes%2A> значение свойства больше, чем 1000 байт и записывающий эту информацию в файл.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#6](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#6)]
 [!code-vb[System.Web.HttpRequest_Sample1#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unvalidated">
      <MemberSignature Language="C#" Value="public System.Web.UnvalidatedRequestValues Unvalidated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UnvalidatedRequestValues Unvalidated" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Unvalidated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Unvalidated As UnvalidatedRequestValues" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UnvalidatedRequestValues ^ Unvalidated { System::Web::UnvalidatedRequestValues ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Unvalidated : System.Web.UnvalidatedRequestValues" Usage="System.Web.HttpRequest.Unvalidated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UnvalidatedRequestValues</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значения HTTP-запроса, не активируя его проверку.</summary>
        <value>Значения HTTP-запроса, которые не были проверены с помощью проверки запроса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Запрос проверки HTML-разметка и скрипт, который может свидетельствовать о потенциальной атаке межсайтовых сценариев. По умолчанию, все значения проверяются с помощью проверки запросов и если все значения содержат разметка или сценарий, ASP.NET создает исключение <xref:System.Web.HttpRequestValidationException> исключение. Используйте этот метод, если предполагается, что запрос будет содержать разметки (например, Вы разрешили пользователям отправлять содержимое, которое содержит разметку) и вы хотите получить необработанное значение запроса.  
  
> [!IMPORTANT]
>  Если это свойство используется, необходимо вручную проверить данные для потенциальных атак с использованием межузловых сценариев.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UnvalidatedRequestValues" />
      </Docs>
    </Member>
    <Member MemberName="Url">
      <MemberSignature Language="C#" Value="public Uri Url { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Url" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Url" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Url As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Url { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Url : Uri" Usage="System.Web.HttpRequest.Url" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает сведения об URL-адресе текущего запроса.</summary>
        <value>Объект <see cref="T:System.Uri" />, содержащий универсальный код ресурса текущего запроса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода пример назначает <xref:System.Uri> объект текущего запроса объектной переменной и отображает значения двух свойств URL-адреса объекта в выходные данные НТТР.  
  
 [!code-csharp[Classic HttpRequest.Url Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Url Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Url Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Url Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Uri" />
        <altmember cref="P:System.Web.HttpRequest.RawUrl" />
      </Docs>
    </Member>
    <Member MemberName="UrlReferrer">
      <MemberSignature Language="C#" Value="public Uri UrlReferrer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri UrlReferrer" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UrlReferrer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UrlReferrer As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ UrlReferrer { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UrlReferrer : Uri" Usage="System.Web.HttpRequest.UrlReferrer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает сведения об URL-адресе предыдущего запроса клиента, связанного с текущим URL-адресом.</summary>
        <value>Объект <see cref="T:System.Uri" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода отображает значения двух свойств URL-адреса, который перенаправляет клиент в текущее приложение.  
  
 [!code-csharp[Classic HttpRequest.UrlReferrer Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.UrlReferrer Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.UrlReferrer Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.UrlReferrer Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UriFormatException">Заголовок запроса HTTP <see langword="Referer" /> имеет неверный формат и не может быть преобразовано в объект <see cref="T:System.Uri" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="UserAgent">
      <MemberSignature Language="C#" Value="public string UserAgent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserAgent" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UserAgent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserAgent As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserAgent { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAgent : string" Usage="System.Web.HttpRequest.UserAgent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает исходную строку пользовательского агента, переданную от клиентского браузера. Обратите внимание, что результат может иметь значение null.</summary>
        <value>Начальная строка пользовательского агента для клиентского браузера.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода назначает Идентификация запрашивающий браузер строковой переменной.  
  
 [!code-csharp[Classic HttpRequest.UserAgent Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.UserAgent Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.UserAgent Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.UserAgent Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.ClientTarget" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="P:System.Web.HttpRequest.Browser" />
        <related type="Article" href="https://msdn.microsoft.com/library/143d14d6-9d12-4d4b-ae60-f00e0eb6938f">Серверные элементы управления ASP.NET и возможностей браузера</related>
      </Docs>
    </Member>
    <Member MemberName="UserHostAddress">
      <MemberSignature Language="C#" Value="public string UserHostAddress { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserHostAddress" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UserHostAddress" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserHostAddress As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserHostAddress { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserHostAddress : string" Usage="System.Web.HttpRequest.UserHostAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает IP-адрес узла удаленного клиента.</summary>
        <value>IP-адрес узла удаленного клиента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода используется <xref:System.Web.HttpUtility.HtmlEncode%2A> метод для HTML-кодирование значение <xref:System.Web.HttpRequest.UserHostAddress%2A> свойство и <xref:System.IO.TextWriter.WriteLine%2A> метод для записи в файл закодированное значение. Данный пример кода является частью большего примера для <xref:System.Web.HttpRequest> класса.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#7)]
 [!code-vb[System.Web.HttpRequest_Sample1#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserHostName">
      <MemberSignature Language="C#" Value="public string UserHostName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserHostName" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UserHostName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserHostName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserHostName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserHostName : string" Usage="System.Web.HttpRequest.UserHostName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает DNS-имя удаленного клиента.</summary>
        <value>DNS-имя удаленного клиента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода используется <xref:System.Web.HttpUtility.HtmlEncode%2A> метод для HTML-кодирование значение <xref:System.Web.HttpRequest.UserHostName%2A> свойство и <xref:System.IO.TextWriter.WriteLine%2A> метод для записи в файл закодированное значение. Данный пример кода является частью большего примера для <xref:System.Web.HttpRequest> класса.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#7)]
 [!code-vb[System.Web.HttpRequest_Sample1#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserLanguages">
      <MemberSignature Language="C#" Value="public string[] UserLanguages { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] UserLanguages" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UserLanguages" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserLanguages As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ UserLanguages { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserLanguages : string[]" Usage="System.Web.HttpRequest.UserLanguages" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает упорядоченный строковый массив языковых настроек клиента.</summary>
        <value>Упорядоченный строковый массив языковых настроек клиента или <see langword="null" /> если пустой.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода захватывает несколько значений, возвращенных <xref:System.Web.HttpRequest.UserLanguages%2A> свойство в массив строк и записи, имя каждого языка в отдельную строку вывода НТТР.  
  
 Названия языков предоставляются браузером, и отсутствует определенный список всех возможных кодов.  Обычно они состоят из двузначных кодов языка, дефиса и двухсимвольный код для языка и региональных параметров, таких как «en-us» для США Английский и «fr-ca» для французский (Канада).  
  
 [!code-csharp[Classic HttpRequest.UserLanguages Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.UserLanguages Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.UserLanguages Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.UserLanguages Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateInput">
      <MemberSignature Language="C#" Value="public void ValidateInput ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateInput() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.ValidateInput" />
      <MemberSignature Language="VB.NET" Value="Public Sub ValidateInput ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ValidateInput();" />
      <MemberSignature Language="F#" Value="member this.ValidateInput : unit -&gt; unit" Usage="httpRequest.ValidateInput " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вызывает проверку для коллекций, доступных через свойства <see cref="P:System.Web.HttpRequest.Cookies" />, <see cref="P:System.Web.HttpRequest.Form" /> и <see cref="P:System.Web.HttpRequest.QueryString" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest> Класс использует флаги проверки входных данных для отслеживания, следует ли выполнять проверку на запрос коллекций, доступных через <xref:System.Web.HttpRequest.Cookies%2A>, <xref:System.Web.HttpRequest.Form%2A>, и <xref:System.Web.HttpRequest.QueryString%2A> свойства. <xref:System.Web.HttpRequest.ValidateInput%2A> Метод устанавливает эти флаги, так что при методы доступа get для <xref:System.Web.HttpRequest.Cookies%2A>, <xref:System.Web.HttpRequest.Form%2A>, или <xref:System.Web.HttpRequest.QueryString%2A> свойств вызываются, производится проверка входных данных. Проверка выполняет обработку всех входящих данных со списком потенциально опасных данных жестко.  
  
 Если функция проверки обеспечивается директивы страницы или конфигурации, этот метод вызывается во время страницы `ProcessRequest` стадию обработки. <xref:System.Web.HttpRequest.ValidateInput%2A> Метод может вызываться в коде, если не включена функция проверки.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpRequestValidationException">Потенциально опасные данные, полученные от клиента.</exception>
        <altmember cref="P:System.Web.HttpRequest.Cookies" />
        <altmember cref="P:System.Web.HttpRequest.Form" />
        <altmember cref="P:System.Web.HttpRequest.QueryString" />
      </Docs>
    </Member>
  </Members>
</Type>