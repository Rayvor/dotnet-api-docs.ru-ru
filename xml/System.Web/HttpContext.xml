<Type Name="HttpContext" FullName="System.Web.HttpContext">
  <Metadata><Meta Name="ms.openlocfilehash" Value="408424d74271b90ba42777a6e94139324fab5fa9" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69396619" /></Metadata><TypeSignature Language="C#" Value="public sealed class HttpContext : IServiceProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpContext extends System.Object implements class System.IServiceProvider" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpContext" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpContext&#xA;Implements IServiceProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpContext sealed : IServiceProvider" />
  <TypeSignature Language="F#" Value="type HttpContext = class&#xA;    interface IServiceProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IServiceProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Инкапсулирует все связанные с НТТР сведения об отдельном НТТР-запросе.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Классы, наследующие <xref:System.Web.IHttpModule> интерфейсы <xref:System.Web.IHttpHandler> и, <xref:System.Web.HttpContext> предоставляются ссылкой на объект для текущего HTTP-запроса. Объект предоставляет доступ к внутренним <xref:System.Web.HttpContext.Request%2A>свойствам, <xref:System.Web.HttpContext.Response%2A>и <xref:System.Web.HttpContext.Server%2A> для запроса.  
  
> [!IMPORTANT] 
> Этот объект готов к сбору <xref:System.Web.HttpRequest> мусора по завершении. Его использование после завершения запроса может привести к неопределенному поведению, например к <xref:System.NullReferenceException>.
>
> Этот объект доступен только в потоке, управляемом ASP.NET. Использование в фоновых потоках может привести к неопределенному поведению.

## Examples  
 В следующем примере показано, как получить доступ к свойствам <xref:System.Web.HttpContext> объекта и отобразить его. Доступ к контексту текущего HTTP-запроса осуществляется с помощью <xref:System.Web.UI.Page.Context%2A> свойства <xref:System.Web.UI.Page> объекта.  
  
 [!code-aspx-csharp[System.Web.HttpContext#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpContext/cs/httpcontextcs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpContext#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpContext/vb/httpcontextvb.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.IHttpModule" />
    <altmember cref="T:System.Web.IHttpHandler" />
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=196730">Важность контекста</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Web.HttpContext" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpContext (System.Web.HttpWorkerRequest wr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.HttpWorkerRequest wr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.#ctor(System.Web.HttpWorkerRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (wr As HttpWorkerRequest)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpContext(System::Web::HttpWorkerRequest ^ wr);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpContext : System.Web.HttpWorkerRequest -&gt; System.Web.HttpContext" Usage="new System.Web.HttpContext wr" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="wr" Type="System.Web.HttpWorkerRequest" />
      </Parameters>
      <Docs>
        <param name="wr">Объект <see cref="T:System.Web.HttpWorkerRequest" /> для текущего HTTP-запроса.</param>
        <summary>Выполняет инициализацию нового экземпляра класса <see cref="T:System.Web.HttpContext" /> с заданным объектом запроса выполнителя.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpContext (System.Web.HttpRequest request, System.Web.HttpResponse response);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.HttpRequest request, class System.Web.HttpResponse response) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.#ctor(System.Web.HttpRequest,System.Web.HttpResponse)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (request As HttpRequest, response As HttpResponse)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpContext(System::Web::HttpRequest ^ request, System::Web::HttpResponse ^ response);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpContext : System.Web.HttpRequest * System.Web.HttpResponse -&gt; System.Web.HttpContext" Usage="new System.Web.HttpContext (request, response)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="request" Type="System.Web.HttpRequest" />
        <Parameter Name="response" Type="System.Web.HttpResponse" />
      </Parameters>
      <Docs>
        <param name="request">Объект <see cref="T:System.Web.HttpRequest" /> для текущего HTTP-запроса.</param>
        <param name="response">Объект <see cref="T:System.Web.HttpResponse" /> для текущего HTTP-запроса.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Web.HttpContext" />, используя заданный запрос и объекты ответов.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AcceptWebSocketRequest">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Принимает запрос <see cref="T:System.Web.WebSockets.AspNetWebSocket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AcceptWebSocketRequest">
      <MemberSignature Language="C#" Value="public void AcceptWebSocketRequest (Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt; userFunc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptWebSocketRequest(class System.Func`2&lt;class System.Web.WebSockets.AspNetWebSocketContext, class System.Threading.Tasks.Task&gt; userFunc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptWebSocketRequest (userFunc As Func(Of AspNetWebSocketContext, Task))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptWebSocketRequest(Func&lt;System::Web::WebSockets::AspNetWebSocketContext ^, System::Threading::Tasks::Task ^&gt; ^ userFunc);" />
      <MemberSignature Language="F#" Value="member this.AcceptWebSocketRequest : Func&lt;System.Web.WebSockets.AspNetWebSocketContext, System.Threading.Tasks.Task&gt; -&gt; unit" Usage="httpContext.AcceptWebSocketRequest userFunc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userFunc" Type="System.Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt;" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="userFunc">Пользовательская функция.</param>
        <summary>Принимает запрос <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> с помощью заданной пользовательской функции.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов этого метода эквивалентен вызову <xref:System.Web.HttpContext.AcceptWebSocketRequest%2A> перегрузки метода и передаче `null` `options` параметра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="userFunc" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Запрос не является запросом <see cref="T:System.Web.WebSockets.AspNetWebSocket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AcceptWebSocketRequest">
      <MemberSignature Language="C#" Value="public void AcceptWebSocketRequest (Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt; userFunc, System.Web.WebSockets.AspNetWebSocketOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptWebSocketRequest(class System.Func`2&lt;class System.Web.WebSockets.AspNetWebSocketContext, class System.Threading.Tasks.Task&gt; userFunc, class System.Web.WebSockets.AspNetWebSocketOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task},System.Web.WebSockets.AspNetWebSocketOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptWebSocketRequest (userFunc As Func(Of AspNetWebSocketContext, Task), options As AspNetWebSocketOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptWebSocketRequest(Func&lt;System::Web::WebSockets::AspNetWebSocketContext ^, System::Threading::Tasks::Task ^&gt; ^ userFunc, System::Web::WebSockets::AspNetWebSocketOptions ^ options);" />
      <MemberSignature Language="F#" Value="member this.AcceptWebSocketRequest : Func&lt;System.Web.WebSockets.AspNetWebSocketContext, System.Threading.Tasks.Task&gt; * System.Web.WebSockets.AspNetWebSocketOptions -&gt; unit" Usage="httpContext.AcceptWebSocketRequest (userFunc, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userFunc" Type="System.Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt;" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="options" Type="System.Web.WebSockets.AspNetWebSocketOptions" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="userFunc">Пользовательская функция.</param>
        <param name="options">Объект параметров.</param>
        <summary>Принимает запрос <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> с помощью заданной пользовательской функции и объекта параметров.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="userFunc" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Запрос не является запросом <see cref="T:System.Web.WebSockets.AspNetWebSocket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddError">
      <MemberSignature Language="C#" Value="public void AddError (Exception errorInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddError(class System.Exception errorInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AddError(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddError (errorInfo As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddError(Exception ^ errorInfo);" />
      <MemberSignature Language="F#" Value="member this.AddError : Exception -&gt; unit" Usage="httpContext.AddError errorInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorInfo" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="errorInfo">Объект <see cref="T:System.Exception" />, добавляемый в коллекцию исключений.</param>
        <summary>Добавляет исключение в коллекцию исключений для текущего HTTP-запроса.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOnRequestCompleted">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken AddOnRequestCompleted (Action&lt;System.Web.HttpContext&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken AddOnRequestCompleted(class System.Action`1&lt;class System.Web.HttpContext&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AddOnRequestCompleted(System.Action{System.Web.HttpContext})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOnRequestCompleted (callback As Action(Of HttpContext)) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ AddOnRequestCompleted(Action&lt;System::Web::HttpContext ^&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="member this.AddOnRequestCompleted : Action&lt;System.Web.HttpContext&gt; -&gt; System.Web.ISubscriptionToken" Usage="httpContext.AddOnRequestCompleted callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Web.HttpContext&gt;" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">Объект контекста HTTP.</param>
        <summary>Создает виртуальное событие, происходящее при завершении HTTP-части запроса.</summary>
        <returns>Токен подписки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие происходит перед <xref:System.Web.WebSockets.AspNetWebSocket> началом соединения.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="callback" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AllErrors">
      <MemberSignature Language="C#" Value="public Exception[] AllErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception[] AllErrors" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AllErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AllErrors As Exception()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;Exception ^&gt; ^ AllErrors { cli::array &lt;Exception ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AllErrors : Exception[]" Usage="System.Web.HttpContext.AllErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает массив ошибок, накопившихся в ходе обработки HTTP-запроса.</summary>
        <value>Массив объектов <see cref="T:System.Exception" /> для текущего HTTP-запроса.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowAsyncDuringSyncStages">
      <MemberSignature Language="C#" Value="public bool AllowAsyncDuringSyncStages { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAsyncDuringSyncStages" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AllowAsyncDuringSyncStages" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowAsyncDuringSyncStages As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowAsyncDuringSyncStages { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowAsyncDuringSyncStages : bool with get, set" Usage="System.Web.HttpContext.AllowAsyncDuringSyncStages" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, разрешены ли асинхронные операции в ходе обработки запроса ASP.NET, когда они не ожидаются.</summary>
        <value>Значение <see langword="false" />, если ASP.NET создаст исключение, когда асинхронный API будет использоваться в момент, когда он не ожидается; в противном случае — значение <see langword="true" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если этот флаг не установлен в `true`значение, ASP.NET выдаст исключение при обнаружении приложением неверного использования асинхронного API. Это может произойти при попытке вызвать асинхронный метод во время выполнения конвейера обработки запроса, когда асинхронные операции не ожидаются или если асинхронная работа по-прежнему недоступна, когда асинхронный модуль или обработчик сигнализирует о завершении. Это поведение предназначено для обеспечения безопасности в начале работы, если вы пишете асинхронный код, который не соответствует ожидаемым шаблонам и может иметь негативные побочные эффекты.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Application">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplicationState Application { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplicationState Application" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Application" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Application As HttpApplicationState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpApplicationState ^ Application { System::Web::HttpApplicationState ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Application : System.Web.HttpApplicationState" Usage="System.Web.HttpContext.Application" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplicationState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Web.HttpApplicationState" /> для текущего HTTP-запроса.</summary>
        <value>Объект <see cref="T:System.Web.HttpApplicationState" /> для текущего HTTP-запроса.  
  
Чтобы получить объект <see cref="T:System.Web.HttpApplication" /> для текущего HTTP-запроса, используйте свойство <see cref="P:System.Web.HttpContext.ApplicationInstance" />. (В платформе ASP.NET свойство, обозначающее текущий экземпляр <see cref="T:System.Web.HttpApplication" />, имеет имя <see langword="ApplicationInstance" /> вместо <see langword="Application" />, чтобы избежать путаницы между ASP.NET и классической платформой ASP. В классической платформе ASP свойство <see langword="Application" /> относится к глобальному словарю состояний приложения.)</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.HttpContext.ApplicationInstance" />
      </Docs>
    </Member>
    <Member MemberName="ApplicationInstance">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplication ApplicationInstance { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplication ApplicationInstance" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.ApplicationInstance" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationInstance As HttpApplication" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpApplication ^ ApplicationInstance { System::Web::HttpApplication ^ get(); void set(System::Web::HttpApplication ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationInstance : System.Web.HttpApplication with get, set" Usage="System.Web.HttpContext.ApplicationInstance" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplication</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает объект <see cref="T:System.Web.HttpApplication" /> для текущего HTTP-запроса.</summary>
        <value>Объект <see cref="T:System.Web.HttpApplication" /> для текущего HTTP-запроса.  
  
В платформе ASP.NET свойство, обозначающее текущий экземпляр <see cref="T:System.Web.HttpApplication" />, имеет имя <see langword="ApplicationInstance" /> вместо <see langword="Application" />, чтобы избежать путаницы между ASP.NET и классической платформой ASP. В классической платформе ASP свойство <see langword="Application" /> относится к глобальному словарю состояний приложения.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Веб-приложение выполняется под управлением IIS 7.0 в интегрированном режиме, однако была предпринята попытка изменить отличное от NULL значение свойства на значение <see langword="null" />.</exception>
        <altmember cref="P:System.Web.HttpContext.Application" />
      </Docs>
    </Member>
    <Member MemberName="AsyncPreloadMode">
      <MemberSignature Language="C#" Value="public System.Web.Configuration.AsyncPreloadModeFlags AsyncPreloadMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.Configuration.AsyncPreloadModeFlags AsyncPreloadMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AsyncPreloadMode" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncPreloadMode As AsyncPreloadModeFlags" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Configuration::AsyncPreloadModeFlags AsyncPreloadMode { System::Web::Configuration::AsyncPreloadModeFlags get(); void set(System::Web::Configuration::AsyncPreloadModeFlags value); };" />
      <MemberSignature Language="F#" Value="member this.AsyncPreloadMode : System.Web.Configuration.AsyncPreloadModeFlags with get, set" Usage="System.Web.HttpContext.AsyncPreloadMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Configuration.AsyncPreloadModeFlags</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает объект, содержащий флаги, которые относятся к асинхронному режиму предварительной загрузки.</summary>
        <value>Объект, содержащий флаги, которые относятся к асинхронному режиму предварительной загрузки.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При первом обращении к этому свойству объект, содержащий флаги для асинхронного режима предварительной загрузки, <xref:System.Web.Configuration.HttpRuntimeSection.AsyncPreloadMode%2A> загружается из параметра в файле конфигурации.  
  
 Хотя это свойство может быть задано программным путем, изменение значения свойства действует, только если это свойство установлено до шага `ExecuteRequestHandler` в конвейере запросов ASP.NET.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.Caching.Cache Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Caching.Cache Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Cache" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cache As Cache" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Caching::Cache ^ Cache { System::Web::Caching::Cache ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cache : System.Web.Caching.Cache" Usage="System.Web.HttpContext.Cache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Caching.Cache</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Web.Caching.Cache" /> для текущего домена приложения.</summary>
        <value>Контекст <see cref="T:System.Web.Caching.Cache" /> для текущего домена приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Существует один экземпляр <xref:System.Web.Caching.Cache> класса для каждого домена приложения. В результате <xref:System.Web.Caching.Cache> объект, возвращаемый <xref:System.Web.HttpContext.Cache%2A> свойством, является <xref:System.Web.Caching.Cache> объектом для всех запросов в домене приложения.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearError">
      <MemberSignature Language="C#" Value="public void ClearError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.ClearError" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearError ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearError();" />
      <MemberSignature Language="F#" Value="member this.ClearError : unit -&gt; unit" Usage="httpContext.ClearError " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет все ошибки текущего HTTP-запроса.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.HttpContext.Error" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Web.HttpContext Current { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Web.HttpContext Current" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Current As HttpContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::HttpContext ^ Current { System::Web::HttpContext ^ get(); void set(System::Web::HttpContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Web.HttpContext with get, set" Usage="System.Web.HttpContext.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает объект <see cref="T:System.Web.HttpContext" /> для текущего HTTP-запроса.</summary>
        <value>Экземпляр <see cref="T:System.Web.HttpContext" /> для текущего HTTP-запроса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство является статическим свойством <xref:System.Web.HttpContext> класса. Свойство хранит <xref:System.Web.HttpContext> экземпляр, который применяется к текущему запросу. Свойства этого экземпляра являются нестатическими свойствами <xref:System.Web.HttpContext> класса.  
  
 Также можно использовать <xref:System.Web.UI.Page.Context%2A?displayProperty=nameWithType> свойство для <xref:System.Web.HttpContext> доступа к объекту для текущего HTTP-запроса.  
  
   
  
## Examples  
 <xref:System.Web.HttpContext.Current%2A> В следующем примере кода свойство используется для <xref:System.Web.HttpContext.AddError%2A?displayProperty=nameWithType> доступа к методам <xref:System.Web.HttpContext.ClearError%2A?displayProperty=nameWithType> и и <xref:System.Web.HttpContext.AllErrors%2A?displayProperty=nameWithType> свойству. В примере создается три пользовательских исключения с помощью <xref:System.Web.HttpContext.AddError%2A> метода и <xref:System.Web.HttpContext.AllErrors%2A> используется свойство для загрузки этих исключений в массив. Затем он записывает массив на содержащую его страницу и использует <xref:System.Web.HttpContext.ClearError%2A> метод для очистки всех ошибок <xref:System.Web.UI.Page.Context%2A> в свойстве.  
  
```csharp  
protected void Page_Load(object sender, EventArgs e)  
{  
    HttpContext context = HttpContext.Current;  
    Response.Write("<p>HttpContext.Current Example:</p>");  
  
    // Add three custom exceptions.  
    context.AddError(new Exception("New Exception #1"));  
    context.AddError(new Exception("New Exception #2"));  
    context.AddError(new Exception("New Exception #3"));  
  
    // Capture all the new Exceptions in an array.  
    Exception[] errs = context.AllErrors;  
  
    foreach (Exception ex in errs)  
    {  
        Response.Write("<p>" + Server.HtmlEncode(ex.ToString()) + "</p>");  
    }  
  
    // Clear the exceptions so ASP.NET won't handle them.  
    context.ClearError();  
}  
```  
  
```vb  
Protected Sub Page_Load(sender As Object, e As EventArgs)  
Dim context As HttpContext = HttpContext.Current  
Response.Write("<p>HttpContext.Current Example:</p>")  
  
' Add three custom exceptions.  
context.AddError(New Exception("New Exception #1"))  
context.AddError(New Exception("New Exception #2"))  
context.AddError(New Exception("New Exception #3"))  
  
' Capture all the new Exceptions in an array.  
Dim errs As Exception() = context.AllErrors  
  
For Each ex As Exception In errs  
Response.Write("<p>" & Server.HtmlEncode(ex.ToString()) & "</p>")  
Next  
  
' Clear the exceptions so ASP.NET won't handle them.  
context.ClearError()  
End Sub  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Response" />
        <altmember cref="P:System.Web.HttpContext.Request" />
      </Docs>
    </Member>
    <Member MemberName="CurrentHandler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler CurrentHandler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler CurrentHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.CurrentHandler" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentHandler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ CurrentHandler { System::Web::IHttpHandler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentHandler : System.Web.IHttpHandler" Usage="System.Web.HttpContext.CurrentHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Web.IHttpHandler" />, представляющий выполняющегося в данный момент обработчика.</summary>
        <value>Объект <see cref="T:System.Web.IHttpHandler" />, представляющий выполняющегося в данный момент обработчика.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текущий выполняющийся обработчик, на который ссылается <xref:System.Web.HttpContext.CurrentHandler%2A> свойство, может отличаться от обработчика, на который ссылается <xref:System.Web.HttpContext.Handler%2A> свойство. Это может произойти при запросе другого обработчика с помощью <xref:System.Web.HttpServerUtility.Execute%2A> метода <xref:System.Web.HttpServerUtility.Transfer%2A> или метода. Когда выполняемый в данный момент обработчик завершает обработку, ранее определенный обработчик восстанавливается.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Handler" />
        <altmember cref="P:System.Web.HttpContext.PreviousHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/f540bdeb-d22e-4e1d-ba8a-fe6c9926283b">Общие сведения о HTTP-обработчиках и модулях HTTP</related>
      </Docs>
    </Member>
    <Member MemberName="CurrentNotification">
      <MemberSignature Language="C#" Value="public System.Web.RequestNotification CurrentNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.RequestNotification CurrentNotification" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.CurrentNotification" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentNotification As RequestNotification" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::RequestNotification CurrentNotification { System::Web::RequestNotification get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentNotification : System.Web.RequestNotification" Usage="System.Web.HttpContext.CurrentNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.RequestNotification</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение <see cref="T:System.Web.RequestNotification" />, указывающее на текущее обрабатываемое событие <see cref="T:System.Web.HttpApplication" />.</summary>
        <value>Одно из значений перечисления <see cref="T:System.Web.RequestNotification" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для <xref:System.Web.HttpContext.CurrentNotification%2A> свойства требуется встроенный режим конвейера в [!INCLUDE[iisver](~/includes/iisver-md.md)] и по крайней мере .NET Framework версии 3,0. Если свойство доступно, оно возвращает <xref:System.Web.RequestNotification> значение. Значение <xref:System.Web.HttpContext.CurrentNotification%2A> свойства указывает, какое событие <xref:System.Web.HttpApplication> в экземпляре в настоящее время обрабатывает запрос.  
  
 <xref:System.Web.HttpContext.CurrentNotification%2A> Свойство не должно быть задано. Вместо этого он задается [!INCLUDE[iisver](~/includes/iisver-md.md)] во время обработки запроса в конвейере ASP.NET. Установка этого <xref:System.Web.HttpContext.CurrentNotification%2A> свойства приведет к ошибке компиляции.  
  
 <xref:System.Web.HttpContext.CurrentNotification%2A>вводится в .NET Framework версии 3,5.  Дополнительные сведения см. в статье [Версии и зависимости платформы .NET Framework](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
   
  
## Examples  
 В следующем примере показано использование <xref:System.Web.HttpContext.CurrentNotification%2A> свойства для определения события <xref:System.Web.HttpApplication> объекта, обрабатывающего текущий запрос. В этом примере обработчик событий обрабатывает несколько событий <xref:System.Web.HttpApplication> объекта, <xref:System.Web.HttpContext.CurrentNotification%2A> а свойство определяет, какой код вызывается для каждого обрабатываемого события.  
  
 [!code-csharp[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Для операции требуется режим интегрированного конвейера в [!INCLUDE[iisver](~/includes/iisver-md.md)] и как минимум платформа .NET Framework версии 3.0.</exception>
        <altmember cref="P:System.Web.HttpContext.IsPostNotification" />
        <altmember cref="T:System.Web.RequestNotification" />
      </Docs>
    </Member>
    <Member MemberName="DisposeOnPipelineCompleted">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken DisposeOnPipelineCompleted (IDisposable target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken DisposeOnPipelineCompleted(class System.IDisposable target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.DisposeOnPipelineCompleted(System.IDisposable)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisposeOnPipelineCompleted (target As IDisposable) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ DisposeOnPipelineCompleted(IDisposable ^ target);" />
      <MemberSignature Language="F#" Value="member this.DisposeOnPipelineCompleted : IDisposable -&gt; System.Web.ISubscriptionToken" Usage="httpContext.DisposeOnPipelineCompleted target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.IDisposable" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="target">Объект, метод <see cref="M:System.IDisposable.Dispose" /> которого должен вызываться при завершении запроса части соединения <see cref="T:System.Web.WebSockets.AspNetWebSocket" />.</param>
        <summary>Позволяет метод <see cref="M:System.IDisposable.Dispose" /> объекта вызываться при завершении части соединения <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> этого запроса.</summary>
        <returns>Токен подписки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод целевого объекта вызывается после завершения HTTP-части запроса <xref:System.Web.WebSockets.AspNetWebSocket> и соединения. <xref:System.IDisposable.Dispose%2A> <xref:System.Web.HttpContext> Объект недоступен для проверки.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public Exception Error { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception Error" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Error" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Error As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Exception ^ Error { Exception ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Error : Exception" Usage="System.Web.HttpContext.Error" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает первую ошибку (при наличии таковой), возникшую в ходе обработки НТТР-запроса.</summary>
        <value>Первый объект <see cref="T:System.Exception" /> для текущего HTTP-запроса/процесса реагирования; на проблемы в противном случае — значение <see langword="null" />, если ошибки не накопились во время обработки HTTP-запроса. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.HttpContext.ClearError" />
      </Docs>
    </Member>
    <Member MemberName="GetAppConfig">
      <MemberSignature Language="C#" Value="public static object GetAppConfig (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetAppConfig(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetAppConfig(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAppConfig (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetAppConfig(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetAppConfig : string -&gt; obj" Usage="System.Web.HttpContext.GetAppConfig name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The recommended alternative is System.Web.Configuration.WebConfigurationManager.GetWebApplicationSection in System.Web.dll. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Тег конфигурации приложения, для которого запрашиваются сведения.</param>
        <summary>Возвращает запрашиваемые сведения о конфигурации для текущего приложения.</summary>
        <returns>Объект, содержащий сведения о конфигурации. (Распределяет возвращенный раздел конфигурации по соответствующему типу конфигурации перед использованием).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Web.HttpContext.GetAppConfig%2A> не рекомендуется к использованию. <xref:System.Web.Configuration.WebConfigurationManager.GetWebApplicationSection%2A> Используйте метод <xref:System.Web.Configuration.WebConfigurationManager> класса, чтобы получить сведения о конфигурации для текущего приложения.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Configuration.WebConfigurationManager" />
      </Docs>
    </Member>
    <Member MemberName="GetConfig">
      <MemberSignature Language="C#" Value="public object GetConfig (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetConfig(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetConfig(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConfig (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetConfig(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetConfig : string -&gt; obj" Usage="httpContext.GetConfig name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The recommended alternative is System.Web.HttpContext.GetSection in System.Web.dll. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Тег конфигурации, для которого запрашиваются сведения.</param>
        <summary>Возвращает запрашиваемые сведения о конфигурации для текущего HTTP-запроса.</summary>
        <returns>Указанный объект <see cref="T:System.Configuration.ConfigurationSection" />, <see langword="null" />, если раздел не существует, или внутренний объект, если раздел не доступен во время выполнения. (Распределяет возвращенный объект по соответствующему типу конфигурации перед использованием).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Web.HttpContext.GetConfig%2A> не рекомендуется к использованию. <xref:System.Web.HttpContext.GetSection%2A> Используйте метод, чтобы получить сведения о конфигурации для текущего HTTP-запроса.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpContext.GetSection(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGlobalResourceObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает ресурс на уровне приложения.</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">Ресурсы в приложениях</related>
        <related type="Article" href="https://msdn.microsoft.com/library/345e86a7-3851-4cdc-8309-a77bdb0d0a97">Макет веб-сайта ASP.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetGlobalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetGlobalResourceObject (string classKey, string resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetGlobalResourceObject(string classKey, string resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGlobalResourceObject (classKey As String, resourceKey As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetGlobalResourceObject(System::String ^ classKey, System::String ^ resourceKey);" />
      <MemberSignature Language="F#" Value="static member GetGlobalResourceObject : string * string -&gt; obj" Usage="System.Web.HttpContext.GetGlobalResourceObject (classKey, resourceKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classKey" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="resourceKey" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="classKey">Строка, представляющая собой свойство <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> запрошенного объекта ресурса.</param>
        <param name="resourceKey">Строка, представляющая собой свойство <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> запрошенного объекта ресурса.</param>
        <summary>Получает объект ресурса на уровне приложения на основе указанных свойств <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> и <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" />.</summary>
        <returns>Объект <see cref="T:System.Object" />, представляющий запрошенный объект ресурса уровня приложения; в противном случае — значение NULL, если подходящий объект ресурса не найден, или найден, но у него отсутствует нужное свойство.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод возвращает глобальный ресурс с использованием языка и региональных параметров, заданных <xref:System.Globalization.CultureInfo.CurrentUICulture%2A> в свойстве. <xref:System.Web.HttpContext.GetGlobalResourceObject%2A>  
  
> [!NOTE]
>  В некоторых средах редактирования, таких [!INCLUDE[vwprvw](~/includes/vwprvw-md.md)]как, редактор может вызвать исключение во время <xref:System.Resources.MissingManifestResourceException> разработки, если в имени ключа глобального ресурса используется точка (.). Однако это не влияет на возможность изменения или сохранения файла, и вы можете пропустить эту ошибку.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">Объект ресурса с указанным параметром <paramref name="classKey" /> не был найден.  
  
-или- 
Главная сборка не содержит ресурсов для нейтральных языка и региональных параметров и данные ресурсы необходимы из-за отсутствия соответствующей вспомогательной сборки.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">Ресурсы в приложениях</related>
        <related type="Article" href="https://msdn.microsoft.com/library/345e86a7-3851-4cdc-8309-a77bdb0d0a97">Макет веб-сайта ASP.NET</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Упаковка и развертывание ресурсов</related>
      </Docs>
    </Member>
    <Member MemberName="GetGlobalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetGlobalResourceObject (string classKey, string resourceKey, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetGlobalResourceObject(string classKey, string resourceKey, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGlobalResourceObject (classKey As String, resourceKey As String, culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetGlobalResourceObject(System::String ^ classKey, System::String ^ resourceKey, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member GetGlobalResourceObject : string * string * System.Globalization.CultureInfo -&gt; obj" Usage="System.Web.HttpContext.GetGlobalResourceObject (classKey, resourceKey, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classKey" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="resourceKey" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="classKey">Строка, представляющая собой свойство <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> запрошенного объекта ресурса.</param>
        <param name="resourceKey">Строка, представляющая свойство <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> запрошенного объекта ресурса.</param>
        <param name="culture">Строка, представляющая собой объект <see cref="T:System.Globalization.CultureInfo" /> запрошенного ресурса.</param>
        <summary>Получает объект ресурса на уровне приложения на основе заданных свойств <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> и <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> и в объекте <see cref="T:System.Globalization.CultureInfo" />.</summary>
        <returns>Объект <see cref="T:System.Object" />, представляющий запрошенный объект ресурса уровня приложения, локализованный для указанного языка и региональных параметров; в противном случае — <see langword="null" />, если подходящий объект ресурса не найден, или найден, но у него отсутствует нужное свойство.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Globalization.CultureInfo> Объект представляет язык и региональные параметры, для которых был локализован ресурс. Если ресурс не локализован для этого языка и региональных параметров, поиск будет выполнен с помощью резервного процесса, чтобы найти соответствующий ресурс. Дополнительные сведения см. в статье [Упаковка и развертывание ресурсов](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md).  
  
> [!NOTE]
>  В некоторых средах редактирования, таких как Visual Web Developer, редактор может вызвать исключение во время <xref:System.Resources.MissingManifestResourceException> разработки, если в глобальном имени ключа ресурса используется точка (.). Однако это не влияет на возможность изменения или сохранения файла, и вы можете пропустить эту ошибку.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">Объект ресурса с указанным для него параметром <paramref name="classKey" /> не был найден.  
  
- или - 
Главная сборка не содержит ресурсов для нейтральных языка и региональных параметров и данные ресурсы необходимы из-за отсутствия соответствующей вспомогательной сборки.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">Ресурсы в приложениях</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Упаковка и развертывание ресурсов</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLocalResourceObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает ресурс на уровне страницы.</summary>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">Ресурсы в приложениях</related>
        <related type="Article" href="https://msdn.microsoft.com/library/345e86a7-3851-4cdc-8309-a77bdb0d0a97">Макет веб-сайта ASP.NET</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Упаковка и развертывание ресурсов</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLocalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetLocalResourceObject (string virtualPath, string resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLocalResourceObject(string virtualPath, string resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetLocalResourceObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLocalResourceObject (virtualPath As String, resourceKey As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLocalResourceObject(System::String ^ virtualPath, System::String ^ resourceKey);" />
      <MemberSignature Language="F#" Value="static member GetLocalResourceObject : string * string -&gt; obj" Usage="System.Web.HttpContext.GetLocalResourceObject (virtualPath, resourceKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="resourceKey" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Свойство <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> для объекта локального ресурса.</param>
        <param name="resourceKey">Строка, представляющая свойство <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> запрошенного объекта ресурса.</param>
        <summary>Получает объект ресурса на уровне станицы на основе заданных свойств <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> и <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" />.</summary>
        <returns>Объект <see cref="T:System.Object" />, представляющий запрошенный объект ресурса на уровне страницы; в противном случае — значение <see langword="null" />, если найдены подходящие объекты ресурса, но не параметр <paramref name="resourceKey" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод возвращает локальный ресурс, используя язык и региональные параметры, указанные <xref:System.Globalization.CultureInfo.CurrentUICulture%2A> в свойстве. <xref:System.Web.HttpContext.GetLocalResourceObject%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">Объект ресурса с указанным для него параметром <paramref name="virtualPath" /> не был найден.</exception>
        <exception cref="T:System.ArgumentException">Указанный параметр <paramref name="virtualPath" /> не находится в корневом каталоге текущего приложения.</exception>
        <exception cref="T:System.InvalidOperationException">Класс ресурсов для страницы не был найден.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">Ресурсы в приложениях</related>
        <related type="Article" href="https://msdn.microsoft.com/library/345e86a7-3851-4cdc-8309-a77bdb0d0a97">Макет веб-сайта ASP.NET</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Упаковка и развертывание ресурсов</related>
        <related type="Article" href="https://msdn.microsoft.com/library/7a06d512-6fc3-40ca-9cb6-7f41d1a9fa28">Практическое руководство. Получение значений ресурсов программным способом</related>
      </Docs>
    </Member>
    <Member MemberName="GetLocalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetLocalResourceObject (string virtualPath, string resourceKey, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLocalResourceObject(string virtualPath, string resourceKey, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetLocalResourceObject(System.String,System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLocalResourceObject (virtualPath As String, resourceKey As String, culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLocalResourceObject(System::String ^ virtualPath, System::String ^ resourceKey, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member GetLocalResourceObject : string * string * System.Globalization.CultureInfo -&gt; obj" Usage="System.Web.HttpContext.GetLocalResourceObject (virtualPath, resourceKey, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="resourceKey" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Свойство <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> для объекта локального ресурса.</param>
        <param name="resourceKey">Строка, представляющая свойство <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> запрошенного объекта ресурса.</param>
        <param name="culture">Строка, представляющая собой объект <see cref="T:System.Globalization.CultureInfo" /> запрошенного объекта ресурса.</param>
        <summary>Получает объект ресурса на уровне страницы на основе заданных свойств <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> и <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" />, а также в объекте <see cref="T:System.Globalization.CultureInfo" />.</summary>
        <returns>Объект <see cref="T:System.Object" />, представляющий запрошенный объект локального ресурса, который локализован для указанного языка и региональных параметров; в противном случае — значение <see langword="null" />, если найден подходящий объект ресурса, но не параметр <paramref name="resourceKey" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если ресурс не локализован для этого языка и региональных параметров, поиск будет выполнен с помощью резервного процесса, чтобы найти соответствующий ресурс. Дополнительные сведения см. в статье [Упаковка и развертывание ресурсов](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">Объект ресурса с указанным для него параметром <paramref name="virtualPath" /> не был найден.</exception>
        <exception cref="T:System.ArgumentException">Указанный параметр <paramref name="virtualPath" /> не находится в корневом каталоге текущего приложения.</exception>
        <exception cref="T:System.InvalidOperationException">Класс ресурсов для страницы не был найден.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">Ресурсы в приложениях</related>
        <related type="Article" href="https://msdn.microsoft.com/library/345e86a7-3851-4cdc-8309-a77bdb0d0a97">Макет веб-сайта ASP.NET</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Упаковка и развертывание ресурсов</related>
        <related type="Article" href="https://msdn.microsoft.com/library/7a06d512-6fc3-40ca-9cb6-7f41d1a9fa28">Практическое руководство. Получение значений ресурсов программным способом</related>
      </Docs>
    </Member>
    <Member MemberName="GetSection">
      <MemberSignature Language="C#" Value="public object GetSection (string sectionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSection(string sectionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetSection(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSection (sectionName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSection(System::String ^ sectionName);" />
      <MemberSignature Language="F#" Value="member this.GetSection : string -&gt; obj" Usage="httpContext.GetSection sectionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sectionName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sectionName">Путь к разделу конфигурации (в формате XPath) и имя элемента конфигурации.</param>
        <summary>Получает указанный раздел конфигурации для конфигурации текущего приложения, заданной по умолчанию.</summary>
        <returns>Указанный объект <see cref="T:System.Configuration.ConfigurationSection" />, <see langword="null" />, если раздел не существует, или внутренний объект, если раздел не доступен во время выполнения.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Configuration.ConfigurationManager.GetSection(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Handler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler Handler { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler Handler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Handler" />
      <MemberSignature Language="VB.NET" Value="Public Property Handler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ Handler { System::Web::IHttpHandler ^ get(); void set(System::Web::IHttpHandler ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Handler : System.Web.IHttpHandler with get, set" Usage="System.Web.HttpContext.Handler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает объект <see cref="T:System.Web.IHttpHandler" />, отвечающий за обработку HTTP-запроса.</summary>
        <value>Объект <see cref="T:System.Web.IHttpHandler" />, отвечающий за обработку HTTP-запроса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.Handler%2A> Свойство содержит ссылку на обработчик, обрабатывающий HTTP-запрос. Обработчик можно указать с помощью элемента [httpHandlers](https://msdn.microsoft.com/library/24ca01f3-7141-4fdc-acac-71c0733cf6c2) или пользовательского обработчика, определенного в пользовательском коде. Дополнительные сведения о обработчиках см. в разделе HTTP [-обработчики и HTTP-модули Обзор](https://msdn.microsoft.com/library/f540bdeb-d22e-4e1d-ba8a-fe6c9926283b).  
  
 Ссылка на <xref:System.Web.HttpContext.Handler%2A> свойство останется неизменной даже после того, как текущая страница была изменена методом на стороне сервера, например <xref:System.Web.HttpServerUtility.Execute%2A> методом или <xref:System.Web.HttpServerUtility.Transfer%2A> методом.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.CurrentHandler" />
        <altmember cref="P:System.Web.HttpContext.PreviousHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/f540bdeb-d22e-4e1d-ba8a-fe6c9926283b">Общие сведения о HTTP-обработчиках и модулях HTTP</related>
      </Docs>
    </Member>
    <Member MemberName="IsCustomErrorEnabled">
      <MemberSignature Language="C#" Value="public bool IsCustomErrorEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCustomErrorEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsCustomErrorEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCustomErrorEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCustomErrorEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCustomErrorEnabled : bool" Usage="System.Web.HttpContext.IsCustomErrorEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, определяющее наличие настраиваемых ошибок в текущем HTTP-запросе.</summary>
        <value>Значение <see langword="true" /> при наличии настраиваемых ошибок; в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDebuggingEnabled">
      <MemberSignature Language="C#" Value="public bool IsDebuggingEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDebuggingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsDebuggingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDebuggingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDebuggingEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDebuggingEnabled : bool" Usage="System.Web.HttpContext.IsDebuggingEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, выполняется ли текущий HTTP-запрос в режиме отладки.</summary>
        <value>Значение <see langword="true" />, если запрос выполняется в режиме отладки; в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPostNotification">
      <MemberSignature Language="C#" Value="public bool IsPostNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPostNotification" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsPostNotification" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPostNotification As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPostNotification { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPostNotification : bool" Usage="System.Web.HttpContext.IsPostNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, которое является текущей точкой обработки в конвейере ASP.NET сразу после завершения обработки события <see cref="T:System.Web.HttpApplication" />.</summary>
        <value>Значение <see langword="true" /> при наличии настраиваемых ошибок; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство поддерживается только в интегрированном режиме в [!INCLUDE[iisver](~/includes/iisver-md.md)] и по крайней мере .NET Framework 3,0. <xref:System.Web.HttpContext.IsPostNotification%2A> Если свойство доступно, оно возвращает логическое значение, указывающее, завершилась ли обработка события <xref:System.Web.HttpApplication> объектом.  
  
 <xref:System.Web.HttpContext.IsPostNotification%2A> Свойство не должно быть задано. Вместо этого он предоставляется [!INCLUDE[iisver](~/includes/iisver-md.md)] средой выполнения ASP.NET для каждого уведомления. Установка этого <xref:System.Web.HttpContext.IsPostNotification%2A> свойства приведет к ошибке компиляции.  
  
 В сценариях, где несколько событий <xref:System.Web.HttpApplication> объекта обрабатываются одним обработчиком событий, можно <xref:System.Web.HttpContext.IsPostNotification%2A> использовать <xref:System.Web.RequestNotification> свойство в сочетании с перечислением, чтобы точно определить, где в жизненном цикле приложения текущее запрос —.  
  
 <xref:System.Web.HttpContext.IsPostNotification%2A>вводится в .NET Framework версии 3,5.  Дополнительные сведения см. в статье [Версии и зависимости платформы .NET Framework](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Web.HttpContext.IsPostNotification%2A> свойство, чтобы определить, когда событие <xref:System.Web.HttpApplication> объекта завершило обработку всех связанных обработчиков событий. Обработчик настраиваемых событий в этом примере обрабатывает несколько событий <xref:System.Web.HttpApplication> объекта, <xref:System.Web.HttpContext.IsPostNotification%2A> а свойство используется для определения кода, который вызывается после обработки определенного события.  
  
 [!code-csharp[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Для операции требуется режим интегрированного конвейера в [!INCLUDE[iisver](~/includes/iisver-md.md)] и как минимум платформа .NET Framework 3.0.</exception>
        <altmember cref="P:System.Web.HttpContext.CurrentNotification" />
        <altmember cref="T:System.Web.RequestNotification" />
      </Docs>
    </Member>
    <Member MemberName="IsWebSocketRequest">
      <MemberSignature Language="C#" Value="public bool IsWebSocketRequest { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWebSocketRequest" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsWebSocketRequest" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWebSocketRequest As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWebSocketRequest { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWebSocketRequest : bool" Usage="System.Web.HttpContext.IsWebSocketRequest" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, которое указывает, является ли запрос запросом <see cref="T:System.Web.WebSockets.AspNetWebSocket" />.</summary>
        <value>Значение <see langword="true" />, если запрос является запросом <see cref="T:System.Web.WebSockets.AspNetWebSocket" />; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает `true` значение, если запрос содержит начальное <xref:System.Web.WebSockets.AspNetWebSocket> подтверждение, и `WebSocket` активен модуль служб IIS.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWebSocketRequestUpgrading">
      <MemberSignature Language="C#" Value="public bool IsWebSocketRequestUpgrading { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWebSocketRequestUpgrading" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsWebSocketRequestUpgrading" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWebSocketRequestUpgrading As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWebSocketRequestUpgrading { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWebSocketRequestUpgrading : bool" Usage="System.Web.HttpContext.IsWebSocketRequestUpgrading" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, обновляется ли соединение HTTP до соединения <see cref="T:System.Web.WebSockets.AspNetWebSocket" />.</summary>
        <value>Значение <see langword="true" />, если подключение обновляется; в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Items" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Items" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Items As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IDictionary ^ Items { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Items : System.Collections.IDictionary" Usage="System.Web.HttpContext.Items" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает коллекцию значений и ключей, которая может быть использована для систематизации и обмена данными между интерфейсами <see cref="T:System.Web.IHttpModule" /> и <see cref="T:System.Web.IHttpHandler" /> во время прохождения HTTP-запроса.</summary>
        <value>Коллекция значений и ключей <see cref="T:System.Collections.IDictionary" />, предоставляющая доступ к отдельным значениям в коллекции с помощью указанного ключа.</value>
        <remarks>To be added.</remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms972109.aspx">Важность контекста</related>
      </Docs>
    </Member>
    <Member MemberName="PageInstrumentation">
      <MemberSignature Language="C#" Value="public System.Web.Instrumentation.PageInstrumentationService PageInstrumentation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Instrumentation.PageInstrumentationService PageInstrumentation" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.PageInstrumentation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PageInstrumentation As PageInstrumentationService" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Instrumentation::PageInstrumentationService ^ PageInstrumentation { System::Web::Instrumentation::PageInstrumentationService ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PageInstrumentation : System.Web.Instrumentation.PageInstrumentationService" Usage="System.Web.HttpContext.PageInstrumentation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Instrumentation.PageInstrumentationService</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает ссылку на экземпляр службы инструментирования страниц для данного запроса.</summary>
        <value>Экземпляр службы инструментирования страниц для данного запроса.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviousHandler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler PreviousHandler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler PreviousHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.PreviousHandler" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreviousHandler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ PreviousHandler { System::Web::IHttpHandler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreviousHandler : System.Web.IHttpHandler" Usage="System.Web.HttpContext.PreviousHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Web.IHttpHandler" /> для родительского обработчика.</summary>
        <value>Экземпляр <see cref="T:System.Web.IHttpHandler" /> или значение <see langword="null" />, если предыдущий обработчик не найден.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.PreviousHandler%2A> Свойство соответствует последнему обработчику перед выполнением текущего запроса.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Handler" />
        <altmember cref="P:System.Web.HttpContext.CurrentHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/f540bdeb-d22e-4e1d-ba8a-fe6c9926283b">Общие сведения о HTTP-обработчиках и модулях HTTP</related>
      </Docs>
    </Member>
    <Member MemberName="Profile">
      <MemberSignature Language="C#" Value="public System.Web.Profile.ProfileBase Profile { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Profile.ProfileBase Profile" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Profile" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Profile As ProfileBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Profile::ProfileBase ^ Profile { System::Web::Profile::ProfileBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Profile : System.Web.Profile.ProfileBase" Usage="System.Web.HttpContext.Profile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Profile.ProfileBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Web.Profile.ProfileBase" /> для текущего профиля пользователя.</summary>
        <value>Объект <see cref="T:System.Web.Profile.ProfileBase" />, если файл конфигурации приложения содержит определение для свойств профиля; в противном случае — значение <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.Profile%2A> Свойство используется для постоянного хранения структурированных данных с помощью безопасного типизированного API. Если доступ к свойству отсутствует, но значение отсутствует, возвращается пустой экземпляр. <xref:System.Web.HttpContext.Profile%2A> `null` не возвращается.  
  
 ]]></format>
        </remarks>
        <altmember cref="N:System.Web.Profile" />
      </Docs>
    </Member>
    <Member MemberName="RemapHandler">
      <MemberSignature Language="C#" Value="public void RemapHandler (System.Web.IHttpHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemapHandler(class System.Web.IHttpHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RemapHandler(System.Web.IHttpHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemapHandler (handler As IHttpHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemapHandler(System::Web::IHttpHandler ^ handler);" />
      <MemberSignature Language="F#" Value="member this.RemapHandler : System.Web.IHttpHandler -&gt; unit" Usage="httpContext.RemapHandler handler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="handler">Объект, который обрабатывает запрос.</param>
        <summary>Позволяет указать обработчик запроса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если задано `handler` значение `null`, для обработки запроса используется обработчик по умолчанию. Можно задать `handler` либо асинхронный обработчик, либо синхронный обработчик. Обработчик должен реализовать <xref:System.Web.IHttpHandler> интерфейс.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Web.HttpContext.RemapHandler(System.Web.IHttpHandler)" /> был вызван после того, как произошло событие <see cref="E:System.Web.HttpApplication.MapRequestHandler" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Request">
      <MemberSignature Language="C#" Value="public System.Web.HttpRequest Request { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpRequest Request" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Request" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Request As HttpRequest" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpRequest ^ Request { System::Web::HttpRequest ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Request : System.Web.HttpRequest" Usage="System.Web.HttpContext.Request" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpRequest</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Web.HttpRequest" /> для текущего HTTP-запроса.</summary>
        <value>Объект <see cref="T:System.Web.HttpRequest" /> для текущего HTTP-запроса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство предоставляет программный доступ к свойствам и методам <xref:System.Web.HttpRequest> класса. <xref:System.Web.HttpContext.Request%2A> Так как страницы <xref:System.Web> ASP.NET содержат ссылку на пространство имен (которая <xref:System.Web.HttpContext> содержит класс) по умолчанию, <xref:System.Web.HttpRequest> можно ссылаться на элементы на ASPX-странице, <xref:System.Web.HttpContext>не используя полную ссылку на класс. Например, можно использовать `Request.Browser` для получения возможностей клиентского браузера. Однако если вы хотите использовать члены <xref:System.Web.HttpRequest> из модуля кода программной части ASP.NET, необходимо включить ссылку <xref:System.Web> на пространство имен в модуль и полную ссылку на текущий активный контекст запроса/ответа и класс в <xref:System.Web> , который требуется использовать. Например, на странице кода программной части необходимо указать полное имя `HttpContext.Current.Request.Browser`.  
  
> [!NOTE]
>  ASP.NET выдаст исключение, если вы попытаетесь использовать это свойство, <xref:System.Web.HttpRequest> когда объект недоступен. Например, это будет иметь значение true в методе Application_Start файла Global. asax или в методе, который вызывается из метода Application_Start. В это время HTTP-запрос еще не создан.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Веб-приложение выполняется под управлением IIS 7 в интегрированном режиме.</exception>
      </Docs>
    </Member>
    <Member MemberName="Response">
      <MemberSignature Language="C#" Value="public System.Web.HttpResponse Response { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpResponse Response" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Response" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Response As HttpResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpResponse ^ Response { System::Web::HttpResponse ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Response : System.Web.HttpResponse" Usage="System.Web.HttpContext.Response" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpResponse</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Web.HttpResponse" /> для текущего HTTP-ответа.</summary>
        <value>Объект <see cref="T:System.Web.HttpResponse" /> для текущего HTTP-ответа.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство предоставляет программный доступ к свойствам и методам <xref:System.Web.HttpResponse> класса. <xref:System.Web.HttpContext.Response%2A> Так как страницы <xref:System.Web> ASP.NET содержат ссылку на пространство имен (которая <xref:System.Web.HttpContext> содержит класс) по умолчанию, <xref:System.Web.HttpContext> можно ссылаться на элементы на ASPX-странице, <xref:System.Web.HttpContext>не используя полную ссылку на класс. Например, можно использовать `Response.Write("some output")` для записи выходных данных в поток вывода HTTP. Однако если вы хотите использовать члены <xref:System.Web.HttpResponse> из модуля кода программной части ASP.NET, необходимо включить ссылку <xref:System.Web> на пространство имен в модуль и полную ссылку на текущий активный контекст запроса/ответа и класс в <xref:System.Web> , который вы хотите использовать. Например, на странице кода программной части необходимо указать полное имя `HttpContext.Current.Response.Write("some output")`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Веб-приложение выполняется под управлением IIS 7 в интегрированном режиме.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RewritePath">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Перенаправляет запрос ресурса по пути, отличному от указанного запрошенным URL-адресом. <see cref="Overload:System.Web.HttpContext.RewritePath" /> используется в состоянии сеанса без куки-файлов, чтобы отделять ИД сеансов от URL-адресов.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string -&gt; unit" Usage="httpContext.RewritePath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Внутренний путь перезаписи.</param>
        <summary>Перезаписывает URL-адрес используя заданный путь.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.RewritePath%28System.String%29> Метод перенаправляет запрос ресурса на путь, отличный от пути, указываемого запрошенным URL-адресом. Если необходимо сбросить виртуальный путь таким образом, чтобы запросы от клиента для ресурсов сервера разрешаются правильно, используйте перегрузку этого метода, которая принимает `rebaseClientPath` параметр, и присвойте `false`параметру значение.  
  
 Переписывание URL-адресов полезно, если необходимо изменить структуру страниц веб-приложения и убедиться, что пользователи с закладками прежних URL-адресов смогут продолжать использовать их после перемещения страниц. Переписывание URL-адресов позволяет прозрачно пересылать запросы на новое расположение страницы.  
  
 Если вы хотите разрешить сайту использовать URL-адреса, которые более понятны и оптимизированы для поисковых систем, более надежная альтернатива заключается в использовании маршрутизации ASP.NET. Дополнительные сведения см. в разделе [ASP.NET Routing](https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Web.HttpContext.RewritePath%2A> метод, чтобы разрешить веб-сайту отвечать на URL-адреса, не отражающие структуру файлов на веб-сайте. Первый блок кода — это веб-страница ASP.NET с именем RewritePath. aspx. Для этого требуется строка запроса. Если веб-сайт имеет имя Website1, URL-адрес `http://localhost/WebSite1/RewritePath.aspx?page=1` отображает «стр. 1» в браузере. Блок кода, следующий за веб-страницей, является `Application_BeginRequest` обработчиком событий в файле Global. asax. Этот код перехватывает запросы URL-адресов, `http://localhost/WebSite1/page1` такие как, и преобразует их в форму, необходимую для RewritePath. aspx перед обработкой. Таким образом, URL `http://localhost/WebSite1/page1` -адрес вызывает RewritePath. aspx с параметром строки запроса, который отображает «стр. 1» в браузере. При получении URL-адреса `http://localhost/WebSite1/page1` , такого как, вызывается <xref:System.Web.HttpContext.RewritePath%2A> перегрузка метода, позволяющая <xref:System.Web.HttpRequest.PathInfo%2A> предоставить значение для свойства, а также параметр строки запроса.  
  
 [!code-aspx-csharp[HttpContext_RewritePath#2](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpContext_ReWritePath/CS/rewritepath.aspx#2)]
 [!code-aspx-vb[HttpContext_RewritePath#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpContext_ReWritePath/VB/rewritepath.aspx#2)]  
  
 [!code-csharp[HttpContext_RewritePath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpContext_ReWritePath/CS/global.asax#1)]
 [!code-vb[HttpContext_RewritePath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpContext_ReWritePath/VB/global.asax#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException">Путь, указанный в параметре <paramref name="path" />, отсутствует в корневом каталоге текущего приложения.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Маршрутизация ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b2decba4-2400-491c-8907-89a7b9e0874c">Пошаговое руководство. Использование маршрутизации ASP.NET в приложении Web Forms</related>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string path, bool rebaseClientPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string path, bool rebaseClientPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (path As String, rebaseClientPath As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ path, bool rebaseClientPath);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string * bool -&gt; unit" Usage="httpContext.RewritePath (path, rebaseClientPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="rebaseClientPath" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Внутренний путь перезаписи.</param>
        <param name="rebaseClientPath">Значение <see langword="true" /> для выполнения сброса виртуального пути; значение <see langword="false" /> для того, чтобы оставить виртуальный путь без изменений.</param>
        <summary>Перезаписывает URL-адрес используя заданный путь и логическое значение, которое указывает, был ли изменен виртуальный путь к ресурсам сервера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод вызывается <xref:System.Web.HttpContext.RewritePath%28System.String%29?displayProperty=nameWithType> методом с параметром, для `rebaseClientPath` `true`которого задано значение. <xref:System.Web.HttpContext.RewritePath%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType> Чтобы гарантировать, что виртуальный путь, используемый для создания путей к ресурсам, не изменялся, задайте `rebaseClientPath` для `false`параметра значение. Распространенный сценарий, в котором может потребоваться задать `rebaseClientPath` `false` значение, если требуется переписать URL-адрес, и вы используете темы и перенаправляете URL-адрес ресурса, расположенного в папке, отличной от папки запрошенного ресурса.  
  
 Переписывание URL-адресов полезно, если необходимо изменить структуру страниц веб-приложения и убедиться, что пользователи с закладками прежних URL-адресов смогут продолжать использовать их после перемещения страниц. Переписывание URL-адресов позволяет прозрачно пересылать запросы на новое расположение страницы.  
  
 Если вы хотите разрешить сайту использовать URL-адреса, которые более понятны и оптимизированы для поисковых систем, более надежная альтернатива заключается в использовании маршрутизации ASP.NET. Дополнительные сведения см. в разделе [ASP.NET Routing](https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
   
  
## Examples  
 Пример кода см. в <xref:System.Web.HttpContext.RewritePath%28System.String%29> разделе перегрузка метода.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException">Путь, указанный в параметре <paramref name="path" />, отсутствует в корневом каталоге текущего приложения.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Маршрутизация ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b2decba4-2400-491c-8907-89a7b9e0874c">Пошаговое руководство. Использование маршрутизации ASP.NET в приложении Web Forms</related>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string filePath, string pathInfo, string queryString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string filePath, string pathInfo, string queryString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (filePath As String, pathInfo As String, queryString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ filePath, System::String ^ pathInfo, System::String ^ queryString);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string * string * string -&gt; unit" Usage="httpContext.RewritePath (filePath, pathInfo, queryString)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="pathInfo" Type="System.String" />
        <Parameter Name="queryString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filePath">Внутренний путь перезаписи.</param>
        <param name="pathInfo">Дополнительные сведения о пути для ресурса. Для получения дополнительной информации см. <see cref="P:System.Web.HttpRequest.PathInfo" />.</param>
        <param name="queryString">Строка очереди запросов.</param>
        <summary>Перезаписывает URL-адрес, используя заданный путь, сведения о пути и данные строки запроса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.RewritePath%2A> Метод перенаправляет запрос ресурса на другой ресурс, не изменяя URL-адрес.  
  
 Параметр не включает содержимое `pathInfo`параметра. `filePath` Для URL- http://www.microsoft.com/virdir/page.html/tailадреса `filePath`параметримеет http://www.microsoft.com/virdir/page.htmlзначение, а параметр—хвост.`pathInfo`  
  
 Переписывание URL-адресов полезно, если необходимо изменить структуру страниц веб-приложения и убедиться, что пользователи с закладками прежних URL-адресов смогут продолжать использовать их после перемещения страниц. Переписывание URL-адресов позволяет прозрачно пересылать запросы на новое расположение страницы.  
  
 Если вы хотите разрешить сайту использовать URL-адреса, которые более понятны и оптимизированы для поисковых систем, более надежная альтернатива заключается в использовании маршрутизации ASP.NET. Дополнительные сведения см. в разделе [ASP.NET Routing](https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
   
  
## Examples  
 Пример кода, включая пример перегрузки этого метода, см. в <xref:System.Web.HttpContext.RewritePath%28System.String%29> разделе перегрузка метода.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Путь, указанный в параметре <paramref name="path" />, отсутствует в корневом каталоге текущего приложения.</exception>
        <exception cref="T:System.Web.HttpException">Путь, указанный в параметре <paramref name="filePath" />, отсутствует в корневом каталоге текущего приложения.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Маршрутизация ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b2decba4-2400-491c-8907-89a7b9e0874c">Пошаговое руководство. Использование маршрутизации ASP.NET в приложении Web Forms</related>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string filePath, string pathInfo, string queryString, bool setClientFilePath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string filePath, string pathInfo, string queryString, bool setClientFilePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (filePath As String, pathInfo As String, queryString As String, setClientFilePath As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ filePath, System::String ^ pathInfo, System::String ^ queryString, bool setClientFilePath);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string * string * string * bool -&gt; unit" Usage="httpContext.RewritePath (filePath, pathInfo, queryString, setClientFilePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filePath" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="pathInfo" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="queryString" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="setClientFilePath" Type="System.Boolean" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="filePath">Виртуальный путь к ресурсу, обслуживающему запрос.</param>
        <param name="pathInfo">Дополнительные сведения о пути, используемом для перенаправления URL-адреса. Для получения дополнительной информации см. <see cref="P:System.Web.HttpRequest.PathInfo" />.</param>
        <param name="queryString">Строка очереди запросов для перенаправления URL-адреса.</param>
        <param name="setClientFilePath">Значение <see langword="true" /> для задания пути файла, используемого для ресурсов клиента, для значения параметра <paramref name="filePath" />; в противном случае — значение <see langword="false" />.</param>
        <summary>Перезаписывает URL-адрес используя заданный виртуальный путь, сведения о пути, сведения о строке запроса и логическое значение, которое указывает, был ли задан путь к файлу клиента для пути перезаписи.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр не включает содержимое `pathInfo` параметра. `filePath` Для URL- http://www.microsoft.com/virdir/page.html/tailадреса `filePath`параметримеет http://www.microsoft.com/virdir/page.htmlзначение, а параметр—хвост.`pathInfo`  
  
 Чтобы гарантировать, что виртуальный путь, используемый для создания путей к ресурсам, не изменялся, задайте `setClientFilePath` для `false`параметра значение. Распространенный сценарий, в котором может потребоваться задать `setClientFilePath` `false` значение, если требуется переписать URL-адрес, и вы используете темы и перенаправляете URL-адрес ресурса, расположенного в папке, отличной от папки запрошенного ресурса.  
  
 Переписывание URL-адресов полезно, если необходимо изменить структуру страниц веб-приложения и убедиться, что пользователи с закладками прежних URL-адресов смогут продолжать использовать их после перемещения страниц. Переписывание URL-адресов позволяет прозрачно пересылать запросы на новое расположение страницы.  
  
 Если вы хотите разрешить сайту использовать URL-адреса, которые более понятны и оптимизированы для поисковых систем, более надежная альтернатива заключается в использовании маршрутизации ASP.NET. Дополнительные сведения см. в разделе [ASP.NET Routing](https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
   
  
## Examples  
 Пример кода см. в <xref:System.Web.HttpContext.RewritePath%28System.String%29> разделе перегрузка метода.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Путь, указанный в параметре <paramref name="path" />, отсутствует в корневом каталоге текущего приложения.</exception>
        <exception cref="T:System.Web.HttpException">Путь, указанный в параметре <paramref name="filePath" />, отсутствует в корневом каталоге текущего приложения.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Маршрутизация ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b2decba4-2400-491c-8907-89a7b9e0874c">Пошаговое руководство. Использование маршрутизации ASP.NET в приложении Web Forms</related>
      </Docs>
    </Member>
    <Member MemberName="Server">
      <MemberSignature Language="C#" Value="public System.Web.HttpServerUtility Server { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpServerUtility Server" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Server" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Server As HttpServerUtility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpServerUtility ^ Server { System::Web::HttpServerUtility ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Server : System.Web.HttpServerUtility" Usage="System.Web.HttpContext.Server" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpServerUtility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Web.HttpServerUtility" />, предоставляющий методы, используемые при обработке веб-запросов.</summary>
        <value>Объект <see cref="T:System.Web.HttpServerUtility" /> для текущего HTTP-запроса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство предоставляет программный доступ к свойствам и методам <xref:System.Web.HttpServerUtility> класса. <xref:System.Web.HttpContext.Server%2A> Так как страницы <xref:System.Web> ASP.NET содержат ссылку на пространство имен (которая <xref:System.Web.HttpContext> содержит класс) по умолчанию, <xref:System.Web.HttpContext> можно ссылаться на элементы на ASPX-странице, <xref:System.Web.HttpContext>не используя полную ссылку на класс. Например, можно использовать `Server.CreateObject("MyCOMComponent")` для создания экземпляра COM-объекта на сервере. Однако если вы хотите использовать члены <xref:System.Web.HttpServerUtility> из модуля кода программной части ASP.NET, необходимо включить ссылку <xref:System.Web> на пространство имен в модуль и полную ссылку на текущий активный контекст запроса/ответа и класс в <xref:System.Web> , который требуется использовать. Например, на странице кода программной части необходимо указать полное имя `HttpContext.Current.Server.CreateObject("MyCOMComponent")`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Session">
      <MemberSignature Language="C#" Value="public System.Web.SessionState.HttpSessionState Session { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.SessionState.HttpSessionState Session" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Session" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Session As HttpSessionState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::SessionState::HttpSessionState ^ Session { System::Web::SessionState::HttpSessionState ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Session : System.Web.SessionState.HttpSessionState" Usage="System.Web.HttpContext.Session" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.SessionState.HttpSessionState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Web.SessionState.HttpSessionState" /> для текущего HTTP-запроса.</summary>
        <value>Объект <see cref="T:System.Web.SessionState.HttpSessionState" /> для текущего HTTP-запроса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство предоставляет программный доступ к свойствам и методам <xref:System.Web.SessionState.HttpSessionState> класса. <xref:System.Web.HttpContext.Session%2A>  
  
 Чтобы использовать состояние сеанса, его необходимо включить. Сведения о том, как включить состояние сеанса, см. в разделе **Настройка состояния** сеанса в [обзоре состояния сеанса ASP.NET](https://msdn.microsoft.com/library/6d60d381-6521-4e1d-9089-da6464f2a9bc).  
  
 Сведения о том, как сохранять значения в состоянии сеанса, см [. в разделе как Сохранение значений в состоянии](https://msdn.microsoft.com/library/a6cb2e3a-df49-4b12-9d9a-eed45541c165)сеанса. Сведения о том, как считывать значения из состояния сеанса, см [. в разделе как Считывает значения из состояния](https://msdn.microsoft.com/library/2ef449bc-5c17-4785-b7cf-378c601af8f5)сеанса.  
  
   
  
## Examples  
 В следующих примерах показано, как сохранять значения в состоянии сеанса и считывать значения из состояния сеанса.  
  
 Для этих примеров требуются:  
  
-   Приложение ASP.NET с включенным состоянием сеанса.  
  
-   Класс страницы Web Forms, имеющий доступ <xref:System.Web.UI.Page.Session%2A?displayProperty=nameWithType> к свойству, или любой класс, имеющий доступ <xref:System.Web.HttpContext.Current%2A?displayProperty=nameWithType> к свойству.  
  
```csharp  
string firstName = "Jeff";  
string lastName = "Smith";  
string city = "Seattle";  
  
// Save to session state in a Web Forms page class.  
Session["FirstName"] = firstName;  
Session["LastName"] = lastName;  
Session["City"] = city;  
  
// Read from session state in a Web Forms page class.  
firstName = (string)(Session["FirstName"]);  
lastName = (string)(Session["LastName"]);  
city = (string)(Session["City"]);  
  
// Outside of Web Forms page class, use HttpContext.Current.  
HttpContext context = HttpContext.Current;  
context.Session["FirstName"] = firstName;  
firstName = (string)(context.Session["FirstName"]);  
  
```  
  
```vb  
Dim firstName As String = "Jeff"  
Dim lastName As String = "Smith"  
Dim city As String = "Seattle"  
  
' Save to session state in a Web Forms page class.  
Session("FirstName") = firstName  
Session("LastName") = lastName  
Session("City") = city  
  
' Read from session state in a Web Forms page class.  
firstName = DirectCast(Session("FirstName"), String)  
lastName = DirectCast(Session("LastName"), String)  
city = DirectCast(Session("City"), String)  
  
' Outside of Web Forms page class, use HttpContext.Current.  
Dim context As HttpContext = HttpContext.Current  
context.Session("FirstName") = firstName  
firstName = DirectCast(context.Session("FirstName"), String)  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSessionStateBehavior">
      <MemberSignature Language="C#" Value="public void SetSessionStateBehavior (System.Web.SessionState.SessionStateBehavior sessionStateBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSessionStateBehavior(valuetype System.Web.SessionState.SessionStateBehavior sessionStateBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.SetSessionStateBehavior(System.Web.SessionState.SessionStateBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSessionStateBehavior(System::Web::SessionState::SessionStateBehavior sessionStateBehavior);" />
      <MemberSignature Language="F#" Value="member this.SetSessionStateBehavior : System.Web.SessionState.SessionStateBehavior -&gt; unit" Usage="httpContext.SetSessionStateBehavior sessionStateBehavior" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionStateBehavior" Type="System.Web.SessionState.SessionStateBehavior" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sessionStateBehavior">Одно из значений перечисления задает, какой тип поведения состояния сеанса требуется.</param>
        <summary>Задает тип поведения состояния сеанса, который необходим для поддержки HTTP-запроса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В реализации ASP.NET по умолчанию обработчик HTTP-запросов указывает, требуется ли состояние сеанса путем реализации <xref:System.Web.SessionState.IRequiresSessionState> интерфейса <xref:System.Web.SessionState.IReadOnlySessionState> или интерфейса. <xref:System.Web.HttpContext.SetSessionStateBehavior%2A> Метод<xref:System.Web.SessionState.SessionStateBehavior> и перечисление позволяют предоставить дополнительные сведения о том, какой тип поддержки состояния сеанса необходим для выполнения запроса. Дополнительные сведения см. в описании перечисления <xref:System.Web.SessionState.SessionStateBehavior>.  
  
 Метод должен вызываться <xref:System.Web.HttpApplication.AcquireRequestState> перед событием конвейера. <xref:System.Web.HttpContext.SetSessionStateBehavior%2A> Вызовы, происходящие во время или после этого события, <xref:System.InvalidOperationException> вызывают исключение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод был вызван после того, как произошло событие <see cref="E:System.Web.HttpApplication.AcquireRequestState" />.</exception>
        <altmember cref="T:System.Web.SessionState.SessionStateBehavior" />
      </Docs>
    </Member>
    <Member MemberName="SkipAuthorization">
      <MemberSignature Language="C#" Value="public bool SkipAuthorization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SkipAuthorization" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.SkipAuthorization" />
      <MemberSignature Language="VB.NET" Value="Public Property SkipAuthorization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SkipAuthorization { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SkipAuthorization : bool with get, set" Usage="System.Web.HttpContext.SkipAuthorization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, определяющее, должен ли объект <see cref="T:System.Web.Security.UrlAuthorizationModule" /> пропускать проверку подлинности текущего запроса.</summary>
        <value>Значение <see langword="true" />, если объект <see cref="T:System.Web.Security.UrlAuthorizationModule" /> должен пропускать проверку подлинности; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.SkipAuthorization%2A> Свойство предназначено для расширенного использования модулями проверки подлинности, которым необходимо перенаправить на страницу, допускающую анонимные соединения. Модуль проверки подлинности с помощью форм и модуль <xref:System.Web.HttpContext.SkipAuthorization%2A> проверки подлинности паспорта устанавливаются при перенаправлении на настроенную страницу входа. <xref:System.Web.HttpContext.SkipAuthorization%2A> Параметр`ControlPrincipal` требует установки флага. Дополнительные сведения об этом `ControlPrincipal` флаге см <xref:System.Security.Permissions.SecurityPermissionFlag>. в разделе.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IServiceProvider.GetService">
      <MemberSignature Language="C#" Value="object IServiceProvider.GetService (Type service);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IServiceProvider.GetService(class System.Type service) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.System#IServiceProvider#GetService(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Function GetService (service As Type) As Object Implements IServiceProvider.GetService" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IServiceProvider.GetService(Type ^ service) = IServiceProvider::GetService;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IServiceProvider.GetService(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="service">Тип службы <see cref="T:System.Web.HttpContext" />, необходимый для задания поставщика услуг.</param>
        <summary>Возвращает объект текущего типа службы.</summary>
        <returns>Объект <see cref="T:System.Web.HttpContext" />; в противном случае — значение <see langword="null" />, если служба не найдена.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод полезен для получения доступа к базовому <xref:System.Web.HttpWorkerRequest> объекту.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ThreadAbortOnTimeout">
      <MemberSignature Language="C#" Value="public bool ThreadAbortOnTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ThreadAbortOnTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.ThreadAbortOnTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ThreadAbortOnTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ThreadAbortOnTimeout { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ThreadAbortOnTimeout : bool with get, set" Usage="System.Web.HttpContext.ThreadAbortOnTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, должна ли исполняющая среда ASP.NET вызывать метод <see cref="M:System.Threading.Thread.Abort" /> в потоке, обслуживающем этот запрос, при истечении времени ожидания для запроса.</summary>
        <value><see langword="true" /> если будет вызван метод <see cref="M:System.Threading.Thread.Abort" />, когда истекает время ожидания потока; в противном случае – значение <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В обработчиках и модулях, использующих <xref:System.Web.HttpRequest.TimedOutToken%2A?displayProperty=nameWithType> свойство для реализации совместной отмены, может потребоваться <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> отключить поведение, которое ASP.NET выполняет по умолчанию при истечении времени ожидания запроса. Установка этого свойства в `false` может помочь гарантировать, что программы отмены и очистки будут выполняться без прерывания ASP.NET.  
  
 Если задать для `false`этого свойства значение, ASP.NET не будет автоматически отображать страницу ошибки "время ожидания запроса" в случае истечения времени ожидания. Приложение несет ответственность за установку содержимого ответа соответствующим образом.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Timestamp">
      <MemberSignature Language="C#" Value="public DateTime Timestamp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Timestamp" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Timestamp" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Timestamp As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime Timestamp { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.Timestamp : DateTime" Usage="System.Web.HttpContext.Timestamp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает исходную отметку времени текущего HTTP-запроса.</summary>
        <value>Отметка времени текущего HTTP-запроса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Отметка времени, возвращаемая <xref:System.Web.HttpContext.Timestamp%2A> свойством, является местным временем сервера и задается во время создания экземпляра <xref:System.Web.HttpContext> объекта. Местное время равно времени UTC и смещению UTC.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trace">
      <MemberSignature Language="C#" Value="public System.Web.TraceContext Trace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.TraceContext Trace" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Trace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Trace As TraceContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::TraceContext ^ Trace { System::Web::TraceContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Trace : System.Web.TraceContext" Usage="System.Web.HttpContext.Trace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.TraceContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Web.TraceContext" /> для текущего HTTP-ответа.</summary>
        <value>Объект <see cref="T:System.Web.TraceContext" /> для текущего HTTP-ответа.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="User">
      <MemberSignature Language="C#" Value="public System.Security.Principal.IPrincipal User { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IPrincipal User" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.User" />
      <MemberSignature Language="VB.NET" Value="Public Property User As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::IPrincipal ^ User { System::Security::Principal::IPrincipal ^ get(); void set(System::Security::Principal::IPrincipal ^ value); };" />
      <MemberSignature Language="F#" Value="member this.User : System.Security.Principal.IPrincipal with get, set" Usage="System.Web.HttpContext.User" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает сведения о безопасности для текущего HTTP-запроса.</summary>
        <value>Сведения о безопасности для текущего HTTP-запроса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство предоставляет программный доступ к свойствам и методам <xref:System.Security.Principal.IPrincipal> интерфейса. <xref:System.Web.HttpContext.User%2A>  
  
 Так как страницы <xref:System.Web> ASP.NET содержат ссылку на пространство имен (которая <xref:System.Web.HttpContext> содержит класс) по умолчанию, <xref:System.Web.HttpContext> можно ссылаться на элементы на ASPX-странице, <xref:System.Web.HttpContext>не используя полную ссылку на класс. Например, можно использовать `User.Identity.Name` для получения имени пользователя, от имени которого выполняется текущий процесс. Однако если вы хотите использовать члены <xref:System.Security.Principal.IPrincipal> из модуля кода программной части ASP.NET, необходимо включить ссылку <xref:System.Web> на пространство имен в модуль и полную ссылку на текущий активный контекст запроса/ответа и класс в <xref:System.Web> , который требуется использовать. Например, на странице кода программной части необходимо указать полное имя `HttpContext.Current.User.Identity.Name`.  
  
   
  
## Examples  
 В следующем примере показано, как получить доступ к свойствам текущего пользователя с <xref:System.Web.HttpContext.User%2A> помощью свойства. Эти свойства используются для задания заголовка веб-страницы.  
  
 Если приложение использует проверку подлинности Windows, имя пользователя включает домен. Например, заголовок страницы будет иметь вид «Домашняя страница для домен \ имя_пользователя».  
  
 [!code-csharp[System.Web.HttpContext.User#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpContext.User/cs/Default.aspx.cs#1)]
 [!code-vb[System.Web.HttpContext.User#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpContext.User/vb/Default.aspx.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="/aspnet/mvc/overview/older-versions/using-oauth-providers-with-mvc">Использование поставщиков OAuth с MVC 4</related>
        <related type="ExternalDocumentation" href="/aspnet/web-forms/overview/getting-started/getting-started-with-aspnet-45-web-forms/checkout-and-payment-with-paypal">Начало работы с помощью веб-форм ASP.NET 4,5 — Оформление и оплата с помощью PayPal</related>
        <related type="ExternalDocumentation" href="/aspnet/mvc/overview/older-versions-1/nerddinner/secure-applications-using-authentication-and-authorization">NerdDinner. Защита приложений с помощью проверки подлинности и авторизации</related>
      </Docs>
    </Member>
    <Member MemberName="WebSocketNegotiatedProtocol">
      <MemberSignature Language="C#" Value="public string WebSocketNegotiatedProtocol { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebSocketNegotiatedProtocol" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.WebSocketNegotiatedProtocol" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebSocketNegotiatedProtocol As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ WebSocketNegotiatedProtocol { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebSocketNegotiatedProtocol : string" Usage="System.Web.HttpContext.WebSocketNegotiatedProtocol" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает согласованный протокол, который был отправлен от сервера клиенту для соединения <see cref="T:System.Web.WebSockets.AspNetWebSocket" />.</summary>
        <value>Согласованный протокол.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WebSocketRequestedProtocols">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;string&gt; WebSocketRequestedProtocols { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;string&gt; WebSocketRequestedProtocols" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.WebSocketRequestedProtocols" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebSocketRequestedProtocols As IList(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::String ^&gt; ^ WebSocketRequestedProtocols { System::Collections::Generic::IList&lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebSocketRequestedProtocols : System.Collections.Generic.IList&lt;string&gt;" Usage="System.Web.HttpContext.WebSocketRequestedProtocols" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает упорядоченный список протоколов, запрашиваемых клиентом.</summary>
        <value>Запрошенные протоколы или значение <see langword="null" />, если это не запрос <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> или если список не существует.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
