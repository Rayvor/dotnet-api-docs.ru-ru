<Type Name="HttpResponse" FullName="System.Web.HttpResponse">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f9107f5d6488ee6167f6ba9ccbfefca02b9f561f" /><Meta Name="ms.sourcegitcommit" Value="0084afad1b3b1cb2c8ad2c142ae3597d08bad4a7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="10/31/2019" /><Meta Name="ms.locfileid" Value="73398854" /></Metadata><TypeSignature Language="C#" Value="public sealed class HttpResponse" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpResponse extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpResponse" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpResponse" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpResponse sealed" />
  <TypeSignature Language="F#" Value="type HttpResponse = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Инкапсулирует данные ответа HTTP, полученные при выполнении операции ASP.NET.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Методы и свойства класса <xref:System.Web.HttpResponse> предоставляются через свойство <xref:System.Web.HttpApplication.Response%2A> классов <xref:System.Web.HttpApplication>, <xref:System.Web.HttpContext>, <xref:System.Web.UI.Page>и <xref:System.Web.UI.UserControl>.  
  
 Следующие методы класса <xref:System.Web.HttpResponse> поддерживаются только в сценариях обратной передачи, а не в сценариях асинхронной обратной передачи:  
  
-   <xref:System.Web.HttpResponse.BinaryWrite%2A>  
  
-   <xref:System.Web.HttpResponse.Clear%2A>  
  
-   <xref:System.Web.HttpResponse.ClearContent%2A>  
  
-   <xref:System.Web.HttpResponse.ClearHeaders%2A>  
  
-   <xref:System.Web.HttpResponse.Close%2A>  
  
-   <xref:System.Web.HttpResponse.End%2A>  
  
-   <xref:System.Web.HttpResponse.Flush%2A>  
  
-   <xref:System.Web.HttpResponse.TransmitFile%2A>  
  
-   <xref:System.Web.HttpResponse.Write%2A>  
  
-   <xref:System.Web.HttpResponse.WriteFile%2A>  
  
-   <xref:System.Web.HttpResponse.WriteSubstitution%2A>  
  
 Частичное обновление страницы включается при использовании <xref:System.Web.UI.UpdatePanel> элементов управления для обновления выбранных областей страницы вместо обновления всей страницы с обратной записью. Дополнительные сведения см. в разделе [Общие сведения об элементе управления UpdatePanel](https://msdn.microsoft.com/library/29a2265d-9674-4c19-b70e-e5560ee9689a) и [Общие сведения о частичной отрисовке страниц](https://msdn.microsoft.com/library/5c12736d-d9e9-464a-9388-3fe0f9f49e49).  
  
   
  
## Examples  
 В следующем примере рисуются три перекрывающихся прямоугольника при запросе страницы. Код начинается с присвоения свойству <xref:System.Web.HttpResponse.ContentType%2A> значения Image/JPEG, чтобы вся страница отображалась как изображение в формате JPEG. Затем код вызывает метод <xref:System.Web.HttpResponse.Clear%2A>, чтобы предотвратить отправку лишнего содержимого с этим ответом. Затем код задает для свойства <xref:System.Web.HttpResponse.BufferOutput%2A> значение true, чтобы страница полностью обрабатывалась перед отправкой запрашивающему клиенту. Затем создаются два объекта, используемые для рисования прямоугольников: <xref:System.Drawing.Bitmap> и <xref:System.Drawing.Graphics>. Переменные, созданные на странице, используются в качестве координат для рисования прямоугольников и строки, которая отображается внутри самого крупного прямоугольника.  
  
 Когда рисуются три прямоугольника и строка, отображаемая внутри них, <xref:System.Drawing.Bitmap> сохраняется в объект <xref:System.IO.Stream>, связанный со свойством <xref:System.Web.HttpResponse.OutputStream%2A>, а его формат имеет значение JPEG. Код вызывает методы <xref:System.Drawing.Image.Dispose%2A> и <xref:System.Drawing.Graphics.Dispose%2A> для освобождения ресурсов, используемых двумя графическими объектами. Наконец, код вызывает метод <xref:System.Web.HttpResponse.Flush%2A> для отправки буферизованного ответа запрашивающему клиенту.  
  
> [!NOTE]
>  В коде на объект <xref:System.Web.HttpResponse> ссылается ключевое слово `Response`. Например, `Response.Clear()` ссылается на метод <xref:System.Web.HttpResponse.Clear%2A?displayProperty=nameWithType>. Класс <xref:System.Web.UI.Page> имеет свойство с именем <xref:System.Web.UI.Page.Response%2A>, которое предоставляет текущий экземпляр <xref:System.Web.HttpResponse>.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpResponse (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.#ctor(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpResponse(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpResponse : System.IO.TextWriter -&gt; System.Web.HttpResponse" Usage="new System.Web.HttpResponse writer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Объект <see cref="T:System.IO.TextWriter" />, который разрешает пользовательские выходные данные HTTP.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Web.HttpResponse" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный член предназначен для поддержки платформы .NET Framework и не должен вызываться напрямую из кода приложения.  
  
 Методы и свойства класса <xref:System.Web.HttpResponse> предоставляются через встроенный объект <xref:System.Web.HttpContext.Response%2A> в ASP.NET.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCacheDependency">
      <MemberSignature Language="C#" Value="public void AddCacheDependency (params System.Web.Caching.CacheDependency[] dependencies);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheDependency(class System.Web.Caching.CacheDependency[] dependencies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheDependency(System.Web.Caching.CacheDependency[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheDependency (ParamArray dependencies As CacheDependency())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheDependency(... cli::array &lt;System::Web::Caching::CacheDependency ^&gt; ^ dependencies);" />
      <MemberSignature Language="F#" Value="member this.AddCacheDependency : System.Web.Caching.CacheDependency[] -&gt; unit" Usage="httpResponse.AddCacheDependency dependencies" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencies" Type="System.Web.Caching.CacheDependency[]" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="dependencies">Файл, ключ кэша или объект <see cref="T:System.Web.Caching.CacheDependency" /> для добавления в список зависимостей приложения.</param>
        <summary>Связывает набор зависимостей кэша с ответом, чтобы упростить переход ответа в недействительное состояние, если он хранится в выходном кэше и указанные зависимости изменяются.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Web.HttpResponse.AddCacheDependency%2A> позволяет создавать зависимости между кэшированными ответами и объектом <xref:System.Web.Caching.CacheDependency>.  
  
   
  
## Examples  
 В следующем примере показано, как создать зависимость кэша с помощью метода <xref:System.Web.HttpResponse.AddCacheDependency%2A> и объекта <xref:System.Web.Caching.CacheDependency>.  
  
 [!code-aspx-csharp[HttpResponse.AddCacheDependency#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpResponse.AddCacheDependency/CS/httpresponse.addcachedependency_cs.aspx#1)]
 [!code-aspx-vb[HttpResponse.AddCacheDependency#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpResponse.AddCacheDependency/VB/httpresponse.addcachedependency_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="dependencies" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Этот метод был вызван слишком поздно в конвейере обработки кэша, после того, как кэшированный ответ уже был создан.</exception>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">Кэширование страниц ASP.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddCacheItemDependencies">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ставит допустимость кэшированного ответа в зависимость от других элементов кэша.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddCacheItemDependencies">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependencies (System.Collections.ArrayList cacheKeys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependencies(class System.Collections.ArrayList cacheKeys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependencies(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependencies (cacheKeys As ArrayList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependencies(System::Collections::ArrayList ^ cacheKeys);" />
      <MemberSignature Language="F#" Value="member this.AddCacheItemDependencies : System.Collections.ArrayList -&gt; unit" Usage="httpResponse.AddCacheItemDependencies cacheKeys" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKeys" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="cacheKeys">Объект <see cref="T:System.Collections.ArrayList" />, содержащий ключи элементов, от которых зависит текущий кэшированный ответ.</param>
        <summary>Ставит допустимость кэшированного ответа в зависимость от других элементов кэша.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда элементы, на которые ссылается параметр `cacheKeys`, удаляются из кэша, кэшированный ответ текущего элемента является недопустимым.  
  
   
  
## Examples  
 В следующем примере показано, как использовать ASP.NET страницу с кэшированным выходом. Код страницы создает <xref:System.Collections.ArrayList> объект ключей, связанных с элементами, хранящимися в объекте <xref:System.Web.Caching.Cache>. Затем код передает <xref:System.Collections.ArrayList> в качестве параметра в вызове метода <xref:System.Web.HttpResponse.AddCacheItemDependencies%2A>. При этом выводимый кэшированный ответ становится недействительным, если какие либо файлы, указанные в <xref:System.Collections.ArrayList>, изменятся.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/cacheitemsdepscs.aspx#5)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/cacheitemsdepsvb.aspx#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">Кэширование страниц ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="AddCacheItemDependencies">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependencies (string[] cacheKeys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependencies(string[] cacheKeys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependencies(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependencies (cacheKeys As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependencies(cli::array &lt;System::String ^&gt; ^ cacheKeys);" />
      <MemberSignature Language="F#" Value="member this.AddCacheItemDependencies : string[] -&gt; unit" Usage="httpResponse.AddCacheItemDependencies cacheKeys" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKeys" Type="System.String[]" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="cacheKeys">Массив ключей элементов, от которых зависит данный кэшированный ответ.</param>
        <summary>Ставит допустимость кэшированного элемента в зависимость от других элементов кэша.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если какие-либо из `cacheKey`удаляются из кэша, кэшированный ответ текущего элемента является недопустимым.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">Кэширование страниц ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="AddCacheItemDependency">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependency (string cacheKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependency(string cacheKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependency(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependency (cacheKey As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependency(System::String ^ cacheKey);" />
      <MemberSignature Language="F#" Value="member this.AddCacheItemDependency : string -&gt; unit" Usage="httpResponse.AddCacheItemDependency cacheKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="cacheKey">Ключ элемента, от которого зависит кэшированный ответ.</param>
        <summary>Ставит допустимость кэшированного ответа в зависимость от другого элемента кэша.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда элемент, соответствующий параметру `cacheKey`, удаляется из кэша, кэшированный ответ текущего элемента является недопустимым.  
  
   
  
## Examples  
 В следующем примере показан пользовательский элемент управления ASP.NET, который является кэшированным выходом. Код элемента управления вызывает метод <xref:System.Web.HttpResponse.AddCacheItemDependency%2A> с ключом элемента, хранящегося в <xref:System.Web.Caching.Cache> объекте, переданном в качестве параметра. Если элемент не существует в кэше, ответ элемента управления, хранящийся в кэше вывода, становится недействительным. Это означает, что при последующем запросе новая версия ответа элемента управления будет добавлена в кэш вывода.  
  
 Затем код проверяет, хранится ли элемент, связанный с `bookData`ным ключом, в `Cache` объекте и отображает одну из двух строк текста, зависящих от результата. Затем в коде задается свойство <xref:System.Web.UI.WebControls.BaseDataList.DataSource%2A> элемента управления <xref:System.Web.UI.WebControls.DataGrid>, имя которого называется `dgBooks`, с вызовом пользовательского метода Shared `GetBookData` класса `DataHelper` и заполняет <xref:System.Web.UI.WebControls.DataGrid> методом <xref:System.Web.UI.Control.DataBind%2A>.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/bookscs.ascx#3)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/booksvb.ascx#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.AddCacheItemDependency(System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">Кэширование страниц ASP.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddFileDependencies">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Добавляет группу имен файлов в коллекцию имен файлов, от которой зависит текущий ответ.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddFileDependencies">
      <MemberSignature Language="C#" Value="public void AddFileDependencies (System.Collections.ArrayList filenames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependencies(class System.Collections.ArrayList filenames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependencies(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependencies (filenames As ArrayList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependencies(System::Collections::ArrayList ^ filenames);" />
      <MemberSignature Language="F#" Value="member this.AddFileDependencies : System.Collections.ArrayList -&gt; unit" Usage="httpResponse.AddFileDependencies filenames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filenames" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="filenames">Добавляемая коллекция файлов.</param>
        <summary>Добавляет группу имен файлов в коллекцию имен файлов, от которой зависит текущий ответ.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере показана ASP.NET страница с кэшированием выходных данных. Код страницы создает <xref:System.Collections.ArrayList> путей к файлам, а затем передает <xref:System.Collections.ArrayList> в качестве параметра в вызове метода <xref:System.Web.HttpResponse.AddFileDependencies%2A>. Это сделает выходной кэшированный ответ недействительным при изменении любого файла, указанного в <xref:System.Collections.ArrayList>.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#6](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/responsefiledepscs.aspx#6)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/responsefiledepsvb.aspx#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">Кэширование страниц ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="AddFileDependencies">
      <MemberSignature Language="C#" Value="public void AddFileDependencies (string[] filenames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependencies(string[] filenames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependencies(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependencies (filenames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependencies(cli::array &lt;System::String ^&gt; ^ filenames);" />
      <MemberSignature Language="F#" Value="member this.AddFileDependencies : string[] -&gt; unit" Usage="httpResponse.AddFileDependencies filenames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filenames" Type="System.String[]" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="filenames">Добавляемый массив файлов.</param>
        <summary>Добавляет массив имен файлов в коллекцию имен файлов, от которой зависит текущий ответ.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере массив имен файлов добавляется в список зависимостей файлов <xref:System.Web.HttpResponse.AddFileDependencies%2A>. Если файлы изменяются, кэшированный ответ становится недействительным.  
  
 [!code-aspx-csharp[Response.AddFileDependency#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Response.AddFileDependency/CS/addfiledependency_cs.aspx#1)]
 [!code-aspx-vb[Response.AddFileDependency#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Response.AddFileDependency/VB/addfiledependency_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">Кэширование страниц ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="AddFileDependency">
      <MemberSignature Language="C#" Value="public void AddFileDependency (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependency(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependency(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependency (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependency(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="member this.AddFileDependency : string -&gt; unit" Usage="httpResponse.AddFileDependency filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Имя добавляемого файла.</param>
        <summary>Добавляет имя файла в коллекцию имен файлов, от которой зависит текущий ответ.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании метода <xref:System.Web.HttpResponse.AddFileDependency%2A> для добавления зависимости файлов необходимо также указать кэширование вывода программно или декларативно. Например, чтобы декларативно указать кэширование выходных данных, используйте директиву [@ OutputCache](https://msdn.microsoft.com/library/28a9e101-fb44-4198-9cb6-b8a52312fec2) . Дополнительные сведения см. [в разделе инструкции. кэширование выходных данных страницы с помощью зависимостей файлов](https://msdn.microsoft.com/library/95ad1c54-329e-45af-9343-a03a1d2ce9db).  
  
   
  
## Examples  
 В следующем примере показано, как добавить одно имя файла в список зависимостей файлов <xref:System.Web.HttpResponse.AddFileDependency%2A>. Если файл изменяется, кэшированный ответ становится недействительным.  
  
 [!code-csharp[Classic HttpResponse.AddFileDependency Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AddFileDependency Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AddFileDependency Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AddFileDependency Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">Кэширование страниц ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="AddHeader">
      <MemberSignature Language="C#" Value="public void AddHeader (string name, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHeader(string name, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddHeader(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHeader (name As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHeader(System::String ^ name, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AddHeader : string * string -&gt; unit" Usage="httpResponse.AddHeader (name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Имя заголовка HTTP, к которому добавляется <paramref name="value" />.</param>
        <param name="value">Строка, которую требуется добавить в заголовок.</param>
        <summary>Добавляет заголовок НТТР в поток вывода. Свойство <see cref="M:System.Web.HttpResponse.AddHeader(System.String,System.String)" /> обеспечивает совместимость с предыдущими версиями ASP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.AddHeader%2A> совпадает с <xref:System.Web.HttpResponse.AppendHeader%2A> и предоставляется только для совместимости с более ранними версиями ASP. С помощью ASP.NET используйте <xref:System.Web.HttpResponse.AppendHeader%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOnSendingHeaders">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken AddOnSendingHeaders (Action&lt;System.Web.HttpContext&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken AddOnSendingHeaders(class System.Action`1&lt;class System.Web.HttpContext&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddOnSendingHeaders(System.Action{System.Web.HttpContext})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOnSendingHeaders (callback As Action(Of HttpContext)) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ AddOnSendingHeaders(Action&lt;System::Web::HttpContext ^&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="member this.AddOnSendingHeaders : Action&lt;System.Web.HttpContext&gt; -&gt; System.Web.ISubscriptionToken" Usage="httpResponse.AddOnSendingHeaders callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Web.HttpContext&gt;" Index="0" FrameworkAlternate="netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">Метод обратного вызова.</param>
        <summary>Регистрирует обратный вызов, который среда выполнения ASP.NET будет вызывать непосредственно перед отправкой заголовков ответа для этого запроса.</summary>
        <returns>Объект <see cref="T:System.Web.ISubscriptionToken" />, который представляет подписку на псевдособытие OnSendingHeaders.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Метод AddOnSendingHeaders не вызывается, если собственный модуль сначала очищает ответ.  
  
 Псевдо-событие Псевдособытие onsendingheaders отличается от события конвейера уровня IHttpModule в том, что это подписка на запрос, а не Подписка на приложение. Цель состоит в том, что обратный вызов может изменить код состояния ответа или задать файл cookie или заголовок ответа. Другие замечания по использованию и предостережения:  
  
-   Этот метод эффективен только в том случае, если службы IIS работают в конвейерном режиме интегрированного конвейера и только если заголовки ответа еще не были отправлены для текущего запроса.  
  
-   Среда выполнения ASP.NET не гарантирует каких-либо сведений о потоке, в котором вызывается обратный вызов. Например, обратный вызов может быть вызван синхронно в фоновом потоке, если выполняется фоновая очистка. <xref:System.Web.HttpContext.Current%2A> не гарантируется доступность в таком потоке.  
  
-   Обратный вызов не должен вызывать метод, который управляет телом объекта ответа или приводит к сбросу. Например, обратный вызов не должен вызывать <xref:System.Web.HttpResponse.Redirect%2A>, так как этот метод может управлять телом объекта ответа.  
  
-   Обратный вызов должен содержать только короткий синхронный код. Попытка вызвать асинхронную операцию или дождаться такой операции может привести к взаимоблокировке.  
  
-   Обратный вызов не должен вызывать исключение. в противном случае поведение не определено.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendCookie">
      <MemberSignature Language="C#" Value="public void AppendCookie (System.Web.HttpCookie cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendCookie(class System.Web.HttpCookie cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendCookie(System.Web.HttpCookie)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendCookie (cookie As HttpCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendCookie(System::Web::HttpCookie ^ cookie);" />
      <MemberSignature Language="F#" Value="member this.AppendCookie : System.Web.HttpCookie -&gt; unit" Usage="httpResponse.AppendCookie cookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Web.HttpCookie" />
      </Parameters>
      <Docs>
        <param name="cookie"><see cref="T:System.Web.HttpCookie" /> для добавления в поток вывода.</param>
        <summary>Добавляет файл Cookie HTTP во встроенную коллекцию файлов Cookie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере создается новый файл cookie с именем `LastVisit`, в качестве значения файла cookie устанавливается текущая дата и время, а затем файл cookie добавляется в текущую коллекцию файлов cookie. Все файлы cookie в коллекции файлов cookie отправляются клиенту в заголовке `Set-Cookie` с выходным потоком HTTP.  
  
 [!code-csharp[Classic HttpResponse.AppendCookie Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AppendCookie Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AppendCookie Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AppendCookie Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Файл Cookie добавляется после отправки заголовков HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendHeader">
      <MemberSignature Language="C#" Value="public void AppendHeader (string name, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendHeader(string name, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendHeader(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendHeader (name As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendHeader(System::String ^ name, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AppendHeader : string * string -&gt; unit" Usage="httpResponse.AppendHeader (name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Имя заголовка НТТР, который добавляется в поток вывода.</param>
        <param name="value">Строка, которую требуется добавить в заголовок.</param>
        <summary>Добавляет заголовок НТТР в поток вывода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании метода <xref:System.Web.HttpResponse.AppendHeader%2A> для отправки заголовков, относящихся к кэшу, и одновременного использования объектной модели кэша (<xref:System.Web.HttpResponse.Cache%2A>) для установки политики кэша, HTTP-заголовки ответа, относящиеся к кэшированию (`Cache-Control`, `Expires`, `Last-Modified`, `Pragma`, и `Vary`) могут быть удалены при использовании объектной модели кэша. Это поведение позволяет ASP.NET поддерживать наиболее ограниченные параметры. Например, рассмотрим страницу, содержащую пользовательские элементы управления. Если эти элементы управления имеют конфликтующие политики кэша, будет использоваться наиболее ограничиваемая политика кэша. Если один пользовательский элемент управления задает заголовок "`Cache-Control: Public`", а другой пользовательский элемент управления устанавливает более ограниченный заголовок "`Cache-Control: Private`" через вызовы в <xref:System.Web.HttpCachePolicy.SetCacheability%2A>, то заголовок "`Cache-Control: Private`" будет отправлен вместе с ответом.  
  
 Список стандартных заголовков HTTP/1.1 см. в разделе 14, «определения полей заголовка» в спецификации [протокола HTTP/1.1](https://go.microsoft.com/fwlink/?LinkID=73147) на веб-сайте консорциум W3C (W3C).  
  
   
  
## Examples  
 В следующем примере вызывается метод <xref:System.Web.HttpResponse.AppendHeader%2A> для добавления пользовательского заголовка к объекту <xref:System.Web.HttpResponse>, отправляемому запрашивающему клиенту.  
  
 [!code-csharp[System.Web.HttpResponse.AppendHeader_Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.AppendHeader_Example/CS/responseappendheader.cs.aspx#1)]
 [!code-vb[System.Web.HttpResponse.AppendHeader_Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.AppendHeader_Example/VB/responseappendheader.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Заголовок добавляется после отправки заголовков HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendToLog">
      <MemberSignature Language="C#" Value="public void AppendToLog (string param);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendToLog(string param) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendToLog(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendToLog (param As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendToLog(System::String ^ param);" />
      <MemberSignature Language="F#" Value="member this.AppendToLog : string -&gt; unit" Usage="httpResponse.AppendToLog param" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="param" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="param">Текст, добавляемый в файл журнала.</param>
        <summary>Добавляет данные пользовательского журнала в файл журнала IIS.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы разрешить запись указанной строки в файл журнала, сначала необходимо включить параметр **запрос URI** в диалоговом окне **свойства расширенного ведения журнала** для сайта, для которого требуется вести журнал активности в службах IIS.  
  
 Чтобы настроить расширенное ведение журнала в IIS 6,0, выполните следующие действия.  
  
1.  В диспетчере служб IIS разверните узел локальный компьютер, разверните папку веб-сайт или узлы FTP, щелкните правой кнопкой мыши веб-сайт или узел FTP и выберите пункт **Свойства**.  
  
2.  Перейдите на вкладку **веб-сайт или FTP-узел** и установите флажок **включить ведение журнала** (если он еще не установлен).  
  
3.  В поле **Формат активного журнала** выберите **Расширенный формат файла журнала W3C**.  
  
4.  Нажмите кнопку **Свойства**.  
  
5.  Перейдите на вкладку **Дополнительно** , выберите свойства, которые необходимо заносить в журнал, и нажмите кнопку **ОК**.  
  
   
  
## Examples  
 В следующем примере показано, как добавить строку в журнал.  
  
 [!code-csharp[Classic HttpResponse.AppendToLog Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AppendToLog Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AppendToLog Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AppendToLog Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=36829">Справка по продукту Windows Server 2003</related>
      </Docs>
    </Member>
    <Member MemberName="ApplyAppPathModifier">
      <MemberSignature Language="C#" Value="public string ApplyAppPathModifier (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ApplyAppPathModifier(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ApplyAppPathModifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyAppPathModifier (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ApplyAppPathModifier(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="member this.ApplyAppPathModifier : string -&gt; string" Usage="httpResponse.ApplyAppPathModifier virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Виртуальный путь к ресурсу.</param>
        <summary>Добавляет идентификатор сеанса в виртуальный путь, если сеанс использует свойство <see cref="P:System.Web.Configuration.SessionStateSection.Cookieless" /> для указания собственного состояния, и возвращает объединенный путь. Если задаваемое свойством <see cref="P:System.Web.Configuration.SessionStateSection.Cookieless" /> состояние сеанса не используется, то метод <see cref="M:System.Web.HttpResponse.ApplyAppPathModifier(System.String)" /> возвращает исходный виртуальный путь.</summary>
        <returns>Параметр <paramref name="virtualPath" /> с добавленным идентификатором сеанса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.ApplyAppPathModifier%2A> используется только с сеансами без файлов cookie для создания абсолютных HREF.  
  
   
  
## Examples  
 В следующем примере объявляется строковая переменная с именем `urlConverted`и присваивается результат вызова метода <xref:System.Web.HttpResponse.ApplyAppPathModifier%2A>. Затем код передает значение переменной в свойство <xref:System.Web.UI.WebControls.HyperLink.NavigateUrl%2A> элемента управления <xref:System.Web.UI.WebControls.HyperLink>.  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/responseapppathmodifiercs.aspx#5)]
 [!code-vb[System.Web.HttpResponse_Sample5#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/responseapppathmodifiervb.aspx#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginFlush(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.BeginFlush(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginFlush (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginFlush(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginFlush : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpResponse.BeginFlush (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">Вызываемый обратно объект.</param>
        <param name="state">Состояние отклика.</param>
        <summary>Отправляет клиенту отклик, находящийся в данный момент в буфере.</summary>
        <returns>Объект асинхронного результата.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если базовый объект <xref:System.Web.HttpWorkerRequest> поддерживает асинхронные операции очистки, и этот метод вызывается из асинхронного события модуля или из асинхронного обработчика, операция очистки выполняется асинхронно. В противном случае операция очистки выполняется синхронно. Асинхронная очистка поддерживается для IIS 6,0 и более поздних версий.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Отклик уже завершен.</exception>
      </Docs>
    </Member>
    <Member MemberName="BinaryWrite">
      <MemberSignature Language="C#" Value="public void BinaryWrite (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BinaryWrite(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.BinaryWrite(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub BinaryWrite (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BinaryWrite(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.BinaryWrite : byte[] -&gt; unit" Usage="httpResponse.BinaryWrite buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Байты, записываемые в поток вывода.</param>
        <summary>Записывает строку двоичных символов в поток вывода НТТР.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере текстовый файл считывается в буфер, а буфер записывается в поток вывода HTTP.  
  
 [!code-csharp[Classic HttpResponse.BinaryWrite Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.BinaryWrite Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.BinaryWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.BinaryWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Buffer">
      <MemberSignature Language="C#" Value="public bool Buffer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Buffer" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Buffer" />
      <MemberSignature Language="VB.NET" Value="Public Property Buffer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Buffer { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Buffer : bool with get, set" Usage="System.Web.HttpResponse.Buffer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, следует ли помещать выходные данные в буфер для отправки с последующей отправкой после завершения обработки ответа.</summary>
        <value>Значение <see langword="true" />, если выходные данные, отправляемые клиенту, помещаются в буфер; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Web.HttpResponse.Buffer%2A> устарело в пользу свойства <xref:System.Web.HttpResponse.BufferOutput%2A> и предоставляется только для совместимости с более ранними версиями ASP. С помощью ASP.NET используйте <xref:System.Web.HttpResponse.BufferOutput%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BufferOutput">
      <MemberSignature Language="C#" Value="public bool BufferOutput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BufferOutput" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.BufferOutput" />
      <MemberSignature Language="VB.NET" Value="Public Property BufferOutput As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BufferOutput { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BufferOutput : bool with get, set" Usage="System.Web.HttpResponse.BufferOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, следует ли помещать выходные данные в буфер для отправки с последующей отправкой после завершения обработки страницы.</summary>
        <value>Значение <see langword="true" />, если выходные данные, отправляемые клиенту, помещаются в буфер; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере задается свойство <xref:System.Web.HttpResponse.ContentType%2A> для ответа на Image/JPEG, вызывается метод <xref:System.Web.HttpResponse.Clear%2A>, чтобы удалить другое содержимое, которое может быть присоединено к ответу, а затем присваивает свойству <xref:System.Web.HttpResponse.BufferOutput%2A> значение true, чтобы вся страница была обработана до любое содержимое отправляется запрашивающему клиенту.  
  
 Полный пример см. в разделе класс <xref:System.Web.HttpResponse>.  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.HttpCachePolicy Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCachePolicy Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Cache" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cache As HttpCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpCachePolicy ^ Cache { System::Web::HttpCachePolicy ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cache : System.Web.HttpCachePolicy" Usage="System.Web.HttpResponse.Cache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает политику кэширования веб-страницы (например, срок действия, параметры конфиденциальности и изменяемые предложения).</summary>
        <value>Объект <see cref="T:System.Web.HttpCachePolicy" />, содержащий сведения о политике кэширования для текущего ответа.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере свойства текущей политики кэширования записываются в поток вывода HTTP.  
  
 [!code-csharp[Classic HttpResponse.Cache Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cache Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cache Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cache Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CacheControl">
      <MemberSignature Language="C#" Value="public string CacheControl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CacheControl" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.CacheControl" />
      <MemberSignature Language="VB.NET" Value="Public Property CacheControl As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CacheControl { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CacheControl : string with get, set" Usage="System.Web.HttpResponse.CacheControl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает заголовок HTTP <see langword="Cache-Control" />, который совпадает с одним из значений перечисления <see cref="T:System.Web.HttpCacheability" />.</summary>
        <value>Строковое представление значения перечисления <see cref="T:System.Web.HttpCacheability" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значения для `Private`, `Public`и `No-Cache` являются строками и должны заключаться в кавычки (""). Если свойству <xref:System.Web.HttpResponse.CacheControl%2A> присвоено значение, которое не соответствует одному из значений перечисления <xref:System.Web.HttpCacheability>, создается исключение <xref:System.ArgumentException>. Если свойство <xref:System.Web.HttpResponse.CacheControl%2A> не задано, то возможность кэширования ответа устанавливается равным <xref:System.Web.HttpCacheability.NoCache>.  
  
 Свойства `CacheControl`, <xref:System.Web.HttpResponse.Expires%2A>и <xref:System.Web.HttpResponse.ExpiresAbsolute%2A> являются устаревшими. Вместо этого методы класса <xref:System.Web.HttpCachePolicy> доступны через встроенный объект <xref:System.Web.HttpResponse.Cache%2A> для управления кэшем вывода службы IIS (IIS) и кэшем клиента.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Строковое значение не совпадает с одним из значений перечисления <see cref="T:System.Web.HttpCacheability" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Charset">
      <MemberSignature Language="C#" Value="public string Charset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Charset" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Charset" />
      <MemberSignature Language="VB.NET" Value="Public Property Charset As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Charset { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Charset : string with get, set" Usage="System.Web.HttpResponse.Charset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает кодировку НТТР для потока вывода.</summary>
        <value>Кодировка НТТР для потока вывода.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойству `Charset` можно присвоить значение `null`, чтобы подавлять заголовок HTTP `Content-Type`.  
  
   
  
## Examples  
 В следующем примере проверяется, является ли кодировка потока вывода Центральной Европейской (ISO).  
  
 [!code-csharp[System.Web.HttpResponse.Charset#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Charset/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.Charset#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Charset/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Свойство <see langword="Charset" /> было задано после отправки заголовков.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="httpResponse.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет все содержимое вывода из потока буфера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Web.HttpResponse.Clear%2A> не очищает сведения о заголовке.  
  
   
  
## Examples  
 В следующем примере задается свойство <xref:System.Web.HttpResponse.ContentType%2A> для ответа на Image/JPEG, вызывается метод <xref:System.Web.HttpResponse.Clear%2A>, чтобы удалить другое содержимое, которое может быть присоединено к ответу, а затем присваивает свойству <xref:System.Web.HttpResponse.BufferOutput%2A> значение true, чтобы завершить обработку страницы до любое содержимое отправляется запрашивающему клиенту.  
  
 Полный пример см. в разделе класс <xref:System.Web.HttpResponse>.  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.ClearHeaders" />
      </Docs>
    </Member>
    <Member MemberName="ClearContent">
      <MemberSignature Language="C#" Value="public void ClearContent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearContent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ClearContent" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearContent ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearContent();" />
      <MemberSignature Language="F#" Value="member this.ClearContent : unit -&gt; unit" Usage="httpResponse.ClearContent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет все содержимое вывода из потока буфера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Web.HttpResponse.ClearContent%2A> не очищает сведения о заголовке.  
  
   
  
## Examples  
 В следующем примере удаляется все содержимое из потока буфера.  
  
 [!code-csharp[Classic HttpResponse.ClearContent Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.ClearContent Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.ClearContent Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.ClearContent Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.ClearHeaders" />
      </Docs>
    </Member>
    <Member MemberName="ClearHeaders">
      <MemberSignature Language="C#" Value="public void ClearHeaders ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearHeaders() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ClearHeaders" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearHeaders ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearHeaders();" />
      <MemberSignature Language="F#" Value="member this.ClearHeaders : unit -&gt; unit" Usage="httpResponse.ClearHeaders " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет все заголовки из потока буфера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере вызывается метод <xref:System.Web.HttpResponse.ClearHeaders%2A>, чтобы гарантировать, что заголовки не отправляются с текущим ответом. Этот метод может быть особенно важен, если ответ ASP.NET создает изображение, например JPEG-файл. В этом примере свойству <xref:System.Web.HttpResponse.ContentType%2A> присвоено значение Image/JPEG.  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponseclearheaderscs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Sample5#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponseclearheadersvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Заголовки удаляются после отправки заголовков HTTP.</exception>
        <altmember cref="M:System.Web.HttpResponse.ClearContent" />
      </Docs>
    </Member>
    <Member MemberName="ClientDisconnectedToken">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationToken ClientDisconnectedToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.CancellationToken ClientDisconnectedToken" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ClientDisconnectedToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientDisconnectedToken As CancellationToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::CancellationToken ClientDisconnectedToken { System::Threading::CancellationToken get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientDisconnectedToken : System.Threading.CancellationToken" Usage="System.Web.HttpResponse.ClientDisconnectedToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Threading.CancellationToken" />, задействуемый при отключении клиента.</summary>
        <value>Токен отмены.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот API является потокобезопасным. Однако существуют некоторые ограничения на использование токена отмены. Неправильное использование может привести к конкуренции, взаимоблокировкам или другим непредвиденным последствиям. Учитывайте следующие рекомендации.  
  
-   Убедитесь, что вы не вызываете этот API за пределами одного запроса, так как ASP.NET будет удалять токен отмены в конце запроса. Нет никакой гарантии, что токен будет переходить в отмененное состояние до его удаления. Например, если запрос завершается без разъединения клиента, маркер будет удален без предварительного отмены.  
  
-   Не следует ждать <xref:System.Threading.CancellationToken.WaitHandle%2A?displayProperty=nameWithType>, так как это нарушает назначение асинхронного уведомления и может вызвать взаимоблокировки.  
  
-   Не вызывайте <xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType> перегрузок, которые вызывают обратный вызов для исходного объекта <xref:System.Threading.SynchronizationContext>.  
  
-   Не используйте <xref:System.Web.HttpContext> объект или другие внутренние объекты ASP.NET, не являющиеся потокобезопасными, в обратном вызове, предоставленном методу <xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType>. Обратный вызов может выполняться параллельно с другим кодом ASP.NET или приложения.  
  
-   Обеспечьте короткий и неблокирующий методы обратного вызова.  
  
-   Сделайте все усилия, чтобы избежать возникновения исключений в методах обратного вызова.  
  
 Это свойство поддерживается только в Internet Information Service (IIS) 7,5 или более поздней версии в интегрированном режиме. При вызове без правильной версии IIS или конвейера создается <xref:System.PlatformNotSupportedException>. Чтобы определить версию IIS, используйте <xref:System.Web.HttpRuntime.IISVersion%2A>. Чтобы определить режим конвейера, используйте <xref:System.Web.HttpRuntime.UsingIntegratedPipeline%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="httpResponse.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Закрывает соединение с клиентом по данному сокету.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод внезапно завершает соединение с клиентом и не предназначен для обычной обработки HTTP-запросов. Метод отправляет клиенту пакет сброса, что может привести к удалению данных ответа, которые буферизуются на сервере, в клиенте или в другом месте.  
  
 Однако, как правило, следует вызывать <xref:System.Web.HttpApplication.CompleteRequest%2A> вместо этого, если вы хотите перейти к событию <xref:System.Web.HttpApplication.EndRequest> и отправить ответ клиенту.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding ContentEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding ContentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ContentEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ ContentEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentEncoding : System.Text.Encoding with get, set" Usage="System.Web.HttpResponse.ContentEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает кодировку НТТР для потока вывода.</summary>
        <value>Объект <see cref="T:System.Text.Encoding" />, содержащий сведения о кодировке текущего ответа.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ContentEncoding` по умолчанию можно указать в файле конфигурации ASP.NET в разделе [Globalization (схема параметров ASP.NET)](https://msdn.microsoft.com/library/e2dffc8e-ebd2-439b-a2fd-e3ac5e620da7) . Если клиент задается <xref:System.Web.HttpResponse.ContentEncoding%2A>, параметры конфигурации по умолчанию переопределяются.  
  
   
  
## Examples  
 В следующем примере записывается понятное для человека описание кодировки набора символов в поток вывода.  
  
 [!code-csharp[Classic HttpResponse.ContentEncoding Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.ContentEncoding Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.ContentEncoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.ContentEncoding Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Попытка установить <see cref="P:System.Web.HttpResponse.ContentEncoding" /> в значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string with get, set" Usage="System.Web.HttpResponse.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает тип формата MIME НТТР потока вывода.</summary>
        <value>Тип формата MIME НТТР потока вывода. Значение по умолчанию — <see langword="text/html" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере задается свойство <xref:System.Web.HttpResponse.ContentType%2A> для ответа на Image/JPEG, вызывается метод <xref:System.Web.HttpResponse.Clear%2A>, чтобы удалить другое содержимое, которое может быть присоединено к ответу, а затем присваивает свойству <xref:System.Web.HttpResponse.BufferOutput%2A> значение true, чтобы завершить обработку страницы до любое содержимое отправляется запрашивающему клиенту.  
  
 Полный пример см. в разделе класс <xref:System.Web.HttpResponse>.  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Свойству <see cref="P:System.Web.HttpResponse.ContentType" /> задано значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Cookies">
      <MemberSignature Language="C#" Value="public System.Web.HttpCookieCollection Cookies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCookieCollection Cookies" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Cookies" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cookies As HttpCookieCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpCookieCollection ^ Cookies { System::Web::HttpCookieCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cookies : System.Web.HttpCookieCollection" Usage="System.Web.HttpResponse.Cookies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCookieCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает коллекцию файлов сookie ответов.</summary>
        <value>Коллекция файлов cookie ответов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET содержит две встроенные коллекции файлов cookie. Коллекция, доступная через коллекцию <xref:System.Web.HttpRequest.Cookies%2A> <xref:System.Web.HttpRequest> содержит файлы cookie, переданные клиентом на сервер в заголовке `Cookie`. Коллекция, доступная через коллекцию <xref:System.Web.HttpResponse.Cookies%2A> <xref:System.Web.HttpResponse>, содержит новые файлы cookie, созданные на сервере и передаваемые клиенту в заголовке `Set-Cookie`.  
  
 После добавления файла cookie с помощью <xref:System.Web.HttpResponse.Cookies%2A?displayProperty=nameWithType> коллекции файл cookie немедленно становится доступным в коллекции <xref:System.Web.HttpRequest.Cookies%2A?displayProperty=nameWithType>, даже если ответ не был отправлен клиенту.  
  
   
  
## Examples  
 В следующем примере создается новый файл cookie с именем `LastVisit`, в качестве значения файла cookie устанавливается текущая дата и время, а затем файл cookie добавляется в текущую коллекцию файлов cookie. Все файлы cookie в коллекции файлов cookie отправляются клиенту в заголовке `Set-Cookie` с выходным потоком HTTP.  
  
 [!code-csharp[Classic HttpResponse.Cookies Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cookies Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableKernelCache">
      <MemberSignature Language="C#" Value="public void DisableKernelCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableKernelCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.DisableKernelCache" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableKernelCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableKernelCache();" />
      <MemberSignature Language="F#" Value="member this.DisableKernelCache : unit -&gt; unit" Usage="httpResponse.DisableKernelCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Запрещает кэширование ядра для текущего ответа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если кэширование ядра не поддерживается, этот метод не действует.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableUserCache">
      <MemberSignature Language="C#" Value="public void DisableUserCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableUserCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.DisableUserCache" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableUserCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableUserCache();" />
      <MemberSignature Language="F#" Value="member this.DisableUserCache : unit -&gt; unit" Usage="httpResponse.DisableUserCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Отключает кэширование IIS в пользовательском режиме для этого ответа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если кэширование в пользовательском режиме IIS не поддерживается, этот метод возвращает значение без выполнения каких-либо действий.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="End">
      <MemberSignature Language="C#" Value="public void End ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void End() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.End" />
      <MemberSignature Language="VB.NET" Value="Public Sub End ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void End();" />
      <MemberSignature Language="F#" Value="member this.End : unit -&gt; unit" Usage="httpResponse.End " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Отправляет клиенту все выходные данные, находящиеся в данный момент в буфере, прекращает выполнение страницы и создает событие <see cref="E:System.Web.HttpApplication.EndRequest" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предоставляется только для обеспечения совместимости с ASP, то есть для совместимости с технологией веб-программирования на основе COM, предшествующей ASP.NET. Если вы хотите перейти к событию <xref:System.Web.HttpApplication.EndRequest> и отправить ответ клиенту, обычно предпочтительнее вызвать метод <xref:System.Web.HttpApplication.CompleteRequest%2A>.  
  
 Чтобы имитировать поведение метода `End` в ASP, этот метод пытается вызвать исключение <xref:System.Threading.ThreadAbortException>. Если эта попытка прошла успешно, вызывающий поток будет прерван, что негативно влияет на производительность вашего сайта. В этом случае код после вызова метода <xref:System.Web.HttpResponse.End%2A> не выполняется.  
  
 Если метод <xref:System.Web.HttpResponse.End%2A> не может вызвать <xref:System.Threading.ThreadAbortException>, он вместо этого сбрасывает байты ответа клиенту. Это синхронно, что может негативно помешать работе вашего сайта.  
  
 В любом случае (независимо от того, было ли успешно создано <xref:System.Threading.ThreadAbortException> исключение), конвейер ответа переходит к событию <xref:System.Web.HttpApplication.EndRequest>.  
  
 Метод <xref:System.Web.HttpApplication.CompleteRequest%2A> не создает исключение и код после вызова метода <xref:System.Web.HttpApplication.CompleteRequest%2A> может быть выполнен. Если ваша цель состоит в том, чтобы избежать выполнения последующего кода, и если приемлема производительность <xref:System.Web.HttpResponse.End%2A>, можно вызвать <xref:System.Web.HttpResponse.End%2A> вместо <xref:System.Web.HttpApplication.CompleteRequest%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadAbortException">Вызов <see cref="M:System.Web.HttpResponse.End" /> завершил текущий запрос.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public void EndFlush (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndFlush(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndFlush (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndFlush(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndFlush : IAsyncResult -&gt; unit" Usage="httpResponse.EndFlush asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Объект асинхронного результата.</param>
        <summary>Завершает асинхронную операцию очистки.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Асинхронная операция очистки не поддерживается, и параметр <paramref name="asyncResult" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Асинхронная операция записи на диск не поддерживается, и параметр <paramref name="asyncResult" /> невозможно привести к объекту <c>FlushAsyncResult</c>.</exception>
      </Docs>
    </Member>
    <Member MemberName="Expires">
      <MemberSignature Language="C#" Value="public int Expires { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Expires" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Expires" />
      <MemberSignature Language="VB.NET" Value="Public Property Expires As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Expires { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Expires : int with get, set" Usage="System.Web.HttpResponse.Expires" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает число минут перед тем, как истечет срок действия страницы, сохраненной в кэше браузера. Если пользователь возвращается к той же странице до момента истечения срока действия, будет отображена кэшированная версия. Свойство <see cref="P:System.Web.HttpResponse.Expires" /> обеспечивает совместимость с предыдущими версиями ASP.</summary>
        <value>Число минут перед тем, как срок действия страницы закончится.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойства `Expires`, <xref:System.Web.HttpResponse.ExpiresAbsolute%2A> и <xref:System.Web.HttpResponse.CacheControl%2A> являются нерекомендуемыми в пользу методов класса <xref:System.Web.HttpCachePolicy>, доступных через встроенный объект <xref:System.Web.HttpResponse.Cache%2A> для управления кэшем вывода службы IIS (IIS) и кэшем клиента.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpiresAbsolute">
      <MemberSignature Language="C#" Value="public DateTime ExpiresAbsolute { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExpiresAbsolute" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ExpiresAbsolute" />
      <MemberSignature Language="VB.NET" Value="Public Property ExpiresAbsolute As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExpiresAbsolute { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.ExpiresAbsolute : DateTime with get, set" Usage="System.Web.HttpResponse.ExpiresAbsolute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает абсолютную дату и время удаления кэшированных сведений из кэша. Свойство <see cref="P:System.Web.HttpResponse.ExpiresAbsolute" /> обеспечивает совместимость с предыдущими версиями ASP.</summary>
        <value>Дата и время истечения срока действия страницы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойства `ExpiresAbsolute`, <xref:System.Web.HttpResponse.Expires%2A>и <xref:System.Web.HttpResponse.CacheControl%2A> не рекомендуются в пользу методов класса <xref:System.Web.HttpCachePolicy>, доступных через внутренний объект <xref:System.Web.HttpResponse.Cache%2A> для управления кэшем вывода службы IIS (IIS) и кэшем клиента.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public System.IO.Stream Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream Filter" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ Filter { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Filter : System.IO.Stream with get, set" Usage="System.Web.HttpResponse.Filter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает объект фильтра обертки, используемый для изменения тела элемента НТТР перед началом передачи.</summary>
        <value>Объект <see cref="T:System.IO.Stream" />, используемый в качестве фильтра вывода.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда вы создаете объект `Stream` и устанавливаете для свойства <xref:System.Web.HttpResponse.Filter%2A> объект `Stream`, все выходные данные HTTP, отправленные <xref:System.Web.HttpResponse.Write%2A>, проходят через фильтр.  
  
   
  
## Examples  
 В следующем примере показана ASP.NET страница, которая задает для свойства <xref:System.Web.HttpResponse.Filter%2A> новый экземпляр класса `UpperCaseFilter`, Пользовательский класс <xref:System.IO.Stream>, который преобразует весь текст, передающий его в верхний регистр. Сведения о запросе сохраняются в текстовом файле, а затем устанавливается свойство <xref:System.Web.HttpResponse.Filter%2A>. После того как фильтр ответов установлен, код вызывает метод <xref:System.Web.HttpRequest.MapPath%2A>, чтобы получить абсолютный путь к текстовому файлу с именем `TestFile.txt`, который служит источником содержимого ответа. Затем код создает новый объект <xref:System.IO.StreamReader> для чтения текстового файла с начала до конца, а затем вызывает метод <xref:System.Web.HttpResponse.Write%2A> для вывода содержимого файла на странице.  
  
 [!code-aspx-csharp[System.Web.HttpRequest_Samples2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/CS/requestsamples2cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_Samples2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/VB/requestsamples2vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Фильтрация данного элемента недопустима.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberSignature Language="F#" Value="member this.Flush : unit -&gt; unit" Usage="httpResponse.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Отправляет клиенту все выходные данные, находящиеся в данный момент в буфере.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Принудительно отправляет клиенту все выходные данные, помещенные в буфер. Метод <xref:System.Web.HttpResponse.Flush%2A> можно вызывать несколько раз во время обработки запроса.  
  
   
  
## Examples  
 В следующем примере вызывается метод <xref:System.Drawing.Graphics.Save%2A> для сохранения объекта <xref:System.Drawing.Bitmap> в свойстве <xref:System.Web.HttpResponse.OutputStream%2A> и преобразования изображения в формат JPEG. Затем код вызывает метод `Dispose` для объекта <xref:System.Drawing.Bitmap> и объекта <xref:System.Drawing.Graphics>, освобождая ресурсы, которые они использовали. Затем он вызывает метод <xref:System.Web.HttpResponse.Flush%2A> для отправки содержимого ответа запрашивающему клиенту.  
  
 Полный пример см. в разделе класс <xref:System.Web.HttpResponse>.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">После отправки ответа кэш очищается.</exception>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FlushAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FlushAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.FlushAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function FlushAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FlushAsync();" />
      <MemberSignature Language="F#" Value="member this.FlushAsync : unit -&gt; System.Threading.Tasks.Task" Usage="httpResponse.FlushAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Асинхронно отправляет клиенту все выходные данные, находящиеся в настоящий момент в буфере.</summary>
        <returns>Объект <see cref="T:System.Threading.Tasks.Task" />, который представляет асинхронную операцию.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HeaderEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding HeaderEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding HeaderEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.HeaderEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property HeaderEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ HeaderEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.HeaderEncoding : System.Text.Encoding with get, set" Usage="System.Web.HttpResponse.HeaderEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает объект <see cref="T:System.Text.Encoding" />, который представляет кодирование для потока вывода текущего заголовка.</summary>
        <value>Объект <see cref="T:System.Text.Encoding" />, содержащий сведения о кодировке текущего заголовка.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Web.HttpResponse.HeaderEncoding%2A> дает возможность отключить или изменить объект <xref:System.Text.Encoding> в заголовке ответа с помощью <xref:System.Text.ASCIIEncoding>, <xref:System.Text.UnicodeEncoding>, <xref:System.Text.UTF7Encoding>или объекта <xref:System.Text.UTF8Encoding>. Значением кодировки по умолчанию является класс <xref:System.Text.UTF8Encoding>.  
  
 Изменяя тип свойства <xref:System.Web.HttpResponse.HeaderEncoding%2A>, вы потенциально можете увеличить риск некоторых вредоносных атак или вызвать отправку конфиденциальных данных через заголовок ответа. Атаки путем внедрения заголовков можно избегать, в части, закрывая свойство <xref:System.Web.HttpResponse.HeaderEncoding%2A> ответа на значение по умолчанию. Атака на уязвимое приложение может вернуть данные сохранность как часть заголовка ответа. Если <xref:System.Web.HttpResponse.HeaderEncoding%2A> отключена из-за необходимости в строках продолжения в заголовке или если какой-либо заголовок строится на основе результатов ненадежных данных, данные заголовка должны быть проверены перед отправкой в поток ответа.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение кодировки — <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException">Значение кодировки — <see cref="P:System.Text.Encoding.Unicode" />.  
  
- или - 
Заголовки уже были отправлены.</exception>
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Headers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Headers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Headers As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Headers { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Headers : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpResponse.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает коллекцию заголовков ответа.</summary>
        <value>Коллекция <see cref="T:System.Collections.Specialized.NameValueCollection" /> заголовков ответа.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Web.HttpResponse.Headers%2A> поддерживается только в режиме интегрированного конвейера [!INCLUDE[iisver](~/includes/iisver-md.md)] и по крайней мере .NET Framework 3,0. При попытке получить доступ к свойству <xref:System.Web.HttpResponse.Headers%2A> и одно из этих двух условий не выполняется, создается <xref:System.PlatformNotSupportedException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Для этой операции требуется режим интегрированного конвейера в [!INCLUDE[iisver](~/includes/iisver-md.md)] и по крайней мере .NET Framework версии 3.0.</exception>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=86952">Обновление приложений ASP.NET до IIS 7,0: различия между интегрированным режимом IIS 7,0 и классическим режимом</related>
      </Docs>
    </Member>
    <Member MemberName="HeadersWritten">
      <MemberSignature Language="C#" Value="public bool HeadersWritten { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HeadersWritten" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.HeadersWritten" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HeadersWritten As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HeadersWritten { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HeadersWritten : bool" Usage="System.Web.HttpResponse.HeadersWritten" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, были ли записаны заголовки ответа.</summary>
        <value>Значение <see langword="true" />, если заголовки ответа были записаны; в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClientConnected">
      <MemberSignature Language="C#" Value="public bool IsClientConnected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClientConnected" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.IsClientConnected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClientConnected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClientConnected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClientConnected : bool" Usage="System.Web.HttpResponse.IsClientConnected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, определяющее наличие подключения клиента к серверу.</summary>
        <value>Значение <see langword="true" />, если клиент подключен в данный момент; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Web.HttpResponse.IsClientConnected%2A> возвращает значение `false`, если выполняются следующие условия.  
  
-   Соединение с клиентом было прервано. Это может произойти, если был вызван метод <xref:System.Web.HttpResponse.Close%2A> или если клиент остановил выполнение веб-страницы или просматривает другую страницу.  
  
-   Объект <xref:System.Web.HttpWorkerRequest>, обрабатывающий запрос, `null` или метод <xref:System.Web.HttpWorkerRequest.IsClientConnected%2A?displayProperty=nameWithType> возвращает `false`. Если пользовательский объект <xref:System.Web.HttpWorkerRequest> обрабатывает запрос, метод <xref:System.Web.HttpWorkerRequest.IsClientConnected%2A?displayProperty=nameWithType> может быть установлен на основе настраиваемых критериев. Например, Пользовательский рабочий запрос может выполнить принудительное истечение времени ожидания по истечении определенного периода времени.  
  
   
  
## Examples  
 В следующем примере используется свойство <xref:System.Web.HttpResponse.IsClientConnected%2A> для проверки того, что клиент, запрашивающий страницу, остается подключенным к серверу. Если <xref:System.Web.HttpResponse.IsClientConnected%2A> имеет значение true, код вызывает метод <xref:System.Web.HttpResponse.Redirect%2A>, и клиент будет просматривать другую страницу. Если <xref:System.Web.HttpResponse.IsClientConnected%2A> имеет значение false, то код вызывает метод <xref:System.Web.HttpResponse.End%2A>, и вся обработка страницы завершается.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page1cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page1vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsRequestBeingRedirected">
      <MemberSignature Language="C#" Value="public bool IsRequestBeingRedirected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsRequestBeingRedirected" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.IsRequestBeingRedirected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsRequestBeingRedirected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsRequestBeingRedirected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsRequestBeingRedirected : bool" Usage="System.Web.HttpResponse.IsRequestBeingRedirected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает логическое значение, указывающее изменение расположения клиента.</summary>
        <value>Значение <see langword="true" />, если значение заголовка ответа расположения отличается от текущего расположения, в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте свойство <xref:System.Web.HttpResponse.IsRequestBeingRedirected%2A> со свойством <xref:System.Web.HttpResponse.RedirectLocation%2A> для проверки и определения того, отличается ли абсолютный URI, передаваемый клиенту в заголовке HTTP-`Location`, от текущего URI и от того, в что будет передаваться новый предполагаемый URI.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Output">
      <MemberSignature Language="C#" Value="public System.IO.TextWriter Output { get; }" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.TextWriter Output" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Output" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Output As TextWriter" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::TextWriter ^ Output { System::IO::TextWriter ^ get(); };" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="F#" Value="member this.Output : System.IO.TextWriter" Usage="System.Web.HttpResponse.Output" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="C#" Value="public System.IO.TextWriter Output { get; set; }" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Property Output As TextWriter" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::TextWriter ^ Output { System::IO::TextWriter ^ get(); void set(System::IO::TextWriter ^ value); };" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="member this.Output : System.IO.TextWriter with get, set" Usage="System.Web.HttpResponse.Output" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Разрешает выводить текст в исходящем потоке ответа НТТР.</summary>
        <value>Объект <see cref="T:System.IO.TextWriter" />, разрешающий пользовательский вывод на сторону клиента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере показана ASP.NET страница, содержащая элемент управления <xref:System.Web.UI.WebControls.TextBox>, для свойства <xref:System.Web.UI.WebControls.TextBox.TextMode%2A> которого задано значение <xref:System.Web.UI.WebControls.TextBoxMode.MultiLine>. Код страницы принимает текст, вводимый пользователем в <xref:System.Web.UI.WebControls.TextBox.TextMode%2A>, использует метод <xref:System.Web.HttpServerUtility.HtmlEncode%2A> для его кодирования в формате HTML и свойство <xref:System.Web.HttpResponse.Output%2A> для вывода закодированной строки на страницу.  
  
 [!code-aspx-csharp[System.Web.HttpResponse.Output_Sample#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Output_Sample/CS/responseoutputcs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse.Output_Sample#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Output_Sample/VB/responseoutputvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OutputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream OutputStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream OutputStream" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.OutputStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OutputStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ OutputStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OutputStream : System.IO.Stream" Usage="System.Web.HttpResponse.OutputStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Разрешает вывод двоичных данных в теле исходящего содержимого НТТР.</summary>
        <value>Объект <see cref="T:System.IO.Stream" /> ввода-вывода, представляющий начальное содержимое тела исходящего содержимого НТТР.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Начиная с версии .NET Framework 2,0 при использовании метода <xref:System.IO.Stream.Write%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> потока ввода-вывода, возвращаемого свойством <xref:System.Web.HttpResponse.OutputStream%2A>, могут возникать следующие исключения.  
  
-   <xref:System.ArgumentOutOfRangeException>, если параметр `offset` или `count` является отрицательным или длина параметра `buffer` минус значение параметра `offset` меньше или равна нулю.  
  
-   <xref:System.ArgumentNullException>, если параметр `buffer` имеет значение `null`.  
  
   
  
## Examples  
 В следующем примере вызывается метод <xref:System.Drawing.Image.Save%2A> для сохранения объекта <xref:System.Drawing.Bitmap> в свойстве <xref:System.Web.HttpResponse.OutputStream%2A> и преобразования изображения в формат JPEG. Затем код вызывает метод Dispose для объекта <xref:System.Drawing.Bitmap> и объекта <xref:System.Drawing.Graphics>, освобождая ресурсы, которые они использовали. Наконец, код вызывает метод <xref:System.Web.HttpResponse.Flush%2A> для отправки содержимого ответа запрашивающему клиенту.  
  
 Полный пример см. в разделе класс <xref:System.Web.HttpResponse>.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Параметр <paramref name="OutputStream" /> недоступен.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pics">
      <MemberSignature Language="C#" Value="public void Pics (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pics(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Pics(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pics (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pics(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Pics : string -&gt; unit" Usage="httpResponse.Pics value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Строка, которую требуется добавить в заголовок <see langword="PICS-Label" />.</param>
        <summary>Добавляет заголовок <see langword="PICS-Label" /> HTTP в поток вывода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Платформа для выбора содержимого Интернета (PICS) — это консорциум W3C (W3C) для меток содержимого. PICS — это, по сути, язык для создания системы оценок.  
  
 Любое значение может быть меткой PICS; ASP.NET не проверяет метку. Максимальная длина строки — 255 символов. Дополнительные сведения о стандартах и синтаксисе PICS см. на веб-сайте [консорциум W3C](https://go.microsoft.com/fwlink/?LinkID=37125) .  
  
   
  
## Examples  
 В следующем примере показана страница ASP.NET, на которой отображается изображение. Код страницы вызывает метод <xref:System.Web.HttpResponse.Pics%2A>, чтобы задать заголовок HTTP `PICS-Label` для ответа. Строка, передаваемая в качестве параметра методу <xref:System.Web.HttpResponse.Pics%2A>, представляет метку оценки, созданную на основе веб-сайта сопоставления оценки содержимого Интернета (икра).  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page2cs.aspx#2)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PushPromise">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Повышает уровень обещанного объекта.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PushPromise">
      <MemberSignature Language="C#" Value="public void PushPromise (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PushPromise(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.PushPromise(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub PushPromise (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PushPromise(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.PushPromise : string -&gt; unit" Usage="httpResponse.PushPromise path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">URL-адрес push-запроса. Это должен быть виртуальный путь относительного ресурса, который сервер должен принудительно отправить клиенту.</param>
        <summary>Этот интерфейс API предназначен для поддержки приложений, которые принудительно отправляют обещания клиентам HTTP 2.0. Дополнительные сведения о принудительной отправке с сервера Http2 можно найти в <see href="https://http2.github.io/http2-spec/#PushResources">разделе 8.2 спецификации HTTP/2: отправка с сервера</see>.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 PushPromise является недетерминированным и приложения не должны иметь логики, зависящей от нее. Единственной целью является преимущество в производительности в некоторых случаях. Существует множество условий (протокол и реализация), которые могут привести к полному игнорированию запросов push-уведомлений. Ожидание основано на пожаре и-забыть.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushPromise">
      <MemberSignature Language="C#" Value="public void PushPromise (string path, string method, System.Collections.Specialized.NameValueCollection headers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PushPromise(string path, string method, class System.Collections.Specialized.NameValueCollection headers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.PushPromise(System.String,System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub PushPromise (path As String, method As String, headers As NameValueCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PushPromise(System::String ^ path, System::String ^ method, System::Collections::Specialized::NameValueCollection ^ headers);" />
      <MemberSignature Language="F#" Value="member this.PushPromise : string * string * System.Collections.Specialized.NameValueCollection -&gt; unit" Usage="httpResponse.PushPromise (path, method, headers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="method" Type="System.String" Index="1" FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" Index="2" FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">URL-адрес push-запроса. Это должен быть виртуальный путь относительного ресурса, который сервер должен принудительно отправить клиенту.</param>
        <param name="method">Метод HTTP-запроса, который будет использоваться в push-запросе.</param>
        <param name="headers">Заголовок HTTP-запроса, который будет использоваться в push-запросе.</param>
        <summary>Этот интерфейс API предназначен для поддержки приложений, которые принудительно отправляют обещания клиентам HTTP 2.0. Дополнительные сведения о принудительной отправке с сервера Http2 можно найти в <see href="https://http2.github.io/http2-spec/#PushResources">разделе 8.2 спецификации HTTP/2: отправка с сервера</see>.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 PushPromise является недетерминированным и приложения не должны иметь логики, зависящей от нее. Единственной целью является преимущество в производительности в некоторых случаях. Существует множество условий (протокол и реализация), которые могут привести к полному игнорированию запросов push-уведомлений. Ожидание основано на пожаре и-забыть.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Redirect">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Перенаправляет клиента на новый URL-адрес.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Redirect">
      <MemberSignature Language="C#" Value="public void Redirect (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redirect(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Redirect(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Redirect (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Redirect(System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.Redirect : string -&gt; unit" Usage="httpResponse.Redirect url" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">Конечное расположение. Это может быть виртуальный путь относительно приложения.</param>
        <summary>Перенаправляет запрос по новому адресу и задает новый URL-адрес.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов <xref:System.Web.HttpResponse.Redirect%2A> эквивалентен вызову <xref:System.Web.HttpResponse.Redirect%2A> со вторым набором параметров, равным `true`.  
  
 <xref:System.Web.HttpResponse.Redirect%2A> вызывает <xref:System.Web.HttpResponse.End%2A>, который вызывает исключение <xref:System.Threading.ThreadAbortException> после завершения. Это исключение негативно влияет на производительность веб-приложений. Поэтому вместо этой перегрузки рекомендуется использовать перегрузку <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType> и передавать `false` для параметра `endResponse`, а затем вызывать метод <xref:System.Web.HttpApplication.CompleteRequest%2A>. Дополнительные сведения см. в описании метода <xref:System.Web.HttpResponse.End%2A>.  
  
> [!NOTE]
>  Только для мобильных страниц, если приложение использует сеансы без файлов cookie или может принимать запросы от мобильных устройств, для которых требуются сеансы без файлов cookie, использование тильды (\~) в пути может привести к созданию нового сеанса и потере данных сеанса. Чтобы задать свойство для мобильного элемента управления с использованием пути, например "\~/Path", разрешите путь с помощью <xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A> "\~/Path", прежде чем назначать его свойству.  
  
 ASP.NET выполняет перенаправление, возвращая код состояния HTTP 302. Другим способом перемещения элемента управления на другую страницу является метод <xref:System.Web.HttpServerUtility.Transfer%2A>. Метод <xref:System.Web.HttpServerUtility.Transfer%2A>, как правило, более эффективен, так как он не вызывает круговой путь к клиенту. Дополнительные сведения см. [в разделе руководство. Перенаправление пользователей на другую страницу](https://msdn.microsoft.com/library/daef3f43-e018-43aa-b43c-46b27bac599e).  
  
   
  
## Examples  
 В следующем примере выполняется принудительное перенаправление на другой веб-сайт.  
  
 [!code-csharp[Classic HttpResponse.Redirect Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Redirect Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Redirect Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Redirect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Выполнена попытка перенаправления после отправки HTTP-заголовков.</exception>
      </Docs>
    </Member>
    <Member MemberName="Redirect">
      <MemberSignature Language="C#" Value="public void Redirect (string url, bool endResponse);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redirect(string url, bool endResponse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Redirect(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Redirect (url As String, endResponse As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Redirect(System::String ^ url, bool endResponse);" />
      <MemberSignature Language="F#" Value="member this.Redirect : string * bool -&gt; unit" Usage="httpResponse.Redirect (url, endResponse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="endResponse" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="url">Расположение целевого объекта.</param>
        <param name="endResponse">Указывает, должно ли прекратиться выполнение текущей страницы.</param>
        <summary>Перенаправляет клиента на новый URL-адрес. Задает новый URL-адрес и условия прекращения выполнения текущей страницы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Абсолютный URL-адрес (например, `http://www.contoso.com/default.aspx`) или относительный URL-адрес (например, Default. aspx) можно указать для целевого расположения, но некоторые браузеры могут отклонять относительный URL-адрес.  
  
 При использовании этого метода в обработчике страницы для завершения запроса одной страницы и запуска нового запроса на другой странице задайте для `endResponse` значение `false` и затем вызовите метод <xref:System.Web.HttpApplication.CompleteRequest%2A>. При указании `true` для параметра `endResponse` этот метод вызывает метод <xref:System.Web.HttpResponse.End%2A> для исходного запроса, который вызывает исключение <xref:System.Threading.ThreadAbortException> после завершения. Это исключение негативно влияет на производительность веб-приложений, поэтому рекомендуется передавать `false` для параметра `endResponse`. Дополнительные сведения см. в описании метода <xref:System.Web.HttpResponse.End%2A>.  
  
> [!NOTE]
>  Для мобильных страниц, если приложение использует сеансы без файлов cookie или может принимать запросы от мобильных устройств, для которых требуются сеансы без файлов cookie, использование тильды (\~) в пути может привести к созданию нового сеанса и потере данных сеанса. Чтобы задать свойство для мобильного элемента управления с использованием пути, например "\~/Path", разрешите путь с помощью <xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A> "\~/Path", прежде чем назначать его свойству.  
  
 ASP.NET выполняет перенаправление, возвращая код состояния HTTP 302. Другим способом перемещения элемента управления на другую страницу является метод <xref:System.Web.HttpServerUtility.Transfer%2A>. Метод <xref:System.Web.HttpServerUtility.Transfer%2A>, как правило, более эффективен, так как он не вызывает круговой путь к клиенту. Дополнительные сведения см. [в разделе руководство. Перенаправление пользователей на другую страницу](https://msdn.microsoft.com/library/daef3f43-e018-43aa-b43c-46b27bac599e).  
  
   
  
## Examples  
 В следующем примере используется свойство <xref:System.Web.HttpResponse.IsClientConnected%2A> для проверки того, что клиент, запрашивающий страницу, остается подключенным к серверу. Если <xref:System.Web.HttpResponse.IsClientConnected%2A> имеет значение true, код вызывает метод <xref:System.Web.HttpResponse.Redirect%2A>, и клиент будет просматривать другую страницу. Если <xref:System.Web.HttpResponse.IsClientConnected%2A> имеет значение false, то код вызывает метод <xref:System.Web.HttpResponse.End%2A>, и вся обработка страницы завершается.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page1cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page1vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="url" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="url" /> содержит символ новой строки.</exception>
        <exception cref="T:System.Web.HttpException">Выполнена попытка перенаправления после отправки HTTP-заголовков.</exception>
        <exception cref="T:System.ApplicationException">Запрос страницы — это результат обратного вызова.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectLocation">
      <MemberSignature Language="C#" Value="public string RedirectLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RedirectLocation" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.RedirectLocation" />
      <MemberSignature Language="VB.NET" Value="Public Property RedirectLocation As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RedirectLocation { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RedirectLocation : string with get, set" Usage="System.Web.HttpResponse.RedirectLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение заголовка HTTP <see langword="Location" />.</summary>
        <value>Абсолютный URI, переданный клиенту в заголовке <see langword="Location" /> HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере показано, как использовать это свойство для указания URL-адреса перенаправления при кодировании постоянного перенаправления с помощью кода ответа HTTP 301.  
  
```csharp  
Response.StatusCode = 301;  
Response.Status = "301 Moved Permanently";  
Response.RedirectLocation = "http://www.newurl.com ";  
Response.End();  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Заголовки HTTP уже записаны.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectPermanent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет безвозвратное перенаправление с запрошенного URL-адреса на заданный URL-адрес.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectPermanent">
      <MemberSignature Language="C#" Value="public void RedirectPermanent (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectPermanent(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectPermanent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectPermanent (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectPermanent(System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.RedirectPermanent : string -&gt; unit" Usage="httpResponse.RedirectPermanent url" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="url">Расположение, в которое следует перенаправить запрос.</param>
        <summary>Выполняет безвозвратное перенаправление с запрошенного URL-адреса на заданный URL-адрес.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Перегрузка метода <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%29> предоставляет код состояния HTTP 301 в ответе и включает URL-адрес для перенаправления запроса. Код состояния HTTP 301 — это стандартный код в HTTP-ответе. Это означает, что существует постоянное перенаправление, и оно предоставляет расположение перенаправления.  
  
 Вызов перегрузки метода <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%29> завершает ответ.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="url" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="url" /> включает символ новой строки (<c>\n</c>).</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectPermanent">
      <MemberSignature Language="C#" Value="public void RedirectPermanent (string url, bool endResponse);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectPermanent(string url, bool endResponse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectPermanent(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectPermanent (url As String, endResponse As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectPermanent(System::String ^ url, bool endResponse);" />
      <MemberSignature Language="F#" Value="member this.RedirectPermanent : string * bool -&gt; unit" Usage="httpResponse.RedirectPermanent (url, endResponse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="endResponse" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="url">Расположение, в которое следует перенаправить запрос.</param>
        <param name="endResponse">Значение <see langword="true" /> для прерывания ответа, в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</param>
        <summary>Выполняет безвозвратное перенаправление с запрошенного URL-адреса на заданный URL-адрес и предоставляет возможность завершить ответ.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Перегрузка метода <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29> предоставляет код состояния HTTP 301 в ответе и включает URL-адрес для перенаправления запроса. Эта перегрузка метода также предоставляет возможность указать, следует ли прерывать или завершать ответ после перенаправления. Код состояния HTTP 301 — это стандартный код в HTTP-ответе. Это означает, что существует постоянное перенаправление, и оно предоставляет расположение перенаправления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="url" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="url" /> включает символ новой строки (<c>\n</c>).</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectToRoute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Перенаправляет запрос на новый URL-адрес, используя значения параметров маршрута, имя маршрута или и то, и другое.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : obj -&gt; unit" Usage="httpResponse.RedirectToRoute routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeValues">Значения параметров маршрута.</param>
        <summary>Перенаправляет запрос на новый URL-адрес, используя значения параметров маршрута.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предоставляется для удобства написания кода. Он эквивалентен вызову метода <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> со вторым набором параметров, равным `false`.  
  
 Этот метод преобразует объект, переданный в `routeValues`, в объект <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> с помощью конструктора <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType>. Затем вызывается метод <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> для определения URL-адреса.  
  
 ASP.NET выполняет перенаправление, возвращая код состояния HTTP 302.  
  
   
  
## Examples  
 В следующем примере показано, как вызвать этот метод для перенаправления в маршрут с параметрами, имеющими имя `productid` и `category`.  
  
```vb  
Response.RedirectToRoute(  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoute(  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ни один маршрут не соответствует указанным параметрам маршрута.</exception>
        <exception cref="T:System.Web.HttpException">Была предпринята попытка перенаправления после отправки заголовков HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Маршрутизация ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : string -&gt; unit" Usage="httpResponse.RedirectToRoute routeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeName">Имя маршрута.</param>
        <summary>Перенаправляет запрос на новый URL-адрес, используя имя маршрута.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предоставляется для удобства написания кода. Он эквивалентен вызову метода <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> со вторым набором параметров, равным `false`.  
  
 Этот метод преобразует имя маршрута, передаваемое в `routeName`, в URL-адрес с помощью метода <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>.  
  
 ASP.NET выполняет перенаправление, возвращая код состояния HTTP 302.  
  
   
  
## Examples  
 В следующем примере показано, как вызвать этот метод для перенаправления к маршруту с именем `Products`.  
  
```vb  
Response.RedirectToRoute("Products")  
```  
  
```csharp  
Response.RedirectToRoute("Products");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ни один маршрут не соответствует указанным параметрам маршрута.</exception>
        <exception cref="T:System.Web.HttpException">Была предпринята попытка перенаправления после отправки заголовков HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Маршрутизация ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoute routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeValues">Значения параметров маршрута.</param>
        <summary>Перенаправляет запрос на новый URL-адрес, используя значения параметров маршрута.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предоставляется для удобства написания кода. Он эквивалентен вызову метода <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> со вторым набором параметров, равным `false`.  
  
 Этот метод вызывает метод <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> для определения URL-адреса.  
  
 ASP.NET выполняет перенаправление, возвращая код состояния HTTP 302.  
  
   
  
## Examples  
 В следующем примере показано, как вызвать этот метод для перенаправления в маршрут с параметрами, имеющими имя `productid` и `category`.  
  
```vb  
Response.RedirectToRoute(  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoute(  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ни один маршрут не соответствует указанным параметрам маршрута.</exception>
        <exception cref="T:System.Web.HttpException">Была предпринята попытка перенаправления после отправки заголовков HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Маршрутизация ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName, object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName, object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String, routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName, System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : string * obj -&gt; unit" Usage="httpResponse.RedirectToRoute (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="routeValues" Type="System.Object" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeName">Имя маршрута.</param>
        <param name="routeValues">Значения параметров маршрута.</param>
        <summary>Перенаправляет запрос на новый URL-адрес, используя значения параметров маршрута и имя маршрута.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предоставляется для удобства написания кода. Он эквивалентен вызову метода <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> со вторым набором параметров, равным `false`.  
  
 Этот метод преобразует объект, переданный в `routeValues`, в объект <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> с помощью конструктора <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType>. Затем вызывается метод <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> для определения URL-адреса.  
  
 ASP.NET выполняет перенаправление, возвращая код состояния HTTP 302.  
  
   
  
## Examples  
 В следующем примере показано, как вызвать этот метод для перенаправления к маршруту с именем `Product` и у которого есть параметры с именами `productid` и `category`.  
  
```vb  
Response.RedirectToRoute("Product",  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoute("Product",  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ни один маршрут не соответствует указанным параметрам маршрута.</exception>
        <exception cref="T:System.Web.HttpException">Была предпринята попытка перенаправления после отправки заголовков HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Маршрутизация ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName, System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName, class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String, routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName, System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : string * System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoute (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeName">Имя маршрута.</param>
        <param name="routeValues">Значения параметров маршрута.</param>
        <summary>Перенаправляет запрос на новый URL-адрес, используя значения параметров маршрута и имя маршрута.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предоставляется для удобства написания кода. Он эквивалентен вызову метода <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> со вторым набором параметров, равным `false`.  
  
 Для определения URL-адреса вызывается метод <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>.  
  
 ASP.NET выполняет перенаправление, возвращая код состояния HTTP 302.  
  
   
  
## Examples  
 В следующем примере показано, как вызвать этот метод для перенаправления к маршруту с именем `Product` и у которого есть параметры с именами `productid` и `category`.  
  
```vb  
Response.RedirectToRoute("Product",  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoute("Product",  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ни один маршрут не соответствует указанным параметрам маршрута.</exception>
        <exception cref="T:System.Web.HttpException">Была предпринята попытка перенаправления после отправки заголовков HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Маршрутизация ASP.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectToRoutePermanent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет постоянное перенаправление запроса с запрошенного URL-адреса на новый URL-адрес, используя значения параметров маршрута, имя маршрута или и то и другое.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : obj -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeValues">Значения параметров маршрута.</param>
        <summary>Выполняет постоянное перенаправление запроса с запрошенного URL-адреса на новый URL-адрес, используя значения параметров маршрута.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предоставляется для удобства написания кода. Он эквивалентен вызову метода <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29> со вторым набором параметров, равным `false`.  
  
 Этот метод преобразует объект, переданный в `routeValues`, в объект <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> с помощью конструктора <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType>. Затем вызывается метод <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> для определения URL-адреса.  
  
 ASP.NET выполняет перенаправление, возвращая код состояния HTTP 301.  
  
   
  
## Examples  
 В следующем примере показано, как вызвать этот метод для перенаправления в маршрут с параметрами, имеющими имя `productid` и `category`.  
  
```vb  
Response.RedirectToRoutePermanent(  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent(  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ни один маршрут не соответствует указанным параметрам маршрута.</exception>
        <exception cref="T:System.Web.HttpException">Была предпринята попытка перенаправления после отправки заголовков HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Маршрутизация ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : string -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent routeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeName">Имя маршрута.</param>
        <summary>Выполняет постоянное перенаправление с запрошенного URL-адреса на новый URL-адрес, используя имя маршрута.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предоставляется для удобства написания кода. Он эквивалентен вызову метода <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29> со вторым набором параметров, равным `false`.  
  
 Этот метод преобразует имя маршрута, передаваемое в `routeName`, в URL-адрес с помощью метода <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>.  
  
 ASP.NET выполняет перенаправление, возвращая код состояния HTTP 301.  
  
   
  
## Examples  
 В следующем примере показано, как вызвать этот метод для перенаправления к маршруту с именем `Products`.  
  
```vb  
Response.RedirectToRoutePermanent("Products")  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Products");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ни один маршрут не соответствует указанным параметрам маршрута.</exception>
        <exception cref="T:System.Web.HttpException">Была предпринята попытка перенаправления после отправки заголовков HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Маршрутизация ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeValues">Значения параметров маршрута.</param>
        <summary>Выполняет постоянное перенаправление запроса с запрошенного URL-адреса на новый URL-адрес, используя значения параметров маршрута.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предоставляется для удобства написания кода. Он эквивалентен вызову метода <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> со вторым набором параметров, равным `false`.  
  
 Этот метод вызывает метод <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> для определения URL-адреса.  
  
 ASP.NET выполняет перенаправление, возвращая код состояния HTTP 301.  
  
   
  
## Examples  
 В следующем примере показано, как вызвать этот метод для перенаправления в маршрут с параметрами, имеющими имя `productid` и `category`.  
  
```vb  
Response.RedirectToRoutePermanent(  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent(  
  new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ни один маршрут не соответствует указанным параметрам маршрута.</exception>
        <exception cref="T:System.Web.HttpException">Была предпринята попытка перенаправления после отправки заголовков HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Маршрутизация ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName, object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName, object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String, routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName, System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : string * obj -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="routeValues" Type="System.Object" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeName">Имя маршрута.</param>
        <param name="routeValues">Значения параметров маршрута.</param>
        <summary>Выполняет постоянное перенаправление запроса с запрошенного URL-адреса на новый URL-адрес, используя значения параметров маршрута и имя маршрута, соответствующее новому URL-адресу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предоставляется для удобства написания кода. Он эквивалентен вызову метода <xref:System.Web.HttpResponse.RedirectPermanent%2A> со вторым набором параметров, равным `false`.  
  
 Этот метод преобразует объект, переданный в `routeValues`, в объект <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> с помощью конструктора <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType>. Затем вызывается метод <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> для определения URL-адреса.  
  
 ASP.NET выполняет перенаправление, возвращая код состояния HTTP 301.  
  
   
  
## Examples  
 В следующем примере показано, как вызвать этот метод для перенаправления к маршруту с именем `Product` и у которого есть параметры с именами `productid` и `category`.  
  
```vb  
Response.RedirectToRoutePermanent("Product",  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Product",  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ни один маршрут не соответствует указанным параметрам маршрута.</exception>
        <exception cref="T:System.Web.HttpException">Была предпринята попытка перенаправления после отправки заголовков HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Маршрутизация ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName, System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName, class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String, routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName, System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : string * System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeName">Имя маршрута.</param>
        <param name="routeValues">Значения параметров маршрута.</param>
        <summary>Выполняет постоянное перенаправление запроса с запрошенного URL-адреса на новый URL-адрес, используя значения параметров маршрута и имя маршрута.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предоставляется для удобства написания кода. Он эквивалентен вызову метода <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> со вторым набором параметров, равным `false`.  
  
 Этот метод вызывает метод <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> для определения URL-адреса.  
  
 ASP.NET выполняет перенаправление, возвращая код состояния HTTP 301.  
  
   
  
## Examples  
 В следующем примере показано, как вызвать этот метод для перенаправления к маршруту с именем `Product` и у которого есть параметры с именами `productid` и `category`.  
  
```vb  
Response.RedirectToRoutePermanent("Product",  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Product",  
  new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ни один маршрут не соответствует указанным параметрам маршрута.</exception>
        <exception cref="T:System.Web.HttpException">Была предпринята попытка перенаправления после отправки заголовков HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Маршрутизация ASP.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveOutputCacheItem">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Удаляет элементы из кэша вывода с помощью поставщика кэша вывода по умолчанию.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveOutputCacheItem">
      <MemberSignature Language="C#" Value="public static void RemoveOutputCacheItem (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveOutputCacheItem(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RemoveOutputCacheItem(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveOutputCacheItem (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveOutputCacheItem(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member RemoveOutputCacheItem : string -&gt; unit" Usage="System.Web.HttpResponse.RemoveOutputCacheItem path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Виртуальный абсолютный путь к элементам, удаляемым из кэша.</param>
        <summary>Удаляет из кэша все элементы, связанные с поставщиком кэша вывода по умолчанию. Это статический метод.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите этот метод, чтобы удалить элементы кэша вывода, связанные с поставщиком кэша вывода по умолчанию. Вызовите метод <xref:System.Web.HttpResponse.RemoveOutputCacheItem%2A>, чтобы удалить элементы кэша вывода, связанные с пользовательскими поставщиками кэша вывода, которые указаны в файле конфигурации веб-сайта.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="path" /> не является абсолютным виртуальным путем.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveOutputCacheItem">
      <MemberSignature Language="C#" Value="public static void RemoveOutputCacheItem (string path, string providerName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveOutputCacheItem(string path, string providerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RemoveOutputCacheItem(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveOutputCacheItem (path As String, providerName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveOutputCacheItem(System::String ^ path, System::String ^ providerName);" />
      <MemberSignature Language="F#" Value="static member RemoveOutputCacheItem : string * string -&gt; unit" Usage="System.Web.HttpResponse.RemoveOutputCacheItem (path, providerName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="providerName" Type="System.String" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Виртуальный абсолютный путь к элементам, удаляемым из кэша.</param>
        <param name="providerName">Поставщик, используемый для удаления артефактов из кэша вывода, связанных с указанным путем.</param>
        <summary>С помощью указанного поставщика кэша вывода удаляет из кэша вывода все элементы, связанные с указанным путем.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите этот метод, чтобы удалить элементы кэша вывода, связанные с пользовательскими поставщиками кэша вывода, указанными в файле конфигурации веб-сайта. Чтобы удалить элементы кэша вывода, связанные с поставщиком кэша вывода по умолчанию, вызовите перегрузку метода <xref:System.Web.HttpResponse.RemoveOutputCacheItem%28System.String%29>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="path" /> имеет значение null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> является недопустимым путем.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCookie">
      <MemberSignature Language="C#" Value="public void SetCookie (System.Web.HttpCookie cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCookie(class System.Web.HttpCookie cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.SetCookie(System.Web.HttpCookie)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCookie (cookie As HttpCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCookie(System::Web::HttpCookie ^ cookie);" />
      <MemberSignature Language="F#" Value="member this.SetCookie : System.Web.HttpCookie -&gt; unit" Usage="httpResponse.SetCookie cookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Web.HttpCookie" />
      </Parameters>
      <Docs>
        <param name="cookie">Файл Cookie, который необходимо обновить в коллекции.</param>
        <summary>Так как метод <b>HttpResponse.SetCookie</b> предназначен только для внутреннего использования, его не следует вызывать в коде. Вместо этого можно вызвать метод <b>HttpResponse.Cookies.Set</b>, как показано в приведенном ниже примере.<br /> Обновляет существующий файл cookie из коллекции данных файлов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере обновляется значение существующего файла cookie.  
  
 [!code-csharp[Classic HttpResponse.SetCookie Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.SetCookie Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.SetCookie Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.SetCookie Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Сделана попытка задать файл Cookie после отправки заголовков HTTP.</exception>
        <altmember cref="F:System.Net.HttpRequestHeader.Cookie" />
        <altmember cref="T:System.Web.HttpCookie" />
        <altmember cref="T:System.Web.HttpCookieMode" />
      </Docs>
    </Member>
    <Member MemberName="Status">
      <MemberSignature Language="C#" Value="public string Status { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Status" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Status" />
      <MemberSignature Language="VB.NET" Value="Public Property Status As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Status { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Status : string with get, set" Usage="System.Web.HttpResponse.Status" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Задает строку <see langword="Status" />, возвращаемую клиенту.</summary>
        <value>При задании кода состояния клиенту возвращается строка, описывающая состояние вывода НТТР. По умолчанию используется значение "200 (ОК)".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.Status%2A> является нерекомендуемым в пользу <xref:System.Web.HttpResponse.StatusDescription%2A> и предоставляется только для обеспечения совместимости с предыдущими версиями ASP. В ASP.NET используйте вместо него <xref:System.Web.HttpResponse.StatusDescription%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Задан недопустимый код состояния.</exception>
      </Docs>
    </Member>
    <Member MemberName="StatusCode">
      <MemberSignature Language="C#" Value="public int StatusCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 StatusCode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.StatusCode" />
      <MemberSignature Language="VB.NET" Value="Public Property StatusCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int StatusCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.StatusCode : int with get, set" Usage="System.Web.HttpResponse.StatusCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает код состояния НТТР вывода, возвращаемого клиенту.</summary>
        <value>Целое число, представляющее состояние НТТР вывода, возвращаемого клиенту. По умолчанию используется значение "200 (ОК)". Список допустимых кодов состояния см. в разделе <see href="/windows/win32/winhttp/http-status-codes">коды состояния HTTP</see>.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере проверяется код состояния выходного потока. Если код состояния не равен 200, выполняется дополнительный код.  
  
 [!code-csharp[System.Web.HttpResponse.StatusCode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.StatusCode/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.StatusCode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.StatusCode/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Свойство <see cref="P:System.Web.HttpResponse.StatusCode" /> задается после отправки заголовков HTTP.</exception>
        <altmember cref="P:System.Web.HttpResponse.SubStatusCode" />
      </Docs>
    </Member>
    <Member MemberName="StatusDescription">
      <MemberSignature Language="C#" Value="public string StatusDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StatusDescription" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.StatusDescription" />
      <MemberSignature Language="VB.NET" Value="Public Property StatusDescription As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ StatusDescription { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StatusDescription : string with get, set" Usage="System.Web.HttpResponse.StatusDescription" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает строку состояния НТТР вывода, возвращаемого клиенту.</summary>
        <value>Строка, описывающая состояние НТТР вывода, возвращаемого клиенту. По умолчанию используется значение "ОК". Список допустимых кодов состояния см. в разделе [коды состояния HTTP](https://go.microsoft.com/fwlink/?LinkId=73157).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере проверяется строка состояния выходного потока. Если состояние не равно "ОК", выполняется дополнительный код.  
  
 [!code-csharp[System.Web.HttpResponse.StatusDescription#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.StatusDescription/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.StatusDescription#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.StatusDescription/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Свойство <paramref name="StatusDescription" /> задается после отправки заголовков HTTP.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Выбранное значение имеет длину больше 512.</exception>
      </Docs>
    </Member>
    <Member MemberName="SubStatusCode">
      <MemberSignature Language="C#" Value="public int SubStatusCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SubStatusCode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SubStatusCode" />
      <MemberSignature Language="VB.NET" Value="Public Property SubStatusCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SubStatusCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SubStatusCode : int with get, set" Usage="System.Web.HttpResponse.SubStatusCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, определяющее код состояния ответа.</summary>
        <value>Целочисленное значение, которое представляет код подсостояния [!INCLUDE[iisver](~/includes/iisver-md.md)].</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Web.HttpResponse.SubStatusCode%2A> поддерживается только в интегрированном режиме конвейера в [!INCLUDE[iisver](~/includes/iisver-md.md)] и по крайней мере .NET Framework версии 3,0. При задании свойства <xref:System.Web.HttpResponse.SubStatusCode%2A> состояние заносится в журнал [!INCLUDE[iisver](~/includes/iisver-md.md)] если настроена Трассировка невыполненных запросов. Независимо от того, настроена ли трассировка, код никогда не отправляется как часть последнего ответа на запрос. Дополнительные сведения см. [в разделе Устранение неполадок неудачных запросов с помощью трассировки неудачных запросов в IIS 7,0](http://www.iis.net/default.aspx?tabid=2&subtabid=25&i=969&p=1).  
  
   
  
## Examples  
 В следующем примере свойство <xref:System.Web.HttpResponse.SubStatusCode%2A> задается в обработчике событий для <xref:System.Web.HttpApplication> экземпляра события <xref:System.Web.HttpApplication.PostAuthenticateRequest>. Вставьте файл кода в папку App_Code веб-приложения и настройте файл Web. config для регистрации модуля. Дополнительные сведения см. [в разделе Пошаговое руководство. Создание и регистрация настраиваемого модуля HTTP](https://msdn.microsoft.com/library/7787d5be-40a4-4072-9075-c2b767428453).  
  
 [!code-csharp[System.Web.HttpResponse.SubStatusCode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.SubStatusCode/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.SubStatusCode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.SubStatusCode/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Для этой операции требуется режим интегрированного конвейера в [!INCLUDE[iisver](~/includes/iisver-md.md)] и по крайней мере .NET Framework версии 3.0.</exception>
        <exception cref="T:System.Web.HttpException">Код состояния задается после отправки всех заголовков HTTP.</exception>
        <altmember cref="P:System.Web.HttpResponse.StatusCode" />
      </Docs>
    </Member>
    <Member MemberName="SupportsAsyncFlush">
      <MemberSignature Language="C#" Value="public bool SupportsAsyncFlush { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsAsyncFlush" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SupportsAsyncFlush" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SupportsAsyncFlush As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SupportsAsyncFlush { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsAsyncFlush : bool" Usage="System.Web.HttpResponse.SupportsAsyncFlush" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, показывающее, поддерживает ли подключение асинхронные операции очистки.</summary>
        <value>Значение <see langword="true" />, если подключение поддерживает асинхронные операции очистки; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство возвращает значение свойства <xref:System.Web.HttpWorkerRequest.SupportsAsyncFlush%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressContent">
      <MemberSignature Language="C#" Value="public bool SuppressContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressContent" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressContent" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressContent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressContent { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SuppressContent : bool with get, set" Usage="System.Web.HttpResponse.SuppressContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, показывающее, следует ли отправить содержимое НТТР клиенту.</summary>
        <value>Значение <see langword="true" /> для подавления вывода; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере проверяется, имеет ли свойство <xref:System.Web.HttpRequest.IsSecureConnection%2A> значение false. Если это так, свойство <xref:System.Web.HttpResponse.SuppressContent%2A> имеет значение true, чтобы предотвратить отправку ответа.  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsesuppresscontentcs.aspx#3)]
 [!code-vb[System.Web.HttpResponse_Sample5#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsesuppresscontentvb.aspx#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressDefaultCacheControlHeader">
      <MemberSignature Language="C#" Value="public bool SuppressDefaultCacheControlHeader { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressDefaultCacheControlHeader" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressDefaultCacheControlHeader" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressDefaultCacheControlHeader As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressDefaultCacheControlHeader { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SuppressDefaultCacheControlHeader : bool with get, set" Usage="System.Web.HttpResponse.SuppressDefaultCacheControlHeader" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, следует ли подавлять заголовок <c>Cache Control: private</c> по умолчанию для текущего HTTP-ответа.</summary>
        <value><see langword="true" /> отключить для текущего HTTP-ответа заданный по умолчанию заголовок <c>"Control Cache: закрытый</c> "; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию ASP.NET отправляет заголовок ответа `Cache-Control: private`, если для этого ответа не указана явная политика кэширования. Это свойство позволяет подавлять этот заголовок ответа по умолчанию для каждого запроса. Заголовок по-прежнему можно подавлять для всего приложения, задав <xref:System.Web.Configuration.HttpRuntimeSection.SendCacheControlHeader%2A> в [элементе httpRuntime (схема параметров ASP.NET)](https://msdn.microsoft.com/library/e9b81350-8aaf-47cc-9843-5f7d0c59f369) или в [элементе OutputCache для кэширования (схема параметров ASP.NET)](https://msdn.microsoft.com/library/47cd2b47-316f-4dfd-bbf8-539be3066fee).  
  
 Будьте внимательны при подавлении заголовка `Cache-Control: private` по умолчанию, так как прокси-серверы и другие посредники могут обрабатывать ответы без этого заголовка как кэшированные по умолчанию. Такая обработка может привести к непреднамеренному кэшированию конфиденциальной информации. Дополнительные сведения см. в [RFC 2616, с. 13,4](https://tools.ietf.org/html/rfc2616) .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressFormsAuthenticationRedirect">
      <MemberSignature Language="C#" Value="public bool SuppressFormsAuthenticationRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressFormsAuthenticationRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressFormsAuthenticationRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressFormsAuthenticationRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressFormsAuthenticationRedirect { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SuppressFormsAuthenticationRedirect : bool with get, set" Usage="System.Web.HttpResponse.SuppressFormsAuthenticationRedirect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, следует ли отключить перенаправление аутентификации с помощью форм на страницу входа.</summary>
        <value>Значение <see langword="true" />, если перенаправление аутентификации на основе форм должно быть отменено; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию проверка подлинности с помощью форм преобразует коды состояния HTTP 401 в 302 для перенаправления на страницу входа. Это не подходит для определенных классов ошибок, например, когда проверка подлинности завершается успешно, но при этом происходит сбой авторизации или если текущий запрос является запросом AJAX или веб-службы. Это свойство позволяет отключить поведение перенаправления и отправить клиенту исходный код состояния.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TransmitFile">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Записывает указанный файл непосредственно в выходной поток ответа HTTP, не используя буфер в памяти.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TransmitFile">
      <MemberSignature Language="C#" Value="public void TransmitFile (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransmitFile(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.TransmitFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransmitFile (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransmitFile(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="member this.TransmitFile : string -&gt; unit" Usage="httpResponse.TransmitFile filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Имя файла, который записывается в выходные данные НТТР.</param>
        <summary>Записывает указанный файл непосредственно в выходной поток ответа HTTP, не используя буфер в памяти.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="filename" /> равно <see langword="null" /></exception>
      </Docs>
    </Member>
    <Member MemberName="TransmitFile">
      <MemberSignature Language="C#" Value="public void TransmitFile (string filename, long offset, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransmitFile(string filename, int64 offset, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.TransmitFile(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransmitFile (filename As String, offset As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransmitFile(System::String ^ filename, long offset, long length);" />
      <MemberSignature Language="F#" Value="member this.TransmitFile : string * int64 * int64 -&gt; unit" Usage="httpResponse.TransmitFile (filename, offset, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="offset" Type="System.Int64" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="length" Type="System.Int64" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="filename">Имя файла, который записывается в выходные данные НТТР.</param>
        <param name="offset">Позиция в файле, с которой начинается запись в выходные данные НТТР.</param>
        <param name="length">Количество передаваемых байтов.</param>
        <summary>Записывает указанную часть файла непосредственно в поток вывода ответа HTTP, не используя буфер в памяти.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если указать 0 в качестве параметра `offset` и-1 в качестве параметра `length`, отправляется весь файл.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="offset" /> меньше нуля.  
  
- или - 
Значение параметра <paramref name="length" /> меньше –1.  
  
- или - 
Параметр <paramref name="length" /> указывает количество байтов, превышающее количество байтов в файле, уменьшенное на значение смещения.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Внепроцессный рабочий запрос не поддерживается.  
  
- или - 
Ответ не использует объект <see cref="T:System.Web.HttpWriter" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="offset" /> меньше нуля или больше размера файла.  
  
- или - 
Значение параметра <paramref name="length" /> меньше -1 или больше значения параметра <paramref name="offset" /> плюс размер файла.</exception>
      </Docs>
    </Member>
    <Member MemberName="TrySkipIisCustomErrors">
      <MemberSignature Language="C#" Value="public bool TrySkipIisCustomErrors { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TrySkipIisCustomErrors" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.TrySkipIisCustomErrors" />
      <MemberSignature Language="VB.NET" Value="Public Property TrySkipIisCustomErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TrySkipIisCustomErrors { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TrySkipIisCustomErrors : bool with get, set" Usage="System.Web.HttpResponse.TrySkipIisCustomErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, которое указывает, отключены ли пользовательские ошибки [!INCLUDE[iisver](~/includes/iisver-md.md)].</summary>
        <value>Значение <see langword="true" />, чтобы запретить пользовательские ошибки IIS, в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A> используется только в том случае, если приложение размещено в IIS 7,0 и более поздних версиях. При работе в классическом режиме значение по умолчанию для свойства <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A> равно `true`. При работе в интегрированном режиме значение по умолчанию для свойства <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A> равно `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Записывает сведения в поток вывода ответа НТТР.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (char ch);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(char ch) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (ch As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(char ch);" />
      <MemberSignature Language="F#" Value="member this.Write : char -&gt; unit" Usage="httpResponse.Write ch" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ch" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ch">Знак, записываемый в поток вывода НТТР.</param>
        <summary>Записывает знак в поток вывода ответа НТТР.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере создается ряд констант, которые записываются на страницу ASP.NET с помощью метода Write. Код вызывает эту версию метода Write для записи отдельных символьных констант на страницу.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample5#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsewritecharscs.aspx#4)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample5#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsewritecharsvb.aspx#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="member this.Write : obj -&gt; unit" Usage="httpResponse.Write obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Объект <see cref="T:System.Object" />, записываемый в поток вывода НТТР.</param>
        <summary>Записывает объект <see cref="T:System.Object" /> в поток ответа HTTP.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (s As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.Write : string -&gt; unit" Usage="httpResponse.Write s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Строка, записываемая в поток вывода НТТР.</param>
        <summary>Записывает строку в поток вывода ответа НТТР.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Динамически создаваемые страницы HTML могут привести к угрозам безопасности, если входные данные, полученные от веб-клиентов, не проверяются при получении от клиента или при передаче обратно клиенту. Вредоносный сценарий, внедренный во входные данные, отправленные на веб-сайт и последующий возврат клиенту, может считаться источником из надежного источника. Такая угроза безопасности называется атакой с помощью межсайтовых сценариев. Всегда следует проверять данные, получаемые от клиента, когда они будут переданы из вашего сайта в клиентские браузеры.  
  
 Более того, каждый раз, когда вы записываете данные в формате HTML в качестве входных данных, следует кодировать его с помощью такой методики, как <xref:System.Web.HttpServerUtility.HtmlEncode%2A> или <xref:System.Web.HttpServerUtility.UrlEncode%2A>, чтобы предотвратить выполнение вредоносного скрипта. Этот метод полезен для данных, которые не проверялись при получении.  
  
 При кодировании или фильтрации данных необходимо указать кодировку для веб-страниц, чтобы фильтр мог вычислить и удалить все последовательности байтов, которые не принадлежат этому набору (например, не буквенно-цифровые последовательности) и потенциально могут содержать вредоносные сценарии, внедренные в сделать.  
  
 Дополнительные сведения об атаках с использованием межсайтовых сценариев см. в статье Q252985 "Предотвращение проблем безопасности межсайтовых сценариев" на веб-сайте [базы знаний Майкрософт](https://go.microsoft.com/fwlink/?LinkID=37115) .  
  
   
  
## Examples  
 Следующий пример возвращает имя клиента обратно в браузер клиента. Метод <xref:System.Web.HttpServerUtility.HtmlEncode%2A> удаляет все вредоносные скрипты и недопустимые символы, которые могли быть переданы в поле ввода `UserName`.  
  
 [!code-csharp[System.Web.HttpResponse.Write#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Write/CS/systemwebhttpresponsewrite.cs#1)]
 [!code-vb[System.Web.HttpResponse.Write#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Write/vb/systemwebhttpresponsewrite.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (buffer As Char(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.Write : char[] * int * int -&gt; unit" Usage="httpResponse.Write (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Записываемый массив знаков.</param>
        <param name="index">Позиция в массиве символов, с которой начинается запись.</param>
        <param name="count">Число знаков для записи, начиная с параметра <paramref name="index" />.</param>
        <summary>Записывает массив символов в поток вывода ответа НТТР.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере создается ряд констант, которые записываются на страницу ASP.NET с помощью метода Write. Код вызывает эту версию метода Write для записи отдельных символьных констант на страницу.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample5#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsewritecharscs.aspx#4)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample5#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsewritecharsvb.aspx#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteFile">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Записывает указанный файл непосредственно в поток вывода ответа НТТР.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : string -&gt; unit" Usage="httpResponse.WriteFile filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Имя файла, который записывается в выходные данные НТТР.</param>
        <summary>Записывает содержимое указанного файла непосредственно в выходной поток ответа HTTP в виде блока файла.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если этот метод используется с большими файлами, вызов метода может вызвать исключение. Размер файла, который может использоваться с этим методом, зависит от конфигурации оборудования веб-сервера. Дополнительные сведения см. в статье 812406, «PRB: Response. WriteFile не удается скачать большой файл» на веб-сайте [базы знаний Майкрософт](https://go.microsoft.com/fwlink/?linkid=149903) .  
  
   
  
## Examples  
 В следующем примере записывается все содержимое текстового файла с именем `Login.txt` (который может содержать литеральный текст HTML и элементы управления вводом) непосредственно в поток вывода.  
  
 [!code-csharp[Classic HttpResponse.WriteFile Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="filename" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename, bool readIntoMemory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename, bool readIntoMemory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String, readIntoMemory As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename, bool readIntoMemory);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : string * bool -&gt; unit" Usage="httpResponse.WriteFile (filename, readIntoMemory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="readIntoMemory" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filename">Имя файла, записываемого в блок памяти.</param>
        <param name="readIntoMemory">Указывает на то, что файл будет записан в блок памяти.</param>
        <summary>Записывает содержимое указанного файла непосредственно в выходной поток ответа HTTP в виде блока памяти.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если этот метод используется с большими файлами, вызов метода может вызвать исключение. Размер файла, который может использоваться с этим методом, зависит от конфигурации оборудования веб-сервера. Дополнительные сведения см. в статье 812406, «PRB: Response. WriteFile не удается скачать большой файл» на веб-сайте [базы знаний Майкрософт](https://go.microsoft.com/fwlink/?linkid=149903) .  
  
   
  
## Examples  
 В следующем примере файл записывается в память.  
  
 [!code-csharp[Classic HttpResponse.WriteFile1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="filename" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (IntPtr fileHandle, long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(native int fileHandle, int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.IntPtr,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (fileHandle As IntPtr, offset As Long, size As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(IntPtr fileHandle, long offset, long size);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : nativeint * int64 * int64 -&gt; unit" Usage="httpResponse.WriteFile (fileHandle, offset, size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileHandle" Type="System.IntPtr" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="fileHandle">Дескриптор файла, который записывается в поток вывода НТТР.</param>
        <param name="offset">Позиция байта в файле, с которой начинается запись.</param>
        <param name="size">Число байтов, записываемое в поток вывода.</param>
        <summary>Записывает указанный файл непосредственно в поток вывода ответа НТТР.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если этот метод используется с большими файлами, вызов метода может вызвать исключение. Размер файла, который может использоваться с этим методом, зависит от конфигурации оборудования веб-сервера. Дополнительные сведения см. в статье 812406, «PRB: Response. WriteFile не удается скачать большой файл» на веб-сайте [базы знаний Майкрософт](https://go.microsoft.com/fwlink/?linkid=149903) .  
  
   
  
## Examples  
 В следующем примере записывается все содержимое текстового файла с именем `Login.txt` (который может содержать литеральный текст HTML и элементы управления вводом) непосредственно в поток вывода.  
  
 [!code-csharp[Classic HttpResponse.WriteFile3 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile3 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="fileHandler" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException">Значение параметра <paramref name="offset" /> меньше 0.  
  
- или - 
 Параметр <paramref name="size" /> больше, чем размер файла минус <paramref name="offset" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename, long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename, int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String, offset As Long, size As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename, long offset, long size);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : string * int64 * int64 -&gt; unit" Usage="httpResponse.WriteFile (filename, offset, size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="filename">Имя файла, который записывается в поток вывода НТТР.</param>
        <param name="offset">Позиция байта в файле, с которой начинается запись.</param>
        <param name="size">Число байтов, записываемое в поток вывода.</param>
        <summary>Записывает указанный файл непосредственно в поток вывода ответа НТТР.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если этот метод используется с большими файлами, вызов метода может вызвать исключение. Размер файла, который может использоваться с этим методом, зависит от конфигурации оборудования веб-сервера. Дополнительные сведения см. в статье 812406, «PRB: Response. WriteFile не удается скачать большой файл» на веб-сайте [базы знаний Майкрософт](https://go.microsoft.com/fwlink/?linkid=149903) .  
  
   
  
## Examples  
 В следующем примере записывается все содержимое текстового файла с именем `Login.txt` (который может содержать литеральный текст и элементы управления вводом HTML) непосредственно в поток вывода.  
  
 [!code-csharp[Classic HttpResponse.WriteFile2 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile2 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Значение параметра <paramref name="offset" /> меньше 0.  
  
- или - 
 Параметр <paramref name="size" /> больше, чем размер файла минус <paramref name="offset" />.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="filename" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteSubstitution">
      <MemberSignature Language="C#" Value="public void WriteSubstitution (System.Web.HttpResponseSubstitutionCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteSubstitution(class System.Web.HttpResponseSubstitutionCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteSubstitution(System.Web.HttpResponseSubstitutionCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteSubstitution (callback As HttpResponseSubstitutionCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteSubstitution(System::Web::HttpResponseSubstitutionCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.WriteSubstitution : System.Web.HttpResponseSubstitutionCallback -&gt; unit" Usage="httpResponse.WriteSubstitution callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Web.HttpResponseSubstitutionCallback" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">Метод, пользовательский элемент управления или объект для замены.</param>
        <summary>Позволяет выполнять вставку блоков замены ответа в ответ, что предоставляет возможность для динамического формирования указанных областей ответа для выходных кэшируемых ответов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно использовать метод <xref:System.Web.HttpResponse.WriteSubstitution%2A> для подстановки после кэширования на страницах, кэшированных на выходе. Передавая объект <xref:System.Web.HttpContext> в метод обратного вызова с предписанной сигнатурой <xref:System.Web.HttpResponseSubstitutionCallback>, можно заменить выходное кэшированное содержимое в любом заданном расположении в кэше страниц. Чтобы начать замену, вызовите метод <xref:System.Web.HttpResponse.WriteSubstitution%2A>, передав ему метод обратного вызова, который должен быть потокобезопасным и может быть одним из следующих:  
  
-   Статический метод на странице контейнера или в пользовательском элементе управления.  
  
-   Статический метод или экземпляр для другого произвольного объекта.  
  
 При первом запросе к странице <xref:System.Web.HttpResponse.WriteSubstitution%2A> вызывает делегат <xref:System.Web.HttpResponseSubstitutionCallback> для получения выходных данных. Затем он добавляет к ответу буфер подстановки, который оставляет делегат для вызова в будущих запросах. Наконец, она снижает возможность кэширования на стороне клиента с общедоступного до сервера, гарантируя, что будущие запросы к странице повторно вызывают делегат, не кэшированные на клиенте.  
  
> [!NOTE]
>  Подстановка после кэширования не поддерживается для кэшированного пользовательского элемента управления, где кэширование вывода применяется на уровне пользовательского элемента управления. Это также называется кэшированием фрагментов. Дополнительные сведения см. в разделе [Кэширование частей страницы ASP.NET](https://msdn.microsoft.com/library/cdd8e523-7305-4685-a456-c5be1de1367e).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Целевой объект параметра <paramref name="callback" /> имеет тип <see cref="T:System.Web.UI.Control" />.</exception>
        <altmember cref="T:System.Web.HttpResponseSubstitutionCallback" />
        <altmember cref="T:System.Web.UI.WebControls.Substitution" />
        <related type="Article" href="https://msdn.microsoft.com/library/d5fbd79f-972d-4557-9a39-f90684b3dcd3">Настройка кэширования страницы</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cdd8e523-7305-4685-a456-c5be1de1367e">Кэширование частей страницы ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/09c9bd9a-0d68-4a5c-aa6f-1b461c208795">Динамическое обновление частей кэшированной страницы</related>
      </Docs>
    </Member>
  </Members>
</Type>
