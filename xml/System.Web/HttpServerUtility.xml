<Type Name="HttpServerUtility" FullName="System.Web.HttpServerUtility">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0b6477787c17199600536f8a4df06d52440d68c5" /><Meta Name="ms.sourcegitcommit" Value="9a6da88bd5455e8274257ca7ad259b42f1de114f" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="05/22/2019" /><Meta Name="ms.locfileid" Value="66008072" /></Metadata><TypeSignature Language="C#" Value="public sealed class HttpServerUtility" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpServerUtility extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpServerUtility" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpServerUtility" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpServerUtility sealed" />
  <TypeSignature Language="F#" Value="type HttpServerUtility = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Предоставляет вспомогательные методы для обработки веб-запросов.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Методы и свойства <xref:System.Web.HttpServerUtility> предоставляются посредством внутреннего <xref:System.Web.HttpContext.Server%2A> объект, предоставляемый ASP.NET.  
  
   
  
## Examples  
 Проект Visual Studio Web сайта с исходным кодом доступен на следующей странице в этом разделе: [Скачайте](https://go.microsoft.com/fwlink/?LinkId=192870).  
  
 Следующий пример демонстрирует, как использовать <xref:System.Web.HttpServerUtility.HtmlEncode%2A> метод и <xref:System.Web.HttpServerUtility.UrlEncode%2A> метод <xref:System.Web.HttpServerUtility> класса. <xref:System.Web.HttpServerUtility.HtmlEncode%2A> Метод гарантирует, любая строка пользовательские входные данные будут отображены в виде статического текста в браузерах, а не исполняемый сценарий или HTML-элементов. <xref:System.Web.HttpServerUtility.UrlEncode%2A> Метод кодирует URL-адреса приложения таким образом, чтобы правильно передаются в поток HTTP.  
  
 [!code-aspx-csharp[System.Web.HttpServerUtility1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpServerUtility1/cs/HttpServerUtilityCS.aspx#1)]
 [!code-aspx-vb[System.Web.HttpServerUtility1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpServerUtility1/vb/HttpServerUtilityVB.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.HttpContext" />
  </Docs>
  <Members>
    <Member MemberName="ClearError">
      <MemberSignature Language="C#" Value="public void ClearError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.ClearError" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearError ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearError();" />
      <MemberSignature Language="F#" Value="member this.ClearError : unit -&gt; unit" Usage="httpServerUtility.ClearError " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет предыдущее исключение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Следующий пример удаляет последнее исключение, вызванное исключение.  
  
 [!code-csharp[Classic HttpServerUtility.ClearError Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.ClearError Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.ClearError Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.ClearError Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpServerUtility.GetLastError" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает на сервере экземпляр объекта СОМ.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateObject">
      <MemberSignature Language="C#" Value="public object CreateObject (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateObject(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.CreateObject(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObject (progID As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateObject(System::String ^ progID);" />
      <MemberSignature Language="F#" Value="member this.CreateObject : string -&gt; obj" Usage="httpServerUtility.CreateObject progID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">Класс или тип объекта создаваемого экземпляра.</param>
        <summary>Создает на сервере экземпляр объекта СОМ, заданный программным идентификатором объектов (ProgID).</summary>
        <returns>Новый объект.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере создается объект с помощью его ProgID.  
  
 [!code-csharp[Classic HttpServerUtility.CreateObject Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObject Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.CreateObject Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObject Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Не удалось создать экземпляр объекта.</exception>
        <altmember cref="M:System.Web.HttpServerUtility.CreateObjectFromClsid(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateObject">
      <MemberSignature Language="C#" Value="public object CreateObject (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateObject(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.CreateObject(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateObject(Type ^ type);" />
      <MemberSignature Language="F#" Value="member this.CreateObject : Type -&gt; obj" Usage="httpServerUtility.CreateObject type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" />, который представляет создаваемый объект.</param>
        <summary>Создает на сервере экземпляр объекта СОМ, заданный с помощью типа объекта.</summary>
        <returns>Новый объект.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObjectFromClsid">
      <MemberSignature Language="C#" Value="public object CreateObjectFromClsid (string clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateObjectFromClsid(string clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.CreateObjectFromClsid(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObjectFromClsid (clsid As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateObjectFromClsid(System::String ^ clsid);" />
      <MemberSignature Language="F#" Value="member this.CreateObjectFromClsid : string -&gt; obj" Usage="httpServerUtility.CreateObjectFromClsid clsid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clsid">Идентификатор класса объекта создаваемого экземпляра.</param>
        <summary>Создает на сервере экземпляр объекта СОМ, заданный идентификатором класса объектов (CLSID).</summary>
        <returns>Новый объект.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Следующий пример демонстрирует, как использовать <xref:System.Web.HttpServerUtility.CreateObjectFromClsid%2A> метод для создания на сервере экземпляр COM-объекта.  
  
 [!code-csharp[Classic HttpServerUtility.CreateObjectFromClsid Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObjectFromClsid Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.CreateObjectFromClsid Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObjectFromClsid Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Не удалось создать экземпляр объекта.</exception>
        <altmember cref="M:System.Web.HttpServerUtility.CreateObject(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Execute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет действия обработчика для заданного ресурса в контексте текущего запроса и возвращает выполнение на страницу, которая его вызвала.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.Execute : string -&gt; unit" Usage="httpServerUtility.Execute path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Выполняемый URL-путь.</param>
        <summary>Выполняет действия обработчика для заданного виртуального пути в контексте текущего запроса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.Execute%2A> Метод продолжает выполнение исходной страницы, после завершения выполнения новой страницы. <xref:System.Web.HttpServerUtility.Transfer%2A> Метод Безусловно передает управление другому обработчику.  
  
 ASP.NET не проверяет, что текущий пользователь авторизован для просмотра ресурсов, доставленных <xref:System.Web.HttpServerUtility.Execute%2A> метод. Несмотря на то, что логика авторизации и проверки подлинности ASP.NET выполняется перед вызовом исходного обработчик ресурсов, ASP.NET напрямую вызывает обработчика, указанного по <xref:System.Web.HttpServerUtility.Execute%2A> метода и не выполняют повторный запуск проверки подлинности и авторизации для нового ресурс. Если политика безопасности приложения требует соответствующей авторизации для доступа к ресурсу, у клиентов, приложения следует принудительно выполняет повторную авторизацию или предоставляет механизм пользовательского управления доступом.  
  
 Можно принудительно выполняет повторную авторизацию с помощью <xref:System.Web.HttpResponse.Redirect%2A> вместо метода <xref:System.Web.HttpServerUtility.Execute%2A> метод. <xref:System.Web.HttpResponse.Redirect%2A> выполняет перенаправление на стороне клиента, в котором браузер запрашивает новый ресурс. Так как это перенаправление является новый запрос, то вход в систему, оно проходит все проверки подлинности и авторизации политика безопасности Internet Information Services (IIS) и ASP.NET.  
  
 Убедитесь, что у пользователя есть разрешение на просмотр ресурсов, добавляя метод настраиваемой авторизации, который использует <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> метод прежде, чем приложение вызовет <xref:System.Web.HttpServerUtility.Execute%2A> метод.  
  
   
  
## Examples  
 Следующий пример отображает ASPX-страницы «Updateinfo.aspx» в текущем каталоге. После отображения страницы Updateinfo.aspx выполнение программы возвращает начальную страницу.  
  
 [!code-csharp[Classic HttpServerUtility.Execute Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.Execute Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.Execute Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.Execute Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Текущий объект <see cref="T:System.Web.HttpContext" /> имеет значение <see langword="null" />.  
  
-или- 
Произошла ошибка при выполнении действий обработчика, заданного <paramref name="path" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.  
  
-или- 
 <paramref name="path" /> не является виртуальным путем.</exception>
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.Execute : string * bool -&gt; unit" Usage="httpServerUtility.Execute (path, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Выполняемый URL-путь.</param>
        <param name="preserveForm">Значение <see langword="true" /> — для сохранения коллекций <see cref="P:System.Web.HttpRequest.QueryString" /> и <see cref="P:System.Web.HttpRequest.Form" />; <see langword="false" /> — для очистки коллекций <see cref="P:System.Web.HttpRequest.QueryString" /> и <see cref="P:System.Web.HttpRequest.Form" />.</param>
        <summary>Выполняет действия обработчика для заданного виртуального пути в контексте текущего запроса и указывает, необходимо ли очистить коллекции <see cref="P:System.Web.HttpRequest.QueryString" /> и <see cref="P:System.Web.HttpRequest.Form" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере показано выполнение на страницу ASPX `Updateinfo.aspx` в текущем запросе и preserve <xref:System.Web.HttpRequest.QueryString%2A> и <xref:System.Web.HttpRequest.Form%2A> коллекций. Возвращает начальную страницу после выполнения программы `Updateinfo.aspx` отображается.  
  
 [!code-csharp[HttpServerUtility.Execute#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpServerUtility.Execute/CS/httpserverutility.execute_cs.aspx#1)]
 [!code-vb[HttpServerUtility.Execute#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpServerUtility.Execute/VB/httpserverutility.execute_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Текущий объект <see cref="T:System.Web.HttpContext" /> имеет значение <see langword="null" />.  
  
-или- 
Произошла ошибка при выполнении действий обработчика, заданного <paramref name="path" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.  
  
-или- 
 <paramref name="path" /> не является виртуальным путем.</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path, System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path, class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String, writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path, System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.Execute : string * System.IO.TextWriter -&gt; unit" Usage="httpServerUtility.Execute (path, writer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="path">Выполняемый URL-путь.</param>
        <param name="writer"><see cref="T:System.IO.TextWriter" /> для перенаправления выходных данных.</param>
        <summary>Выполняет действия обработчика для заданного виртуального пути в контексте текущего запроса. <see cref="T:System.IO.TextWriter" /> перенаправляет выходные данные выполненного обработчика.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.Execute%2A> Метод продолжает выполнение исходного запроса, после завершения выполнения указанного виртуального пути. <xref:System.Web.HttpServerUtility.Transfer%2A> Метод Безусловно передает управление другому обработчику.  
  
 ASP.NET не проверяет, что текущий пользователь авторизован для просмотра ресурсов, доставленных <xref:System.Web.HttpServerUtility.Execute%2A> метод. Несмотря на то, что логика авторизации и проверки подлинности ASP.NET выполняется перед вызовом исходного обработчик ресурсов, ASP.NET напрямую вызывает обработчика, указанного по <xref:System.Web.HttpServerUtility.Execute%2A> метода и не выполняют повторный запуск проверки подлинности и авторизации для нового ресурс. Если политика безопасности приложения требует соответствующей авторизации для доступа к ресурсу, у клиентов, приложения следует принудительно выполняет повторную авторизацию или предоставляет механизм пользовательского управления доступом.  
  
 Можно принудительно выполняет повторную авторизацию с помощью <xref:System.Web.HttpResponse.Redirect%2A> вместо метода <xref:System.Web.HttpServerUtility.Execute%2A> метод. <xref:System.Web.HttpResponse.Redirect%2A> выполняет перенаправление на стороне клиента, в котором браузер запрашивает новый ресурс. Так как это перенаправление является новый запрос, то вход в систему, оно проходит все проверки подлинности и авторизации политика безопасности Internet Information Services (IIS) и ASP.NET.  
  
 Убедитесь, что у пользователя есть разрешение на просмотр ресурсов, добавляя метод настраиваемой авторизации, который использует <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> метод прежде, чем приложение вызовет <xref:System.Web.HttpServerUtility.Execute%2A> метод.  
  
   
  
## Examples  
 В следующем примере выполняется `Login.aspx` странице на сервере в текущем каталоге и получает выходные данные со страницы через <xref:System.IO.StringWriter> объект `writer`. Он записывает в поток HTML, полученные от `writer` поток вывода НТТР.  
  
 [!code-csharp[Classic HttpServerUtility.Execute1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.Execute1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.Execute1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.Execute1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Текущий объект <see cref="T:System.Web.HttpContext" /> имеет значение <see langword="null" />.  
  
-или- 
Произошла ошибка при выполнении действий обработчика, заданного <paramref name="path" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.  
  
-или- 
 <paramref name="path" /> не является виртуальным путем.</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path, System.IO.TextWriter writer, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path, class System.IO.TextWriter writer, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String,System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String, writer As TextWriter, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path, System::IO::TextWriter ^ writer, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.Execute : string * System.IO.TextWriter * bool -&gt; unit" Usage="httpServerUtility.Execute (path, writer, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Выполняемый URL-путь.</param>
        <param name="writer"><see cref="T:System.IO.TextWriter" /> для перенаправления выходных данных.</param>
        <param name="preserveForm">Значение <see langword="true" /> — для сохранения коллекций <see cref="P:System.Web.HttpRequest.QueryString" /> и <see cref="P:System.Web.HttpRequest.Form" />; <see langword="false" /> — для очистки коллекций <see cref="P:System.Web.HttpRequest.QueryString" /> и <see cref="P:System.Web.HttpRequest.Form" />.</param>
        <summary>Выполняет действия обработчика для заданного виртуального пути в контексте текущего запроса. <see cref="T:System.IO.TextWriter" /> перенаправляет выходные данные со страницы, а логический параметр указывает, необходимо ли очищать коллекции <see cref="P:System.Web.HttpRequest.QueryString" /> и <see cref="P:System.Web.HttpRequest.Form" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.Execute%2A> Метод продолжает выполнение исходного запроса, после завершения выполнения указанного виртуального пути. <xref:System.Web.HttpServerUtility.Transfer%2A> Метод Безусловно передает управление другому обработчику.  
  
 ASP.NET не проверяет, что текущий пользователь авторизован для просмотра ресурсов, доставленных <xref:System.Web.HttpServerUtility.Execute%2A> метод. Несмотря на то, что логика авторизации и проверки подлинности ASP.NET выполняется перед вызовом исходного обработчик ресурсов, ASP.NET напрямую вызывает обработчика, указанного по <xref:System.Web.HttpServerUtility.Execute%2A> метода и не выполняют повторный запуск проверки подлинности и авторизации для нового ресурс. Если политика безопасности приложения требует соответствующей авторизации для доступа к ресурсу, у клиентов, приложения следует принудительно выполняет повторную авторизацию или предоставляет механизм пользовательского управления доступом.  
  
 Можно принудительно выполняет повторную авторизацию с помощью <xref:System.Web.HttpResponse.Redirect%2A> вместо метода <xref:System.Web.HttpServerUtility.Execute%2A> метод. <xref:System.Web.HttpResponse.Redirect%2A> выполняет перенаправление на стороне клиента, в котором браузер запрашивает новый ресурс. Так как это перенаправление является новый запрос, то вход в систему, оно проходит все проверки подлинности и авторизации политика безопасности Internet Information Services (IIS) и ASP.NET.  
  
 Убедитесь, что у пользователя есть разрешение на просмотр ресурсов, добавляя метод настраиваемой авторизации, который использует <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> метод прежде, чем приложение вызовет <xref:System.Web.HttpServerUtility.Execute%2A> метод.  
  
   
  
## Examples  
 В следующем примере выполняется `Login.aspx` странице на сервере в текущем каталоге и получает выходные данные со страницы через <xref:System.IO.StringWriter> объект `writer`. Он записывает в поток HTML, полученные от `writer` поток вывода НТТР. Содержание <xref:System.Web.HttpRequest.Form%2A> и <xref:System.Web.HttpRequest.QueryString%2A> коллекций сохраняются.  
  
 [!code-csharp[HttpServerUtility.Execute02#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpServerUtility.Execute02/CS/httpserverutility.execute02_cs.aspx#1)]
 [!code-vb[HttpServerUtility.Execute02#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpServerUtility.Execute02/VB/httpserverutility.execute02_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Текущий <see cref="T:System.Web.HttpContext" /> является пустой ссылкой (<see langword="Nothing" /> в Visual Basic).  
  
-или- 
 В конце <paramref name="path" /> стоит точка (.).  
  
-или- 
Произошла ошибка при выполнении действий обработчика, заданного <paramref name="path" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> не является виртуальным путем.</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (System.Web.IHttpHandler handler, System.IO.TextWriter writer, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(class System.Web.IHttpHandler handler, class System.IO.TextWriter writer, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.Web.IHttpHandler,System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (handler As IHttpHandler, writer As TextWriter, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::Web::IHttpHandler ^ handler, System::IO::TextWriter ^ writer, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.Execute : System.Web.IHttpHandler * System.IO.TextWriter * bool -&gt; unit" Usage="httpServerUtility.Execute (handler, writer, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="handler">Обработчик HTTP-данных, который содержит реализацию <see cref="T:System.Web.IHttpHandler" />, куда передается текущий запрос.</param>
        <param name="writer"><see cref="T:System.IO.TextWriter" /> для перенаправления выходных данных.</param>
        <param name="preserveForm">Значение <see langword="true" /> — для сохранения коллекций <see cref="P:System.Web.HttpRequest.QueryString" /> и <see cref="P:System.Web.HttpRequest.Form" />; <see langword="false" /> — для очистки коллекций <see cref="P:System.Web.HttpRequest.QueryString" /> и <see cref="P:System.Web.HttpRequest.Form" />.</param>
        <summary>Выполняет действия обработчика для заданного виртуального пути в контексте текущего запроса. <see cref="T:System.IO.TextWriter" /> перенаправляет выходные данные от выполненного обработчика, а логический параметр указывает, необходимо ли очищать коллекции <see cref="P:System.Web.HttpRequest.QueryString" /> и <see cref="P:System.Web.HttpRequest.Form" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вы можете написать пользовательские обработчики HTTP для обработки заранее определенных типов HTTP-запросов на любом языке, совместимом с общей спецификацией (CLS). Исполняемый код, который определен в классы обработчиков HTTP вместо обычных страницах ASP (также известный как classic ASP) и на страницах ASP.NET отвечает на эти определенные запросы. Обработчики HTTP для взаимодействия с низкого уровня запроса и ответа службы веб-сервера, на котором выполняется Internet Information Services (IIS), и они обеспечивают функциональные возможности, схожие расширения ISAPI, но с более простую модель программирования.  
  
 ASP.NET не проверяет, что текущий пользователь авторизован для просмотра ресурсов, которое доставляется по <xref:System.Web.HttpServerUtility.Execute%2A> метод. Несмотря на то, что логика авторизации и проверки подлинности ASP.NET выполняется перед вызовом исходного обработчик ресурсов, ASP.NET напрямую вызывает обработчик, который обозначается <xref:System.Web.HttpServerUtility.Execute%2A> метода и не выполняется повторно логику проверки подлинности и авторизации для новый ресурс. Если политика безопасности приложения требует у клиентов соответствующие авторизации для получения доступа к ресурсу, приложение следует принудительно выполняет повторную авторизацию или предоставляет механизм пользовательского управления доступом.  
  
 Можно принудительно выполняет повторную авторизацию с помощью <xref:System.Web.HttpResponse.Redirect%2A> вместо метода <xref:System.Web.HttpServerUtility.Execute%2A> метод. <xref:System.Web.HttpResponse.Redirect%2A> Выполняет перенаправление на стороне клиента, в котором браузер запрашивает новый ресурс. Так как это перенаправление является новый запрос, то вход в систему, оно проходит всю логику проверки подлинности и авторизации ASP.NET и IIS политики безопасности.  
  
 Убедитесь, что у пользователя есть разрешение на просмотр ресурсов, добавляя метод настраиваемой авторизации, который использует <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> метод прежде, чем приложение вызовет <xref:System.Web.HttpServerUtility.Execute%2A> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Произошла ошибка при выполнении действий обработчика, заданного <paramref name="handler" />.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="handler" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="GetLastError">
      <MemberSignature Language="C#" Value="public Exception GetLastError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Exception GetLastError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.GetLastError" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLastError () As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception ^ GetLastError();" />
      <MemberSignature Language="F#" Value="member this.GetLastError : unit -&gt; Exception" Usage="httpServerUtility.GetLastError " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает предыдущее исключение.</summary>
        <returns>Предыдущее выданное исключение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере выводится описание последней ошибки приложения в поток вывода НТТР. «Нет ошибки» выводится в том случае, если ошибки не обнаружены.  
  
 [!code-csharp[Classic HttpServerUtility.GetLastError Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.GetLastError Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.GetLastError Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.GetLastError Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpServerUtility.ClearError" />
      </Docs>
    </Member>
    <MemberGroup MemberName="HtmlDecode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Декодирует строку, кодирование которой выполнялось для выделения недопустимых знаков HTML.  
  
Чтобы закодировать или декодировать значения вне веб-приложения, используйте класс <see cref="T:System.Net.WebUtility" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HtmlDecode">
      <MemberSignature Language="C#" Value="public string HtmlDecode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string HtmlDecode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlDecode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function HtmlDecode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ HtmlDecode(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.HtmlDecode : string -&gt; string" Usage="httpServerUtility.HtmlDecode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Декодируемая строка HTML.</param>
        <summary>Декодирует строку в кодировке HTML с последующим возращением.</summary>
        <returns>Расшифрованный текст.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML-кодирования гарантирует, что текст отображается правильно в браузере и не интерпретируется браузером как HTML. Например, если текстовая строка содержит знак «меньше» (\<) или более поздней версии перенаправления (>), браузер интерпретирует эти символы как открывающей или закрывающей скобки тега HTML. Когда все символы в кодировке HTML, они преобразуются в строки `&lt;` и `&gt;`, обеспечивающие для отображения меньше чем "и" больше правильное. <xref:System.Web.HttpServerUtility.HtmlDecode%2A> расшифровывает текст, была передана на сервер.  
  
 Этот метод является удобным способом для доступа к <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> во время выполнения из приложения ASP.NET. На внутреннем уровне этот метод использует <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> для декодирования строки.  
  
 В файле кода для веб-страницу ASP.NET, доступ к экземпляру <xref:System.Web.HttpServerUtility> помощью `Server` свойство. В классе, который не находится в файле кода, используйте `HttpContext.Current.Server` для доступа к экземпляру <xref:System.Web.HttpServerUtility> класса.  
  
 Вне веб-приложения, использовать <xref:System.Net.WebUtility> класс закодировать или декодировать значения.  
  
   
  
## Examples  
 В следующем примере содержится функция `LoadDecodedFile`, которая декодирует данные из файла и копирует их в одну строку.  
  
 [!code-aspx-csharp[Classic HttpServerUtility.HtmlDecode Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode Example/CS/sourcecs.aspx#1)]
 [!code-aspx-vb[Classic HttpServerUtility.HtmlDecode Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode Example/VB/sourcevb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HtmlDecode">
      <MemberSignature Language="C#" Value="public void HtmlDecode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void HtmlDecode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlDecode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub HtmlDecode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void HtmlDecode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="member this.HtmlDecode : string * System.IO.TextWriter -&gt; unit" Usage="httpServerUtility.HtmlDecode (s, output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">Декодируемая строка HTML.</param>
        <param name="output">Поток выходных данных <see cref="T:System.IO.TextWriter" />, содержащий расшифрованную строку.</param>
        <summary>Декодирует строку в кодировке HTML и отправляет конечные выходные данные в поток выходных данных <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML-кодирования гарантирует, что текст отображается правильно в браузере и не интерпретируется браузером как HTML. Например, если текстовая строка содержит знак «меньше» (\<) или более поздней версии перенаправления (>), браузер интерпретирует эти символы как открывающей или закрывающей скобки тега HTML. Когда все символы в кодировке HTML, они преобразуются в строки `&lt;` и `&gt;`, обеспечивающие для отображения меньше чем "и" больше правильное.  
  
 <xref:System.Web.HttpServerUtility.HtmlDecode%2A> расшифровывает текст, была передана на сервер.  
  
 <xref:System.Web.HttpServerUtility.HtmlDecode%2A> — Это удобный способ доступа к <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> во время выполнения из приложения ASP.NET. На внутреннем уровне <xref:System.Web.HttpServerUtility.HtmlDecode%2A> использует <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> для декодирования строки.  
  
 Чтобы закодировать или декодировать значения вне веб-приложения, используйте класс <xref:System.Net.WebUtility>.  
  
   
  
## Examples  
 Следующий пример расшифровывает строку в кодировке HTML для передачи по протоколу HTTP. Он декодирует указанную строку с именем `EncodedString` которого содержит текст «это &lt;тестовая строка&gt;.» и копирует их в строку с именем `DecodedString` как» это \<тестовая строка >.».  
  
 [!code-csharp[Classic HttpServerUtility.HtmlDecode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.HtmlDecode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="HtmlEncode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Кодирует строку, отображаемую в браузере.  
  
Чтобы закодировать или декодировать значения вне веб-приложения, используйте класс <see cref="T:System.Net.WebUtility" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HtmlEncode">
      <MemberSignature Language="C#" Value="public string HtmlEncode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string HtmlEncode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlEncode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function HtmlEncode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ HtmlEncode(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.HtmlEncode : string -&gt; string" Usage="httpServerUtility.HtmlEncode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Кодируемая текстовая строка.</param>
        <summary>Кодирует строку в формате HTML и возвращает закодированную строку.</summary>
        <returns>Текст в формате HTML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML-кодирования гарантирует, что текст отображается правильно в браузере и не интерпретируется браузером как HTML. Например, если текстовая строка содержит знак «меньше» (\<) или более поздней версии перенаправления (>), браузер интерпретирует эти символы как открывающей или закрывающей скобки тега HTML. Когда все символы в кодировке HTML, они преобразуются в строки `&lt;` и `&gt;`, обеспечивающие для отображения меньше чем "и" больше правильное.  
  
 Этот метод является удобным способом для доступа к <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> во время выполнения из приложения ASP.NET. На внутреннем уровне этот метод использует <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> для кодирования строк.  
  
 В файле кода для веб-страницу ASP.NET, доступ к экземпляру <xref:System.Web.HttpServerUtility> помощью `Server` свойство. В классе, который не находится в файле кода, используйте `HttpContext.Current.Server` для доступа к экземпляру <xref:System.Web.HttpServerUtility> класса.  
  
 Вне веб-приложения, использовать <xref:System.Net.WebUtility> класс закодировать или декодировать значения.  
  
   
  
## Examples  
 В следующем примере показано, как для HTML-кодирования значение, потенциально кодов небезопасного кода. Код находится в файл с выделенным кодом для веб-страницы. Значение для кодирования, жестко заданное в этом примере только для упрощения примера и Показать тип значения, что может кодировать в HTML. Как правило как HTML-кодирование значение, полученный от пользователя или запрос. `Result` ссылается на `Literal` элемента управления.  
  
 [!code-csharp[System.Web.HttpServerUtility.HtmlEncode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.HtmlEncode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/vb/default.aspx.vb#1)]  
  
 Следующий пример похож на предыдущий пример, за исключением того, он показывает, как HTML-кодирование значение в пределах класса, не в файле кода.  
  
 [!code-csharp[System.Web.HttpServerUtility.HtmlEncode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.HtmlEncode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HtmlEncode">
      <MemberSignature Language="C#" Value="public void HtmlEncode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void HtmlEncode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlEncode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub HtmlEncode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void HtmlEncode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="member this.HtmlEncode : string * System.IO.TextWriter -&gt; unit" Usage="httpServerUtility.HtmlEncode (s, output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">Кодируемая строка.</param>
        <param name="output">Поток выходных данных <see cref="T:System.IO.TextWriter" />, содержащий зашифрованную строку.</param>
        <summary>Кодирует строку в формате HTML и отправляет результирующие выходные данные в поток вывода <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML-кодировка гарантирует, что текст правильно отображается в браузере, не интерпретируется браузером как HTML. Например, если текстовая строка содержит знак «меньше» (\<) или более поздней версии перенаправления (>), браузер интерпретирует эти символы как открывающую или закрывающую скобку тега HTML. Кодировки HTML для этих знаков `&lt;` и `&gt;`, соответственно, что вызывает отображение меньше чем "и" больше правильное.  
  
 <xref:System.Web.HttpServerUtility.HtmlEncode%2A> — Это удобный способ доступа к <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> во время выполнения из приложения ASP.NET. На внутреннем уровне <xref:System.Web.HttpServerUtility.HtmlEncode%2A> использует <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> для кодирования строк.  
  
 Чтобы закодировать или декодировать значения вне веб-приложения, используйте класс <xref:System.Net.WebUtility>.  
  
   
  
## Examples  
 В следующем примере кодируется в строку для передачи по HTTP. Кодирует строку с именем `TestString`, который содержит текст «это \<тестовая строка >.» и копирует их в строку с именем `EncodedString` как» это &lt;тестовая строка&gt;.».  
  
 [!code-csharp[Classic HttpServerUtility.HtmlEncode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlEncode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.HtmlEncode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlEncode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpServerUtility.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Web.HttpServerUtility.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает имя компьютера сервера.</summary>
        <value>Имя локального компьютера.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере сохраняется имя компьютера сервера как строковую переменную.  
  
 [!code-csharp[Classic HttpServerUtility.MachineName Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.MachineName Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.MachineName Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.MachineName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Не удается найти имя компьютера.</exception>
      </Docs>
    </Member>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.MapPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MapPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.MapPath : string -&gt; string" Usage="httpServerUtility.MapPath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Виртуальный путь в веб-приложении.</param>
        <summary>Возвращает физический путь к файлу, соответствующий указанному виртуальному пути.</summary>
        <returns>Физический путь к файлу на веб-сервере, соответствующий <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `path` — `null`, <xref:System.Web.HttpServerUtility.MapPath%2A> метод возвращает полный физический путь к каталогу, содержащему текущий запрос для пути. Относительный путь не требуется указать существующий файл или папку для этого метода для возврата значения. Тем не менее нельзя указать путь вне веб-приложения.  
  
> [!IMPORTANT]
>  <xref:System.Web.HttpServerUtility.MapPath%2A> Метод потенциально конфиденциальной информацией о среде размещения. Возвращаемое значение не должно отображаться для пользователей.  
  
 Веб-приложения, которая размещается в `C:\ExampleSites\TestMapPath` возвратит следующие результаты:  
  
|Запрашивать у|`path`|возвращаемое значение|  
|------------------|------------|--------------------|  
|RootLevelPage.aspx|`null`|C:\ExampleSites\TestMapPath|  
|RootLevelPage.aspx|"/DownOneLevel/DownLevelPage.aspx"|C:\ExampleSites\TestMapPath\DownOneLevel\DownLevelPage.aspx|  
|RootLevelPage.aspx|"/NotRealFolder"|C:\ExampleSites\TestMapPath\NotRealFolder|  
|RootLevelPage.aspx|".. / OutsideApplication»|<xref:System.Web.HttpException>|  
|/DownOneLevel/DownLevelPage.aspx|`null`|C:\ExampleSites\TestMapPath\DownOneLevel|  
|/DownOneLevel/DownLevelPage.aspx|"../RootLevelPage.aspx"|C:\ExampleSites\TestMapPath\RootLevelPage.aspx|  
  
   
  
## Examples  
 В следующем примере показано, как для получения физического файла относительный виртуальный путь. Код находится в файле кода для веб-страницы и использует значение по умолчанию `Server` объекта.  
  
 [!code-csharp[System.Web.HttpServerUtility.MapPath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.mappath/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.MapPath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.mappath/vb/default.aspx.vb#1)]  
  
 Следующий пример как в предыдущем примере, за исключением того, показано, как получить физический путь из в классе, который не находится в файле кода.  
  
 [!code-csharp[System.Web.HttpServerUtility.MapPath#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.mappath/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.MapPath#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.mappath/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Текущий объект <see cref="T:System.Web.HttpContext" /> имеет значение <see langword="null" />.
        
-или- 
<paramref name="path" /> является физическим путем, а требуется виртуальный путь.</exception>
      </Docs>
    </Member>
    <Member MemberName="ScriptTimeout">
      <MemberSignature Language="C#" Value="public int ScriptTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ScriptTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpServerUtility.ScriptTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ScriptTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ScriptTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ScriptTimeout : int with get, set" Usage="System.Web.HttpServerUtility.ScriptTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение времени ожидания запроса в секундах.</summary>
        <value>Параметры значения времени ожидания для запросов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.ScriptTimeout%2A> Свойство можно задать в файле Web.config, задав `executionTimeout` атрибут [httpRuntime](https://msdn.microsoft.com/library/e9b81350-8aaf-47cc-9843-5f7d0c59f369) элемент. Задание времени ожидания программным образом с помощью <xref:System.Web.HttpServerUtility.ScriptTimeout%2A> свойство имеет приоритет над параметр Web.config.  
  
> [!NOTE]
>  Если задать `debug` атрибут [httpRuntime](https://msdn.microsoft.com/library/e9b81350-8aaf-47cc-9843-5f7d0c59f369) элемент `true` в файле Web.config, а значение <xref:System.Web.HttpServerUtility.ScriptTimeout%2A> будет игнорироваться.  
  
   
  
## Examples  
 Следующий пример устанавливает время ожидания запроса в 60 секунд.  
  
 [!code-csharp[Classic HttpServerUtility.ScriptTimeout Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.ScriptTimeout Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.ScriptTimeout Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.ScriptTimeout Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Текущий объект <see cref="T:System.Web.HttpContext" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Период ожидания равен <see langword="null" />; в противном случае — не может быть задан.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Transfer">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Прекращает выполнение текущей страницы и начинает выполнение новой страницы для текущего запроса.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Transfer">
      <MemberSignature Language="C#" Value="public void Transfer (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transfer(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Transfer(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Transfer (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transfer(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.Transfer : string -&gt; unit" Usage="httpServerUtility.Transfer path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">URL-путь новой выполняемой страницы на сервере.</param>
        <summary>Для текущего запроса прекращает выполнение текущей страницы и начинает выполнение новой страницы с помощью заданного URL-пути к странице.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Переданная страница должен быть другой ASPX-страницы. Например перенаправление на страницу .asp или .asmx является недопустимым. <xref:System.Web.HttpServerUtility.Transfer%2A> Метод сохраняет <xref:System.Web.HttpRequest.QueryString%2A> и <xref:System.Web.HttpRequest.Form%2A> коллекций.  
  
 <xref:System.Web.HttpServerUtility.Transfer%2A> вызовы <xref:System.Web.HttpResponse.End%2A>, какие вызывает <xref:System.Threading.ThreadAbortException> исключение после завершения.  
  
 ASP.NET не проверяет, что текущий пользователь авторизован для просмотра ресурсов, доставленных <xref:System.Web.HttpServerUtility.Transfer%2A> метод. Несмотря на то, что логика авторизации и проверки подлинности ASP.NET выполняется перед вызовом исходного обработчик ресурсов, ASP.NET напрямую вызывает обработчика, указанного по <xref:System.Web.HttpServerUtility.Transfer%2A> метода и не выполняют повторный запуск проверки подлинности и авторизации для нового ресурс. Если политика безопасности приложения требует соответствующей авторизации для доступа к ресурсу, у клиентов, приложения следует принудительно выполняет повторную авторизацию или предоставляет механизм пользовательского управления доступом.  
  
 Можно принудительно выполняет повторную авторизацию с помощью <xref:System.Web.HttpResponse.Redirect%2A> вместо метода <xref:System.Web.HttpServerUtility.Transfer%2A> метод. <xref:System.Web.HttpResponse.Redirect%2A> Метод выполняет перенаправление на стороне клиента, в котором браузер запрашивает новый ресурс. Так как это перенаправление является новый запрос, то вход в систему, оно проходит все проверки подлинности и авторизации политика безопасности Internet Information Services (IIS) и ASP.NET.  
  
 Убедитесь, что у пользователя есть разрешение на просмотр ресурсов, добавляя метод настраиваемой авторизации, который использует <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> метод прежде, чем приложение вызовет <xref:System.Web.HttpServerUtility.Transfer%2A> метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transfer">
      <MemberSignature Language="C#" Value="public void Transfer (string path, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transfer(string path, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Transfer(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Transfer (path As String, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transfer(System::String ^ path, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.Transfer : string * bool -&gt; unit" Usage="httpServerUtility.Transfer (path, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">URL-путь новой выполняемой страницы на сервере.</param>
        <param name="preserveForm">Значение <see langword="true" /> — для сохранения коллекций <see cref="P:System.Web.HttpRequest.QueryString" /> и <see cref="P:System.Web.HttpRequest.Form" />; <see langword="false" /> — для очистки коллекций <see cref="P:System.Web.HttpRequest.QueryString" /> и <see cref="P:System.Web.HttpRequest.Form" />.</param>
        <summary>Прекращает выполнение текущей страницы и начинает выполнение новой страницы с помощью заданного URL-пути к странице. Указывает, необходимо ли очистить коллекции <see cref="P:System.Web.HttpRequest.QueryString" /> и <see cref="P:System.Web.HttpRequest.Form" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Переданная страница должен быть другой ASPX-страницы. Например перенаправление на страницу .asp или .asmx является недопустимым.  
  
 <xref:System.Web.HttpServerUtility.Transfer%2A> вызовы <xref:System.Web.HttpResponse.End%2A>, какие вызывает <xref:System.Threading.ThreadAbortException> исключение после завершения.  
  
 Если задать `preserveForm` параметр `true`, целевой страницы будут иметь возможность обращаться к состоянию представления предыдущей страницы с помощью <xref:System.Web.UI.Page.PreviousPage%2A> свойство.  
  
 В целях безопасности необходимо хранить `enableViewStateMac` атрибут `true`. ASP.NET не проверяет, что текущий пользователь авторизован для просмотра ресурсов, доставленных <xref:System.Web.HttpServerUtility.Transfer%2A> метод. Несмотря на то, что логика авторизации и проверки подлинности ASP.NET выполняется перед вызовом исходного обработчик ресурсов, ASP.NET напрямую вызывает обработчика, указанного по <xref:System.Web.HttpServerUtility.Transfer%2A> метода и не выполняют повторный запуск проверки подлинности и авторизации для нового ресурс. Если политика безопасности приложения требует соответствующей авторизации для доступа к ресурсу, у клиентов, приложения следует принудительно выполняет повторную авторизацию или предоставляет механизм пользовательского управления доступом.  
  
 Можно принудительно выполняет повторную авторизацию с помощью <xref:System.Web.HttpResponse.Redirect%2A> вместо метода <xref:System.Web.HttpServerUtility.Transfer%2A> метод. <xref:System.Web.HttpResponse.Redirect%2A> Метод выполняет перенаправление на стороне клиента, в котором браузер запрашивает новый ресурс. Так как это перенаправление является новый запрос, то вход в систему, оно проходит все проверки подлинности и авторизации политика безопасности Internet Information Services (IIS) и ASP.NET.  
  
 Убедитесь, что у пользователя есть разрешение на просмотр ресурсов, добавляя метод настраиваемой авторизации, который использует <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> метод прежде, чем приложение вызовет <xref:System.Web.HttpServerUtility.Transfer%2A> метод.  
  
   
  
## Examples  
 В следующем примере выполняется новая страница в одном каталоге с текущей страницы.  
  
 [!code-csharp[Classic HttpServerUtility.Transfer Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.Transfer Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.Transfer Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.Transfer Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">Запрос текущей страницы — обратный звонок.</exception>
      </Docs>
    </Member>
    <Member MemberName="Transfer">
      <MemberSignature Language="C#" Value="public void Transfer (System.Web.IHttpHandler handler, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transfer(class System.Web.IHttpHandler handler, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Transfer(System.Web.IHttpHandler,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Transfer (handler As IHttpHandler, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transfer(System::Web::IHttpHandler ^ handler, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.Transfer : System.Web.IHttpHandler * bool -&gt; unit" Usage="httpServerUtility.Transfer (handler, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="handler">Обработчик HTTP-данных, который содержит реализацию <see cref="T:System.Web.IHttpHandler" />, куда передается текущий запрос.</param>
        <param name="preserveForm">Значение <see langword="true" /> — для сохранения коллекций <see cref="P:System.Web.HttpRequest.QueryString" /> и <see cref="P:System.Web.HttpRequest.Form" />; <see langword="false" /> — для очистки коллекций <see cref="P:System.Web.HttpRequest.QueryString" /> и <see cref="P:System.Web.HttpRequest.Form" />.</param>
        <summary>Прекращает выполнение текущей страницы и начинает выполнение новой страницы при помощи пользовательского обработчика HTTP-данных, который содержит реализацию интерфейса <see cref="T:System.Web.IHttpHandler" />, и указывает, необходимо ли очистить коллекции <see cref="P:System.Web.HttpRequest.QueryString" /> и <see cref="P:System.Web.HttpRequest.Form" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вы можете написать пользовательские обработчики HTTP для обработки заранее определенных типов HTTP-запросов на любом языке, совместимом с общей спецификацией (CLS). Исполняемый код, который определен в классы обработчиков HTTP вместо обычных страницах ASP (также известный как classic ASP) и на страницах ASP.NET отвечает на эти определенные запросы. Обработчики HTTP для взаимодействия с низкого уровня запроса и ответа службы веб-сервера, на котором выполняется Internet Information Services (IIS), и они обеспечивают функциональные возможности, схожие расширения ISAPI, но с более простую модель программирования.  
  
 Если задать `preserveForm` параметр `true`, целевой страницы будут иметь возможность обращаться к состоянию представления предыдущей страницы с помощью <xref:System.Web.UI.Page.PreviousPage%2A> свойство.  
  
 В целях безопасности необходимо хранить `enableViewStateMac` атрибут `true`. ASP.NET не проверяет, что текущий пользователь авторизован для просмотра ресурсов, доставленных <xref:System.Web.HttpServerUtility.Transfer%2A> метод. Несмотря на то, что логика авторизации и проверки подлинности ASP.NET выполняется перед вызовом исходного обработчик ресурсов, ASP.NET напрямую вызывает обработчика, указанного по <xref:System.Web.HttpServerUtility.Transfer%2A> метод, а не повторно выполняет логику проверки подлинности и авторизации для нового ресурс. Если политика безопасности приложения требует соответствующей авторизации для доступа к ресурсу, у клиентов, приложения следует принудительно выполняет повторную авторизацию или предоставляет механизм пользовательского управления доступом.  
  
 Можно принудительно выполняет повторную авторизацию с помощью <xref:System.Web.HttpResponse.Redirect%2A> вместо метода <xref:System.Web.HttpServerUtility.Transfer%2A> метод. <xref:System.Web.HttpResponse.Redirect%2A> Метод выполняет перенаправление на стороне клиента, в котором браузер запрашивает новый ресурс. Так как это перенаправление является новый запрос, то вход в систему, оно проходит всю логику проверки подлинности и авторизации ASP.NET и IIS политики безопасности.  
  
 Убедитесь, что у пользователя есть разрешение на просмотр ресурсов, добавляя метод настраиваемой авторизации, который использует <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> метод прежде, чем приложение вызовет <xref:System.Web.HttpServerUtility.Transfer%2A> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">Запрос текущей страницы — обратный звонок.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TransferRequest">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет асинхронное выполнение заданного URL-адреса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.TransferRequest%2A> появился в .NET Framework версии 3.5. Сводные данные о .NET Framework, см. в разделе [версии и зависимости](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.TransferRequest : string -&gt; unit" Usage="httpServerUtility.TransferRequest path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">URL-путь новой выполняемой страницы на сервере.</param>
        <summary>Выполняет асинхронное выполнение заданного URL-адреса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка метода вызывает <xref:System.Web.HttpServerUtility.TransferRequest%2A> перегрузка с `preserveForm` параметру присвоить `false`, `method` параметру присвоить `null`, `headers` параметру присвоить `null`и `preserveUser` значение параметра `true`. Дополнительные сведения см. в разделе «Примечания» в <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29> перегрузки.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Для запроса требуется интегрированный режим конвейера [!INCLUDE[iisver](~/includes/iisver-md.md)].</exception>
        <exception cref="T:System.Web.HttpException">Сервер недоступен для обработки запроса.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="path" /> является недопустимым.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.TransferRequest : string * bool -&gt; unit" Usage="httpServerUtility.TransferRequest (path, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">URL-путь новой выполняемой страницы на сервере.</param>
        <param name="preserveForm">Значение <see langword="true" /> для сохранения коллекции <see cref="P:System.Web.HttpRequest.Form" />; значение <see langword="false" /> для удаления коллекции <see cref="P:System.Web.HttpRequest.Form" />.</param>
        <summary>Выполняет асинхронное выполнение заданного URL-адреса и сохраняет параметры строки запросов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка вызывает <xref:System.Web.HttpServerUtility.TransferRequest%2A> перегрузка с `preserveForm` параметром, имеющим значение, переданное в, `method` параметру присвоить `null`, `headers` параметру присвоить `null`и `preserveUser` набор параметров Чтобы `true`. Дополнительные сведения см. в разделе «Примечания» в <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29>.  
  
 <xref:System.Web.HttpServerUtility.TransferRequest%2A> впервые появился в .NET Framework версии 3.5.  Дополнительные сведения см. в статье [Версии и зависимости платформы .NET Framework](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Для запроса требуется интегрированный режим конвейера [!INCLUDE[iisver](~/includes/iisver-md.md)].</exception>
        <exception cref="T:System.Web.HttpException">Сервер недоступен для обработки запроса.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="path" /> является недопустимым.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path, bool preserveForm, string method, System.Collections.Specialized.NameValueCollection headers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path, bool preserveForm, string method, class System.Collections.Specialized.NameValueCollection headers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String, preserveForm As Boolean, method As String, headers As NameValueCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path, bool preserveForm, System::String ^ method, System::Collections::Specialized::NameValueCollection ^ headers);" />
      <MemberSignature Language="F#" Value="member this.TransferRequest : string * bool * string * System.Collections.Specialized.NameValueCollection -&gt; unit" Usage="httpServerUtility.TransferRequest (path, preserveForm, method, headers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">URL-путь новой выполняемой страницы на сервере.</param>
        <param name="preserveForm">Значение <see langword="true" /> для сохранения коллекции <see cref="P:System.Web.HttpRequest.Form" />; значение <see langword="false" /> для удаления коллекции <see cref="P:System.Web.HttpRequest.Form" />.</param>
        <param name="method">Метод HTTP для использования при выполнении нового запроса.</param>
        <param name="headers">Коллекция <see cref="T:System.Collections.Specialized.NameValueCollection" /> заголовков запросов для нового запроса.</param>
        <summary>Выполняет асинхронное выполнение заданного URL-адреса с использованием указанного метода и заголовков HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется при работе в режиме интегрированного конвейера в [!INCLUDE[iisver](~/includes/iisver-md.md)] разрешающее обработки запроса будет передаваться от одного типа ресурса в другой при выполнении целевого запроса в правильном контексте запроса. Например, можно использовать <xref:System.Web.HttpServerUtility.TransferRequest%2A> способ передачи запроса для страницы ASPX на запрос к XML-странице.  
  
 <xref:System.Web.HttpServerUtility.TransferRequest%2A> Метод выполняет выполнение асинхронного дочернего указанный URL-адрес со следующими условиями:  
  
-   Если `path` параметр указывает строку запроса, он будет использоваться в качестве новой строкой запроса. Если строка запроса отсутствует, будет повторно использоваться строке запроса.  
  
-   Если `method` параметр указан, он будет использоваться. Если это `null`, будет использоваться метод HTTP исходного запроса.  
  
-   Если `preserveForm` параметр `true`, текущий текст сущности запроса будет доступен для целевого запроса. Это позволяет записей форм и передает будут передаваться.  
  
-   Если удостоверение пользователя в исходном запросе, будут передаваться идентификатор нового запроса. Это позволяет повторно использовать результат проверки подлинности для нового запроса запросы проверки подлинности. Если не хотите, чтобы передавать пользователя, задайте ему значение `null` в исходном запросе перед передачей.  
  
-   Если `headers` параметр указан, новый запрос будет выполняться с указанными заголовками. Это можно использовать для изменения заголовков запросов и файлы cookie для нового запроса, или добавьте специальный заголовок, который указывает, где был получен исходный запрос.  
  
     Этот метод вызывает метод <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%2CSystem.Boolean%29> перегрузку метода с `preserveUser` параметру присвоить `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Для запроса требуется [!INCLUDE[iisver](~/includes/iisver-md.md)], работающий в интегрированном режиме.</exception>
        <exception cref="T:System.Web.HttpException">Сервер недоступен для обработки запроса.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="path" /> является недопустимым.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path, bool preserveForm, string method, System.Collections.Specialized.NameValueCollection headers, bool preserveUser);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path, bool preserveForm, string method, class System.Collections.Specialized.NameValueCollection headers, bool preserveUser) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String, preserveForm As Boolean, method As String, headers As NameValueCollection, preserveUser As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path, bool preserveForm, System::String ^ method, System::Collections::Specialized::NameValueCollection ^ headers, bool preserveUser);" />
      <MemberSignature Language="F#" Value="member this.TransferRequest : string * bool * string * System.Collections.Specialized.NameValueCollection * bool -&gt; unit" Usage="httpServerUtility.TransferRequest (path, preserveForm, method, headers, preserveUser)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" Index="3" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveUser" Type="System.Boolean" Index="4" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Путь.</param>
        <param name="preserveForm">Значение <see langword="true" /> для сохранения коллекции <see cref="P:System.Web.HttpRequest.Form" />; значение <see langword="false" /> для удаления коллекции <see cref="P:System.Web.HttpRequest.Form" />.</param>
        <param name="method">Метод HTTP, используемый в новом запросе.</param>
        <param name="headers">Объект <see cref="T:System.Collections.Specialized.NameValueCollection" />, содержащий заголовки запроса для нового запроса.</param>
        <param name="preserveUser">Значение <see langword="true" /> для сохранения удостоверения пользователя; в противном случае — значение <see langword="false" />. Другие перегрузки метода данного метода вызывают эту перегрузку со значением <see langword="true" /> этого параметра.</param>
        <summary>Выполняет асинхронно заданный url-адрес, используя указанный метод HTTP, заголовки и путь, а также, при необходимости, сохраняет значения формы и удостоверение пользователя.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения см. в разделе «Примечания» в <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Для запроса требуется интегрированный режим конвейера [!INCLUDE[iisver](~/includes/iisver-md.md)].</exception>
        <exception cref="T:System.Web.HttpException">Сервер недоступен для обработки запроса.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="path" /> является недопустимым.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="UrlDecode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Расшифровывает строку, кодированную для передачи НТТР-данных и отправки на сервер с кодировкой URL.  
  
Чтобы закодировать или декодировать значения вне веб-приложения, используйте класс <see cref="T:System.Net.WebUtility" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UrlDecode">
      <MemberSignature Language="C#" Value="public string UrlDecode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string UrlDecode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlDecode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function UrlDecode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ UrlDecode(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.UrlDecode : string -&gt; string" Usage="httpServerUtility.UrlDecode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Текстовая строка для декодирования.</param>
        <summary>Расшифровывает строку в кодировке URL с последующим возвращением.</summary>
        <returns>Расшифрованный текст.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Кодировка URL обеспечивает правильную передачу текста в строках URL-адрес во всех браузерах. Символы, как вопросительный знак (?), амперсанд (&), косая черта (/) и пробелы может быть усечен или обозревателем. Таким образом, эти символы должны быть закодированы в `<a>` теги или в строки запросов, которые могут быть повторно отправлены обозревателем в строке запроса.  
  
 Этот метод является удобным способом для доступа к <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> во время выполнения из приложения ASP.NET. На внутреннем уровне этот метод использует <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> для декодирования строки.  
  
 В файле кода для веб-страницу ASP.NET, доступ к экземпляру <xref:System.Web.HttpServerUtility> помощью `Server` свойство. В классе, который не находится в файле кода, используйте `HttpContext.Current.Server` для доступа к экземпляру <xref:System.Web.HttpServerUtility> класса.  
  
 Вне веб-приложения, использовать <xref:System.Net.WebUtility> класс закодировать или декодировать значения.  
  
   
  
## Examples  
 В следующем примере показано как URL-адрес декодировать значение, извлекается из строки запроса. Код находится в файл с выделенным кодом для веб-страницы. `ReturnPage` ссылается на `HyperLink` элемента управления.  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlDecode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.UrlDecode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/vb/default.aspx.vb#1)]  
  
 Следующий пример похож на предыдущий пример, за исключением того, он показывает, как декодировать в URL-значение в пределах класса, не в файле кода.  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlDecode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.UrlDecode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlDecode">
      <MemberSignature Language="C#" Value="public void UrlDecode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UrlDecode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlDecode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UrlDecode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UrlDecode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="member this.UrlDecode : string * System.IO.TextWriter -&gt; unit" Usage="httpServerUtility.UrlDecode (s, output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">Декодируемая строка HTML.</param>
        <param name="output">Поток выходных данных <see cref="T:System.IO.TextWriter" />, содержащий расшифрованную строку.</param>
        <summary>Декодирует строку HTML, полученную с кодировкой URL, и отправляет конечные выходные данные в поток выходных данных <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Кодировка URL обеспечивает правильную передачу текста в строках URL-адрес во всех браузерах. Символы, как вопросительный знак (?), амперсанд (&), косая черта (/) и пробелы может быть усечен или обозревателем. Таким образом, эти символы должны быть закодированы в `<a>` теги или в строки запросов, которые могут быть повторно отправлены обозревателем в строке запроса.  
  
 <xref:System.Web.HttpServerUtility.UrlDecode%2A> — Это удобный способ доступа к <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> во время выполнения из приложения ASP.NET. На внутреннем уровне <xref:System.Web.HttpServerUtility.UrlDecode%2A> использует <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> для декодирования строки.  
  
 Чтобы закодировать или декодировать значения вне веб-приложения, используйте класс <xref:System.Net.WebUtility>.  
  
   
  
## Examples  
 Следующий пример расшифровывает строку с именем `EncodedString` (получено в URL-адрес) в строку с именем `DecodedString`.  
  
 [!code-csharp[Classic HttpServerUtility.UrlDecode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.UrlDecode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.UrlDecode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.UrlDecode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="UrlEncode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Кодирует строку для надежной передачи HTTP-данных в кодировке URL с веб-сервера клиенту.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.UrlEncode%2A> — Это удобный способ доступа к <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> во время выполнения из приложения ASP.NET. На внутреннем уровне <xref:System.Web.HttpServerUtility.UrlEncode%2A> использует <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> для кодирования строк.  
  
 Чтобы закодировать или декодировать значения вне веб-приложения, используйте класс <xref:System.Net.WebUtility>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="UrlEncode">
      <MemberSignature Language="C#" Value="public string UrlEncode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string UrlEncode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlEncode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function UrlEncode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ UrlEncode(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.UrlEncode : string -&gt; string" Usage="httpServerUtility.UrlEncode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Текст для преобразования в кодировку URL.</param>
        <summary>Кодирует строку в кодировке URL и возвращает закодированную строку.</summary>
        <returns>Текст в кодировке URL.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Кодировка URL обеспечивает правильную передачу текста в строках URL-адрес во всех браузерах. Символы, как вопросительный знак (?), амперсанд (&), косая черта (/) и пробелы может быть усечен или обозревателем. Таким образом, эти символы должны быть закодированы в `<a>` теги или в строки запросов, которые могут быть повторно отправлены обозревателем в строке запроса.  
  
 Этот метод является удобным способом для доступа к <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> во время выполнения из приложения ASP.NET. На внутреннем уровне этот метод использует <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> для кодирования строк.  
  
 В файле кода для веб-страницу ASP.NET, доступ к экземпляру <xref:System.Web.HttpServerUtility> помощью `Server` свойство. В классе, который не находится в файле кода, используйте `HttpContext.Current.Server` для доступа к экземпляру <xref:System.Web.HttpServerUtility> класса.  
  
 Вне веб-приложения, использовать <xref:System.Net.WebUtility> класс закодировать или декодировать значения.  
  
   
  
## Examples  
 В следующем примере как для кодирования URL-адрес, значение, используется в качестве значения строки запроса гиперссылки. Код находится в файл с выделенным кодом для веб-страницы. Значение для кодирования, жестко заданное в этом примере только для упрощения примера и Показать тип значения, что можно было бы кодирование URL-адреса. Как правило как кодировать в URL-значение, полученный от пользователя или запрос. `NextPage` ссылается на `HyperLink` элемента управления.  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlEncode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.UrlEncode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/vb/default.aspx.vb#1)]  
  
 Следующий пример похож на предыдущий пример, за исключением того, он показывает, как для кодирования URL-адрес на значение из класса, не в файле кода.  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlEncode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.UrlEncode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlEncode">
      <MemberSignature Language="C#" Value="public void UrlEncode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UrlEncode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlEncode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UrlEncode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UrlEncode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="member this.UrlEncode : string * System.IO.TextWriter -&gt; unit" Usage="httpServerUtility.UrlEncode (s, output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">Кодируемая текстовая строка.</param>
        <param name="output">Поток выходных данных <see cref="T:System.IO.TextWriter" />, содержащий зашифрованную строку.</param>
        <summary>Кодирует в URL строку и отправляет конечные выходные данные в поток выходных данных <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Кодировка URL обеспечивает правильную передачу текста в строках URL-адрес во всех браузерах. Символы, как вопросительный знак (?), амперсанд (&), косая черта (/) и пробелы может быть усечен или обозревателем. Таким образом, эти символы должны быть закодированы в `<a>` теги или в строки запросов, которые могут быть повторно отправлены обозревателем в строке запроса.  
  
 <xref:System.Web.HttpServerUtility.UrlEncode%2A> — Это удобный способ доступа к <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> во время выполнения из приложения ASP.NET. На внутреннем уровне <xref:System.Web.HttpServerUtility.UrlEncode%2A> использует <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> для кодирования строк.  
  
 Чтобы закодировать или декодировать значения вне веб-приложения, используйте класс <xref:System.Net.WebUtility>.  
  
   
  
## Examples  
 В следующем примере кодируется в строку для передачи по HTTP. Кодирует строку с именем `TestString`, который содержит текст «это \<тестовая строка >.» и копирует их в строку с именем `EncodedString` как «этот + является + % 3cTest + строку % 3e.».  
  
 [!code-csharp[Classic HttpServerUtility.UrlEncode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.UrlEncode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.UrlEncode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.UrlEncode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlPathEncode">
      <MemberSignature Language="C#" Value="public string UrlPathEncode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string UrlPathEncode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlPathEncode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function UrlPathEncode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ UrlPathEncode(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.UrlPathEncode : string -&gt; string" Usage="httpServerUtility.UrlPathEncode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Текст для преобразования в кодировку URL.</param>
        <summary>Не использовать; предназначено исключительно для совместимости браузеров. Используйте ключевое слово <see cref="M:System.Web.HttpServerUtility.UrlEncode(System.String)" />.</summary>
        <returns>Текст в кодировке URL.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlTokenDecode">
      <MemberSignature Language="C#" Value="public static byte[] UrlTokenDecode (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] UrlTokenDecode(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlTokenDecode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UrlTokenDecode (input As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ UrlTokenDecode(System::String ^ input);" />
      <MemberSignature Language="F#" Value="static member UrlTokenDecode : string -&gt; byte[]" Usage="System.Web.HttpServerUtility.UrlTokenDecode input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="input">Декодируемая в URL лексема строки.</param>
        <summary>Расшифровывает лексему строки в кодировке URL в эквивалентный массив байтов, используя базовые 64 цифры.</summary>
        <returns>Массив байтов, содержащий декодированную в URL лексему строки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.UrlTokenDecode%2A> Метод преобразует токен строки URL-адрес, который кодирует двоичные данные в кодировке Base64, в массив байтов в эквивалентное представление. Используйте <xref:System.Web.HttpServerUtility.UrlTokenDecode%2A> метод для расшифровки маркеров, отправленных на URL-адрес и зашифрованы с помощью <xref:System.Web.HttpServerUtility.UrlTokenEncode%2A>.  
  
 <xref:System.Web.HttpServerUtility.UrlTokenDecode%2A> Метод возвращает пустой массив байтов, если `input` параметр имеет длину меньше единицы.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">параметр <paramref name="input" /> имеет значение <see langword="null" />;</exception>
        <altmember cref="M:System.Convert.FromBase64CharArray(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Web.HttpServerUtility.UrlTokenEncode(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="UrlTokenEncode">
      <MemberSignature Language="C#" Value="public static string UrlTokenEncode (byte[] input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string UrlTokenEncode(unsigned int8[] input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlTokenEncode(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UrlTokenEncode (input As Byte()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ UrlTokenEncode(cli::array &lt;System::Byte&gt; ^ input);" />
      <MemberSignature Language="F#" Value="static member UrlTokenEncode : byte[] -&gt; string" Usage="System.Web.HttpServerUtility.UrlTokenEncode input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Byte[]" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="input">Кодируемый массив байтов.</param>
        <summary>Кодирует массив байтов в эквивалентное представление строки при помощи 64 знаков, используемых для передачи в кодировке URL.</summary>
        <returns>Строка, которая содержит закодированный токен, если длина *length* массива байтов больше единицы; в противном случае пустая строка ("").</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.UrlTokenEncode%2A> Метод преобразует массив байтов в эквивалентное строковое представление в кодировке в кодировке Base64. В результате лексема строки может быть передана по URL-адрес.  
  
 <xref:System.Web.HttpServerUtility.UrlTokenEncode%2A> Вернет пустую строку, если `input` параметр имеет длину меньше единицы.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">параметр <paramref name="input" /> имеет значение <see langword="null" />;</exception>
        <altmember cref="M:System.Convert.ToBase64String(System.Byte[])" />
        <altmember cref="M:System.Web.HttpServerUtility.UrlTokenDecode(System.String)" />
      </Docs>
    </Member>
  </Members>
</Type>