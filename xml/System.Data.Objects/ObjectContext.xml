<Type Name="ObjectContext" FullName="System.Data.Objects.ObjectContext">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0739e35dfd766a98d9d788dc1ddf7da712d3e3b2" /><Meta Name="ms.sourcegitcommit" Value="0807ab0a64414edc9b4d09d3877857e83cb7f7a4" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="08/13/2019" /><Meta Name="ms.locfileid" Value="68972554" /></Metadata><TypeSignature Language="C#" Value="public class ObjectContext : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ObjectContext extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Data.Objects.ObjectContext" />
  <TypeSignature Language="VB.NET" Value="Public Class ObjectContext&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ObjectContext : IDisposable" />
  <TypeSignature Language="F#" Value="type ObjectContext = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Entity</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Обеспечивает средства обработки запросов и работы с данными сущности как с объектами.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Класс <xref:System.Data.Objects.ObjectContext> не является потокобезопасным. Целостность объектов данных в <xref:System.Data.Objects.ObjectContext> не может быть обеспечена в многопоточных сценариях.  
  
 <xref:System.Data.Objects.ObjectContext> Класс является основным классом для взаимодействия с данными в виде объектов, являющихся экземплярами типов сущностей, которые определены в концептуальной модели. Экземпляр класса <xref:System.Data.Objects.ObjectContext> инкапсулирует следующее:  
  
-   Соединение с базой данных в форме объекта <xref:System.Data.EntityClient.EntityConnection>.  
  
-   Метаданные, описывающие модель, в форме объекта <xref:System.Data.Metadata.Edm.MetadataWorkspace>.  
  
-   Объект <xref:System.Data.Objects.ObjectStateManager>, который управляет объектами, сохраненными в кэше.  
  
 Если уровень объектов, представляющий концептуальную модель, создается EDM инструментами, класс, представляющий объект <xref:System.Data.Metadata.Edm.EntityContainer> для модели, является производным <xref:System.Data.Objects.ObjectContext>от класса.  
  
   
  
## Examples  
 Этот пример основан на [модели AdventureWorks Sales](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). В этом примере показано создание объекта <xref:System.Data.Objects.ObjectContext>.  
  
 [!code-csharp[DP ObjectServices Concepts#ObjectContext](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#objectcontext)]
 [!code-vb[DP ObjectServices Concepts#ObjectContext](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#objectcontext)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/framework/data/adonet/ef/querying-a-conceptual-model.md">Запросы к данным как к объектам (платформа Entity Framework)</related>
    <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Работа с объектами (Entity Framework)</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Data.Objects.ObjectContext" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ObjectContext (System.Data.EntityClient.EntityConnection connection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.EntityClient.EntityConnection connection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.#ctor(System.Data.EntityClient.EntityConnection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connection As EntityConnection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ObjectContext(System::Data::EntityClient::EntityConnection ^ connection);" />
      <MemberSignature Language="F#" Value="new System.Data.Objects.ObjectContext : System.Data.EntityClient.EntityConnection -&gt; System.Data.Objects.ObjectContext" Usage="new System.Data.Objects.ObjectContext connection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connection" Type="System.Data.EntityClient.EntityConnection" />
      </Parameters>
      <Docs>
        <param name="connection">Объект <see cref="T:System.Data.EntityClient.EntityConnection" />, содержащий ссылки на модель и подключение к источнику данных.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Data.Objects.ObjectContext" /> с заданным подключением. Во время построения рабочая область метаданных извлекается из объекта <see cref="T:System.Data.EntityClient.EntityConnection" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="connection" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="connection" /> недопустимо.  
  
- или - 
Недопустимая рабочая область метаданных.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Работа с объектами (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ObjectContext (string connectionString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string connectionString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connectionString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ObjectContext(System::String ^ connectionString);" />
      <MemberSignature Language="F#" Value="new System.Data.Objects.ObjectContext : string -&gt; System.Data.Objects.ObjectContext" Usage="new System.Data.Objects.ObjectContext connectionString" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connectionString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="connectionString">Строка подключения, которая, кроме того, обеспечивает доступ к метаданным.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Data.Objects.ObjectContext" /> с заданной строкой подключения и именем контейнера сущностей по умолчанию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `connectionString` — Это строка, содержащая сведения, необходимые для доступа к концептуальной модели и подключения к источнику данных. Чтобы правильно отформатировать строку, можно использовать класс <xref:System.Data.EntityClient.EntityConnectionStringBuilder>.  
  
 [Средства EDM](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb399249(v%3dvs.100)) создают именованную строку подключения, которая хранится в файле конфигурации приложения. Эта именованная строка подключения может быть указана вместо `connectionString` параметра при создании экземпляра <xref:System.Data.Objects.ObjectContext> класса.  
  
   
  
## Examples  
 Пример в этом разделе основан на [модели AdventureWorks Sales](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). В этом примере показано создание объекта <xref:System.Data.Objects.ObjectContext>.  
  
 [!code-csharp[DP ObjectServices Concepts#ObjectContext](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#objectcontext)]
 [!code-vb[DP ObjectServices Concepts#ObjectContext](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#objectcontext)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="connectionString" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="connectionString" /> недопустимо.  
  
-или- 
Недопустимая рабочая область метаданных.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Работа с объектами (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ObjectContext (System.Data.EntityClient.EntityConnection connection, string defaultContainerName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Data.EntityClient.EntityConnection connection, string defaultContainerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.#ctor(System.Data.EntityClient.EntityConnection,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (connection As EntityConnection, defaultContainerName As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ObjectContext(System::Data::EntityClient::EntityConnection ^ connection, System::String ^ defaultContainerName);" />
      <MemberSignature Language="F#" Value="new System.Data.Objects.ObjectContext : System.Data.EntityClient.EntityConnection * string -&gt; System.Data.Objects.ObjectContext" Usage="new System.Data.Objects.ObjectContext (connection, defaultContainerName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connection" Type="System.Data.EntityClient.EntityConnection" />
        <Parameter Name="defaultContainerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="connection">Объект <see cref="T:System.Data.EntityClient.EntityConnection" />, содержащий ссылки на модель и подключение к источнику данных.</param>
        <param name="defaultContainerName">Имя контейнера сущностей по умолчанию. Если задание <paramref name="defaultContainerName" /> осуществляется посредством данного метода, это свойство становится доступным только для чтения.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Data.Objects.ObjectContext" /> с заданным подключением и именем контейнера сущностей.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="connection" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="connection" /> или <paramref name="defaultContainerName" /> либо рабочая область метаданных недопустимы.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Работа с объектами (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ObjectContext (string connectionString, string defaultContainerName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(string connectionString, string defaultContainerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (connectionString As String, defaultContainerName As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ObjectContext(System::String ^ connectionString, System::String ^ defaultContainerName);" />
      <MemberSignature Language="F#" Value="new System.Data.Objects.ObjectContext : string * string -&gt; System.Data.Objects.ObjectContext" Usage="new System.Data.Objects.ObjectContext (connectionString, defaultContainerName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connectionString" Type="System.String" />
        <Parameter Name="defaultContainerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="connectionString">Строка подключения, которая, кроме того, обеспечивает доступ к метаданным.</param>
        <param name="defaultContainerName">Имя контейнера сущностей по умолчанию. Если задание <paramref name="defaultContainerName" /> осуществляется посредством данного метода, это свойство становится доступным только для чтения.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Data.Objects.ObjectContext" /> с заданной строкой подключения и именем контейнера сущностей.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `connectionString` — Это строка, содержащая сведения, необходимые для доступа к концептуальной модели и подключения к источнику данных. Чтобы правильно отформатировать строку, можно использовать класс <xref:System.Data.EntityClient.EntityConnectionStringBuilder>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="connectionString" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="connectionString" /> или <paramref name="defaultContainerName" /> либо рабочая область метаданных недопустимы.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Работа с объектами (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="AcceptAllChanges">
      <MemberSignature Language="C#" Value="public void AcceptAllChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptAllChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.AcceptAllChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptAllChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptAllChanges();" />
      <MemberSignature Language="F#" Value="member this.AcceptAllChanges : unit -&gt; unit" Usage="objectContext.AcceptAllChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Принимает все изменения, внесенные в объекты в данном контексте объекта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Принимает изменения во всех ассоциированных сущностях в диспетчере <xref:System.Data.Objects.ObjectStateManager> так, что их итоговое состояние является либо неизменным, либо отсоединенным.  
  
 Этот метод выполняет итерацию всех объектов <xref:System.Data.Objects.ObjectStateEntry> в диспетчере <xref:System.Data.Objects.ObjectStateManager>, которые добавлены или изменены, а затем устанавливает неизменное состояние сущности. Удаленные элементы становятся отсоединенными.  
  
 Если метод был вызван <xref:System.Data.Objects.SaveOptions.AcceptAllChangesAfterSave> и не был указан, пользователь должен вызвать <xref:System.Data.Objects.ObjectContext.AcceptAllChanges%2A> метод. <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> Метод <xref:System.Data.Objects.ObjectContext.AcceptAllChanges%2A> полезно использовать, если транзакция завершилась с ошибкой и пользователь хочет сделать повторную попытку.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Работа с объектами (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="AddObject">
      <MemberSignature Language="C#" Value="public void AddObject (string entitySetName, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddObject(string entitySetName, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.AddObject(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddObject (entitySetName As String, entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddObject(System::String ^ entitySetName, System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.AddObject : string * obj -&gt; unit" Usage="objectContext.AddObject (entitySetName, entity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entitySetName">Представляет имя набора сущностей, которое можно уточнить по имени контейнера сущностей.</param>
        <param name="entity">Добавляемый объект <see cref="T:System.Object" />.</param>
        <summary>Добавляет объект в контекст объекта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите метод <xref:System.Data.Objects.ObjectContext.AddObject%2A> для объекта <xref:System.Data.Objects.ObjectContext>, чтобы добавить объект в контекст объекта. Это делается, когда объект является новым объектом, который еще не существует в источнике данных. Дополнительные сведения см. в разделе [Присоединение и отсоединение объектов](https://msdn.microsoft.com/library/41d5c1ef-1b78-4502-aa10-7e1438d62d23).  
  
 Объекты добавляются в диспетчер <xref:System.Data.Objects.ObjectStateManager> в состоянии <xref:System.Data.EntityState.Detached>, <xref:System.Data.EntityState.Deleted> или <xref:System.Data.EntityState.Added>.  
  
 Если создается новый объект, связанный с другим объектом в контексте объекта, добавьте объект с помощью одного из следующих методов.  
  
-   Вызовите метод <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> для коллекции <xref:System.Data.Objects.DataClasses.EntityCollection%601> и укажите связанный объект. Выполните это действие для связей «один ко многим» или «многие ко многим».  
  
-   Задайте свойство <xref:System.Data.Objects.DataClasses.EntityReference%601.Value%2A> объекта <xref:System.Data.Objects.DataClasses.EntityReference%601> для связанного объекта. Выполните это действие для связей «один к одному» или «многие к одному».  
  
 Дополнительные сведения см. в разделе [Создание, добавление, изменение и удаление объектов](https://msdn.microsoft.com/library/f76f1fad-c553-4b59-820b-89b3dec2fad1).  
  
 Если объект находится в отсоединенном состоянии, он не должен иметь <xref:System.Data.EntityKey>.  
  
 Ниже приведены правила для `entitySetName` этого формата.  
  
-   Если свойство имеет `null`значение, то значение `entitySetName` должно быть полным, как в  *\<имени контейнера сущностей >.* <xref:System.Data.Objects.ObjectContext.DefaultContainerName%2A>  *Имя\<набора сущностей >*.  
  
-   Если <xref:System.Data.Objects.ObjectContext.DefaultContainerName%2A> параметрнеравен`entitySetName` , то может быть либо  *\<имя контейнера сущностей, >.* `null` *Имя\<набора сущностей >* или  *\<имя набора сущностей >*.  
  
 <xref:System.Data.Metadata.Edm.EntitySet> Если объект `object` <xref:System.Data.EntityKey> имеет и `entitySetName` имеет значение, тозначение`entitySetName` ключа сущности должно совпадать с именем ,найденнымнаосновеимениконтейнерасущностейи.<xref:System.Data.Metadata.Edm.EntitySet>  
  
   
  
## Examples  
 Этот пример основан на [модели AdventureWorks Sales](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). В примере добавляется новый продукт и сохраняются изменения в базе данных.  
  
 [!code-csharp[DP ObjectServices Concepts#AddObject](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#addobject)]
 [!code-vb[DP ObjectServices Concepts#AddObject](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#addobject)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="entity" /> имеет значение <see langword="null" />.  
  
-или- 
Имя <paramref name="entitySetName" /> не уточнено.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.AddObject(`0)" />
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Работа с объектами (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="ApplyCurrentValues&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public TEntity ApplyCurrentValues&lt;TEntity&gt; (string entitySetName, TEntity currentEntity) where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TEntity ApplyCurrentValues&lt;class TEntity&gt;(string entitySetName, !!TEntity currentEntity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ApplyCurrentValues``1(System.String,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyCurrentValues(Of TEntity As Class) (entitySetName As String, currentEntity As TEntity) As TEntity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; where TEntity : class TEntity ApplyCurrentValues(System::String ^ entitySetName, TEntity currentEntity);" />
      <MemberSignature Language="F#" Value="member this.ApplyCurrentValues : string * 'Entity -&gt; 'Entity (requires 'Entity : null)" Usage="objectContext.ApplyCurrentValues (entitySetName, currentEntity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TEntity</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="currentEntity" Type="TEntity" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">Тип сущности объекта.</typeparam>
        <param name="entitySetName">Имя набора сущностей, к которому принадлежит объект.</param>
        <param name="currentEntity">Отсоединенный объект, к исходному объекту которого нужно применить обновления свойств. Ключ сущности объекта <paramref name="currentEntity" /> должен совпадать со свойством <see cref="P:System.Data.Objects.ObjectStateEntry.EntityKey" /> сущности в контексте <see cref="T:System.Data.Objects.ObjectContext" />.</param>
        <summary>Копирует скалярные значения из указанного объекта в объект в контексте <see cref="T:System.Data.Objects.ObjectContext" />, содержащем тот же ключ.</summary>
        <returns>Обновленный объект.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод используется для применения изменений, внесенных в объекты <xref:System.Data.Objects.ObjectContext>за пределами, например отсоединенные объекты, полученные веб-службой. <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A> Метод копирует скалярные значения из предоставленного объекта в объект в <xref:System.Data.Objects.ObjectContext> , имеющий тот же ключ. Можно использовать <xref:System.Data.EntityKey> Отсоединенный объект для получения экземпляра этого объекта из источника данных. Дополнительные сведения см. в разделе [Практическое руководство. Возвращает конкретный объект, используя его ключ](https://msdn.microsoft.com/library/2e9902af-29b0-4e5d-92db-03dfe6ec49bd). Любые значения, отличные от исходных значений объекта, помечаются как измененные. Обратите внимание, что метод не применяет текущие значения к связанным `currentEntity`объектам.  
  
 Если имеется граф с текущими значениями и необходимо применить исходные значения, вызовите <xref:System.Data.Objects.ObjectContext.ApplyOriginalValues%2A> метод.  
  
 Также <xref:System.Data.Objects.ObjectSet%601.ApplyCurrentValues%2A> можно использовать <xref:System.Data.Objects.ObjectSet%601> метод метода <xref:System.Data.Objects.ObjectStateEntry.ApplyCurrentValues%2A>или. <xref:System.Data.Objects.ObjectStateEntry> Дополнительные сведения см. в разделе [Создание N-уровневых приложений](https://msdn.microsoft.com/library/9439d2ba-6b5f-44e8-be65-8a442d922cbb).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="entitySetName" /> или <paramref name="current" /> — <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Набор сущностей <see cref="T:System.Data.Metadata.Edm.EntitySet" /> из параметра <paramref name="entitySetName" /> не совпадает с набором сущностей <see cref="T:System.Data.Metadata.Edm.EntitySet" /> ключа <see cref="T:System.Data.EntityKey" /> объекта.  
  
-или- 
Объект не находится в состоянии <see cref="T:System.Data.Objects.ObjectStateManager" /> или находится в состоянии <see cref="F:System.Data.EntityState.Detached" />.  
  
-или- 
Ключ сущности предоставленного объекта является недопустимым.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="entitySetName" /> содержит пустую строку.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.ApplyCurrentValues(`0)" />
        <altmember cref="M:System.Data.Objects.ObjectStateEntry.ApplyCurrentValues(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ApplyOriginalValues&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public TEntity ApplyOriginalValues&lt;TEntity&gt; (string entitySetName, TEntity originalEntity) where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TEntity ApplyOriginalValues&lt;class TEntity&gt;(string entitySetName, !!TEntity originalEntity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ApplyOriginalValues``1(System.String,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyOriginalValues(Of TEntity As Class) (entitySetName As String, originalEntity As TEntity) As TEntity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; where TEntity : class TEntity ApplyOriginalValues(System::String ^ entitySetName, TEntity originalEntity);" />
      <MemberSignature Language="F#" Value="member this.ApplyOriginalValues : string * 'Entity -&gt; 'Entity (requires 'Entity : null)" Usage="objectContext.ApplyOriginalValues (entitySetName, originalEntity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TEntity</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="originalEntity" Type="TEntity" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">Тип объекта сущности.</typeparam>
        <param name="entitySetName">Имя набора сущностей, к которому принадлежит объект.</param>
        <param name="originalEntity">Отсоединенный объект, имеющий исходные значения, применяемые к данному объекту. Ключ сущности объекта <paramref name="originalEntity" /> должен совпадать со свойством <see cref="P:System.Data.Objects.ObjectStateEntry.EntityKey" /> сущности в контексте <see cref="T:System.Data.Objects.ObjectContext" />.</param>
        <summary>Копирует скалярные значения из указанного объекта в набор исходных значений для объекта в контексте <see cref="T:System.Data.Objects.ObjectContext" />, содержащем тот же ключ.</summary>
        <returns>Обновленный объект.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод используется для применения изменений, внесенных в объекты <xref:System.Data.Objects.ObjectContext>за пределами, например отсоединенные объекты, полученные веб-службой. <xref:System.Data.Objects.ObjectContext.ApplyOriginalValues%2A> Метод копирует скалярные значения из предоставленного объекта в объект в <xref:System.Data.Objects.ObjectContext> , имеющий тот же ключ. Можно использовать <xref:System.Data.EntityKey> Отсоединенный объект для получения экземпляра этого объекта из источника данных. Дополнительные сведения см. в разделе [Практическое руководство. Возвращает конкретный объект, используя его ключ](https://msdn.microsoft.com/library/2e9902af-29b0-4e5d-92db-03dfe6ec49bd). Любые значения, отличные от текущих значений объекта, помечаются как измененные. Обратите внимание, что метод не применяет текущие значения к связанным `originalEntity`объектам.  
  
 Если имеется граф с исходными значениями и необходимо применить текущие значения, вызовите <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A> метод.  
  
 Также <xref:System.Data.Objects.ObjectSet%601.ApplyOriginalValues%2A> можно использовать <xref:System.Data.Objects.ObjectSet%601> метод метода <xref:System.Data.Objects.ObjectStateEntry.ApplyOriginalValues%2A>или. <xref:System.Data.Objects.ObjectStateEntry> Дополнительные сведения см. в разделе [Создание N-уровневых приложений](https://msdn.microsoft.com/library/9439d2ba-6b5f-44e8-be65-8a442d922cbb).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="entitySetName" /> или <paramref name="original" /> — <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Набор сущностей <see cref="T:System.Data.Metadata.Edm.EntitySet" /> из параметра <paramref name="entitySetName" /> не совпадает с набором сущностей <see cref="T:System.Data.Metadata.Edm.EntitySet" /> ключа <see cref="T:System.Data.EntityKey" /> объекта.  
  
-или- 
Для объекта не удается найти <see cref="T:System.Data.Objects.ObjectStateEntry" /> в <see cref="T:System.Data.Objects.ObjectStateManager" />. - или - 
Объект находится в состоянии <see cref="F:System.Data.EntityState.Added" /> или <see cref="F:System.Data.EntityState.Detached" />.  
  
- или - 
Ключ сущности предоставленного объекта является недопустимым или имеет измененные свойства.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="entitySetName" /> содержит пустую строку.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.ApplyOriginalValues(`0)" />
        <altmember cref="M:System.Data.Objects.ObjectStateEntry.ApplyOriginalValues(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ApplyPropertyChanges">
      <MemberSignature Language="C#" Value="public void ApplyPropertyChanges (string entitySetName, object changed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ApplyPropertyChanges(string entitySetName, object changed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ApplyPropertyChanges(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ApplyPropertyChanges (entitySetName As String, changed As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ApplyPropertyChanges(System::String ^ entitySetName, System::Object ^ changed);" />
      <MemberSignature Language="F#" Value="member this.ApplyPropertyChanges : string * obj -&gt; unit" Usage="objectContext.ApplyPropertyChanges (entitySetName, changed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Use ApplyCurrentValues instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="changed" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entitySetName">Имя набора сущностей, к которому принадлежит объект.</param>
        <param name="changed">Отсоединенный объект, к исходному объекту которого нужно применить обновления свойств.</param>
        <summary>Применяет изменения свойств из отсоединенного объекта к объекту, который уже был присоединен к контексту объекта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A> используется, чтобы применять изменения свойств от измененной, отсоединенной версии объекта к исходной версии, присоединенной к контексту <xref:System.Data.Objects.ObjectContext>. Это обеспечивает поддержку таких сценариев, как веб-службы, в которых объект сущности отсоединяется и отправляется удаленному приложению, где выполняется обновление свойств. Этот метод упрощает применение этих изменений назад к исходному объекту.  
  
 После выполнения метода <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A> объект находится в состоянии <xref:System.Data.EntityState.Modified>. Для обновления источника данных <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> необходимо вызвать метод.  
  
 Исходный объект должен существовать в диспетчере <xref:System.Data.Objects.ObjectStateManager> и должен находиться в состоянии <xref:System.Data.EntityState.Modified> или <xref:System.Data.EntityState.Unchanged>. Исходный объект изменяется только при наличии измененных свойств в `changed` объекте.  
  
 Свойству переданного объекта должно быть присвоено допустимое <xref:System.Data.EntityKey>значение. <xref:System.Data.Objects.DataClasses.EntityObject.EntityKey%2A>  
  
 Метод <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A> не затрагивает свойства навигации или связанные объекты.  
  
 Метод <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A> задает только те свойства, которые существуют в метаданных сущности для этого типа. Например, свойства, которые добавлены в разделяемый класс, не включаются в операцию <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Если <paramref name="entitySetName" /> равно <see langword="null" /> или пустая строка.  
  
-или- 
Если значение параметра <paramref name="changed" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Когда набор сущностей <see cref="T:System.Data.Metadata.Edm.EntitySet" /> из параметра <paramref name="entitySetName" /> не совпадает с набором сущностей <see cref="T:System.Data.Metadata.Edm.EntitySet" /> ключа <see cref="T:System.Data.EntityKey" /> объекта.  
  
-или- 
Сущность находится в состоянии, отличном от <see cref="F:System.Data.EntityState.Modified" /> или <see cref="F:System.Data.EntityState.Unchanged" />.  
  
-или- 
Исходный объект не присоединен к контексту.</exception>
        <exception cref="T:System.ArgumentException">Когда тип объекта <paramref name="changed" /> отличается от типа исходного объекта.</exception>
      </Docs>
    </Member>
    <Member MemberName="Attach">
      <MemberSignature Language="C#" Value="public void Attach (System.Data.Objects.DataClasses.IEntityWithKey entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Attach(class System.Data.Objects.DataClasses.IEntityWithKey entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Attach(System.Data.Objects.DataClasses.IEntityWithKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Attach (entity As IEntityWithKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Attach(System::Data::Objects::DataClasses::IEntityWithKey ^ entity);" />
      <MemberSignature Language="F#" Value="member this.Attach : System.Data.Objects.DataClasses.IEntityWithKey -&gt; unit" Usage="objectContext.Attach entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Data.Objects.DataClasses.IEntityWithKey" />
      </Parameters>
      <Docs>
        <param name="entity">Присоединяемый объект.</param>
        <summary>Присоединяет объект или граф объекта к контексту объекта, если объект имеет ключ сущности.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите метод <xref:System.Data.Objects.ObjectContext.Attach%2A> для объекта <xref:System.Data.Objects.ObjectContext>, чтобы присоединить объект к контексту объекта. Это делается, если объект уже существует в источнике данных, но в данный момент не присоединен к контексту. Дополнительные сведения см. в разделе [Настройка объектов](https://msdn.microsoft.com/library/af6f07ce-2261-4c65-87cf-d018ad082921).  
  
 Метод <xref:System.Data.Objects.ObjectContext.Attach%2A> используется для присоединения объекта или объекта высшего уровня в графе объектов.  
  
 В присоединяемом объекте должен быть реализован интерфейс <xref:System.Data.Objects.DataClasses.IEntityWithKey>, чтобы показать ключ <xref:System.Data.EntityKey>. Все сформированные классы сущности реализуют интерфейс <xref:System.Data.Objects.DataClasses.IEntityWithKey>.  
  
 При присоединении связанных объектов необходимо также вызвать метод `Attach` <xref:System.Data.Objects.DataClasses.EntityReference%601> в или <xref:System.Data.Objects.DataClasses.EntityCollection%601> для определения связи.  
  
 Этот метод вызывает метод <xref:System.Data.Objects.ObjectContext.AttachTo%2A>.  
  
 Во время присоединения объектов следует принимать во внимание следующие соображения.  
  
-   Если у присоединяемого объекта есть связанные объекты, они также будут присоединены к контексту объекта.  
  
-   Объекты добавляются к контексту объекта в неизменном состоянии.  
  
-   Объект, который передается методу <xref:System.Data.Objects.ObjectContext.Attach%2A>, должен иметь допустимое значение <xref:System.Data.Objects.DataClasses.EntityObject.EntityKey%2A>. Если у объекта нет допустимого значения <xref:System.Data.Objects.DataClasses.EntityObject.EntityKey%2A>, используйте для указания имени набора сущностей метод <xref:System.Data.Objects.ObjectContext.AttachTo%2A>.  
  
   
  
## Examples  
 Пример в этом разделе основан на [модели AdventureWorks Sales](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). В этом примере два объекта присоединяются, а затем определяется связь.  
  
 [!code-csharp[DP ObjectServices Concepts#AttachRelatedObjects](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#attachrelatedobjects)]
 [!code-vb[DP ObjectServices Concepts#AttachRelatedObjects](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#attachrelatedobjects)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="entity" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Недопустимый ключ сущности.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.Attach(`0)" />
      </Docs>
    </Member>
    <Member MemberName="AttachTo">
      <MemberSignature Language="C#" Value="public void AttachTo (string entitySetName, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AttachTo(string entitySetName, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.AttachTo(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AttachTo (entitySetName As String, entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AttachTo(System::String ^ entitySetName, System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.AttachTo : string * obj -&gt; unit" Usage="objectContext.AttachTo (entitySetName, entity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entitySetName">Представляет имя набора сущностей, которое можно уточнить по имени контейнера сущностей.</param>
        <param name="entity">Присоединяемый объект <see cref="T:System.Object" />.</param>
        <summary>Присоединяет объект или граф объекта к контексту объекта в конкретном наборе сущностей.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите <xref:System.Data.Objects.ObjectContext.AttachTo%2A> метод <xref:System.Data.Objects.ObjectContext> , чтобы присоединить объект к определенному набору сущностей в контексте объекта или `null` если объект имеет значение`Nothing` (в Visual Basic <xref:System.Data.EntityKey> ). Дополнительные сведения см. в разделе [Присоединение и отсоединение объектов](https://msdn.microsoft.com/library/41d5c1ef-1b78-4502-aa10-7e1438d62d23).  
  
 Присоединяемый объект может быть единичным объектом или частью графа.  
  
 Ниже приведены правила для `entitySetName` этого формата.  
  
-   Если свойство имеет `null`значение, то значение `entitySetName` должно быть полным, как в  *\<имени контейнера сущностей >.* <xref:System.Data.Objects.ObjectContext.DefaultContainerName%2A>  *Имя\<набора сущностей >*.  
  
-   Если значение <xref:System.Data.Objects.ObjectContext.DefaultContainerName%2A> `null`не равно, то `entitySetName` может быть либо  *\<имя контейнера сущностей, >*. *Имя\<набора сущностей >* или  *\<имя набора сущностей >*.  
  
 Присоединяемый объект не обязательно должен иметь ассоциированный с ним ключ <xref:System.Data.EntityKey>. Если у объекта нет ключа сущности, то `entitySetName` не может быть пустой строкой.  
  
 Если присоединяемый объект имеет <xref:System.Data.EntityKey> и `entitySetName` имеет значение, то <xref:System.Data.Metadata.Edm.EntitySet> объект ключа сущности должен `entitySetName` соответствовать <xref:System.Data.Metadata.Edm.EntitySet> найденному в зависимости от имени контейнера сущностей и.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="entity" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Недопустимый набор сущностей.  
  
- или - 
Объект имеет временный ключ.  
  
-или- 
Объект имеет ключ <see cref="T:System.Data.EntityKey" />, а набор <see cref="T:System.Data.Metadata.Edm.EntitySet" /> не соответствует набору сущностей, переданному в качества параметра метода.  
  
- или - 
Объект не имеет ключа <see cref="T:System.Data.EntityKey" />, и не предоставлено ни одного набора сущностей.  
  
-или- 
Объект из графа объектов имеет временный ключ <see cref="T:System.Data.EntityKey" />.  
  
-или- 
Объект из графа объектов имеет недопустимый ключ <see cref="T:System.Data.EntityKey" /> (например, значения в ключе не совпадают со значениями в объекте).  
  
-или- 
Не удалось найти набор сущностей по заданному имени <paramref name="entitySetName" /> и имени контейнера сущностей.  
  
-или- 
Объект из графа объектов уже существует в другом диспетчере состояния.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.Attach(`0)" />
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Работа с объектами (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="CommandTimeout">
      <MemberSignature Language="C#" Value="public Nullable&lt;int&gt; CommandTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;int32&gt; CommandTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.CommandTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property CommandTimeout As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Nullable&lt;int&gt; CommandTimeout { Nullable&lt;int&gt; get(); void set(Nullable&lt;int&gt; value); };" />
      <MemberSignature Language="F#" Value="member this.CommandTimeout : Nullable&lt;int&gt; with get, set" Usage="System.Data.Objects.ObjectContext.CommandTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение времени ожидания (в секундах) для всех операций контекста объекта. Значение <see langword="null" /> указывает, что будет использоваться значение базового поставщика по умолчанию.</summary>
        <value>Значение <see cref="T:System.Int32" />, которое является значением времени ожидания (в секундах).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию время ожидания для запросов объектов и операции <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> определяется основным поставщиком соединений. Но это заданное по умолчанию время ожидания можно переопределить с помощью свойства <xref:System.Data.Objects.ObjectContext.CommandTimeout%2A> объекта <xref:System.Data.Objects.ObjectContext>, как показано в следующем примере.  
  
 [!code-csharp[DP ObjectServices Concepts#QueryTimeout](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#querytimeout)]
 [!code-vb[DP ObjectServices Concepts#QueryTimeout](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#querytimeout)]  
  
 Необходимость в этом возникает, если применяется сложный запрос или если другие проблемы производительности становятся причиной того, что запросы или вызовы <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> часто завершаются в связи с истечением времени ожидания.  
  
   
  
## Examples  
 [Запросы объектов](https://msdn.microsoft.com/library/0768033c-876f-471d-85d5-264884349276)  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение времени ожидания меньше 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbConnection Connection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbConnection Connection" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.Connection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connection As DbConnection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbConnection ^ Connection { System::Data::Common::DbConnection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Connection : System.Data.Common.DbConnection" Usage="System.Data.Objects.ObjectContext.Connection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbConnection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает подключение, используемое контекстом объекта.</summary>
        <value>Объект <see cref="T:System.Data.Common.DbConnection" />, представляющий собой подключение.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство возвращает объект соединения, который был передан в конструктор или создан во время построения. Владение соединением определяется используемыми конструкторами.  
  
   
  
## Examples  
 В этом примере создается объект <xref:System.Data.EntityClient.EntityConnection>, который передается в конструктор долго выполняющегося контекста <xref:System.Data.Objects.ObjectContext>. Соединение открыто вручную. Объект <xref:System.Data.EntityClient.EntityConnection> и класс <xref:System.Data.Objects.ObjectContext> освобождаются вручную.  
  
 [!code-csharp[DP ObjectServices Concepts#OpenEntityConnection](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#openentityconnection)]
 [!code-vb[DP ObjectServices Concepts#OpenEntityConnection](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#openentityconnection)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Когда экземпляр <see cref="T:System.Data.Objects.ObjectContext" /> был удален.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Работа с объектами (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="ContextOptions">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectContextOptions ContextOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Objects.ObjectContextOptions ContextOptions" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.ContextOptions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContextOptions As ObjectContextOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Objects::ObjectContextOptions ^ ContextOptions { System::Data::Objects::ObjectContextOptions ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContextOptions : System.Data.Objects.ObjectContextOptions" Usage="System.Data.Objects.ObjectContext.ContextOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectContextOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает экземпляр <see cref="T:System.Data.Objects.ObjectContextOptions" />, содержащий параметры, которые воздействуют на поведение <see cref="T:System.Data.Objects.ObjectContext" />.</summary>
        <value>Экземпляр <see cref="T:System.Data.Objects.ObjectContextOptions" />, содержащий параметры, которые воздействуют на поведение <see cref="T:System.Data.Objects.ObjectContext" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDatabase">
      <MemberSignature Language="C#" Value="public void CreateDatabase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateDatabase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateDatabase" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateDatabase ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateDatabase();" />
      <MemberSignature Language="F#" Value="member this.CreateDatabase : unit -&gt; unit" Usage="objectContext.CreateDatabase " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает базу данных, используя текущее подключение к источнику данных и метаданные в коллекции <see cref="T:System.Data.Metadata.Edm.StoreItemCollection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите метод <xref:System.Data.Objects.ObjectContext.CreateDatabaseScript%2A> , чтобы просмотреть скрипт языка описания данных (DDL). Вызовите метод <xref:System.Data.Objects.ObjectContext.CreateDatabase%2A> , чтобы выполнить скрипт.  
  
 Большая часть работы делегируется <xref:System.Data.Common.DbProviderServices.CreateDatabase%2A> методу.  
  
 Дополнительные сведения см. в разделе [Работа с языком определения данных](~/docs/framework/data/adonet/ef/working-with-data-definition-language.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabaseScript" />
        <altmember cref="M:System.Data.Objects.ObjectContext.DatabaseExists" />
      </Docs>
    </Member>
    <Member MemberName="CreateDatabaseScript">
      <MemberSignature Language="C#" Value="public string CreateDatabaseScript ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string CreateDatabaseScript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateDatabaseScript" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDatabaseScript () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ CreateDatabaseScript();" />
      <MemberSignature Language="F#" Value="member this.CreateDatabaseScript : unit -&gt; string" Usage="objectContext.CreateDatabaseScript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Формирует DDL-скрипт, создающий объекты схемы (таблицы, первичные ключи, внешние ключи) для метаданных в коллекции <see cref="T:System.Data.Metadata.Edm.StoreItemCollection" />. Класс <see cref="T:System.Data.Metadata.Edm.StoreItemCollection" /> загружает метаданные из SSDL-файлов.</summary>
        <returns>DDL-скрипт, создающий объекты схемы для метаданных в коллекции <see cref="T:System.Data.Metadata.Edm.StoreItemCollection" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите <xref:System.Data.Objects.ObjectContext.CreateDatabaseScript%2A> для просмотра скрипта DDL. Вызовите метод <xref:System.Data.Objects.ObjectContext.CreateDatabase%2A> , чтобы выполнить скрипт.  
  
 Большая часть работы делегируется <xref:System.Data.Common.DbProviderServices.CreateDatabase%2A> методу.  
  
 Дополнительные сведения см. в разделе [Работа с языком определения данных](~/docs/framework/data/adonet/ef/working-with-data-definition-language.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabase" />
        <altmember cref="M:System.Data.Objects.ObjectContext.DatabaseExists" />
      </Docs>
    </Member>
    <Member MemberName="CreateEntityKey">
      <MemberSignature Language="C#" Value="public System.Data.EntityKey CreateEntityKey (string entitySetName, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.EntityKey CreateEntityKey(string entitySetName, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateEntityKey(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateEntityKey (entitySetName As String, entity As Object) As EntityKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::EntityKey ^ CreateEntityKey(System::String ^ entitySetName, System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.CreateEntityKey : string * obj -&gt; System.Data.EntityKey" Usage="objectContext.CreateEntityKey (entitySetName, entity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.EntityKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entitySetName">Полное имя набора сущностей, к которому принадлежит объект сущности.</param>
        <param name="entity">Объект, для которого извлекается ключ сущности.</param>
        <summary>Создает ключ сущности для определенного объекта или возвращает ключ сущности, если тот уже существует.</summary>
        <returns>Ключ <see cref="T:System.Data.EntityKey" /> объекта.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если для объекта `entity`не существует, <xref:System.Data.Objects.ObjectContext.CreateEntityKey%2A> метод создает для него новый ключ. <xref:System.Data.EntityKey>  
  
 Этот метод используется, чтобы определить, присоединен ли уже объект, который имеет такой же ключ <xref:System.Data.EntityKey>, к классу <xref:System.Data.Objects.ObjectContext> или нет. Если объект, который имеет такой же ключ <xref:System.Data.EntityKey>, уже присоединен, вызывается исключение. Используйте метод <xref:System.Data.Objects.ObjectContext.CreateEntityKey%2A>, чтобы пытаться получить ключ <xref:System.Data.EntityKey> отсоединенного объекта перед тем, как вызвать метод <xref:System.Data.Objects.ObjectContext.Attach%2A>.  
  
   
  
## Examples  
 Пример в этом разделе основан на [модели AdventureWorks Sales](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). В этом примере с помощью метода <xref:System.Data.Objects.ObjectContext.CreateEntityKey%2A> получается ключ сущности существующего объекта.  
  
 [!code-csharp[DP ObjectServices Concepts#ApplyItemUpdatesGetObject](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#applyitemupdatesgetobject)]
 [!code-vb[DP ObjectServices Concepts#ApplyItemUpdatesGetObject](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#applyitemupdatesgetobject)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Один из параметров имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Когда <paramref name="entitySetName" /> пусто.  
  
-или- 
Когда тип объекта <paramref name="entity" /> не существует в наборе сущностей.  
  
-или- 
Когда имя <paramref name="entitySetName" /> является неполным.</exception>
        <exception cref="T:System.InvalidOperationException">Ключ сущности невозможно построить на основе предоставленных параметров.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateObject&lt;T&gt;">
      <MemberSignature Language="C#" Value="public T CreateObject&lt;T&gt; () where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!T CreateObject&lt;class T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateObject``1" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObject(Of T As Class) () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class T CreateObject();" />
      <MemberSignature Language="F#" Value="member this.CreateObject : unit -&gt; 'T (requires 'T : null)" Usage="objectContext.CreateObject " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Тип возвращаемого объекта.</typeparam>
        <summary>Создает и возвращает экземпляр запрашиваемого типа.</summary>
        <returns>Экземпляр запрашиваемого типа <paramref name="T" /> или экземпляр производного типа, позволяющий использовать <paramref name="T" /> с Entity Framework. Возвращаемый объект является экземпляром запрашиваемого типа или экземпляром производного типа, который позволяет использовать запрашиваемый тип с Entity Framework.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.CreateObject%2A> Метод используется с пользовательскими классами данных POCO, чтобы убедиться, что возвращаемый объект может правильно управляться Entity Framework. Дополнительные сведения см. в разделе [требования для создания прокси-серверов POCO](https://msdn.microsoft.com/library/dcdbf982-9b9d-4582-806a-64de4a1c03c8) и [работы с сущностями POCO](https://msdn.microsoft.com/library/5e0fb82a-b6d1-41a1-b37b-c12db61629d3).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObjectSet&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectSet&lt;TEntity&gt; CreateObjectSet&lt;TEntity&gt; () where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectSet`1&lt;!!TEntity&gt; CreateObjectSet&lt;class TEntity&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateObjectSet``1" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObjectSet(Of TEntity As Class) () As ObjectSet(Of TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; where TEntity : class System::Data::Objects::ObjectSet&lt;TEntity&gt; ^ CreateObjectSet();" />
      <MemberSignature Language="F#" Value="member this.CreateObjectSet : unit -&gt; System.Data.Objects.ObjectSet&lt;'Entity (requires 'Entity : null)&gt; (requires 'Entity : null)" Usage="objectContext.CreateObjectSet " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectSet&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="TEntity">Тип сущности запрошенного объекта <see cref="T:System.Data.Objects.ObjectSet`1" />.</typeparam>
        <summary>Создает новый экземпляр <see cref="T:System.Data.Objects.ObjectSet`1" />, используемый для запроса, добавления, изменения и удаления объектов указанного типа сущности.</summary>
        <returns>Новый экземпляр <see cref="T:System.Data.Objects.ObjectSet`1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Свойство <see cref="P:System.Data.Objects.ObjectContext.DefaultContainerName" /> не задается в <see cref="T:System.Data.Objects.ObjectContext" />.  
  
-или- 
Заданный тип относится к более чем одному набору сущностей.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateObjectSet&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectSet&lt;TEntity&gt; CreateObjectSet&lt;TEntity&gt; (string entitySetName) where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectSet`1&lt;!!TEntity&gt; CreateObjectSet&lt;class TEntity&gt;(string entitySetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateObjectSet``1(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObjectSet(Of TEntity As Class) (entitySetName As String) As ObjectSet(Of TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; where TEntity : class System::Data::Objects::ObjectSet&lt;TEntity&gt; ^ CreateObjectSet(System::String ^ entitySetName);" />
      <MemberSignature Language="F#" Value="member this.CreateObjectSet : string -&gt; System.Data.Objects.ObjectSet&lt;'Entity (requires 'Entity : null)&gt; (requires 'Entity : null)" Usage="objectContext.CreateObjectSet entitySetName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectSet&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">Тип сущности запрошенного объекта <see cref="T:System.Data.Objects.ObjectSet`1" />.</typeparam>
        <param name="entitySetName">Имя набора сущностей для возвращенного объекта <see cref="T:System.Data.Objects.ObjectSet`1" />. Если свойство <see cref="P:System.Data.Objects.ObjectContext.DefaultContainerName" /> не задано в контексте <see cref="T:System.Data.Objects.ObjectContext" />, строка определяется именем контейнера по умолчанию.</param>
        <summary>Создает новый экземпляр <see cref="T:System.Data.Objects.ObjectSet`1" />, используемый для запроса, добавления, изменения и удаления объектов указанного типа с заданным именем набора сущностей.</summary>
        <returns>Новый экземпляр <see cref="T:System.Data.Objects.ObjectSet`1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Набор сущностей <see cref="T:System.Data.Metadata.Edm.EntitySet" /> из параметра <paramref name="entitySetName" /> не совпадает с набором сущностей <see cref="T:System.Data.Metadata.Edm.EntitySet" /> ключа <see cref="T:System.Data.EntityKey" /> объекта.  
  
- или - 
Свойство <see cref="P:System.Data.Objects.ObjectContext.DefaultContainerName" /> не задается на <see cref="T:System.Data.Objects.ObjectContext" />, а имя не задано как часть параметра <paramref name="entitySetName" />.  
  
-или- 
Заданный тип относится к более чем одному набору сущностей.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateProxyTypes">
      <MemberSignature Language="C#" Value="public void CreateProxyTypes (System.Collections.Generic.IEnumerable&lt;Type&gt; types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateProxyTypes(class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateProxyTypes(System.Collections.Generic.IEnumerable{System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateProxyTypes (types As IEnumerable(Of Type))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateProxyTypes(System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="member this.CreateProxyTypes : seq&lt;Type&gt; -&gt; unit" Usage="objectContext.CreateProxyTypes types" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Collections.Generic.IEnumerable&lt;System.Type&gt;" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="types">Перечисление объектов <see cref="T:System.Type" />, представляющих пользовательские классы данных, которые сопоставляются с концептуальной моделью.</param>
        <summary>Создает эквивалентный тип, который можно использовать с Entity Framework для каждого типа в предоставленном перечислении.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Отдельные типы в `types` перечислении, которые не сопоставляются с типом сущности в концептуальной модели, игнорируются.  
  
 Дополнительные сведения см. в разделе [требования для создания прокси-серверов POCO](https://msdn.microsoft.com/library/dcdbf982-9b9d-4582-806a-64de4a1c03c8) и [работы с сущностями POCO](https://msdn.microsoft.com/library/5e0fb82a-b6d1-41a1-b37b-c12db61629d3).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateQuery&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectQuery&lt;T&gt; CreateQuery&lt;T&gt; (string queryString, params System.Data.Objects.ObjectParameter[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectQuery`1&lt;!!T&gt; CreateQuery&lt;T&gt;(string queryString, class System.Data.Objects.ObjectParameter[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateQuery``1(System.String,System.Data.Objects.ObjectParameter[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateQuery(Of T) (queryString As String, ParamArray parameters As ObjectParameter()) As ObjectQuery(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Data::Objects::ObjectQuery&lt;T&gt; ^ CreateQuery(System::String ^ queryString, ... cli::array &lt;System::Data::Objects::ObjectParameter ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.CreateQuery : string * System.Data.Objects.ObjectParameter[] -&gt; System.Data.Objects.ObjectQuery&lt;'T&gt;" Usage="objectContext.CreateQuery (queryString, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectQuery&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="queryString" Type="System.String" />
        <Parameter Name="parameters" Type="System.Data.Objects.ObjectParameter[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.5">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">Тип сущности возвращенного объекта <see cref="T:System.Data.Objects.ObjectQuery`1" />.</typeparam>
        <param name="queryString">Строка запроса, которую необходимо выполнить.</param>
        <param name="parameters">Параметры для передачи в запрос.</param>
        <summary>Создает объект <see cref="T:System.Data.Objects.ObjectQuery`1" /> в текущем контексте объекта с помощью указанной строки запроса.</summary>
        <returns>Объект <see cref="T:System.Data.Objects.ObjectQuery`1" /> указанного типа.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте класс <xref:System.Data.Objects.ObjectContext.CreateQuery%2A>, чтобы создать объект <xref:System.Data.Objects.ObjectQuery%601> указанного типа, принадлежащий к текущему контексту объекта.  
  
   
  
## Examples  
 Этот пример основан на [модели AdventureWorks Sales](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832).  
  
 В этом примере создается простой запрос и выполняется итерация через коллекцию результатов.  
  
 [!code-csharp[DP ObjectServices Concepts#CreateQuery](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#createquery)]
 [!code-vb[DP ObjectServices Concepts#CreateQuery](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#createquery)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="queryString" /> или <paramref name="parameters" /> — <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/ef/querying-a-conceptual-model.md">Запрос концептуальной модели</related>
      </Docs>
    </Member>
    <Member MemberName="DatabaseExists">
      <MemberSignature Language="C#" Value="public bool DatabaseExists ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DatabaseExists() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.DatabaseExists" />
      <MemberSignature Language="VB.NET" Value="Public Function DatabaseExists () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DatabaseExists();" />
      <MemberSignature Language="F#" Value="member this.DatabaseExists : unit -&gt; bool" Usage="objectContext.DatabaseExists " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Проверяет, существует ли в источнике данных база данных, указанная в качестве базы данных в текущем подключении к источнику данных.</summary>
        <returns>Значение <see langword="true" />, если база данных существует.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Большая часть работы делегируется <xref:System.Data.Common.DbProviderServices.DatabaseExists%2A> методу.  
  
 Дополнительные сведения см. в разделе [Работа с языком определения данных](~/docs/framework/data/adonet/ef/working-with-data-definition-language.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabase" />
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabaseScript" />
      </Docs>
    </Member>
    <Member MemberName="DefaultContainerName">
      <MemberSignature Language="C#" Value="public string DefaultContainerName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DefaultContainerName" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.DefaultContainerName" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultContainerName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DefaultContainerName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultContainerName : string with get, set" Usage="System.Data.Objects.ObjectContext.DefaultContainerName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает имя контейнера по умолчанию.</summary>
        <value>Объект <see cref="T:System.String" />, являющийся именем контейнера по умолчанию.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.DefaultContainerName%2A>никогда не `null`возвращает; либо возвращает значение, которое было задано, либо пустая строка. Пользователь может задать для `null`этого свойства значение, но для внутреннего имени будет задана пустая строка, поэтому пользователю не нужно будет проверять пустую строку и. `null`  
  
 Имя контейнера по умолчанию также определяется как часть конструктора. Если имя контейнера по умолчанию задается через закрытый конструктор, это свойство становится доступным только для чтения.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Работа с объектами (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteDatabase">
      <MemberSignature Language="C#" Value="public void DeleteDatabase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteDatabase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.DeleteDatabase" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteDatabase ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteDatabase();" />
      <MemberSignature Language="F#" Value="member this.DeleteDatabase : unit -&gt; unit" Usage="objectContext.DeleteDatabase " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет базу данных, указанную в качестве базы данных в текущем подключении к источнику данных.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Большая часть работы делегируется <xref:System.Data.Common.DbProviderServices.DeleteDatabase%2A> методу.  
  
 Дополнительные сведения см. в разделе [Работа с языком определения данных](~/docs/framework/data/adonet/ef/working-with-data-definition-language.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabase" />
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabaseScript" />
        <altmember cref="M:System.Data.Objects.ObjectContext.DatabaseExists" />
      </Docs>
    </Member>
    <Member MemberName="DeleteObject">
      <MemberSignature Language="C#" Value="public void DeleteObject (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteObject(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.DeleteObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteObject (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteObject(System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.DeleteObject : obj -&gt; unit" Usage="objectContext.DeleteObject entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Объект, задающий удаляемую сущность. Объект может находиться в любом состоянии, кроме <see cref="F:System.Data.EntityState.Detached" />.</param>
        <summary>Помечает объект для удаления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Помечает объект для удаления из диспетчера <xref:System.Data.Objects.ObjectStateManager>. Объект удаляется в источнике данных при <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> вызове метода.  
  
 Удаление родительского объекта приводит к удалению всех дочерних объектов в связи, к которой применяется ограничение. Результат этого действия такой же, как включение свойства `CascadeDelete` ассоциации для связи.  
  
 <xref:System.Data.Objects.ObjectContext.DeleteObject%2A> Метод может быть вызван для объектов, которые уже удалены.  
  
   
  
## Examples  
 Эти примеры основаны на [модели AdventureWorks Sales](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832).  
  
 В этом примере создается <xref:System.Data.EntityKey> объект с указанным ProductID, используется ключ для получения объекта Product из источника данных, удаляется продукт и сохраняются изменения в базе данных.  
  
 [!code-csharp[DP ObjectServices Concepts#DeleteObject](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#deleteobject)]
 [!code-vb[DP ObjectServices Concepts#DeleteObject](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#deleteobject)]  
  
 В этом примере удаляется существующий элемент Order, добавляется новый элемент и сохраняются изменения в базе данных.  
  
 [!code-csharp[DP ObjectServices Concepts#SaveChanges](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#savechanges)]
 [!code-vb[DP ObjectServices Concepts#SaveChanges](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#savechanges)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="entity" /> — <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="entity" /> не существует.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.DeleteObject(`0)" />
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Работа с объектами (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="Detach">
      <MemberSignature Language="C#" Value="public void Detach (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Detach(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Detach(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Detach (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Detach(System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.Detach : obj -&gt; unit" Usage="objectContext.Detach entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Отсоединяемый объект. Удаляется только <paramref name="entity" />; при наличии связанных объектов, отслеживаемых тем же <see cref="T:System.Data.Objects.ObjectStateManager" />, они не будут автоматически отсоединены.</param>
        <summary>Удаляет объект из контекста объекта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Удаляет объект из диспетчера <xref:System.Data.Objects.ObjectStateManager>. При этом для этого объекта отключается отслеживание изменений и разрешение идентификаторов. Дополнительные сведения см. в разделе [Присоединение и отсоединение объектов](https://msdn.microsoft.com/library/41d5c1ef-1b78-4502-aa10-7e1438d62d23).  
  
 После вызова метода <xref:System.Data.Objects.ObjectContext.Detach%2A> система больше не будет хранить ссылки, указывающие на этот объект и его сможет собрать сборщик мусора.  
  
> [!NOTE]
>  Сборка мусора может произойти только в случае, если в пользовательском коде нет никаких ссылок на отсоединенный объект.  
  
 Во время отсоединения объектов следует принимать во внимание следующие соображения.  
  
-   Метод <xref:System.Data.Objects.ObjectContext.Detach%2A> затрагивает только конкретный объект, который передается этому методу. Если у отсоединяемого объекта в контексте объекта есть связанные объекты, они не отсоединяются.  
  
-   Отсоединение объектов не влияет на данные в источнике данных.  
  
-   Во время операции отсоединения не применяются директивы каскадного удаления и ссылочные ограничения.  
  
 Дополнительные сведения см. в разделе [Присоединение и отсоединение объектов](https://msdn.microsoft.com/library/41d5c1ef-1b78-4502-aa10-7e1438d62d23).  
  
   
  
## Examples  
 [!code-csharp[DP ObjectServices Concepts#DetachObjects](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#detachobjects)]
 [!code-vb[DP ObjectServices Concepts#DetachObjects](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#detachobjects)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="entity" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Сущность <paramref name="entity" /> не ассоциирована с этим контекстом <see cref="T:System.Data.Objects.ObjectContext" /> (например, она вновь создана и еще не ассоциирована с каким-либо контекстом, или была получена через какой-либо другой контекст, или уже была отсоединена).</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.Detach(`0)" />
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Работа с объектами (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="DetectChanges">
      <MemberSignature Language="C#" Value="public void DetectChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DetectChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.DetectChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub DetectChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DetectChanges();" />
      <MemberSignature Language="F#" Value="member this.DetectChanges : unit -&gt; unit" Usage="objectContext.DetectChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Обеспечивает синхронизацию изменений объекта <see cref="T:System.Data.Objects.ObjectStateEntry" /> с изменениями во всех объектах, отслеживаемых посредством объекта <see cref="T:System.Data.Objects.ObjectStateManager" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Освобождает ресурсы, используемые контекстом объекта.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="objectContext.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает ресурсы, используемые контекстом объекта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод закрывает соединение, если оно было открыто Entity Frameworkом. После <xref:System.Data.Objects.ObjectContext.Dispose%2A> вызова операции, для которых требуется открытое соединение, например выполнение запроса или <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> вызов метода, вызовет исключение. Операции, для которых не требуется открытое соединение, такие как составление запроса или присоединение объекта, не вызовут исключения. <xref:System.Data.Objects.ObjectContext.Dispose%2A> Метод не закрывает явно открытые соединения.  
  
 Ограничение области действия <xref:System.Data.Objects.ObjectContext> `using` внутри блока (`Using` в Visual Basic) гарантирует, что ресурсы будут правильно удалены. Дополнительные сведения см. в разделе [Управление соединениями и транзакциями](https://msdn.microsoft.com/library/b6659d2a-9a45-4e98-acaa-d7a8029e5b99).  
  
 Метод вызывает метод(`Overridable`в Visual Basic) <xref:System.Data.Objects.ObjectContext.Dispose%28System.Boolean%29>. `virtual` <xref:System.Data.Objects.ObjectContext.Dispose>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Работа с объектами (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="objectContext.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Значение <see langword="true" /> позволяет освободить управляемые и неуправляемые ресурсы; значение <see langword="false" /> позволяет освободить только неуправляемые ресурсы.</param>
        <summary>Освобождает ресурсы, используемые контекстом объекта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод закрывает соединение. После <xref:System.Data.Objects.ObjectContext.Dispose%2A> вызова операции, для которых требуется открытое соединение, например выполнение запроса или <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> вызов метода, вызовет исключение. Операции, для которых не требуется открытое соединение, такие как составление запроса или присоединение объекта, не вызовут исключения.  
  
 Ограничение области действия <xref:System.Data.Objects.ObjectContext> `using` внутри блока (`Using` в Visual Basic) гарантирует, что ресурсы будут правильно удалены. Дополнительные сведения см. в разделе [Управление соединениями и транзакциями](https://msdn.microsoft.com/library/b6659d2a-9a45-4e98-acaa-d7a8029e5b99).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Работа с объектами (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="ExecuteFunction">
      <MemberSignature Language="C#" Value="public int ExecuteFunction (string functionName, params System.Data.Objects.ObjectParameter[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteFunction(string functionName, class System.Data.Objects.ObjectParameter[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteFunction(System.String,System.Data.Objects.ObjectParameter[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteFunction (functionName As String, ParamArray parameters As ObjectParameter()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteFunction(System::String ^ functionName, ... cli::array &lt;System::Data::Objects::ObjectParameter ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteFunction : string * System.Data.Objects.ObjectParameter[] -&gt; int" Usage="objectContext.ExecuteFunction (functionName, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="parameters" Type="System.Data.Objects.ObjectParameter[]" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="functionName">Имя хранимой процедуры или функции. Имя может содержать имя контейнера, например <c>&lt;Имя контейнера&gt;.&lt;Имя функции&gt;</c>. Если имя контейнера по умолчанию известно, требуется только имя функции.</param>
        <param name="parameters">Массив объектов <see cref="T:System.Data.Objects.ObjectParameter" />.</param>
        <summary>Выполняет хранимую процедуру или функцию, определенную в источнике данных и выраженную в концептуальной модели; отменяет любые результаты, возвращенные функцией; возвращает количество строк, обработанных при выполнении команды.</summary>
        <returns>Число подвергшихся воздействию строк.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="function" /> имеет значение null или пуст 
-или- 
 Параметр <paramref name="function" /> не найден.</exception>
        <exception cref="T:System.InvalidOperationException">Средство чтения сущностей не поддерживает эту функцию <paramref name="function" />.  
  
- или - 
Несоответствие типов между средством чтения и функцией <paramref name="function" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExecuteFunction&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TElement&gt; ExecuteFunction&lt;TElement&gt; (string functionName, params System.Data.Objects.ObjectParameter[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TElement&gt; ExecuteFunction&lt;TElement&gt;(string functionName, class System.Data.Objects.ObjectParameter[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteFunction``1(System.String,System.Data.Objects.ObjectParameter[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteFunction(Of TElement) (functionName As String, ParamArray parameters As ObjectParameter()) As ObjectResult(Of TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TElement&gt;&#xA; System::Data::Objects::ObjectResult&lt;TElement&gt; ^ ExecuteFunction(System::String ^ functionName, ... cli::array &lt;System::Data::Objects::ObjectParameter ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteFunction : string * System.Data.Objects.ObjectParameter[] -&gt; System.Data.Objects.ObjectResult&lt;'Element&gt;" Usage="objectContext.ExecuteFunction (functionName, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" />
        <Parameter Name="parameters" Type="System.Data.Objects.ObjectParameter[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.5">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TElement">Тип сущности объекта <see cref="T:System.Data.Objects.ObjectResult`1" />, возвращаемого при выполнении функции в отношении источника данных. Данный тип должен реализовывать <see cref="T:System.Data.Objects.DataClasses.IEntityWithChangeTracker" />.</typeparam>
        <param name="functionName">Имя хранимой процедуры или функции. Имя может содержать имя контейнера, например <c>&lt;Имя контейнера&gt;.&lt;Имя функции&gt;</c>. Если имя контейнера по умолчанию известно, требуется только имя функции.</param>
        <param name="parameters">Массив объектов <see cref="T:System.Data.Objects.ObjectParameter" />.</param>
        <summary>Выполняет хранимую процедуру или функцию, определенную в источнике данных и сопоставленную в концептуальной модели (с применением указанных параметров). Возвращает типизированный объект <see cref="T:System.Data.Objects.ObjectResult`1" />.</summary>
        <returns>Объект <see cref="T:System.Data.Objects.ObjectResult`1" /> для данных, возвращенных хранимой процедурой.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.ExecuteFunction%2A> Метод — это вспомогательный метод, который используется для выполнения хранимых процедур или функций, определенных в источнике данных и представленных в концептуальной модели. Средства EDM создают метод для каждого [элемента FunctionImport](/ef/ef6/modeling/designer/advanced/edmx/csdl-spec#functionimport-element-csdl) в концептуальной модели. Эти методы вызывают строго типизированный `ExecuteFunction` метод для возврата типизированного. <xref:System.Data.Objects.ObjectResult%601> Дополнительные сведения см. в разделе [код приложения с использованием хранимых процедур (Entity Framework)](https://docs.microsoft.com/previous-versions/cc716795(v=vs.90)).  
  
 Все параметры функции обязательны в массиве Parameters, и все типы проверяются на соответствие метаданным функции Import, включая тип самой функции. `null`значения разрешены для типов значений CLR. Проверка параметров производится поставщиком.  
  
 <xref:System.Data.Objects.ObjectContext.ExecuteFunction%2A> Метод<xref:System.Data.Objects.MergeOption> использует значение .<xref:System.Data.Objects.MergeOption.AppendOnly> Таким образом, если объект уже существует в контексте объекта, он не будет загружен из источника данных.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="function" /> имеет значение null или пуст 
- или - 
 Параметр <paramref name="function" /> не найден.</exception>
        <exception cref="T:System.InvalidOperationException">Средство чтения сущностей не поддерживает эту функцию <paramref name="function" />.  
  
-или- 
Несоответствие типов между средством чтения и функцией <paramref name="function" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Работа с объектами (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="ExecuteFunction&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TElement&gt; ExecuteFunction&lt;TElement&gt; (string functionName, System.Data.Objects.MergeOption mergeOption, params System.Data.Objects.ObjectParameter[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TElement&gt; ExecuteFunction&lt;TElement&gt;(string functionName, valuetype System.Data.Objects.MergeOption mergeOption, class System.Data.Objects.ObjectParameter[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteFunction``1(System.String,System.Data.Objects.MergeOption,System.Data.Objects.ObjectParameter[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TElement&gt;&#xA; System::Data::Objects::ObjectResult&lt;TElement&gt; ^ ExecuteFunction(System::String ^ functionName, System::Data::Objects::MergeOption mergeOption, ... cli::array &lt;System::Data::Objects::ObjectParameter ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteFunction : string * System.Data.Objects.MergeOption * System.Data.Objects.ObjectParameter[] -&gt; System.Data.Objects.ObjectResult&lt;'Element&gt;" Usage="objectContext.ExecuteFunction (functionName, mergeOption, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="parameters" Type="System.Data.Objects.ObjectParameter[]" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TElement">Тип сущности объекта <see cref="T:System.Data.Objects.ObjectResult`1" />, возвращаемого при выполнении функции в отношении источника данных. Данный тип должен реализовывать <see cref="T:System.Data.Objects.DataClasses.IEntityWithChangeTracker" />.</typeparam>
        <param name="functionName">Имя хранимой процедуры или функции. Имя может содержать имя контейнера, например <c>&lt;Имя контейнера&gt;.&lt;Имя функции&gt;</c>. Если имя контейнера по умолчанию известно, требуется только имя функции.</param>
        <param name="mergeOption">Значение из перечисления <see cref="T:System.Data.Objects.MergeOption" />, используемое для выполнения запроса.</param>
        <param name="parameters">Массив объектов <see cref="T:System.Data.Objects.ObjectParameter" />.</param>
        <summary>Выполняет данную хранимую процедуру или функцию, определенную в источнике данных и выраженную в концептуальной модели (с применением указанных параметров и команды слияния). Возвращает типизированный объект <see cref="T:System.Data.Objects.ObjectResult`1" />.</summary>
        <returns>Объект <see cref="T:System.Data.Objects.ObjectResult`1" /> для данных, возвращенных хранимой процедурой.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.ExecuteFunction%2A> Метод — это вспомогательный метод, который используется для выполнения хранимых процедур или функций, определенных в источнике данных и представленных в концептуальной модели. Средства EDM создают метод для каждого [элемента FunctionImport](/ef/ef6/modeling/designer/advanced/edmx/csdl-spec#functionimport-element-csdl) в концептуальной модели. Эти методы вызывают строго типизированный `ExecuteFunction` метод для возврата типизированного. <xref:System.Data.Objects.ObjectResult%601> Дополнительные сведения см. в разделе [код приложения с использованием хранимых процедур (Entity Framework)](https://docs.microsoft.com/previous-versions/cc716795(v=vs.90)).  
  
 Все параметры функции обязательны в массиве Parameters, и все типы проверяются на соответствие метаданным функции Import, включая тип самой функции. `null`значения разрешены для типов значений CLR. Проверка параметров производится поставщиком.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="function" /> имеет значение null или пуст 
-или- 
 Параметр <paramref name="function" /> не найден.</exception>
        <exception cref="T:System.InvalidOperationException">Средство чтения сущностей не поддерживает эту функцию <paramref name="function" />.  
  
-или- 
Несоответствие типов между средством чтения и функцией <paramref name="function" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Работа с объектами (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="ExecuteStoreCommand">
      <MemberSignature Language="C#" Value="public int ExecuteStoreCommand (string commandText, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteStoreCommand(string commandText, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteStoreCommand(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteStoreCommand (commandText As String, ParamArray parameters As Object()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteStoreCommand(System::String ^ commandText, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteStoreCommand : string * obj[] -&gt; int" Usage="objectContext.ExecuteStoreCommand (commandText, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="commandText" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="parameters" Type="System.Object[]" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="commandText">Выполняемая команда на языке источника данных.</param>
        <param name="parameters">Массив параметров для передачи команде.</param>
        <summary>Выполняет произвольную команду непосредственно в отношении источника данных с помощью существующего подключения.</summary>
        <returns>Число подвергшихся воздействию строк.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Использование параметризованных команд помогает защищаться от атак путем внедрения кода SQL, в которых атакующий «внедряет» в инструкцию SQL команду, нарушающую безопасность сервера. Параметризованные команды обеспечивают защиту от атак путем внедрения кода SQL, гарантируя, что значения, полученные из внешнего источника, передаются только как значения, а не как часть инструкции SQL. В результате команды SQL, вставленные в значение, не выполняются в источнике данных. Вместо этого они обрабатываются исключительно как значения параметров. Помимо преимуществ безопасности, параметризованные команды предоставляют удобный способ организации значений, передаваемых с помощью инструкции SQL или хранимой процедуры.  
  
 Значение `parameters` может быть массивом объектов <xref:System.Data.Common.DbParameter> или массивом значений параметров. Если указаны только значения, создается массив <xref:System.Data.Common.DbParameter> объектов на основе порядка значений в массиве.  
  
 Команда Store выполняется в контексте текущей транзакции, если текущая транзакция существует.  
  
 Дополнительные сведения см. в следующих разделах.  
  
 [Непосредственное исполнение команд Store](https://msdn.microsoft.com/library/5708d0a2-3f76-4825-978a-d06ff5c4bb3d) и  
  
 [Практическое руководство. Выполнять команды непосредственно в источнике данных](https://msdn.microsoft.com/library/def3cc87-cfff-4dee-83cf-1a40c73a2d01)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteStoreQuery&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TElement&gt; ExecuteStoreQuery&lt;TElement&gt; (string commandText, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TElement&gt; ExecuteStoreQuery&lt;TElement&gt;(string commandText, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteStoreQuery``1(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteStoreQuery(Of TElement) (commandText As String, ParamArray parameters As Object()) As ObjectResult(Of TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TElement&gt;&#xA; System::Data::Objects::ObjectResult&lt;TElement&gt; ^ ExecuteStoreQuery(System::String ^ commandText, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteStoreQuery : string * obj[] -&gt; System.Data.Objects.ObjectResult&lt;'Element&gt;" Usage="objectContext.ExecuteStoreQuery (commandText, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="commandText" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="parameters" Type="System.Object[]" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TElement">Тип возвращаемых данных.</typeparam>
        <param name="commandText">Выполняемая команда на языке источника данных.</param>
        <param name="parameters">Массив параметров для передачи команде.</param>
        <summary>Выполняет запрос непосредственно в отношении источника данных, возвращающего последовательность типизированных результатов.</summary>
        <returns>Перечисление объектов типа <paramref name="TElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> Метод использует существующее соединение для выполнения произвольной команды непосредственно для источника данных. Команда store выполняется в контексте текущей транзакции, если она существует.  
  
 Вызов метода <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> эквивалентен вызову метода <xref:System.Data.Common.DbCommand.ExecuteReader%2A> класса <xref:System.Data.Common.DbCommand>, с тем отличием, что <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> возвращает сущности, а <xref:System.Data.Common.DbCommand.ExecuteReader%2A> возвращает значения свойств в <xref:System.Data.Common.DbDataReader>.  
  
 Вызовите <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> с указанным именем набора сущностей, если требуется, чтобы результаты были записаны.  
  
 Вызовите <xref:System.Data.Common.DbDataReader> метод, чтобы перевести объект в объект сущности, когда средство чтения содержит строки данных, сопоставленные с указанным типом сущности. <xref:System.Data.Objects.ObjectContext.Translate%2A>  
  
 Использование параметризованных команд помогает защищаться от атак путем внедрения кода SQL, в которых атакующий «внедряет» в инструкцию SQL команду, нарушающую безопасность сервера. Параметризованные команды обеспечивают защиту от атак путем внедрения кода SQL, гарантируя, что значения, полученные из внешнего источника, передаются только как значения, а не как часть инструкции SQL. В результате команды SQL, вставленные в значение, не выполняются в источнике данных. Вместо этого они обрабатываются исключительно как значения параметров. Помимо преимуществ безопасности, параметризованные команды предоставляют удобный способ организации значений, передаваемых с помощью инструкции SQL или хранимой процедуры.  
  
 Значение `parameters` может быть массивом объектов <xref:System.Data.Common.DbParameter> или массивом значений параметров. Если указаны только значения, создается массив <xref:System.Data.Common.DbParameter> объектов на основе порядка значений в массиве.  
  
 Дополнительные сведения см. в следующих разделах.  
  
 [Непосредственное исполнение команд Store](https://msdn.microsoft.com/library/5708d0a2-3f76-4825-978a-d06ff5c4bb3d) и  
  
 [Практическое руководство. Выполнять команды непосредственно в источнике данных](https://msdn.microsoft.com/library/def3cc87-cfff-4dee-83cf-1a40c73a2d01)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteStoreQuery&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TEntity&gt; ExecuteStoreQuery&lt;TEntity&gt; (string commandText, string entitySetName, System.Data.Objects.MergeOption mergeOption, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TEntity&gt; ExecuteStoreQuery&lt;TEntity&gt;(string commandText, string entitySetName, valuetype System.Data.Objects.MergeOption mergeOption, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteStoreQuery``1(System.String,System.String,System.Data.Objects.MergeOption,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; System::Data::Objects::ObjectResult&lt;TEntity&gt; ^ ExecuteStoreQuery(System::String ^ commandText, System::String ^ entitySetName, System::Data::Objects::MergeOption mergeOption, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteStoreQuery : string * string * System.Data.Objects.MergeOption * obj[] -&gt; System.Data.Objects.ObjectResult&lt;'Entity&gt;" Usage="objectContext.ExecuteStoreQuery (commandText, entitySetName, mergeOption, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="commandText" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="entitySetName" Type="System.String" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="parameters" Type="System.Object[]" Index="3" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TEntity">Тип сущности возвращенных данных.</typeparam>
        <param name="commandText">Выполняемая команда на языке источника данных.</param>
        <param name="entitySetName">Набор сущностей типа <typeparamref name="TEntity" />. Без указания имени набора сущностей отслеживания результатов не будет.</param>
        <param name="mergeOption">Значение из перечисления <see cref="T:System.Data.Objects.MergeOption" />, используемое для выполнения запроса. Значение по умолчанию — <see cref="F:System.Data.Objects.MergeOption.AppendOnly" />.</param>
        <param name="parameters">Массив параметров для передачи команде.</param>
        <summary>Выполняет запрос непосредственно в отношении источника данных и возвращает последовательность типизированных результатов. Укажите набор сущностей и параметр слияния, посредством которых результаты запроса можно будет отслеживать в качестве сущностей.</summary>
        <returns>Перечисление объектов типа <paramref name="TResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> Метод использует существующее соединение для выполнения произвольной команды непосредственно для источника данных. Команда store выполняется в контексте текущей транзакции, если она существует.  
  
 Вызов метода <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> эквивалентен вызову метода <xref:System.Data.Common.DbCommand.ExecuteReader%2A> класса <xref:System.Data.Common.DbCommand>, с тем отличием, что <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> возвращает сущности, а <xref:System.Data.Common.DbCommand.ExecuteReader%2A> возвращает значения свойств в <xref:System.Data.Common.DbDataReader>.  
  
 Укажите имя набора сущностей, если необходимо, чтобы результаты были записаны в виде сущностей.  
  
 Вызов <xref:System.Data.Objects.ObjectContext.Translate%2A> метода для <xref:System.Data.Common.DbDataReader> преобразования объекта в объект сущности, если средство чтения содержит строки данных, сопоставленные с указанным типом сущности.  
  
 Использование параметризованных команд помогает защищаться от атак путем внедрения кода SQL, в которых атакующий «внедряет» в инструкцию SQL команду, нарушающую безопасность сервера. Параметризованные команды обеспечивают защиту от атак путем внедрения кода SQL, гарантируя, что значения, полученные из внешнего источника, передаются только как значения, а не как часть инструкции SQL. В результате команды SQL, вставленные в значение, не выполняются в источнике данных. Вместо этого они обрабатываются исключительно как значения параметров. Помимо преимуществ безопасности, параметризованные команды предоставляют удобный способ организации значений, передаваемых с помощью инструкции SQL или хранимой процедуры.  
  
 Значение `parameters` может быть массивом объектов <xref:System.Data.Common.DbParameter> или массивом значений параметров. Если указаны только значения, создается массив <xref:System.Data.Common.DbParameter> объектов на основе порядка значений в массиве.  
  
 Дополнительные сведения см. в следующих разделах.  
  
 [Непосредственное исполнение команд Store](https://msdn.microsoft.com/library/5708d0a2-3f76-4825-978a-d06ff5c4bb3d) и  
  
 [Практическое руководство. Выполнять команды непосредственно в источнике данных](https://msdn.microsoft.com/library/def3cc87-cfff-4dee-83cf-1a40c73a2d01)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetKnownProxyTypes">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;Type&gt; GetKnownProxyTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; GetKnownProxyTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.GetKnownProxyTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetKnownProxyTypes () As IEnumerable(Of Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ GetKnownProxyTypes();" />
      <MemberSignature Language="F#" Value="static member GetKnownProxyTypes : unit -&gt; seq&lt;Type&gt;" Usage="System.Data.Objects.ObjectContext.GetKnownProxyTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает все существующие типы прокси.</summary>
        <returns>Перечисление <see cref="T:System.Collections.Generic.IEnumerable`1" /> всех существующих типов прокси.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.GetKnownProxyTypes%2A> Метод используется при включении создания прокси-объектов для сущностей POCO. Дополнительные сведения см. в разделе [требования для создания прокси-серверов POCO](https://msdn.microsoft.com/library/dcdbf982-9b9d-4582-806a-64de4a1c03c8) и [работы с сущностями POCO](https://msdn.microsoft.com/library/5e0fb82a-b6d1-41a1-b37b-c12db61629d3).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectByKey">
      <MemberSignature Language="C#" Value="public object GetObjectByKey (System.Data.EntityKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetObjectByKey(class System.Data.EntityKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.GetObjectByKey(System.Data.EntityKey)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetObjectByKey (key As EntityKey) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetObjectByKey(System::Data::EntityKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.GetObjectByKey : System.Data.EntityKey -&gt; obj" Usage="objectContext.GetObjectByKey key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Data.EntityKey" />
      </Parameters>
      <Docs>
        <param name="key">Ключ объекта, который нужно найти.</param>
        <summary>Возвращает объект, имеющий указанный ключ сущности.</summary>
        <returns>Объект <see cref="T:System.Object" />, являющийся экземпляром типа сущности.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Data.Objects.ObjectContext.GetObjectByKey%2A> пытается получить объект с указанным ключом <xref:System.Data.EntityKey> из диспетчера <xref:System.Data.Objects.ObjectStateManager>. Если объект в данный момент не загружен в контекст объекта, выполняется запрос при попытке вернуть объект из источника данных. Дополнительные сведения см. в разделе [запросы объектов](https://msdn.microsoft.com/library/0768033c-876f-471d-85d5-264884349276).  
  
 Если объект невозможно найти, метод <xref:System.Data.Objects.ObjectContext.GetObjectByKey%2A> вызывает исключение <xref:System.Data.ObjectNotFoundException>. Чтобы избежать обработки этого исключения, взамен используйте метод <xref:System.Data.Objects.ObjectContext.TryGetObjectByKey%2A>.  
  
 Этот метод будет возвращать объекты в состоянии <xref:System.Data.EntityState.Deleted>.  
  
 Временный ключ нельзя использовать для возврата объекта из источника данных.  
  
   
  
## Examples  
 Этот пример основан на [модели AdventureWorks Sales](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). В этом примере создается ключ <xref:System.Data.EntityKey> для сущности данного типа, а затем сущность выбирается по ключу.  
  
 [!code-csharp[DP ObjectServices Concepts#EntityKeyClass_GetObjectByKey](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#entitykeyclass_getobjectbykey)]
 [!code-vb[DP ObjectServices Concepts#EntityKeyClass_GetObjectByKey](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#entitykeyclass_getobjectbykey)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="key" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Data.ObjectNotFoundException">Объект не найден ни в объекте <see cref="T:System.Data.Objects.ObjectStateManager" />, ни в источнике данных.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/ef/querying-a-conceptual-model.md">Запросы к данным как к объектам (платформа Entity Framework)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Работа с объектами (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="GetObjectType">
      <MemberSignature Language="C#" Value="public static Type GetObjectType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetObjectType(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.GetObjectType(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetObjectType(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetObjectType : Type -&gt; Type" Usage="System.Data.Objects.ObjectContext.GetObjectType type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="type">Объект <see cref="T:System.Type" /> прокси-объекта.</param>
        <summary>Возвращает тип сущности POCO, связанной с прокси-объектом заданного типа.</summary>
        <returns>Тип <see cref="T:System.Type" /> связанной сущности POCO.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.GetObjectType%2A> Метод используется при включении создания прокси-объектов для сущностей POCO. Дополнительные сведения см. в разделе [требования для создания прокси-серверов POCO](https://msdn.microsoft.com/library/dcdbf982-9b9d-4582-806a-64de4a1c03c8) и [работы с сущностями POCO](https://msdn.microsoft.com/library/5e0fb82a-b6d1-41a1-b37b-c12db61629d3).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadProperty">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Явным образом загружает связанный объект при использовании пользовательских классов данных POCO.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании пользовательских классов данных POCO связанные объекты не могут быть явно загружены как экземпляры типов сущностей, созданные инструментами EDM. Это <xref:System.Data.Objects.DataClasses.EntityCollection%601> обусловлено тем, что средства создают свойства навигации, возвращающие или <xref:System.Data.Objects.DataClasses.EntityReference%601> связанные объекты <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> , <xref:System.Data.Objects.DataClasses.RelatedEnd>когда вызывается для. Сущности POCO по-прежнему можно загружать с помощью отложенной загрузки, <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> присвоив `true` свойству значение в <xref:System.Data.Objects.ObjectContextOptions> экземпляре, возвращаемом <xref:System.Data.Objects.ObjectContext.ContextOptions%2A?displayProperty=nameWithType> свойством, или с помощью безотлагательной загрузки <xref:System.Data.Objects.ObjectQuery%601.Include%2A> метода в <xref:System.Data.Objects.ObjectQuery%601>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadProperty">
      <MemberSignature Language="C#" Value="public void LoadProperty (object entity, string navigationProperty);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadProperty(object entity, string navigationProperty) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.LoadProperty(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadProperty (entity As Object, navigationProperty As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadProperty(System::Object ^ entity, System::String ^ navigationProperty);" />
      <MemberSignature Language="F#" Value="member this.LoadProperty : obj * string -&gt; unit" Usage="objectContext.LoadProperty (entity, navigationProperty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="navigationProperty" Type="System.String" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="entity">Сущность, для которой необходимо загрузить связанные объекты.</param>
        <param name="navigationProperty">Имя свойства навигации, возвращающего связанные объекты для загрузки.</param>
        <summary>Явным образом загружает объект, связанный с предоставленным объектом, посредством заданного свойства навигации и параметра слияния по умолчанию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> Метод должен вызываться для обеспечения явной загрузки при использовании пользовательских классов данных POCO.  
  
 После вызова <xref:System.Data.Objects.ObjectContext.LoadProperty%2A>доступ к связанному объекту можно получить через свойства навигации исходной сущности.  
  
 При использовании пользовательских классов данных POCO связанные объекты не могут быть явно загружены как экземпляры типов сущностей, созданные инструментами EDM. Это <xref:System.Data.Objects.DataClasses.EntityCollection%601> обусловлено тем, что средства создают свойства навигации, возвращающие или <xref:System.Data.Objects.DataClasses.EntityReference%601> связанные объекты <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> , <xref:System.Data.Objects.DataClasses.RelatedEnd>когда вызывается для. Сущности POCO по-прежнему можно загружать с помощью отложенной загрузки, <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> присвоив `true` свойству значение в <xref:System.Data.Objects.ObjectContextOptions> экземпляре, возвращаемом <xref:System.Data.Objects.ObjectContext.ContextOptions%2A?displayProperty=nameWithType> свойством, или с помощью безотлагательной загрузки <xref:System.Data.Objects.ObjectQuery%601.Include%2A> метода в <xref:System.Data.Objects.ObjectQuery%601>.  
  
 При вызове <xref:System.Data.Objects.ObjectContext> <xref:System.Data.Objects.MergeOption> <xref:System.Data.Objects.MergeOption.AppendOnly>метода объекты загружаются в объект с помощью значения по умолчанию. <xref:System.Data.Objects.ObjectContext.LoadProperty%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Параметр <paramref name="entity" /> в состоянии <see cref="F:System.Data.EntityState.Detached" />, <see cref="F:System.Data.EntityState.Added" /> или <see cref="F:System.Data.EntityState.Deleted" />. 
-или- 
Если <paramref name="entity" /> присоединен к другому экземпляру <see cref="T:System.Data.Objects.ObjectContext" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadProperty">
      <MemberSignature Language="C#" Value="public void LoadProperty (object entity, string navigationProperty, System.Data.Objects.MergeOption mergeOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadProperty(object entity, string navigationProperty, valuetype System.Data.Objects.MergeOption mergeOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.LoadProperty(System.Object,System.String,System.Data.Objects.MergeOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadProperty(System::Object ^ entity, System::String ^ navigationProperty, System::Data::Objects::MergeOption mergeOption);" />
      <MemberSignature Language="F#" Value="member this.LoadProperty : obj * string * System.Data.Objects.MergeOption -&gt; unit" Usage="objectContext.LoadProperty (entity, navigationProperty, mergeOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="navigationProperty" Type="System.String" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="entity">Сущность, для которой необходимо загрузить связанные объекты.</param>
        <param name="navigationProperty">Имя свойства навигации, возвращающего связанные объекты для загрузки.</param>
        <param name="mergeOption">Значение <see cref="T:System.Data.Objects.MergeOption" />, используемое при загрузке связанных объектов.</param>
        <summary>Явным образом загружает объект, связанный с предоставленным объектом, посредством заданного свойства навигации и указанного параметра слияния.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> Метод должен вызываться для обеспечения явной загрузки при использовании пользовательских классов данных POCO.  
  
 После вызова <xref:System.Data.Objects.ObjectContext.LoadProperty%2A>доступ к связанному объекту можно получить через свойства навигации исходной сущности.  
  
 При использовании пользовательских классов данных POCO связанные объекты не могут быть явно загружены как экземпляры типов сущностей, созданные инструментами EDM. Это <xref:System.Data.Objects.DataClasses.EntityCollection%601> обусловлено тем, что средства создают свойства навигации, возвращающие или <xref:System.Data.Objects.DataClasses.EntityReference%601> связанные объекты <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> , <xref:System.Data.Objects.DataClasses.RelatedEnd>когда вызывается для. Сущности POCO по-прежнему можно загружать с помощью отложенной загрузки, <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> присвоив `true` свойству значение в <xref:System.Data.Objects.ObjectContextOptions> экземпляре, возвращаемом <xref:System.Data.Objects.ObjectContext.ContextOptions%2A?displayProperty=nameWithType> свойством, или с помощью безотлагательной загрузки <xref:System.Data.Objects.ObjectQuery%601.Include%2A> метода в <xref:System.Data.Objects.ObjectQuery%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Параметр <paramref name="entity" /> в состоянии <see cref="F:System.Data.EntityState.Detached" />, <see cref="F:System.Data.EntityState.Added" /> или <see cref="F:System.Data.EntityState.Deleted" />. 
-или- 
Если <paramref name="entity" /> присоединен к другому экземпляру <see cref="T:System.Data.Objects.ObjectContext" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadProperty&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public void LoadProperty&lt;TEntity&gt; (TEntity entity, System.Linq.Expressions.Expression&lt;Func&lt;TEntity,object&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadProperty&lt;TEntity&gt;(!!TEntity entity, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TEntity, object&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.LoadProperty``1(``0,System.Linq.Expressions.Expression{System.Func{``0,System.Object}})" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadProperty(Of TEntity) (entity As TEntity, selector As Expression(Of Func(Of TEntity, Object)))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; void LoadProperty(TEntity entity, System::Linq::Expressions::Expression&lt;Func&lt;TEntity, System::Object ^&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="member this.LoadProperty : 'Entity * System.Linq.Expressions.Expression&lt;Func&lt;'Entity, obj&gt;&gt; -&gt; unit" Usage="objectContext.LoadProperty (entity, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TEntity,System.Object&gt;&gt;" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">Тип предоставленного объекта.</typeparam>
        <param name="entity">Исходный объект, для которого необходимо загрузить связанные объекты.</param>
        <param name="selector">Выражение LINQ, определяющее связанные объекты для загрузки.</param>
        <summary>Явным образом загружает объект, связанный с предоставленным объектом, посредством заданного запроса LINQ и параметра слияния по умолчанию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> Метод должен вызываться для обеспечения явной загрузки при использовании пользовательских классов данных POCO.  
  
 После вызова <xref:System.Data.Objects.ObjectContext.LoadProperty%2A>доступ к связанному объекту можно получить через свойства навигации исходной сущности.  
  
 Свойство для загрузки задается выражением LINQ, которое должно быть в виде простого доступа к члену свойства, как в `(entity) => entity.PropertyName`, где *PropertyName* — это свойство навигации, возвращающее связанные объекты для загрузки. Если используются другие формы выражения LINQ, возникает исключение.  
  
 При использовании пользовательских классов данных POCO связанные объекты не могут быть явно загружены как экземпляры типов сущностей, созданные инструментами EDM. Это <xref:System.Data.Objects.DataClasses.EntityCollection%601> обусловлено тем, что средства создают свойства навигации, возвращающие или <xref:System.Data.Objects.DataClasses.EntityReference%601> связанные объекты <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> , <xref:System.Data.Objects.DataClasses.RelatedEnd>когда вызывается для. Сущности POCO по-прежнему можно загружать с помощью отложенной загрузки, <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> присвоив `true` свойству значение в <xref:System.Data.Objects.ObjectContextOptions> экземпляре, возвращаемом <xref:System.Data.Objects.ObjectContext.ContextOptions%2A?displayProperty=nameWithType> свойством, или с помощью безотлагательной загрузки <xref:System.Data.Objects.ObjectQuery%601.Include%2A> метода в <xref:System.Data.Objects.ObjectQuery%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="selector" /> не поддерживает допустимый входной параметр.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="selector" /> равно null.</exception>
        <exception cref="T:System.InvalidOperationException">Параметр <paramref name="entity" /> в состоянии <see cref="F:System.Data.EntityState.Detached" />, <see cref="F:System.Data.EntityState.Added" /> или <see cref="F:System.Data.EntityState.Deleted" />. 
- или - 
Если <paramref name="entity" /> присоединен к другому экземпляру <see cref="T:System.Data.Objects.ObjectContext" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadProperty&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public void LoadProperty&lt;TEntity&gt; (TEntity entity, System.Linq.Expressions.Expression&lt;Func&lt;TEntity,object&gt;&gt; selector, System.Data.Objects.MergeOption mergeOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadProperty&lt;TEntity&gt;(!!TEntity entity, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TEntity, object&gt;&gt; selector, valuetype System.Data.Objects.MergeOption mergeOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.LoadProperty``1(``0,System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.Data.Objects.MergeOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; void LoadProperty(TEntity entity, System::Linq::Expressions::Expression&lt;Func&lt;TEntity, System::Object ^&gt; ^&gt; ^ selector, System::Data::Objects::MergeOption mergeOption);" />
      <MemberSignature Language="F#" Value="member this.LoadProperty : 'Entity * System.Linq.Expressions.Expression&lt;Func&lt;'Entity, obj&gt;&gt; * System.Data.Objects.MergeOption -&gt; unit" Usage="objectContext.LoadProperty (entity, selector, mergeOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TEntity,System.Object&gt;&gt;" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">Тип предоставленного объекта.</typeparam>
        <param name="entity">Исходный объект, для которого необходимо загрузить связанные объекты.</param>
        <param name="selector">Выражение LINQ, определяющее связанные объекты для загрузки.</param>
        <param name="mergeOption">Значение <see cref="T:System.Data.Objects.MergeOption" />, используемое при загрузке связанных объектов.</param>
        <summary>Явным образом загружает объект, связанный с предоставленным объектом, посредством заданного запроса LINQ и указанного параметра слияния.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> Метод должен вызываться для обеспечения явной загрузки при использовании пользовательских классов данных POCO.  
  
 После вызова <xref:System.Data.Objects.ObjectContext.LoadProperty%2A>доступ к связанному объекту можно получить через свойства навигации исходной сущности.  
  
 Свойство для загрузки задается выражением LINQ, которое должно быть в виде простого доступа к члену свойства, как в `(entity) => entity.PropertyName` случае, когда *PropertyName* — это свойство навигации, возвращающее связанные объекты для загрузки. Если используются другие формы выражения LINQ, возникает исключение.  
  
 При использовании пользовательских классов данных POCO связанные объекты не могут быть явно загружены как экземпляры типов сущностей, созданные инструментами EDM. Это <xref:System.Data.Objects.DataClasses.EntityCollection%601> обусловлено тем, что средства создают свойства навигации, возвращающие или <xref:System.Data.Objects.DataClasses.EntityReference%601> связанные объекты <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> , <xref:System.Data.Objects.DataClasses.RelatedEnd>когда вызывается для. Сущности POCO по-прежнему можно загружать с помощью отложенной загрузки, <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> присвоив `true` свойству значение в <xref:System.Data.Objects.ObjectContextOptions> экземпляре, возвращаемом <xref:System.Data.Objects.ObjectContext.ContextOptions%2A?displayProperty=nameWithType> свойством, или с помощью безотлагательной загрузки <xref:System.Data.Objects.ObjectQuery%601.Include%2A> метода в <xref:System.Data.Objects.ObjectQuery%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="selector" /> не поддерживает допустимый входной параметр.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="selector" /> равно null.</exception>
        <exception cref="T:System.InvalidOperationException">Параметр <paramref name="entity" /> в состоянии <see cref="F:System.Data.EntityState.Detached" />, <see cref="F:System.Data.EntityState.Added" /> или <see cref="F:System.Data.EntityState.Deleted" />. 
-или- 
Если <paramref name="entity" /> присоединен к другому экземпляру <see cref="T:System.Data.Objects.ObjectContext" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MetadataWorkspace">
      <MemberSignature Language="C#" Value="public System.Data.Metadata.Edm.MetadataWorkspace MetadataWorkspace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Metadata.Edm.MetadataWorkspace MetadataWorkspace" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.MetadataWorkspace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MetadataWorkspace As MetadataWorkspace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Metadata::Edm::MetadataWorkspace ^ MetadataWorkspace { System::Data::Metadata::Edm::MetadataWorkspace ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MetadataWorkspace : System.Data.Metadata.Edm.MetadataWorkspace" Usage="System.Data.Objects.ObjectContext.MetadataWorkspace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Metadata.Edm.MetadataWorkspace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает рабочую область метаданных, используемую контекстом объекта.</summary>
        <value>Объект <see cref="T:System.Data.Metadata.Edm.MetadataWorkspace" />, связанный с этим объектом <see cref="T:System.Data.Objects.ObjectContext" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Класс <xref:System.Data.Metadata.Edm.MetadataWorkspace> является центральным API времени выполнения, который можно использовать, чтобы взаимодействовать с метаданными модели EDM в контексте приложения. 
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Работа с объектами (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="ObjectMaterialized">
      <MemberSignature Language="C#" Value="public event System.Data.Objects.ObjectMaterializedEventHandler ObjectMaterialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.Objects.ObjectMaterializedEventHandler ObjectMaterialized" />
      <MemberSignature Language="DocId" Value="E:System.Data.Objects.ObjectContext.ObjectMaterialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ObjectMaterialized As ObjectMaterializedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::Objects::ObjectMaterializedEventHandler ^ ObjectMaterialized;" />
      <MemberSignature Language="F#" Value="member this.ObjectMaterialized : System.Data.Objects.ObjectMaterializedEventHandler " Usage="member this.ObjectMaterialized : System.Data.Objects.ObjectMaterializedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectMaterializedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возникает при создании нового объекта сущности на основании данных в источнике данных в составе операции загрузки или запроса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие возникает после установки всех скалярных, сложных и ссылочных свойств объекта, но до загрузки коллекций. Если в контексте объекта существует объект с таким же значением ключа, Entity Framework не будет повторно создавать объект, и это событие не будет вызвано.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ObjectStateManager">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectStateManager ObjectStateManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Objects.ObjectStateManager ObjectStateManager" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.ObjectStateManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ObjectStateManager As ObjectStateManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Objects::ObjectStateManager ^ ObjectStateManager { System::Data::Objects::ObjectStateManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ObjectStateManager : System.Data.Objects.ObjectStateManager" Usage="System.Data.Objects.ObjectContext.ObjectStateManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectStateManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает диспетчер состояния объекта, используемый контекстом объекта для отслеживания изменений объекта.</summary>
        <value>Хранилище <see cref="T:System.Data.Objects.ObjectStateManager" />, используемое данной службой <see cref="T:System.Data.Objects.ObjectContext" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Эти примеры основаны на [модели AdventureWorks Sales](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). В этом примере диспетчер состояния <xref:System.Data.Objects.ObjectStateManager> возвращается из класса <xref:System.Data.Objects.ObjectContext>, а затем используется для доступа к объекту в этом контексте.  
  
 [!code-csharp[DP ObjectServices Concepts#ObjectStateManager](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#objectstatemanager)]
 [!code-vb[DP ObjectServices Concepts#ObjectStateManager](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#objectstatemanager)]  
  
 В этом примере для возвращаемого диспетчера <xref:System.Data.Objects.ObjectStateManager.TryGetObjectStateEntry%2A> используется метод <xref:System.Data.Objects.ObjectStateManager>, чтобы получить объект по его ключу сущности.  
  
 [!code-csharp[DP ObjectServices Concepts#ApplyItemUpdates](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#applyitemupdates)]
 [!code-vb[DP ObjectServices Concepts#ApplyItemUpdates](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#applyitemupdates)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Работа с объектами (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="QueryProvider">
      <MemberSignature Language="C#" Value="protected internal System.Linq.IQueryProvider QueryProvider { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Linq.IQueryProvider QueryProvider" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.QueryProvider" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property QueryProvider As IQueryProvider" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Linq::IQueryProvider ^ QueryProvider { System::Linq::IQueryProvider ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.QueryProvider : System.Linq.IQueryProvider" Usage="System.Data.Objects.ObjectContext.QueryProvider" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает поставщик запроса LINQ, связанного с контекстом данного объекта.</summary>
        <value>Экземпляр <see cref="T:System.Linq.IQueryProvider" />, используемый контекстом данного объекта.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Refresh">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Обновляет определенные объекты в контексте объекта, используя данные из источника данных.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объекты обновляются в недетерминированном порядке.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Objects.RefreshMode refreshMode, System.Collections.IEnumerable collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Objects.RefreshMode refreshMode, class System.Collections.IEnumerable collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Refresh(System.Data.Objects.RefreshMode,System.Collections.IEnumerable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Objects::RefreshMode refreshMode, System::Collections::IEnumerable ^ collection);" />
      <MemberSignature Language="F#" Value="member this.Refresh : System.Data.Objects.RefreshMode * System.Collections.IEnumerable -&gt; unit" Usage="objectContext.Refresh (refreshMode, collection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="refreshMode" Type="System.Data.Objects.RefreshMode" />
        <Parameter Name="collection" Type="System.Collections.IEnumerable" />
      </Parameters>
      <Docs>
        <param name="refreshMode">Значение <see cref="T:System.Data.Objects.RefreshMode" />, которое указывает, перезаписываются ли изменения свойств в контексте объекта значениями свойств из источника данных.</param>
        <param name="collection">Обновляемая коллекция объектов <see cref="T:System.Collections.IEnumerable" />.</param>
        <summary>Обновляет коллекцию объектов в контексте объекта, используя данные из источника данных.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет двойную предназначение, позволяющую объектам в контексте объекта обновлять данные из источника данных, а также механизм, с помощью которого можно разрешить конфликты. Дополнительные сведения см. в разделе [Сохранение изменений и управление параллелизмом](https://msdn.microsoft.com/library/b8378601-4f26-4a05-a24a-f50aeb68610e).  
  
 Объекты обновляются в недетерминированном порядке.  
  
 После <xref:System.Data.Objects.ObjectContext.Refresh%2A> вызова исходные значения объекта всегда будут обновляться значением источника данных, но текущие значения могут быть или не обновлены значением источника данных. Это зависит от значения <xref:System.Data.Objects.RefreshMode>. <xref:System.Data.Objects.RefreshMode.StoreWins> Режим означает, что объекты в коллекции должны быть обновлены в соответствии со значениями источника данных. <xref:System.Data.Objects.RefreshMode.ClientWins>означает, что будут сохраняться только изменения в контексте объекта, даже если в источнике данных были внесены другие изменения.  
  
 Чтобы гарантировать, что объекты были обновлены логикой на стороне источника данных, можно вызвать <xref:System.Data.Objects.ObjectContext.Refresh%2A> <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> метод <xref:System.Data.Objects.RefreshMode.StoreWins> с после вызова метода.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="collection" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Недопустимый параметр <paramref name="refreshMode" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="collection" /> пуст.  
  
- или - 
Объект не присоединен к контексту.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Работа с объектами (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Objects.RefreshMode refreshMode, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Objects.RefreshMode refreshMode, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Refresh(System.Data.Objects.RefreshMode,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Objects::RefreshMode refreshMode, System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.Refresh : System.Data.Objects.RefreshMode * obj -&gt; unit" Usage="objectContext.Refresh (refreshMode, entity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="refreshMode" Type="System.Data.Objects.RefreshMode" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="refreshMode">Одно из значений <see cref="T:System.Data.Objects.RefreshMode" />, которое задает режим, используемый для обновления <see cref="T:System.Data.Objects.ObjectStateManager" />.</param>
        <param name="entity">Обновляемый объект.</param>
        <summary>Обновляет какой-либо объект в контексте объекта, используя данные из источника данных.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.Refresh%2A>имеет двойную предназначение, позволяющую обновлять объект данными из источника данных и использовать механизм, с помощью которого можно разрешить конфликты. Дополнительные сведения см. в разделе [Сохранение изменений и управление параллелизмом](https://msdn.microsoft.com/library/b8378601-4f26-4a05-a24a-f50aeb68610e).  
  
 Объекты обновляются в недетерминированном порядке.  
  
 После вызова <xref:System.Data.Objects.ObjectContext.Refresh%2A> метода исходные значения объекта всегда будут обновляться значением источника данных, но текущие значения могут быть или не обновлены значением источника данных. Это зависит от значения <xref:System.Data.Objects.RefreshMode>. <xref:System.Data.Objects.RefreshMode.StoreWins> Режим означает, что объект должен быть обновлен в соответствии со значениями источника данных. Это <xref:System.Data.Objects.RefreshMode.ClientWins> значение означает, что будут сохраняться только изменения в контексте объекта, даже если в источнике данных были внесены другие изменения.  
  
 Чтобы гарантировать, что объект был обновлен логикой на стороне источника данных, можно вызвать <xref:System.Data.Objects.ObjectContext.Refresh%2A> метод <xref:System.Data.Objects.RefreshMode.StoreWins> со <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> значением после вызова метода.  
  
   
  
## Examples  
 Этот пример основан на [модели AdventureWorks Sales](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). В этом примере выполняется попытка сохранить изменения, и это может вызвать конфликт параллелизма. Затем показывается, как разрешить конфликт параллелизма путем обновления контекста объекта перед повторным сохранением изменений.  
  
 [!code-csharp[DP ObjectServices Concepts#Concurrency](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#concurrency)]
 [!code-vb[DP ObjectServices Concepts#Concurrency](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#concurrency)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="collection" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Недопустимый параметр <paramref name="refreshMode" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="collection" /> пуст.  
  
- или - 
Объект не присоединен к контексту.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Работа с объектами (Entity Framework)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SaveChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Сохраняет все обновления в источнике данных.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SaveChanges">
      <MemberSignature Language="C#" Value="public int SaveChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SaveChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.SaveChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function SaveChanges () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SaveChanges();" />
      <MemberSignature Language="F#" Value="member this.SaveChanges : unit -&gt; int" Usage="objectContext.SaveChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Сохраняет все обновления в источнике данных и сбрасывает отслеживание изменений в контексте объекта.</summary>
        <returns>Количество объектов в состоянии <see cref="F:System.Data.EntityState.Added" />, <see cref="F:System.Data.EntityState.Modified" /> или <see cref="F:System.Data.EntityState.Deleted" /> на момент вызова метода <see cref="M:System.Data.Objects.ObjectContext.SaveChanges" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы гарантировать, что объекты на клиенте были обновлены логикой на стороне источника данных, можно вызвать <xref:System.Data.Objects.ObjectContext.Refresh%2A> метод <xref:System.Data.Objects.RefreshMode.StoreWins> со значением после вызова <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>метода. Дополнительные сведения см. в разделе [Сохранение изменений и управление параллелизмом](https://msdn.microsoft.com/library/b8378601-4f26-4a05-a24a-f50aeb68610e).  
  
 <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>работает в рамках транзакции. <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>будет выполнять откат этой транзакции и создавать исключение, если ни один из грязных <xref:System.Data.Objects.ObjectStateEntry> объектов не может быть сохранен.  
  
 Если произошло нарушение оптимистичного параллелизма, вызывается исключение <xref:System.Data.OptimisticConcurrencyException>. Нарушение оптимистичного параллелизма можно разрешить, выявив его путем вызова метода <xref:System.Data.Objects.ObjectContext.Refresh%2A> со значением <xref:System.Data.Objects.RefreshMode.StoreWins> или <xref:System.Data.Objects.RefreshMode.ClientWins>, а затем повторного вызова метода <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>. Дополнительные сведения см. в разделе [Практическое руководство. Управление параллелизмом данных в контексте](https://msdn.microsoft.com/library/25ffe70d-ce97-4f0a-8ae0-22b7c40f748a)объекта.  
  
   
  
## Examples  
 Этот пример основан на [модели AdventureWorks Sales](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). В этом примере выполняется попытка сохранить изменения, которые могут вызвать конфликт параллелизма. Затем показывается, как разрешить конфликт параллелизма путем обновления контекста объекта перед повторным сохранением изменений.  
  
 [!code-csharp[DP ObjectServices Concepts#Concurrency](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#concurrency)]
 [!code-vb[DP ObjectServices Concepts#Concurrency](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#concurrency)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.OptimisticConcurrencyException">В источнике данных произошло нарушение оптимистичного параллелизма.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Работа с объектами (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="SaveChanges">
      <MemberSignature Language="C#" Value="public int SaveChanges (bool acceptChangesDuringSave);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SaveChanges(bool acceptChangesDuringSave) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.SaveChanges(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function SaveChanges (acceptChangesDuringSave As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SaveChanges(bool acceptChangesDuringSave);" />
      <MemberSignature Language="F#" Value="member this.SaveChanges : bool -&gt; int" Usage="objectContext.SaveChanges acceptChangesDuringSave" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Use SaveChanges(SaveOptions options) instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptChangesDuringSave" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="acceptChangesDuringSave">Этот параметр необходим для поддержки транзакций на стороне клиента. Если он имеет значение <see langword="true" />, сброс отслеживания изменений во всех объектах производится по завершении работы <see cref="M:System.Data.Objects.ObjectContext.SaveChanges(System.Boolean)" />. Если значение параметра равно <see langword="false" />, необходимо вызвать метод <see cref="M:System.Data.Objects.ObjectContext.AcceptAllChanges" /> по окончании работы <see cref="M:System.Data.Objects.ObjectContext.SaveChanges(System.Boolean)" />.</param>
        <summary>Сохраняет все обновления в источнике данных и при необходимости сбрасывает отслеживание изменений в контексте объекта.</summary>
        <returns>Количество объектов в состоянии <see cref="F:System.Data.EntityState.Added" />, <see cref="F:System.Data.EntityState.Modified" /> или <see cref="F:System.Data.EntityState.Deleted" /> на момент вызова метода <see cref="M:System.Data.Objects.ObjectContext.SaveChanges" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вместо этого вызовите метод. <xref:System.Data.Objects.ObjectContext.SaveChanges%28System.Data.Objects.SaveOptions%29>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.OptimisticConcurrencyException">Произошло нарушение оптимистической блокировки.</exception>
      </Docs>
    </Member>
    <Member MemberName="SaveChanges">
      <MemberSignature Language="C#" Value="public virtual int SaveChanges (System.Data.Objects.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 SaveChanges(valuetype System.Data.Objects.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.SaveChanges(System.Data.Objects.SaveOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SaveChanges (options As SaveOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int SaveChanges(System::Data::Objects::SaveOptions options);" />
      <MemberSignature Language="F#" Value="abstract member SaveChanges : System.Data.Objects.SaveOptions -&gt; int&#xA;override this.SaveChanges : System.Data.Objects.SaveOptions -&gt; int" Usage="objectContext.SaveChanges options" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Data.Objects.SaveOptions" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="options">Значение <see cref="T:System.Data.Objects.SaveOptions" />, определяющее поведение операции.</param>
        <summary>Сохраняет все обновления в источнике данных, используя указанные параметры <see cref="T:System.Data.Objects.SaveOptions" />.</summary>
        <returns>Количество объектов в состоянии <see cref="F:System.Data.EntityState.Added" />, <see cref="F:System.Data.EntityState.Modified" /> или <see cref="F:System.Data.EntityState.Deleted" /> на момент вызова метода <see cref="M:System.Data.Objects.ObjectContext.SaveChanges" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту конкретную перегрузку <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> , чтобы убедиться, что <xref:System.Data.Objects.ObjectContext.DetectChanges%2A> вызывается перед сохранением изменений в источнике данных <xref:System.Data.Objects.ObjectContext.AcceptAllChanges%2A> или вызывается после сохранения изменений в источнике данных.  
  
 Это перечисление <xref:System.FlagsAttribute> содержит, которое позволяет побитовое сочетание значений его членов.  
  
 Чтобы гарантировать, что объекты на клиенте были обновлены логикой на стороне источника данных, можно вызвать <xref:System.Data.Objects.ObjectContext.Refresh%2A> метод <xref:System.Data.Objects.RefreshMode.StoreWins> со значением после вызова <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>метода. <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> Метод работает в транзакции. <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>будет выполнять откат этой транзакции и создавать исключение, если ни один из объектов Dirty <xref:System.Data.Objects.ObjectStateEntry> не может быть сохранен.  
  
 Если произошло нарушение оптимистичного параллелизма, вызывается исключение <xref:System.Data.OptimisticConcurrencyException>. Нарушение оптимистичного параллелизма можно разрешить, выявив его путем вызова метода <xref:System.Data.Objects.ObjectContext.Refresh%2A> со значениями <xref:System.Data.Objects.RefreshMode.StoreWins> или <xref:System.Data.Objects.RefreshMode.ClientWins>, а затем путем повторного вызова метода <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>. Дополнительные сведения см. в разделе [Практическое руководство. Управление параллелизмом данных в контексте](https://msdn.microsoft.com/library/25ffe70d-ce97-4f0a-8ae0-22b7c40f748a)объекта.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.OptimisticConcurrencyException">Произошло нарушение оптимистической блокировки.</exception>
      </Docs>
    </Member>
    <Member MemberName="SavingChanges">
      <MemberSignature Language="C#" Value="public event EventHandler SavingChanges;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SavingChanges" />
      <MemberSignature Language="DocId" Value="E:System.Data.Objects.ObjectContext.SavingChanges" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SavingChanges As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SavingChanges;" />
      <MemberSignature Language="F#" Value="member this.SavingChanges : EventHandler " Usage="member this.SavingChanges : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возникает при сохранении изменений в источнике данных.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Событие <xref:System.Data.Objects.ObjectContext.SavingChanges> происходит в начале операции <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> для объекта <xref:System.Data.Objects.ObjectContext>. Обычно это событие используется для проверки измененного объекта перед записью новых значений в базу данных.  
  
   
  
## Examples  
 Этот пример основан на [модели AdventureWorks Sales](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). Таким способом обработчик для события <xref:System.Data.Objects.ObjectContext.SavingChanges>, которое проверяет состояния сущности, будет зарегистрирован.  
  
 [!code-csharp[DP ObjectServices Concepts#SavingChanges](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#savingchanges)]
 [!code-vb[DP ObjectServices Concepts#SavingChanges](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#savingchanges)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Работа с объектами (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="Translate&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TElement&gt; Translate&lt;TElement&gt; (System.Data.Common.DbDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TElement&gt; Translate&lt;TElement&gt;(class System.Data.Common.DbDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Translate``1(System.Data.Common.DbDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function Translate(Of TElement) (reader As DbDataReader) As ObjectResult(Of TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TElement&gt;&#xA; System::Data::Objects::ObjectResult&lt;TElement&gt; ^ Translate(System::Data::Common::DbDataReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.Translate : System.Data.Common.DbDataReader -&gt; System.Data.Objects.ObjectResult&lt;'Element&gt;" Usage="objectContext.Translate reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <typeparam name="TElement">Тип сущности данных в интерфейсе <see cref="T:System.Data.Common.DbDataReader" />.</typeparam>
        <param name="reader">Объект <see cref="T:System.Data.Common.DbDataReader" />, содержащий данные сущности для преобразования в объекты сущности.</param>
        <summary>Преобразует объект <see cref="T:System.Data.Common.DbDataReader" />, содержащий строки данных сущности, в объекты запрошенного типа сущности.</summary>
        <returns>Перечисление объектов типа <paramref name="TResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод используется для преобразования данных сущности <xref:System.Data.Common.DbDataReader> из в объекты запрошенного типа. <xref:System.Data.Objects.ObjectContext.Translate%2A> Этот процесс выполняется автоматически при <xref:System.Data.Objects.ObjectQuery%601> выполнении для возврата данных сущности. <xref:System.Data.Objects.ObjectContext.Translate%2A> Метод позволяет выполнить стандартный запрос ADO.NET к источнику данных и преобразовать возвращенные строки данных в объекты сущностей.  
  
 Переданный <xref:System.Data.Common.DbDataReader> объект должен содержать данные, сопоставленные с запрошенным типом сущности.  
  
 Дополнительные сведения см. в следующих разделах.  
  
 [Непосредственное исполнение команд Store](https://msdn.microsoft.com/library/5708d0a2-3f76-4825-978a-d06ff5c4bb3d) и  
  
 [Практическое руководство. Выполнять команды непосредственно в источнике данных](https://msdn.microsoft.com/library/def3cc87-cfff-4dee-83cf-1a40c73a2d01)  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Если значение параметра <paramref name="reader" /> равно <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Translate&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TEntity&gt; Translate&lt;TEntity&gt; (System.Data.Common.DbDataReader reader, string entitySetName, System.Data.Objects.MergeOption mergeOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TEntity&gt; Translate&lt;TEntity&gt;(class System.Data.Common.DbDataReader reader, string entitySetName, valuetype System.Data.Objects.MergeOption mergeOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Translate``1(System.Data.Common.DbDataReader,System.String,System.Data.Objects.MergeOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; System::Data::Objects::ObjectResult&lt;TEntity&gt; ^ Translate(System::Data::Common::DbDataReader ^ reader, System::String ^ entitySetName, System::Data::Objects::MergeOption mergeOption);" />
      <MemberSignature Language="F#" Value="member this.Translate : System.Data.Common.DbDataReader * string * System.Data.Objects.MergeOption -&gt; System.Data.Objects.ObjectResult&lt;'Entity&gt;" Usage="objectContext.Translate (reader, entitySetName, mergeOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="entitySetName" Type="System.String" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">Тип сущности данных в интерфейсе <see cref="T:System.Data.Common.DbDataReader" />.</typeparam>
        <param name="reader">Объект <see cref="T:System.Data.Common.DbDataReader" />, содержащий данные сущности для преобразования в объекты сущности.</param>
        <param name="entitySetName">Набор сущностей типа <typeparamref name="TEntity" />.</param>
        <param name="mergeOption">Объект <see cref="T:System.Data.Objects.MergeOption" />, используемый при добавлении преобразованных объектов в контекст объекта. Значение по умолчанию — <see cref="F:System.Data.Objects.MergeOption.AppendOnly" />.</param>
        <summary>Преобразует объект <see cref="T:System.Data.Common.DbDataReader" />, содержащий строки данных сущности, в объекты запрошенного типа сущности (в определенном наборе сущностей и с применением указанного параметра слияния).</summary>
        <returns>Перечисление объектов типа <paramref name="TResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод используется для преобразования данных сущности <xref:System.Data.Common.DbDataReader> из в объекты запрошенного типа. <xref:System.Data.Objects.ObjectContext.Translate%2A> Этот процесс выполняется автоматически при <xref:System.Data.Objects.ObjectQuery%601> выполнении для возврата данных сущности. <xref:System.Data.Objects.ObjectContext.Translate%2A> Метод позволяет выполнить стандартный запрос ADO.NET к источнику данных и преобразовать возвращенные строки данных в объекты сущностей.  
  
 Переданный <xref:System.Data.Common.DbDataReader> объект должен содержать данные, сопоставленные с запрошенным типом сущности.  
  
 Дополнительные сведения см. в следующих разделах.  
  
 [Непосредственное исполнение команд Store](https://msdn.microsoft.com/library/5708d0a2-3f76-4825-978a-d06ff5c4bb3d) и  
  
 [Практическое руководство. Выполнять команды непосредственно в источнике данных](https://msdn.microsoft.com/library/def3cc87-cfff-4dee-83cf-1a40c73a2d01)  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Если значение параметра <paramref name="reader" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Когда предоставленный <paramref name="mergeOption" /> не является допустимым значением <see cref="T:System.Data.Objects.MergeOption" />.</exception>
        <exception cref="T:System.InvalidOperationException">Когда предоставленный <paramref name="entitySetName" /> не является допустимым набором сущностей для типа <paramref name="TResult" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryGetObjectByKey">
      <MemberSignature Language="C#" Value="public bool TryGetObjectByKey (System.Data.EntityKey key, out object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetObjectByKey(class System.Data.EntityKey key, [out] object&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.TryGetObjectByKey(System.Data.EntityKey,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetObjectByKey (key As EntityKey, ByRef value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetObjectByKey(System::Data::EntityKey ^ key, [Runtime::InteropServices::Out] System::Object ^ % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetObjectByKey : System.Data.EntityKey *  -&gt; bool" Usage="objectContext.TryGetObjectByKey (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Data.EntityKey" />
        <Parameter Name="value" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">Ключ объекта, который нужно найти.</param>
        <param name="value">При возвращении данного метода содержит объект.</param>
        <summary>Возвращает объект, имеющий указанный ключ сущности.</summary>
        <returns><see langword="true" />, если объект был успешно извлечен. Значение <see langword="false" />, если ключ <paramref name="key" /> является временным, подключение равно значению <see langword="null" /> или объект <paramref name="value" /> равен значению <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Data.Objects.ObjectContext.TryGetObjectByKey%2A> пытается получить объект с указанным ключом <xref:System.Data.EntityKey> из диспетчера <xref:System.Data.Objects.ObjectStateManager>. Если объект в данный момент не загружен в контекст объекта, выполняется запрос при попытке вернуть объект из источника данных. Дополнительные сведения см. в разделе [запросы объектов](https://msdn.microsoft.com/library/0768033c-876f-471d-85d5-264884349276).  
  
 Используйте метод <xref:System.Data.Objects.ObjectContext.TryGetObjectByKey%2A>, чтобы избежать обработки исключения <xref:System.Data.ObjectNotFoundException>, вызванного методом <xref:System.Data.Objects.ObjectContext.GetObjectByKey%2A>, когда объект невозможно найти.  
  
 Этот метод будет возвращать объекты в состоянии <xref:System.Data.EntityState.Deleted>.  
  
 Временный ключ нельзя использовать для возврата объекта из источника данных.  
  
 <xref:System.Data.Objects.ObjectContext.GetObjectByKey%2A> `TryParse` <xref:System.Data.ObjectNotFoundException> `false` Метод применяет стандартный шаблон .NET для метода, возвращая при перехвате. <xref:System.Data.Objects.ObjectContext.TryGetObjectByKey%2A>  
  
   
  
## Examples  
 Пример в этом разделе основан на [модели AdventureWorks Sales](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). В этом примере создается ключ <xref:System.Data.EntityKey> для сущности данного типа, а затем выполняется попытка получить сущность по ключу.  
  
 [!code-csharp[DP ObjectServices Concepts#EntityKeyClass_TryGetObjectByKey](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#entitykeyclass_trygetobjectbykey)]
 [!code-vb[DP ObjectServices Concepts#EntityKeyClass_TryGetObjectByKey](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#entitykeyclass_trygetobjectbykey)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Несовместимые метаданные для <paramref name="key" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> — <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Работа с объектами (Entity Framework)</related>
      </Docs>
    </Member>
  </Members>
</Type>
