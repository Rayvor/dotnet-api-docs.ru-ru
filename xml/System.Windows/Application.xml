<Type Name="Application" FullName="System.Windows.Application">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3f32abe385886566024cf8917dc78743dad79f9b" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70481280" /></Metadata><TypeSignature Language="C#" Value="public class Application : System.Windows.Threading.DispatcherObject, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Application extends System.Windows.Threading.DispatcherObject implements class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Application" />
  <TypeSignature Language="VB.NET" Value="Public Class Application&#xA;Inherits DispatcherObject&#xA;Implements IQueryAmbient" />
  <TypeSignature Language="C++ CLI" Value="public ref class Application : System::Windows::Threading::DispatcherObject, System::Windows::Markup::IQueryAmbient" />
  <TypeSignature Language="F#" Value="type Application = class&#xA;    inherit DispatcherObject&#xA;    interface IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Инкапсулирует приложение Windows Presentation Foundation.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application>— Это класс, инкапсулирующий [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] функциональные возможности конкретного приложения, включая следующие:  
  
-   **Время существования приложения** <xref:System.Windows.Application.Activated>: <xref:System.Windows.Application.Deactivated> <xref:System.Windows.Application.Current%2A> <xref:System.Windows.Application.DispatcherUnhandledException> ,, <xref:System.Windows.Application.Run%2A> ,, , <xref:System.Windows.Application.SessionEnding> , , ,, <xref:System.Windows.Application.ShutdownMode%2A> . <xref:System.Windows.Application.Shutdown%2A> <xref:System.Windows.Application.Exit> <xref:System.Windows.Application.Startup>  
  
-   **Окно области приложения, свойство и управление ресурсами** <xref:System.Windows.Application.FindResource%2A>: <xref:System.Windows.Application.StartupUri%2A>, <xref:System.Windows.Application.MainWindow%2A> <xref:System.Windows.Application.GetContentStream%2A>, <xref:System.Windows.Application.GetResourceStream%2A>, <xref:System.Windows.Application.LoadComponent%2A>,, <xref:System.Windows.Application.Properties%2A>, <xref:System.Windows.Application.Resources%2A>,,. <xref:System.Windows.Application.Windows%2A>  
  
-   **Параметры командной строки и обработка кода выхода**: <xref:System.Windows.Application.Startup?displayProperty=nameWithType>, <xref:System.Windows.Application.Exit?displayProperty=nameWithType>, <xref:System.Windows.Application.Shutdown%2A?displayProperty=nameWithType>.  
  
-   **Навигация**: <xref:System.Windows.Application.FragmentNavigation>, <xref:System.Windows.Application.LoadCompleted>, , <xref:System.Windows.Application.Navigated>  , <xref:System.Windows.Application.NavigationProgress> , , <xref:System.Windows.Application.NavigationFailed> , , . <xref:System.Windows.Application.GetCookie%2A>  <xref:System.Windows.Application.Navigating> <xref:System.Windows.Application.NavigationStopped> <xref:System.Windows.Application.SetCookie%2A>  
  
 <xref:System.Windows.Application>реализует Одноэлементный шаблон для предоставления общего доступа к службам окна, свойства и области ресурсов. Следовательно, для каждого <xref:System.Windows.Application> <xref:System.AppDomain>экземпляра можно создать только один экземпляр класса.  
  
 Можно реализовать <xref:System.Windows.Application> с помощью разметки, разметки и кода программной части или кода. Если <xref:System.Windows.Application> реализуется с разметкой (разметка или разметка и код программной части), то файл разметки должен быть настроен [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] `ApplicationDefinition` как элемент.  
  
> [!NOTE]
>  Для <xref:System.Windows.Application> автономного приложения не требуется объект; можно реализовать пользовательский `static` метод точки входа (`Main`), который <xref:System.Windows.Application>открывает окно без создания экземпляра. Однако для [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)] этого <xref:System.Windows.Application> требуется объект.  
  
   
  
## Examples  
 В следующем примере показано, как стандартное приложение определяется с использованием только разметки:  
  
 [!code-xaml[ApplicationSnippets#ApplicationMARKUP](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/AppMarkup.xaml#applicationmarkup)]  
  
 В следующем примере показано, как стандартное приложение определяется с использованием только кода.  
  
 [!code-csharp[ApplicationSnippets#ApplicationCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/AppCode.cs#applicationcode)]
 [!code-vb[ApplicationSnippets#ApplicationCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSnippets/visualbasic/appcode.vb#applicationcode)]  
  
 В следующем примере показано определение стандартного приложения с помощью сочетания разметки и кода программной части.  
  
 [!code-xaml[ApplicationSnippets#ApplicationXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/App.xaml#applicationxaml)]  
  
 [!code-csharp[ApplicationSnippets#ApplicationCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/App.xaml.cs#applicationcodebehind)]
 [!code-vb[ApplicationSnippets#ApplicationCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSnippets/visualbasic/application.xaml.vb#applicationcodebehind)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Открытые <see langword="static" />  ( <see langword="Shared" />  в Visual Basic) члены этого типа являются потокобезопасными. Кроме того <see cref="M:System.Windows.Application.FindResource(System.Object)" /> , методы и <see cref="M:System.Windows.Application.TryFindResource(System.Object)" /> и <see cref="P:System.Windows.Application.Properties" /> <see cref="P:System.Windows.Application.Resources" /> свойства и являются потокобезопасными.</threadsafe>
    <altmember cref="T:System.Windows.Window" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Application ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Application();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.Application" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для каждого <xref:System.Windows.Application> <xref:System.AppDomain>экземпляра можно создать только один экземпляр класса, чтобы обеспечить общий доступ к отдельному набору окна, свойства и данных ресурса в области приложения. Следовательно, конструктор <xref:System.Windows.Application> без параметров класса определяет, является ли инициализированный экземпляр первым экземпляром <xref:System.AppDomain>в; если нет, <xref:System.InvalidOperationException> создается исключение.  
  
 Объект для текущего <xref:System.AppDomain> объекта предоставляется из статического <xref:System.Windows.Application.Current%2A> свойства. <xref:System.Windows.Application>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Для каждого <see cref="T:System.Windows.Application" /> создается больше одного экземпляра класса <see cref="T:System.AppDomain" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Activated" />
      <MemberSignature Language="VB.NET" Value="Public Event Activated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Activated;" />
      <MemberSignature Language="F#" Value="member this.Activated : EventHandler " Usage="member this.Activated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда приложение становиться активным.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Активировано Windows Presentation Foundationое приложение, которое содержит одно или несколько открытых окон (становится основным приложением), когда одно из окон активируется впервые с момента запуска приложения или когда одна из окон активирована в момент приложение неактивно: в частности, активация происходит в следующих случаях:  
  
-   Приложение открывает свое первое окно.  
  
-   Пользователь переключается на приложение с помощью сочетания клавиш ALT + TAB или диспетчера задач.  
  
-   Пользователь нажимает кнопку на панели задач для одного из окон в приложении.  
  
 Приложения, которым необходимо определить, когда они активируются, <xref:System.Windows.Application.Activated> могут справиться с событием.  
  
 После первой активации приложения оно может быть деактивировано и повторно активировано много раз во время его существования. Если поведение или состояние приложения зависит от состояния активации, оно может управлять <xref:System.Windows.Application.Activated> событиями и <xref:System.Windows.Application.Deactivated> , чтобы определить состояние активации.  
  
 После того как приложение становится активным <xref:System.Windows.Application.Activated> , оно не будет вызываться повторно до тех пор, пока приложение не будет отключено, независимо от того, сколько окон в приложении активируется, пока приложение активно.  
  
 <xref:System.Windows.Application.Activated>не вызывается для [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)].  
  
   
  
## Examples  
 В следующем примере показано, как определить, когда автономное приложение активируется и деактивируется.  
  
 [!code-xaml[ApplicationActivationSnippets#DetectActivationStateXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml#detectactivationstatexaml)]  
  
 [!code-csharp[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml.cs#detectactivationstatecodebehind)]
 [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationActivationSnippets/visualbasic/application.xaml.vb#detectactivationstatecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnActivated(System.EventArgs)" />
        <altmember cref="E:System.Windows.Application.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Windows.Application Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Application Current" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Current As Application" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Application ^ Current { System::Windows::Application ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Windows.Application" Usage="System.Windows.Application.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Application</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Windows.Application" /> текущего <see cref="T:System.AppDomain" />.</summary>
        <value>Объект <see cref="T:System.Windows.Application" /> для текущего <see cref="T:System.AppDomain" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application>— Это <xref:System.Windows.Application.Current%2A> <xref:System.Windows.Application> <xref:System.AppDomain>одноэлементный тип, реализующий статическое свойство для предоставления общего доступа к экземпляру для текущего.<xref:System.AppDomain> Такая схема гарантирует, что состояние, <xref:System.Windows.Application>управляемое, включая общие ресурсы и состояние, доступно из одного общего расположения.  
  
 Это свойство является потокобезопасным и доступно из любого потока.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Deactivated">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Deactivated" />
      <MemberSignature Language="VB.NET" Value="Public Event Deactivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Deactivated;" />
      <MemberSignature Language="F#" Value="member this.Deactivated : EventHandler " Usage="member this.Deactivated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда приложение перестает быть активным.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows Presentation Foundation приложение, которое имеет одно или несколько открытых окон, деактивируется (перестает быть основным приложением), когда пользователь выполняет следующие действия:  
  
-   Переключает на другое приложение с помощью ALT + TAB или диспетчера задач.  
  
-   Нажимает кнопку панели задач для окна в другом приложении.  
  
 Приложения, которым необходимо обнаружить деактивацию, могут <xref:System.Windows.Application.Deactivated> справиться с событием.  
  
 После первой активации приложения оно может быть деактивировано и повторно активировано много раз во время его существования. Если поведение приложения или его состояние зависит от состояния активации, оно может управлять <xref:System.Windows.Application.Deactivated> событиями и <xref:System.Windows.Application.Activated> , чтобы определить, в каком состоянии оно находится.  
  
 <xref:System.Windows.Application.Deactivated>не вызывается для [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)].  
  
   
  
## Examples  
 В следующем примере показано, как определить, когда автономное приложение деактивируется и активируется.  
  
 [!code-xaml[ApplicationActivationSnippets#DetectActivationStateXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml#detectactivationstatexaml)]  
  
 [!code-csharp[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml.cs#detectactivationstatecodebehind)]
 [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationActivationSnippets/visualbasic/application.xaml.vb#detectactivationstatecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
        <altmember cref="E:System.Windows.Application.Activated" />
      </Docs>
    </Member>
    <Member MemberName="DispatcherUnhandledException">
      <MemberSignature Language="C#" Value="public event System.Windows.Threading.DispatcherUnhandledExceptionEventHandler DispatcherUnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Threading.DispatcherUnhandledExceptionEventHandler DispatcherUnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.DispatcherUnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DispatcherUnhandledException As DispatcherUnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Threading::DispatcherUnhandledExceptionEventHandler ^ DispatcherUnhandledException;" />
      <MemberSignature Language="F#" Value="member this.DispatcherUnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " Usage="member this.DispatcherUnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherUnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при генерации приложением исключения, которое не обрабатывается.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию Windows Presentation Foundation перехватывает необработанные исключения, уведомляет пользователей об исключении из диалогового окна (из которого они могут сообщить об исключении) и автоматически завершает работу приложения.  
  
 Однако если приложению требуется выполнить пользовательскую обработку необработанных исключений из централизованного расположения, необходимо обработать <xref:System.Windows.Application.DispatcherUnhandledException>.  
  
 <xref:System.Windows.Application.DispatcherUnhandledException>вызывается <xref:System.Windows.Application> объектом для каждого исключения, которое не обрабатывается кодом, выполняемым в основном потоке пользовательского интерфейса.  
  
 Если исключение не обрабатывается в фоновом потоке пользовательского интерфейса (потоке с собственным <xref:System.Windows.Threading.Dispatcher>) или в фоновом рабочем потоке (потоке <xref:System.Windows.Threading.Dispatcher>без), то исключение не пересылается в основной поток пользовательского интерфейса. Следовательно, <xref:System.Windows.Application.DispatcherUnhandledException> не вызывается. В таких случаях необходимо написать код для следующих действий:  
  
1.  Обрабатывайте исключения в фоновом потоке.  
  
2.  Отправьте эти исключения в основной поток пользовательского интерфейса.  
  
3.  Вызывайте их в основном потоке пользовательского интерфейса, не обрабатывая <xref:System.Windows.Application.DispatcherUnhandledException> их, чтобы их можно было вызывать.  
  
 Дополнительные сведения см. в статье Общие сведения о [потоковой модели](~/docs/framework/wpf/advanced/threading-model.md) .  
  
 Обработчику <xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs> событий передается аргумент, который содержит контекстные сведения об исключении, в том числе: <xref:System.Windows.Application.DispatcherUnhandledException>  
  
-   Исключение (<xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Exception%2A>).  
  
-   Источник <xref:System.Windows.Threading.Dispatcher> , из которого он был создан<xref:System.Windows.Threading.DispatcherEventArgs.Dispatcher%2A>().  
  
 Эти сведения можно использовать, чтобы определить, является ли исключение восстанавливаемым или нет. Восстанавливаемым исключением может быть <xref:System.IO.FileNotFoundException>, например, в то время как невосстанавливаемое исключение может <xref:System.StackOverflowException>быть, например.  
  
 При обработке необработанного исключения <xref:System.Windows.Application.DispatcherUnhandledException>из и вы не хотите [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] продолжать его обработку, необходимо присвоить <xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled%2A> свойству `true`значение.  
  
 В отличие от других событий, <xref:System.Windows.Application> которые вызываются, <xref:System.Windows.Application.DispatcherUnhandledException> не имеет соответствующей защищенной виртуальной реализации (ондиспатчерунхандледексцептион). Следовательно, классы, производные от <xref:System.Windows.Application> , должны всегда регистрировать <xref:System.Windows.Application.DispatcherUnhandledException> обработчик событий для обработки необработанных исключений.  
  
   
  
## Examples  
 В следующем примере показано, как обрабатывать необработанные исключения, обрабатывая <xref:System.Windows.Application.DispatcherUnhandledException> событие.  
  
 [!code-csharp[handling-unhandled-exceptions](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/CSharp/App.xaml.cs)]
 [!code-vb[handling-unhandled-exceptions](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/visualbasic/application.xaml.vb)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public event System.Windows.ExitEventHandler Exit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.ExitEventHandler Exit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exit As ExitEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::ExitEventHandler ^ Exit;" />
      <MemberSignature Language="F#" Value="member this.Exit : System.Windows.ExitEventHandler " Usage="member this.Exit : System.Windows.ExitEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ExitEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Генерируется непосредственно перед завершением работы приложения и не может быть отменено.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Приложение может завершить работу по одной из следующих причин:  
  
-   Метод объекта вызывается либо явным образом, либо в соответствии со <xref:System.Windows.Application.ShutdownMode%2A> свойством. <xref:System.Windows.Application> <xref:System.Windows.Application.Shutdown%2A>  
  
-   Пользователь завершает сеанс путем выхода из системы или завершения его работы.  
  
 Можно определить, когда происходит завершение работы приложения, обрабатывая <xref:System.Windows.Application.Exit> событие, и при необходимости выполнить дополнительную обработку.  
  
 Кроме того <xref:System.Windows.Application.Exit> , можно выполнять проверку или изменение кода выхода приложения, если вам не нужно вызывать <xref:System.Windows.Application.Shutdown%2A> его явным образом. Код выхода предоставляется из <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> свойства <xref:System.Windows.ExitEventArgs> аргумента <xref:System.Windows.Application.Exit> , который передается в обработчик событий. При остановке работы приложения код выхода передается в операционную систему для последующей обработки.  
  
 Если приложение обрабатывает <xref:System.Windows.Application.SessionEnding> событие, а затем отменяет его, <xref:System.Windows.Application.Exit> не вызывается и приложение продолжит выполнение в соответствии с режимом завершения работы.  
  
 Код выхода можно задать из [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)], хотя значение игнорируется.  
  
 Для [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)] , <xref:System.Windows.Application.Exit>  вызывается в следующих случаях:  
  
-   [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] Выполняется переход от.  
  
-   В [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)]при закрытии вкладки, на которой [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] размещается.  
  
-   Закрывается браузер.  
  
 Во всех случаях значение <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> свойства игнорируется.  
  
   
  
## Examples  
 В следующем примере показано, как:  
  
-   Обработайте <xref:System.Windows.Application.Exit> событие.  
  
-   Проверьте и обновите <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> свойство <xref:System.Windows.ExitEventArgs>объекта.  
  
-   Запись записи в журнал приложения в изолированном хранилище.  
  
-   Сохранение состояния приложения в изолированном хранилище.  
  
 [!code-xaml[ApplicationExitSnippets#HandleExitXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationExitSnippets/CSharp/App.xaml#handleexitxaml)]  
  
 [!code-csharp[ApplicationExitSnippets#HandleExitCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationExitSnippets/CSharp/App.xaml.cs#handleexitcodebehind)]
 [!code-vb[ApplicationExitSnippets#HandleExitCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationExitSnippets/visualbasic/application.xaml.vb#handleexitcodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
        <altmember cref="E:System.Windows.Application.Startup" />
        <altmember cref="T:System.IO.IsolatedStorage.IsolatedStorage" />
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="application.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Имя искомого ресурса.</param>
        <summary>Осуществляет поиск ресурса [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)], например <see cref="T:System.Windows.Style" /> или <see cref="T:System.Windows.Media.Brush" />, с указанным ключом и генерирует исключение, если запрошенный ресурс не найден (см. [Ресурсы XAML](~/docs/framework/wpf/advanced/xaml-resources.md)).</summary>
        <returns>Запрошенный объект ресурса. Если ресурс не найден, генерируется <see cref="T:System.Windows.ResourceReferenceKeyNotFoundException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.FindResource%2A>сначала проанализируйте ресурсы области приложения для указанного ресурса. Ресурсы области приложения управляются с помощью <xref:System.Windows.Application>и предоставляются <xref:System.Windows.Application.Resources%2A> из свойства. Если указанный ресурс не найден в наборе ресурсов области приложения, <xref:System.Windows.Application.FindResource%2A> далее выполняется поиск по системным ресурсам. Системные ресурсы — это ресурсы оболочки, определенные пользователем, включая цвета, шрифты и конфигурации оболочки. Они предоставляются из <xref:System.Windows.SystemColors>типов, <xref:System.Windows.SystemFonts>и <xref:System.Windows.SystemParameters> соответственно в качестве статических свойств. Чтобы использовать <xref:System.Windows.Application.FindResource%2A> для их получения, эти типы также предоставляют свойства ключа ресурса, предназначенные для <xref:System.Windows.Application.FindResource%2A>передачи, например <xref:System.Windows.SystemParameters.IconWidthKey%2A>.  
  
 Поскольку <xref:System.Windows.Application.FindResource%2A> возвращает объект, необходимо привести возвращаемое значение к соответствующему типу, если ресурс найден.  
  
> [!IMPORTANT]
>  При вызове этого метода для ключа, который не удается найти, создается исключение. Если вы не хотите управлять исключениями, полученными в результате <xref:System.Windows.Application.FindResource%2A>вызова метода <xref:System.Windows.Application.TryFindResource%2A> , вызовите вместо него. <xref:System.Windows.Application.TryFindResource%2A> возвращает ссылку, если запрошенный ресурс не удается найти и не создает исключение. `null`  
  
 Этот метод является потокобезопасным и может быть вызван из любого потока.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Windows.Application.FindResource%2A> для поиска ресурса, а также для решения <xref:System.Windows.ResourceReferenceKeyNotFoundException> , если ресурс не найден.  
  
 [!code-csharp[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcallfindresourcecodebehind)]
 [!code-vb[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcallfindresourcecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">Не удалось найти данный ресурс.</exception>
        <altmember cref="M:System.Windows.Application.TryFindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FragmentNavigation">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.FragmentNavigation" />
      <MemberSignature Language="VB.NET" Value="Public Event FragmentNavigation As FragmentNavigationEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::FragmentNavigationEventHandler ^ FragmentNavigation;" />
      <MemberSignature Language="F#" Value="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " Usage="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.FragmentNavigationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда начинается переход к фрагменту содержимого, Переход происходит сразу же, если желаемый фрагмент находится в текущем содержимом, или после загрузки исходного содержимого [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)], если желаемый фрагмент находится в другом содержимом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Навигатор — <xref:System.Windows.Navigation.NavigationWindow> это либо <xref:System.Windows.Controls.Frame>или.  
  
 См. раздел <xref:System.Windows.Navigation.NavigationService.FragmentNavigation?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="GetContentStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetContentStream (Uri uriContent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetContentStream(class System.Uri uriContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetContentStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetContentStream (uriContent As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetContentStream(Uri ^ uriContent);" />
      <MemberSignature Language="F#" Value="static member GetContentStream : Uri -&gt; System.Windows.Resources.StreamResourceInfo" Usage="System.Windows.Application.GetContentStream uriContent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriContent" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriContent">Относительный <see cref="T:System.Uri" />, указывающий на неприсоединенный ресурс.</param>
        <summary>Возвращает поток ресурса для файла данных содержания, расположенного в указанном <see cref="T:System.Uri" /> (см. [Ресурсы, содержимое и файлы данных WPF-приложения](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).</summary>
        <returns><see cref="T:System.Windows.Resources.StreamResourceInfo" />, содержащий файла данных содержания, расположенного в указанном <see cref="T:System.Uri" />. Если неприсоединенный ресурс не найден, тогда возвращается значение null.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не является потокобезопасным.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="T:System.Uri" />, передаваемый <see cref="M:System.Windows.Application.GetContentStream(System.Uri)" /> является нулевым.</exception>
        <exception cref="T:System.ArgumentException"><see cref="T:System.Uri" />, передаваемый <see cref="M:System.Windows.Application.GetContentStream(System.Uri)" /> является абсолютным <see cref="T:System.Uri" />.</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="GetCookie">
      <MemberSignature Language="C#" Value="public static string GetCookie (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetCookie(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetCookie(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetCookie(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="static member GetCookie : Uri -&gt; string" Usage="System.Windows.Application.GetCookie uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri"><see cref="T:System.Uri" />, определяющий положение, для которого был создан файл cookie.</param>
        <summary>Возвращает файл cookie для расположения, указанного <see cref="T:System.Uri" />.</summary>
        <returns><see cref="T:System.String" />, в случае, если файл cookie существует; в противном случае — если клавиша ALT нажата, в противном случае генерируется <see cref="T:System.ComponentModel.Win32Exception" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.GetCookie%2A>Извлекает файл cookie для указанного <xref:System.Uri>объекта. Если не удается извлечь файл cookie, <xref:System.ComponentModel.Win32Exception> создается исключение. Необходимо написать код для анализа строки cookie в список пар "имя-значение".  
  
 Общие сведения о файлах cookie в [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]см. в разделе [Общие сведения о навигации](~/docs/framework/wpf/app-development/navigation-overview.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Если при попытке извлечь указанный файл cookie возникла проблема, функция <see langword="InternetGetCookie" /> (вызванная <see cref="M:System.Windows.Application.GetCookie(System.Uri)" />), генерирует ошибку [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)].</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для получения файла cookie для файлов <see cref="T:System.Uri" />. Связанное перечисление:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">для получения файла cookie для не основанного на <see cref="T:System.Uri" />файлах. Связанное перечисление:<see cref="P:System.Net.WebPermission.ConnectList" /></permission>
        <altmember cref="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRemoteStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetRemoteStream (Uri uriRemote);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetRemoteStream(class System.Uri uriRemote) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRemoteStream (uriRemote As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetRemoteStream(Uri ^ uriRemote);" />
      <MemberSignature Language="F#" Value="static member GetRemoteStream : Uri -&gt; System.Windows.Resources.StreamResourceInfo" Usage="System.Windows.Application.GetRemoteStream uriRemote" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriRemote" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriRemote"><see cref="T:System.Uri" />, указывающий на неприсоединенный ресурс в источнике.</param>
        <summary>Возвращает поток ресурса для исходного файла данных ресурса, расположенного в указанном <see cref="T:System.Uri" /> (см. [Ресурсы, содержимое и файлы данных WPF-приложения](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).</summary>
        <returns><see cref="T:System.Windows.Resources.StreamResourceInfo" />, содержащий поток ресурса для исходного файла данных ресурса, расположенного в указанном <see cref="T:System.Uri" />. Если неприсоединенный ресурс не найден, тогда возвращается <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не является потокобезопасным.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="T:System.Uri" />, передаваемый <see cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" /> является нулевым.</exception>
        <exception cref="T:System.ArgumentException"><see cref="T:System.Uri" />, передаваемый в <see cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />, является неотносительным, абсолютным, но не задан в форме <c>pack://siteoforigin:,,,/</c>.</exception>
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="GetResourceStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetResourceStream (Uri uriResource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetResourceStream(class System.Uri uriResource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetResourceStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetResourceStream (uriResource As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetResourceStream(Uri ^ uriResource);" />
      <MemberSignature Language="F#" Value="static member GetResourceStream : Uri -&gt; System.Windows.Resources.StreamResourceInfo" Usage="System.Windows.Application.GetResourceStream uriResource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriResource" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriResource"><see cref="T:System.Uri" />, указующий на внедренный ресурс.</param>
        <summary>Возвращает поток ресурса для файла данных ресурса, расположенного в указанном <see cref="T:System.Uri" /> (см. [Ресурсы, содержимое и файлы данных WPF-приложения](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).</summary>
        <returns><see cref="T:System.Windows.Resources.StreamResourceInfo" />, содержащий поток ресурса для файла данных ресурса, расположенного в указанном <see cref="T:System.Uri" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не является потокобезопасным.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="T:System.Uri" />, передаваемый <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> является нулевым.</exception>
        <exception cref="T:System.ArgumentException"><see cref="T:System.Uri" />, передаваемый в <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />, является неотносительным, абсолютным, но не задан в форме <c>pack://application:,,,/</c>.</exception>
        <exception cref="T:System.IO.IOException">Не удается найти <see cref="T:System.Uri" />, передаваемый в <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />.</exception>
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="LoadCompleted">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.LoadCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Event LoadCompleted As LoadCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::LoadCompletedEventHandler ^ LoadCompleted;" />
      <MemberSignature Language="F#" Value="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " Usage="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.LoadCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит после того, как содержимое, переданное приложению, было загружено, проанализировано и отрисовывается.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Навигатор — <xref:System.Windows.Navigation.NavigationWindow> это либо <xref:System.Windows.Controls.Frame>или.  
  
 См. раздел <xref:System.Windows.Navigation.NavigationService.LoadCompleted?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Прослушивать события в перемещенном содержимом, таком как <xref:System.Windows.FrameworkElement.Loaded> <xref:System.Windows.Controls.Page> событие, перед обращением к свойствам перемещенного содержимого.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadComponent">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Подгружает файл [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)], расположенный по указанному [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)].</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Файл может представлять собой файл кода приложения (настроенный [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] как элемент страницы) или файл данных приложения (файл ресурсов, файл содержимого или файл исходного сайта; см. раздел [ресурс приложения WPF, содержимое и файлы данных](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)). [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]  
  
> [!NOTE]
>  Этот метод не является потокобезопасным.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadComponent">
      <MemberSignature Language="C#" Value="public static object LoadComponent (Uri resourceLocator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object LoadComponent(class System.Uri resourceLocator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.LoadComponent(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadComponent (resourceLocator As Uri) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ LoadComponent(Uri ^ resourceLocator);" />
      <MemberSignature Language="F#" Value="static member LoadComponent : Uri -&gt; obj" Usage="System.Windows.Application.LoadComponent resourceLocator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceLocator" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="resourceLocator">Объект <see cref="T:System.Uri" />, сопоставляемый с относительным файлом [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</param>
        <summary>Подгружает файл [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)], располагающийся по указанному [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)], и преобразует его в экземпляр объекта, определенного корневым элементом файла [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)].</summary>
        <returns>Экземпляр корневого элемента, заданный загруженным файлом XAML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Необходимо явно преобразовать возвращаемое значение в тот же тип, что и корневой элемент [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] файла.  
  
 Файл может представлять собой файл кода приложения (настроенный [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] как элемент страницы) или файл данных приложения (файл ресурсов, файл содержимого или файл исходного сайта; см. раздел [ресурс приложения WPF, содержимое и файлы данных](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)). [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]  
  
> [!NOTE]
>  Этот метод не является потокобезопасным.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="resourceLocator" /> имеет значение null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="resourceLocator" /> — это абсолютный [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</exception>
        <exception cref="T:System.Exception">Файл не является файлом [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)].</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="LoadComponent">
      <MemberSignature Language="C#" Value="public static void LoadComponent (object component, Uri resourceLocator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LoadComponent(object component, class System.Uri resourceLocator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.LoadComponent(System.Object,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LoadComponent (component As Object, resourceLocator As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LoadComponent(System::Object ^ component, Uri ^ resourceLocator);" />
      <MemberSignature Language="F#" Value="static member LoadComponent : obj * Uri -&gt; unit" Usage="System.Windows.Application.LoadComponent (component, resourceLocator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="resourceLocator" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="component">Объект того же типа, что и корневой элемент файла [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</param>
        <param name="resourceLocator">Объект <see cref="T:System.Uri" />, сопоставляемый с относительным файлом [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</param>
        <summary>Загружает файл [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)], расположенный в указанном [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)], и преобразует его в экземпляр объекта, заданного корневым элементом файла [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)].</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Файл может представлять собой файл кода приложения (настроенный [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] как элемент страницы) или файл данных приложения (файл ресурсов, файл содержимого или файл исходного сайта; см. раздел [ресурс приложения WPF, содержимое и файлы данных](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)). [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]  
  
> [!NOTE]
>  Этот метод не является потокобезопасным.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="resourceLocator" /> имеет значение null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="resourceLocator" /> — это абсолютный [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</exception>
        <exception cref="T:System.Exception">Тип элемента <paramref name="component" /> не соответствует корневому элементу файла [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="MainWindow">
      <MemberSignature Language="C#" Value="public System.Windows.Window MainWindow { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Window MainWindow" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.MainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Property MainWindow As Window" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Window ^ MainWindow { System::Windows::Window ^ get(); void set(System::Windows::Window ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MainWindow : System.Windows.Window with get, set" Usage="System.Windows.Application.MainWindow" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает главное окно приложения.</summary>
        <value><see cref="T:System.Windows.Window" />, определяющееся, как лавное окно приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.MainWindow%2A>автоматически устанавливается со ссылкой на первый <xref:System.Windows.Window> объект, для которого создается экземпляр <xref:System.AppDomain>в.  
  
 Можно указать другое главное окно, задав <xref:System.Windows.Application.MainWindow%2A> для <xref:System.Windows.Application.MainWindow%2A> свойства значение другого <xref:System.Windows.Application.Windows%2A> объекта.  
  
 <xref:System.Windows.Application.ShutdownMode%2A> Если свойство <xref:System.Windows.Application> объекта имеет значение <xref:System.Windows.ShutdownMode.OnMainWindowClose>, закрытие главного окна приведет к завершению работы приложения.  
  
 <xref:System.Windows.Application.MainWindow%2A> Свойство можно установить из [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)], если главное окно приложения не является окном, созданным путем задания <xref:System.Windows.Application.StartupUri%2A> свойства в [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]. Существуют два ограничения [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] этого подхода.  
  
-   В <xref:System.Windows.Navigation.NavigationWindow> качестве главного окна можно [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]указать только <xref:System.Windows.Window> или [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)].  
  
-   Необходимо задать <xref:System.Windows.UIElement.Visibility%2A> свойство указанного окна, в противном случае оно не будет показано.  
  
 Ссылка на первый <xref:System.Windows.Window> объект, для которого создается экземпляр, также добавляется в качестве первого элемента <xref:System.Windows.Application.Windows%2A> в коллекцию. Если <xref:System.Windows.Application.MainWindow%2A> в дальнейшем задается ссылка на другой <xref:System.Windows.Window>объект, то позиция элемента со ссылкой на главное окно изменится, а порядок элементов <xref:System.Windows.Application.Windows%2A> останется прежним. Следовательно, всегда используйте <xref:System.Windows.Application.MainWindow%2A> для ссылки на главное окно, а не на первый элемент в <xref:System.Windows.Application.Windows%2A>.  
  
> [!NOTE]
>  <xref:System.Windows.Navigation.NavigationWindow>Если главное окно —, и требуется специальный доступ к <xref:System.Windows.Navigation.NavigationWindow> элементам, необходимо присвоить значение <xref:System.Windows.Application.MainWindow%2A> <xref:System.Windows.Navigation.NavigationWindow>типу.  
>   
>  Это свойство доступно только из потока, в котором был создан <xref:System.Windows.Application> объект.  
  
   
  
## Examples  
 В следующем примере показано, как найти главное окно приложения.  
  
 [!code-csharp[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationMainWindowSnippets/CSharp/App.xaml.cs#getapplicationmainwindowcode)]
 [!code-vb[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationMainWindowSnippets/visualbasic/application.xaml.vb#getapplicationmainwindowcode)]  
  
 В следующем примере показано, как задать <xref:System.Windows.Application.MainWindow%2A> с [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]помощью.  
  
 [!code-xaml[ApplicationMainWindowSnippets#SetApplicationMainWindowXAML](~/samples/snippets/xaml/VS_Snippets_Wpf/ApplicationMainWindowSnippets/XAML/App.xaml#setapplicationmainwindowxaml)]  
  
 В следующем примере показано, <xref:System.Windows.Application.MainWindow%2A> как создать экземпляр в коде во время запуска приложения.  
  
 [!code-csharp[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/CSharp/App.xaml.cs#firstwindowusingcodecodebehind)]
 [!code-vb[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/visualbasic/application.xaml.vb#firstwindowusingcodecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Windows.Application.MainWindow" /> устанавливается из приложения, находящегося в браузере, например, [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)].</exception>
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Navigated">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatedEventHandler Navigated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatedEventHandler Navigated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Navigated" />
      <MemberSignature Language="VB.NET" Value="Public Event Navigated As NavigatedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatedEventHandler ^ Navigated;" />
      <MemberSignature Language="F#" Value="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " Usage="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда содержимое, к которому осуществляется переход, найдено, хотя его загрузка, возможно, еще не завершена.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Навигатор — <xref:System.Windows.Navigation.NavigationWindow> это либо <xref:System.Windows.Controls.Frame>или.  
  
 См. раздел <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="Navigating">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatingCancelEventHandler Navigating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatingCancelEventHandler Navigating" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Navigating" />
      <MemberSignature Language="VB.NET" Value="Public Event Navigating As NavigatingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatingCancelEventHandler ^ Navigating;" />
      <MemberSignature Language="F#" Value="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " Usage="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при запросе приложением перехода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Навигатор — <xref:System.Windows.Navigation.NavigationWindow> это либо <xref:System.Windows.Controls.Frame>или.  
  
 См. раздел <xref:System.Windows.Navigation.NavigationService.Navigating?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationFailed">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationFailed" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationFailed As NavigationFailedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationFailedEventHandler ^ NavigationFailed;" />
      <MemberSignature Language="F#" Value="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " Usage="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationFailedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда происходит ошибка при переходе к указанному содержимому.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Навигатор — <xref:System.Windows.Navigation.NavigationWindow> это либо <xref:System.Windows.Controls.Frame>или.  
  
 См. раздел <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationProgress">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationProgress" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationProgress As NavigationProgressEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationProgressEventHandler ^ NavigationProgress;" />
      <MemberSignature Language="F#" Value="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " Usage="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationProgressEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит время от времени во время загрузки, управляемой приложением для предоставления информации о статусе загрузки.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Навигатор — <xref:System.Windows.Navigation.NavigationWindow> это либо <xref:System.Windows.Controls.Frame>или.  
  
 См. раздел <xref:System.Windows.Navigation.NavigationService.NavigationProgress?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationStopped">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationStopped" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationStopped As NavigationStoppedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationStoppedEventHandler ^ NavigationStopped;" />
      <MemberSignature Language="F#" Value="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " Usage="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationStoppedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Появляется при вызове метода перехода приложения <see langword="StopLoading" />, или когда поступил запрос нового перехода во время выполнения текущего.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Навигатор — <xref:System.Windows.Navigation.NavigationWindow> это либо <xref:System.Windows.Controls.Frame>или.  
  
 См. раздел <xref:System.Windows.Navigation.NavigationService.NavigationStopped?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnActivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnActivated : EventArgs -&gt; unit&#xA;override this.OnActivated : EventArgs -&gt; unit" Usage="application.OnActivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Создает событие <see cref="E:System.Windows.Application.Activated" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Application.OnActivated%2A> формирует событие <xref:System.Windows.Application.Activated>.  
  
 Тип, производный от <xref:System.Windows.Application> , может переопределить. <xref:System.Windows.Application.OnActivated%2A> <xref:System.Windows.Application.OnActivated%2A> При <xref:System.Windows.Application.Activated>  необходимости переопределенный метод должен вызывать в базовом классе.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDeactivated">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDeactivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDeactivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDeactivated : EventArgs -&gt; unit&#xA;override this.OnDeactivated : EventArgs -&gt; unit" Usage="application.OnDeactivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Application.Deactivated" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Application.OnDeactivated%2A> формирует событие <xref:System.Windows.Application.Deactivated>.  
  
 Тип, производный от <xref:System.Windows.Application> , может переопределить. <xref:System.Windows.Application.OnDeactivated%2A> <xref:System.Windows.Application.OnDeactivated%2A> При <xref:System.Windows.Application.Deactivated>  необходимости переопределенный метод должен вызывать в базовом классе.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnActivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnExit">
      <MemberSignature Language="C#" Value="protected virtual void OnExit (System.Windows.ExitEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnExit(class System.Windows.ExitEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnExit (e As ExitEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnExit(System::Windows::ExitEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnExit : System.Windows.ExitEventArgs -&gt; unit&#xA;override this.OnExit : System.Windows.ExitEventArgs -&gt; unit" Usage="application.OnExit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.ExitEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.Windows.ExitEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Application.Exit" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Application.OnExit%2A> формирует событие <xref:System.Windows.Application.Exit>.  
  
 Тип, производный от <xref:System.Windows.Application> , может <xref:System.Windows.Application.OnExit%2A> переопределять метод. <xref:System.Windows.Application.OnExit%2A> При <xref:System.Windows.Application.Exit>  необходимости переопределенный метод должен вызывать в базовом классе.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnFragmentNavigation">
      <MemberSignature Language="C#" Value="protected virtual void OnFragmentNavigation (System.Windows.Navigation.FragmentNavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFragmentNavigation(class System.Windows.Navigation.FragmentNavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnFragmentNavigation (e As FragmentNavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnFragmentNavigation(System::Windows::Navigation::FragmentNavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnFragmentNavigation : System.Windows.Navigation.FragmentNavigationEventArgs -&gt; unit&#xA;override this.OnFragmentNavigation : System.Windows.Navigation.FragmentNavigationEventArgs -&gt; unit" Usage="application.OnFragmentNavigation e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.FragmentNavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Windows.Navigation.FragmentNavigationEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Application.FragmentNavigation" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Application.OnFragmentNavigation%2A> формирует событие <xref:System.Windows.Application.FragmentNavigation>.  
  
 Тип, производный от <xref:System.Windows.Application> , может переопределить. <xref:System.Windows.Application.OnFragmentNavigation%2A> <xref:System.Windows.Application.OnFragmentNavigation%2A> При <xref:System.Windows.Application.FragmentNavigation>  необходимости переопределенный метод должен вызывать в базовом классе.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnLoadCompleted">
      <MemberSignature Language="C#" Value="protected virtual void OnLoadCompleted (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoadCompleted(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLoadCompleted (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLoadCompleted(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoadCompleted : System.Windows.Navigation.NavigationEventArgs -&gt; unit&#xA;override this.OnLoadCompleted : System.Windows.Navigation.NavigationEventArgs -&gt; unit" Usage="application.OnLoadCompleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Windows.Navigation.NavigationEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Application.LoadCompleted" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Application.OnLoadCompleted%2A> формирует событие <xref:System.Windows.Application.LoadCompleted>.  
  
 Тип, производный от <xref:System.Windows.Application> , может переопределить. <xref:System.Windows.Application.OnLoadCompleted%2A> <xref:System.Windows.Application.OnLoadCompleted%2A> При <xref:System.Windows.Application.LoadCompleted>  необходимости переопределенный метод должен вызывать в базовом классе.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigated">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigated (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigated(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigated (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigated(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigated : System.Windows.Navigation.NavigationEventArgs -&gt; unit&#xA;override this.OnNavigated : System.Windows.Navigation.NavigationEventArgs -&gt; unit" Usage="application.OnNavigated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Windows.Navigation.NavigationEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Application.Navigated" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Application.OnNavigated%2A> формирует событие <xref:System.Windows.Application.Navigated>.  
  
 Тип, производный от <xref:System.Windows.Application> , может переопределить. <xref:System.Windows.Application.OnNavigated%2A> <xref:System.Windows.Application.OnNavigated%2A> При <xref:System.Windows.Application.Navigated>  необходимости переопределенный метод должен вызывать в базовом классе.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigating">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigating (System.Windows.Navigation.NavigatingCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigating(class System.Windows.Navigation.NavigatingCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigating (e As NavigatingCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigating(System::Windows::Navigation::NavigatingCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigating : System.Windows.Navigation.NavigatingCancelEventArgs -&gt; unit&#xA;override this.OnNavigating : System.Windows.Navigation.NavigatingCancelEventArgs -&gt; unit" Usage="application.OnNavigating e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigatingCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Windows.Navigation.NavigatingCancelEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Application.Navigating" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Application.OnNavigating%2A> формирует событие <xref:System.Windows.Application.Navigating>.  
  
 Тип, производный от <xref:System.Windows.Application> , может переопределить. <xref:System.Windows.Application.OnNavigating%2A> <xref:System.Windows.Application.OnNavigating%2A> При <xref:System.Windows.Application.Navigating>  необходимости переопределенный метод должен вызывать в базовом классе.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigationFailed">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationFailed (System.Windows.Navigation.NavigationFailedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationFailed(class System.Windows.Navigation.NavigationFailedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationFailed (e As NavigationFailedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationFailed(System::Windows::Navigation::NavigationFailedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigationFailed : System.Windows.Navigation.NavigationFailedEventArgs -&gt; unit&#xA;override this.OnNavigationFailed : System.Windows.Navigation.NavigationFailedEventArgs -&gt; unit" Usage="application.OnNavigationFailed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationFailedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Windows.Navigation.NavigationFailedEventArgs" />, содержащий данные события.</param>
        <summary>Создает событие <see cref="E:System.Windows.Application.NavigationFailed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Application.OnNavigationFailed%2A> формирует событие <xref:System.Windows.Application.NavigationFailed>.  
  
 Тип, производный от <xref:System.Windows.Application> , может переопределить. <xref:System.Windows.Application.OnNavigationFailed%2A> <xref:System.Windows.Application.OnNavigationFailed%2A> При <xref:System.Windows.Application.NavigationFailed>  необходимости переопределенный метод должен вызывать в базовом классе.  
  
   
  
## Examples  
 <xref:System.Windows.Application.OnFragmentNavigation%2A>  
  
 <xref:System.Windows.Application.OnLoadCompleted%2A>  
  
 <xref:System.Windows.Application.OnNavigating%2A>  
  
 <xref:System.Windows.Application.OnNavigated%2A>  
  
 <xref:System.Windows.Application.OnNavigationProgress%2A>  
  
 <xref:System.Windows.Application.OnNavigationStopped%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnNavigationProgress">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationProgress (System.Windows.Navigation.NavigationProgressEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationProgress(class System.Windows.Navigation.NavigationProgressEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationProgress (e As NavigationProgressEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationProgress(System::Windows::Navigation::NavigationProgressEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigationProgress : System.Windows.Navigation.NavigationProgressEventArgs -&gt; unit&#xA;override this.OnNavigationProgress : System.Windows.Navigation.NavigationProgressEventArgs -&gt; unit" Usage="application.OnNavigationProgress e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationProgressEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Windows.Navigation.NavigationProgressEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Application.NavigationProgress" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Application.OnNavigationProgress%2A> формирует событие <xref:System.Windows.Application.NavigationProgress>.  
  
 Тип, производный от <xref:System.Windows.Application> , может переопределить. <xref:System.Windows.Application.OnNavigationProgress%2A> Переопределенный метод должен явным образом вызывать <xref:System.Windows.Application.OnNavigationProgress%2A> в базовом классе, <xref:System.Windows.Application.NavigationProgress> если необходимо.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigationStopped">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationStopped (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationStopped(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationStopped (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationStopped(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigationStopped : System.Windows.Navigation.NavigationEventArgs -&gt; unit&#xA;override this.OnNavigationStopped : System.Windows.Navigation.NavigationEventArgs -&gt; unit" Usage="application.OnNavigationStopped e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Windows.Navigation.NavigationEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Application.NavigationStopped" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Application.OnNavigationStopped%2A> формирует событие <xref:System.Windows.Application.NavigationStopped>.  
  
 Тип, производный от <xref:System.Windows.Application> , может переопределить. <xref:System.Windows.Application.OnNavigationStopped%2A> <xref:System.Windows.Application.OnNavigationStopped%2A> При <xref:System.Windows.Application.NavigationStopped>  необходимости переопределенный метод должен вызывать в базовом классе.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSessionEnding">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionEnding (System.Windows.SessionEndingCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionEnding(class System.Windows.SessionEndingCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionEnding (e As SessionEndingCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionEnding(System::Windows::SessionEndingCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSessionEnding : System.Windows.SessionEndingCancelEventArgs -&gt; unit&#xA;override this.OnSessionEnding : System.Windows.SessionEndingCancelEventArgs -&gt; unit" Usage="application.OnSessionEnding e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.SessionEndingCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Windows.SessionEndingCancelEventArgs" />, содержащий данные события.</param>
        <summary>Создает событие <see cref="E:System.Windows.Application.SessionEnding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Application.OnSessionEnding%2A> формирует событие <xref:System.Windows.Application.SessionEnding>.  
  
 Тип, производный от <xref:System.Windows.Application> , может переопределить. <xref:System.Windows.Application.OnSessionEnding%2A> <xref:System.Windows.Application.OnSessionEnding%2A> При <xref:System.Windows.Application.SessionEnding>  необходимости переопределенный метод должен вызывать в базовом классе.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStartup">
      <MemberSignature Language="C#" Value="protected virtual void OnStartup (System.Windows.StartupEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStartup(class System.Windows.StartupEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStartup (e As StartupEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStartup(System::Windows::StartupEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStartup : System.Windows.StartupEventArgs -&gt; unit&#xA;override this.OnStartup : System.Windows.StartupEventArgs -&gt; unit" Usage="application.OnStartup e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.StartupEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Windows.StartupEventArgs" />, содержащий данные события.</param>
        <summary>Создает событие <see cref="E:System.Windows.Application.Startup" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Application.OnStartup%2A> формирует событие <xref:System.Windows.Application.Startup>.  
  
 Тип, производный от <xref:System.Windows.Application> , может переопределить. <xref:System.Windows.Application.OnStartup%2A> Переопределенный метод должен вызывать <xref:System.Windows.Application.OnStartup%2A> в базовом классе, <xref:System.Windows.Application.Startup> если должно быть вызвано событие.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Properties">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Properties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Properties" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Properties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Properties As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IDictionary ^ Properties { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Properties : System.Collections.IDictionary" Usage="System.Windows.Application.Properties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает коллекцию свойств области приложения.</summary>
        <value><see cref="T:System.Collections.IDictionary" />, который содержит свойства области приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application>предоставляет словарь <xref:System.Windows.Application.Properties%2A> , с помощью которого можно хранить свойства области приложения. Это позволяет предоставлять общий доступ к состоянию всего кода <xref:System.AppDomain> в потокобезопасным способом, не требуя написания собственного кода состояния.  
  
 Свойства, хранящиеся в <xref:System.Windows.Application.Properties%2A> , должны быть преобразованы в соответствующий возвращаемый тип.  
  
 <xref:System.Windows.Application.Properties%2A> Свойство является потокобезопасным и доступно из любого потока.  
  
   
  
## Examples  
 В следующем примере показано, как создать и использовать свойство области приложения с помощью <xref:System.Windows.Application.Properties%2A>.  
  
 [!code-xaml[ApplicationPropertiesSnippets#HandleStartupXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/App.xaml#handlestartupxaml)]  
  
 [!code-csharp[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/App.xaml.cs#handlestartupcodebehind)]
 [!code-vb[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationPropertiesSnippets/visualbasic/application.xaml.vb#handlestartupcodebehind)]  
  
 [!code-xaml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml#mainwindowgetpropertyxaml1)]  
[!code-xaml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml#mainwindowgetpropertyxaml2)]  
  
 [!code-csharp[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml.cs#mainwindowgetpropertycodebehind)]
 [!code-vb[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationPropertiesSnippets/visualbasic/mainwindow.xaml.vb#mainwindowgetpropertycodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Startup" />
      </Docs>
    </Member>
    <Member MemberName="ResourceAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ResourceAssembly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Assembly ResourceAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.ResourceAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ResourceAssembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Assembly ^ ResourceAssembly { System::Reflection::Assembly ^ get(); void set(System::Reflection::Assembly ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ResourceAssembly : System.Reflection.Assembly with get, set" Usage="System.Windows.Application.ResourceAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает <see cref="T:System.Reflection.Assembly" />, обеспечивающий набор [!INCLUDE[TLA#tla_uri#plural](~/includes/tlasharptla-urisharpplural-md.md)] для ресурсов приложения [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)].</summary>
        <value>Ссылка на <see cref="T:System.Reflection.Assembly" />, обеспечивающий набор [!INCLUDE[TLA#tla_uri#plural](~/includes/tlasharptla-urisharpplural-md.md)] для ресурсов приложения [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)].</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] ресурсы разрешаются во время выполнения по отношению к сборке записи, которая определяется значением, возвращенным <xref:System.Reflection.Assembly.GetEntryAssembly%2A> методом.  
  
 Входная сборка — это сборка, возвращаемая функцией <xref:System.Reflection.Assembly.GetEntryAssembly%2A> и может быть следующей:  
  
-   Исполняемая сборка в домене приложения по умолчанию.  
  
-   Первая сборка, которая будет выполнена путем вызова <xref:System.AppDomain.ExecuteAssembly%2A>.  
  
 Однако в следующих случаях [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] сборка не может получить ссылку на сборку записи:  
  
-   Сборка размещается в [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] неуправляемом (собственном) приложении.  
  
-   Управляемое приложение размещает [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] сборку, загружая ее в новый домен приложения, используя метод, отличный <xref:System.AppDomain.ExecuteAssembly%2A>от.  
  
 В обоих случаях <xref:System.Reflection.Assembly.GetEntryAssembly%2A> возвращает `null`, и [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] ресурсы сборки не могут быть разрешены. В таких случаях <xref:System.Windows.Application.ResourceAssembly%2A> можно задать только один раз со ссылкой на сборку, которая будет использоваться для разрешения ресурсов.  
  
 <xref:System.Windows.Application.ResourceAssembly%2A>может быть задан только один раз, так как маловероятно, что сборка ресурсов изменится после [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] загрузки сборки.  
  
> [!NOTE]
>  <xref:System.Windows.Application.ResourceAssembly%2A>не может быть задан, [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] если сборка может обнаружить входную сборку, то есть при <xref:System.Reflection.Assembly.GetEntryAssembly%2A> возврате ссылки `null`на сборку, а не на.  
  
 Это свойство является потокобезопасным и доступно из любого потока.  
  
 <xref:System.Windows.Application.ResourceAssembly%2A>вводится в .NET Framework версии 3,5.  Дополнительные сведения см. в статье [Версии и зависимости платформы .NET Framework](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Приложение [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] имеет ассемблированную запись или <see cref="P:System.Windows.Application.ResourceAssembly" /> уже присвоено значение.</exception>
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.Application.Resources" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Markup.IHaveResources.Resources</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает коллекцию ресурсов области приложения, например, стилей и кистей.</summary>
        <value>Объект <see cref="T:System.Windows.ResourceDictionary" />, содержащий ноль или более ресурсов области приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.Resources%2A> Свойство можно использовать для совместного использования ресурсов в окнах и элементах приложения. Кроме того, <xref:System.Windows.Application.Resources%2A> свойство включается в путь поиска ресурса, который проходит в следующем порядке:  
  
1.  Элементы  
  
2.  Windows  
  
3.  <xref:System.Windows.Application.Resources%2A?displayProperty=nameWithType>  
  
4.  Система  
  
 Следовательно, [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] элементы могут быть привязаны к ресурсам области приложения. Кроме того, если ресурсы изменяются, система ресурсов гарантирует, что свойства элементов, привязанные к этим ресурсам, будут автоматически обновлены в соответствии с изменениями.  
  
 Ресурсы области приложения обеспечивают простой способ поддержки согласованной темы в приложении. Можно легко создать тему в [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] с `Application.Resources` помощью тега. Тем не менее, если приложение поддерживает несколько тем, которые могут содержать большое количество элементов темы, может быть проще управлять ими с помощью одного <xref:System.Windows.ResourceDictionary> экземпляра для каждой темы. Таким образом можно применить новую тему, задав для свойства Resources соответствующее <xref:System.Windows.ResourceDictionary>значение.  
  
 При использовании <xref:System.Windows.Application.Resources%2A>следует учитывать два аспекта. Во-первых, *ключ* словаря является объектом, поэтому необходимо использовать один и тот же экземпляр объекта при установке и получении значения свойства (Обратите внимание, что при использовании строки в ключе учитывается регистр). Во-вторых, *значение* словаря является объектом, поэтому необходимо преобразовать значение в нужный тип при получении значения свойства.  
  
 <xref:System.Windows.Application.Resources%2A>является потокобезопасным и доступна из любого потока.  
  
   
  
## Examples  
В этом примере показано, как использовать XAML вместе с ресурсами области приложения для создания единообразного визуального представления. Первый пример — из *app. XAML*; второй — из *MainWindow. XAML*. 
  
[!code-xaml[ApplicationResourcesSnippets#ResourcesPropertyXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/App.xaml#resourcespropertyxaml)]  
  
[!code-xaml[ApplicationResourcesSnippets#WindowBackgroundPropertyXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/MainWindow.xaml?highlight=7)]  
  
 В следующем примере показано, как задать ресурс приложения в коде и XAML (в файле App. XAML в проекте C# WPF или в файле Application. xaml в Visual Basic проекте WPF).  
  
 [!code-csharp[Setting-an-application-resource-in-code](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/ApplicationPropertiesSnippet.xaml.cs#setapplicationscoperesourcecode)]
 [!code-vb[Setting-an-application-resource-in-code](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/visualbasic/applicationpropertiessnippet.xaml.vb#setapplicationscoperesourcecode)]  
  
 [!code-xaml[Setting-an-application-resource-in-XAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/App.xaml?highlight=8-10)]  
  
 В следующем примере показано, как получить ресурс приложения в коде.  
  
 [!code-csharp[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/ApplicationPropertiesSnippet.xaml.cs#getapplicationscoperesourcecode)]
 [!code-vb[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/visualbasic/applicationpropertiessnippet.xaml.vb#getapplicationscoperesourcecode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Запускает приложение Windows Presentation Foundation.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public int Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Run" />
      <MemberSignature Language="VB.NET" Value="Public Function Run () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Run();" />
      <MemberSignature Language="F#" Value="member this.Run : unit -&gt; int" Usage="application.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Запускает приложение Windows Presentation Foundation.</summary>
        <returns>Код выхода <see cref="T:System.Int32" />, возвращаемый приложением в операционную систему при завершении работы приложения. По умолчанию, код выхода равен 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.Run%2A>вызывается для запуска [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] приложения. При определении <xref:System.Windows.Application> с помощью разметки или разметки и кода <xref:System.Windows.Application.Run%2A> программной части будет вызываться неявно. Однако при определении <xref:System.Windows.Application> с помощью кода необходимо явно вызвать метод <xref:System.Windows.Application.Run%2A>.  
  
 При <xref:System.Windows.Application.Run%2A> <xref:System.Windows.Threading.Dispatcher> вызове метода присоединяет новый экземпляр к потоку пользовательского интерфейса. <xref:System.Windows.Application> Затем вызывается <xref:System.Windows.Threading.Dispatcher.Run%2A> метод объекта, который запускает конвейер сообщений для обработки сообщений Windows. <xref:System.Windows.Threading.Dispatcher> Наконец, <xref:System.Windows.Threading.Dispatcher> объект <xref:System.Windows.Application> вызывает <xref:System.Windows.Application.OnStartup%2A> метод объекта для вызова <xref:System.Windows.Application.Startup> события. Следовательно, модель выполнения приложения была установлена на время обработки <xref:System.Windows.Application.Startup>, после чего приложение считается запущенным.  
  
 Приложение прекращает выполнение при <xref:System.Windows.Application.Shutdown%2A> вызове; значение <xref:System.Windows.Application.ShutdownMode%2A> свойства определяет, когда <xref:System.Windows.Application.Shutdown%2A> вызывается, и происходит ли его автоматическое или необходимо явно вызывать.  
  
 <xref:System.Windows.Application.Run%2A>может вызываться только из потока, который создает <xref:System.Windows.Application> объект. Кроме того <xref:System.Windows.Application.Run%2A> , нельзя вызывать [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)]из.  
  
   
  
## Examples  
 В следующем примере показано приложение, которое использует пользовательский <xref:System.Windows.Application> объект и поэтому должен явно вызывать метод. <xref:System.Windows.Application.Run%2A>  
  
 [!code-csharp[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationRunSnippets/CSharp/App.cs#customentrypointandruncode)]
 [!code-vb[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationRunSnippets/visualbasic/app.vb#customentrypointandruncode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Windows.Application.Run" /> вызывается из приложения-владельца браузера (например, [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]).</exception>
        <altmember cref="M:System.Windows.Application.Run(System.Windows.Window)" />
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public int Run (System.Windows.Window window);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Run(class System.Windows.Window window) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Run(System.Windows.Window)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Run(System::Windows::Window ^ window);" />
      <MemberSignature Language="F#" Value="member this.Run : System.Windows.Window -&gt; int" Usage="application.Run window" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="window" Type="System.Windows.Window" />
      </Parameters>
      <Docs>
        <param name="window"><see cref="T:System.Windows.Window" />, открывающееся автоматически при запуске приложения.</param>
        <summary>Запускает приложение Windows Presentation Foundation с открытием указанного окна.</summary>
        <returns>Код выхода <see cref="T:System.Int32" />, возвращаемый приложением в операционную систему при завершении работы приложения. По умолчанию, код выхода равен 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка расширяет <xref:System.Windows.Application.Run%2A> метод, чтобы открыть указанное окно после запуска приложения.  
  
 Если вы определяете код <xref:System.Windows.Application> , который открывает окно при запуске, вы явно вызываете метод <xref:System.Windows.Application.Run%2A>.  
  
 При создании <xref:System.Windows.Application> с помощью разметки или разметки и кода программной части окно можно автоматически открыть при помощи любого из следующих методов:  
  
-   Декларативно, с помощью <xref:System.Windows.Application.StartupUri%2A>параметра.  
  
-   Программно, путем <xref:System.Windows.Application.Startup>обработки.  
  
   
  
## Examples  
 В следующем примере показано приложение с созданным вручную статическим методом точки входа, который создает экземпляр <xref:System.Windows.Application>перед вызовом <xref:System.Windows.Application.Run%2A>метода.  
  
 [!code-csharp[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationRunOL1Snippets/CSharp/App.cs#customentrypointandrunol1code)]
 [!code-vb[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationRunOL1Snippets/visualbasic/app.vb#customentrypointandrunol1code)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Windows.Application.Run" /> вызывается из приложения-владельца браузера (например, [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]).</exception>
        <altmember cref="M:System.Windows.Application.Shutdown" />
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SessionEnding">
      <MemberSignature Language="C#" Value="public event System.Windows.SessionEndingCancelEventHandler SessionEnding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.SessionEndingCancelEventHandler SessionEnding" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.SessionEnding" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SessionEnding As SessionEndingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::SessionEndingCancelEventHandler ^ SessionEnding;" />
      <MemberSignature Language="F#" Value="member this.SessionEnding : System.Windows.SessionEndingCancelEventHandler " Usage="member this.SessionEnding : System.Windows.SessionEndingCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SessionEndingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь завершает сеанс Windows, выходя из системы или завершая работу операционной системы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию приложение завершает работу при завершении сеанса Windows, что происходит, когда пользователь выходит из системы или завершает работу. В этом случае Windows запрашивает завершение работы каждого открытого приложения. Однако возможно, что приложение может быть не готово к завершению работы, когда это происходит. Например, приложение может иметь данные, которые находятся в нестабильном состоянии или в ходе длительной операции. В таких ситуациях может быть желательно предотвратить завершение сеанса, и может быть более желательным, чтобы позволить пользователям выбрать, следует ли разрешить завершение сеанса.  
  
 Определить, когда сеанс завершается, можно, обрабатывая <xref:System.Windows.Application.SessionEnding> событие. Если приложению требуется предотвратить <xref:System.Windows.SessionEndingCancelEventArgs> завершение сеанса, аргумент, передаваемый обработчику событий, предоставляет объект <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> , для `true` которого задано значение (по умолчанию — `false`).  
  
 Если <xref:System.Windows.Application.SessionEnding> параметр не обработан или обрабатывается без отмены, <xref:System.Windows.Application.Shutdown%2A> вызывается метод и <xref:System.Windows.Application.Exit> возникает событие.  
  
 Чтобы получить дополнительные сведения о том, почему сеанс завершается, приложение может проверить <xref:System.Windows.SessionEndingCancelEventArgs.ReasonSessionEnding%2A>, какое значение имеет одно <xref:System.Windows.ReasonSessionEnding> из значений (<xref:System.Windows.ReasonSessionEnding.Logoff?displayProperty=nameWithType> и <xref:System.Windows.ReasonSessionEnding.Shutdown?displayProperty=nameWithType>).  
  
 <xref:System.Windows.Application.SessionEnding>не вызывается консольными приложениями.  
  
 <xref:System.Windows.Application.SessionEnding>вызывается только в потоке, который создает <xref:System.Windows.Application> объект.  
  
 <xref:System.Windows.Application.SessionEnding>не вызывается для приложений браузера XAML (XBAP).  
  
   
  
## Examples  
 В следующем примере показано, как выполнить обработку <xref:System.Windows.Application.SessionEnding> события и позволить пользователю отменить его.  
  
 [!code-xaml[ApplicationSessionEndingSnippets#HandlingSessionEndingXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/CSharp/App.xaml#handlingsessionendingxaml)]  
  
 [!code-csharp[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/CSharp/App.xaml.cs#handlingsessionendingcodebehind)]
 [!code-vb[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/visualbasic/application.xaml.vb#handlingsessionendingcodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
        <altmember cref="E:System.Windows.Application.Startup" />
      </Docs>
    </Member>
    <Member MemberName="SetCookie">
      <MemberSignature Language="C#" Value="public static void SetCookie (Uri uri, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCookie(class System.Uri uri, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCookie(Uri ^ uri, System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member SetCookie : Uri * string -&gt; unit" Usage="System.Windows.Application.SetCookie (uri, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uri"><see cref="T:System.Uri" />, определяющий положение, для которого следует создать файл cookie.</param>
        <param name="value"><see cref="T:System.String" />, содержащий данные о файле cookie.</param>
        <summary>Создает файл cookie для расположения, указанного <see cref="T:System.Uri" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Файл cookie — это произвольная часть данных, которая может храниться в приложении на клиентском компьютере во время сеансов приложения (файлы cookie сеансов) или в сеансах приложения (постоянные файлы cookie). Можно создать оба типа файлов cookie, вызвав <xref:System.Windows.Application.SetCookie%2A>.  
  
 Данные файлов cookie обычно принимают форму пары "имя-значение" в следующем формате:  
  
 `Name=Value`  
  
 Вы передаете строку этого формата <xref:System.Windows.Application.SetCookie%2A>вместе <xref:System.Uri> с расположением, для которого должен быть задан файл cookie (обычно это домен приложения).  
  
 Является ли файл cookie файлом cookie сеанса или сохраняемым файлом cookie, зависит от того, <xref:System.Windows.Application.SetCookie%2A> содержит ли строка файла cookie, которую вы передаете, дату окончания срока действия. Строка для файла cookie сеанса не содержит дату окончания срока действия. Строка для постоянного файла cookie имеет значение и должно иметь следующий формат:  
  
 `NAME=VALUE; expires=DAY, DD-MMM-YYYY HH:MM:SS GMT`  
  
 Постоянные файлы cookie хранятся в папке Temporary [!INCLUDE[TLA#tla_mswin](~/includes/tlasharptla-mswin-md.md)] Internet Files текущей установки до истечения срока действия, в этом случае они удаляются. Вы можете удалить постоянный файл cookie из приложения, указав для его даты окончания срока действия значение даты и времени в прошлом.  
  
 Общие сведения о файлах cookie в [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]см. в разделе [Общие сведения о навигации](~/docs/framework/wpf/app-development/navigation-overview.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Если при попытке создать указанный файл cookie возникла проблема, функция <see langword="InternetSetCookie" /> (вызванная <see cref="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />) генерирует ошибку [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)].</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для получения файла cookie для файлов <see cref="T:System.Uri" />. Связанное перечисление:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">для получения файла cookie для не основанного на <see cref="T:System.Uri" />файлах. Связанное перечисление:<see cref="F:System.Net.NetworkAccess.Connect" /></permission>
        <altmember cref="M:System.Windows.Application.GetCookie(System.Uri)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Shutdown">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Завершить работу приложения.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Shutdown" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown();" />
      <MemberSignature Language="F#" Value="member this.Shutdown : unit -&gt; unit" Usage="application.Shutdown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Завершить работу приложения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При <xref:System.Windows.Application.Shutdown%2A> вызове приложение прекращает работу. Можно обработать <xref:System.Windows.Application.Exit> событие, чтобы определить, когда приложение собирается запуститься, чтобы выполнить необходимую обработку.  
  
 <xref:System.Windows.Application.Shutdown%2A>метод неявно вызывается Windows Presentation Foundation в следующих ситуациях:  
  
-   Если <xref:System.Windows.Application.ShutdownMode%2A> параметр имеет <xref:System.Windows.ShutdownMode.OnLastWindowClose>значение.  
  
-   Если параметр <xref:System.Windows.ShutdownMode.OnMainWindowClose>имеет значение. <xref:System.Windows.Application.ShutdownMode%2A>  
  
-   Когда пользователь завершает сеанс <xref:System.Windows.Application.SessionEnding> , событие либо необработанное, либо обрабатывается без отмены.  
  
 Вызов <xref:System.Windows.Application.Shutdown%2A> явным образом приводит к завершению работы приложения независимо <xref:System.Windows.Application.ShutdownMode%2A> от параметра. Однако если <xref:System.Windows.Application.ShutdownMode%2A> параметр имеет <xref:System.Windows.ShutdownMode.OnExplicitShutdown>значение, необходимо вызвать <xref:System.Windows.Application.Shutdown%2A> , чтобы завершить работу приложения.  
  
> [!IMPORTANT]
>  Когда <xref:System.Windows.Application.Shutdown%2A> вызывается метод, работа приложения будет завершена независимо от <xref:System.Windows.Window.Closing> того, отменено ли событие любого открытого окна.  
  
 Этот метод может быть вызван только из потока, в котором был <xref:System.Windows.Application> создан объект.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">разрешение на использование всех окон и событий ввода данных пользователем без ограничений. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.SessionEnding" />
        <altmember cref="M:System.Windows.Application.Run" />
        <altmember cref="M:System.Windows.Application.Run(System.Windows.Window)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (int exitCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(int32 exitCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Shutdown(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (exitCode As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(int exitCode);" />
      <MemberSignature Language="F#" Value="member this.Shutdown : int -&gt; unit" Usage="application.Shutdown exitCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exitCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="exitCode">Целочисленный код завершения для приложения. По умолчанию, код выхода равен 0.</param>
        <summary>Завершает работу приложения и передает указанный код завершения операционной системой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно выполнить обработку <xref:System.Windows.Application.Exit> события, чтобы задать код выхода. Однако если явно вызвать метод <xref:System.Windows.Application.Shutdown%2A>и вы обрабатываете <xref:System.Windows.Application.Exit> только Задание кода выхода, можно вызвать <xref:System.Windows.Application.Shutdown%2A> вместо него.  
  
 Этот метод может быть вызван только из потока, в котором был <xref:System.Windows.Application> создан объект.  
  
 Дополнительные <xref:System.Environment.ExitCode%2A?displayProperty=nameWithType> сведения о кодах завершения см. в разделе.
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">разрешение на использование всех окон и событий ввода данных пользователем без ограничений. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="Overload:System.Windows.Application.Run" />
      </Docs>
    </Member>
    <Member MemberName="ShutdownMode">
      <MemberSignature Language="C#" Value="public System.Windows.ShutdownMode ShutdownMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.ShutdownMode ShutdownMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.ShutdownMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ShutdownMode As ShutdownMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ShutdownMode ShutdownMode { System::Windows::ShutdownMode get(); void set(System::Windows::ShutdownMode value); };" />
      <MemberSignature Language="F#" Value="member this.ShutdownMode : System.Windows.ShutdownMode with get, set" Usage="System.Windows.Application.ShutdownMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ShutdownMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает условие, которое является причиной вызова метода <see cref="M:System.Windows.Application.Shutdown" />.</summary>
        <value>Значение перечисления <see cref="T:System.Windows.ShutdownMode" />. Значение по умолчанию — <see cref="F:System.Windows.ShutdownMode.OnLastWindowClose" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Приложения перестают выполняться, <xref:System.Windows.Application.Shutdown%2A> только когда вызывается метод приложения. Завершение работы может происходить неявно или явно, как указано в значении <xref:System.Windows.Application.ShutdownMode%2A> свойства.  
  
 Если задано <xref:System.Windows.Application.ShutdownMode%2A> значение <xref:System.Windows.ShutdownMode.OnLastWindowClose>, Windows Presentation Foundation (WPF) неявным <xref:System.Windows.Application.Shutdown%2A> образом вызывается при закрытии последнего окна в приложении, даже если все экземпляры окна в данный момент установлены в качестве главного окна <xref:System.Windows.Application.MainWindow%2A>(см.).  
  
 Вызывает неявное вызов <xref:System.Windows.Application.Shutdown%2A> WPF при закрытии, даже если другие окна открыты в данный момент. <xref:System.Windows.Application.MainWindow%2A>  <xref:System.Windows.Application.ShutdownMode%2A> <xref:System.Windows.ShutdownMode.OnMainWindowClose>  
  
 Время существования некоторых приложений может не зависеть от того, когда главное окно или Последнее окно закрываются или вообще не зависят от Windows. Для этих сценариев необходимо задать <xref:System.Windows.Application.ShutdownMode%2A> для <xref:System.Windows.ShutdownMode.OnExplicitShutdown>свойства значение, которое требует явного <xref:System.Windows.Application.Shutdown%2A> вызова метода для того, чтобы приложение было приостановлено. В противном случае приложение продолжит выполнение в фоновом режиме.  
  
 <xref:System.Windows.Application.ShutdownMode%2A>можно настроить декларативно из [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] кода или программным способом.  
  
 Это свойство доступно только из потока, в котором был создан <xref:System.Windows.Application> объект.  
  
   
  
## Examples  
 В следующем примере показано, как настроить <xref:System.Windows.Application.ShutdownMode%2A> , чтобы указать, что приложение должно быть закрыто явным образом.  
  
 [!code-xaml[ApplicationShutdownModeSnippets#SetShutdownModeXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationShutdownModeSnippets/CS/App.xaml#setshutdownmodexaml)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Startup">
      <MemberSignature Language="C#" Value="public event System.Windows.StartupEventHandler Startup;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.StartupEventHandler Startup" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Startup" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Startup As StartupEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::StartupEventHandler ^ Startup;" />
      <MemberSignature Language="F#" Value="member this.Startup : System.Windows.StartupEventHandler " Usage="member this.Startup : System.Windows.StartupEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.StartupEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при вызове метода <see cref="M:System.Windows.Application.Run" /> объекта <see cref="T:System.Windows.Application" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Типичное Windows Presentation Foundation приложение может выполнять разнообразные задачи инициализации при запуске, в том числе:  
  
-   Обработка параметров командной строки.  
  
-   Открытие главного окна.  
  
-   Инициализация ресурсов области приложения.  
  
-   Инициализация свойств области приложения.  
  
 Можно декларативно указать основное окно и ресурсы области приложения с помощью [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] (<xref:System.Windows.Application.StartupUri%2A> и <xref:System.Windows.Application.Resources%2A>соответственно). Однако иногда ресурсы или главное окно приложения можно определить только программно во время выполнения. Кроме того, свойства области приложения и параметры командной строки можно использовать только программно. Программную инициализацию можно выполнить, обрабатывая <xref:System.Windows.Application.Startup> событие, включая следующие:  
  
-   Получение и обработка параметров командной строки, доступных из <xref:System.Windows.StartupEventArgs.Args%2A> свойства <xref:System.Windows.StartupEventArgs> класса <xref:System.Windows.Application.Startup> , который передается в обработчик событий.  
  
-   Инициализируйте ресурсы области приложения с помощью <xref:System.Windows.Application.Resources%2A> свойства.  
  
-   Инициализируйте свойства области приложения с помощью <xref:System.Windows.Application.Properties%2A> свойства.  
  
-   Создание экземпляра и отображение одного (или нескольких) окон.  
  
> [!NOTE]
>  Параметры командной строки также можно получить, вызвав статический <xref:System.Environment.GetCommandLineArgs%2A> метод <xref:System.Environment> объекта. Однако для выполнения требуется полное доверие. <xref:System.Environment.GetCommandLineArgs%2A>  
  
 Если <xref:System.Windows.Application.StartupUri%2A> задать параметр using [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)], то главное окно, которое создается, <xref:System.Windows.Application.MainWindow%2A> не будет доступно <xref:System.Windows.Application.Windows%2A> ни в свойстве, ни в свойстве <xref:System.Windows.Application> объекта, пока <xref:System.Windows.Application.Startup> не будет обработано событие. Если во время запуска требуется доступ к главному окну, необходимо вручную создать новый объект Window из <xref:System.Windows.Application.Startup> обработчика событий.  
  
> [!NOTE]
>  Если приложение <xref:System.Net.AuthenticationManager.CredentialPolicy%2A> использует для указания политики учетных данных, необходимо задать <xref:System.Windows.Application.Startup> <xref:System.Net.AuthenticationManager.CredentialPolicy%2A> параметр After. в противном [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] случае присваивает его внутренней политике по умолчанию непосредственно после <xref:System.Windows.Application.Startup> возникновения события.  
  
 Аргументы командной строки, передаваемые <xref:System.Windows.Application.Startup> в обработчик событий, не совпадают [!INCLUDE[TLA#tla_url](~/includes/tlasharptla-url-md.md)] с параметрами строки запроса [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)], передаваемыми в.  
  
   
  
## Examples  
 В следующем примере показано, как получить и обработать параметры командной строки из автономного приложения. Если указан параметр командной строки **/StartMinimized** , приложение открывает главное окно в режиме с минимальным состоянием.  
  
 [!code-xaml[ApplicationStartupSnippets#HandleStartupXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationStartupSnippets/CSharp/App.xaml#handlestartupxaml)]  
  
 [!code-csharp[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationStartupSnippets/CSharp/App.xaml.cs#handlestartupcodebehind)]
 [!code-vb[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationStartupSnippets/visualbasic/application.xaml.vb#handlestartupcodebehind)]  
  
 [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)]не удается получить и обработать аргументы командной строки, так как они запускаются с [!INCLUDE[TLA#tla_clickonce](~/includes/tlasharptla-clickonce-md.md)] развертыванием (см. раздел [развертывание WPF-приложения (WPF)](~/docs/framework/wpf/app-development/deploying-a-wpf-application-wpf.md)). Однако они могут извлекать и обрабатывать строковые параметры запроса из URL-адресов, которые используются для их запуска.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="StartupUri">
      <MemberSignature Language="C#" Value="public Uri StartupUri { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri StartupUri" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.StartupUri" />
      <MemberSignature Language="VB.NET" Value="Public Property StartupUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ StartupUri { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StartupUri : Uri with get, set" Usage="System.Windows.Application.StartupUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает пользовательский интерфейс, отображающееся автоматически при запуске приложения.</summary>
        <value>Объект <see cref="T:System.Uri" /> , который ссылается на пользовательский интерфейс, который автоматически открывается при запуске приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно использовать <xref:System.Windows.Application.StartupUri%2A> для автоматической загрузки ресурса пользовательского интерфейса при запуске приложения.  
  
 В следующей таблице показаны типы ресурсов пользовательского интерфейса, которые могут быть загружены, тип окна, в котором они открыты, и тип приложения, в котором эти ресурсы могут быть установлены в <xref:System.Windows.Application.StartupUri%2A>качестве.  
  
|Тип|Окно|Тип приложения|  
|----------|------------|----------------------|  
|<xref:System.Windows.Window>|<xref:System.Windows.Window>|Только автономный|  
|<xref:System.Windows.Navigation.NavigationWindow>|<xref:System.Windows.Navigation.NavigationWindow>|Только автономный|  
|<xref:System.Windows.Controls.Page>|<xref:System.Windows.Navigation.NavigationWindow>|Автономный или размещенный в браузере|  
|<xref:System.Windows.Controls.UserControl>|<xref:System.Windows.Navigation.NavigationWindow>|Автономный или размещенный в браузере|  
|<xref:System.Windows.Documents.FlowDocument>|<xref:System.Windows.Navigation.NavigationWindow>|Автономный или размещенный в браузере|  
|<xref:System.Windows.Navigation.PageFunction%601>|<xref:System.Windows.Navigation.NavigationWindow>|Автономный или размещенный в браузере|  
  
 Как правило, <xref:System.Windows.Application.StartupUri%2A> свойство задается декларативно [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]в. Тем не менее, можно <xref:System.Windows.Application.StartupUri%2A> задать программно, например, <xref:System.Windows.Application.Startup> из обработчика событий, что полезно, если для приложений, которые могут загружать необходимые ресурсы пользовательского интерфейса во время выполнения. Например, приложение может ожидать, пока время выполнения загрузит свои ресурсы, если имя ресурса пользовательского интерфейса хранится в файле конфигурации.  
  
 Независимо от <xref:System.Windows.Application.StartupUri%2A> <xref:System.Windows.Application.Startup> того, задается декларативно или программно, соответствующий ресурс пользовательского интерфейса не загружается до тех пор, пока не будет обработано событие. Следовательно, у вас не будет доступа к результирующему окну из <xref:System.Windows.Application.Windows%2A> свойства <xref:System.Windows.Application.MainWindow%2A> или свойства при обработке <xref:System.Windows.Application.Startup>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Windows.Application.StartupUri" /> устанавливается со значением null.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="propertyName">Имя запрошенного внешнего свойства.</param>
        <summary>Запрашивает, доступно ли заданное внешнее свойство в текущей области.</summary>
        <returns>Значение <see langword="true" />, если запрошенное внешнее свойство доступно; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Windows.Application> приведен к типу интерфейса <xref:System.Windows.Markup.IQueryAmbient>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.IQueryAmbient" />
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="application.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Имя искомого ресурса.</param>
        <summary>Осуществляет поиск указанного ресурса.</summary>
        <returns>Запрошенный объект ресурса. Если ресурс не найден, возвращается нулевая ссылка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.TryFindResource%2A>сначала проанализируйте ресурсы области приложения для указанного ресурса. Ресурсы области приложения управляются с помощью <xref:System.Windows.Application>и предоставляются <xref:System.Windows.Application.Resources%2A> из свойства. Если указанный ресурс не найден в наборе ресурсов области приложения, <xref:System.Windows.Application.TryFindResource%2A> далее выполняется поиск по системным ресурсам. Системные ресурсы — это ресурсы оболочки, определенные пользователем, включая цвета, шрифты и конфигурации оболочки. Они предоставляются из <xref:System.Windows.SystemColors>типов, <xref:System.Windows.SystemFonts>и <xref:System.Windows.SystemParameters> соответственно в качестве статических свойств. Чтобы использовать <xref:System.Windows.Application.TryFindResource%2A> для их получения, эти типы также предоставляют свойства ключа ресурса, предназначенные для <xref:System.Windows.Application.TryFindResource%2A>передачи, например <xref:System.Windows.SystemParameters.IconWidthKey%2A>.  
  
 Поскольку <xref:System.Windows.Application.TryFindResource%2A> возвращает объект, необходимо привести возвращаемое значение к соответствующему типу, если ресурс найден.  
  
 Этот метод является потокобезопасным и может быть вызван из любого потока.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Windows.Application.TryFindResource%2A> для получения ресурса.  
  
 [!code-xaml[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/App.xaml#applicationcalltryfindresourcexaml)]  
  
 [!code-csharp[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind1)]
 [!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind1)]  
[!code-csharp[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind2)]
[!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Windows">
      <MemberSignature Language="C#" Value="public System.Windows.WindowCollection Windows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.WindowCollection Windows" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Windows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Windows As WindowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowCollection ^ Windows { System::Windows::WindowCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Windows : System.Windows.WindowCollection" Usage="System.Windows.Application.Windows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает созданные окна приложения.</summary>
        <value>Объект <see cref="T:System.Windows.WindowCollection" />, содержащий ссылки на все объекты окна текущего <see cref="T:System.AppDomain" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ссылка добавляется автоматически <xref:System.Windows.Application.Windows%2A> сразу после создания экземпляра окна в [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] потоке; окна, созданные рабочими потоками, не добавляются. <xref:System.Windows.Window> Ссылка автоматически удаляется <xref:System.Windows.Window.Closing> после обработки события и до <xref:System.Windows.Window.Closed> возникновения события. <xref:System.Windows.Window>  
  
 По умолчанию первый элемент, добавленный в <xref:System.Windows.Application.Windows%2A> свойство, преобразуется в. <xref:System.Windows.Application.MainWindow%2A>  
  
 Это свойство доступно только из потока, в котором был создан <xref:System.Windows.Application> объект.  
  
   
  
## Examples  
 В следующем примере показано, как перечислить <xref:System.Windows.Application.Windows%2A> свойство для создания меню окон верхнего уровня, которое является общим для [!INCLUDE[TLA#tla_mdi](~/includes/tlasharptla-mdi-md.md)] приложений, например [!INCLUDE[TLA#tla_xl](~/includes/tlasharptla-xl-md.md)], или приложений с несколькими экземплярами однодокументного интерфейса (SDI), таких как [!INCLUDE[TLA#tla_word](~/includes/tlasharptla-word-md.md)].  
  
 [!code-csharp[ApplicationWindowsSnippets#WindowMenuItemCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/WindowMenuItem.cs#windowmenuitemcode)]
 [!code-vb[ApplicationWindowsSnippets#WindowMenuItemCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/windowmenuitem.vb#windowmenuitemcode)]  
  
 [!code-xaml[ApplicationWindowsSnippets#MainWindowSetWindowsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml#mainwindowsetwindowsxaml)]  
  
 [!code-csharp[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind1)]
 [!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/mainwindow.xaml.vb#mainwindowsetwindowscodebehind1)]  
[!code-csharp[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind2)]
[!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/mainwindow.xaml.vb#mainwindowsetwindowscodebehind2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Window" />
      </Docs>
    </Member>
  </Members>
</Type>
