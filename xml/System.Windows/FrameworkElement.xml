<Type Name="FrameworkElement" FullName="System.Windows.FrameworkElement">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a06289148efbd4e1466e223308d59b98e5550843" /><Meta Name="ms.sourcegitcommit" Value="9a6da88bd5455e8274257ca7ad259b42f1de114f" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="05/22/2019" /><Meta Name="ms.locfileid" Value="66008519" /></Metadata><TypeSignature Language="C#" Value="public class FrameworkElement : System.Windows.UIElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FrameworkElement extends System.Windows.UIElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement, class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkElement" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkElement&#xA;Inherits UIElement&#xA;Implements IFrameworkInputElement, IQueryAmbient, ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkElement : System::Windows::UIElement, System::ComponentModel::ISupportInitialize, System::Windows::IFrameworkInputElement, System::Windows::Markup::IQueryAmbient" />
  <TypeSignature Language="F#" Value="type FrameworkElement = class&#xA;    inherit UIElement&#xA;    interface IFrameworkInputElement&#xA;    interface IInputElement&#xA;    interface ISupportInitialize&#xA;    interface IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.UIElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IFrameworkInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.RuntimeNameProperty("Name")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.UsableDuringInitialization(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.XmlLangProperty("Language")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет набор свойств, событий и методов уровня платформы WPF для элементов Windows Presentation Foundation (WPF). Этот класс представляет предоставленную реализацию уровня платформы WPF, созданную на базе API уровня ядра WPF, которые определяются <see cref="T:System.Windows.UIElement" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> Представляет точку соединения между классами элемента уровня платформы WPF и набора уровня ядра WPF <xref:System.Windows.UIElement> службами представления. Дополнительные сведения об этих понятиях см. в разделе [архитектура WPF](~/docs/framework/wpf/advanced/wpf-architecture.md).  
  
 <xref:System.Windows.FrameworkElement> расширяет <xref:System.Windows.UIElement> и добавляет следующие возможности:  
  
-   **Определения системы макета**: <xref:System.Windows.FrameworkElement> предоставляет конкретные реализации уровня платформы WPF для некоторых методов, которые были определены как виртуальные элементы в <xref:System.Windows.UIElement>. Прежде всего <xref:System.Windows.FrameworkElement> запечатывает определенных переопределения макета уровня ядра WPF, а вместо этого предоставляет эквивалента уровня инфраструктуры WPF, которые производные классы должны переопределить вместо этого. Например <xref:System.Windows.FrameworkElement> пломбы <xref:System.Windows.UIElement.ArrangeCore%2A> , но предоставляет <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>. Эти изменения отражают тот факт, на уровне среды WPF это полная система структуры на месте, который может преобразовать любой <xref:System.Windows.FrameworkElement> производного класса. В WPF основы уровня, некоторые элементы, которые будут структуру общего [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] решения на основе макета в месте, но фактические ядра системы макета не определен. Дополнительные сведения см. в разделе [Макет](~/docs/framework/wpf/advanced/layout.md).  
  
-   **Логическое дерево:** Общие [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] модель программирования часто выражается в терминах выполняется дерева элементов. Поддержка выражения дерева элементов в виде логического дерева и сопутствующие поддержки для определения этого дерева в разметке реализована в <xref:System.Windows.FrameworkElement> уровень. Обратите внимание что <xref:System.Windows.FrameworkElement> намеренно не определяет модель содержимого и оставляя эту ответственность производных классов. Дополнительные сведения см. в разделе [Деревья в WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
-   **События времени жизни объекта:** Часто бывает полезно знать, когда инициализируется элемент (конструктор вызывается) или при первой загрузке элемента в логическом дереве. <xref:System.Windows.FrameworkElement> определяет несколько событий, связанных с временем жизни объекта, которые предоставляют полезные обработчики для кода операции, включающие элементы, такие как добавление нескольких дочерних элементов. Дополнительные сведения см. в разделе [события времени жизни объекта](~/docs/framework/wpf/advanced/object-lifetime-events.md).  
  
-   **Поддержка привязки данных и ссылки на динамические ресурсы:** Поддержка уровня свойств для привязки данных и ресурсов реализуется <xref:System.Windows.DependencyProperty> класса и принята в системе свойств, но возможность разрешения значение элемента, который хранится в виде <xref:System.Windows.Expression> (конструкции программирования, лежащий в основе обоих Привязка данных и динамические ресурсы) реализуется <xref:System.Windows.FrameworkElement>. Дополнительные сведения см. в разделе [Общие сведения о привязке данных](~/docs/framework/wpf/data/data-binding-overview.md) и [ресурсы XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
-   **Стили:** <xref:System.Windows.FrameworkElement> определяет <xref:System.Windows.FrameworkElement.Style%2A> свойство. Тем не менее <xref:System.Windows.FrameworkElement> еще не определить поддержку для шаблонов или поддержки декораторов. Эти функции появились классы элементов управления, например <xref:System.Windows.Controls.Control> и <xref:System.Windows.Controls.ContentControl>.  
  
-   **Дополнительная поддержка анимации:** Некоторые поддержку анимации уже было определено на уровне ядра WPF, но <xref:System.Windows.FrameworkElement> расширяет это путем реализации <xref:System.Windows.FrameworkElement.BeginStoryboard%2A> и связанные элементы.  
  
 Как видно из иерархии классов много [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] классы являются производными от <xref:System.Windows.FrameworkElement>, напрямую или через промежуточный базовыми классами такие как <xref:System.Windows.Controls.Panel> или <xref:System.Windows.Controls.Control>.  
  
 Если вы планируете использовать <xref:System.Windows.FrameworkElement> как базовый класс, может потребоваться сначала проверить существующие производные классы. <xref:System.Windows.FrameworkElement> обеспечивает поддержку нескольких основных сценариев, но такой способ не обеспечивает ряд возможностей, которые предпочтительны для «element» в том смысле, используемом для создания стандартного блока [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] в [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. Например <xref:System.Windows.FrameworkElement> не определяет любое значение true, модель содержимого; <xref:System.Windows.FrameworkElement> как базовый класс не определяет свойство, которое можно создать [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] дочерних элементов. В частности, может потребоваться рассмотреть <xref:System.Windows.Controls.Control> и <xref:System.Windows.Controls.ContentControl>.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyObject" />
    <altmember cref="T:System.Windows.FrameworkContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.FrameworkElement" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualHeight">
      <MemberSignature Language="C#" Value="public double ActualHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ActualHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ActualHeight" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActualHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ActualHeight { double get(); };" />
      <MemberSignature Language="F#" Value="member this.ActualHeight : double" Usage="System.Windows.FrameworkElement.ActualHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает визуализированную высоту данного элемента.</summary>
        <value>Высота элемента, представленная в [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Значение по умолчанию — 0 (нуль).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство имеет значение, вычисленное на основе других вводимых высот и системы макета. Значение задается самой системой макета в зависимости от фактического прохода отрисовки и может таким образом немного отставать от установки значений свойств таких как <xref:System.Windows.FrameworkElement.Height%2A> , являются основой для изменения ввода.  
  
 Поскольку <xref:System.Windows.FrameworkElement.ActualHeight%2A> является вычисляемым значением, следует иметь в виду, могут производиться многократные или добавочные сообщаемые изменения к нему в результате различных операций системой макета. Система макета может вычислять требуемое место измерения для дочерних элементов, ограничения родительского элемента и т. д.  
  
 Несмотря на то, что невозможно задать это свойство из [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], может быть основан <xref:System.Windows.Trigger> после его значение в стиле.  
  
<a name="dependencyPropertyInfo_ActualHeight"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.ActualHeightProperty>|  
|Значение свойства метаданных `true`|Нет|  
  
   
  
## Examples  
 Следующий пример показывает различные свойства высоты.  
  
 [!code-csharp[HeightMinHeightMaxHeight#3](~/samples/snippets/csharp/VS_Snippets_Wpf/HeightMinHeightMaxHeight/CSharp/Window1.xaml.cs#3)]
 [!code-vb[HeightMinHeightMaxHeight#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HeightMinHeightMaxHeight/VisualBasic/Window1.xaml.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ActualHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ActualHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ActualHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ActualHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ActualHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ActualHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ActualHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.ActualHeight" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualWidth">
      <MemberSignature Language="C#" Value="public double ActualWidth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ActualWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ActualWidth" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActualWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ActualWidth { double get(); };" />
      <MemberSignature Language="F#" Value="member this.ActualWidth : double" Usage="System.Windows.FrameworkElement.ActualWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает визуализированную ширину данного элемента.</summary>
        <value>Ширина элемента, представленная в [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Значение по умолчанию — 0 (нуль).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство имеет значение, вычисленное на основе других входных значений ширины и системы макета. Значение задается самой системой макета в зависимости от фактического прохода отрисовки и может таким образом немного отставать от установки значений свойств таких как <xref:System.Windows.FrameworkElement.Width%2A> , являются основой для изменения ввода.  
  
 Поскольку <xref:System.Windows.FrameworkElement.ActualWidth%2A> является вычисляемым значением, следует иметь в виду, могут производиться многократные или добавочные сообщаемые изменения к нему в результате различных операций системой макета. Система макета может вычислять требуемое место измерения для дочерних элементов, ограничения родительского элемента и т. д.  
  
 Несмотря на то, что невозможно задать это свойство из [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], может быть основан <xref:System.Windows.Trigger> после его значение в стиле.  
  
<a name="dependencyPropertyInfo_ActualWidth"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.ActualWidthProperty>|  
|Значение свойства метаданных `true`|Нет|  
  
   
  
## Examples  
 Следующий пример показывает различные свойства ширины.  
  
 [!code-csharp[WidthMinWidthMaxWidth#3](~/samples/snippets/csharp/VS_Snippets_Wpf/WidthMinWidthMaxWidth/CSharp/Window1.xaml.cs#3)]
 [!code-vb[WidthMinWidthMaxWidth#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WidthMinWidthMaxWidth/VisualBasic/Window1.xaml.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ActualWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ActualWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ActualWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ActualWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ActualWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ActualWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ActualWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.ActualWidth" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void AddLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.AddLogicalChild : obj -&gt; unit" Usage="frameworkElement.AddLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">Добавляемый дочерний элемент.</param>
        <summary>Добавляет указанный объект в логическое дерево данного элемента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для реализации коллекции объектов, представляющих логических дочерних элементов элемента. Обслуживание коллекции для коллекции дочерних элементов может выполняться в методы получения свойств или методов задания, обработчик события Changed, конструкторов, или внутри самих коллекции типов класса.  
  
 Для разработчиков элементов управления обработка логического дерева на этом уровне не рекомендуется, если ни одна из моделей содержимого для доступных базовых классов элементов управления не подходит для вашего сценария управления. Рассмотрите возможность создания подклассов на уровне <xref:System.Windows.Controls.ContentControl>, <xref:System.Windows.Controls.ItemsControl>, и <xref:System.Windows.Controls.HeaderedItemsControl>. Эти классы предоставляют модель содержимого с определенной органами логическое дерево дочерних элементов с помощью выделенного [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)], а также поддерживает другие функции, обычно желательно, [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] элемента управления, такие как стили через шаблоны. Дополнительные сведения об использовании <xref:System.Windows.FrameworkElement.LogicalChildren%2A> и <xref:System.Windows.FrameworkElement.AddLogicalChild%2A>, см. в разделе [деревья в WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 <xref:System.Windows.FrameworkElement.AddLogicalChild%2A> может вызывать исключение, если вызывается в момент, когда выполняется итерация логического дерева с помощью другого процесса.  
  
   
  
## Examples  
 В следующем примере реализуется `Child` свойство в пользовательском <xref:System.Windows.FrameworkElement> который выполняет собственную реализацию на визуальном уровне. Метод задания свойства разработан таким образом, если значение изменяется, старое значение удаляется из логического дерева, а также коллекцию визуальных элементов данного класса. Значение свойства кэшируется, и затем добавляется новое значение для логического дерева и коллекция пользовательских визуальных элементов.  
  
 [!code-csharp[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/csharp/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/CSharp/ParticleEffectExamples/OverlayRenderDecorator.cs#addremovelogicalchild)]
 [!code-vb[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/visualbasic/particleeffectexamples/overlayrenderdecorator.vb#addremovelogicalchild)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ApplyTemplate">
      <MemberSignature Language="C#" Value="public bool ApplyTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ApplyTemplate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ApplyTemplate" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyTemplate () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ApplyTemplate();" />
      <MemberSignature Language="F#" Value="member this.ApplyTemplate : unit -&gt; bool" Usage="frameworkElement.ApplyTemplate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При необходимости строит визуальное дерево текущего шаблона и возвращает значение, указывающее, было ли это визуальное дерево перестроено в результате этого вызова.</summary>
        <returns>Значение <see langword="true" />, если в дерево были добавлены визуальные элементы; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Приложения могут вызывать этот метод, чтобы гарантировать, что визуальное дерево элемента завершена. Такая гарантия может возникнуть необходимость в том случае, если код будет проверять дочерние элементы в дереве. Обычный элемент логике приложений, вызвав <xref:System.Windows.FrameworkElement.ApplyTemplate%2A> не нужен, так как шаблоны будут применяться к элементам в соответствующий момент их времени существования автоматически.  
  
 <xref:System.Windows.FrameworkElement.ApplyTemplate%2A> вызывается для всех мер передать системой макетов уровня среды WPF.  
  
 <xref:System.Windows.FrameworkElement> производные классы могут использовать <xref:System.Windows.FrameworkElement.OnApplyTemplate%2A> обработчик класса для получения уведомлений из случаев, когда этот метод был вызван явным образом или системой макета. <xref:System.Windows.FrameworkElement.OnApplyTemplate%2A> вызывается после шаблон полностью создается и прикрепляется к логическому дереву.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ControlTemplate" />
      </Docs>
    </Member>
    <Member MemberName="ArrangeCore">
      <MemberSignature Language="C#" Value="protected override sealed void ArrangeCore (System.Windows.Rect finalRect);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ArrangeCore(valuetype System.Windows.Rect finalRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ArrangeCore(System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Sub ArrangeCore (finalRect As Rect)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ArrangeCore(System::Windows::Rect finalRect);" />
      <MemberSignature Language="F#" Value="override this.ArrangeCore : System.Windows.Rect -&gt; unit" Usage="frameworkElement.ArrangeCore finalRect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="finalRect" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="finalRect">Итоговая область в родительском элементе, которую этот элемент должен использовать для размещения себя и своих дочерних элементов.</param>
        <summary>Реализует метод <see cref="M:System.Windows.UIElement.ArrangeCore(System.Windows.Rect)" /> (определенный как виртуальный в классе <see cref="T:System.Windows.UIElement" />) и запечатывает реализацию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод является запечатанным. Чтобы переопределить логику в пользовательских элементе специально для проход макета элемента вашей <xref:System.Windows.FrameworkElement> производный класс должен переопределять <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Size ArrangeOverride (System.Windows.Size finalSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size finalSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ArrangeOverride (finalSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Size ArrangeOverride(System::Windows::Size finalSize);" />
      <MemberSignature Language="F#" Value="abstract member ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size&#xA;override this.ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="frameworkElement.ArrangeOverride finalSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="finalSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="finalSize">Итоговая область в родительском элементе, которую этот элемент должен использовать для размещения себя и своих дочерних элементов.</param>
        <summary>При переопределении в производном классе размещает дочерние элементы и определяет размер для производного класса <see cref="T:System.Windows.FrameworkElement" />.</summary>
        <returns>Фактический используемый размер.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Которым необходимо настроить на проход упорядочивания обработки макета необходимо переопределить этот метод. Шаблон реализации должен вызывать <see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" /> на каждый элемент видимого дочернего элемента и передайте конечный требуемого размера для каждого дочернего элемента, как <paramref name="finalRect" /> параметр. Родительские элементы должны вызывать <see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" /> на каждый дочерний элемент, в противном случае дочерние элементы не отображается.  
  
Во многих производных классах реализации этого метода. Известных методов входят следующие: <see cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />, <see cref="M:System.Windows.Controls.Page.ArrangeOverride(System.Windows.Size)" /> и <see cref="M:System.Windows.Controls.Control.ArrangeOverride(System.Windows.Size)" />.</para></block>
        <altmember cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="frameworkElement.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Запускает процесс инициализации данного элемента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно вызвать для отдельных элементов, если они выравниваются способами, которые еще не предоставляют или подключения элемента для любого элемента дерева. Например, вы могли создать новый <xref:System.Windows.FrameworkElement>, но не еще подключено его логическому дереву. Или, логическое дерево, где элемент является дочерним элементом в нем не может быть подключен к окно или страницу приложения.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Этот метод реализуется для обеспечения специальной обработки, которая будет выполняться перед инициализацией элемента в процессе его загрузки.  
  
Реализация должна вызывать базовую реализацию, так как реализация base (по умолчанию) устанавливает внутренние флаги для отслеживания инициализации. Для использования этого метода в качестве ловушки в собственных процедур инициализации закрытого класса, которые еще не включены конструкторами является одной из возможных реализаций.  
  
Базовая реализация вызовет исключение, если <see cref="M:System.Windows.FrameworkElement.BeginInit" /> вызывается несколько раз для одного элемента до <see cref="M:System.Windows.FrameworkElement.EndInit" /> вызова.</para></block>
        <altmember cref="M:System.Windows.FrameworkElement.EndInit" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginStoryboard">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Начинает последовательность действий, содержащихся в предоставленной раскадровке.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard -&gt; unit" Usage="frameworkElement.BeginStoryboard storyboard" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
      </Parameters>
      <Docs>
        <param name="storyboard">Раскадровка, которая будет начата.</param>
        <summary>Начинает последовательность действий, содержащихся в предоставленной раскадровке.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не следует использовать для наиболее типичных сценариях анимации. Обычно создается <xref:System.Windows.Media.Animation.Storyboard> или <xref:System.Windows.Media.Animation.BeginStoryboard> элемент в разметке, а затем поместите их в качестве <xref:System.Windows.EventTrigger> содержимого в элементе. При срабатывании триггера события, выполняется анимация. Большинство аспектов управления <xref:System.Windows.Media.Animation.Storyboard> можно обратиться по свойствами, доступными в разметке.  
  
 Для подписей, которые не используют `isControllable`, параметр, или если указан этот параметр `false`, часы шкалы времени, которые связаны с анимацией удаляются сразу же анимации наступит время «Fill». Не анимации может быть перезапущено после однократного запуска. Управление анимацией также требует, чтобы раскадровка [директива x: Name](~/docs/framework/xaml-services/x-name-directive.md) или быть доступны по ссылке в коде.  
  
   
  
## Examples  
 В следующем примере извлекается <xref:System.Windows.Media.Animation.Storyboard> из ресурсов, а затем запускается, <xref:System.Windows.Media.Animation.Storyboard> при внутреннее событие обрабатывается классом.  
  
 [!code-csharp[CubeAnimation#FEBeginStoryboard](~/samples/snippets/csharp/VS_Snippets_Wpf/CubeAnimation/CSharp/Page1.xaml.cs#febeginstoryboard)]
 [!code-vb[CubeAnimation#FEBeginStoryboard](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CubeAnimation/visualbasic/page1.xaml.vb#febeginstoryboard)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="frameworkElement.BeginStoryboard (storyboard, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="storyboard">Раскадровка, которая будет начата.</param>
        <param name="handoffBehavior">Значение перечисления, описывающего поведение в случае, если описанное в раскадровке свойство уже анимировано.</param>
        <summary>Начинает последовательность действий, содержащихся в предоставленной раскадровке, с параметрами, указывающими на реакцию в случае уже анимированного свойства.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не следует использовать для наиболее типичных сценариях анимации. Обычно создается <xref:System.Windows.Media.Animation.Storyboard> или <xref:System.Windows.Media.Animation.BeginStoryboard> элемент в разметке, а затем поместите их в качестве <xref:System.Windows.EventTrigger> содержимого в элементе. При срабатывании триггера события, выполняется анимация. Большинство аспектов управления <xref:System.Windows.Media.Animation.Storyboard> можно обратиться по свойствами, доступными в разметке.  
  
 Для подписей, которые не используют `isControllable`, параметр, или если указан этот параметр `false`, часы шкалы времени, которые связаны с анимацией удаляются сразу же анимации наступит время «Fill». Не анимации может быть перезапущено после однократного запуска. Управление анимацией также требует, чтобы раскадровка [директива x: Name](~/docs/framework/xaml-services/x-name-directive.md) или быть доступны по ссылке в коде.  
  
 Переадресуемое поведение может быть указан как атрибут <xref:System.Windows.Media.Animation.BeginStoryboard>.  
  
## <a name="using-the-compose-handoffbehavior"></a>С помощью Compose HandoffBehavior  
 При применении <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, или <xref:System.Windows.Media.Animation.AnimationClock> к свойству с помощью <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>любые <xref:System.Windows.Media.Animation.Clock> ранее связанную с ним объекты по-прежнему потребляют ресурсы системы; система управления временем не не удаляет эти часы автоматически.  
  
 Чтобы избежать проблем с производительностью при применении большого количества часов с помощью <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, следует удалять составные часы из анимируемого свойства после их завершения. Существует несколько способов удаления часов:  
  
-   Чтобы удалить все часы из свойства, используйте <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> или <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> метод анимируемого объекта. Укажите в качестве первого параметра анимируемое свойство и `null` как второй. При этом удаляются все часы анимации из свойства.  
  
-   Чтобы удалить определенные <xref:System.Windows.Media.Animation.AnimationClock> из списка часов, используйте <xref:System.Windows.Media.Animation.Clock.Controller%2A> свойство <xref:System.Windows.Media.Animation.AnimationClock> извлекаемого <xref:System.Windows.Media.Animation.ClockController>, затем вызвать <xref:System.Windows.Media.Animation.ClockController.Remove%2A> метод <xref:System.Windows.Media.Animation.ClockController>. Обычно это делается <xref:System.Windows.Media.Animation.Clock.Completed> обработчик событий для часов. Обратите внимание, что только корневые часы могут управляться <xref:System.Windows.Media.Animation.ClockController>; <xref:System.Windows.Media.Animation.Clock.Controller%2A> дочерних часов вернет `null`. Обратите внимание, что <xref:System.Windows.Media.Animation.Clock.Completed> событие не происходит, если эффективная продолжительность часов — forever.  В этом случае пользователь должен определить, когда нужно вызывать <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 В основном это проблема для анимации объектов, имеющих длинное время жизни.  Если объект удаляется сборщиком мусора, его часы также будут отключены, и сборщиком мусора.  
  
 Дополнительные сведения об объектах часов см. в разделе [анимации и общие сведения о характере системы](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
   
  
## Examples  
 В следующем примере извлекается <xref:System.Windows.Media.Animation.Storyboard> из ресурсов, а затем запускается, <xref:System.Windows.Media.Animation.Storyboard> при внутреннее событие обрабатывается классом.  
  
 [!code-csharp[CubeAnimation#FEBeginStoryboard](~/samples/snippets/csharp/VS_Snippets_Wpf/CubeAnimation/CSharp/Page1.xaml.cs#febeginstoryboard)]
 [!code-vb[CubeAnimation#FEBeginStoryboard](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CubeAnimation/visualbasic/page1.xaml.vb#febeginstoryboard)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="frameworkElement.BeginStoryboard (storyboard, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="storyboard">Раскадровка, которая будет начата.</param>
        <param name="handoffBehavior">Значение перечисления, описывающего поведение в случае, если описанное в раскадровке свойство уже анимировано.</param>
        <param name="isControllable">Объявляет, является ли анимация управляемой после запуска (можно ли ее приостановить).</param>
        <summary>Начинает последовательность действий, содержащихся в предоставленной раскадровке, с указанным состоянием элемента управления анимацией после ее запуска.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не следует использовать для наиболее типичных сценариях анимации. Обычно создается <xref:System.Windows.Media.Animation.Storyboard> или <xref:System.Windows.Media.Animation.BeginStoryboard> элемент в разметке, а затем поместите их в качестве <xref:System.Windows.EventTrigger> содержимого в элементе. При срабатывании триггера события, выполняется анимация. Большинство аспектов управления <xref:System.Windows.Media.Animation.Storyboard> можно обратиться по свойствами, доступными в разметке.  
  
 Для подписей, которые не используют `isControllable`, параметр, или если указан этот параметр `false`, часы шкалы времени, которые связаны с анимацией удаляются сразу же анимации наступит время «Fill». Не анимации может быть перезапущено после однократного запуска. Управление анимацией также требует, чтобы раскадровка [директива x: Name](~/docs/framework/xaml-services/x-name-directive.md) или быть доступны по ссылке в коде.  
  
 Переадресуемое поведение может быть указан как атрибут <xref:System.Windows.Media.Animation.BeginStoryboard>.  
  
## <a name="using-the-compose-handoffbehavior"></a>С помощью Compose HandoffBehavior  
 При применении <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, или <xref:System.Windows.Media.Animation.AnimationClock> к свойству с помощью <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>любые <xref:System.Windows.Media.Animation.Clock> ранее связанную с ним объекты по-прежнему потребляют ресурсы системы; система управления временем не не удаляет эти часы автоматически.  
  
 Чтобы избежать проблем с производительностью при применении большого количества часов с помощью <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, следует удалять составные часы из анимируемого свойства после их завершения. Существует несколько способов удаления часов:  
  
-   Чтобы удалить все часы из свойства, используйте <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> или <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> метод анимируемого объекта. Укажите в качестве первого параметра анимируемое свойство и `null` как второй. При этом удаляются все часы анимации из свойства.  
  
-   Чтобы удалить определенные <xref:System.Windows.Media.Animation.AnimationClock> из списка часов, используйте <xref:System.Windows.Media.Animation.Clock.Controller%2A> свойство <xref:System.Windows.Media.Animation.AnimationClock> извлекаемого <xref:System.Windows.Media.Animation.ClockController>, затем вызвать <xref:System.Windows.Media.Animation.ClockController.Remove%2A> метод <xref:System.Windows.Media.Animation.ClockController>. Обычно это делается <xref:System.Windows.Media.Animation.Clock.Completed> обработчик событий для часов. Обратите внимание, что только корневые часы могут управляться <xref:System.Windows.Media.Animation.ClockController>; <xref:System.Windows.Media.Animation.Clock.Controller%2A> дочерних часов вернет `null`. Обратите внимание, что <xref:System.Windows.Media.Animation.Clock.Completed> событие не происходит, если эффективная продолжительность часов — forever.  В этом случае пользователь должен определить, когда нужно вызывать <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 В основном это проблема для анимации объектов, имеющих длинное время жизни.  Если объект удаляется сборщиком мусора, его часы также будут отключены, и сборщиком мусора.  
  
 Дополнительные сведения об объектах часов см. в разделе [анимации и общие сведения о характере системы](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroup">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingGroup BindingGroup { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingGroup BindingGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.BindingGroup" />
      <MemberSignature Language="VB.NET" Value="Public Property BindingGroup As BindingGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingGroup ^ BindingGroup { System::Windows::Data::BindingGroup ^ get(); void set(System::Windows::Data::BindingGroup ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BindingGroup : System.Windows.Data.BindingGroup with get, set" Usage="System.Windows.FrameworkElement.BindingGroup" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingGroup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает группу <see cref="T:System.Windows.Data.BindingGroup" />,  которая используется для элемента.</summary>
        <value>Группа <see cref="T:System.Windows.Data.BindingGroup" />, используемая для элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Windows.Data.BindingGroup> может использоваться для проверки значений нескольких свойств объекта. Например, предположим, что приложение предлагает пользователю ввести адрес, а затем заполняет объект типа `Address`, который имеет свойства `Street`, `City`, `ZipCode`, и `Country`, со значениями, пользователь предоставляются. Приложение имеет панель, которая содержит четыре <xref:System.Windows.Controls.TextBox> элементов управления, привязанных к одному из свойств объекта. Можно использовать <xref:System.Windows.Controls.ValidationRule> в <xref:System.Windows.Data.BindingGroup> проверяемый `Address` объекта. Например <xref:System.Windows.Controls.ValidationRule> гарантирует, что ZIP-код является допустимым в стране адреса.  
  
 Дочерние элементы наследуют <xref:System.Windows.Data.BindingGroup> от своих родительских элементов, как и в других наследуемое свойство.  
  
<a name="dependencyPropertyInfo_BindingGroup"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.BindingGroupProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 Следующие примеры являются частью приложения, которое проверяет, ли пользователь задать свойства двух объектов одинаковые значения. В первом примере создается два <xref:System.Windows.Controls.TextBox> элементов управления, каждый из которых привязан к другому источнику данных. <xref:System.Windows.Controls.StackPanel> Имеет <xref:System.Windows.Data.BindingGroup> , содержащий <xref:System.Windows.Controls.ValidationRule> , проверяет, что две строки равны.  
  
 [!code-xaml[BindingGroupSnippets#BindingGroupComplete](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml#bindinggroupcomplete)]  
  
 В следующем примере показан <xref:System.Windows.Controls.ValidationRule> , используемый в предыдущем примере.  В <xref:System.Windows.Controls.ValidationRule.Validate%2A> переопределения метода, в примере показано получение каждого исходного объекта из <xref:System.Windows.Data.BindingGroup> и проверяет, равны ли свойства объектов.  
  
 [!code-csharp[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml.cs#bindinggroupnamevalidationrule)]
 [!code-vb[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window3.xaml.vb#bindinggroupnamevalidationrule)]  
  
 Для вызова <xref:System.Windows.Controls.ValidationRule>, вызовите <xref:System.Windows.Data.BindingGroup.UpdateSources%2A> метод.  В следующем примере вызывается <xref:System.Windows.Data.BindingGroup.UpdateSources%2A> при возникновении события щелчка кнопки.  
  
 [!code-csharp[BindingGroupSnippets#UpdateSourcesClick](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml.cs#updatesourcesclick)]
 [!code-vb[BindingGroupSnippets#UpdateSourcesClick](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window3.xaml.vb#updatesourcesclick)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroupProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BindingGroupProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BindingGroupProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.BindingGroupProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BindingGroupProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BindingGroupProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BindingGroupProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.BindingGroupProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.BindingGroup" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BringIntoView">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Пытается отобразить данный элемент вместе с содержащимися в нем прокручиваемыми областями.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView();" />
      <MemberSignature Language="F#" Value="member this.BringIntoView : unit -&gt; unit" Usage="frameworkElement.BringIntoView " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Пытается отобразить данный элемент вместе с содержащимися в нем прокручиваемыми областями.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов этого метода, повышении <xref:System.Windows.FrameworkElement.RequestBringIntoView> события, происходящие из текущего элемента. Это событие возникает в том случае, таким образом, чтобы оно могло быть обработано <xref:System.Windows.Controls.ScrollViewer>, или класс производного или аналогичные. Ожидаемым поведением является событие обрабатывается родительским элементом, помечено как обработанное в данных события, и источник события переводится в режим в представление через логику, внедренных в <xref:System.Windows.Controls.ScrollViewer> элемента управления. Ни <xref:System.Windows.FrameworkElement.RequestBringIntoView> событий ни <xref:System.Windows.FrameworkElement.BringIntoView%2A> метод передавать никакую информацию, об успехе или неудаче, отличные от, обычно событие является помечены обработано на успех. Вызвано следующими причинами сбоя могут включать параметры элемента, например <xref:System.Windows.UIElement.Visibility%2A> выполняется некоторое значение, отличное от <xref:System.Windows.Visibility.Visible>.  
  
 Если вы используете подпись, которая не содержит `targetRectangle`, затем размер всего элемента (его <xref:System.Windows.UIElement.RenderSize%2A>) будет сделан видимым.  
  
 Вызов этого метода, вы потенциально вызовет <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> на любой родительский прокручиваемую область, которая содержит элемент. Если этот элемент не содержится в прокручиваемой области, <xref:System.Windows.FrameworkElement.RequestBringIntoView> событие по-прежнему, но будет не влияет, так как отсутствуют прослушиватели событий.  
  
   
  
## Examples  
 В следующем примере реализуется обработчик для события навигации в приложении, отвечающее каждый раз, когда [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] которой осуществляется переход к фрагменту, включает в себя. Фрагмент именуется в [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] следуя решетки (#), и реализованное поведение вызывает элемент, который прокручивается в представлении в фрейме. <xref:System.Windows.FrameworkElement.BringIntoView%2A> и <xref:System.Windows.FrameworkElement.RequestBringIntoView> запроса, поведением прокрутки в примере.  
  
 [!code-csharp[FragmentNavigationSample#FEBringIntoView](~/samples/snippets/csharp/VS_Snippets_Wpf/FragmentNavigationSample/CSharp/MainWindow.xaml.cs#febringintoview)]
 [!code-vb[FragmentNavigationSample#FEBringIntoView](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FragmentNavigationSample/VisualBasic/MainWindow.xaml.vb#febringintoview)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ScrollViewer" />
      </Docs>
    </Member>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView (System.Windows.Rect targetRectangle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView(valuetype System.Windows.Rect targetRectangle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView (targetRectangle As Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView(System::Windows::Rect targetRectangle);" />
      <MemberSignature Language="F#" Value="member this.BringIntoView : System.Windows.Rect -&gt; unit" Usage="frameworkElement.BringIntoView targetRectangle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetRectangle" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="targetRectangle">Указанный размер элемента, который также следует отобразить.</param>
        <summary>Пытается отобразить указанный размер области данного элемента вместе с содержащимися в нем прокручиваемыми областями.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов этого метода, повышении <xref:System.Windows.FrameworkElement.RequestBringIntoView> события, происходящие из текущего элемента. Это событие возникает в том случае, таким образом, чтобы оно могло быть обработано <xref:System.Windows.Controls.ScrollViewer>, или класс производного или аналогичные. Ожидаемым поведением является событие обрабатывается родительским элементом, помечено как обработанное в данных события, и источник события переводится в режим в представление через логику, внедренных в <xref:System.Windows.Controls.ScrollViewer> элемента управления. Ни <xref:System.Windows.FrameworkElement.RequestBringIntoView> событий ни <xref:System.Windows.FrameworkElement.BringIntoView%2A> метод передавать никакую информацию, об успехе или неудаче, отличные от, обычно событие является помечены обработано на успех. Вызвано следующими причинами сбоя могут включать параметры элемента, например <xref:System.Windows.UIElement.Visibility%2A> выполняется некоторое значение, отличное от <xref:System.Windows.Visibility.Visible>.  
  
 Если вы используете подпись, которая не содержит `targetRectangle`, затем размер всего элемента (его <xref:System.Windows.UIElement.RenderSize%2A>) будет сделан видимым.  
  
 Вызов этого метода, вы потенциально вызовет <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> на любой родительский прокручиваемую область, которая содержит элемент. Если этот элемент не содержится в прокручиваемой области, <xref:System.Windows.FrameworkElement.RequestBringIntoView> событие по-прежнему, но будет не влияет, так как отсутствуют прослушиватели событий.  
  
   
  
## Examples  
 Следующий пример имеет большой рисунок в ограниченной области прокрутки. На кнопке на странице есть обработчик, который Прокручивает представление определенной областью большого изображения.  
  
 [!code-xaml[BaseElementsSmorgasbord#BringIntoViewRectMarkup](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml#bringintoviewrectmarkup)]  
  
 [!code-csharp[BaseElementsSmorgasbord#BringIntoViewRectCode](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#bringintoviewrectcode)]
 [!code-vb[BaseElementsSmorgasbord#BringIntoViewRectCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#bringintoviewrectcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.FlowDocumentScrollViewer" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ContextMenu ^ ContextMenu { System::Windows::Controls::ContextMenu ^ get(); void set(System::Windows::Controls::ContextMenu ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenu : System.Windows.Controls.ContextMenu with get, set" Usage="System.Windows.FrameworkElement.ContextMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает элемент контекстного меню, который должен отображаться каждый раз при вызове контекстного меню через [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] из этого элемента.</summary>
        <value>Контекстное меню, назначенное этому элементу.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.ContextMenu> сам по себе является <xref:System.Windows.FrameworkElement> производного класса, и технически возможно для <xref:System.Windows.Controls.ContextMenu> сам иметь <xref:System.Windows.FrameworkElement.ContextMenu%2A> свойство. Тем не менее это создает путаницу контекстное меню удобство работы пользователей, и это не рекомендуется.  
  
<a name="dependencyPropertyInfo_ContextMenu"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.ContextMenuProperty>|  
|Значение свойства метаданных `true`|Нет|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ContextMenuClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuClosing As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuClosing;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит непосредственно перед закрытием какого-либо контекстного меню в элементе.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для подавления закрытия контекстных меню обработчики события следует пометить как обработанное.  
  
 Чтобы использовать это событие как <xref:System.Windows.EventTrigger> в стиле, необходимо сослаться на определение базовой службой события:  
  
 [!code-xaml[CorePseudocode#FEContextMenuClosing](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuclosing)]  
  
 (Такое использование не требуются, поскольку реализация событий на <xref:System.Windows.FrameworkElement> , предоставляет базовые события службы не были сопоставлены <xref:System.Windows.FrameworkElement.ContextMenuClosing> идентификатор таким образом, что его можно использовать как триггер).  
  
 <xref:System.Windows.Controls.ContextMenu> сам по себе является <xref:System.Windows.FrameworkElement> производного класса, но <xref:System.Windows.FrameworkElement.ContextMenuClosing> событие не возникнет, контекстное меню напрямую. Вместо этого событие инициируется элементом, который «владеет» в контекстном меню, как свойство и только тогда, когда пользователь пытается закрыть контекстное меню в пользовательском Интерфейсе. Тем не менее существует возможность <xref:System.Windows.Controls.ContextMenu> сам иметь <xref:System.Windows.FrameworkElement.ContextMenu%2A> свойство (вложенные контекстное меню). В этом случае <xref:System.Windows.Controls.ContextMenu> действительно является владельцем вложенного <xref:System.Windows.Controls.ContextMenu> и может вызывать события, с источником события, что вложенное содержимое для меню.  
  
 <xref:System.Windows.Controls.ContextMenu> Сам класс также имеет аналогичное событие (<xref:System.Windows.Controls.ContextMenu.Closed>), но <xref:System.Windows.Controls.ContextMenu.Closed> событий не предоставляет вам возможность отмены действия пользователя.  
  
<a name="routedEventInfo_ContextMenuClosing"></a>   
## <a name="routed-event-information"></a>Сведения о маршрутизируемом событии  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.ContextMenuClosingEvent>|  
|Стратегия маршрутизации|Восходящая маршрутизация|  
|делегат|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
-   Переопределить <xref:System.Windows.FrameworkElement.OnContextMenuClosing%2A> реализовать обработчик класса для этого события в производных классах.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ContextMenuClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует направленное событие <see cref="E:System.Windows.FrameworkElement.ContextMenuClosing" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Идентификаторы перенаправленных событий создаются при их регистрации. Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события. Эти идентификаторы можно использовать для добавления обработчиков классов.  
  
 Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ContextMenuOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuOpening As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuOpening;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при открытии какого-либо контекстного меню в элементе.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вручную открыть контекстные меню, обработчики событий следует помечать соответствующее событие как обработанное. В противном случае существующее значение <xref:System.Windows.FrameworkElement.ContextMenu%2A> свойство будет использоваться для автоматического открытия контекстного меню. Маркировка события как обработанного эффективно отменит действие по умолчанию и может быть возможность сбросить значение <xref:System.Windows.FrameworkElement.ContextMenu%2A> свойство и откройте новый <xref:System.Windows.Controls.ContextMenu>. Тем не менее есть ошибки синхронизации, которые следует учитывать. Чтобы полностью заменить контекстное меню способом <xref:System.Windows.FrameworkElement.ContextMenuOpening> обработчик, начальной контекстное меню не должно быть null или пустым. Кроме того может потребоваться обработать событие и затем вручную открыть новое контекстное меню. Подробную информацию см. в разделе [Практическое руководство. Обработка события ContextMenuOpening](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md).  
  
 Чтобы использовать это событие как <xref:System.Windows.EventTrigger> в стиле, необходимо сослаться на основное присоединенное событие:  
  
 [!code-xaml[CorePseudocode#FEContextMenuOpening](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuopening)]  
  
 (Такое использование не требуются, поскольку реализация событий на <xref:System.Windows.FrameworkElement> , предоставляет базовые события службы не были сопоставлены <xref:System.Windows.FrameworkElement.ContextMenuOpening> идентификатор таким образом, что его можно использовать в триггерах).  
  
 <xref:System.Windows.Controls.ContextMenu> сам по себе является <xref:System.Windows.FrameworkElement> производного класса, но это событие не будет вызываться в контекстном меню, открываемом в качестве источника. События из элемента, «владеет» в контекстном меню, как свойство и только тогда, когда пользователь пытается открыть контекстное меню в пользовательском Интерфейсе. Существует возможность <xref:System.Windows.Controls.ContextMenu> сам иметь <xref:System.Windows.FrameworkElement.ContextMenu%2A> свойство, но следует избегать в этом сценарии (Дополнительные сведения см. в разделе <xref:System.Windows.FrameworkElement.ContextMenu%2A?displayProperty=nameWithType>).  
  
 <xref:System.Windows.Controls.ContextMenu> Сам класс также имеет аналогичное событие (<xref:System.Windows.Controls.ContextMenu.Opened>), но <xref:System.Windows.Controls.ContextMenu.Opened> не предоставляет вам возможность отмены действия пользователя.  
  
<a name="routedEventInfo_ContextMenuOpening"></a>   
## <a name="routed-event-information"></a>Сведения о маршрутизируемом событии  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.ContextMenuOpeningEvent>|  
|Стратегия маршрутизации|Восходящая маршрутизация|  
|делегат|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
-   Переопределить <xref:System.Windows.FrameworkElement.OnContextMenuOpening%2A> реализовать обработчик класса для этого события в производных классах.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ContextMenuOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует направленное событие <see cref="E:System.Windows.FrameworkElement.ContextMenuOpening" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Идентификаторы перенаправленных событий создаются при их регистрации. Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события. Эти идентификаторы можно использовать для добавления обработчиков классов.  
  
 Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContextMenuProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContextMenuProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContextMenuProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ContextMenuProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет свойство зависимостей <see cref="P:System.Windows.FrameworkElement.ContextMenu" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public System.Windows.Input.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::Cursor ^ Cursor { System::Windows::Input::Cursor ^ get(); void set(System::Windows::Input::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Cursor : System.Windows.Input.Cursor with get, set" Usage="System.Windows.FrameworkElement.Cursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение или установка курсора, который отображается при наведении указателя мыши на этот элемент.</summary>
        <value>Отображаемый курсор. Значение по умолчанию определяется как <see langword="null" /> для данного свойства зависимостей. Однако на практике значение по умолчанию во время выполнения зависит от множества факторов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если это свойство задается в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] процессора полагается на преобразования типов для <xref:System.Windows.Input.Cursor> класса для вычисления строки. Должно быть введенная строка <xref:System.Windows.Input.CursorType> значение. Подробные сведения см. в разделе <xref:System.Windows.Input.Cursor>.  
  
 Ли курсор, как установить это свойство будет или не выводится, когда указатель мыши находится над данным элементом зависит также от значения <xref:System.Windows.FrameworkElement.ForceCursor%2A> свойство. Кроме того вопросы, связанные с событиями, как активное перетаскивание, захват мыши, режимы редактирования текста в элементы управления и т. д., также влияет на курсор с высоким приоритетом, чем значение, указанное в этом свойстве.  
  
 Чтобы отменить поведение этого свойства к стандартному, установите его в `null` еще раз.  
  
 `null` По умолчанию действительно означает, что определение практического значения курсора здесь отложено и должны быть получены из другого источника. Если представления без программных значений, из любого источника, курсор по умолчанию это визуально более [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] приложения будет стрелкой. Тем не менее, временных курсор изменяется не настроены для <xref:System.Windows.FrameworkElement.Cursor%2A> значения элементов, если они передаются. <xref:System.Windows.FrameworkElement.Cursor%2A> Свойство будет только отчет не значения null в случаях, где он фактически было задано, например посредством кода или стиль. Каждое движение указателя мыши над [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] приложение создает событие <xref:System.Windows.UIElement.QueryCursor> событий. Событие и любой элемент в маршруте имеет возможность обработать событие и установите для параметра курсора с помощью аргументов этого события. Это механизм обеспечивает визуальное отображение курсора в большинстве случаев. Если <xref:System.Windows.UIElement.QueryCursor> обработчик возвращает результат курсора, а затем тот факт, что событие обрабатывается и имеет измененное значение в аргументах имеет приоритет над значением <xref:System.Windows.FrameworkElement.Cursor%2A> свойство на любом уровне, если только не <xref:System.Windows.FrameworkElement.ForceCursor%2A> имеет значение.  
  
 Если не создается пользовательский курсор, вы обычно значение этого свойства значение статического свойства <xref:System.Windows.Input.Cursors> класса. Параметр <xref:System.Windows.FrameworkElement.Cursor%2A> в коде требуется одно из следующих:  
  
-   Вызовите <xref:System.Windows.Input.Cursor> конструктор, чтобы получить <xref:System.Windows.Input.Cursor> экземпляра. Оба подписи <xref:System.Windows.Input.Cursor> использовать конструктор потоков или файлов, в ближайшем будущем, для которого создается <xref:System.Windows.Input.Cursor> объект для пользовательский курсор.  
  
-   Используйте <xref:System.Windows.Input.CursorConverter> класса и его <xref:System.Windows.Input.CursorConverter.ConvertFrom%2A> метод для указания курсора по <xref:System.Windows.Input.CursorType>, или строку, которая может быть <xref:System.Windows.Input.CursorType>и приведите вернуться к <xref:System.Windows.Input.Cursor>.  
  
 Параметр <xref:System.Windows.Input.Cursor> пользовательское значение не включен в режиме частичного доверия. Дополнительные сведения о пользовательских курсоров, см. в разделе [Общие сведения о входных данных](~/docs/framework/wpf/advanced/input-overview.md).  
  
<a name="dependencyPropertyInfo_Cursor"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.CursorProperty>|  
|Значение свойства метаданных `true`|Нет|  
  
   
  
## Examples  
 Приведенный ниже показано, как намеренную установку графического изображения курсора.  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.QueryCursor" />
        <altmember cref="P:System.Windows.FrameworkElement.ForceCursor" />
        <altmember cref="P:System.Windows.Input.Mouse.OverrideCursor" />
      </Docs>
    </Member>
    <Member MemberName="CursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.CursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.CursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.Cursor" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContext">
      <MemberSignature Language="C#" Value="public object DataContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.DataContext" />
      <MemberSignature Language="VB.NET" Value="Public Property DataContext As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataContext { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataContext : obj with get, set" Usage="System.Windows.FrameworkElement.DataContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает контекст данных для элемента, участвующего в привязке данных.</summary>
        <value>Объект, используемый в качестве контекста данных.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *Контекст данных* — это понятие, позволяет элементам наследовать сведения от своих родительских элементов об источнике данных, который используется для привязки, а также другие характеристики привязки, например путь.  
  
 Контекст данных можно задать непосредственно в объект .NET с привязками, оценки свойств этого объекта. Кроме того, можно задать контекст данных <xref:System.Windows.Data.DataSourceProvider> объекта.  
  
 Это свойство зависимостей наследует значения свойств. Если существуют дочерние элементы без других значений для <xref:System.Windows.FrameworkElement.DataContext%2A> установленное при помощи локальных значений или стили, то система свойств будет задать значение должно быть <xref:System.Windows.FrameworkElement.DataContext%2A> значение ближайшего родительского элемента с назначенным данным значением.  
  
 Кроме того, можно использовать один из следующих свойств объекта <xref:System.Windows.Data.Binding> класс, чтобы явно указать источник привязки:
  
    - <xref:System.Windows.Data.Binding.ElementName%2A>.
    - <xref:System.Windows.Data.Binding.Source%2A>.
    - <xref:System.Windows.Data.Binding.RelativeSource%2A>. 
  
  Дополнительные сведения см. в разделе [Практическое руководство. Указание источника привязки](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md).  
  
 В XAML <xref:System.Windows.FrameworkElement.DataContext%2A> наиболее обычно устанавливается в виде <xref:System.Windows.Data.Binding> объявления. Можно использовать синтаксис элементов свойств или синтаксиса атрибутов. Синтаксис атрибутов показан в примере на этой странице. Код также можно использовать для задания <xref:System.Windows.FrameworkElement.DataContext%2A>.  
  
 <xref:System.Windows.FrameworkElement.DataContext%2A> является свойством привязки, чтобы облегчить ситуацию, где один контекст может быть привязана к другому. Тем не менее если выполняется привязка к <xref:System.Windows.FrameworkElement.DataContext%2A>, будьте внимательны, чтобы не создавать ссылки циклическая привязка (без привязки <xref:System.Windows.FrameworkElement.DataContext%2A> на себя, это можно сделать из-за характера наследования значения свойства <xref:System.Windows.FrameworkElement.DataContext%2A> свойство).  
  
<a name="xamlPropertyElementUsage_DataContext"></a>   
## <a name="xaml-property-element-usage"></a>Использование элемента свойства XAML  
  
```  
<object>  
  <object.DataContext>  
    <dataContextObject />  
  </object.DataContext>  
</object>  
```  
  
<a name="xamlAttributeUsage_DataContext"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object DataContext="bindingUsage"/>  
- or -  
<object DataContext="{resourceExtension contextResourceKey}"/>  
```  
  
<a name="xamlValues_DataContext"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *dataContextObject*  
 Непосредственно внедренный объект, который служит в качестве контекста данных для любых привязок внутри родительского элемента. Как правило, этот объект является <xref:System.Windows.Data.Binding> или другой <xref:System.Windows.Data.BindingBase> производного класса. Кроме того необработанные данные любого типа объекта, предназначенного для привязки здесь можно разместить, а фактические привязки, определенные позднее.  
  
 *bindingUsage*  
 Использование привязки, результатом вычисления которого в соответствующий контекст данных. Дополнительные сведения см. в разделе [Привязка расширения разметки](~/docs/framework/wpf/advanced/binding-markup-extension.md).  
  
 *ResourceExtension*  
 Одно из следующих: [ `StaticResource` ](~/docs/framework/wpf/advanced/staticresource-markup-extension.md) или [ `DynamicResource` ](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md). Такое использование используется при обращении к необработанным данным объектом, в ресурсах. См. в разделе [ресурсы XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *contextResourceKey*  
 Идентификатор ключа для запрашиваемого изнутри объекта <xref:System.Windows.ResourceDictionary>.  
  
<a name="dependencyPropertyInfo_DataContext"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.DataContextProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 В следующем примере показано, как действует контекст данных для привязки и предоставляет сведения, которые определяет конкретные значения связанных свойств.  
  
 [!code-xaml[MasterDetail#DataContextProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty)]  
[!code-xaml[MasterDetail#DataContextProperty2](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty2)]  
[!code-xaml[MasterDetail#DataContextProperty3](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler DataContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.DataContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataContextChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ DataContextChanged;" />
      <MemberSignature Language="F#" Value="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении контекста данных для элемента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Описание контекстов данных и привязки данных, см. в разделе [Общие сведения о привязке данных](~/docs/framework/wpf/data/data-binding-overview.md).  
  
> [!IMPORTANT]
>  Когда <xref:System.Windows.FrameworkElement.DataContext%2A> для изменения элемента, потенциально подвержены все свойства с привязкой к данным в этом элементе. Это относится к дочерние элементы текущего элемента в логическом дереве, наследующим контекст данных, все элементы, а также сам элемент. Все существующие привязки необходимо интерпретировать повторно новый <xref:System.Windows.FrameworkElement.DataContext%2A> и будут пересчитаны результаты привязки. Механизм привязки данных не является детерминированным о порядке эти повторные вычисления, относительно формирование <xref:System.Windows.FrameworkElement.DataContextChanged> событий. Повторные вычисления могут произойти до события, после события или в любом сочетании.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.DataContext" />
      </Docs>
    </Member>
    <Member MemberName="DataContextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DataContextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DataContextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.DataContextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DataContextProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ DataContextProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DataContextProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.DataContextProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.DataContext" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKey">
      <MemberSignature Language="C#" Value="protected internal object DefaultStyleKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.DefaultStyleKey" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property DefaultStyleKey As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Object ^ DefaultStyleKey { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultStyleKey : obj with get, set" Usage="System.Windows.FrameworkElement.DefaultStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает ключ, используемый для ссылки на стиль этого элемента управления, при использовании или определении тематических стилей.</summary>
        <value>Ключ стиля. Для правильной работы в процессе поиска тематического стиля, это значение должно быть <see cref="T:System.Type" /> элемента управления, к которому применяется стиль.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство обычно не задается через любой из его прямых методов доступа. Вместо этого каждый раз при создании нового переопределить метаданные определенного типа данного свойства зависимостей <xref:System.Windows.FrameworkElement> производного класса. При наследовании элемент управления, вызовите <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> метода <xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty> идентификатор в статическом конструкторе элемента управления производный класс (или эквивалентный класс инициализации).  
  
 Элемент управления обычно переопределяет значение по умолчанию этого свойства как свой собственный тип, но в некоторых случаях также может использовать базовый тип, для которого существует стиль в тематических словарей. Это целесообразно только шаблоны элементов управления базового элемента управления полностью определяют визуальное представление производного элемента управления, если любые дополнительные элементы, которые предоставляют производные типы не требуют дополнительных элементов как часть шаблона элемента управления.  
  
 Элемент или элемент управления, намеренно не использовать тематические стили, задайте <xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A> свойства `true`.  
  
<a name="dependencyPropertyInfo_DefaultStyleKey"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 В следующем примере показано использование переопределения метаданных свойства зависимостей, рассматриваемые в "Примечания". Этот код определяет класс пользовательского элемента управления `NumericUpDown` предназначен для использования из сборки библиотеку выделенного элемента управления. Иллюстрированные статический конструктор ссылается на некоторые закрытые функции инициализации, регистрирует обработчик класса (еще один распространенный сценарий создания подклассов элемента управления; см. описание [маркировка перенаправленных событий как обработанных и обработка классов](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)) и, наконец переопределяет <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> метаданные свойства зависимостей на `NumericUpDown` класса. <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> всегда возвращает собственный тип как предполагаемый ключ, который является соглашением, системой стиля темы для поиска стиля для некоторых произвольного элемента управления без стиля. Полный пример также определяет стиль темы элемента управления, на который ссылается этот ключ; см. в разделе [пользовательского элемента управления NumericUpDown с темой и пример Поддержка автоматизации пользовательского интерфейса](https://go.microsoft.com/fwlink/?LinkID=160025).  
  
 [!code-csharp[CustomControlNumericUpDown#StaticCtorOfCustomClassCommonTasks](~/samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp/CustomControlLibrary/NumericUpDown2.cs)]
 [!code-vb[CustomControlNumericUpDown#StaticCtorOfCustomClassCommonTasks](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic/customcontrollibrary/numericupdown2.vb)]  

  Полный исходный код для этого примера доступен на сайте GitHub для обоих [ C# ](https://github.com/dotnet/samples/tree/master/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp/CustomControlLibrary) и [Visual Basic](https://github.com/dotnet/samples/tree/master/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic/customcontrollibrary).

 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.OverridesDefaultStyle" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160025">Пользовательского элемента управления NumericUpDown с темой и пример Поддержка автоматизации пользовательского интерфейса</related>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKeyProperty">
      <MemberSignature Language="C#" Value="protected internal static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly static initonly class System.Windows.DependencyProperty DefaultStyleKeyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.DefaultStyleKeyProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared ReadOnly DefaultStyleKeyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="protected public: static initonly System::Windows::DependencyProperty ^ DefaultStyleKeyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultStyleKeyProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.DefaultStyleKeyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.DefaultStyleKey" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="frameworkElement.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Указывает на завершение процесса инициализации элемента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.Windows.FrameworkElement.BeginInit%2A> ранее был вызван, базовый реализация будет создавать <xref:System.Windows.FrameworkElement.Initialized> событий. В противном случае, если <xref:System.Windows.FrameworkElement.BeginInit%2A> не был вызван или не удалось определить ли <xref:System.Windows.FrameworkElement.BeginInit%2A> был вызван, <xref:System.Windows.FrameworkElement.Initialized> не возникает и вместо этого создается исключение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Windows.FrameworkElement.EndInit" /> был вызван без предварительного вызова метода <see cref="M:System.Windows.FrameworkElement.BeginInit" /> для элемента.</exception>
        <block subset="none" type="overrides"><para>Этот метод реализуется для обеспечения специальной обработки, которая может возникать при инициализации элемента в процессе его загрузки.  
  
Реализация должна вызывать базовую реализацию, так как реализация base (по умолчанию) устанавливает внутренние флаги для отслеживания инициализации.</para></block>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.FindName : string -&gt; obj" Usage="frameworkElement.FindName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Имя запрошенного элемента.</param>
        <summary>Находит элемент по указанному имени идентификатора.</summary>
        <returns>Запрошенный элемент. Это может быть значение <see langword="null" />, если соответствующий элемент не найден.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если элемент имеет дочерние элементы, эти дочерние элементы являются все выполняется рекурсивный поиск запрошенного именованного элемента.  
  
 <xref:System.Windows.FrameworkElement.FindName%2A> действует в пределах области видимости имен текущего элемента. Дополнительные сведения см. в разделе [области видимости имен XAML WPF](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.FrameworkElement.Name" />
        <related type="Article" href="https://msdn.microsoft.com/library/b7e61222-e8cf-48d2-acd0-6df3b7685d48">Атрибут x: Name</related>
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="frameworkElement.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Ключевой идентификатор запрашиваемого ресурса.</param>
        <summary>Осуществляет поиск ресурса с указанным ключом и вызывает исключение, если запрошенный ресурс не найден.</summary>
        <returns>Запрошенный ресурс. Если ресурс с указанным ключом не найден, выдается исключение. В случае исключение может быть также возвращено значение <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Если этот метод вызывается для ключа, который не удается найти, создается исключение. Если вы не хотите обрабатывать исключения, возникающие в результате вызова метода <xref:System.Windows.FrameworkElement.FindResource%2A>, вызовите <xref:System.Windows.FrameworkElement.TryFindResource%2A> вместо этого. <xref:System.Windows.FrameworkElement.TryFindResource%2A> Возвращает `null` когда не удается найти запрошенный ресурс и выдает исключение.  
  
 Если ресурс не найден в вызывающем элементе, родительским элементом в логическом дереве является выполняется дальнейший поиск, а затем приложение, а затем темы и наконец системных ресурсов. Этот метод поиска идентична как поиск в дереве, если по ссылке на динамический ресурс в разметке запрошенного ресурса. Дополнительные сведения о поиске ресурсов, см. в разделе [ресурсы XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 Как правило, вы сразу же привести <xref:System.Windows.FrameworkElement.FindResource%2A> возвращаемое значение к типу свойства, вы параметр со значением возвращаемым ресурсом.  
  
 Ключи ресурсов не обязательно являются строками. Например, стили для элементов управления на уровне темы намеренно соответствующие <xref:System.Type> элемента управления, а приложения или страницы стили для элементов управления этот параметр обычно используется ключ соглашение. Дополнительные сведения см. в разделе [Стилизация и использование шаблонов](~/docs/framework/wpf/controls/styling-and-templating.md) или [ресурсы XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
   
  
## Examples  
 Следующий пример получает именованный ресурс и приводит его к соответствующему типу для заполнения свойства.  
  
 [!code-csharp[PropertiesOvwSupport#ResourceProceduralGet](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page3.xaml.cs#resourceproceduralget)]
 [!code-vb[PropertiesOvwSupport#ResourceProceduralGet](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertiesOvwSupport/visualbasic/page3.xaml.vb#resourceproceduralget)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException"><paramref name="resourceKey" /> не найден, и обработчик событий для события <see cref="E:System.Windows.Threading.Dispatcher.UnhandledException" /> не существует.  
  
-или- 
 <paramref name="resourceKey" /> не найден, и свойство <see cref="P:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled" /> имеет значение <see langword="false" /> в событии <see cref="E:System.Windows.Threading.Dispatcher.UnhandledException" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceKey" /> — <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.FrameworkElement.TryFindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FlowDirection">
      <MemberSignature Language="C#" Value="public System.Windows.FlowDirection FlowDirection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.FlowDirection FlowDirection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.FlowDirection" />
      <MemberSignature Language="VB.NET" Value="Public Property FlowDirection As FlowDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::FlowDirection FlowDirection { System::Windows::FlowDirection get(); void set(System::Windows::FlowDirection value); };" />
      <MemberSignature Language="F#" Value="member this.FlowDirection : System.Windows.FlowDirection with get, set" Usage="System.Windows.FrameworkElement.FlowDirection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.FlowDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает направление, в котором текстовые и другие элементы [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] следуют в родительском элементе, определяющем их размещение.</summary>
        <value>Направление, в котором текстовые и другие элементы [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] следуют в родительском элементе, как значение перечисления. Значение по умолчанию — <see cref="F:System.Windows.FlowDirection.LeftToRight" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Наборы использования свойств зависимостей <xref:System.Windows.FrameworkElement.FlowDirection%2A> данного элемента. Благодаря наследованию значения свойства, задание <xref:System.Windows.FrameworkElement.FlowDirection%2A> на элементе потенциально можно задать <xref:System.Windows.FrameworkElement.FlowDirection%2A> на все дочерние элементы, которые не задали <xref:System.Windows.FrameworkElement.FlowDirection%2A> локально или менее другим способом, таким как стили.  
  
 Это свойство не задано автоматически как часть любого языка и региональных параметров сведений о приложении, так как элемент может содержать содержимое, которое не обязательно соблюдать направление Общая последовательность действий, содержится в разрешении региональными параметрами. Дополнительные сведения о глобализации см. в разделе [Глобализация для WPF](~/docs/framework/wpf/advanced/globalization-for-wpf.md).  
  
 Это свойство не определил [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] метод доступа к свойству, поэтому он функционирует как свойство зависимостей. Тем не менее он также регистрируется как подключенные, поэтому он также может работать как присоединенное свойство. Вложенная регистрация является главным образом, что поддерживается наследование значения свойства, но свойство также может использоваться как истинное вложенное свойство. Использование вложенного свойства применяется, только если вы хотите задать направление потока на объект имеет <xref:System.Windows.FrameworkElement> сам не является родительский элемент, который выполняет макета на нем <xref:System.Windows.FrameworkElement>и еще не содержит более явно определенным `FlowDirection` свойство. (Некоторые потока документов классы, такие как <xref:System.Windows.Documents.Block> и <xref:System.Windows.Documents.Inline> определять свои собственные `FlowDirection`, и это свойство можно также задать направление потока. Значение свойства затем считывается службой итоговой узла содержимого без необходимости использования присоединенных свойств.)  
  
<a name="xamlAttributeUsage_FlowDirection"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
 \<*object* **FlowDirection**="<xref:System.Windows.FlowDirection>"/>  
  
<a name="xamlTextUsage_FlowDirection"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Это свойство также может устанавливаться на классы, не являющиеся <xref:System.Windows.FrameworkElement> производные классы, ниже [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] прикрепленное свойство:  
  
 `<` *object* `FrameworkElement.`**FlowDirection**="<xref:System.Windows.FlowDirection>`"/>`  
  
<a name="dependencyPropertyInfo_FlowDirection"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.FlowDirectionProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 Это свойство является свойством зависимостей и присоединенным свойством; см. в разделе "Примечания".  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlowDirectionProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FlowDirectionProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FlowDirectionProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.FlowDirectionProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FlowDirectionProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FlowDirectionProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FlowDirectionProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.FlowDirectionProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.FlowDirection" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Style FocusVisualStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style FocusVisualStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.FocusVisualStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FocusVisualStyle As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ FocusVisualStyle { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FocusVisualStyle : System.Windows.Style with get, set" Usage="System.Windows.FrameworkElement.FocusVisualStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает свойство, позволяющее настройку внешнего вида, эффектов или других характеристик стиля, применяемых к данному элементу, когда он получает фокус клавиатуры.</summary>
        <value>Требуемый стиль для применения при получении фокуса. Значением по умолчанию, как объявлено в свойстве зависимостей, является пустой статический объект <see cref="T:System.Windows.Style" />. Тем не менее, действительным значением во время выполнения часто (но не всегда) является стиль, представленный поддержкой тем для элементов управления.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство влияет на внешний вид, но не сообщает о <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> в метаданных. Это, поскольку изменение внешнего вида основано на событиях и могут применяться не все время и поэтому не следует сообщать обычно любые сведения о visual или макета в метаданных.  
  
 По сути visual поведение фокуса, примененное к элементу управления, должно быть согласовано от элемента управления. Наиболее понятным способом применения согласованности является изменение визуального стиля фокуса только при составлении целой темы. Задание этого свойства для отдельных стилей управления, а не как частью темы не предполагаемое использование этого свойства, так как это может привести к путанице при использовании фокуса клавиатуры. Если планируется поведения элемента управления, которое намеренно не согласовано в рамках темы, гораздо лучшим подходом является использование триггеры в стилях для отдельных свойств состояния ввода, таких как <xref:System.Windows.UIElement.IsFocused%2A> или <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>и таким образом способом, который не поддерживает визуально повлиять на работу любого существующего визуального стиля фокуса. Дополнительные сведения о необходимым <xref:System.Windows.FrameworkElement.FocusVisualStyle%2A> и альтернативное сосредоточиться свойств, см. в разделе [Стилизация фокуса в элементах управления и FocusVisualStyle](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md).  
  
<a name="xamlAttributeUsage_FocusVisualStyle"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object FocusVisualStyle="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_FocusVisualStyle"></a>   
## <a name="xaml-property-element-usage"></a>Использование элемента свойства XAML  
  
<a name="xamlValues_FocusVisualStyle"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *ResourceExtension*  
 Одно из следующих:, или. См. в разделе [ресурсы XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *styleResourceKey*  
 Ключ, который идентифицирует запрашиваемый стиль. Ключ ссылается на существующий ресурс в <xref:System.Windows.ResourceDictionary>.  
  
> [!NOTE]
>  Синтаксис элемента свойства технически возможно, но не рекомендуется. См. в разделе [встроенные стили и шаблоны](~/docs/framework/wpf/advanced/inline-styles-and-templates.md). Ссылка на привязку с помощью [TemplateBinding](~/docs/framework/wpf/advanced/templatebinding-markup-extension.md) или <xref:System.Windows.Data.Binding> — также, возможно, но встречается редко.  
  
<a name="dependencyPropertyInfo_FocusVisualStyle"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.FocusVisualStyleProperty>|  
|Значение свойства метаданных `true`|Нет|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusVisualStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.FocusVisualStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusVisualStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusVisualStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FocusVisualStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.FocusVisualStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет свойство зависимостей <see cref="P:System.Windows.FrameworkElement.FocusVisualStyle" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursor">
      <MemberSignature Language="C#" Value="public bool ForceCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ForceCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ForceCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property ForceCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ForceCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ForceCursor : bool with get, set" Usage="System.Windows.FrameworkElement.ForceCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, следует ли данному <see cref="T:System.Windows.FrameworkElement" /> заставлять [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] визуализировать курсор, как объявлено свойством <see cref="P:System.Windows.FrameworkElement.Cursor" />.</summary>
        <value><see langword="true" />, если для презентации курсора, расположенного над данным элементом, принудительно используются текущие настройки <see cref="P:System.Windows.FrameworkElement.Cursor" /> для курсора (а также для всех дочерних элементов); в противном случае — <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если задано это свойство `true` переопределяют настройки курсора, установленные дочерними элементами. Поэтому в общем приложении это [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] может ввести в заблуждение пользователя, особенно в том случае, если дочерние элементы пытаются задавать курсоры. Параметр <xref:System.Windows.FrameworkElement.ForceCursor%2A> больше подходит в сценариях создания подклассов или композиции элемента управления.  
  
<a name="dependencyPropertyInfo_ForceCursor"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.ForceCursorProperty>|  
|Значение свойства метаданных `true`|Нет|  
  
   
  
## Examples  
 В следующем примере принудительно значение курсора.  
  
 [!code-xaml[ForceCursor#ForceCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/ForceCursor/CS/default.xaml#forcecursor)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="ForceCursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForceCursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForceCursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ForceCursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForceCursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForceCursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ForceCursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ForceCursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.ForceCursor" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetBindingExpression(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBindingExpression (dp As DependencyProperty) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ GetBindingExpression(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetBindingExpression : System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingExpression" Usage="frameworkElement.GetBindingExpression dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Целевой объект <see cref="T:System.Windows.DependencyProperty" />, из которого нужно получить привязку.</param>
        <summary>Возвращает <see cref="T:System.Windows.Data.BindingExpression" />, представляющий привязку к заданному свойству.</summary>
        <returns>Значение <see cref="T:System.Windows.Data.BindingExpression" />, если целевое свойство имеет активную привязку; в противном случае — значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Проверка возвращаемого значения для `null` — это метод, который можно использовать для определения, имеет ли свойство активную привязку.  
  
 Этот метод является лишь удобную оболочку вокруг <xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=nameWithType> метод. <xref:System.Windows.FrameworkElement.GetBindingExpression%2A> передает текущий экземпляр и `dp` параметр <xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Data.BindingOperations" />
      </Docs>
    </Member>
    <Member MemberName="GetFlowDirection">
      <MemberSignature Language="C#" Value="public static System.Windows.FlowDirection GetFlowDirection (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.FlowDirection GetFlowDirection(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetFlowDirection(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFlowDirection (element As DependencyObject) As FlowDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::FlowDirection GetFlowDirection(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetFlowDirection : System.Windows.DependencyObject -&gt; System.Windows.FlowDirection" Usage="System.Windows.FrameworkElement.GetFlowDirection element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FlowDirection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Элемент, для которого требуется возвратить <see cref="P:System.Windows.FrameworkElement.FlowDirection" />.</param>
        <summary>Получает значение присоединенного свойства <see cref="P:System.Windows.FrameworkElement.FlowDirection" /> указанного элемента <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>Запрошенное направление потока, как значение перечисления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Основная цель этого метода является поддержка синтаксиса присоединенного свойства для <xref:System.Windows.FrameworkElement.FlowDirection%2A> свойство, таким образом позволяя дочерних элементов заданного <xref:System.Windows.FrameworkElement> для указания направления потока для размещения в родительском элементе. Чтобы получить это значение в текущем <xref:System.Windows.FrameworkElement>, использовать прямые [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] доступа <xref:System.Windows.FrameworkElement.FlowDirection%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.FlowDirection" />
      </Docs>
    </Member>
    <Member MemberName="GetLayoutClip">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.Geometry GetLayoutClip (System.Windows.Size layoutSlotSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Geometry GetLayoutClip(valuetype System.Windows.Size layoutSlotSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetLayoutClip (layoutSlotSize As Size) As Geometry" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::Geometry ^ GetLayoutClip(System::Windows::Size layoutSlotSize);" />
      <MemberSignature Language="F#" Value="override this.GetLayoutClip : System.Windows.Size -&gt; System.Windows.Media.Geometry" Usage="frameworkElement.GetLayoutClip layoutSlotSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Geometry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="layoutSlotSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="layoutSlotSize">Размер части элемента, выполняющей визуальную презентацию.</param>
        <summary>Возвращает геометрию маски отсечения. Маска применяется при попытке системы структуры скомпоновать элемент, размер которого превышает доступное экранное пространство.</summary>
        <returns>Геометрия отсечения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поля вычитаются из `layoutSlotSize` как часть поведение системы макета.  
  
 Возвращаемая ссылка null указывает, что отсечение выполнено не будет. Реализация по умолчанию всегда возвращает `null` при <xref:System.Windows.UIElement.ClipToBounds%2A> является `false`. Этот метод переопределяет метод <xref:System.Windows.UIElement.GetLayoutClip%2A?displayProperty=nameWithType>. <xref:System.Windows.FrameworkElement> Реализация использует <xref:System.Windows.FrameworkElement.MaxHeight%2A> и <xref:System.Windows.FrameworkElement.MaxWidth%2A> в вычислениях. Несколько подклассы <xref:System.Windows.FrameworkElement> Переопределите этот метод еще раз. <xref:System.Windows.Documents.Adorner.GetLayoutClip%2A?displayProperty=nameWithType>, переопределяет всегда возвращают `null` поскольку декоративных элементов часто намеренно за пределы обычных границ. <xref:System.Windows.Controls.Canvas.GetLayoutClip%2A?displayProperty=nameWithType> и <xref:System.Windows.Controls.InkPresenter.GetLayoutClip%2A?displayProperty=nameWithType> возвращают `null` Если <xref:System.Windows.UIElement.ClipToBounds%2A> является `false`.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Реализация по умолчанию всегда возвращает <see langword="null" /> при <see cref="P:System.Windows.UIElement.ClipToBounds" /> является <see langword="false" />. Переопределений обычно ожидается для сохранения этого поведения, хотя существуют исключения, в зависимости от связи и назначения производного класса и его логику макета, в отличие от базового класса.</para></block>
        <altmember cref="P:System.Windows.UIElement.Clip" />
        <altmember cref="P:System.Windows.UIElement.ClipToBounds" />
      </Docs>
    </Member>
    <Member MemberName="GetTemplateChild">
      <MemberSignature Language="C#" Value="protected internal System.Windows.DependencyObject GetTemplateChild (string childName);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Windows.DependencyObject GetTemplateChild(string childName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetTemplateChild(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function GetTemplateChild (childName As String) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::Windows::DependencyObject ^ GetTemplateChild(System::String ^ childName);" />
      <MemberSignature Language="F#" Value="member this.GetTemplateChild : string -&gt; System.Windows.DependencyObject" Usage="frameworkElement.GetTemplateChild childName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="childName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="childName">Имя искомого дочернего элемента.</param>
        <summary>Возвращает именованный элемент в визуальном дереве объекта <see cref="T:System.Windows.Controls.ControlTemplate" />, для которого создан экземпляр.</summary>
        <returns>Запрошенный элемент. Может иметь значение <see langword="null" />, если элемента с запрошенным именем не существует.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Шаблоны в [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] имеют автономное области видимости имен. Это обусловлено шаблоны повторно используются, и любое имя, определенное в шаблоне не может оставаться уникальными, когда несколько экземпляров элемента управления, создать экземпляр его шаблона. Вызовите <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> метод для возврата ссылки на объекты, полученные из шаблона, после ее создания. Нельзя использовать <xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType> способ поиска элементов на основе шаблонов, так как <xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType> действует в более общей области, и нет подключения между <xref:System.Windows.Controls.ControlTemplate> классов самого и экземпляра шаблона, после его применения.  
  
 <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType> предоставляет ту же функцию, что этот метод. <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType> public, а не защищен, и использует правильный имен рекомендации, позволяющие получить доступ к шаблону в пределах элемента и поиска с именем элементов внутри него. Используйте <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType> при необходимости получения элемента за пределами его родительского элемента.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkTemplate.FindName(System.String,System.Windows.FrameworkElement)" />
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal override System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberSignature Language="F#" Value="override this.GetUIParentCore : unit -&gt; System.Windows.DependencyObject" Usage="frameworkElement.GetUIParentCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает альтернативный логический родительский объект для этого элемента при отсутствии визуального родительского объекта.</summary>
        <returns>Возвращает нечто, отличное от <see langword="null" />, каждый раз, когда реализация уровня инфраструктуры WPF этого метода имеет подключение без визуального родительского объекта.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод переопределяет метод <xref:System.Windows.UIElement.GetUIParentCore%2A?displayProperty=nameWithType>. Значение по умолчанию <xref:System.Windows.FrameworkElement> реализация возвращает ожидаемый одного визуального родительского объекта, это тот же результат, как получение <xref:System.Windows.FrameworkElement.Parent%2A> значение. Реализация производного класса может возвращать альтернативные родительские связи.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Parent" />
      </Docs>
    </Member>
    <Member MemberName="GetVisualChild">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.Visual GetVisualChild (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Visual GetVisualChild(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetVisualChild (index As Integer) As Visual" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::Visual ^ GetVisualChild(int index);" />
      <MemberSignature Language="F#" Value="override this.GetVisualChild : int -&gt; System.Windows.Media.Visual" Usage="frameworkElement.GetVisualChild index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Visual</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Отсчитываемый от нуля индекс запрошенного дочернего элемента коллекции.</param>
        <summary>Переопределяет <see cref="M:System.Windows.Media.Visual.GetVisualChild(System.Int32)" /> и возвращает дочерний элемент по указанному индексу из коллекции дочерних элементов.</summary>
        <returns>Запрошенный дочерний элемент. Не должен возвращать <see langword="null" />; если указанный индекс находится вне диапазона, создается исключение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В <xref:System.Windows.FrameworkElement> реализации только допустимый индекс равен нулю. Модель содержимого для <xref:System.Windows.FrameworkElement.GetVisualChild%2A> поддерживает ноль или один дочерний элемент, не коллекцию.  
  
   
  
## Examples  
 В следующем примере показано, как пользовательский декоративный элемент использует значения, объявленные с <xref:System.Windows.Media.VisualCollection> , он поддерживает для нескольких визуальных дочерних элементов. Эти значения передаются через переопределения <xref:System.Windows.FrameworkElement.VisualChildrenCount%2A> и <xref:System.Windows.FrameworkElement.GetVisualChild%2A>.  
  
 [!code-csharp[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverridespre)]
 [!code-vb[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverridespre)]  
[!code-csharp[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverrides)]
[!code-vb[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverrides)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Эта реализация допустимо только для элементов, которые не поддерживают более описательную коллекцию визуальных дочерних элементов. Любой элемент, который имеет такой коллекции необходимо переопределить этот метод и сопоставьте индекс с эквивалентным индексом в коллекции дочерних элементов, поддерживаемой данным элементом. Индекс в диапазоне от нуля до <see cref="P:System.Windows.FrameworkElement.VisualChildrenCount" /> (минус) должен возвращать допустимый элемент; любого другого индекса должен создать исключение out of range. Пример типа элемента, который поддерживает коллекцию дочерних и переопределяет <see cref="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)" /> для возврата нескольких возможных дочерних является <see cref="T:System.Windows.Controls.Panel" />.  
  
Реализация по умолчанию в <see cref="T:System.Windows.FrameworkElement" /> предполагает только один визуальный дочерний элемент. Любое значение, переданное <paramref name="index" /> Кроме нуль вызывает исключение, исключение. Некоторые стандартные элементы, например декораторы, графические элементы или элементы со специальными средствами визуализации, переопределяют <see cref="T:System.Windows.FrameworkElement" /> реализацию (реализация из промежуточных базовых классов). В некоторых реализациях по-прежнему принудительно один визуальный дочерний элемент, тогда как другие разрешают коллекцию.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Height">
      <MemberSignature Language="C#" Value="public double Height { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Height" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Height" />
      <MemberSignature Language="VB.NET" Value="Public Property Height As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Height { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Height : double with get, set" Usage="System.Windows.FrameworkElement.Height" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает предлагаемую высоту элемента.</summary>
        <value>Высота элемента в [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Значение по умолчанию — <see cref="F:System.Double.NaN" />. Это значение должно быть не меньше 0,0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Height%2A> является одним из трех свойств для записи на <xref:System.Windows.FrameworkElement> , укажите информацию о высоте. Два других <xref:System.Windows.FrameworkElement.MinHeight%2A> и <xref:System.Windows.FrameworkElement.MaxHeight%2A>. Если возникает конфликт между эти значения, порядок приложения для определения фактического высота является то, что первый <xref:System.Windows.FrameworkElement.MinHeight%2A> необходимо обработать, затем <xref:System.Windows.FrameworkElement.MaxHeight%2A>и, наконец, если он присутствует в рамках заданных границ, <xref:System.Windows.FrameworkElement.Height%2A>.  
  
 Если этот элемент является дочерним элементом в другой элемент, затем этому свойству присвоить значение подходит ли предлагаемое значение. Система макета, а также логику конкретного макета родительского элемента будет использовать значение качестве несвязанного ввода во время прохода разметки. На практике <xref:System.Windows.FrameworkElement> почти всегда является дочерним элементом еще; даже в том случае, при установке <xref:System.Windows.FrameworkElement.Height%2A> на <xref:System.Windows.Window>. (Для <xref:System.Windows.Window>, что значение используется при базовой моделью приложения устанавливает базовый отрисовки предположения, которые создают Hwnd, где размещено приложение.)  
  
 В дополнение к приемлемым <xref:System.Double> значения, это свойство также может быть <xref:System.Double.NaN?displayProperty=nameWithType>. Это, как указать поведение автоматического изменения размеров в коде. В [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] значение в строку «Auto» (без учета регистра) чтобы включить автоматическое изменение размеров. Автоматическое изменение размеров предполагает, что элемент заполнит доступную ему высоту. Тем не менее, обратите внимание, что определенные элементы управления передают значения по умолчанию через свои тематические стили по умолчанию, которые отключают автоматическое изменение размеров, если не нужно специально включить ее.  
  
 Возвращаемое значение этого свойства всегда является таким же, как любое значение, которое было задано. В свою очередь, значение <xref:System.Windows.FrameworkElement.ActualHeight%2A> могут отличаться. Это может произойти либо статически макет отклонить предполагаемый размер по какой-либо причине, или моментально. Сама система структуры работает асинхронно относительно набора в системе свойств <xref:System.Windows.FrameworkElement.Height%2A> и может не обработать конкретное изменение свойства размера еще.  
  
 Ограничения для значений на <xref:System.Double> с установленным значением <xref:System.Windows.ValidateValueCallback> механизм. Если вы попытаетесь указать недопустимое значение, создается исключение времени выполнения.  
  
 В дополнение к проверке подлинности, имеется значение недетерминированные верхней границы для <xref:System.Windows.FrameworkElement.Height%2A> , обеспечивается системой макета (это очень много, размер которых превышает <xref:System.Single.MaxValue?displayProperty=nameWithType> но меньше, чем <xref:System.Double.MaxValue?displayProperty=nameWithType>). Если вы превысите это ограничение, элемент не будет отображаться, и исключение не создается. Не устанавливайте <xref:System.Windows.FrameworkElement.Height%2A> значение значительно больше, чем максимальный размер любого возможного визуального дисплея, или может превысить эту недетерминированную верхнюю границу.  
  
<a name="xamlAttributeUsage_Height"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object Height="double"/>  
- or -  
<object Height="qualifiedDouble"/>  
- or -  
<object Height="Auto"/>  
```  
  
<a name="xamlValues_Height"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *double*  
 <xref:System.Double>  
  
 Строковое представление <xref:System.Double> значение, равное или больше 0,0. Сведения о верхней границе см. в разделе "Примечания". Это значение интерпретируется как [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] измерения. Строки не нужно явно указывать десятичных запятых. Для экземпляра значение `1` приемлемо.  
  
 *qualifiedDouble*  
 Объект *двойные* значение как описано выше, за которым следует один из следующих строк объявления единицы измерения: `px`, `in`, `cm`, `pt`.  
  
 `px` (по умолчанию) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` дюймах; 1 in == 96 точек  
  
 `cm` сантиметрах; 1см==(96/2,54) px  
  
 `pt` точках; 1точка==(96/72) px  
  
 **Auto**  
 Включает автоматическое определение размера. См. заметки.  
  
<a name="dependencyPropertyInfo_Height"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.HeightProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.ActualHeight" />
      </Docs>
    </Member>
    <Member MemberName="HeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.HeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable HeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.HeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.Height" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.HorizontalAlignment HorizontalAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.HorizontalAlignment HorizontalAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.HorizontalAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property HorizontalAlignment As HorizontalAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::HorizontalAlignment HorizontalAlignment { System::Windows::HorizontalAlignment get(); void set(System::Windows::HorizontalAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.HorizontalAlignment : System.Windows.HorizontalAlignment with get, set" Usage="System.Windows.FrameworkElement.HorizontalAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение или установка характеристик выравнивания по горизонтали, применяемых к этому элементу при его размещении в родительском элементе управления, например в панели или элементе управления элементами.</summary>
        <value>Параметр горизонтального выравнивания как значение перечисления. Значение по умолчанию — <see cref="F:System.Windows.HorizontalAlignment.Stretch" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Windows.FrameworkElement.Height%2A> и <xref:System.Windows.FrameworkElement.Width%2A> явно задано для элемента, эти измерения, более приоритетны во время структурирования и отменит типичный последствия параметр <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> для <xref:System.Windows.HorizontalAlignment.Stretch>.  
  
 <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> является [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] метод доступа свойства для Какова на самом деле свойство зависимостей. Это свойство определенная зависимость довольно часто имеет значение «по умолчанию» по-разному в подклассах элементов, в частности в элементах управления. Обычно это происходит в одном из двух способов: свойство зависимости регистрируется повторно для конкретного подкласса, но с разными метаданными для задания значения по умолчанию; или стиль по умолчанию применяется, который задает значение свойства зависимостей по-разному. Например, «по умолчанию» из <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> для <xref:System.Windows.Controls.Label> элемент управления будет <xref:System.Windows.HorizontalAlignment.Left>, даже если <xref:System.Windows.Controls.Label> наследует <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> непосредственно от <xref:System.Windows.FrameworkElement>. Это обусловлено тем, это значение было сброшено в качестве стиля по умолчанию <xref:System.Windows.Controls.Label>, в шаблоне стиля элемента управления.  
  
 <xref:System.Windows.Controls.Canvas> не используйте <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> при создании макета, так как <xref:System.Windows.Controls.Canvas> основывающаяся на абсолютном позиционировании.  
  
 Если наследуемые <xref:System.Windows.Controls.Label> или производных классов, <xref:System.Windows.Controls.Label> переопределяет значение по умолчанию этого свойства зависимостей, чтобы быть <xref:System.Windows.HorizontalAlignment.Left>.  
  
<a name="dependencyPropertyInfo_HorizontalAlignment"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.HorizontalAlignmentProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HorizontalAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HorizontalAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.HorizontalAlignmentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HorizontalAlignmentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HorizontalAlignmentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable HorizontalAlignmentProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.HorizontalAlignmentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.HorizontalAlignment" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InheritanceBehavior">
      <MemberSignature Language="C#" Value="protected internal System.Windows.InheritanceBehavior InheritanceBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.InheritanceBehavior InheritanceBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.InheritanceBehavior" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property InheritanceBehavior As InheritanceBehavior" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Windows::InheritanceBehavior InheritanceBehavior { System::Windows::InheritanceBehavior get(); void set(System::Windows::InheritanceBehavior value); };" />
      <MemberSignature Language="F#" Value="member this.InheritanceBehavior : System.Windows.InheritanceBehavior with get, set" Usage="System.Windows.FrameworkElement.InheritanceBehavior" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.InheritanceBehavior</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает пределы области видимости для наследования значений свойств, поиска ключей ресурсов и поиска RelativeSource FindAncestor.</summary>
        <value>Значение перечисления. Значение по умолчанию — <see cref="F:System.Windows.InheritanceBehavior.Default" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Определенные границы в элементе дерева набора <xref:System.Windows.FrameworkElement.InheritanceBehavior%2A> чтобы намеренно ограничить область поведение наследования, то поиск ресурсов force для проверки ресурсов приложения, или чтобы не дать поиска RelativeSource FindAncestor запрашивать текущий элемент или какого-либо другого. Также поиска RelativeSource FindAncestor происходит, когда привязка использует <xref:System.Windows.Data.RelativeSource> с его <xref:System.Windows.Data.RelativeSource.Mode%2A> свойству присвоено <xref:System.Windows.Data.RelativeSourceMode.FindAncestor?displayProperty=nameWithType> значение.  
  
 Производный класс и присвойте этому свойству следует это необходимо делать в статическом конструкторе или в других процедур инициализации.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Frame" />
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит во время инициализации данного <see cref="T:System.Windows.FrameworkElement" />. Данное событие совпадает со случаями, когда значение свойства <see cref="P:System.Windows.FrameworkElement.IsInitialized" /> изменяется с <see langword="false" /> (или неопределенного) на <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие будет вызывается при изменении <xref:System.Windows.FrameworkElement.EndInit%2A> или <xref:System.Windows.FrameworkElement.OnVisualParentChanged%2A> методы вызываются. Вызовы для любого из этих методов производятся из кода приложения или с помощью [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] поведение процессора при [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] обработки страницы.  
  
 Выбор режима обработки <xref:System.Windows.FrameworkElement.Loaded> или <xref:System.Windows.FrameworkElement.Initialized> зависит от требований. Если вам не нужно считывать свойства элементов, необходимо сбросить свойства и не обязательно все сведения о макете <xref:System.Windows.FrameworkElement.Initialized> лучше событие, с которым выполняется действие. Если вам нужен все свойства элемента доступны, и установка свойств, которые, скорее всего сбросить макет, <xref:System.Windows.FrameworkElement.Loaded> может быть лучше событий, с которым выполняется действие. Будьте внимательны повторного входа, если обработчик сбрасывает все свойства, которые интерпретируются системой макета, что имеется в виду, что новый проход макета является обязательным. (Может потребоваться проверить <xref:System.Windows.FrameworkPropertyMetadata> передавать значения для свойства, если вы не знаете свойства, которые может потребоваться новый макет, если они изменились.)  
  
 Дополнительные сведения о последовательности событий объекта для <xref:System.Windows.FrameworkElement>, а также нескольких связанных классах приложений и элементов, см. в разделе [события времени жизни объекта](~/docs/framework/wpf/advanced/object-lifetime-events.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.OnInitialized(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="InputScope">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputScope InputScope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputScope InputScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.InputScope" />
      <MemberSignature Language="VB.NET" Value="Public Property InputScope As InputScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputScope ^ InputScope { System::Windows::Input::InputScope ^ get(); void set(System::Windows::Input::InputScope ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InputScope : System.Windows.Input.InputScope with get, set" Usage="System.Windows.FrameworkElement.InputScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает контекст для входных данных, используемых этим элементом <see cref="T:System.Windows.FrameworkElement" />.</summary>
        <value>Область ввода, которая изменяет интерпретацию ввода с помощью альтернативных методов. Значение по умолчанию — <see langword="null" /> (что приводит к обработке команд по умолчанию).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство зависимостей наследует значения свойств. Если существуют дочерние элементы без других значений для <xref:System.Windows.FrameworkElement.InputScope%2A> установленное при помощи локальных значений или стили, то система свойств будет задать значение должно быть <xref:System.Windows.FrameworkElement.InputScope%2A> значение ближайшего предка элемента с назначенным данным значением.  
  
 Несмотря на то что [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] синтаксис использования указано и синтаксически разрешено, задание этого свойства [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] не часто.  
  
<a name="dependencyPropertyInfo_InputScope"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.InputScopeProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.InputScope" />
        <altmember cref="T:System.Windows.IInputElement" />
      </Docs>
    </Member>
    <Member MemberName="InputScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty InputScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty InputScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.InputScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InputScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ InputScopeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable InputScopeProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.InputScopeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.InputScope" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Windows.FrameworkElement.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, был ли инициализирован этот элемент — либо в ходе обработки процессором [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], либо путем явного вызова своего метода <see cref="M:System.Windows.FrameworkElement.EndInit" />.</summary>
        <value>Значение <see langword="true" />, если элемент инициализирован путем вышеупомянутой обработки [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] или вызовов метода; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство также может быть `true` Если этот элемент был перемещен в логическом дереве таким образом, он имеет новый родительский элемент и снова станет перегруженным.  
  
 Это свойство полезно, если вы также используете <xref:System.Windows.FrameworkElement.BeginInit%2A> и <xref:System.Windows.FrameworkElement.EndInit%2A>. Элементы в логическом дереве, загружаемой в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] процессора подтверждаются выдавшей их инициализации. Элементы не в логическом дереве инициализируются при <xref:System.Windows.FrameworkElement.EndInit%2A> вызывается. При отсутствии какой-либо определенной обработки из <xref:System.Windows.FrameworkElement.BeginInit%2A> и <xref:System.Windows.FrameworkElement.EndInit%2A>, это происходит сразу после завершения работы конструктор возвращает инициализированный результат.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.IsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoaded { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoaded : bool" Usage="System.Windows.FrameworkElement.IsLoaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, загружен ли данный элемент для презентации.</summary>
        <value><see langword="true" />, если текущий элемент присоединен к дереву элементов; <see langword="false" />, если элемент никогда не был присоединен к загруженному дереву элементов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Из только что созданной <xref:System.Windows.FrameworkElement>, это свойство начинается `false`и остается `true` после он становится равным `true`, даже если элемент исключен из подключенного логического дерева по коду. `true` состояние задается общей логикой презентации при загрузке элементов в механизм презентации.  
  
 Как правило, являются загруженных элементов, готовый для просмотра, но не все <xref:System.Windows.FrameworkElement> производные классы имеют презентации и другие свойства, такие как <xref:System.Windows.UIElement.Visibility%2A> могут повлиять на презентации.  
  
   
  
## Examples  
 В следующем примере реализуется два обработчика: один обрабатывает <xref:System.Windows.FrameworkElement.Loaded> событий корневого элемента, чтобы убедиться, что корневого элемента страницы загружается, потому что это значение события. Другой обработчик привязан к пользовательского элемента управления и вызовы <xref:System.Windows.FrameworkElement.IsLoaded%2A> чтобы убедиться, что корневой элемент загружается полностью. Оба обработчика вызова ту же функцию (не показан), будет заполнять дочерних элементов с помощью новых данных.  
  
 [!code-csharp[GroupBoxExample#FEIsLoaded](~/samples/snippets/csharp/VS_Snippets_Wpf/GroupBoxExample/CSharp/Page1.xaml.cs#feisloaded)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Language">
      <MemberSignature Language="C#" Value="public System.Windows.Markup.XmlLanguage Language { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Markup.XmlLanguage Language" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Language" />
      <MemberSignature Language="VB.NET" Value="Public Property Language As XmlLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Markup::XmlLanguage ^ Language { System::Windows::Markup::XmlLanguage ^ get(); void set(System::Windows::Markup::XmlLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Language : System.Windows.Markup.XmlLanguage with get, set" Usage="System.Windows.FrameworkElement.Language" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.XmlLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает сведения о языке локализации и глобализации, который применяется к элементу.</summary>
        <value>Сведения о языке для этого элемента. Значение по умолчанию — <see cref="T:System.Windows.Markup.XmlLanguage" />, и для его значения <see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /> задана строка гu-RU.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Строковые форматы соответствуют стандарту RFC 3066. Например США Английский — «en US». Дополнительные сведения о значениях и формате см. в разделе <xref:System.Windows.Markup.XmlLanguage>.  
  
 Это свойство зависимостей наследует значения свойств. Если существуют дочерние элементы без других значений для <xref:System.Windows.FrameworkElement.Language%2A> установленное при помощи локальных значений или стили, система свойств задаст значение должно быть <xref:System.Windows.FrameworkElement.Language%2A> значение ближайшего предка элемента с назначенным данным значением.  
  
 [!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)] Определяет общие значения `xml:lang` атрибута. <xref:System.Windows.FrameworkElement.Language%2A> по сути, открывает значение этого атрибута как свойство зависимостей. <xref:System.Windows.FrameworkElement.Language%2A> можно изменить программно и могут участвовать в наследование значения свойства системы способом, который работает так же как `xml:lang` может наследовать атрибут к дочерней элемент [!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)]. Если задать <xref:System.Windows.FrameworkElement.Language%2A>, это значение становится `xml:lang` и перезаписывает все предыдущие значения. Дополнительные сведения см. в разделе [XML: lang в XAML обработки](~/docs/framework/xaml-services/xml-lang-handling-in-xaml.md).  
  
<a name="dependencyPropertyInfo_CultureInfo"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.LanguageProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LanguageProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LanguageProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LanguageProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LanguageProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LanguageProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LanguageProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.LanguageProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.Language" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LayoutTransform">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Transform LayoutTransform { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Transform LayoutTransform" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.LayoutTransform" />
      <MemberSignature Language="VB.NET" Value="Public Property LayoutTransform As Transform" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Transform ^ LayoutTransform { System::Windows::Media::Transform ^ get(); void set(System::Windows::Media::Transform ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LayoutTransform : System.Windows.Media.Transform with get, set" Usage="System.Windows.FrameworkElement.LayoutTransform" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Transform</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает графическое преобразование, которое применяется к элементу при изменении параметров размещения.</summary>
        <value>Преобразование, которое должен использовать данный элемент. Значение по умолчанию — <see cref="P:System.Windows.Media.Transform.Identity" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В отличие от к <xref:System.Windows.UIElement.RenderTransform%2A>, <xref:System.Windows.FrameworkElement.LayoutTransform%2A> повлияет на результаты макета.  
  
 Задание преобразования предоставляет мощные возможности масштабирования и вращения. Тем не менее <xref:System.Windows.FrameworkElement.LayoutTransform%2A> игнорирует <xref:System.Windows.Media.TranslateTransform> операций. Это обусловлено тем, поведение системы макета для дочерних элементов <xref:System.Windows.FrameworkElement> автоматически исправляет любые смещения расположения элемента масштабированный и повернутый с макетом и системы координат родительского элемента.  
  
 <xref:System.Windows.FrameworkElement.LayoutTransform%2A> может привести к ухудшению производительности приложения, если ее можно вызвать в сценарии, который не требуется полный проход системы макета. При применении <xref:System.Windows.FrameworkElement.LayoutTransform%2A> для <xref:System.Windows.Controls.Panel.Children%2A> коллекцию <xref:System.Windows.Controls.Panel>, оно активирует новый проход системы макета и заставляет все объекты на экране необходимо повторно измерить и упорядочить. Если вы обновляете полное приложение [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)], эта функция может оказаться именно то, что вам нужно. Тем не менее, если не требуется полная передача макета, используйте <xref:System.Windows.UIElement.RenderTransform%2A> свойство, которое не вызывает систему макета и, как правило, лучшим выбором для этого сценария.  
  
 Примеры сценариев где <xref:System.Windows.FrameworkElement.LayoutTransform%2A> может быть полезно, включают: поворот элементов, таких как компоненты меню с горизонтального на вертикальное или наоборот, масштабирование элементы (увеличивать) при получении фокуса, предоставляя возможность редактирования и т. д.  
  
<a name="dependencyPropertyInfo_LayoutTransform"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.LayoutTransformProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 В следующем примере показано, как применить <xref:System.Windows.FrameworkElement.LayoutTransform%2A> на элемент. В примере создается экземпляр <xref:System.Windows.Controls.Button> и размещает его в родительском элементе <xref:System.Windows.Controls.Grid>. Он также использует <xref:System.Windows.FrameworkElement.LayoutTransform%2A> свойство для применения <xref:System.Windows.Media.RotateTransform> для <xref:System.Windows.Controls.Button>.  
  
 [!code-cpp[LayoutTransform#1](~/samples/snippets/cpp/VS_Snippets_Wpf/LayoutTransform/CPP/LayoutTransform.cpp#1)]
 [!code-csharp[LayoutTransform#1](~/samples/snippets/csharp/VS_Snippets_Wpf/LayoutTransform/CSharp/LayoutTransform.cs#1)]
 [!code-vb[LayoutTransform#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/LayoutTransform/VisualBasic/LayoutTransform.vb#1)]
 [!code-xaml[LayoutTransform#1](~/samples/snippets/xaml/VS_Snippets_Wpf/LayoutTransform/XAML/default.xaml#1)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=158252">Пример двумерных преобразований</related>
      </Docs>
    </Member>
    <Member MemberName="LayoutTransformProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LayoutTransformProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LayoutTransformProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LayoutTransformProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LayoutTransformProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LayoutTransformProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LayoutTransformProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.LayoutTransformProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.LayoutTransform" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Loaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Loaded;" />
      <MemberSignature Language="F#" Value="member this.Loaded : System.Windows.RoutedEventHandler " Usage="member this.Loaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, если элемент размещен, отрисован и готов к взаимодействию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Loaded> Обычно последнее событие возникает в последовательности инициализации элемента. Всегда будет вызываться после <xref:System.Windows.FrameworkElement.Initialized>. Выбор режима обработки <xref:System.Windows.FrameworkElement.Loaded> или <xref:System.Windows.FrameworkElement.Initialized> зависит от требований. Если вам не нужно считывать свойства элементов, необходимо сбросить свойства и не обязательно все сведения о макете <xref:System.Windows.FrameworkElement.Initialized> лучше событие, с которым выполняется действие. Если вам нужен все свойства элемента доступны, и установка свойств, которые, скорее всего сбросить макет, <xref:System.Windows.FrameworkElement.Loaded> может быть лучше событий, с которым выполняется действие. Будьте внимательны повторного входа, если обработчик сбрасывает все свойства, которые интерпретируются системой макета, что имеется в виду, что новый проход макета является обязательным. (Может потребоваться проверить <xref:System.Windows.FrameworkPropertyMetadata> передавать значения для свойства, если вы не знаете свойства, которые может потребоваться новый макет, если они изменились.)  
  
 Дополнительные сведения о последовательности событий объекта для <xref:System.Windows.FrameworkElement>, а также нескольких связанных классах приложений и элементов, см. в разделе [события времени жизни объекта](~/docs/framework/wpf/advanced/object-lifetime-events.md).  
  
 События с прямой маршрутизацией не выполняйте маршрут, они обрабатываются только внутри элемента, на котором они вызываются. Прямые перенаправленные события поддерживают другие поведения перенаправленного события: они поддерживают коллекцию доступных обработчиков и могут использоваться в качестве <xref:System.Windows.EventTrigger> в стиле.  
  
 <xref:System.Windows.FrameworkElement.Loaded> и <xref:System.Windows.FrameworkElement.Unloaded> оба возникающие в элементах управления, в результате изменения темы системы, инициированного пользователем. Изменение темы делает недействительность шаблон элемента управления и автономной визуальное дерево, которое в свою очередь вызывает весь элемент управления для выгрузки и повторной загрузки. Таким образом <xref:System.Windows.FrameworkElement.Loaded> нельзя предполагать, происходят только при первой загрузке страницы посредством перемещения на страницу.  
  
<a name="routedEventInfo_Loaded"></a>   
## <a name="routed-event-information"></a>Сведения о маршрутизируемом событии  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.LoadedEvent>|  
|Стратегия маршрутизации|Direct|  
|делегат|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" />
      </Docs>
    </Member>
    <Member MemberName="LoadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LoadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LoadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LoadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LoadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LoadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LoadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.LoadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует направленное событие <see cref="E:System.Windows.FrameworkElement.Loaded" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Идентификаторы перенаправленных событий создаются при их регистрации. Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события. Эти идентификаторы можно использовать для добавления обработчиков классов.  
  
 Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.FrameworkElement.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает перечислитель для логических дочерних элементов данного элемента.</summary>
        <value>Перечислитель для логических дочерних элементов данного элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.LogicalChildren%2A> позволяет выполнять итерацию по дочерним элементам. Это полезно для элементов, которые могут не определен, выделенную коллекцию, но по-прежнему содержать более одного дочернего элемента, особенно <xref:System.Windows.FrameworkContentElement> дочерних элементов.  
  
 Дополнительные сведения об использовании <xref:System.Windows.FrameworkElement.LogicalChildren%2A> и <xref:System.Windows.FrameworkElement.AddLogicalChild%2A>, см. в разделе [деревья в WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/c5358e14-d24c-44c7-b5eb-6062a4fd981c">Расширение разметки x:Array</related>
      </Docs>
    </Member>
    <Member MemberName="Margin">
      <MemberSignature Language="C#" Value="public System.Windows.Thickness Margin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Thickness Margin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Margin" />
      <MemberSignature Language="VB.NET" Value="Public Property Margin As Thickness" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Thickness Margin { System::Windows::Thickness get(); void set(System::Windows::Thickness value); };" />
      <MemberSignature Language="F#" Value="member this.Margin : System.Windows.Thickness with get, set" Usage="System.Windows.FrameworkElement.Margin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Thickness</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение внешнего поля элемента.</summary>
        <value>Предоставляет значения полей для элемента. Значение по умолчанию — <see cref="T:System.Windows.Thickness" />. Все свойства равны 0 (нулю).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поле — это пространство между данным элементом и другим элементам, которые будет размещаться рядом, когда создает макет [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]. Общие элементы могут быть одноранговыми (например, другие элементы в коллекции общего родительского элемента управления) или может быть родительским для данного элемента.  
  
 <xref:System.Windows.FrameworkElement.Margin%2A> задается как <xref:System.Windows.Thickness> структуры, а не как число, чтобы поле можно задать асимметрично. <xref:System.Windows.Thickness> Сама структура поддерживает преобразования типов строковых, можно указать асимметричный <xref:System.Windows.FrameworkElement.Margin%2A> в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] также синтаксис атрибута.  
  
 Ненулевое значение поля применяет пространство за пределами макет элемента <xref:System.Windows.FrameworkElement.ActualWidth%2A> и <xref:System.Windows.FrameworkElement.ActualHeight%2A>.  
  
 Поля являются аддитивными для одноуровневых элементов в макете; Например два соседних элемента, установленные с границей 30 в соседней edge бы 60 единиц пробела между ними.  
  
 Элементы, которые заданы поля обычно не ограничивают размер указанного <xref:System.Windows.FrameworkElement.Margin%2A> если выделенное прямоугольное пространство недостаточно велик для поля, а также область содержимого элемента. Область содержимого элемента будет ограничен вместо этого при вычислении макета. Единственный случай, где будет ограничиваться поля также — если содержимое уже ограничен вплоть до нуля.  
  
<a name="xamlAttributeUsage_Margin"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object Margin="left,top,right,bottom"/>  
- or -  
<object Margin="left,top"/>  
- or -  
<object Margin="thicknessReference"/>  
```  
  
<a name="xamlPropertyElementUsage_Margin"></a>   
## <a name="xaml-property-element-usage"></a>Использование элемента свойства XAML  
  
```  
<object>  
  <object.Margin>  
    <Thickness Left="left" Top="top" Right="right" Bottom="bottom"/>  
  </object.Margin>  
</object>  
```  
  
<a name="xamlValues_Margin"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *слева, сверху, справа, снизу*  
 Числовые значения между 0 и <xref:System.Double.PositiveInfinity> , указать четыре возможных измерений свойства <xref:System.Windows.Thickness> структуры.  
  
 Использование атрибута также примет сокращенные значения, которые применяются в указанном порядке, симметрично и логически. Например `Margin="20"` будет интерпретироваться <xref:System.Windows.Thickness> со всеми свойствами, значение 20. `Margin="20,50"` будет интерпретироваться <xref:System.Windows.Thickness> с <xref:System.Windows.Thickness.Left%2A> и <xref:System.Windows.Thickness.Right%2A> значение 20, и <xref:System.Windows.Thickness.Top%2A> и <xref:System.Windows.Thickness.Bottom%2A> значение 50.  
  
 Единица измерения по умолчанию для <xref:System.Windows.Thickness> мера [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]. Также можно указать другие единицы измерения путем добавления строк Тип единицы измерения `cm`, `in`, или `pt` к любой величине.  
  
 Число значений, указанных как [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] атрибуты не требуется указывать десятичные точки (0 приемлемо, не обязательно должен быть представлен в виде 0,0). Дополнительные сведения о [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] использования, см. в разделе <xref:System.Windows.Thickness>.  
  
 *thicknessReference*  
 Ссылка на объект в существующий <xref:System.Windows.Thickness>. Это может быть `}`, или `}` ссылки. Дополнительные сведения о [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] использования, см. в разделе <xref:System.Windows.Thickness>.  
  
<a name="dependencyPropertyInfo_Margin"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.MarginProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Thickness" />
      </Docs>
    </Member>
    <Member MemberName="MarginProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MarginProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MarginProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MarginProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MarginProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MarginProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MarginProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MarginProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.Margin" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxHeight">
      <MemberSignature Language="C#" Value="public double MaxHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MaxHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MaxHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MaxHeight { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MaxHeight : double with get, set" Usage="System.Windows.FrameworkElement.MaxHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение или установка максимально допустимой высоты элемента.</summary>
        <value>Максимальная высота элемента в [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Значение по умолчанию — <see cref="F:System.Double.PositiveInfinity" />. Это значение может быть больше или равно 0,0. Значение <see cref="F:System.Double.PositiveInfinity" /> также допустимо.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это один из трех свойств на <xref:System.Windows.FrameworkElement> , укажите информацию о высоте. Два других <xref:System.Windows.FrameworkElement.MinHeight%2A> и <xref:System.Windows.FrameworkElement.Height%2A>.  Если возникает конфликт между этими значениями, порядок приложения для определения фактического Высота первого <xref:System.Windows.FrameworkElement.MinHeight%2A> необходимо обработать, затем <xref:System.Windows.FrameworkElement.MaxHeight%2A>и, наконец, если каждый из них выходят за границы, <xref:System.Windows.FrameworkElement.Height%2A>.  
  
 Ограничения для значений на <xref:System.Double> с установленным значением <xref:System.Windows.ValidateValueCallback> механизм. Если вы попытаетесь указать недопустимое значение создается исключение времени выполнения.  
  
<a name="xamlAttributeUsage_MaxHeight"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object MaxHeight="double"/>  
- or -  
<object MaxHeight ="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MaxHeight"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *double*  
 <xref:System.Double>  
  
 Строковое представление <xref:System.Double> значение, равное или больше 0,0. Это значение интерпретируется как [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] измерения. Строки не нужно явно указывать десятичных запятых. Для экземпляра значение `1` приемлемо.  
  
 Же <xref:System.Double> применяются ограничения диапазона, как упоминалось в разделе значение свойства, за исключением того, что необходимо использовать [расширение разметки x: Static](~/docs/framework/xaml-services/x-static-markup-extension.md) необходимо явно задать значение должно быть <xref:System.Double.PositiveInfinity>.  
  
 *qualifiedDouble*  
 Объект *двойные* значение как описано выше, за которым следует один из следующих строк объявления единицы измерения: `px`, `in`, `cm`, `pt`.  
  
 `px` (по умолчанию) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` дюймах; 1 in == 96 точек  
  
 `cm` сантиметрах; 1см==(96/2,54) px  
  
 `pt` точках; 1точка==(96/72) px  
  
<a name="dependencyPropertyInfo_MaxHeight"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.MaxHeightProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MaxHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MaxHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MaxHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MaxHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MaxHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MaxHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MaxHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.MaxHeight" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxWidth">
      <MemberSignature Language="C#" Value="public double MaxWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MaxWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MaxWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MaxWidth { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MaxWidth : double with get, set" Usage="System.Windows.FrameworkElement.MaxWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение или установка максимально допустимой ширины элемента.</summary>
        <value>Максимальная ширина элемента в [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Значение по умолчанию — <see cref="F:System.Double.PositiveInfinity" />. Это значение может быть больше или равно 0,0. Значение <see cref="F:System.Double.PositiveInfinity" /> также допустимо.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это один из трех свойств на <xref:System.Windows.FrameworkElement> , укажите сведения ширины. Два других <xref:System.Windows.FrameworkElement.MinWidth%2A> и <xref:System.Windows.FrameworkElement.Width%2A>. Если возникает конфликт между этими значениями, порядок приложения для определения фактическую ширину первого <xref:System.Windows.FrameworkElement.MinWidth%2A> необходимо обработать, затем <xref:System.Windows.FrameworkElement.MaxWidth%2A>и, наконец, если каждый из них выходят за границы, <xref:System.Windows.FrameworkElement.Width%2A>.  
  
 Ограничения для значений на <xref:System.Double> с установленным значением <xref:System.Windows.ValidateValueCallback> механизм. Если вы попытаетесь указать недопустимое значение, создается исключение времени выполнения.  
  
<a name="xamlAttributeUsage_MaxWidth"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object MaxWidth="double"/>  
- or -  
<object MaxWidth="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MaxWidth"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *double*  
 <xref:System.Double>  
  
 Строковое представление <xref:System.Double> значение, равное или больше 0,0. Это значение интерпретируется как [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] измерения. Строки не нужно явно указывать десятичных запятых. Для экземпляра значение `1` приемлемо.  
  
 Же <xref:System.Double> применяются ограничения диапазона, как упоминалось в разделе значение свойства, за исключением того, что необходимо использовать [расширение разметки x: Static](~/docs/framework/xaml-services/x-static-markup-extension.md) задаваемое значение должно быть <xref:System.Double.PositiveInfinity>.  
  
 *qualifiedDouble*  
 Объект *двойные* значение как описано выше, за которым следует один из следующих строк объявления единицы измерения: `px`, `in`, `cm`, `pt`.  
  
 `px` (по умолчанию) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` дюймах; 1 in == 96 точек  
  
 `cm` сантиметрах; 1см==(96/2,54) px  
  
 `pt` точках; 1точка==(96/72) px  
  
<a name="dependencyPropertyInfo_MaxWidth"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.MaxWidthProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MaxWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MaxWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MaxWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MaxWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MaxWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MaxWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MaxWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.MaxWidth" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureCore">
      <MemberSignature Language="C#" Value="protected override sealed System.Windows.Size MeasureCore (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureCore(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MeasureCore(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function MeasureCore (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureCore(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="override this.MeasureCore : System.Windows.Size -&gt; System.Windows.Size" Usage="frameworkElement.MeasureCore availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">Доступный размер, который родительский элемент может предоставить дочерним элементам.</param>
        <summary>Реализует базовое поведение системы макета на этапе измерения для <see cref="T:System.Windows.FrameworkElement" />.</summary>
        <returns>Желательный размер этого элемента в макете.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод переопределяет <xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=nameWithType> подключения уровня ядра WPF и реализации мер макетов уровня среды WPF. <xref:System.Windows.FrameworkElement> Метод запечатывает реализацию. Для настройки измерения проход макета любого элемента, который основан на уровне среды WPF, переопределить <xref:System.Windows.FrameworkElement.MeasureOverride%2A> вместо этого. Для настройки на меру передачи поведение макета элемента, который намеренно не зависят от уровня среды WPF или используйте <xref:System.Windows.FrameworkElement>, переопределить <xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Size MeasureOverride (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function MeasureOverride (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Size MeasureOverride(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="abstract member MeasureOverride : System.Windows.Size -&gt; System.Windows.Size&#xA;override this.MeasureOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="frameworkElement.MeasureOverride availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">Доступный размер, который этот элемент может предоставить дочерним элементам. Можно задать бесконечное значение, указав таким образом, что элемент будет масштабироваться в соответствии с любым содержимым.</param>
        <summary>При переопределении в производном классе измеряет размер в структуре, требуемый для дочерних элементов, и определяет размер для класса, производного от <see cref="T:System.Windows.FrameworkElement" />.</summary>
        <returns>Размер, определяемый данным элементом для своих потребностей во время структурирования на основе вычисления размеров дочерних элементов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Переопределить <xref:System.Windows.FrameworkElement.MeasureOverride%2A> для реализации пользовательского макета размеров для элемента, которое участвует в [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] системы макета. Реализация должна делать следующее:  
  
1.  Итерации этого элемента определенной коллекции дочерних элементов, которые являются частью макета, вызов <xref:System.Windows.UIElement.Measure%2A> для каждого дочернего элемента.  
  
2.  Сразу же получите <xref:System.Windows.UIElement.DesiredSize%2A> дочерних элементов (он задается как свойство после <xref:System.Windows.UIElement.Measure%2A> вызывается).  
  
3.  Вычислений net требуемый размер родительского элемента на основе измерения из дочерних элементов.  
  
 Возвращаемое значение <xref:System.Windows.FrameworkElement.MeasureOverride%2A> должен быть собственный требуемого размер элемента, который затем становится входных данных для родительского элемента текущего элемента меры. Этот процесс продолжается по система макета, пока не будет достигнут корневой элемент страницы.  
  
 В ходе этого процесса дочерних элементов может возвращать более крупный <xref:System.Windows.UIElement.DesiredSize%2A> размер, чем начального `availableSize` указать, что дочерний элемент больше места. Это может быть обработано в собственную реализацию путем введения прокручиваемой области, путем изменения размеров родительского элемента управления путем создания каким-либо образом заказа с накоплением или любое количество решений для измерения или компоновки содержимого.  
  
> [!IMPORTANT]
>  Элементы должны вызывать <xref:System.Windows.UIElement.Measure%2A> на каждом дочернем во время этого процесса, в противном случае дочерние элементы не будет правильно размера или упорядочены.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>В следующем коде некомпилируемый показано эта схема реализации.  <c>VisualChildren</c> представляет свойство перечисляемую коллекцию дочерних элементов, которые необходимо определить собственного элемента. Свойство может быть присвоено любое имя. <c>VisualChildren</c> является именем-заполнителем для целей этого примера <c>VisualChildren</c> не [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] предоставленный [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] или его части шаблону именования. 
  
[! code-csharp[CorePseudocode #FEMeasureOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#femeasureoverride)] [! код vb[CorePseudocode #FEMeasureOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#femeasureoverride)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="MinHeight">
      <MemberSignature Language="C#" Value="public double MinHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MinHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MinHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property MinHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MinHeight { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MinHeight : double with get, set" Usage="System.Windows.FrameworkElement.MinHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение или установка минимально допустимой высоты элемента.</summary>
        <value>Минимальная высота элемента в [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Значение по умолчанию — 0,0. Это значение может быть больше или равно 0,0. Однако <see cref="F:System.Double.PositiveInfinity" /> и <see cref="F:System.Double.NaN" /> являются недопустимыми.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это один из трех свойств на <xref:System.Windows.FrameworkElement> , укажите информацию о высоте.  Два других <xref:System.Windows.FrameworkElement.Height%2A> и <xref:System.Windows.FrameworkElement.MaxHeight%2A>. Если возникает конфликт между этими значениями, порядок приложения для определения фактического Высота первого <xref:System.Windows.FrameworkElement.MinHeight%2A> необходимо обработать, затем <xref:System.Windows.FrameworkElement.MaxHeight%2A>и, наконец, если каждый из них выходят за границы, <xref:System.Windows.FrameworkElement.Height%2A>.  
  
 Ограничения для значений на <xref:System.Double> с установленным значением <xref:System.Windows.ValidateValueCallback> механизм. Если вы попытаетесь указать недопустимое значение, создается исключение времени выполнения.  
  
<a name="xamlAttributeUsage_MinHeight"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object MinHeight="double"/>  
- or -  
<object MinHeight="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MinHeight"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *double*  
 <xref:System.Double>  
  
 Строковое представление <xref:System.Double> значение, равное или больше 0,0. Это значение интерпретируется как [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] измерения. Строки не нужно явно указывать десятичных запятых. Для экземпляра значение `1` приемлемо.  
  
 Же <xref:System.Double> ограничения диапазона, как упоминалось в разделе значение свойства.  
  
 *qualifiedDouble*  
 Объект *двойные* значение как описано выше, за которым следует один из следующих строк объявления единицы измерения: `px`, `in`, `cm`, `pt`.  
  
 `px` (по умолчанию) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` дюймах; 1 in == 96 точек  
  
 `cm` сантиметрах; 1см==(96/2,54) px  
  
 `pt` точках; 1точка==(96/72) px  
  
<a name="dependencyPropertyInfo_MinHeight"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.MinHeightProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MinHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MinHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MinHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MinHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MinHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MinHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MinHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.MinHeight" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinWidth">
      <MemberSignature Language="C#" Value="public double MinWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MinWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MinWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MinWidth { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MinWidth : double with get, set" Usage="System.Windows.FrameworkElement.MinWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение или установка минимально допустимой ширины элемента.</summary>
        <value>Минимальная ширина элемента в [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Значение по умолчанию — 0,0. Это значение может быть больше или равно 0,0. Однако <see cref="F:System.Double.PositiveInfinity" /> и <see cref="F:System.Double.NaN" /> являются недопустимыми.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это один из трех свойств на <xref:System.Windows.FrameworkElement> , укажите сведения ширины.  Два других <xref:System.Windows.FrameworkElement.Width%2A> и <xref:System.Windows.FrameworkElement.MaxWidth%2A>.  Если возникает конфликт между этими значениями, порядок приложения для определения фактическую ширину первого <xref:System.Windows.FrameworkElement.MinWidth%2A> необходимо обработать, затем <xref:System.Windows.FrameworkElement.MaxWidth%2A>и, наконец, если каждый из них выходят за границы, <xref:System.Windows.FrameworkElement.Width%2A>.  
  
 Ограничения для значений на <xref:System.Double> с установленным значением <xref:System.Windows.ValidateValueCallback> механизм. Если вы попытаетесь указать недопустимое значение, создается исключение времени выполнения.  
  
<a name="xamlAttributeUsage_MinWidth"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object MinWidth="double"/>  
- or -  
<object MinWidth="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MinWidth"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *double*  
 <xref:System.Double>  
  
 Строковое представление <xref:System.Double> значение, равное или больше 0,0. Это значение интерпретируется как [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] измерения. Строки не нужно явно указывать десятичных запятых. Для экземпляра значение `1` приемлемо.  
  
 Же <xref:System.Double> ограничения диапазона, как упоминалось в разделе значение свойства.  
  
 *qualifiedDouble*  
 Объект *двойные* значение как описано выше, за которым следует один из следующих строк объявления единицы измерения: `px`, `in`, `cm`, `pt`.  
  
 `px` (по умолчанию) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` дюймах; 1 in == 96 точек  
  
 `cm` сантиметрах; 1см==(96/2,54) px  
  
 `pt` точках; 1точка==(96/72) px  
  
<a name="dependencyPropertyInfo_MinWidth"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.MinWidthProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MinWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MinWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MinWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MinWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MinWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MinWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MinWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.MinWidth" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="override this.MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool" Usage="frameworkElement.MoveFocus request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">Направление, в котором перемещается фокус, в виде значения перечисления.</param>
        <summary>Перемещает клавиатурный фокус от данного элемента на другой элемент в указанном направлении обхода.</summary>
        <returns>Возвращает значение <see langword="true" />, если фокус успешно перемещен; <see langword="false" />, если целевого элемента в указанном направлении не существует или на него нельзя установить клавиатурный фокус.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта реализация переопределяет <xref:System.Windows.UIElement.MoveFocus%2A?displayProperty=nameWithType> и запечатывает метод.  
  
   
  
## Examples  
 В следующем примере реализуется обработчик, который обрабатывает несколько возможных вводов кнопок. Каждой кнопке соответствует возможного <xref:System.Windows.Input.FocusNavigationDirection>. Обработчик отслеживает элемента с текущим фокусом клавиатуры и вызывает <xref:System.Windows.FrameworkElement.MoveFocus%2A> на этот элемент, указав соответствующие <xref:System.Windows.Input.FocusNavigationDirection> для инициализации <xref:System.Windows.Input.TraversalRequest> предоставленный параметр типа.  
  
 [!code-csharp[FocusSample#FocusSampleMoveFocus](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSample/CSharp/Window1.xaml.cs#focussamplemovefocus)]
 [!code-vb[FocusSample#FocusSampleMoveFocus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSample/visualbasic/window1.xaml.vb#focussamplemovefocus)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="M:System.Windows.UIElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.FrameworkElement.Name" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IFrameworkInputElement.Name</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Markup.DesignerSerializationOptions(System.Windows.Markup.DesignerSerializationOptions.SerializeAsAttribute)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Windows.Markup.DesignerSerializationOptions</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает имя, обозначающее элемент. Имя предоставляет ссылку, чтобы код программной части, например код обработчика событий, мог ссылаться на элемент разметки после создания этого элемента в ходе обработки процессором [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</summary>
        <value>Имя элемента. Значение по умолчанию - пустая строка.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Наиболее распространенный случай использования этого свойства является указание [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] имя элемента, как атрибут в разметке.  
  
 По существу, это свойство предоставляет свойство удобства уровня платформы WPF, чтобы установить [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [директива x: Name](~/docs/framework/xaml-services/x-name-directive.md).  
  
 Имена должны быть уникальными в пределах области видимости имен. Дополнительные сведения см. в разделе [области видимости имен XAML WPF](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
 Начало <xref:System.Windows.FrameworkElement.Name%2A> при создании элементов в коде не часто. Если вы уже соответствующую ссылку в коде, можно просто вызвать методы и свойства в элементе ссылки и не будет обычно необходимость <xref:System.Windows.FrameworkElement.Name%2A>. Исключение — если <xref:System.Windows.FrameworkElement.Name%2A> строка имеет несколько перегруженных значение, например если необходимо отобразить это имя в [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]. Установка <xref:System.Windows.FrameworkElement.Name%2A> из кода если исходный <xref:System.Windows.FrameworkElement.Name%2A> была настроена из разметки также не рекомендуется использовать и изменения свойства после загрузки [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] ссылка на исходный объект не изменится. Ссылки на объекты создаются только в том случае, когда основной области видимости имен явно создаются во время синтаксического анализа. Необходимо явно вызывать <xref:System.Windows.FrameworkElement.RegisterName%2A> вносить изменений для <xref:System.Windows.FrameworkElement.Name%2A> свойства элемента уже загружен.  
  
 Один заметных случае там, где параметр <xref:System.Windows.FrameworkElement.Name%2A> из кода важна при регистрации имен для элементов, которые раскадровки будет выполняться, чтобы на них можно ссылаться во время выполнения. Перед регистрацией имени, может также потребоваться создания экземпляров и присваивания <xref:System.Windows.NameScope> экземпляра. См. в разделе "Пример" или [Общие сведения о раскадровках](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).  
  
 Установка <xref:System.Windows.FrameworkElement.Name%2A> из кода имеет ограниченную приложения, но Получение элемента с <xref:System.Windows.FrameworkElement.Name%2A> чаще. Один из сценариев является, если приложение поддерживает модель навигации, где перезагрузкой страниц в приложение, и код времени выполнения не обязательно кода программной части, определенным для этой страницы. Служебный метод <xref:System.Windows.FrameworkElement.FindName%2A>, который доступен из любого <xref:System.Windows.FrameworkElement>, можно найти любой элемент, <xref:System.Windows.FrameworkElement.Name%2A> в логическом дереве для этого элемента, поиск в дереве рекурсивно, при необходимости. Или можно использовать <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> статический метод <xref:System.Windows.LogicalTreeHelper>, который также принимает <xref:System.Windows.FrameworkElement.Name%2A> строку в качестве аргумента.  
  
 Как правило, используется корневых элементов (<xref:System.Windows.Window>, <xref:System.Windows.Controls.Page> для примера) реализовать интерфейс <xref:System.Windows.Markup.INameScope>. Реализации этого интерфейса ожидается обеспечение однозначности имен в их области. Корневые элементы, которые определяют этот интерфейс также определить поведение границы области видимости имен для всех связанных [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)].  
  
 <xref:System.Windows.FrameworkElement.Name%2A> Свойства также служит в качестве идентификатора для других процессов. Например [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] будет использовать модель автоматизации <xref:System.Windows.FrameworkElement.Name%2A> как AutomationId для клиентов и поставщиков.  
  
 Строковые значения, используемые для <xref:System.Windows.FrameworkElement.Name%2A> имеют некоторые ограничения, как налагаемые базовой [директива x: Name](~/docs/framework/xaml-services/x-name-directive.md) определяется [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] спецификации. Прежде всего <xref:System.Windows.FrameworkElement.Name%2A> должно начинаться с буквы или символа подчеркивания (_) и должно содержать только буквы, цифры или символы подчеркивания. Дополнительные сведения см. в разделе [области видимости имен XAML WPF](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
 <xref:System.Windows.FrameworkElement.Name%2A> является одним из немногих свойства зависимости, которые не могут анимироваться (<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> является `true` в метаданных), так как само имя критически важен для нацеливания анимации. Привязка данных <xref:System.Windows.FrameworkElement.Name%2A> технически возможно, но встречается крайне редко, так как привязкой к данным <xref:System.Windows.FrameworkElement.Name%2A> не может служить главной цель свойство: для предоставления идентификатор точки подключения для кода.  
  
<a name="dependencyPropertyInfo_Name"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.NameProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|  
  
   
  
## Examples  
 В следующем примере задается <xref:System.Windows.FrameworkElement.Name%2A> свойства в коде, а затем регистрирует имя в только что созданный <xref:System.Windows.NameScope> путем вызова <xref:System.Windows.FrameworkElement.RegisterName%2A>. Показанный здесь прием является обязательным для анимации с помощью раскадровок, так как раскадровки требуют указания цели с <xref:System.Windows.FrameworkElement.Name%2A>, а не может быть нацелена на ссылку на объект.  
  
 [!code-csharp[animateHeight_procedural#FEName](~/samples/snippets/csharp/VS_Snippets_Wpf/animateHeight_procedural/CSharp/AnimatedHeightExample.cs#fename)]
 [!code-vb[animateHeight_procedural#FEName](~/samples/snippets/visualbasic/VS_Snippets_Wpf/animateHeight_procedural/visualbasic/animatedheightexample.vb#fename)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty NameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty NameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.NameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ NameProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable NameProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.NameProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.Name" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnApplyTemplate">
      <MemberSignature Language="C#" Value="public virtual void OnApplyTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnApplyTemplate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnApplyTemplate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnApplyTemplate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnApplyTemplate();" />
      <MemberSignature Language="F#" Value="abstract member OnApplyTemplate : unit -&gt; unit&#xA;override this.OnApplyTemplate : unit -&gt; unit" Usage="frameworkElement.OnApplyTemplate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе вызывается всякий раз, когда код приложения или внутренние процессы вызывают метод <see cref="M:System.Windows.FrameworkElement.ApplyTemplate" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не имеет значение по умолчанию реализации.  
  
 Шаблоны представляют собой часть элемента визуального дерева, поступающие от свойство Template <xref:System.Windows.Style> , применяемый для элемента. Более подробную информацию см. в разделе [Стилизация и использование шаблонов](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Классы, унаследованные от <see cref="T:System.Windows.FrameworkElement" /> можно использовать этот метод для уведомления о различных возможных сценариев: 
-Можно вызвать собственную реализацию кода, который создает в оставшейся части визуального дерева элемента.  
  
— Можно выполнять код, основанный на визуальное дерево из примененных шаблонов, таких как получение ссылок на именованные элементы, полученные из шаблона.  
  
-Можно внедрить службы, которые имеют смысл только существовать после завершения визуального дерева на основе шаблонов.  
  
— Можно задать состояния и свойств элементов в шаблоне, которые зависят от других факторов. К примеру значения свойств могут быть доступными только мы знаем, родительский элемент, или когда конкретного производного класса использует общий шаблон.  
  
Разработчикам следует всегда вызывать базовую реализацию перед свою собственную реализацию. <see cref="T:System.Windows.FrameworkElement" /> сам не имеет стандартного реализации, но промежуточные классы могут.  
  
 <see cref="T:System.Windows.Controls.Control" /> предоставляет аналогичные override, <see cref="M:System.Windows.Controls.Control.OnTemplateChanged(System.Windows.Controls.ControlTemplate,System.Windows.Controls.ControlTemplate)" />.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuClosing (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuClosing(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkElement.OnContextMenuClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Предоставляет данные о событии.</param>
        <summary>Вызывается, когда необработанное перенаправленное событие <see cref="E:System.Windows.FrameworkElement.ContextMenuClosing" /> достигает этого класса на своем пути. Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не имеет значение по умолчанию реализации. Если промежуточный класс в цепочке наследования реализует данный метод рекомендуется вызывать базовую реализацию.  
  
 Этот метод похож на [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на * методы: она предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра. В этом случае соответствующее событие является перенаправленное событие. Шаблон реализации методы On * отличается для перенаправленных событий, так как перенаправленное событие может быть вызвано дочерний элемент, не обязательно является элементом, который будет вызывать обработчики, поэтому вашей реализации потребуется использовать источник для аргументов событий свойства в учетной записи (и не следует пытаться повторно отправить событие в большинстве случаев). Подклассы <xref:System.Windows.FrameworkElement> может выбрать для вызова методов обработчика закрытый класс при получении события в маршруте. Одним из потенциальных сценариев является получение аргументов события и специально помечать событие как обработанное.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuOpening (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuOpening(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkElement.OnContextMenuOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.Windows.RoutedEventArgs" />, содержащий данные о событии.</param>
        <summary>Вызывается, когда необработанное перенаправленное событие <see cref="E:System.Windows.FrameworkElement.ContextMenuOpening" /> достигает этого класса на своем пути. Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не имеет значение по умолчанию реализации. Если промежуточный класс в цепочке наследования реализует данный метод рекомендуется вызывать базовую реализацию.  
  
 Этот метод похож на [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на * методы: она предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра. В этом случае соответствующее событие является перенаправленное событие. Шаблон реализации методы On * отличается для перенаправленных событий, так как перенаправленное событие может быть вызвано дочерний элемент, не обязательно является элементом, который будет вызывать обработчики, поэтому вашей реализации потребуется использовать источник для аргументов событий свойства в учетной записи (и не следует пытаться повторно отправить событие в большинстве случаев). Подклассы <xref:System.Windows.FrameworkElement> может выбрать для вызова методов обработчика закрытый класс при получении события в маршруте. Одним из потенциальных сценариев является получение аргументов события и специально помечать событие как обработанное.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="frameworkElement.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.Windows.RoutedEventArgs" />, содержащий данные о событии.</param>
        <summary>Вызывается, когда необработанное событие <see cref="E:System.Windows.UIElement.GotFocus" /> достигает этого элемента на своем пути.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В отличие от некоторых других на * методов, предоставляемых базовые элементы, <xref:System.Windows.FrameworkElement.OnGotFocus%2A> имеет реализации по умолчанию. В частности, он имеет реализацию, которая переопределяет null реализацию на следующем уровне базового элемента, <xref:System.Windows.UIElement.OnGotFocus%2A>. При вызове <xref:System.Windows.FrameworkElement.OnGotFocus%2A> задает соответствующее поведение фокуса на этот элемент в случаях, в котором произошло событие из текущего элемента из-за фокус клавиатуры. <xref:System.Windows.FrameworkElement.OnGotFocus%2A> Обработчик не помечают аргументы события как обработанные, даже если фокус перемещается к текущему элементу. Если источником события был другой элемент в дереве (а не текущего элемента), обработчик не выполняет никаких действий.  
  
 Можно переопределить этот метод, чтобы изменить поведение фокуса по умолчанию для вашего элемента, но имейте в виду, что изменение поведения фокуса таким образом можно реализовать лучше, не позволяя элемента, который требуется вообще (см. в разделе <xref:System.Windows.UIElement.Focusable%2A>).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Если вы собираетесь пометить событие как обработанное в аргументах, следует учитывать последствия обработка событий в другие родительские элементы в дереве элементов. Так как данный обработчик действует на событие с восходящей маршрутизации, для установки фокуса на текущий <paramref name="sender" /> каждого события аргументов может не подойти. Фокус может быть выполнен либо составного дочернему элементу или родительскому элементу, в зависимости от композиции определенных элементов управления. Поэтому помечать событие фокуса как обработанное рекомендуется, только если весь визуальное дерево, событием является частью композиции элемента управления, созданные.</para></block>
        <altmember cref="P:System.Windows.UIElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="OnInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitialized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInitialized : EventArgs -&gt; unit&#xA;override this.OnInitialized : EventArgs -&gt; unit" Usage="frameworkElement.OnInitialized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.Windows.RoutedEventArgs" />, содержащий данные о событии.</param>
        <summary>Создает событие <see cref="E:System.Windows.FrameworkElement.Initialized" />. Этот метод вызывается всякий раз, когда <see cref="P:System.Windows.FrameworkElement.IsInitialized" /> имеет внутреннее значение <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный конкретный на * метод не является ловушкой обработчика класса. Ни он точно следовать установленному [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] на * метод соглашение, что соответствующее ему событие может быть отменено с помощью переопределения этого метода и не вызывает базовую реализацию.  
  
 Обратите внимание, что <xref:System.Windows.FrameworkElement.IsInitialized%2A> свойство только для чтения, поэтому невозможно задать <xref:System.Windows.FrameworkElement.IsInitialized%2A> для принудительного использования поведения инициализации. Задание состояния инициализации должен выполняться только [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] framework.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Реализация по умолчанию данного виртуального метода вызывает вышеописанное событие. Для поддержания данного режима работы переопределение должно вызывать базовую реализацию. Если вам не удается вызвать базовую реализацию, не только вы не вызовут <see cref="E:System.Windows.FrameworkElement.Initialized" /> события как обычно, ожидаемых <see cref="T:System.Windows.FrameworkElement" /> производного класса, но также будет запрещена две важные стилю и цветовой схеме стиль инициализации операции, которые являются реализуется базовая реализация.</para></block>
        <altmember cref="M:System.Windows.FrameworkElement.OnApplyTemplate" />
        <altmember cref="E:System.Windows.FrameworkElement.Initialized" />
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="frameworkElement.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Данные события, описывающие измененное свойство, а также старое и новое значения.</param>
        <summary>Вызывается каждый раз, когда обновляется действительное значение любого свойства зависимостей для данного <see cref="T:System.Windows.FrameworkElement" />. Конкретное измененное свойство зависимостей сообщается в параметре аргументов. Переопределяет <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не предназначен для обычно обнаружения изменения свойств или недействительности. Он предназначен для изменения общего шаблона недействительности Если известны определенные сведения о классификациях расширенных свойств.  
  
 Этот метод потенциально вызывается много раз в течение жизненного цикла объекта. Таким образом, можно повысить производительность, если переопределить метаданные свойств, а затем подключить <xref:System.Windows.CoerceValueCallback> или <xref:System.Windows.PropertyChangedCallback> функции для отдельных свойств. Тем не менее, можно использовать, этот метод Если <xref:System.Windows.FrameworkElement> включает значительное количество свойств зависимостей с взаимосвязанными значение, или если он содержит логику, такие как поведение отрисовки, необходимо повторно для нескольких связанных случаев недействительности свойств.  
  
 Обратите внимание, что таким же именем `OnPropertyChanged` метод с другой сигнатурой (тип параметра является <xref:System.ComponentModel.PropertyChangedEventArgs>), которые могут возникнуть на несколько классов. Что `OnPropertyChanged` используется для уведомления объекта данных, и является частью контракта для <xref:System.ComponentModel.INotifyPropertyChanged>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Всегда вызывайте базовую реализацию, как первую операцию в реализации. Если этого не сделать значительно отключит всего [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] системы свойств, в результате чего будут сообщены неверные значения. Конкретный <see cref="T:System.Windows.FrameworkElement" /> реализация также отвечает за обслуживание в правильном состоянии для различных свойств, влияющих на видимого пользовательского интерфейса. К ним относятся, стал недопустимым визуального дерева в зависимости от изменений стиля в нужное время.</para></block>
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
        <altmember cref="T:System.Windows.PropertyChangedCallback" />
      </Docs>
    </Member>
    <Member MemberName="OnRenderSizeChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnRenderSizeChanged (System.Windows.SizeChangedInfo sizeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnRenderSizeChanged(class System.Windows.SizeChangedInfo sizeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnRenderSizeChanged (sizeInfo As SizeChangedInfo)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnRenderSizeChanged(System::Windows::SizeChangedInfo ^ sizeInfo);" />
      <MemberSignature Language="F#" Value="override this.OnRenderSizeChanged : System.Windows.SizeChangedInfo -&gt; unit" Usage="frameworkElement.OnRenderSizeChanged sizeInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sizeInfo" Type="System.Windows.SizeChangedInfo" />
      </Parameters>
      <Docs>
        <param name="sizeInfo">Сведения о старом и новом размерах при изменении.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.FrameworkElement.SizeChanged" />, используя заданную информацию как часть итоговых данных события.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод переопределяет метод <xref:System.Windows.UIElement.OnRenderSizeChanged%2A>. При вызове этого метода Вы сбрасываете <xref:System.Windows.FrameworkElement.ActualWidth%2A> свойства <xref:System.Windows.FrameworkElement.ActualHeight%2A> свойство (или оба) в зависимости от того, что указано как изменения в предоставленных аргументов и будут всегда создается событие.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Не следует переопределять этот метод для сценариев типичное расположение. Система макета работает в намеренно асинхронный способ заверения в том что Упорядочить все возможные макета и случаев меры. Система макета переопределять методы <see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" /> и <see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" /> обычно достаточно для какой-либо настройки требуется макет. <see cref="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" /> указывается в виде виртуальной. Можно переопределить <see cref="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" /> для исправления в исключительных случаях, где изменения поведения времени выполнения, связанных с события, в сочетании с элементом управления ввода рекомпозиции в ответ может предоставить сведения о макете неточным.  
  
Вы по-прежнему могут переопределить этот метод в производных классах (он защищен, но не запечатан). Всегда вызовите базовую реализацию, чтобы сохранить поведение, описанное выше, если у вас нет особых причин для отключения поведение отрисовки уровня среды WPF по умолчанию. Не удалось вызвать <see cref="E:System.Windows.FrameworkElement.SizeChanged" /> событий приведет к поведению нестандартного макета, при использовании стандартной реализации системы макета уровня среды WPF.</para></block>
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStyleChanged(class System.Windows.Style oldStyle, class System.Windows.Style newStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStyleChanged (oldStyle As Style, newStyle As Style)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStyleChanged(System::Windows::Style ^ oldStyle, System::Windows::Style ^ newStyle);" />
      <MemberSignature Language="F#" Value="abstract member OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit&#xA;override this.OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit" Usage="frameworkElement.OnStyleChanged (oldStyle, newStyle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldStyle" Type="System.Windows.Style" />
        <Parameter Name="newStyle" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="oldStyle">Старый стиль.</param>
        <param name="newStyle">Новый стиль.</param>
        <summary>Вызывается при изменении текущего стиля данного элемента, что ведет к недействительности структуры.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет реализацию по умолчанию, который устанавливает внутренний флаг, заметки о состоянии изменения стиля.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Не следует обычно переопределить этот метод. Любые изменения на стиль, который включает в себя меру или упорядочить изменение уже приведет к запуску другого цикла отрисовки, при условии, что типичная реализация <see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />  /  <see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />, или значения по умолчанию. Переопределяет из <see cref="M:System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" /> может быть целесообразным Если ваш <see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />  /  <see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" /> реализаций были намеренно оптимизации или частичных обновлений, которые поддерживают но по-прежнему хотите применить изменения в стили напрямую. (Частичное обновление будет попытка во избежание нескольких вызовов добавочные <see cref="M:System.Windows.UIElement.Measure(System.Windows.Size)" /> и <see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" /> на любые дочерние элементы).</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipClosing(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipClosing (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipClosing(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkElement.OnToolTipClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Предоставляет данные о событии.</param>
        <summary>Вызывается, когда необработанное перенаправленное событие <see cref="E:System.Windows.FrameworkElement.ToolTipClosing" /> достигает этого класса на своем пути. Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не имеет значение по умолчанию реализации. Если промежуточный класс в цепочке наследования реализует данный метод рекомендуется вызывать базовую реализацию.  
  
 Этот метод похож на [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на * методы: она предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра. В этом случае соответствующее событие является перенаправленное событие. Шаблон реализации методы On * отличается для перенаправленных событий, так как перенаправленное событие может быть вызвано дочерний элемент, не обязательно является элементом, который будет вызывать обработчики, поэтому вашей реализации потребуется использовать источник для аргументов событий свойства в учетной записи (и не следует пытаться повторно отправить событие в большинстве случаев). Подклассы <xref:System.Windows.FrameworkElement> может выбрать для вызова методов обработчика закрытый класс при получении события в маршруте. Одним из потенциальных сценариев является получение аргументов события и специально помечать событие как обработанное.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipOpening(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipOpening (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipOpening(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkElement.OnToolTipOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Предоставляет данные о событии.</param>
        <summary>Вызывается, когда перенаправленное событие <see cref="E:System.Windows.FrameworkElement.ToolTipOpening" /> достигает этого класса на своем пути. Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не имеет значение по умолчанию реализации. Если промежуточный класс в цепочке наследования реализует данный метод рекомендуется вызывать базовую реализацию.  
  
 Этот метод похож на [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на * методы: она предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра. В этом случае соответствующее событие является перенаправленное событие. Шаблон реализации методы On * отличается для перенаправленных событий, так как перенаправленное событие может быть вызвано дочерний элемент, не обязательно является элементом, который будет вызывать обработчики, поэтому вашей реализации потребуется использовать источник для аргументов событий свойства в учетной записи (и не следует пытаться повторно отправить событие в большинстве случаев). Подклассы <xref:System.Windows.FrameworkElement> может выбрать для вызова методов обработчика закрытый класс при получении события в маршруте. Одним из потенциальных сценариев является получение аргументов события и пометка события как обработанного для сокращения маршрута.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberSignature Language="F#" Value="override this.OnVisualParentChanged : System.Windows.DependencyObject -&gt; unit" Usage="frameworkElement.OnVisualParentChanged oldParent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">Прежний родительский элемент. Может иметь значение <see langword="null" />, чтобы показать, что ранее у элемента не было родительского элемента.</param>
        <summary>Вызывается при изменении родителя данного  элемента в визуальном дереве. Переопределяет <see cref="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Визуальное дерево потенциально отличается от логического дерева, так как он не содержит элементы, которые не отображаются визуально, такие как коллекции и раскрывает некоторые элементы на основании их тем и стилей композиции. Дополнительные сведения см. в разделе [Деревья в WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Реализация по умолчанию данного виртуального метода запрашивает новый родительский элемент, создает различные события инициализации и задает внутренние флаги состояния инициализации для <see cref="T:System.Windows.FrameworkElement" /> соответствующим образом. Наконец, он вызывает последовательных базовых реализаций, объявленном с <see cref="T:System.Windows.UIElement" />, которое в свою очередь вызывает базовую в <see cref="T:System.Windows.Media.Visual" />. Всегда вызовите базовую реализацию для сохранения этого поведения, в противном случае поведение дерева элементов для этого элемента, объявленного как дочерний элемент другого элемента не может быть должным образом.  
  
Несколько существующих [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] классы переопределяют этот метод, например: <see cref="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />, <see cref="M:System.Windows.Controls.ListBoxItem.OnVisualParentChanged(System.Windows.DependencyObject)" />. Наиболее распространенный сценарий — обеспечить, что новый родительский элемент должен быть определенного типа. Это может вызвать исключение, если новый родитель не каким-либо образом тип теста. Специализированная версия этого сценария существует в реализации для элементов списка и пунктов меню, которые не имеют смысла любой за пределами родительского visual, которыми владеет соответствующую коллекцию для их хранения. Обратите внимание на то, что эти случаи не обязательно вызывают исключения, поскольку может существовать сценарии конструктора, которые зависят от того, Переподчинение элементы, которые являются сразу же без родительских «regular».  
  
Этот метод переопределяется также в некоторые элементы, которые обычно являются корневыми, такие как <see cref="T:System.Windows.Window" />. Другим случаем являются элементы, которые являются очевидными корневой элемент в разметке, но который Автоформирование обширную инфраструктуру в скомпилированном логическом дереве (такие как <see cref="T:System.Windows.Controls.Page" />). <see cref="T:System.Windows.Window" /> И <see cref="T:System.Windows.Controls.Page" /> реализаций намеренно запечатать метод.</para></block>
        <altmember cref="M:System.Windows.Media.Visual.OnVisualParentChanged(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyle">
      <MemberSignature Language="C#" Value="public bool OverridesDefaultStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesDefaultStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.OverridesDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesDefaultStyle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesDefaultStyle { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesDefaultStyle : bool with get, set" Usage="System.Windows.FrameworkElement.OverridesDefaultStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение или установка значения, определяющего использование в элементе свойств стиля, заданных в стилях темы.</summary>
        <value>Значение <see langword="true" />, если этот элемент не использует свойства стиля темы; все свойства, определяющие стиль, получаются из локальных стилей приложения, а свойства стиля темы не применяются. Значение <see langword="false" />, если сначала применяются стили приложения, а затем стили тем для свойств, которые не были явным образом заданы в стилях приложения. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Наиболее распространенный случай использования этого свойства является непрямое использование в переключателе стиля, который передает тематический стиль.  
  
> [!IMPORTANT]
>  Если задать <xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A> для `true` на элемент управления будет подавление шаблон элемента управления по умолчанию, предоставляемые тематические стили. Этот шаблон обычно включает средство отображения содержимого и других сложных элементов, которые предоставляют основные [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] функциональные возможности и визуализации для элемента управления. Если вы хотите организовать дальнейшую поддержку те же функции, что тематические стили по умолчанию элемент управления, необходимо указать альтернативный стиль с шаблоном элемента управления, которая реплицирует ту же структуру. Дополнительные сведения см. в разделе [Общие сведения о разработке элементов управления](~/docs/framework/wpf/controls/control-authoring-overview.md).  
  
<a name="dependencyPropertyInfo_OverridesDefaultStyle"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.OverridesDefaultStyleProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OverridesDefaultStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.OverridesDefaultStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OverridesDefaultStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OverridesDefaultStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OverridesDefaultStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.OverridesDefaultStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.OverridesDefaultStyle" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkElement.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает логический родительский элемент этого элемента.</summary>
        <value>Логический родительский объект этого элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Parent%2A> может быть `null` в случаях, когда элемент был создан, но не подключен к логическому дереву, в конечном итоге подключается на уровне корневого элемента страницы или объекту приложения.  
  
 Обратите внимание, что логический родитель элемента потенциально может меняться в зависимости от функциональности приложения, и сохранение значения этого свойства не отразит это изменение. Обычно нужно получить значение, непосредственно перед он вам нужен.  
  
 См. в разделе [деревья в WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md) для сценариев и Дополнительные сведения о логическому дереву там, где с помощью <xref:System.Windows.FrameworkElement.Parent%2A> как методика родительского элемента подходит обнаружения.  
  
 Механизм свойства потенциально пересчитывает все значения свойств элемента при изменении его родителя, так как некоторые свойства наследуют значения по логическому дереву. <xref:System.Windows.FrameworkElement.DataContext%2A> , Применяемый для привязки также можно изменить при изменении в родителя или элементов.  
  
 Изменение родительского элемента обычно выполняется только через управление коллекциями, с использованием выделенных методов добавления и удаления, или путем задания свойств содержимого элементов.  
  
 Наиболее типичный сценарий использования <xref:System.Windows.FrameworkElement.Parent%2A> свойство является получить ссылку, а затем получить различные <xref:System.Windows.FrameworkElement> значения свойств из родительского элемента. Для шаблонов <xref:System.Windows.FrameworkElement.Parent%2A> шаблона со временем будет `null`. Чтобы преодолеть эту точку и расширить в логическом дереве, где фактически применяется шаблон, используйте <xref:System.Windows.FrameworkElement.TemplatedParent%2A>.  
  
 Обратите внимание на то, что это свойство не сообщает о родительских элементов визуального дерева в случаях, когда они отличаются от родителей логического дерева. Родительские элементы визуального дерева обычно не важны в общих случаях приложений, но может быть целевыми родительскими элементами для некоторых случаях визуального уровня. См. раздел <xref:System.Windows.Media.VisualTreeHelper>.  
  
   
  
## Examples  
 В примере показан код, который проверяет родительский элемент, а затем использует значения свойств из родительского элемента для задания свойств для дочернего элемента для сопоставления. В данном случае это свойства, которые влияют на размер отрисовки.  
  
 [!code-csharp[GeometryDesigner#FEParentProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/GeometryDesigner/CSharp/Window1.xaml.cs#feparentproperty)]
 [!code-vb[GeometryDesigner#FEParentProperty](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GeometryDesigner/visualbasic/window1.xaml.vb#feparentproperty)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.TemplatedParent" />
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="ParentLayoutInvalidated">
      <MemberSignature Language="C#" Value="protected internal virtual void ParentLayoutInvalidated (System.Windows.UIElement child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void ParentLayoutInvalidated(class System.Windows.UIElement child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub ParentLayoutInvalidated (child As UIElement)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void ParentLayoutInvalidated(System::Windows::UIElement ^ child);" />
      <MemberSignature Language="F#" Value="abstract member ParentLayoutInvalidated : System.Windows.UIElement -&gt; unit&#xA;override this.ParentLayoutInvalidated : System.Windows.UIElement -&gt; unit" Usage="frameworkElement.ParentLayoutInvalidated child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="child">Дочерний элемент, сообщающий об изменении.</param>
        <summary>Поддерживает реализации инкрементного макета в специализированных подклассах <see cref="T:System.Windows.FrameworkElement" />. Метод <see cref="M:System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)" /> вызывается, когда дочерний элемент делает недействительным свойство, помеченное в метаданных как влияющее на проходы измерения или компоновки родительского элемента во время структурирования.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если этот элемент содержит дочерний элемент, на котором был объявлен недействительным, некоторые свойства и свойства был помечен как <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> или <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> свойства метаданных во время регистрации, этот метод вызывается. Вызов метода уведомляет конкретный дочерний элемент которого должен быть повторно измеренный, если этот элемент поддерживает частичное (добавочное) обновление макета родительского элемента.  
  
 По умолчанию <xref:System.Windows.FrameworkElement> не поддерживает последовательный макет и в <xref:System.Windows.FrameworkElement> класса это у метода нет реализации по умолчанию. Сценарий, в котором было бы необходимо переопределение этого метода не является типичным, так как он требует изменить систему макета по умолчанию.  
  
 Пример сценария реализации может быть Если класс типа ограничения для возможные дочерние элементы, которые значительно более строгие, чем система макетов уровня среды WPF. Из-за природы данных пользовательских элементов изменения свойств могут быть намеренно отложены при реализации особого поведения структуры. Например измерения или компоновки переопределения методов, которые пытаются оптимизировать дочерний элемент прохода отрисовки, могут быть отложены для некоторых типов изменений, которые обычно приводят к очередной проход разметки.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberSignature Language="F#" Value="override this.PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject" Usage="frameworkElement.PredictFocus direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Направление, в котором следует определить перспективное изменение фокуса.</param>
        <summary>Определяет следующий элемент, который получит фокус, относительно данного элемента для указанного направления движения фокуса, но реально фокус не перемещает.</summary>
        <returns>Следующий элемент, на который будет перемещен фокус в случае фактического обхода фокуса. Может возвращать значение <see langword="null" />, если фокус нельзя переместить относительно данного элемента в указанном направлении.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.MoveFocus%2A> — Это связанный метод, который фактически перемещения фокуса.  
  
   
  
## Examples  
 В следующем примере реализуется обработчик, который обрабатывает несколько возможных вводов кнопок, каждой кнопки, представляющий возможного <xref:System.Windows.Input.FocusNavigationDirection>. Обработчик отслеживает элемента с текущим фокусом клавиатуры и вызывает <xref:System.Windows.FrameworkElement.PredictFocus%2A> на этот элемент и задает соответствующий <xref:System.Windows.Input.FocusNavigationDirection> для инициализации <xref:System.Windows.Input.TraversalRequest> предоставленный параметр типа. Вместо перемещения этого элемента как <xref:System.Windows.FrameworkElement.MoveFocus%2A> бы сделать, обработчик изменяет размеры назначения прогнозируемое фокус в целях визуализации.  
  
 [!code-csharp[FocusSample#FEPredictFocus](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSample/CSharp/Window1.xaml.cs#fepredictfocus)]
 [!code-vb[FocusSample#FEPredictFocus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSample/visualbasic/window1.xaml.vb#fepredictfocus)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Одно из следующих направлений, указанное в <see cref="T:System.Windows.Input.TraversalRequest" />: <see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.First" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Last" />. Эти направления недопустимы для метода <see cref="M:System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> (однако допустимы для метода <see cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />).</exception>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="M:System.Windows.UIElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberSignature Language="F#" Value="member this.RegisterName : string * obj -&gt; unit" Usage="frameworkElement.RegisterName (name, scopedElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Имя, используемое для сопоставления указанного имени с объектом.</param>
        <param name="scopedElement">Объект для сопоставления.</param>
        <summary>Предоставляет метод доступа, упрощающий доступ к методу регистрации <see cref="T:System.Windows.NameScope" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод — это удобный метод для вызова <xref:System.Windows.NameScope.RegisterName%2A>. Реализация будет проверять последовательных родительских элементах, пока не найдет применимой <xref:System.Windows.NameScope> реализации, в которой находится путем поиск элемента, который реализует <xref:System.Windows.Markup.INameScope>. Дополнительные сведения об области видимости имен см. в разделе [области видимости имен XAML WPF](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
 Вызов <xref:System.Windows.FrameworkElement.RegisterName%2A> нужно, чтобы правильно подключить раскадровки анимации для приложений, при создании в коде. Это обусловлено тем, одним из ключевых раскадровка свойства, <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>, выполняет поиск имен времени выполнения, вместо того использовать ссылку на целевой элемент. Это справедливо, даже если этот элемент доступен по ссылке из кода. Дополнительные сведения о том, почему требуется регистрировать имена целей раскадровки, см. в разделе [Общие сведения о раскадровках](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).  
  
   
  
## Examples  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#NameScopeExample](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/ScopeExample.cs#namescopeexample)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#NameScopeExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/scopeexample.vb#namescopeexample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.NameScope.RegisterName(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void RemoveLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RemoveLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RemoveLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RemoveLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.RemoveLogicalChild : obj -&gt; unit" Usage="frameworkElement.RemoveLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">Подлежащий удалению элемент.</param>
        <summary>Удаляет предоставленный объект из логического дерева этого элемента. <see cref="T:System.Windows.FrameworkElement" /> обновляет затронутые указатели в логическом дереве для синхронизации с данным удалением.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для реализации коллекции объектов, представляющих логических дочерних элементов элемента. Это можно сделать в методы получения свойств или методов задания, обработчиков класса `Changed` события, конструкторы, или в коллекции типов сами.  
  
 Для разработчиков элементов управления обработка логического дерева на этом уровне не рекомендуется, если только не подходит ни одна из моделей содержимого указанный базовый класс элемента управления. Рассмотрите возможность создания подклассов на уровне <xref:System.Windows.Controls.ContentControl>, <xref:System.Windows.Controls.ItemsControl>, и <xref:System.Windows.Controls.HeaderedItemsControl>. Эти классы предоставляют модель содержимого с определенной применение логических дочерних элементов через выделенный [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)], а также поддерживает другие функции, обычно желательно, [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] элемента управления, такие как стили через шаблоны.  
  
   
  
## Examples  
 В следующем примере реализуется `Child` свойство в пользовательском <xref:System.Windows.FrameworkElement> который выполняет собственную реализацию на визуальном уровне. Метод задания свойства разработан таким образом, если значение изменяется, старое значение удаляется из логического дерева, а также коллекцию визуальных элементов данного класса. Значения кэшируются, и затем добавляется новое значение как стандартный framework уровня логическом дереве WPF, так и коллекция пользовательских визуальных элементов.  
  
 [!code-csharp[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/csharp/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/CSharp/ParticleEffectExamples/OverlayRenderDecorator.cs#addremovelogicalchild)]
 [!code-vb[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/visualbasic/particleeffectexamples/overlayrenderdecorator.vb#addremovelogicalchild)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RequestBringIntoView">
      <MemberSignature Language="C#" Value="public event System.Windows.RequestBringIntoViewEventHandler RequestBringIntoView;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RequestBringIntoViewEventHandler RequestBringIntoView" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.RequestBringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RequestBringIntoView As RequestBringIntoViewEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RequestBringIntoViewEventHandler ^ RequestBringIntoView;" />
      <MemberSignature Language="F#" Value="member this.RequestBringIntoView : System.Windows.RequestBringIntoViewEventHandler " Usage="member this.RequestBringIntoView : System.Windows.RequestBringIntoViewEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RequestBringIntoViewEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при вызове метода <see cref="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" /> в данном элементе.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие указывает, к родительскому элементу <xref:System.Windows.Controls.ScrollViewer> (или производного класса), на элемент, который инициирует <xref:System.Windows.FrameworkElement.RequestBringIntoView> событий следует сделать видимой в прокручиваемой области. <xref:System.Windows.Controls.ScrollViewer> Затем пометит <xref:System.Windows.FrameworkElement.RequestBringIntoView> событие как обработанное, с помощью класса обработку события. В целом <xref:System.Windows.FrameworkElement.RequestBringIntoView> событий, данные не следует помечать обработанные с любого класса, который элемент управления области прокрутки или каким-либо экземпляр обработчика, так как это может повлиять на целью элемента, который вызывается <xref:System.Windows.FrameworkElement.BringIntoView%2A>.  
  
<a name="routedEventInfo_RequestBringIntoView"></a>   
## <a name="routed-event-information"></a>Сведения о маршрутизируемом событии  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.RequestBringIntoViewEvent>|  
|Стратегия маршрутизации|Восходящая маршрутизация|  
|делегат|<xref:System.Windows.RequestBringIntoViewEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" />
        <altmember cref="T:System.Windows.Controls.ScrollViewer" />
      </Docs>
    </Member>
    <Member MemberName="RequestBringIntoViewEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent RequestBringIntoViewEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent RequestBringIntoViewEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.RequestBringIntoViewEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly RequestBringIntoViewEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ RequestBringIntoViewEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable RequestBringIntoViewEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.RequestBringIntoViewEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует направленное событие <see cref="E:System.Windows.FrameworkElement.RequestBringIntoView" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.FrameworkElement.Resources" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Markup.IHaveResources.Resources</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает локально определенный словарь ресурсов.</summary>
        <value>Текущий локально определенный словарь ресурсов, где доступ к каждому ресурсу может осуществляться по ключу.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Словари ресурсов, которые могут быть определены полностью или частично в [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] обычно создаются в качестве элемента свойства и обычно находятся на корневой элемент для любой отдельной страницы или приложения. Размещение словаря ресурсов на этом уровне облегчает поиск из отдельных дочерних элементов на странице (или с любой страницы, в случае приложения). В большинстве сценариев приложений, рекомендуется определить эти стили как элементы объекта в словаре ресурсов, или как внешние ресурсы, чтобы весь ресурс стиля могут быть автономными (этот подход помогает отдельный конструктор Ответственность от ответственности разработчика путем разделения физических файлов, которые нужно редактировать).  
  
 Обратите внимание, что это свойство возвращает только словарь ресурсов, объявленные непосредственно в этот элемент. Это отличается от фактического процесса поиска ресурсов, где дочерний элемент можно использовать все ресурсы, определенные в каждом родительском элементе, поиск вверх рекурсивно.  
  
 Ресурсы можно ссылаться с помощью кода из коллекции, но имейте в виду, что ресурсы созданы в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] , определенно не будут доступны до после <xref:System.Windows.FrameworkElement.Loaded> элементом, который объявляет словаря. На самом деле, ресурсы, анализируются асинхронно и не даже <xref:System.Windows.FrameworkElement.Loaded> событий является гарантией того, вы можете ссылаться на [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] определенных ресурсов. По этой причине следует обычно только обращаться к [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] ресурсы, определяемые как часть кода среды выполнения, или через другие [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] методы, такие как стили или ссылки на расширения ресурсов для значений атрибутов. При доступе к ресурсам с помощью кода, это по существу эквивалентно [DynamicResource](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) ссылку из [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 Базовый <xref:System.Windows.ResourceDictionary> поддерживает методы, необходимые для добавления, удаления или запроса ресурсов из коллекции с помощью кода. <xref:System.Windows.FrameworkElement.Resources%2A> Свойство является настраиваемым для поддержки сценария полной замены ресурсам коллекцию новый или другой элемент <xref:System.Windows.ResourceDictionary>.  
  
 Обратите внимание, что [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] синтаксиса не включает элемент для <xref:System.Windows.ResourceDictionary>. Ниже приведен пример неявного синтаксиса коллекции; можно опустить тег, представляющий элемент коллекции. Вместо этого указываются элементы, которые будут добавлены как элементы в коллекцию. Дополнительные сведения о неявных коллекциях и [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], см. в разделе [XAML подробное описание синтаксиса](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md). Один случай где <xref:System.Windows.ResourceDictionary> по-прежнему указывается явно как элемент, Представляем объединенный словарь, в этом случае существует обычно нет дочерних элементов для этого <xref:System.Windows.ResourceDictionary>. Дополнительные сведения см. в разделе [объединенные словари ресурсов](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).  
  
<a name="xamlPropertyElementUsage_Resources"></a>   
## <a name="xaml-property-element-usage"></a>Использование элемента свойства XAML  
  
```  
<object>  
  <object.Resources>  
    oneOrMoreResourceElements  
  </object.Resources>  
</object>  
```  
  
<a name="xamlValues_Resources"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *oneOrMoreResourceElements*  
 Один или несколько объектов элементов, каждый из которых определяет ресурс. В каждом элементе свойства ресурсов в каждом <xref:System.Windows.ResourceDictionary> должен иметь уникальное значение для [директивы x: Key](~/docs/framework/xaml-services/x-key-directive.md), который используется в качестве уникального ключа при получении значений из <xref:System.Windows.ResourceDictionary>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Application.Resources" />
        <related type="Article" href="https://msdn.microsoft.com/library/1985cd45-f197-42d5-b75e-886add64b248">x: Key-атрибут</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBinding">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Присоединяет привязку к этому элементу для указанного свойства зависимостей.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression SetBinding(class System.Windows.DependencyProperty dp, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, path As String) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * string -&gt; System.Windows.Data.BindingExpression" Usage="frameworkElement.SetBinding (dp, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dp">Идентифицирует свойство назначения, к которому следует установить привязку.</param>
        <param name="path">Имя исходного свойства или путь к свойству, используемому для привязки.</param>
        <summary>Прикрепляет привязку к данному элементу на основе указанного имени исходного свойства в виде классификационного пути к источнику данных.</summary>
        <returns>Фиксирует состояния привязки. Это возвращаемое значение можно использовать для проверки ошибок.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод — это удобный метод для вызова <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, который передает текущий экземпляр как <xref:System.Windows.DependencyObject>и создает новый <xref:System.Windows.Data.Binding> на основе предоставленной `path` параметра. Эта подпись является более удобным, если устанавливается простой привязки по умолчанию. Если вам нужно указать любые свойства привязки для условия не по умолчанию, или хотите использовать <xref:System.Windows.Data.MultiBinding> или <xref:System.Windows.Data.PriorityBinding>, следует использовать <xref:System.Windows.FrameworkElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> подписи.  
  
   
  
## Examples  
 Следующий пример задает привязку, по определенному пути.  
  
 [!code-csharp[BaseElementsSmorgasbord#SetBindingPath](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#setbindingpath)]
 [!code-vb[BaseElementsSmorgasbord#SetBindingPath](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#setbindingpath)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, binding As BindingBase) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpressionBase ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::Windows::Data::BindingBase ^ binding);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * System.Windows.Data.BindingBase -&gt; System.Windows.Data.BindingExpressionBase" Usage="frameworkElement.SetBinding (dp, binding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="dp">Определяет свойство, которому следует установить привязку.</param>
        <param name="binding">Представляет подробные сведения о привязки данных.</param>
        <summary>Прикрепляет привязку к данному элементу на основе предоставленной привязки объекта.</summary>
        <returns>Фиксирует состояния привязки. Это возвращаемое значение можно использовать для проверки ошибок.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод — это удобный метод для вызова <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, который передает текущий экземпляр как <xref:System.Windows.DependencyObject>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetFlowDirection">
      <MemberSignature Language="C#" Value="public static void SetFlowDirection (System.Windows.DependencyObject element, System.Windows.FlowDirection value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetFlowDirection(class System.Windows.DependencyObject element, valuetype System.Windows.FlowDirection value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetFlowDirection(System.Windows.DependencyObject,System.Windows.FlowDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetFlowDirection (element As DependencyObject, value As FlowDirection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetFlowDirection(System::Windows::DependencyObject ^ element, System::Windows::FlowDirection value);" />
      <MemberSignature Language="F#" Value="static member SetFlowDirection : System.Windows.DependencyObject * System.Windows.FlowDirection -&gt; unit" Usage="System.Windows.FrameworkElement.SetFlowDirection (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.FlowDirection" />
      </Parameters>
      <Docs>
        <param name="element">Элемент, указывающий направление потока.</param>
        <param name="value">Значение перечисления, указывающее направление.</param>
        <summary>Задает значение присоединенного свойства <see cref="P:System.Windows.FrameworkElement.FlowDirection" /> указанного элемента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод поддерживает синтаксис присоединенное свойство <xref:System.Windows.FrameworkElement.FlowDirection%2A> свойство, таким образом позволяя дочерних элементов заданного <xref:System.Windows.FrameworkElement> для указания направления потока для размещения в родительском элементе. Для задания значения в текущем <xref:System.Windows.FrameworkElement>, использовать прямые [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] доступа <xref:System.Windows.FrameworkElement.FlowDirection%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.FlowDirection" />
      </Docs>
    </Member>
    <Member MemberName="SetResourceReference">
      <MemberSignature Language="C#" Value="public void SetResourceReference (System.Windows.DependencyProperty dp, object name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetResourceReference(class System.Windows.DependencyProperty dp, object name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetResourceReference (dp As DependencyProperty, name As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetResourceReference(System::Windows::DependencyProperty ^ dp, System::Object ^ name);" />
      <MemberSignature Language="F#" Value="member this.SetResourceReference : System.Windows.DependencyProperty * obj -&gt; unit" Usage="frameworkElement.SetResourceReference (dp, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="name" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">Свойство, к которому привязан ресурс.</param>
        <param name="name">Имя ресурса.</param>
        <summary>Выполняет поиск ресурса по указанному имени и устанавливает ссылку на этот ресурс для указанного свойства.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ссылка на ресурс похоже на использование [расширение разметки DynamicResource](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) в разметке. Ссылка на ресурс создает внутреннее выражение, содержащий значение заданного свойства на основе отложенного выполнения. Выражение будет повторно вычисляться каждый раз, когда словарь ресурсов указывает измененного значения через внутренние события, или при каждом изменении родителя текущего элемента (родителя изменяется путь для поиска словаря).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.Application.Resources" />
        <altmember cref="P:System.Windows.FrameworkElement.Resources" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeResources">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeResources" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeResources () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeResources();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeResources : unit -&gt; bool" Usage="frameworkElement.ShouldSerializeResources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает логическое значение, указывающее, следует ли процессам сериализации сериализировать содержимое свойства <see cref="P:System.Windows.FrameworkElement.Resources" />.</summary>
        <returns>Значение <see langword="true" />, если значение свойства <see cref="P:System.Windows.FrameworkElement.Resources" /> подлежит сериализации, в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта команда возвращает `true` до тех пор, пока есть хотя бы один ресурс с ключом в локальной <xref:System.Windows.FrameworkElement.Resources%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeStyle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeStyle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeStyle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeStyle();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeStyle : unit -&gt; bool" Usage="frameworkElement.ShouldSerializeStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает логическое значение, указывающее, следует ли процессам сериализации сериализировать содержимое свойства <see cref="P:System.Windows.FrameworkElement.Style" />.</summary>
        <returns>Значение <see langword="true" />, если значение свойства <see cref="P:System.Windows.FrameworkElement.Style" /> подлежит сериализации, в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта команда возвращает `true` Если <xref:System.Windows.Style> устанавливается локально.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTriggers">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTriggers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTriggers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeTriggers" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTriggers () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTriggers();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTriggers : unit -&gt; bool" Usage="frameworkElement.ShouldSerializeTriggers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает логическое значение, указывающее, следует ли процессам сериализации сериализировать содержимое свойства <see cref="P:System.Windows.FrameworkElement.Triggers" />.</summary>
        <returns>Значение <see langword="true" />, если значение свойства <see cref="P:System.Windows.FrameworkElement.Triggers" /> подлежит сериализации, в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает `true` Если <xref:System.Windows.FrameworkElement.Triggers%2A> свойства устанавливается локально.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.SizeChangedEventHandler SizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.SizeChangedEventHandler SizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.SizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SizeChanged As SizeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::SizeChangedEventHandler ^ SizeChanged;" />
      <MemberSignature Language="F#" Value="member this.SizeChanged : System.Windows.SizeChangedEventHandler " Usage="member this.SizeChanged : System.Windows.SizeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SizeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении значения любого из свойств <see cref="P:System.Windows.FrameworkElement.ActualHeight" /> или <see cref="P:System.Windows.FrameworkElement.ActualWidth" /> данного элемента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 События с прямой маршрутизацией не выполняйте маршрут, они обрабатываются только внутри элемента, на котором они вызываются. Прямые перенаправленные события поддерживают другие поведения перенаправленного события: они поддерживают коллекцию доступных обработчиков и могут использоваться в качестве <xref:System.Windows.EventTrigger> в стиле.  
  
 Система макета считывает свойства <xref:System.Windows.SizeChangedEventArgs> класс аргументов этого события, чтобы определить ли сообщенные изменения размера должно считаться важным. Это позволяет системе макета или реализации макет элемента управления во избежание принудительного обновления структуры из-за визуально неощутимо различий между значениями старого и нового высоты или ширины. Из-за округления или аналогичного результата вычисления типов данных с плавающей запятой может быть неощутимо различия.  
  
<a name="routedEventInfo_SizeChanged"></a>   
## <a name="routed-event-information"></a>Сведения о маршрутизируемом событии  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.SizeChangedEvent>|  
|Стратегия маршрутизации|Direct|  
|делегат|<xref:System.Windows.SizeChangedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Height" />
        <altmember cref="P:System.Windows.FrameworkElement.Width" />
      </Docs>
    </Member>
    <Member MemberName="SizeChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent SizeChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent SizeChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.SizeChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SizeChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ SizeChangedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable SizeChangedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.SizeChangedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует направленное событие <see cref="E:System.Windows.FrameworkElement.SizeChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Идентификаторы перенаправленных событий создаются при их регистрации. Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события. Эти идентификаторы можно использовать для добавления обработчиков классов.  
  
 Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.SourceUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ SourceUpdated;" />
      <MemberSignature Language="F#" Value="member this.SourceUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.SourceUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении исходного значения любого существующего свойства, привязанного к данному элементу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие создает псевдоним для <xref:System.Windows.Data.Binding.SourceUpdated> событие, вызванное каким-либо <xref:System.Windows.Data.Binding> связанных с этим элементом.  
  
<a name="xamlAttributeUsage_SourceUpdated"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object SourceUpdated="eventHandler"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Data.Binding.SourceUpdated" />
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public System.Windows.Style Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ Style { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Style : System.Windows.Style with get, set" Usage="System.Windows.FrameworkElement.Style" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает стиль, который должен использоваться этим элементом при его отрисовке.</summary>
        <value>Примененный стиль не по умолчанию для элемента, если присутствует. В противном случае — значение <see langword="null" />. Значение по умолчанию для созданного по умолчанию <see cref="T:System.Windows.FrameworkElement" /> — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для элементов управления текущий стиль часто предоставляемые стиль по умолчанию из темы элементов управления или из стилей обычно применяется к элементам управления этого типа ресурсами на уровне страницы или приложения (неявный стиль). Это свойство не по умолчанию устанавливает и не возвращает стили (темы), но возвращает неявный стиль или явный стиль, действующий на элемент. В случае явного или неявного стили неважно ли стиль задается как ресурс или определенные локально.  
  
 Задание стилей имеет некоторые ограничения. Вы можете сбросить всего <xref:System.Windows.FrameworkElement.Style%2A> свойство в новый <xref:System.Windows.Style> в любое время, что вынудит рекомпозиции макета. Тем не менее, как можно быстрее, так как этот стиль размещается используется загруженным элементом <xref:System.Windows.Style> должно считаться запечатанный. Попытка внести изменение любого отдельного свойства используемого стиля (такие как любые действия в коллекцию <xref:System.Windows.Style.Setters%2A>) приводит к возникновению исключения, исключение. Стиль, определенный в разметке считается используется как только он загружается из словаря ресурсов (для ресурсов) или загрузке страницы, в которой оно содержится в (для встроенных стилей).  
  
 <xref:System.Windows.FrameworkElement.Style%2A> является свойством зависимостей с помощью специальных приоритет. Локально заданное стиль обычно действует с наивысшим приоритетом в системе свойств. Если <xref:System.Windows.FrameworkElement.Style%2A> имеет значение null на этом этапе во время загрузки, система свойств ищет неявных стилей в локальном или приложение ресурсов этого типа. Если стиль равен null после выполнения этого шага, то действующий стиль для целей представления обычно поступает из стиля по умолчанию (тема), но стиль по умолчанию не возвращается в <xref:System.Windows.FrameworkElement.Style%2A> значение свойства. См. в разделе [приоритет значений свойств зависимостей](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md) или [Стилизация и использование шаблонов](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
<a name="xamlAttributeUsage_Style"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object Style="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_Style"></a>   
## <a name="xaml-property-element-usage"></a>Использование элемента свойства XAML  
  
<a name="xamlValues_Style"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *ResourceExtension*  
 Одно из следующих:, или. См. в разделе [ресурсы XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *styleResourceKey*  
 Ключ, который идентифицирует запрашиваемый стиль. Ключ ссылается на существующий ресурс в <xref:System.Windows.ResourceDictionary>.  
  
> [!NOTE]
>  Синтаксис элемента свойства технически возможно, но не рекомендуется для большинства сценариев стилей. См. в разделе [встроенные стили и шаблоны](~/docs/framework/wpf/advanced/inline-styles-and-templates.md). Ссылка на привязку с помощью [TemplateBinding](~/docs/framework/wpf/advanced/templatebinding-markup-extension.md) или <xref:System.Windows.Data.Binding> — также, возможно, но встречается редко.  
  
<a name="dependencyPropertyInfo_Style"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.StyleProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 В следующем примере определяется стиль в словаре ресурсов.  
  
 [!code-xaml[FEResource#StyleProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty)]  
[!code-xaml[FEResource#StyleProperty2](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty2)]  
[!code-xaml[FEResource#StyleProperty3](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty3)]  
[!code-xaml[FEResource#StyleProperty4](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty StyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty StyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.StyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ StyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable StyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.StyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.Style" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="propertyName">Имя запрошенного внешнего свойства.</param>
        <summary>Описание этого элемента содержится в методе <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" />.</summary>
        <returns>Значение <see langword="true" />, если свойство с именем в параметре <paramref name="propertyName" /> доступно; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный элемент является явной реализацией элемента интерфейса. Он может использоваться только при условии, что экземпляр класса <xref:System.Windows.FrameworkElement> приведен к типу интерфейса <xref:System.Windows.Markup.IQueryAmbient>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Windows.FrameworkElement.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение или установка произвольного значения объекта, которое может использоваться для хранения особых сведений об этом элементе.</summary>
        <value>Целевое значение. Это свойство не имеет значения по умолчанию.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство является аналогом свойства тега в других моделях программирования для Microsoft, таких как Visual Basic для приложений или Windows Forms. <xref:System.Windows.FrameworkElement.Tag%2A> предназначена для предоставления существующего свойства расположению, где можно хранить некоторые основные пользовательские сведения о любом <xref:System.Windows.FrameworkElement> без необходимости в подкласс элемента.  
  
 Так как это свойство принимает объект, необходимо использовать использование элемента свойства, чтобы задать <xref:System.Windows.FrameworkElement.Tag%2A> свойства в XAML только на объект с известным и встроенный тип преобразователя, например строку. Объекты, используемые таким образом, обычно не входят в стандартные пространства имен WPF и поэтому может потребоваться сопоставление пространства имен с внешним пространством имен для новых элементов XAML. Дополнительные сведения см. в разделе [пространства имен XAML и сопоставление пространств имен для WPF XAML](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md) и [XAML и пользовательские классы для WPF](~/docs/framework/wpf/advanced/xaml-and-custom-classes-for-wpf.md).  
  
<a name="dependencyPropertyInfo_Tag"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.TagProperty>|  
|Значение свойства метаданных `true`|Нет|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="TagProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TagProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TagProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.TagProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TagProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TagProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TagProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.TagProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет свойство зависимостей <see cref="P:System.Windows.FrameworkElement.Tag" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.TargetUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TargetUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ TargetUpdated;" />
      <MemberSignature Language="F#" Value="member this.TargetUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.TargetUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении целевого значения для любого свойства, привязанного к этому элементу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие создает псевдоним для <xref:System.Windows.Data.Binding.TargetUpdated> событие, вызванное каким-либо <xref:System.Windows.Data.Binding> связанных с этим элементом. Обычно это означает, что рассматриваемая представляет собой двустороннюю привязку и что связанного свойства зависимостей подтверждает, что предыдущее значение свойства стало недопустимым с точки зрения проверку или схеме кеширования, который поддерживает свойство или источник данных.  
  
 Используйте данные <xref:System.Windows.FrameworkElement.TargetUpdated> событие, чтобы определить специального свойства, которое сообщает, обновления целевого значения.  
  
<a name="xamlAttributeUsage_TargetUpdated"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object TargetUpdated="eventHandler"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Data.Binding.TargetUpdated" />
      </Docs>
    </Member>
    <Member MemberName="TemplatedParent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject TemplatedParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject TemplatedParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.TemplatedParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TemplatedParent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ TemplatedParent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TemplatedParent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkElement.TemplatedParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает ссылку на родительский объект шаблона данного элемента. Это свойство не актуально, если элемент не был создан с помощью шаблона.</summary>
        <value>Элемент, свойство <see cref="T:System.Windows.FrameworkTemplate" /> шаблона <see cref="P:System.Windows.FrameworkTemplate.VisualTree" />  которого вызвало создание данного элемента. Это значение часто равно <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.TemplatedParent%2A> часто `null` для объектов, которые создаются в разметке приложения или код. Это так, как создать эти объекты напрямую, не с помощью шаблона. Ссылки на полученные путем прохода логического дерева от корня или по типичное имя ссылки на объекты, не исходят из шаблона.  
  
 Ситуации, когда <xref:System.Windows.FrameworkElement.TemplatedParent%2A> может оказаться `null` включают операции, такие как проверка нажатия, обработка событий для определенных низкоуровневых событий ввода, прохода визуального дерева с <xref:System.Windows.Media.VisualTreeHelper>, или работа с перечислителями, могут возвращать элементы, поступившие на основе шаблонов. Другой вариант — если специально вызывать <xref:System.Windows.FrameworkTemplate.FindName%2A> от существующего <xref:System.Windows.FrameworkTemplate> . они работают с возвращаемый объект.  
  
 Шаблоны являются фактически общих объектов, в которой содержимое шаблона создаются только один раз. Таким образом Если получить ссылку на элемент, который поступил из шаблона, вы обнаружите, что заметно логическое дерево не удалось связаться с корневой страницы. Чтобы подключить такую ссылку шаблона для логического дерева страницы, вы должны получить <xref:System.Windows.FrameworkElement.TemplatedParent%2A> значение и продолжать переместиться в этом дереве элемент, при необходимости.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTip">
      <MemberSignature Language="C#" Value="public object ToolTip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ToolTip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ToolTip" />
      <MemberSignature Language="VB.NET" Value="Public Property ToolTip As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ToolTip { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ToolTip : obj with get, set" Usage="System.Windows.FrameworkElement.ToolTip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.ToolTip)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает объект подсказки, отображаемый для данного элемента в [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</summary>
        <value>Объект подсказки.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если значение этого свойства имеет тип <xref:System.Windows.Controls.ToolTip>, то это значение является всплывающей подсказки, которые используются для [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].  Если значение любого другого типа, то это значение будет использоваться в качестве *содержимого* для <xref:System.Windows.Controls.ToolTip> предоставленные (создан) системой. Дополнительные сведения см. в разделе <xref:System.Windows.Controls.ToolTipService>. Служебный класс предоставляет вложенные свойства, которые могут использоваться для дальнейшей настройки <xref:System.Windows.Controls.ToolTip>.  
  
<a name="xamlAttributeUsage_ToolTip"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object ToolTip="toolTipContent"/>  
```  
  
<a name="xamlPropertyElementUsage_ToolTip"></a>   
## <a name="xaml-property-element-usage"></a>Использование элемента свойства XAML  
  
```  
<object>  
  <object.ToolTip>  
    <ToolTip .../>  
  </object.ToolTip>  
</object>  
- or -  
<object>  
  <object.ToolTip>  
    toolTipObjectContent  
  </object.ToolTip>  
</object>  
```  
  
<a name="xamlValues_ToolTip"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *toolTipContent*  
 Строка, которая становится отображаемый текст для <xref:System.Windows.FrameworkElement.ToolTip%2A>.  
  
 *toolTipObjectContent*  
 Некоторые объектом, указанным в форме элемента объекта, который должен использоваться как содержимое <xref:System.Windows.FrameworkElement> . Обычно это было бы <xref:System.Windows.FrameworkElement> или другой элемент, который создает композиции макета для <xref:System.Windows.FrameworkElement.ToolTip%2A>, со временем, содержащий текстовое содержимое в композиции. При таком использовании <xref:System.Windows.Controls.ToolTip> создается элемент неявно из проанализированный [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]и *toolTipObjectContent* содержимое устанавливается в качестве его <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType> свойство.  
  
 <`ToolTip` .../>  
 См. раздел <xref:System.Windows.Controls.ToolTip>.  
  
<a name="dependencyPropertyInfo_ToolTip"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.ToolTipProperty>|  
|Значение свойства метаданных `true`|Нет|  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Windows.Controls.ToolTip> в код, а затем устанавливает <xref:System.Windows.FrameworkElement.ToolTip%2A> свойство <xref:System.Windows.Controls.Primitives.StatusBar> элемента управления.  
  
 [!code-csharp[StatusBar#MakeProgressBar](~/samples/snippets/csharp/VS_Snippets_Wpf/StatusBar/CSharp/Window1.xaml.cs#makeprogressbar)]
 [!code-vb[StatusBar#MakeProgressBar](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StatusBar/visualbasic/window1.xaml.vb#makeprogressbar)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ToolTipClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipClosing As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipClosing;" />
      <MemberSignature Language="F#" Value="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит непосредственно перед закрытием какой-либо подсказки в элементе.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Пометка <xref:System.Windows.FrameworkElement.ToolTipClosing> событие как обработанное не отменяет закрытие подсказки. Если подсказка отображается, закрытие подсказки выполняется только в ответ на взаимодействие пользователя с помощью пользовательского интерфейса.  
  
 Это событие не может быть <xref:System.Windows.EventTrigger> в стиле. Это потому, что поле идентификатора данного события повторно использует реализацию из службы, не предоставляет методы Добавление и удаление событий для события уровня службы.  
  
<a name="routedEventInfo_ToolTipClosing"></a>   
## <a name="routed-event-information"></a>Сведения о маршрутизируемом событии  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.ToolTipClosingEvent>|  
|Стратегия маршрутизации|Direct|  
|делегат|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
-   Переопределить <xref:System.Windows.FrameworkElement.OnToolTipClosing%2A> реализовать обработчик класса для этого события в производных классах.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ToolTip" />
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ToolTipClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует направленное событие <see cref="E:System.Windows.FrameworkElement.ToolTipClosing" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Идентификаторы перенаправленных событий создаются при их регистрации. Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события. Эти идентификаторы можно использовать для добавления обработчиков классов.  
  
 Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ToolTipOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipOpening As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipOpening;" />
      <MemberSignature Language="F#" Value="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при открытии любой всплывающей подсказки к элементу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы предотвратить появление в пользовательском Интерфейсе, ваш обработчик для всплывающей подсказки <xref:System.Windows.FrameworkElement.ToolTipOpening> можно пометить <xref:System.Windows.Controls.ToolTipEventArgs> обрабатываются данные события. В противном случае отображается подсказка, используя значение <xref:System.Windows.FrameworkElement.ToolTip%2A> свойство как содержимое подсказки. Другой возможный сценарий — что можно написать обработчик, который сбрасывает значение <xref:System.Windows.FrameworkElement.ToolTip%2A> свойства для элемента, который является источником события, непосредственно перед отображением всплывающей подсказки.  
  
 <xref:System.Windows.FrameworkElement.ToolTipOpening> не будет вызываться, если значение <xref:System.Windows.FrameworkElement.ToolTip%2A> является `null` или иным способом не задано. Не устанавливайте намеренно <xref:System.Windows.FrameworkElement.ToolTip%2A> для `null` пока открыт всплывающей подсказки или открыв; это не будет действовать закрытия подсказки и создаст нежелательный визуальный артефакт в пользовательском Интерфейсе.  
  
 <xref:System.Windows.FrameworkElement.ToolTipOpening> Событие не может быть <xref:System.Windows.EventTrigger> в стиле. Это потому, что поле идентификатора данного события повторно использует реализацию из службы, не предоставляет методы Добавление и удаление событий для события уровня службы.  
  
<a name="routedEventInfo_ToolTipOpening"></a>   
## <a name="routed-event-information"></a>Сведения о маршрутизируемом событии  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.ToolTipOpeningEvent>|  
|Стратегия маршрутизации|Direct|  
|делегат|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
-   Переопределить <xref:System.Windows.FrameworkElement.OnToolTipClosing%2A> реализовать обработчик класса для этого события в производных классах.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ToolTip" />
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ToolTipOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует направленное событие <see cref="E:System.Windows.FrameworkElement.ToolTipOpening" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Идентификаторы перенаправленных событий создаются при их регистрации. Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события. Эти идентификаторы можно использовать для добавления обработчиков классов.  
  
 Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ToolTipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ToolTipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ToolTipProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ToolTipProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет свойство зависимостей <see cref="P:System.Windows.FrameworkElement.ToolTip" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Triggers">
      <MemberSignature Language="C#" Value="public System.Windows.TriggerCollection Triggers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.TriggerCollection Triggers" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Triggers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Triggers As TriggerCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TriggerCollection ^ Triggers { System::Windows::TriggerCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Triggers : System.Windows.TriggerCollection" Usage="System.Windows.FrameworkElement.Triggers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.TriggerCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает коллекцию триггеров, установленных непосредственно в этом элементе или в его дочерних элементах.</summary>
        <value>Строго типизированная коллекция объектов <see cref="T:System.Windows.Trigger" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Это свойство можно задать только в [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] через показанного синтаксиса коллекции или путем доступа к объекту коллекции и использования его различных методов, например Add. Свойство для доступа к объекту коллекции только для чтения, сама эта коллекция является чтения и записи. Это свойство существует только в корневых элементах; Попытка найти или задать другое расположение вызовет исключение.  
  
 Это свойство позволяет проверять триггеры, существующие как часть стилей, используемых в этом элементе. Он только сообщает коллекцию триггеров, которые буквально добавляются в коллекцию, либо в разметку или код. Элементы обычно не имеют таких элементов по умолчанию (с помощью шаблона для экземпляра); очень часто триггеры, поступающие из композиции элементов управления, устанавливаются в стилях.  
  
 С точки зрения поведение (и устанавливается, какой эффект поступил из объявленного элемента <xref:System.Windows.FrameworkElement.Triggers%2A> коллекции), условие триггера и его эффект может быть данного элемента, или на его дочерние элементы в логическом дереве. Обратите внимание, что при использовании события времени жизни <xref:System.Windows.FrameworkElement.Loaded> для получения этой коллекции триггеров дочернего элемента могут еще не быть полностью загружены, и коллекция будет меньше, чем было бы действительно во время выполнения.  
  
 Обратите внимание, что поддерживает только коллекцию триггеров, установленных на элементе <xref:System.Windows.EventTrigger>, не триггеры свойств (<xref:System.Windows.Trigger>). Если вам требуется триггеры свойств, необходимо разместить их в стиле или шаблоне и затем применить этот стиль или шаблон к элементу либо непосредственно через <xref:System.Windows.FrameworkElement.Style%2A> свойства, либо косвенно через неявную ссылку на стиль.  
  
<a name="xamlPropertyElementUsage_Triggers"></a>   
## <a name="xaml-property-element-usage"></a>Использование элемента свойства XAML  
  
```  
<object>  
  <object.Triggers>  
    oneOrMoreTriggers  
  </object.Triggers>  
</object>  
```  
  
<a name="xamlValues_Triggers"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *OneOrMoreTriggers*  
 Один или несколько определенных <xref:System.Windows.EventTrigger> элементов. Каждый такой триггер должен содержать допустимые действия раскадровки и ссылки. Обратите внимание на то, что эта коллекция может быть установлено только для корневого элемента страницы. Дополнительные сведения см. в разделе [Общие сведения о Storyboard](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.EventTrigger" />
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="frameworkElement.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Ключевой идентификатор искомого ресурса.</param>
        <summary>Ищет ресурс с указанным ключом и возвращает его, если он найден.</summary>
        <returns>Найденный ресурс или значение <see langword="null" />, если ресурс с указанным <paramref name="key" /> не обнаружен.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если ресурс не найден в вызывающем элементе, выполняется поиск в дереве ресурсов родительского вверх по логическому дереву, таким же образом, который бы были запрошены искомая Если ресурс по ключу во время выполнения. Этот метод возвращает `null` только в том случае, если ресурс этого ключа не существует в любом месте в дереве ресурсов в существующих условий дерева во время, <xref:System.Windows.FrameworkElement.TryFindResource%2A> вызывается.  
  
 Обычно вы сразу же привести возвращаемое значение к типу свойства, которое вы пытаетесь значения возвращаемым ресурсом.  
  
 <xref:System.Windows.FrameworkElement.FindResource%2A> Метод имеет аналогичное поведение, за исключением того, что он создает исключение, если ресурс с указанным ключом не было возвращено.  
  
   
  
## Examples  
 В следующем примере реализуется как обработчик кнопки, где кнопку наборов фоном кисти ресурс определен получен путем вызова <xref:System.Windows.FrameworkElement.TryFindResource%2A> на себя. Это обходит дерево элементов и поиск ресурса (сам ресурс определен в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] и не отображается).  
  
 [!code-csharp[BaseElementsSmorgasbord#FETryFindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#fetryfindresource)]
 [!code-vb[BaseElementsSmorgasbord#FETryFindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#fetryfindresource)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Unloaded;" />
      <MemberSignature Language="F#" Value="member this.Unloaded : System.Windows.RoutedEventHandler " Usage="member this.Unloaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при удалении элемента из дерева с загруженными элементами.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 События с прямой маршрутизацией не выполняйте маршрут, они обрабатываются только внутри элемента, на котором они вызываются. Прямые перенаправленные события поддерживают другие поведения перенаправленного события: они поддерживают коллекцию доступных обработчиков и могут использоваться в качестве <xref:System.Windows.EventTrigger> в стиле.  
  
 <xref:System.Windows.FrameworkElement.Loaded> и <xref:System.Windows.FrameworkElement.Unloaded> оба возникающие в элементах управления, в результате изменения темы системы, инициированного пользователем. Изменение темы делает недействительность шаблон элемента управления и автономной визуальное дерево, которое в свою очередь вызывает весь элемент управления для выгрузки и повторной загрузки. Таким образом <xref:System.Windows.FrameworkElement.Unloaded> нельзя предполагать, происходят только при навигации за пределы страницы.  
  
 Обратите внимание, что <xref:System.Windows.FrameworkElement.Unloaded> событие не происходит после начала приложение завершает работу. Завершение работы приложения происходит, когда определяются условия <xref:System.Windows.Application.ShutdownMode%2A> происходит свойство. Если вы поместите код очистки в обработчике для <xref:System.Windows.FrameworkElement.Unloaded> событий, таких как <xref:System.Windows.Window> или <xref:System.Windows.Controls.UserControl>, он может не вызываться должным образом.  
  
<a name="routedEventInfo_Unloaded"></a>   
## <a name="routed-event-information"></a>Сведения о маршрутизируемом событии  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.UnloadedEvent>|  
|Стратегия маршрутизации|Direct|  
|делегат|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="UnloadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent UnloadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent UnloadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.UnloadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnloadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ UnloadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnloadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.UnloadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует направленное событие <see cref="E:System.Windows.FrameworkElement.Unloaded" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Идентификаторы перенаправленных событий создаются при их регистрации. Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события. Эти идентификаторы можно использовать для добавления обработчиков классов.  
  
 Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.UnregisterName : string -&gt; unit" Usage="frameworkElement.UnregisterName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Имя пары имя-объект, которую необходимо удалить из текущей области видимости.</param>
        <summary>Упрощает доступ к методу отмены регистрации <see cref="T:System.Windows.NameScope" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Требуется отменять регистрацию имен Если планируется повторно зарегистрировать другой элемент с таким же именем.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.RegisterName(System.String,System.Object)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultStyle">
      <MemberSignature Language="C#" Value="public void UpdateDefaultStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateDefaultStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.UpdateDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateDefaultStyle ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateDefaultStyle();" />
      <MemberSignature Language="F#" Value="member this.UpdateDefaultStyle : unit -&gt; unit" Usage="frameworkElement.UpdateDefaultStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Повторно применяет стиль по умолчанию к текущему объекту <see cref="T:System.Windows.FrameworkElement" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseLayoutRounding">
      <MemberSignature Language="C#" Value="public bool UseLayoutRounding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseLayoutRounding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.UseLayoutRounding" />
      <MemberSignature Language="VB.NET" Value="Public Property UseLayoutRounding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseLayoutRounding { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseLayoutRounding : bool with get, set" Usage="System.Windows.FrameworkElement.UseLayoutRounding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, должно ли применяться округление макета для размера и позиции данного элемента во время структурирования.</summary>
        <value>Значение <see langword="true" />, если округление макета применяется; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Windows.FrameworkElement.UseLayoutRounding%2A> свойство для элемента является `true`, все пикселей не целочисленные значения, которые вычисляются во время <xref:System.Windows.UIElement.Measure%2A> и <xref:System.Windows.UIElement.Arrange%2A> передает округляются до целых значений пикселей.  
  
 Это свойство наследуется дочерними элементами.  
  
> [!NOTE]
>  Необходимо задать <xref:System.Windows.FrameworkElement.UseLayoutRounding%2A> для `true` в корневом элементе. Система макета добавляет координаты дочернего координат родительского; Таким образом Если координаты родительского элемента не на границе пикселов, координаты дочернего, также не на границе пикселей. Если <xref:System.Windows.FrameworkElement.UseLayoutRounding%2A> не может быть в корне, задайте <xref:System.Windows.UIElement.SnapsToDevicePixels%2A> дочерних элементов для получения необходимого эффекта.  
  
 Графические объекты на границах пикселей устраняет полупрозрачные края, производимые сглаживания, когда границы попадает в середину пикселя устройства. Ниже показаны выходные данные из одного пикселя нулевой ширины строки, попадает в середину пикселя устройства. В строке в левой части не использует округление макета и является сглаженными. Строка справа использует округление макета.  
  
 ![Противодействия&#45;псевдоним линия в сравнении с одной точки строки. ] (~/add/media/pixelsnaplinecompare.PNG "Сглаженная линия, по сравнению с размером в один пиксель строки.")  
  
 При использовании округление макета и <xref:System.Windows.GridUnitType.Star> определения размера, система макета создает небольшие вариации в измерениях столбцов или строк, чтобы избежать субпиксельной визуализации. Например, если сетка содержит шириной 100 с 3 столбцами размера <xref:System.Windows.GridUnitType.Star>, вместо создания трех столбцов, имеющих ширину 33,3, система макета создает 2 столбцов, имеющих ширину 33 и один шириной 34.  
  
> [!NOTE]
>  В .NET 4.6 для снижения числа вхождений обрезки в элементах управления с границами в округление макетов внесены изменения. По умолчанию эта функция включена, если целевой платформой является .NET Framework 4.6 или более поздней. Приложений, предназначенных для более ранних версий платформы, можно выбрать новое поведение, добавив следующий параметр в файл app.config: `<runtime><AppContextSwitchOverrides value="Switch.MS.Internal.DoNotApplyLayoutRoundingToMarginsAndBorderThickness=false"/></runtime>` Настройка оказывает эффект только в том случае, когда приложение выполняется на платформе .NET Framework 4.6.  
  
   
  
## Examples  
 В следующем примере демонстрируется эффект, <xref:System.Windows.FrameworkElement.UseLayoutRounding%2A> свойство имеет один пиксель нулевой ширины строки. Строки в левой части использует округление макета, в строке, в правой части используется округление макета. Если медленно изменения размера окна, можно увидеть разницу, округлением макета.  
  
```xaml  
  
<Page x:Class="LayoutRounding.Lines"  
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"  
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"  
    Title="Lines" Name="linesPage"  
    >  
  <StackPanel Width="150"  Margin="7" Orientation="Horizontal">  
    <!-- Single pixel line with layout rounding turned OFF.-->  
    <Rectangle UseLayoutRounding="False"  
       Width="45.5" Margin="10" Height="1" Fill="Red"/>  
    <!-- Single pixel line with layout rounding turned ON.-->  
    <Rectangle UseLayoutRounding="True"  
      Width="45.5" Margin="10" Height="1" Fill="Red"/>  
  </StackPanel>  
  <!-- Background Grid -->  
  <Page.Background>  
    <DrawingBrush  Viewport="0,0,10,10" ViewportUnits="Absolute" TileMode="Tile">  
      <DrawingBrush.Drawing>  
        <DrawingGroup>  
          <GeometryDrawing Brush="White">  
            <GeometryDrawing.Geometry>  
              <RectangleGeometry Rect="0,0,1,1" />  
            </GeometryDrawing.Geometry>  
          </GeometryDrawing>  
          <GeometryDrawing Geometry="M0,0 L1,0 1,0.1, 0,0.1Z " Brush="#CCCCFF" />  
          <GeometryDrawing Geometry="M0,0 L0,1 0.1,1, 0.1,0Z" Brush="#CCCCFF" />  
        </DrawingGroup>  
      </DrawingBrush.Drawing>  
    </DrawingBrush>  
  </Page.Background>  
</Page>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseLayoutRoundingProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty UseLayoutRoundingProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty UseLayoutRoundingProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.UseLayoutRoundingProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UseLayoutRoundingProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ UseLayoutRoundingProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable UseLayoutRoundingProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.UseLayoutRoundingProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.UseLayoutRounding" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.VerticalAlignment VerticalAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.VerticalAlignment VerticalAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.VerticalAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property VerticalAlignment As VerticalAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::VerticalAlignment VerticalAlignment { System::Windows::VerticalAlignment get(); void set(System::Windows::VerticalAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.VerticalAlignment : System.Windows.VerticalAlignment with get, set" Usage="System.Windows.FrameworkElement.VerticalAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.VerticalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает характеристики выравнивания по вертикали, применяемые к этому элементу при его размещении в родительском элементе, например в панели или элементе управления элементами.</summary>
        <value>Настройка вертикального выравнивания. Значение по умолчанию — <see cref="F:System.Windows.VerticalAlignment.Stretch" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Windows.FrameworkElement.Height%2A> и <xref:System.Windows.FrameworkElement.Width%2A> явно задано для элемента, эти измерения имеют приоритет и отменяют обычный эффект от этому свойству присвоить <xref:System.Windows.VerticalAlignment.Stretch>.  
  
 <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> является [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] метод доступа свойства для Какова на самом деле свойство зависимостей. Это свойство определенная зависимость довольно часто имеет значение «по умолчанию» по-разному в производных классах элементов, особенно элементы управления. Обычно это происходит в одном из двух способов: свойство зависимости регистрируется повторно для определенного производного класса, но с разными метаданными для задания значения по умолчанию; или стиль по умолчанию применяется, который задает значение свойства зависимостей по-разному. Например, «по умолчанию» из <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> для <xref:System.Windows.Controls.ComboBoxItem> элемент управления будет <xref:System.Windows.VerticalAlignment.Center>, даже если <xref:System.Windows.Controls.ComboBoxItem> наследует <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> непосредственно от <xref:System.Windows.FrameworkElement>. Это обусловлено тем, это значение было сброшено в качестве стиля по умолчанию <xref:System.Windows.Controls.ComboBoxItem>, в шаблоне стиля элемента управления.  
  
 <xref:System.Windows.Controls.Canvas> не используйте <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> при создании макета, так как <xref:System.Windows.Controls.Canvas> основывающаяся на абсолютном позиционировании.  
  
 Если наследуемые <xref:System.Windows.Controls.ComboBoxItem> или любые производные классы, <xref:System.Windows.Controls.ComboBoxItem> переопределяет значение по умолчанию это свойство имело <xref:System.Windows.VerticalAlignment.Center>.  
  
<a name="dependencyPropertyInfo_VerticalAlignment"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.VerticalAlignmentProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty VerticalAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty VerticalAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.VerticalAlignmentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VerticalAlignmentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ VerticalAlignmentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable VerticalAlignmentProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.VerticalAlignmentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.VerticalAlignment" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualChildrenCount">
      <MemberSignature Language="C#" Value="protected override int VisualChildrenCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VisualChildrenCount" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.VisualChildrenCount" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property VisualChildrenCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property int VisualChildrenCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VisualChildrenCount : int" Usage="System.Windows.FrameworkElement.VisualChildrenCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает количество визуальных дочерних элементов внутри этого элемента.</summary>
        <value>Количество визуальных дочерних элементов для этого элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> Реализация <xref:System.Windows.FrameworkElement.VisualChildrenCount%2A> всегда возвращает ноль или один. Классы, которые обслуживают коллекции дочерних визуальных элементов, который может превышать один необходимо переопределить это свойство и <xref:System.Windows.FrameworkElement.GetVisualChild%2A>.  
  
 Это свойство обычно используется для определения верхней границы текущей коллекции дочерних для целей реализации переопределения макета (<xref:System.Windows.FrameworkElement.MeasureOverride%2A>, <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>).  
  
   
  
## Examples  
 В следующем примере показано, как пользовательский декоративный элемент использует значения, объявленные с <xref:System.Windows.Media.VisualCollection> он поддерживает для нескольких визуальных дочерних элементов и сообщает эти значения с помощью переопределений из <xref:System.Windows.FrameworkElement.VisualChildrenCount%2A> и <xref:System.Windows.FrameworkElement.GetVisualChild%2A>.  
  
 [!code-csharp[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverridespre)]
 [!code-vb[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverridespre)]  
[!code-csharp[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverrides)]
[!code-vb[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverrides)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Если ваш класс поддерживает несколько визуальный дочерний элемент в коллекцию дочерних элементов, переопределите это свойство, чтобы возвращать число элементов в этой коллекции. Это необходимо сделать, даже если сам объект коллекции возвращает счетчик. Логику макета элемента на уровне платформы WPF предполагает, что все элементы будут возвращать допустимое значение счетчика через их <see cref="P:System.Windows.FrameworkElement.VisualChildrenCount" /> свойство.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Width">
      <MemberSignature Language="C#" Value="public double Width { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Width" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Width" />
      <MemberSignature Language="VB.NET" Value="Public Property Width As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Width { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Width : double with get, set" Usage="System.Windows.FrameworkElement.Width" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение или установка ширины элемента.</summary>
        <value>Ширина элемента в [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Значение по умолчанию — <see cref="F:System.Double.NaN" />. Это значение должно быть не меньше 0,0. Сведения о верхней границе см. в разделе "Примечания".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это один из трех свойств на <xref:System.Windows.FrameworkElement> , укажите сведения ширины.  Два других <xref:System.Windows.FrameworkElement.MinWidth%2A> и <xref:System.Windows.FrameworkElement.MaxWidth%2A>.  Если возникает конфликт между этими значениями, порядок приложения для определения фактическую ширину первого <xref:System.Windows.FrameworkElement.MinWidth%2A> необходимо обработать, затем <xref:System.Windows.FrameworkElement.MaxWidth%2A>и, наконец, если каждый из них выходят за границы, <xref:System.Windows.FrameworkElement.Width%2A>.  
  
 Возвращаемое значение этого свойства всегда является таким же, как любое значение, которое было задано. В свою очередь, значение <xref:System.Windows.FrameworkElement.ActualWidth%2A> могут отличаться. Макет может отклонить предлагаемый размер для какой-либо причине. Кроме того, сама система структуры работает асинхронно относительно набор системных свойств <xref:System.Windows.FrameworkElement.Width%2A> и может не обработать конкретное изменение свойства размера еще.  
  
 В дополнение к приемлемым <xref:System.Double> значения, это свойство также может быть <xref:System.Double.NaN?displayProperty=nameWithType>. Это, как указать поведение автоматического изменения размеров. В [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] значение в строку «Auto» (без учета регистра) чтобы включить автоматическое изменение размеров. Автоматическое изменение размеров предполагает, что элемент заполнит по ширине к нему. Тем не менее, обратите внимание, что определенные элементы управления передают значения по умолчанию в их стили по умолчанию, которые отключают автоматическое изменение размеров, если не нужно специально включить ее.  
  
 В дополнение к проверке подлинности, имеется значение недетерминированные верхней границы для <xref:System.Windows.FrameworkElement.Width%2A> , обеспечивается системой макета (это очень много, размер которых превышает <xref:System.Single.MaxValue?displayProperty=nameWithType> но меньше, чем <xref:System.Double.MaxValue?displayProperty=nameWithType>). Если вы превысите это ограничение, элемент не будет отображаться, и исключение не создается. Не устанавливайте <xref:System.Windows.FrameworkElement.Width%2A> значение значительно больше, чем максимальный размер любого возможного визуального дисплея, или может превысить эту недетерминированную верхнюю границу.  
  
<a name="xamlAttributeUsage_Width"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object Width="double"/>  
- or -  
<object Width ="qualifiedDouble"/>  
- or -  
<object Width ="Auto"/>  
```  
  
<a name="xamlValues_Width"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *double*  
 <xref:System.Double>  
  
 Строковое представление <xref:System.Double> значение, равное или больше 0,0. Сведения о верхней границе см. в разделе "Примечания". Это значение интерпретируется как [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] измерения. Строки не нужно явно указывать десятичных запятых. Для экземпляра значение `1` приемлемо.  
  
 *qualifiedDouble*  
 Объект *двойные* значение как описано выше, за которым следует один из следующих строк объявления единицы измерения: `px`, `in`, `cm`, `pt`.  
  
 `px` (по умолчанию) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` дюймах; 1 in == 96 точек  
  
 `cm` сантиметрах; 1см==(96/2,54) px  
  
 `pt` точках; 1точка==(96/72) px  
  
 `Auto`  
 Включает автоматическое определение размера. См. заметки.  
  
<a name="dependencyPropertyInfo_Width"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.WidthProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.WidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable WidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.WidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.Width" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>