<Type Name="FrameworkElement" FullName="System.Windows.FrameworkElement">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ad57920204dd6eb21659f24f630348b37d27fe3c" /><Meta Name="ms.sourcegitcommit" Value="0084afad1b3b1cb2c8ad2c142ae3597d08bad4a7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="10/31/2019" /><Meta Name="ms.locfileid" Value="73347769" /></Metadata><TypeSignature Language="C#" Value="public class FrameworkElement : System.Windows.UIElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FrameworkElement extends System.Windows.UIElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement, class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkElement" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkElement&#xA;Inherits UIElement&#xA;Implements IFrameworkInputElement, IQueryAmbient, ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkElement : System::Windows::UIElement, System::ComponentModel::ISupportInitialize, System::Windows::IFrameworkInputElement, System::Windows::Markup::IQueryAmbient" />
  <TypeSignature Language="F#" Value="type FrameworkElement = class&#xA;    inherit UIElement&#xA;    interface IFrameworkInputElement&#xA;    interface IInputElement&#xA;    interface ISupportInitialize&#xA;    interface IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.UIElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IFrameworkInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.RuntimeNameProperty("Name")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.UsableDuringInitialization(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.XmlLangProperty("Language")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет набор свойств, событий и методов уровня платформы WPF для элементов Windows Presentation Foundation (WPF). Этот класс представляет предоставленную реализацию уровня платформы WPF, созданную на базе API уровня ядра WPF, которые определяются <see cref="T:System.Windows.UIElement" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> — это точка подключения между классами элементов уровня среды WPF и набором <xref:System.Windows.UIElement> служб представления на уровне ядра WPF. Дополнительные сведения об этих понятиях см. в разделе [Архитектура WPF](~/docs/framework/wpf/advanced/wpf-architecture.md).  
  
 <xref:System.Windows.FrameworkElement> расширяет <xref:System.Windows.UIElement> и добавляет следующие возможности:  
  
-   **Определение системы макета**: <xref:System.Windows.FrameworkElement> предоставляет определенные реализации уровня среды WPF для определенных методов, которые были определены как виртуальные элементы в <xref:System.Windows.UIElement>. Особенно важно, <xref:System.Windows.FrameworkElement> запечатывает некоторые переопределения макета уровня ядра WPF, а вместо этого предоставляет эквивалент уровня инфраструктуры WPF, который следует переопределить производными классами. Например, <xref:System.Windows.FrameworkElement> запечатывает <xref:System.Windows.UIElement.ArrangeCore%2A>, но предоставляет <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>. Эти изменения отражены на том, что на уровне платформы WPF имеется полная система макета, которая может визуализировать любой <xref:System.Windows.FrameworkElement> производный класс. На уровне ядра WPF некоторые члены, которые будут структурировать общее [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]ное решение, основаны на месте, но фактическая подсистема макета не определена. Дополнительные сведения см. в разделе [Макет](~/docs/framework/wpf/advanced/layout.md).  
  
-   **Логическое дерево:** Общая [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] модель программирования часто выражается в виде дерева элементов. Поддержка представления дерева элементов в виде логического дерева и сопутствующая поддержка определения того, что дерево в разметке Реализовано на уровне <xref:System.Windows.FrameworkElement>. Обратите внимание, что <xref:System.Windows.FrameworkElement> намеренно не определяет модель содержимого и оставляет ответственность за производные классы. Дополнительные сведения см. в разделе [Деревья в WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
-   **События времени жизни объекта:** Часто бывает полезно выяснить, когда инициализируется элемент (вызывается конструктор) или когда элемент сначала загружается в логическое дерево. <xref:System.Windows.FrameworkElement> определяет несколько событий, связанных с временем существования объекта, которые предоставляют полезные обработчики для операций с кодом программной части, затрагивающих элементы, такие как добавление дополнительных дочерних элементов. Дополнительные сведения см. в разделе [события времени жизни объекта](~/docs/framework/wpf/advanced/object-lifetime-events.md).  
  
-   **Поддержка привязки данных и ссылок на динамические ресурсы:** Поддержка привязки данных и ресурсов реализуется классом <xref:System.Windows.DependencyProperty> и внедряется в систему свойств, но возможность разрешать значение элемента, которое хранится в виде <xref:System.Windows.Expression> (программная конструкция, которая зависит как от привязки данных и динамические ресурсы) реализуются с помощью <xref:System.Windows.FrameworkElement>. Дополнительные сведения см. в разделе [Общие сведения о привязке данных](~/docs/framework/wpf/data/data-binding-overview.md) и [ресурсы XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
-   **Styles:** <xref:System.Windows.FrameworkElement> определяет свойство <xref:System.Windows.FrameworkElement.Style%2A>. Однако <xref:System.Windows.FrameworkElement> еще не определяет поддержку шаблонов или поддерживает декораторы. Эти функции представлены такими классами элементов управления, как <xref:System.Windows.Controls.Control> и <xref:System.Windows.Controls.ContentControl>.  
  
-   **Дополнительная поддержка анимации:** Часть поддержки анимации уже определена на уровне ядра WPF, но <xref:System.Windows.FrameworkElement> расширяет это путем реализации <xref:System.Windows.FrameworkElement.BeginStoryboard%2A> и связанных элементов.  
  
 Как видно из иерархии классов, многие [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] классы являются производными от <xref:System.Windows.FrameworkElement>либо напрямую, либо через промежуточные базовые классы, такие как <xref:System.Windows.Controls.Panel> или <xref:System.Windows.Controls.Control>.  
  
 Если предполагается использовать <xref:System.Windows.FrameworkElement> в качестве базового класса, может потребоваться сначала изучить существующие производные классы. <xref:System.Windows.FrameworkElement> обеспечивает поддержку ряда основных сценариев, но также не имеет ряда функций, которые желательно использовать для "Element" в смысле стандартного блока, который используется для создания [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] в [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. Например, <xref:System.Windows.FrameworkElement> не определяет ни одной модели содержимого. <xref:System.Windows.FrameworkElement> в качестве базового класса не определяет свойство, которое может создавать [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] дочерние элементы. В частности, может потребоваться рассмотреть <xref:System.Windows.Controls.Control> и <xref:System.Windows.Controls.ContentControl>.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyObject" />
    <altmember cref="T:System.Windows.FrameworkContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.FrameworkElement" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualHeight">
      <MemberSignature Language="C#" Value="public double ActualHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ActualHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ActualHeight" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActualHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ActualHeight { double get(); };" />
      <MemberSignature Language="F#" Value="member this.ActualHeight : double" Usage="System.Windows.FrameworkElement.ActualHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает визуализированную высоту данного элемента.</summary>
        <value>Высота элемента, представленная в [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Значение по умолчанию — 0 (нуль).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это вычисляемое значение, основанное на других входных значениях высоты и системе макета. Значение задается самой системой макета, основанной на фактическом этапе отрисовки, и, таким образом, может немного отставать от установленного значения свойств, например <xref:System.Windows.FrameworkElement.Height%2A>, которые являются основанием для изменения входных данных.  
  
 Поскольку <xref:System.Windows.FrameworkElement.ActualHeight%2A> является вычисляемым значением, следует иметь в виду, что в результате выполнения различных операций в системе макета в нее могут быть внесены несколько или более добавочных отчетов. Система макета может вычислять требуемое место измерения для дочерних элементов, ограничения родительского элемента и т. д.  
  
 Хотя это свойство нельзя задать из [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], можно создать <xref:System.Windows.Trigger> на основе его значения в стиле.  
  
<a name="dependencyPropertyInfo_ActualHeight"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.ActualHeightProperty>|  
|Для свойств метаданных задано значение `true`|Отсутствуют|  
  
   
  
## Examples  
 В следующем примере выводятся различные свойства высоты.  
  
 [!code-csharp[HeightMinHeightMaxHeight#3](~/samples/snippets/csharp/VS_Snippets_Wpf/HeightMinHeightMaxHeight/CSharp/Window1.xaml.cs#3)]
 [!code-vb[HeightMinHeightMaxHeight#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HeightMinHeightMaxHeight/VisualBasic/Window1.xaml.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ActualHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ActualHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ActualHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ActualHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ActualHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ActualHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ActualHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.ActualHeight" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualWidth">
      <MemberSignature Language="C#" Value="public double ActualWidth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ActualWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ActualWidth" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActualWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ActualWidth { double get(); };" />
      <MemberSignature Language="F#" Value="member this.ActualWidth : double" Usage="System.Windows.FrameworkElement.ActualWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает визуализированную ширину данного элемента.</summary>
        <value>Ширина элемента, представленная в [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Значение по умолчанию — 0 (нуль).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это вычисляемое значение, основанное на других входных значениях ширины и системе макета. Значение задается самой системой макета, основанной на фактическом этапе отрисовки, и, таким образом, может немного отставать от установленного значения свойств, например <xref:System.Windows.FrameworkElement.Width%2A>, которые являются основанием для изменения входных данных.  
  
 Поскольку <xref:System.Windows.FrameworkElement.ActualWidth%2A> является вычисляемым значением, следует иметь в виду, что в результате выполнения различных операций в системе макета в нее могут быть внесены несколько или более добавочных отчетов. Система макета может вычислять требуемое место измерения для дочерних элементов, ограничения родительского элемента и т. д.  
  
 Хотя это свойство нельзя задать из [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], можно создать <xref:System.Windows.Trigger> на основе его значения в стиле.  
  
<a name="dependencyPropertyInfo_ActualWidth"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.ActualWidthProperty>|  
|Для свойств метаданных задано значение `true`|Отсутствуют|  
  
   
  
## Examples  
 В следующем примере выводятся различные свойства ширины.  
  
 [!code-csharp[WidthMinWidthMaxWidth#3](~/samples/snippets/csharp/VS_Snippets_Wpf/WidthMinWidthMaxWidth/CSharp/Window1.xaml.cs#3)]
 [!code-vb[WidthMinWidthMaxWidth#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WidthMinWidthMaxWidth/VisualBasic/Window1.xaml.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ActualWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ActualWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ActualWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ActualWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ActualWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ActualWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ActualWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.ActualWidth" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void AddLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.AddLogicalChild : obj -&gt; unit" Usage="frameworkElement.AddLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">Добавляемый дочерний элемент.</param>
        <summary>Добавляет указанный объект в логическое дерево данного элемента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется для реализации коллекций объектов, представляющих логические дочерние элементы элемента. Обслуживание коллекций дочерних элементов может выполняться в методах получения или задания свойств, обработки классов измененных событий, конструкторов или в самих типах коллекций.  
  
 Для авторов элементов управления логическое дерево на этом уровне не рекомендуется, если ни одна из моделей содержимого для доступных базовых классов не подходит для вашего сценария управления. Рассмотрите возможность подклассов на уровне <xref:System.Windows.Controls.ContentControl>, <xref:System.Windows.Controls.ItemsControl>и <xref:System.Windows.Controls.HeaderedItemsControl>. Эти классы предоставляют модель содержимого с определенным применением дочерних элементов логического дерева через выделенные API, а также поддержку других функций, которые обычно желательно применять в [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] элементе управления, таком как стилизация через шаблоны. Дополнительные сведения об использовании <xref:System.Windows.FrameworkElement.LogicalChildren%2A> и <xref:System.Windows.FrameworkElement.AddLogicalChild%2A>см. в разделе [деревья в WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 <xref:System.Windows.FrameworkElement.AddLogicalChild%2A> может вызвать исключение, если вызывается в момент, когда логическое дерево перебирается другим процессом.  
  
   
  
## Examples  
 В следующем примере реализуется свойство `Child` для пользовательского <xref:System.Windows.FrameworkElement>, который выполняет собственную реализацию уровня визуального элемента. Метод задания свойства разрабатывается таким образом, что при изменении значения старое значение удаляется из логического дерева, а также из визуальной коллекции, зависящей от класса. Значение свойства кэшируется, а новое значение добавляется как в логическое дерево, так и в коллекцию пользовательских визуальных элементов.  
  
 [!code-csharp[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/csharp/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/CSharp/ParticleEffectExamples/OverlayRenderDecorator.cs#addremovelogicalchild)]
 [!code-vb[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/visualbasic/particleeffectexamples/overlayrenderdecorator.vb#addremovelogicalchild)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ApplyTemplate">
      <MemberSignature Language="C#" Value="public bool ApplyTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ApplyTemplate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ApplyTemplate" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyTemplate () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ApplyTemplate();" />
      <MemberSignature Language="F#" Value="member this.ApplyTemplate : unit -&gt; bool" Usage="frameworkElement.ApplyTemplate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При необходимости строит визуальное дерево текущего шаблона и возвращает значение, указывающее, было ли это визуальное дерево перестроено в результате этого вызова.</summary>
        <returns>Значение <see langword="true" />, если в дерево были добавлены визуальные элементы; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Приложения могут вызывать этот метод, чтобы гарантировать, что визуальное дерево элемента завершено. Эта гарантия может потребоваться, если код будет проверять дочерние элементы дерева. Для типичной логики элементов в приложениях вызов <xref:System.Windows.FrameworkElement.ApplyTemplate%2A> не требуется, поскольку шаблоны будут применяться автоматически к элементам в соответствующей точке их жизненного цикла.  
  
 <xref:System.Windows.FrameworkElement.ApplyTemplate%2A> вызывается для каждой меры, передаваемых системой макета уровня платформы WPF.  
  
 <xref:System.Windows.FrameworkElement> производные классы могут использовать обработчик класса <xref:System.Windows.FrameworkElement.OnApplyTemplate%2A>, чтобы получать уведомления о случаях, когда этот метод был вызван явным образом или системой макета. <xref:System.Windows.FrameworkElement.OnApplyTemplate%2A> вызывается после полного создания шаблона и присоединения к логическому дереву.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ControlTemplate" />
      </Docs>
    </Member>
    <Member MemberName="ArrangeCore">
      <MemberSignature Language="C#" Value="protected override sealed void ArrangeCore (System.Windows.Rect finalRect);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ArrangeCore(valuetype System.Windows.Rect finalRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ArrangeCore(System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Sub ArrangeCore (finalRect As Rect)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ArrangeCore(System::Windows::Rect finalRect);" />
      <MemberSignature Language="F#" Value="override this.ArrangeCore : System.Windows.Rect -&gt; unit" Usage="frameworkElement.ArrangeCore finalRect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="finalRect" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="finalRect">Итоговая область в родительском элементе, которую этот элемент должен использовать для размещения себя и своих дочерних элементов.</param>
        <summary>Реализует метод <see cref="M:System.Windows.UIElement.ArrangeCore(System.Windows.Rect)" /> (определенный как виртуальный в классе <see cref="T:System.Windows.UIElement" />) и запечатывает реализацию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод запечатан. Чтобы переопределить логику в пользовательском элементе специально для прохода компоновки элемента, производный класс <xref:System.Windows.FrameworkElement> должен переопределить <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Size ArrangeOverride (System.Windows.Size finalSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size finalSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ArrangeOverride (finalSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Size ArrangeOverride(System::Windows::Size finalSize);" />
      <MemberSignature Language="F#" Value="abstract member ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size&#xA;override this.ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="frameworkElement.ArrangeOverride finalSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="finalSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="finalSize">Итоговая область в родительском элементе, которую этот элемент должен использовать для размещения себя и своих дочерних элементов.</param>
        <summary>При переопределении в производном классе размещает дочерние элементы и определяет размер для производного класса <see cref="T:System.Windows.FrameworkElement" />.</summary>
        <returns>Фактический используемый размер.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Эти методы должны переопределяться авторами элементов управления, которые хотят настроить проход компоновки при обработке макета. Шаблон реализации должен вызывать <see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" /> для каждого видимого дочернего элемента и передавать конечный требуемый размер для каждого дочернего элемента в качестве параметра <paramref name="finalRect" />. Родительские элементы должны вызывать <see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" /> для каждого дочернего элемента, в противном случае дочерние элементы не будут отображены.  
  
Многие производные классы предлагают реализации этого метода. К наглядным относятся: <see cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />, <see cref="M:System.Windows.Controls.Page.ArrangeOverride(System.Windows.Size)" /> и <see cref="M:System.Windows.Controls.Control.ArrangeOverride(System.Windows.Size)" />.</para></block>
        <altmember cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="frameworkElement.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Запускает процесс инициализации данного элемента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно вызывать для отдельных элементов, если вы настраиваете их так, чтобы не предоставлять или не подключать элемент к какому бы то ни было дереву элементов. Например, вы могли создать новый <xref:System.Windows.FrameworkElement>, но еще не присоединили его к какому-либо логическому дереву. Или логическое дерево, в котором элемент является дочерним элементом, может не быть подключен к окну или странице приложения.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Реализуйте этот метод, чтобы реализовать специальную обработку, которая должна произойти перед инициализацией элемента во время процесса загрузки элемента.  
  
Реализация должна вызывать базовую реализацию, так как базовая реализация (по умолчанию) задает некоторые внутренние флаги для наблюдения за инициализацией. Одной из возможных реализаций является использование этого метода в качестве обработчика для собственных подпрограмм инициализации закрытого класса, которые еще не включены конструкторами.  
  
Базовая реализация создает исключение, если <see cref="M:System.Windows.FrameworkElement.BeginInit" /> вызывается более одного раза в одном элементе до вызова <see cref="M:System.Windows.FrameworkElement.EndInit" />.</para></block>
        <altmember cref="M:System.Windows.FrameworkElement.EndInit" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginStoryboard">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Начинает последовательность действий, содержащихся в предоставленной раскадровке.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard -&gt; unit" Usage="frameworkElement.BeginStoryboard storyboard" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
      </Parameters>
      <Docs>
        <param name="storyboard">Раскадровка, которая будет начата.</param>
        <summary>Начинает последовательность действий, содержащихся в предоставленной раскадровке.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В большинстве типичных сценариев анимации этот метод не используется. Как правило, вы создаете <xref:System.Windows.Media.Animation.Storyboard> или <xref:System.Windows.Media.Animation.BeginStoryboard> элемент в разметке, а затем размещаете их в качестве <xref:System.Windows.EventTrigger>ного содержимого в элементе. При срабатывании события запускается анимация. Большинство аспектов управления <xref:System.Windows.Media.Animation.Storyboard> может быть адресовано свойствами, которые доступны в разметке.  
  
 Для сигнатур, которые не используют `isControllable`, параметр или если этот параметр указан `false`, часы временной шкалы, связанные с анимацией, удаляются сразу же после того, как анимация достигнет периода заполнения. Поэтому анимация не может быть перезапущена после однократного запуска. Для управления анимацией также требуется, чтобы раскадровка имела [директиву x:Name](~/docs/framework/xaml-services/x-name-directive.md) или была доступна по ссылке в коде.  
  
   
  
## Examples  
 В следующем примере извлекается <xref:System.Windows.Media.Animation.Storyboard> из ресурсов, а затем выполняется этот <xref:System.Windows.Media.Animation.Storyboard> при обработке внутреннего события классом.  
  
 [!code-csharp[CubeAnimation#FEBeginStoryboard](~/samples/snippets/csharp/VS_Snippets_Wpf/CubeAnimation/CSharp/Page1.xaml.cs#febeginstoryboard)]
 [!code-vb[CubeAnimation#FEBeginStoryboard](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CubeAnimation/visualbasic/page1.xaml.vb#febeginstoryboard)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="frameworkElement.BeginStoryboard (storyboard, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="storyboard">Раскадровка, которая будет начата.</param>
        <param name="handoffBehavior">Значение перечисления, описывающего поведение в случае, если описанное в раскадровке свойство уже анимировано.</param>
        <summary>Начинает последовательность действий, содержащихся в предоставленной раскадровке, с параметрами, указывающими на реакцию в случае уже анимированного свойства.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В большинстве типичных сценариев анимации этот метод не используется. Как правило, вы создаете <xref:System.Windows.Media.Animation.Storyboard> или <xref:System.Windows.Media.Animation.BeginStoryboard> элемент в разметке, а затем размещаете их в качестве <xref:System.Windows.EventTrigger>ного содержимого в элементе. При срабатывании события запускается анимация. Большинство аспектов управления <xref:System.Windows.Media.Animation.Storyboard> может быть адресовано свойствами, которые доступны в разметке.  
  
 Для сигнатур, которые не используют `isControllable`, параметр или если этот параметр указан `false`, часы временной шкалы, связанные с анимацией, удаляются сразу же после того, как анимация достигнет периода заполнения. Поэтому анимация не может быть перезапущена после однократного запуска. Для управления анимацией также требуется, чтобы раскадровка имела [директиву x:Name](~/docs/framework/xaml-services/x-name-directive.md) или была доступна по ссылке в коде.  
  
 Поведение передачи можно указать как атрибут <xref:System.Windows.Media.Animation.BeginStoryboard>.  
  
## <a name="using-the-compose-handoffbehavior"></a>Использование создания HandoffBehavior  
 При применении <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>или <xref:System.Windows.Media.Animation.AnimationClock> к свойству с помощью <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>любые <xref:System.Windows.Media.Animation.Clock> объекты, ранее связанные с этим свойством, продолжают потреблять системные ресурсы. система времени не удаляет часы автоматически.  
  
 Чтобы избежать проблем с производительностью при применении большого количества часов с помощью <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, следует удалить составные часы из анимированного свойства после их завершения. Существует несколько способов удаления часов.  
  
-   Чтобы удалить все часы из свойства, используйте метод <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> или <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> анимированного объекта. Укажите свойство, анимированное в качестве первого параметра, и `null` в качестве второго. Это приведет к удалению всех часов анимации из свойства.  
  
-   Чтобы удалить определенное <xref:System.Windows.Media.Animation.AnimationClock> из списка часов, используйте свойство <xref:System.Windows.Media.Animation.Clock.Controller%2A> <xref:System.Windows.Media.Animation.AnimationClock> для получения <xref:System.Windows.Media.Animation.ClockController>, а затем вызовите метод <xref:System.Windows.Media.Animation.ClockController.Remove%2A> из <xref:System.Windows.Media.Animation.ClockController>. Обычно это делается в обработчике событий <xref:System.Windows.Media.Animation.Clock.Completed> для часов. Обратите внимание, что <xref:System.Windows.Media.Animation.ClockController> может управлять только корневыми часами. Свойство <xref:System.Windows.Media.Animation.Clock.Controller%2A> дочернего объекта Clock возвращает `null`. Обратите внимание, что событие <xref:System.Windows.Media.Animation.Clock.Completed> не возникает, если фактическая длительность часов бесконечно.  В этом случае пользователь должен определить, когда следует вызывать <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 В основном это проблема для анимации объектов, имеющих длинное время жизни.  Если объект уничтожается сборщиком мусора, его часы также отключаются и уничтожаются мусором.  
  
 Дополнительные сведения об объектах часов см. в разделе [Общие сведения о анимации и системе управления временем](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
   
  
## Examples  
 В следующем примере извлекается <xref:System.Windows.Media.Animation.Storyboard> из ресурсов, а затем выполняется этот <xref:System.Windows.Media.Animation.Storyboard> при обработке внутреннего события классом.  
  
 [!code-csharp[CubeAnimation#FEBeginStoryboard](~/samples/snippets/csharp/VS_Snippets_Wpf/CubeAnimation/CSharp/Page1.xaml.cs#febeginstoryboard)]
 [!code-vb[CubeAnimation#FEBeginStoryboard](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CubeAnimation/visualbasic/page1.xaml.vb#febeginstoryboard)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="frameworkElement.BeginStoryboard (storyboard, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="storyboard">Раскадровка, которая будет начата.</param>
        <param name="handoffBehavior">Значение перечисления, описывающего поведение в случае, если описанное в раскадровке свойство уже анимировано.</param>
        <param name="isControllable">Объявляет, является ли анимация управляемой после запуска (можно ли ее приостановить).</param>
        <summary>Начинает последовательность действий, содержащихся в предоставленной раскадровке, с указанным состоянием элемента управления анимацией после ее запуска.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В большинстве типичных сценариев анимации этот метод не используется. Как правило, вы создаете <xref:System.Windows.Media.Animation.Storyboard> или <xref:System.Windows.Media.Animation.BeginStoryboard> элемент в разметке, а затем размещаете их в качестве <xref:System.Windows.EventTrigger>ного содержимого в элементе. При срабатывании события запускается анимация. Большинство аспектов управления <xref:System.Windows.Media.Animation.Storyboard> может быть адресовано свойствами, которые доступны в разметке.  
  
 Для сигнатур, которые не используют `isControllable`, параметр или если этот параметр указан `false`, часы временной шкалы, связанные с анимацией, удаляются сразу же после того, как анимация достигнет периода заполнения. Поэтому анимация не может быть перезапущена после однократного запуска. Для управления анимацией также требуется, чтобы раскадровка имела [директиву x:Name](~/docs/framework/xaml-services/x-name-directive.md) или была доступна по ссылке в коде.  
  
 Поведение передачи можно указать как атрибут <xref:System.Windows.Media.Animation.BeginStoryboard>.  
  
## <a name="using-the-compose-handoffbehavior"></a>Использование создания HandoffBehavior  
 При применении <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>или <xref:System.Windows.Media.Animation.AnimationClock> к свойству с помощью <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>любые <xref:System.Windows.Media.Animation.Clock> объекты, ранее связанные с этим свойством, продолжают потреблять системные ресурсы. система времени не удаляет часы автоматически.  
  
 Чтобы избежать проблем с производительностью при применении большого количества часов с помощью <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, следует удалить составные часы из анимированного свойства после их завершения. Существует несколько способов удаления часов.  
  
-   Чтобы удалить все часы из свойства, используйте метод <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> или <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> анимированного объекта. Укажите свойство, анимированное в качестве первого параметра, и `null` в качестве второго. Это приведет к удалению всех часов анимации из свойства.  
  
-   Чтобы удалить определенное <xref:System.Windows.Media.Animation.AnimationClock> из списка часов, используйте свойство <xref:System.Windows.Media.Animation.Clock.Controller%2A> <xref:System.Windows.Media.Animation.AnimationClock> для получения <xref:System.Windows.Media.Animation.ClockController>, а затем вызовите метод <xref:System.Windows.Media.Animation.ClockController.Remove%2A> из <xref:System.Windows.Media.Animation.ClockController>. Обычно это делается в обработчике событий <xref:System.Windows.Media.Animation.Clock.Completed> для часов. Обратите внимание, что <xref:System.Windows.Media.Animation.ClockController> может управлять только корневыми часами. Свойство <xref:System.Windows.Media.Animation.Clock.Controller%2A> дочернего объекта Clock возвращает `null`. Обратите внимание, что событие <xref:System.Windows.Media.Animation.Clock.Completed> не возникает, если фактическая длительность часов бесконечно.  В этом случае пользователь должен определить, когда следует вызывать <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 В основном это проблема для анимации объектов, имеющих длинное время жизни.  Если объект уничтожается сборщиком мусора, его часы также отключаются и уничтожаются мусором.  
  
 Дополнительные сведения об объектах часов см. в разделе [Общие сведения о анимации и системе управления временем](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroup">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingGroup BindingGroup { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingGroup BindingGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.BindingGroup" />
      <MemberSignature Language="VB.NET" Value="Public Property BindingGroup As BindingGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingGroup ^ BindingGroup { System::Windows::Data::BindingGroup ^ get(); void set(System::Windows::Data::BindingGroup ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BindingGroup : System.Windows.Data.BindingGroup with get, set" Usage="System.Windows.FrameworkElement.BindingGroup" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingGroup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает группу <see cref="T:System.Windows.Data.BindingGroup" />,  которая используется для элемента.</summary>
        <value>Группа <see cref="T:System.Windows.Data.BindingGroup" />, используемая для элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Data.BindingGroup> можно использовать для проверки значений нескольких свойств объекта. Например, предположим, что приложение предлагает пользователю ввести адрес, а затем заполнит объект типа `Address`, содержащий свойства `Street`, `City`, `ZipCode`и `Country`, со значениями, предоставленными пользователем. Приложение содержит панель, содержащую четыре элемента управления <xref:System.Windows.Controls.TextBox>, каждый из которых привязан к одному из свойств объекта. Для проверки объекта `Address` можно использовать <xref:System.Windows.Controls.ValidationRule> в <xref:System.Windows.Data.BindingGroup>. Например, <xref:System.Windows.Controls.ValidationRule> может гарантировать, что почтовый индекс действителен для страны или региона адреса.  
  
 Дочерние элементы наследуют <xref:System.Windows.Data.BindingGroup> от их родительских элементов, как и любые другие наследуемые свойства.  
  
<a name="dependencyPropertyInfo_BindingGroup"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.BindingGroupProperty>|  
|Для свойств метаданных задано значение `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 Следующие примеры являются частью приложения, которое проверяет, установил ли пользователь свойства двух объектов равными значениями. В первом примере создаются два элемента управления <xref:System.Windows.Controls.TextBox>, каждый из которых привязан к другому источнику данных. <xref:System.Windows.Controls.StackPanel> имеет <xref:System.Windows.Data.BindingGroup>, содержащий <xref:System.Windows.Controls.ValidationRule>, который проверяет, равны ли две строки.  
  
 [!code-xaml[BindingGroupSnippets#BindingGroupComplete](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml#bindinggroupcomplete)]  
  
 В следующем примере показаны <xref:System.Windows.Controls.ValidationRule>, используемые в предыдущем примере.  В переопределении метода <xref:System.Windows.Controls.ValidationRule.Validate%2A> этот пример получает каждый исходный объект из <xref:System.Windows.Data.BindingGroup> и проверяет, равны ли свойства объектов.  
  
 [!code-csharp[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml.cs#bindinggroupnamevalidationrule)]
 [!code-vb[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window3.xaml.vb#bindinggroupnamevalidationrule)]  
  
 Чтобы вызвать <xref:System.Windows.Controls.ValidationRule>, вызовите метод <xref:System.Windows.Data.BindingGroup.UpdateSources%2A>.  В следующем примере вызывается <xref:System.Windows.Data.BindingGroup.UpdateSources%2A> при возникновении события нажатия кнопки.  
  
 [!code-csharp[BindingGroupSnippets#UpdateSourcesClick](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml.cs#updatesourcesclick)]
 [!code-vb[BindingGroupSnippets#UpdateSourcesClick](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window3.xaml.vb#updatesourcesclick)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroupProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BindingGroupProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BindingGroupProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.BindingGroupProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BindingGroupProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BindingGroupProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BindingGroupProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.BindingGroupProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.BindingGroup" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BringIntoView">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Пытается отобразить данный элемент вместе с содержащимися в нем прокручиваемыми областями.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView();" />
      <MemberSignature Language="F#" Value="member this.BringIntoView : unit -&gt; unit" Usage="frameworkElement.BringIntoView " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Пытается отобразить данный элемент вместе с содержащимися в нем прокручиваемыми областями.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызывая этот метод, вы создаете событие <xref:System.Windows.FrameworkElement.RequestBringIntoView>, которое происходит из текущего элемента. Это событие вызывается, чтобы его можно было обработать с помощью <xref:System.Windows.Controls.ScrollViewer>или производного или аналогичного класса. Ожидаемое поведение заключается в том, что событие обрабатывается родительским элементом, помеченным как обработанный в данных события, а источник события передается в представление через логику, внедренную в элемент управления <xref:System.Windows.Controls.ScrollViewer>. Ни событие <xref:System.Windows.FrameworkElement.RequestBringIntoView>, ни метод <xref:System.Windows.FrameworkElement.BringIntoView%2A> не передают никаких сведений об успехе или неудаче, Кроме того, что событие обычно отмечается как обработанное при успешном выполнении. Причины сбоя могут включать в себя параметры элемента, такие как <xref:System.Windows.UIElement.Visibility%2A> имеют значение, отличное от <xref:System.Windows.Visibility.Visible>.  
  
 Если используется сигнатура, не указывающая `targetRectangle`, то весь элемент (его <xref:System.Windows.UIElement.RenderSize%2A>) становится видимым.  
  
 Вызывая этот метод, вы потенциально будете вызывать <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> для любой родительской прокручиваемой области, содержащей элемент. Если этот элемент не содержится в прокручиваемой области, событие <xref:System.Windows.FrameworkElement.RequestBringIntoView> по-прежнему вызывается, но не будет действовать, так как прослушиватели событий отсутствуют.  
  
   
  
## Examples  
 В следующем примере реализуется обработчик для события навигации приложения, который реагирует на то, что при переходе на универсальный код ресурса (URI) включает фрагмент. Фрагмент именуется в URI после символа решетки (#), и реализованное поведение заставляет элемент прокручиваться в пределах рамки. <xref:System.Windows.FrameworkElement.BringIntoView%2A> и <xref:System.Windows.FrameworkElement.RequestBringIntoView> запрашивают поведение прокрутки в примере.  
  
 [!code-csharp[FragmentNavigationSample#FEBringIntoView](~/samples/snippets/csharp/VS_Snippets_Wpf/FragmentNavigationSample/CSharp/MainWindow.xaml.cs#febringintoview)]
 [!code-vb[FragmentNavigationSample#FEBringIntoView](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FragmentNavigationSample/VisualBasic/MainWindow.xaml.vb#febringintoview)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ScrollViewer" />
      </Docs>
    </Member>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView (System.Windows.Rect targetRectangle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView(valuetype System.Windows.Rect targetRectangle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView (targetRectangle As Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView(System::Windows::Rect targetRectangle);" />
      <MemberSignature Language="F#" Value="member this.BringIntoView : System.Windows.Rect -&gt; unit" Usage="frameworkElement.BringIntoView targetRectangle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetRectangle" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="targetRectangle">Указанный размер элемента, который также следует отобразить.</param>
        <summary>Пытается отобразить указанный размер области данного элемента вместе с содержащимися в нем прокручиваемыми областями.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызывая этот метод, вы создаете событие <xref:System.Windows.FrameworkElement.RequestBringIntoView>, которое происходит из текущего элемента. Это событие вызывается, чтобы его можно было обработать с помощью <xref:System.Windows.Controls.ScrollViewer>или производного или аналогичного класса. Ожидаемое поведение заключается в том, что событие обрабатывается родительским элементом, помеченным как обработанный в данных события, а источник события передается в представление через логику, внедренную в элемент управления <xref:System.Windows.Controls.ScrollViewer>. Ни событие <xref:System.Windows.FrameworkElement.RequestBringIntoView>, ни метод <xref:System.Windows.FrameworkElement.BringIntoView%2A> не передают никаких сведений об успехе или неудаче, Кроме того, что событие обычно отмечается как обработанное при успешном выполнении. Причины сбоя могут включать в себя параметры элемента, такие как <xref:System.Windows.UIElement.Visibility%2A> имеют значение, отличное от <xref:System.Windows.Visibility.Visible>.  
  
 Если используется сигнатура, не указывающая `targetRectangle`, то весь элемент (его <xref:System.Windows.UIElement.RenderSize%2A>) становится видимым.  
  
 Вызывая этот метод, вы потенциально будете вызывать <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> для любой родительской прокручиваемой области, содержащей элемент. Если этот элемент не содержится в прокручиваемой области, событие <xref:System.Windows.FrameworkElement.RequestBringIntoView> по-прежнему вызывается, но не будет действовать, так как прослушиватели событий отсутствуют.  
  
   
  
## Examples  
 В следующем примере большая графика находится в ограниченной области прокрутки. Кнопка на странице содержит обработчик, который Прокручивает представление до определенной области крупного графика.  
  
 [!code-xaml[BaseElementsSmorgasbord#BringIntoViewRectMarkup](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml#bringintoviewrectmarkup)]  
  
 [!code-csharp[BaseElementsSmorgasbord#BringIntoViewRectCode](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#bringintoviewrectcode)]
 [!code-vb[BaseElementsSmorgasbord#BringIntoViewRectCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#bringintoviewrectcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.FlowDocumentScrollViewer" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ContextMenu ^ ContextMenu { System::Windows::Controls::ContextMenu ^ get(); void set(System::Windows::Controls::ContextMenu ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenu : System.Windows.Controls.ContextMenu with get, set" Usage="System.Windows.FrameworkElement.ContextMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает элемент контекстного меню, который должен отображаться каждый раз при вызове контекстного меню через [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] из этого элемента.</summary>
        <value>Контекстное меню, назначенное этому элементу.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.ContextMenu> сам является <xref:System.Windows.FrameworkElement> производным классом, и технически возможно, что <xref:System.Windows.Controls.ContextMenu> само свойство <xref:System.Windows.FrameworkElement.ContextMenu%2A>. Однако это создает путаницу в контекстном меню для пользователя, и этот подход не рекомендуется.  
  
<a name="dependencyPropertyInfo_ContextMenu"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.ContextMenuProperty>|  
|Для свойств метаданных задано значение `true`|Отсутствуют|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ContextMenuClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuClosing As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuClosing;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит непосредственно перед закрытием какого-либо контекстного меню в элементе.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы подавить закрытие контекстных меню, обработчики события должны пометить его как обработанное.  
  
 Чтобы использовать это событие в качестве <xref:System.Windows.EventTrigger> в стиле, необходимо ссылаться на определение события базовой службы:  
  
 [!code-xaml[CorePseudocode#FEContextMenuClosing](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuclosing)]  
  
 (Это необходимо, поскольку реализация события в <xref:System.Windows.FrameworkElement>, которая предоставляет базовое событие службы, не сопоставляет идентификатор <xref:System.Windows.FrameworkElement.ContextMenuClosing>, так что его можно использовать в качестве триггера).  
  
 <xref:System.Windows.Controls.ContextMenu> сам является <xref:System.Windows.FrameworkElement> производным классом, но событие <xref:System.Windows.FrameworkElement.ContextMenuClosing> не будет вызываться непосредственно контекстным меню. Вместо этого событие вызывается из элемента, который "владеет" контекстным меню в качестве свойства и вызывается только тогда, когда пользователь пытается закрыть контекстное меню в пользовательском интерфейсе. Однако <xref:System.Windows.Controls.ContextMenu> может иметь свойство <xref:System.Windows.FrameworkElement.ContextMenu%2A> (вложенное контекстное меню). В этом случае <xref:System.Windows.Controls.ContextMenu> действительно владеет вложенным <xref:System.Windows.Controls.ContextMenu> и может вызвать событие, а источником события является вложенное контекстное меню.  
  
 Сам класс <xref:System.Windows.Controls.ContextMenu> также имеет аналогичное событие (<xref:System.Windows.Controls.ContextMenu.Closed>), но событие <xref:System.Windows.Controls.ContextMenu.Closed> не дает вам возможности отменить действие пользователя.  
  
<a name="routedEventInfo_ContextMenuClosing"></a>   
## <a name="routed-event-information"></a>Сведения о маршрутизируемом событии  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.ContextMenuClosingEvent>|  
|Стратегия маршрутизации|Восходящей маршрутизации|  
|делегат|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
-   Переопределите <xref:System.Windows.FrameworkElement.OnContextMenuClosing%2A>, чтобы реализовать обработку класса для этого события в производных классах.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ContextMenuClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует направленное событие <see cref="E:System.Windows.FrameworkElement.ContextMenuClosing" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Идентификаторы перенаправленных событий создаются при их регистрации. Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события. Эти идентификаторы можно использовать для добавления обработчиков классов.  
  
 Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ContextMenuOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuOpening As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuOpening;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при открытии какого-либо контекстного меню в элементе.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы открыть контекстное меню вручную, обработчики событий должны отметить соответствующее событие как обработанное. В противном случае существующее значение свойства <xref:System.Windows.FrameworkElement.ContextMenu%2A> будет использоваться для автоматического открытия контекстного меню. Пометка события как обработанного отменяет действие по умолчанию и может привести к сбросу значения свойства <xref:System.Windows.FrameworkElement.ContextMenu%2A>, а затем открыть новый <xref:System.Windows.Controls.ContextMenu>. Однако существует ошибка синхронизации, о которой следует знать. Чтобы полностью заменить контекстное меню с помощью обработчика <xref:System.Windows.FrameworkElement.ContextMenuOpening>, исходное контекстное меню не должно быть пустым или иметь значение null. Кроме того, может потребоваться выполнить обработку события, а затем вручную открыть новое контекстное меню. Дополнительные сведения см. в разделе [как обрабатывает событие ContextMenuOpening](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md).  
  
 Чтобы использовать это событие в качестве <xref:System.Windows.EventTrigger> в стиле, необходимо ссылаться на базовое присоединенное событие:  
  
 [!code-xaml[CorePseudocode#FEContextMenuOpening](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuopening)]  
  
 (Это необходимо, поскольку реализация события в <xref:System.Windows.FrameworkElement>, которая предоставляет базовое событие службы, не сопоставляет идентификатор <xref:System.Windows.FrameworkElement.ContextMenuOpening>, чтобы его можно было использовать в триггерах).  
  
 <xref:System.Windows.Controls.ContextMenu> сам является <xref:System.Windows.FrameworkElement> производным классом, но это событие не будет вызываться из контекстного меню, открываемого в качестве источника. Событие вызывается из элемента, который "владеет" контекстным меню в качестве свойства и вызывается только тогда, когда пользователь пытается открыть контекстное меню в пользовательском интерфейсе. <xref:System.Windows.Controls.ContextMenu> может иметь <xref:System.Windows.FrameworkElement.ContextMenu%2A> свойство, но следует избегать этого сценария (Дополнительные сведения см. в разделе <xref:System.Windows.FrameworkElement.ContextMenu%2A?displayProperty=nameWithType>).  
  
 Сам класс <xref:System.Windows.Controls.ContextMenu> также имеет аналогичное событие (<xref:System.Windows.Controls.ContextMenu.Opened>), но <xref:System.Windows.Controls.ContextMenu.Opened> не предоставляет возможности отмены действия пользователя.  
  
<a name="routedEventInfo_ContextMenuOpening"></a>   
## <a name="routed-event-information"></a>Сведения о маршрутизируемом событии  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.ContextMenuOpeningEvent>|  
|Стратегия маршрутизации|Восходящей маршрутизации|  
|делегат|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
-   Переопределите <xref:System.Windows.FrameworkElement.OnContextMenuOpening%2A>, чтобы реализовать обработку класса для этого события в производных классах.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ContextMenuOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует направленное событие <see cref="E:System.Windows.FrameworkElement.ContextMenuOpening" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Идентификаторы перенаправленных событий создаются при их регистрации. Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события. Эти идентификаторы можно использовать для добавления обработчиков классов.  
  
 Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContextMenuProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContextMenuProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContextMenuProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ContextMenuProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.ContextMenu" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public System.Windows.Input.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::Cursor ^ Cursor { System::Windows::Input::Cursor ^ get(); void set(System::Windows::Input::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Cursor : System.Windows.Input.Cursor with get, set" Usage="System.Windows.FrameworkElement.Cursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение или установка курсора, который отображается при наведении указателя мыши на этот элемент.</summary>
        <value>Отображаемый курсор. Значение по умолчанию определяется как <see langword="null" /> для данного свойства зависимостей. Однако на практике значение по умолчанию во время выполнения зависит от множества факторов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если это свойство задано в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], то процессор [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] использует преобразование типов для класса <xref:System.Windows.Input.Cursor> для вычисления строки. Указанная строка должна иметь значение <xref:System.Windows.Input.CursorType>. Подробные сведения см. в разделе <xref:System.Windows.Input.Cursor>.  
  
 Будет ли курсор, установленный этим свойством, или не будет отображаться, если указатель мыши находится над данным элементом, также зависит от значения свойства <xref:System.Windows.FrameworkElement.ForceCursor%2A>. Кроме того, вопросы, связанные с событиями, такие как активное перетаскивание, захват мыши, режимы редактирования текста в элементах управления и т. д., также влияют на курсор с более высоким приоритетом, чем значение, указанное в этом свойстве.  
  
 Чтобы отменить поведение установки этого свойства в конечном итоге, задайте для него значение `null`.  
  
 `null` по умолчанию действительно означает, что определение практического значения курсора будет отложено и должно быть получено из других мест. Если вы предвидите без программных значений из какого-либо источника, то курсором по умолчанию, который находится на [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] приложении, будет стрелка. Однако изменения временного курсора не задаются <xref:System.Windows.FrameworkElement.Cursor%2A> значений элементов при их передаче. Свойство <xref:System.Windows.FrameworkElement.Cursor%2A> будет сообщать только значения, отличные от NULL, в тех случаях, где они были заданы, например, с помощью кода или стиля. Каждое перемещение указателя мыши на [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] приложение вызывает событие <xref:System.Windows.UIElement.QueryCursor>. Событие переносится вверх, и любой элемент маршрута имеет возможность управлять событием и устанавливать значение курсора с помощью аргументов этого события. Это механизм, который в большинстве случаев создает визуально видимый курсор. Если обработчик <xref:System.Windows.UIElement.QueryCursor> возвращает результат курсора, то тот факт, что событие обрабатывается и имеет измененное значение в аргументах, имеет приоритет над значением свойства <xref:System.Windows.FrameworkElement.Cursor%2A> на любом уровне, если не задано значение <xref:System.Windows.FrameworkElement.ForceCursor%2A>.  
  
 Если не создается пользовательский курсор, обычно этому свойству присваивается статическое значение свойства <xref:System.Windows.Input.Cursors> класса. Для установки <xref:System.Windows.FrameworkElement.Cursor%2A> в коде необходимо одно из следующих значений:  
  
-   Вызовите конструктор <xref:System.Windows.Input.Cursor>, чтобы получить экземпляр <xref:System.Windows.Input.Cursor>. Обе сигнатуры конструктора <xref:System.Windows.Input.Cursor> используют потоки или файлы, в том случае, если вы создаете объект <xref:System.Windows.Input.Cursor> для пользовательского курсора.  
  
-   Используйте класс <xref:System.Windows.Input.CursorConverter> и его метод <xref:System.Windows.Input.CursorConverter.ConvertFrom%2A>, чтобы указать курсор на <xref:System.Windows.Input.CursorType>или строку, которая может вычислять <xref:System.Windows.Input.CursorType>, и приведите возвращаемое значение к <xref:System.Windows.Input.Cursor>.  
  
 Установка для <xref:System.Windows.Input.Cursor> пользовательского значения не включена при частичном доверии. Дополнительные сведения о пользовательских курсорах см. в разделе [Общие сведения о входных данных](~/docs/framework/wpf/advanced/input-overview.md).  
  
<a name="dependencyPropertyInfo_Cursor"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.CursorProperty>|  
|Для свойств метаданных задано значение `true`|Отсутствуют|  
  
   
  
## Examples  
 В следующем примере показано, как намеренно задать рисунок курсора.  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.QueryCursor" />
        <altmember cref="P:System.Windows.FrameworkElement.ForceCursor" />
        <altmember cref="P:System.Windows.Input.Mouse.OverrideCursor" />
      </Docs>
    </Member>
    <Member MemberName="CursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.CursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.CursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.Cursor" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContext">
      <MemberSignature Language="C#" Value="public object DataContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.DataContext" />
      <MemberSignature Language="VB.NET" Value="Public Property DataContext As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataContext { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataContext : obj with get, set" Usage="System.Windows.FrameworkElement.DataContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает контекст данных для элемента, участвующего в привязке данных.</summary>
        <value>Объект, используемый в качестве контекста данных.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *Контекст данных* — это концепция, которая позволяет элементам наследовать от своих родительских элементов сведения об источнике данных, используемом для привязки, а также о других характеристиках привязки, таких как путь.  
  
 Контекст данных можно задать непосредственно для объекта .NET с привязками, оценивающих свойства этого объекта. Кроме того, можно задать для контекста данных объект <xref:System.Windows.Data.DataSourceProvider>.  
  
 Это свойство зависимости наследует значения свойств. Если имеются дочерние элементы, не имеющие других значений для <xref:System.Windows.FrameworkElement.DataContext%2A>, установленных с помощью локальных значений или стилей, система свойств установит значение, равное <xref:System.Windows.FrameworkElement.DataContext%2A>ому значению ближайшего родительского элемента, которому назначено это значение.  
  
 Кроме того, можно использовать одно из следующих свойств класса <xref:System.Windows.Data.Binding>, чтобы явно указать источник привязки:
  
    - <xref:System.Windows.Data.Binding.ElementName%2A>.
    - <xref:System.Windows.Data.Binding.Source%2A>.
    - <xref:System.Windows.Data.Binding.RelativeSource%2A>. 
  
  Дополнительные сведения см. в разделе [инструкции. Указание источника привязки](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md).  
  
 В XAML <xref:System.Windows.FrameworkElement.DataContext%2A> обычно задается как объявление <xref:System.Windows.Data.Binding>. Можно использовать либо синтаксис элемента свойства, либо синтаксис атрибутов. Синтаксис атрибута показан в примере на этой странице. Можно также использовать код для установки <xref:System.Windows.FrameworkElement.DataContext%2A>.  
  
 <xref:System.Windows.FrameworkElement.DataContext%2A> является связываемым свойством для упрощения сценариев, в которых один контекст может быть привязан к другому. Однако при привязке к <xref:System.Windows.FrameworkElement.DataContext%2A>следует избегать создания циклических ссылок привязки (не привязывать <xref:System.Windows.FrameworkElement.DataContext%2A> к самому себе, что можно сделать из-за особенностей наследования значений свойств свойства <xref:System.Windows.FrameworkElement.DataContext%2A>).  
  
<a name="xamlPropertyElementUsage_DataContext"></a>   
## <a name="xaml-property-element-usage"></a>Использование элемента свойства XAML  
  
```  
<object>  
  <object.DataContext>  
    <dataContextObject />  
  </object.DataContext>  
</object>  
```  
  
<a name="xamlAttributeUsage_DataContext"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```xaml  
<object DataContext="bindingUsage"/>  
```

- или -

```xaml
<object DataContext="{resourceExtension contextResourceKey}"/>  
```
  
<a name="xamlValues_DataContext"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *датаконтекстобжект*  
 Непосредственно внедренный объект, который служит контекстом данных для любых привязок в родительском элементе. Как правило, этот объект является <xref:System.Windows.Data.Binding> или другим <xref:System.Windows.Data.BindingBase> производным классом. Кроме того, здесь можно разместить необработанные данные любого типа объекта, предназначенного для привязки, с фактическими привязками, определенными далее.  
  
 *биндингусаже*  
 Использование привязки, результатом которого является соответствующий контекст данных. Дополнительные сведения см. в разделе [Привязка расширения разметки](~/docs/framework/wpf/advanced/binding-markup-extension.md).  
  
 *ресаурцеекстенсион*  
 Один из следующих: [`StaticResource`](~/docs/framework/wpf/advanced/staticresource-markup-extension.md) или [`DynamicResource`](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md). Это использование используется при ссылке на необработанные данные, определенные как объект в ресурсах. См. раздел [ресурсы XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *контекстресаурцекэй*  
 Идентификатор ключа для объекта, запрашиваемого в <xref:System.Windows.ResourceDictionary>.  
  
<a name="dependencyPropertyInfo_DataContext"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.DataContextProperty>|  
|Для свойств метаданных задано значение `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 В следующем примере показано, как контекст данных работает с привязкой и предоставляет сведения, определяющие конкретные значения связанных свойств.  
  
 [!code-xaml[MasterDetail#DataContextProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty)]  
[!code-xaml[MasterDetail#DataContextProperty2](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty2)]  
[!code-xaml[MasterDetail#DataContextProperty3](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler DataContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.DataContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataContextChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ DataContextChanged;" />
      <MemberSignature Language="F#" Value="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении контекста данных для элемента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Описание контекстов данных и привязки данных см. в разделе [Общие сведения о привязке данных](~/docs/framework/wpf/data/data-binding-overview.md).  
  
> [!IMPORTANT]
>  При изменении <xref:System.Windows.FrameworkElement.DataContext%2A> элемента все свойства, привязанные к данным этого элемента, потенциально затрагиваются. Это относится к любым элементам, которые являются дочерними элементами текущего элемента в логическом дереве, который наследует контекст данных, а также текущий элемент. Все существующие привязки должны повторно интерпретировать новые <xref:System.Windows.FrameworkElement.DataContext%2A> и переоценивать результаты привязки. Механизм привязки данных не является детерминированным в порядке этих переоценок относительно вызова события <xref:System.Windows.FrameworkElement.DataContextChanged>. Повторные вычисления могут происходить до события, после события или в любом сочетании.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.DataContext" />
      </Docs>
    </Member>
    <Member MemberName="DataContextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DataContextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DataContextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.DataContextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DataContextProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ DataContextProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DataContextProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.DataContextProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.DataContext" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKey">
      <MemberSignature Language="C#" Value="protected internal object DefaultStyleKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.DefaultStyleKey" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property DefaultStyleKey As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Object ^ DefaultStyleKey { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultStyleKey : obj with get, set" Usage="System.Windows.FrameworkElement.DefaultStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает ключ, используемый для ссылки на стиль этого элемента управления, при использовании или определении тематических стилей.</summary>
        <value>Ключ стиля. Для правильной работы в процессе поиска тематического стиля, это значение должно быть <see cref="T:System.Type" /> элемента управления, к которому применяется стиль.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство обычно не задается через любые его прямые методы доступа к свойствам. Вместо этого переопределяются метаданные этого свойства зависимостей, относящиеся к типу, при каждом создании нового <xref:System.Windows.FrameworkElement> производного класса. При наследовании элемента управления вызывайте метод <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> по идентификатору <xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty> в статическом конструкторе производного класса Control (или эквивалентной инициализации класса).  
  
 Обычно элемент управления переопределяет значение этого свойства по умолчанию своим собственным типом, но в некоторых случаях может также использовать базовый тип, для которого существует стиль в тематических словарях. Это целесообразно только в том случае, если шаблоны элементов управления базового элемента управления полностью определяют визуальное представление этого производного элемента управления и если какие-либо дополнительные члены, предоставляемые производными типами, не нуждаются в дополнительных элементах как часть шаблона элемента управления.  
  
 Если необходимо, чтобы элемент или элемент управления намеренно не использовал стили темы, установите для свойства <xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A> значение `true`.  
  
<a name="dependencyPropertyInfo_DefaultStyleKey"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty>|  
|Для свойств метаданных задано значение `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 В следующем примере показано использование переопределения метаданных свойства зависимостей, которое обсуждалось в разделе "Примечания". Этот код определяет класс пользовательского элемента управления `NumericUpDown` предназначенный для использования из выделенной сборки библиотеки элементов управления. Показанный статический конструктор ссылается на некоторую закрытую функцию инициализации, регистрирует обработчик класса (другой сценарий подкласса общего элемента управления; см. раздел [Маркировка перенаправленных событий как обработанных и обработка классов](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)) и, наконец, переопределяет <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> метаданных свойств зависимостей в классе `NumericUpDown`. <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> всегда возвращает собственный тип в качестве предполагаемого ключа, который представляет собой соглашение, используемое системой тематических стилей для поиска стиля для какого-либо произвольного элемента управления без стиля. Полный пример также определяет стиль темы фактического элемента управления, на который ссылается этот ключ; см. [Пример пользовательского элемента управления NumericUpDown с темой и поддержкой модели автоматизации пользовательского интерфейса](https://go.microsoft.com/fwlink/?LinkID=160025).  
  
 [!code-csharp[CustomControlNumericUpDown#StaticCtorOfCustomClassCommonTasks](~/samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp/CustomControlLibrary/NumericUpDown2.cs)]
 [!code-vb[CustomControlNumericUpDown#StaticCtorOfCustomClassCommonTasks](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic/customcontrollibrary/numericupdown2.vb)]  

  Полный исходный код для этого примера доступен на сайте GitHub как для, [C#](https://github.com/dotnet/samples/tree/master/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp/CustomControlLibrary) так и для [Visual Basic](https://github.com/dotnet/samples/tree/master/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic/customcontrollibrary).

 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.OverridesDefaultStyle" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160025">Пример пользовательского элемента управления NumericUpDown с поддержкой темы и модели автоматизации пользовательского интерфейса</related>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKeyProperty">
      <MemberSignature Language="C#" Value="protected internal static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly static initonly class System.Windows.DependencyProperty DefaultStyleKeyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.DefaultStyleKeyProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared ReadOnly DefaultStyleKeyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="protected public: static initonly System::Windows::DependencyProperty ^ DefaultStyleKeyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultStyleKeyProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.DefaultStyleKeyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.DefaultStyleKey" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="frameworkElement.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Указывает на завершение процесса инициализации элемента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если ранее был вызван <xref:System.Windows.FrameworkElement.BeginInit%2A>, базовая реализация вызовет событие <xref:System.Windows.FrameworkElement.Initialized>. В противном случае, если <xref:System.Windows.FrameworkElement.BeginInit%2A> не был вызван или не удалось определить, было ли вызвано <xref:System.Windows.FrameworkElement.BeginInit%2A>, <xref:System.Windows.FrameworkElement.Initialized> не будет вызвано, а вместо этого будет создано исключение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Windows.FrameworkElement.EndInit" /> был вызван без предварительного вызова метода <see cref="M:System.Windows.FrameworkElement.BeginInit" /> для элемента.</exception>
        <block subset="none" type="overrides"><para>Реализуйте этот метод, чтобы реализовать специальную обработку, которая должна выполняться при инициализации элемента во время загрузки элемента.  
  
 Реализация должна вызывать базовую реализацию, так как базовая реализация (по умолчанию) задает некоторые внутренние флаги для наблюдения за инициализацией.</para></block>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.FindName : string -&gt; obj" Usage="frameworkElement.FindName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Имя запрошенного элемента.</param>
        <summary>Находит элемент по указанному имени идентификатора.</summary>
        <returns>Запрошенный элемент. Это может быть значение <see langword="null" />, если соответствующий элемент не найден.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если у элемента есть дочерние элементы, все эти дочерние элементы ищутся рекурсивно для запрошенного именованного элемента.  
  
 <xref:System.Windows.FrameworkElement.FindName%2A> работает в области имен текущего элемента. Дополнительные сведения см. в разделе [области имен XAML WPF](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.FrameworkElement.Name" />
        <related type="Article" href="https://msdn.microsoft.com/library/b7e61222-e8cf-48d2-acd0-6df3b7685d48">x:Name, атрибут</related>
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="frameworkElement.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Ключевой идентификатор запрашиваемого ресурса.</param>
        <summary>Осуществляет поиск ресурса с указанным ключом и вызывает исключение, если запрошенный ресурс не найден.</summary>
        <returns>Запрошенный ресурс. Если ресурс с указанным ключом не найден, выдается исключение. В случае исключение может быть также возвращено значение <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  При вызове этого метода для ключа, который не удается найти, создается исключение. Если вы не хотите выполнять обработку исключений, возникающих в результате вызова <xref:System.Windows.FrameworkElement.FindResource%2A>, вызовите <xref:System.Windows.FrameworkElement.TryFindResource%2A>. <xref:System.Windows.FrameworkElement.TryFindResource%2A> возвращает `null`, если не удается найти запрошенный ресурс и не создает исключение.  
  
 Если ресурс не найден в вызывающем элементе, далее выполняется поиск родительского элемента в логическом дереве, затем приложение, затем темы и, наконец, системные ресурсы. Эта методология поиска аналогична поиску в дереве, если ресурс был запрошен ссылкой на динамический ресурс в разметке. Дополнительные сведения о поиске ресурсов см. в разделе [ресурсы XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 Как правило, вы немедленно приводите <xref:System.Windows.FrameworkElement.FindResource%2A> возвращаемое значение к типу свойства, которое вы задаете с помощью возвращаемого значения ресурса.  
  
 Ключи ресурсов не обязательно являются строками. Например, стили для элементов управления на уровне темы преднамеренно заключаются в <xref:System.Type> элемента управления, а стили приложения или страницы для элементов управления обычно используют это же соглашение о ключах. Дополнительные сведения см. в разделе [Стилизация и создание шаблонов](~/docs/framework/wpf/controls/styling-and-templating.md) или [ресурсов XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
   
  
## Examples  
 Следующий пример получает именованный ресурс и приводит его к соответствующему типу для заполнения свойства.  
  
 [!code-csharp[PropertiesOvwSupport#ResourceProceduralGet](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page3.xaml.cs#resourceproceduralget)]
 [!code-vb[PropertiesOvwSupport#ResourceProceduralGet](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertiesOvwSupport/visualbasic/page3.xaml.vb#resourceproceduralget)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException"><paramref name="resourceKey" /> не найден, и обработчик событий для события <see cref="E:System.Windows.Threading.Dispatcher.UnhandledException" /> не существует.  
  
- или - 
 <paramref name="resourceKey" /> не найден, и свойство <see cref="P:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled" /> имеет значение <see langword="false" /> в событии <see cref="E:System.Windows.Threading.Dispatcher.UnhandledException" />.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="resourceKey" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.FrameworkElement.TryFindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FlowDirection">
      <MemberSignature Language="C#" Value="public System.Windows.FlowDirection FlowDirection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.FlowDirection FlowDirection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.FlowDirection" />
      <MemberSignature Language="VB.NET" Value="Public Property FlowDirection As FlowDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::FlowDirection FlowDirection { System::Windows::FlowDirection get(); void set(System::Windows::FlowDirection value); };" />
      <MemberSignature Language="F#" Value="member this.FlowDirection : System.Windows.FlowDirection with get, set" Usage="System.Windows.FrameworkElement.FlowDirection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.FlowDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает направление, в котором текстовые и другие элементы [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] следуют в родительском элементе, определяющем их размещение.</summary>
        <value>Направление, в котором текстовые и другие элементы [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] следуют в родительском элементе, как значение перечисления. Значение по умолчанию — <see cref="F:System.Windows.FlowDirection.LeftToRight" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Использование свойства зависимости задает <xref:System.Windows.FrameworkElement.FlowDirection%2A> для этого элемента. Из-за наследования значения свойства параметр <xref:System.Windows.FrameworkElement.FlowDirection%2A> элемента может устанавливать <xref:System.Windows.FrameworkElement.FlowDirection%2A> для всех дочерних элементов, которые не были заданы <xref:System.Windows.FrameworkElement.FlowDirection%2A> локально или в других случаях, таких как стили.  
  
 Это свойство не устанавливается автоматически как часть сведений о культуре приложения, так как элемент может содержать содержимое, которое не обязательно должно соответствовать общему направлению потока, подразумеваемому сведениями о языке и региональных параметрах. Дополнительные сведения о вопросах глобализации см. в разделе [глобализация для WPF](~/docs/framework/wpf/advanced/globalization-for-wpf.md).  
  
 Это свойство имеет определенный метод доступа [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] свойства, поэтому он работает как свойство зависимостей. Однако он также регистрируется как прикрепленный, поэтому он также может функционировать как присоединенное свойство. Подключенная регистрация в основном используется, чтобы наследование значения свойства поддерживалось, но свойство также может использоваться как присоединяемое свойство. Использование присоединенного свойства уместно только в том случае, если объект, для которого нужно задать направление потока, имеет <xref:System.Windows.FrameworkElement> родительский элемент, выполняющий разметку, сам по себе не является <xref:System.Windows.FrameworkElement>и еще не имеет более явно определенного свойства `FlowDirection`. (Некоторые классы документов нефиксированного формата, такие как <xref:System.Windows.Documents.Block> и <xref:System.Windows.Documents.Inline>, определяют свои собственные `FlowDirection`, и это свойство также может задавать направление потока. Затем значение свойства считывается на конечном узле содержимого, не требуя использования присоединенного свойства.)  
  
<a name="xamlAttributeUsage_FlowDirection"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
 \<*объекта* **FlowDirection**= "<xref:System.Windows.FlowDirection>"/>  
  
<a name="xamlTextUsage_FlowDirection"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Это свойство также можно задать для классов, которые не <xref:System.Windows.FrameworkElement> производных классах, следующим [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] использование присоединенного свойства:  
  
 `<` *объект* `FrameworkElement.`**FlowDirection**= "<xref:System.Windows.FlowDirection>`"/>`  
  
<a name="dependencyPropertyInfo_FlowDirection"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.FlowDirectionProperty>|  
|Для свойств метаданных задано значение `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 Это свойство является и свойством зависимостей, и присоединенным свойством. см. раздел Примечания.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlowDirectionProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FlowDirectionProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FlowDirectionProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.FlowDirectionProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FlowDirectionProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FlowDirectionProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FlowDirectionProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.FlowDirectionProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.FlowDirection" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Style FocusVisualStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style FocusVisualStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.FocusVisualStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FocusVisualStyle As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ FocusVisualStyle { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FocusVisualStyle : System.Windows.Style with get, set" Usage="System.Windows.FrameworkElement.FocusVisualStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает свойство, позволяющее настройку внешнего вида, эффектов или других характеристик стиля, применяемых к данному элементу, когда он получает фокус клавиатуры.</summary>
        <value>Требуемый стиль для применения при получении фокуса. Значением по умолчанию, как объявлено в свойстве зависимостей, является пустой статический объект <see cref="T:System.Windows.Style" />. Тем не менее, действительным значением во время выполнения часто (но не всегда) является стиль, представленный поддержкой тем для элементов управления.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство влияет на визуальный внешний вид, но не сообщает о <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> в метаданных. Это связано с тем, что изменение внешнего вида осуществляется на основе событий и может применяться не всегда, и поэтому не должно сообщать о каких-либо визуальных и макетных сведениях в метаданных.  
  
 По сути, визуальное поведение фокуса, применяемого к элементу управления, должно быть согласовано с элементом управления. Наиболее разумным способом принудительного применения согласованности является изменение визуального стиля фокуса при составлении целой темы. Задание этого свойства в отдельных стилях элемента управления, а не в теме, не является предполагаемым использованием этого свойства, поскольку оно может привести к путанице в работе пользователя с фокусом клавиатуры. Если вы планируете поведение конкретного элемента управления, которое намеренно не согласовано в теме, гораздо лучшим подходом является использование триггеров в стилях для отдельных свойств состояния ввода, таких как <xref:System.Windows.UIElement.IsFocused%2A> или <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>, и делать это так, чтобы не визуально влияет на любой имеющийся визуальный стиль фокуса. Дополнительные сведения о намерении разработки <xref:System.Windows.FrameworkElement.FocusVisualStyle%2A> и альтернативных свойствах фокуса см. [в разделе Стилизация фокуса в элементах управления и FocusVisualStyle](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md).  
  
<a name="xamlAttributeUsage_FocusVisualStyle"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object FocusVisualStyle="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_FocusVisualStyle"></a>   
## <a name="xaml-property-element-usage"></a>Использование элемента свойства XAML  
  
<a name="xamlValues_FocusVisualStyle"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *ресаурцеекстенсион*  
 Один из следующих элементов: или. См. раздел [ресурсы XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *стилересаурцекэй*  
 Ключ, определяющий запрашиваемый стиль. Ключ ссылается на существующий ресурс в <xref:System.Windows.ResourceDictionary>.  
  
> [!NOTE]
>  Синтаксис элемента свойства технически возможен, но не рекомендуется. См. раздел [встроенные стили и шаблоны](~/docs/framework/wpf/advanced/inline-styles-and-templates.md). Ссылка на привязку с помощью [TemplateBinding](~/docs/framework/wpf/advanced/templatebinding-markup-extension.md) или <xref:System.Windows.Data.Binding> также возможна, но не часто.  
  
<a name="dependencyPropertyInfo_FocusVisualStyle"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.FocusVisualStyleProperty>|  
|Для свойств метаданных задано значение `true`|Отсутствуют|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusVisualStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.FocusVisualStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusVisualStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusVisualStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FocusVisualStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.FocusVisualStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.FocusVisualStyle" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursor">
      <MemberSignature Language="C#" Value="public bool ForceCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ForceCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ForceCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property ForceCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ForceCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ForceCursor : bool with get, set" Usage="System.Windows.FrameworkElement.ForceCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, следует ли данному <see cref="T:System.Windows.FrameworkElement" /> заставлять [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] визуализировать курсор, как объявлено свойством <see cref="P:System.Windows.FrameworkElement.Cursor" />.</summary>
        <value><see langword="true" />, если для презентации курсора, расположенного над данным элементом, принудительно используются текущие настройки <see cref="P:System.Windows.FrameworkElement.Cursor" /> для курсора (а также для всех дочерних элементов); в противном случае — <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если для этого свойства задано значение `true` то настройки курсора, установленные дочерними элементами, будут переопределены. Это может показаться непонятным для пользователя [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)], особенно если дочерние элементы пытаются указать курсоры. Параметр <xref:System.Windows.FrameworkElement.ForceCursor%2A> более подходит в сценариях управления подклассами или компоновки.  
  
<a name="dependencyPropertyInfo_ForceCursor"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.ForceCursorProperty>|  
|Для свойств метаданных задано значение `true`|Отсутствуют|  
  
   
  
## Examples  
 В следующем примере выполняется принудительное выполнение значения курсора.  
  
 [!code-xaml[ForceCursor#ForceCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/ForceCursor/CS/default.xaml#forcecursor)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="ForceCursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForceCursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForceCursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ForceCursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForceCursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForceCursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ForceCursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ForceCursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.ForceCursor" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetBindingExpression(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBindingExpression (dp As DependencyProperty) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ GetBindingExpression(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetBindingExpression : System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingExpression" Usage="frameworkElement.GetBindingExpression dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Целевой объект <see cref="T:System.Windows.DependencyProperty" />, из которого нужно получить привязку.</param>
        <summary>Возвращает <see cref="T:System.Windows.Data.BindingExpression" />, представляющий привязку к заданному свойству.</summary>
        <returns>Значение <see cref="T:System.Windows.Data.BindingExpression" />, если целевое свойство имеет активную привязку; в противном случае — значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Проверка возвращаемого значения для `null` — это метод, с помощью которого можно определить, имеет ли свойство активную привязку.  
  
 Этот метод на самом деле является просто оболочкой для метода <xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=nameWithType>. <xref:System.Windows.FrameworkElement.GetBindingExpression%2A> передает текущий экземпляр и параметр `dp` в <xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Data.BindingOperations" />
      </Docs>
    </Member>
    <Member MemberName="GetFlowDirection">
      <MemberSignature Language="C#" Value="public static System.Windows.FlowDirection GetFlowDirection (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.FlowDirection GetFlowDirection(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetFlowDirection(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFlowDirection (element As DependencyObject) As FlowDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::FlowDirection GetFlowDirection(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetFlowDirection : System.Windows.DependencyObject -&gt; System.Windows.FlowDirection" Usage="System.Windows.FrameworkElement.GetFlowDirection element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FlowDirection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Элемент, для которого требуется возвратить <see cref="P:System.Windows.FrameworkElement.FlowDirection" />.</param>
        <summary>Получает значение присоединенного свойства <see cref="P:System.Windows.FrameworkElement.FlowDirection" /> указанного элемента <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>Запрошенное направление потока, как значение перечисления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Основной целью этого метода является поддержка синтаксиса присоединенного свойства для свойства <xref:System.Windows.FrameworkElement.FlowDirection%2A>, что позволяет дочерним элементам предоставленного <xref:System.Windows.FrameworkElement> указывать направление потока для упорядочения в пределах своего родительского элемента. Чтобы получить значение в текущем <xref:System.Windows.FrameworkElement>, используйте метод доступа Direct [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] <xref:System.Windows.FrameworkElement.FlowDirection%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.FlowDirection" />
      </Docs>
    </Member>
    <Member MemberName="GetLayoutClip">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.Geometry GetLayoutClip (System.Windows.Size layoutSlotSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Geometry GetLayoutClip(valuetype System.Windows.Size layoutSlotSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetLayoutClip (layoutSlotSize As Size) As Geometry" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::Geometry ^ GetLayoutClip(System::Windows::Size layoutSlotSize);" />
      <MemberSignature Language="F#" Value="override this.GetLayoutClip : System.Windows.Size -&gt; System.Windows.Media.Geometry" Usage="frameworkElement.GetLayoutClip layoutSlotSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Geometry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="layoutSlotSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="layoutSlotSize">Размер части элемента, выполняющей визуальную презентацию.</param>
        <summary>Возвращает геометрию маски отсечения. Маска применяется при попытке системы структуры скомпоновать элемент, размер которого превышает доступное экранное пространство.</summary>
        <returns>Геометрия отсечения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поля будут вычитаться из `layoutSlotSize` как часть поведения системы макета.  
  
 Возвращенная пустая ссылка указывает, что отсечение не выполняется. Реализация по умолчанию всегда возвращает `null`, когда <xref:System.Windows.UIElement.ClipToBounds%2A> `false`. Этот метод переопределяет метод <xref:System.Windows.UIElement.GetLayoutClip%2A?displayProperty=nameWithType>. <xref:System.Windows.FrameworkElement> реализация использует <xref:System.Windows.FrameworkElement.MaxHeight%2A> и <xref:System.Windows.FrameworkElement.MaxWidth%2A> в своих вычислениях. Несколько подклассов <xref:System.Windows.FrameworkElement> переопределяют этот метод. <xref:System.Windows.Documents.Adorner.GetLayoutClip%2A?displayProperty=nameWithType>, переопределяет значение, чтобы всегда возвращать `null`, так как декораторы часто намеренно выходят за рамки обычных границ. <xref:System.Windows.Controls.Canvas.GetLayoutClip%2A?displayProperty=nameWithType> и <xref:System.Windows.Controls.InkPresenter.GetLayoutClip%2A?displayProperty=nameWithType> возвращают `null`, если <xref:System.Windows.UIElement.ClipToBounds%2A> `false`.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Реализация по умолчанию всегда возвращает <see langword="null" />, когда <see cref="P:System.Windows.UIElement.ClipToBounds" /> <see langword="false" />. Переопределения обычно должны сохранять такое поведение, хотя существуют исключения, в зависимости от связи и назначения производного класса и его логики макета в отличие от базового класса.</para></block>
        <altmember cref="P:System.Windows.UIElement.Clip" />
        <altmember cref="P:System.Windows.UIElement.ClipToBounds" />
      </Docs>
    </Member>
    <Member MemberName="GetTemplateChild">
      <MemberSignature Language="C#" Value="protected internal System.Windows.DependencyObject GetTemplateChild (string childName);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Windows.DependencyObject GetTemplateChild(string childName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetTemplateChild(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function GetTemplateChild (childName As String) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::Windows::DependencyObject ^ GetTemplateChild(System::String ^ childName);" />
      <MemberSignature Language="F#" Value="member this.GetTemplateChild : string -&gt; System.Windows.DependencyObject" Usage="frameworkElement.GetTemplateChild childName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="childName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="childName">Имя искомого дочернего элемента.</param>
        <summary>Возвращает именованный элемент в визуальном дереве объекта <see cref="T:System.Windows.Controls.ControlTemplate" />, для которого создан экземпляр.</summary>
        <returns>Запрошенный элемент. Может иметь значение <see langword="null" />, если элемента с запрошенным именем не существует.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Шаблоны в [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] имеют автономную область имен. Это обусловлено тем, что шаблоны используются повторно, и любое имя, определенное в шаблоне, не может оставаться уникальным, если несколько экземпляров элемента управления создают свой шаблон. Вызовите метод <xref:System.Windows.FrameworkElement.GetTemplateChild%2A>, чтобы вернуть ссылки на объекты, поступающие из шаблона после создания экземпляра. Нельзя использовать метод <xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType> для поиска элементов из шаблонов, так как <xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType> работает в более общей области, и между самим классом <xref:System.Windows.Controls.ControlTemplate> и созданным шаблоном не существует соединения.  
  
 <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType> предоставляет ту же функцию, что и этот метод. <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType> является общедоступным, а не защищенным, и использует правильные ограничения области имен, позволяющие ему получить доступ к шаблону внутри элемента и найти в нем именованные элементы. Используйте <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType>, если необходимо получить элемент за пределами родительского элемента управления.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkTemplate.FindName(System.String,System.Windows.FrameworkElement)" />
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal override System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberSignature Language="F#" Value="override this.GetUIParentCore : unit -&gt; System.Windows.DependencyObject" Usage="frameworkElement.GetUIParentCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает альтернативный логический родительский объект для этого элемента при отсутствии визуального родительского объекта.</summary>
        <returns>Возвращает нечто, отличное от <see langword="null" />, каждый раз, когда реализация уровня инфраструктуры WPF этого метода имеет подключение без визуального родительского объекта.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод переопределяет метод <xref:System.Windows.UIElement.GetUIParentCore%2A?displayProperty=nameWithType>. Реализация <xref:System.Windows.FrameworkElement> по умолчанию возвращает ожидаемый один визуальный элемент, который является тем же результатом, что и получение значения <xref:System.Windows.FrameworkElement.Parent%2A>. Реализации производного класса могут возвращать альтернативные родительские связи.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Parent" />
      </Docs>
    </Member>
    <Member MemberName="GetVisualChild">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.Visual GetVisualChild (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Visual GetVisualChild(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetVisualChild (index As Integer) As Visual" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::Visual ^ GetVisualChild(int index);" />
      <MemberSignature Language="F#" Value="override this.GetVisualChild : int -&gt; System.Windows.Media.Visual" Usage="frameworkElement.GetVisualChild index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Visual</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Отсчитываемый от нуля индекс запрошенного дочернего элемента коллекции.</param>
        <summary>Переопределяет <see cref="M:System.Windows.Media.Visual.GetVisualChild(System.Int32)" /> и возвращает дочерний элемент по указанному индексу из коллекции дочерних элементов.</summary>
        <returns>Запрошенный дочерний элемент. Не должен возвращать <see langword="null" />; если указанный индекс находится вне диапазона, создается исключение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В реализации <xref:System.Windows.FrameworkElement> единственным допустимым индексом является нуль. Модель содержимого для <xref:System.Windows.FrameworkElement.GetVisualChild%2A> поддерживает либо ноль, либо один дочерний элемент, а не коллекцию.  
  
   
  
## Examples  
 В следующем примере показано, как пользовательский декоративный элемент использует значения, объявленные <xref:System.Windows.Media.VisualCollection>, которые он поддерживает для нескольких визуальных дочерних элементов. Эти значения передаются через переопределения <xref:System.Windows.FrameworkElement.VisualChildrenCount%2A> и <xref:System.Windows.FrameworkElement.GetVisualChild%2A>.  
  
 [!code-csharp[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverridespre)]
 [!code-vb[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverridespre)]  
[!code-csharp[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverrides)]
[!code-vb[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverrides)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Эта реализация допустима только для элементов, которые не поддерживают более описательную коллекцию визуальных дочерних элементов. Любой элемент, имеющий такую коллекцию, должен переопределять этот метод и сопоставлять индекс с эквивалентным индексом в коллекции дочерних элементов, которая поддерживается этим элементом. Индекс в диапазоне от нуля до <see cref="P:System.Windows.FrameworkElement.VisualChildrenCount" /> (минус единица) должен возвращать допустимый элемент; любой другой индекс должен вызывать исключение вне диапазона. Пример типа элемента, который поддерживает дочернюю коллекцию и переопределяет <see cref="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)" />, чтобы возвращать более одного возможного дочернего элемента <see cref="T:System.Windows.Controls.Panel" />.  
  
Реализация по умолчанию в <see cref="T:System.Windows.FrameworkElement" /> предполагает только один визуальный дочерний элемент. Любое значение, переданное для <paramref name="index" />, отличное от нуля, приводит к возникновению исключения. Некоторые общие элементы, такие как декораторы, декоративные элементы или элементы с специализированной отрисовкой, переопределяют <see cref="T:System.Windows.FrameworkElement" />ную реализацию (реализации из промежуточных базовых классов). Некоторые реализации по-прежнему применяют один визуальный дочерний элемент, а другие допускают сбор.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Height">
      <MemberSignature Language="C#" Value="public double Height { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Height" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Height" />
      <MemberSignature Language="VB.NET" Value="Public Property Height As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Height { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Height : double with get, set" Usage="System.Windows.FrameworkElement.Height" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает предлагаемую высоту элемента.</summary>
        <value>Высота элемента в [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Значение по умолчанию — <see cref="F:System.Double.NaN" />. Это значение должно быть не меньше 0,0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Height%2A> является одним из трех доступных для записи свойств <xref:System.Windows.FrameworkElement>, которые указывают сведения о высоте. Два других — <xref:System.Windows.FrameworkElement.MinHeight%2A> и <xref:System.Windows.FrameworkElement.MaxHeight%2A>. Если между этими значениями возникает конфликт, то порядок применения для определения фактической высоты заключается в том, что первый <xref:System.Windows.FrameworkElement.MinHeight%2A> должен учитываться, затем <xref:System.Windows.FrameworkElement.MaxHeight%2A>и, наконец, если он находится в пределах границ, <xref:System.Windows.FrameworkElement.Height%2A>.  
  
 Если этот элемент является дочерним элементом в каком-либо другом элементе, установка этого свойства в значение действительно является только рекомендуемым значением. Система макета, а также конкретная логика макета родительского элемента будет использовать значение в качестве непривязки входных данных во время процесса макета. На практике <xref:System.Windows.FrameworkElement> почти всегда является дочерним элементом чего-то еще; даже при установке <xref:System.Windows.FrameworkElement.Height%2A> на <xref:System.Windows.Window>. (Для <xref:System.Windows.Window>это значение используется, когда базовая модель приложения устанавливает базовые предположения отрисовки, создающие HWND, в котором размещено приложение.)  
  
 Кроме допустимых значений <xref:System.Double>, это свойство также можно <xref:System.Double.NaN?displayProperty=nameWithType>. Таким образом вы указываете поведение автоматического изменения размера в коде. В [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] значение строки "Auto" (без учета регистра) задается для включения автоматического изменения размера. Автоматическое изменение размеров подразумевает, что элемент будет заполнять доступную для него высоту. Обратите внимание, что определенные элементы управления часто предоставляют значения по умолчанию с помощью стилей тем по умолчанию, которые будут отключать автоматическое изменение размера, если только они не были специально включены.  
  
 Возвращаемое значение этого свойства всегда совпадает с любым значением, заданным для него. В отличие от этого, значение <xref:System.Windows.FrameworkElement.ActualHeight%2A> может отличаться. Это может произойти либо статически, поскольку макет отклонил предлагаемый размер по какой-либо причине или моментально. Сама система макета работает асинхронно относительно набора <xref:System.Windows.FrameworkElement.Height%2A> системы свойств и может еще не обработать это конкретное изменение свойства изменения размера.  
  
 Ограничения по значению для <xref:System.Double> значения применяются механизмом <xref:System.Windows.ValidateValueCallback>. При попытке задать недопустимое значение возникает исключение времени выполнения.  
  
 В дополнение к проверке проверки существует недетерминированное верхнее значение, привязанное к <xref:System.Windows.FrameworkElement.Height%2A>, которое применяется системой макета (это очень большое число, которое больше, чем <xref:System.Single.MaxValue?displayProperty=nameWithType>, но меньше <xref:System.Double.MaxValue?displayProperty=nameWithType>). Если превысить эту границу, элемент не будет отображен и исключение не создается. Не устанавливайте для <xref:System.Windows.FrameworkElement.Height%2A> значение, которое значительно превышает максимальный размер любого возможного визуального отображения, или может быть превышена недетерминированная верхняя граница.  
  
<a name="xamlAttributeUsage_Height"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```xaml
<object Height="double"/>  
```

- или -

```xaml
<object Height="qualifiedDouble"/>  
```

- или -

```xaml
<object Height="Auto"/>  
```  
  
<a name="xamlValues_Height"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *double*  
 <xref:System.Double>  
  
 Строковое представление значения <xref:System.Double>, равное или больше 0,0. Сведения о верхней границе см. в разделе "Примечания". Это значение интерпретируется как измерение [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]. Строки не должны явно включать десятичные разделители. Для экземпляра значение `1` приемлемо.  
  
 *куалифиеддаубле*  
 Значение *типа Double* , как описано выше, за которым следует одна из следующих строк объявления единицы: `px`, `in`, `cm`, `pt`.  
  
 `px` (по умолчанию) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` в дюймах; 1in = = 96 пикселей  
  
 `cm` — сантиметры; 1cm = = (96/2,54) px  
  
 `pt` — это точки; выбрано 1pt = = (96/72) px  
  
 **Auto**  
 Включает режим автоподбора размера. См. заметки.  
  
<a name="dependencyPropertyInfo_Height"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.HeightProperty>|  
|Для свойств метаданных задано значение `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.ActualHeight" />
      </Docs>
    </Member>
    <Member MemberName="HeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.HeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable HeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.HeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.Height" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.HorizontalAlignment HorizontalAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.HorizontalAlignment HorizontalAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.HorizontalAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property HorizontalAlignment As HorizontalAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::HorizontalAlignment HorizontalAlignment { System::Windows::HorizontalAlignment get(); void set(System::Windows::HorizontalAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.HorizontalAlignment : System.Windows.HorizontalAlignment with get, set" Usage="System.Windows.FrameworkElement.HorizontalAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение или установка характеристик выравнивания по горизонтали, применяемых к этому элементу при его размещении в родительском элементе управления, например в панели или элементе управления элементами.</summary>
        <value>Параметр горизонтального выравнивания как значение перечисления. Значение по умолчанию — <see cref="F:System.Windows.HorizontalAlignment.Stretch" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если свойства <xref:System.Windows.FrameworkElement.Height%2A> и <xref:System.Windows.FrameworkElement.Width%2A> явно заданы для элемента, эти измерения занимают более высокий приоритет во время компоновки и отменяют типичные эффекты установки <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> в <xref:System.Windows.HorizontalAlignment.Stretch>.  
  
 <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> — это метод доступа [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] свойства для того, что в действительности является свойством зависимостей. Это конкретное свойство зависимости довольно часто имеет свое видимое значение по умолчанию для элементов подклассов, особенно элементов управления. Обычно это происходит одним из двух способов: свойство зависимости повторно регистрируется в определенном подклассе, но с различными метаданными для установки значений по умолчанию. или применяется стиль по умолчанию, который устанавливает это значение свойства зависимостей по-разному. Например, очевидным «по умолчанию» <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> для элемента управления <xref:System.Windows.Controls.Label> будет <xref:System.Windows.HorizontalAlignment.Left>, несмотря на то, что <xref:System.Windows.Controls.Label> наследует <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> непосредственно от <xref:System.Windows.FrameworkElement>. Это происходит потому, что это значение было сброшено в стиле по умолчанию <xref:System.Windows.Controls.Label>в шаблоне элемента управления стиля.  
  
 <xref:System.Windows.Controls.Canvas> не использует <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> при создании макета, поскольку <xref:System.Windows.Controls.Canvas> основан на абсолютном положении.  
  
 При наследовании <xref:System.Windows.Controls.Label> или производными классами <xref:System.Windows.Controls.Label> переопределяет значение по умолчанию этого свойства зависимостей на <xref:System.Windows.HorizontalAlignment.Left>.  
  
<a name="dependencyPropertyInfo_HorizontalAlignment"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.HorizontalAlignmentProperty>|  
|Для свойств метаданных задано значение `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HorizontalAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HorizontalAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.HorizontalAlignmentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HorizontalAlignmentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HorizontalAlignmentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable HorizontalAlignmentProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.HorizontalAlignmentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.HorizontalAlignment" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InheritanceBehavior">
      <MemberSignature Language="C#" Value="protected internal System.Windows.InheritanceBehavior InheritanceBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.InheritanceBehavior InheritanceBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.InheritanceBehavior" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property InheritanceBehavior As InheritanceBehavior" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Windows::InheritanceBehavior InheritanceBehavior { System::Windows::InheritanceBehavior get(); void set(System::Windows::InheritanceBehavior value); };" />
      <MemberSignature Language="F#" Value="member this.InheritanceBehavior : System.Windows.InheritanceBehavior with get, set" Usage="System.Windows.FrameworkElement.InheritanceBehavior" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.InheritanceBehavior</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает пределы области видимости для наследования значений свойств, поиска ключей ресурсов и поиска RelativeSource FindAncestor.</summary>
        <value>Значение перечисления. Значение по умолчанию — <see cref="F:System.Windows.InheritanceBehavior.Default" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Некоторые границы в наборе дерева элементов <xref:System.Windows.FrameworkElement.InheritanceBehavior%2A> для намеренного ограничения области действия наследования, принудительного уточняющего запроса ресурса для проверки ресурсов приложения или для предотвращения RelativeSource FindAncestorного поиска из запроса текущего элемента или любого других. Поиск в RelativeSource FindAncestor происходит, когда в привязке используется <xref:System.Windows.Data.RelativeSource>, для свойства <xref:System.Windows.Data.RelativeSource.Mode%2A> которого задано значение <xref:System.Windows.Data.RelativeSourceMode.FindAncestor?displayProperty=nameWithType>.  
  
 Если вы хотите, чтобы производный класс установил это свойство, это необходимо сделать в статическом конструкторе или в других подпрограммых инициализации.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Frame" />
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит во время инициализации данного <see cref="T:System.Windows.FrameworkElement" />. Данное событие совпадает со случаями, когда значение свойства <see cref="P:System.Windows.FrameworkElement.IsInitialized" /> изменяется с <see langword="false" /> (или неопределенного) на <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие будет вызвано при вызове методов <xref:System.Windows.FrameworkElement.EndInit%2A> или <xref:System.Windows.FrameworkElement.OnVisualParentChanged%2A>. Вызовы любого из методов могут происходить из кода приложения или с помощью [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]ного обработчика при обработке страницы [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 Нужно ли выполнять обработку <xref:System.Windows.FrameworkElement.Loaded> или <xref:System.Windows.FrameworkElement.Initialized> зависит от ваших требований. Если не требуется считывать свойства элементов, планируется сбрасывать свойства и не требуется никакой информации о макете, <xref:System.Windows.FrameworkElement.Initialized> может быть лучшим событием. Если требуется, чтобы все свойства элемента были доступны, и вы задаете свойства, которые, скорее всего, будут сбрасывать макет, <xref:System.Windows.FrameworkElement.Loaded> может быть лучшим событием. Будьте внимательны при повторном входе, если ваш обработчик сбрасывает все свойства, интерпретируемые системой макета, что означает необходимость нового прохода макета. (Может потребоваться проверить значения <xref:System.Windows.FrameworkPropertyMetadata> свойства, если вы не уверены, какие свойства могут потребовать нового прохода макета, если они были изменены.)  
  
 Дополнительные сведения о последовательности событий объекта для <xref:System.Windows.FrameworkElement>, а также о нескольких связанных классах приложений и элементов см. в разделе [события времени существования объекта](~/docs/framework/wpf/advanced/object-lifetime-events.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.OnInitialized(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="InputScope">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputScope InputScope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputScope InputScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.InputScope" />
      <MemberSignature Language="VB.NET" Value="Public Property InputScope As InputScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputScope ^ InputScope { System::Windows::Input::InputScope ^ get(); void set(System::Windows::Input::InputScope ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InputScope : System.Windows.Input.InputScope with get, set" Usage="System.Windows.FrameworkElement.InputScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает контекст для входных данных, используемых этим элементом <see cref="T:System.Windows.FrameworkElement" />.</summary>
        <value>Область ввода, которая изменяет интерпретацию ввода с помощью альтернативных методов. Значение по умолчанию — <see langword="null" /> (что приводит к обработке команд по умолчанию).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство зависимости наследует значения свойств. Если имеются дочерние элементы, не имеющие других значений для <xref:System.Windows.FrameworkElement.InputScope%2A>, установленных с помощью локальных значений или стилей, система свойств установит значение, которое будет <xref:System.Windows.FrameworkElement.InputScope%2A>ым значением ближайшего предка, которому назначено это значение.  
  
 Несмотря на то что [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] синтаксис указан и является синтаксически разрешенным, установка этого свойства в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] не является распространенной.  
  
<a name="dependencyPropertyInfo_InputScope"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.InputScopeProperty>|  
|Для свойств метаданных задано значение `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.InputScope" />
        <altmember cref="T:System.Windows.IInputElement" />
      </Docs>
    </Member>
    <Member MemberName="InputScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty InputScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty InputScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.InputScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InputScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ InputScopeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable InputScopeProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.InputScopeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.InputScope" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Windows.FrameworkElement.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, был ли инициализирован этот элемент — либо в ходе обработки процессором [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], либо путем явного вызова своего метода <see cref="M:System.Windows.FrameworkElement.EndInit" />.</summary>
        <value>Значение <see langword="true" />, если элемент инициализирован путем вышеупомянутой обработки [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] или вызовов метода; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство также может быть `true`, если этот элемент был перемещен в логическое дерево таким образом, что он имеет новый родительский элемент и, следовательно, снова перезагружен.  
  
 Это свойство полезно, если вы также используете <xref:System.Windows.FrameworkElement.BeginInit%2A> и <xref:System.Windows.FrameworkElement.EndInit%2A>. Элементы логического дерева, загружаемые процессором [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], гарантированно инициализируются. Элементы, не являющиеся в логическом дереве, инициализируются при вызове <xref:System.Windows.FrameworkElement.EndInit%2A>. В отсутствие какой либо конкретной обработки <xref:System.Windows.FrameworkElement.BeginInit%2A> и <xref:System.Windows.FrameworkElement.EndInit%2A>это происходит сразу после того, как конструктор вернет инициализированный результат.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.IsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoaded { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoaded : bool" Usage="System.Windows.FrameworkElement.IsLoaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, загружен ли данный элемент для презентации.</summary>
        <value><see langword="true" />, если текущий элемент присоединен к дереву элементов; <see langword="false" />, если элемент никогда не был присоединен к загруженному дереву элементов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Из вновь созданного <xref:System.Windows.FrameworkElement>это свойство начинается с `false`и остается `true` после его установки в `true`, даже если элемент впоследствии удаляется из подключенного логического дерева по коду. состояние `true` задается общей логикой представления при загрузке элементов в подсистему представления.  
  
 Как правило, загруженные элементы подготавливаются к просмотру, но не все <xref:System.Windows.FrameworkElement> производные классы имеют представление, а другие свойства, такие как <xref:System.Windows.UIElement.Visibility%2A>, могут повлиять на представление.  
  
   
  
## Examples  
 В следующем примере реализуются два обработчика: один обрабатывает событие <xref:System.Windows.FrameworkElement.Loaded> корневого элемента, поэтому необходимо загрузить корневой элемент страницы, так как это значимость события. Другой обработчик связан с пользовательским элементом управления и вызывает <xref:System.Windows.FrameworkElement.IsLoaded%2A>, чтобы убедиться, что корневой элемент полностью загружен. Оба обработчика вызывают одну и ту же функцию (не показано), которая будет заполнять дочерние элементы новыми данными.  
  
 [!code-csharp[GroupBoxExample#FEIsLoaded](~/samples/snippets/csharp/VS_Snippets_Wpf/GroupBoxExample/CSharp/Page1.xaml.cs#feisloaded)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Language">
      <MemberSignature Language="C#" Value="public System.Windows.Markup.XmlLanguage Language { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Markup.XmlLanguage Language" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Language" />
      <MemberSignature Language="VB.NET" Value="Public Property Language As XmlLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Markup::XmlLanguage ^ Language { System::Windows::Markup::XmlLanguage ^ get(); void set(System::Windows::Markup::XmlLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Language : System.Windows.Markup.XmlLanguage with get, set" Usage="System.Windows.FrameworkElement.Language" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.XmlLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает сведения о языке локализации и глобализации, который применяется к элементу.</summary>
        <value>Сведения о языке для этого элемента. Значение по умолчанию — <see cref="T:System.Windows.Markup.XmlLanguage" />, и для его значения <see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /> задана строка гu-RU.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Форматы строк соответствуют стандарту RFC 3066. Например, Английский (США) — EN-US. Дополнительные сведения о значениях и формате см. в разделе <xref:System.Windows.Markup.XmlLanguage>.  
  
 Это свойство зависимости наследует значения свойств. Если имеются дочерние элементы, не имеющие других значений для <xref:System.Windows.FrameworkElement.Language%2A>, установленных с помощью локальных значений или стилей, система свойств установит значение, которое будет <xref:System.Windows.FrameworkElement.Language%2A>ым значением ближайшего предка, которому назначено это значение.  
  
 [!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)] определяет общее значение атрибута `xml:lang`. <xref:System.Windows.FrameworkElement.Language%2A>, по сути, представляет значение этого атрибута как свойство зависимостей. <xref:System.Windows.FrameworkElement.Language%2A> могут быть скорректированы программно и могут участвовать в наследовании значения системы свойств способом, который параллельно наследуется атрибутом `xml:lang` в области дочернего элемента в [!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)]. Если задать <xref:System.Windows.FrameworkElement.Language%2A>, это значение станет `xml:lang` и перезапишет любое предыдущее значение. Дополнительные сведения см. [в разделе Обработка XML: lang в XAML](~/docs/framework/xaml-services/xml-lang-handling-in-xaml.md).  
  
<a name="dependencyPropertyInfo_CultureInfo"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.LanguageProperty>|  
|Для свойств метаданных задано значение `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LanguageProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LanguageProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LanguageProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LanguageProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LanguageProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LanguageProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.LanguageProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.Language" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LayoutTransform">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Transform LayoutTransform { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Transform LayoutTransform" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.LayoutTransform" />
      <MemberSignature Language="VB.NET" Value="Public Property LayoutTransform As Transform" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Transform ^ LayoutTransform { System::Windows::Media::Transform ^ get(); void set(System::Windows::Media::Transform ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LayoutTransform : System.Windows.Media.Transform with get, set" Usage="System.Windows.FrameworkElement.LayoutTransform" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Transform</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает графическое преобразование, которое применяется к элементу при изменении параметров размещения.</summary>
        <value>Преобразование, которое должен использовать данный элемент. Значение по умолчанию — <see cref="P:System.Windows.Media.Transform.Identity" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В отличие от <xref:System.Windows.UIElement.RenderTransform%2A><xref:System.Windows.FrameworkElement.LayoutTransform%2A> будет влиять на результаты макета.  
  
 Задание преобразования предоставляет эффективные возможности масштабирования и вращения. Однако <xref:System.Windows.FrameworkElement.LayoutTransform%2A> игнорирует операции <xref:System.Windows.Media.TranslateTransform>. Это обусловлено тем, что поведение системы макета для дочерних элементов <xref:System.Windows.FrameworkElement> автоматически корректирует любое смещение до позиции масштабированного или повернутого элемента в макет и систему координат родительского элемента.  
  
 <xref:System.Windows.FrameworkElement.LayoutTransform%2A> может привести к ухудшению производительности приложения, если вызвать его в сценарии, не требующем полного прохода системой макета. При применении <xref:System.Windows.FrameworkElement.LayoutTransform%2A> к коллекции <xref:System.Windows.Controls.Panel.Children%2A> <xref:System.Windows.Controls.Panel>, она запускает новый проход системы макета и принудительно переносит и упорядочивает все объекты на экране. При обновлении полного [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]приложения эта функция может быть именно тем, что вам нужно. Однако если не требуется полный проход макета, используйте свойство <xref:System.Windows.UIElement.RenderTransform%2A>, которое не вызывает систему макета и, следовательно, является лучшим выбором для этого сценария.  
  
 Примеры сценариев, в которых можно использовать <xref:System.Windows.FrameworkElement.LayoutTransform%2A>: поворот элементов, таких как компоненты меню, от горизонтального к вертикальному или наоборот, масштабирование элементов (увеличение) на фокусе, предоставление редактирования и т. д.  
  
<a name="dependencyPropertyInfo_LayoutTransform"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.LayoutTransformProperty>|  
|Для свойств метаданных задано значение `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 В следующем примере показано, как применить к элементу <xref:System.Windows.FrameworkElement.LayoutTransform%2A>. В примере создается экземпляр <xref:System.Windows.Controls.Button> и размещается в родительской <xref:System.Windows.Controls.Grid>. Он также использует свойство <xref:System.Windows.FrameworkElement.LayoutTransform%2A> для применения <xref:System.Windows.Media.RotateTransform> к <xref:System.Windows.Controls.Button>.  
  
 [!code-cpp[LayoutTransform#1](~/samples/snippets/cpp/VS_Snippets_Wpf/LayoutTransform/CPP/LayoutTransform.cpp#1)]
 [!code-csharp[LayoutTransform#1](~/samples/snippets/csharp/VS_Snippets_Wpf/LayoutTransform/CSharp/LayoutTransform.cs#1)]
 [!code-vb[LayoutTransform#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/LayoutTransform/VisualBasic/LayoutTransform.vb#1)]
 [!code-xaml[LayoutTransform#1](~/samples/snippets/xaml/VS_Snippets_Wpf/LayoutTransform/XAML/default.xaml#1)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=158252">Пример двумерной преобразования</related>
      </Docs>
    </Member>
    <Member MemberName="LayoutTransformProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LayoutTransformProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LayoutTransformProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LayoutTransformProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LayoutTransformProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LayoutTransformProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LayoutTransformProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.LayoutTransformProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.LayoutTransform" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Loaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Loaded;" />
      <MemberSignature Language="F#" Value="member this.Loaded : System.Windows.RoutedEventHandler " Usage="member this.Loaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, если элемент размещен, отрисован и готов к взаимодействию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Loaded> обычно является последним событием, возникающим в последовательности инициализации элемента. Он всегда будет вызываться после <xref:System.Windows.FrameworkElement.Initialized>. Нужно ли выполнять обработку <xref:System.Windows.FrameworkElement.Loaded> или <xref:System.Windows.FrameworkElement.Initialized> зависит от ваших требований. Если не требуется считывать свойства элементов, планируется сбрасывать свойства и не требуется никакой информации о макете, <xref:System.Windows.FrameworkElement.Initialized> может быть лучшим событием. Если требуется, чтобы все свойства элемента были доступны, и вы задаете свойства, которые, скорее всего, будут сбрасывать макет, <xref:System.Windows.FrameworkElement.Loaded> может быть лучшим событием. Будьте внимательны при повторном входе, если ваш обработчик сбрасывает все свойства, интерпретируемые системой макета, что означает необходимость нового прохода макета. (Может потребоваться проверить значения <xref:System.Windows.FrameworkPropertyMetadata> свойства, если вы не уверены, какие свойства могут потребовать нового прохода макета, если они были изменены.)  
  
 Дополнительные сведения о последовательности событий объекта для <xref:System.Windows.FrameworkElement>, а также о нескольких связанных классах приложений и элементов см. в разделе [события времени существования объекта](~/docs/framework/wpf/advanced/object-lifetime-events.md).  
  
 Прямые перенаправленные события не следуют маршруту, они обрабатываются только в том же элементе, в котором они вызываются. Перенаправленные события поддерживают другое поведение перенаправленного события: они поддерживают коллекцию обработчиков, доступную для доступа, и могут использоваться в качестве <xref:System.Windows.EventTrigger> в стиле.  
  
 <xref:System.Windows.FrameworkElement.Loaded> и <xref:System.Windows.FrameworkElement.Unloaded> могут быть вызваны в элементах управления в результате изменения пользовательской темы, инициированной пользователем. Изменение темы приводит к недействительности шаблона элемента управления и содержащегося в нем визуального дерева, которое, в свою очередь, приводит к выгрузке и перезагрузке всего элемента управления. Поэтому <xref:System.Windows.FrameworkElement.Loaded> не может быть предполагается выполнять только при первой загрузке страницы с помощью перехода на страницу.  
  
<a name="routedEventInfo_Loaded"></a>   
## <a name="routed-event-information"></a>Сведения о маршрутизируемом событии  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.LoadedEvent>|  
|Стратегия маршрутизации|Direct|  
|делегат|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" />
      </Docs>
    </Member>
    <Member MemberName="LoadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LoadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LoadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LoadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LoadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LoadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LoadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.LoadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует направленное событие <see cref="E:System.Windows.FrameworkElement.Loaded" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Идентификаторы перенаправленных событий создаются при их регистрации. Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события. Эти идентификаторы можно использовать для добавления обработчиков классов.  
  
 Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.FrameworkElement.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает перечислитель для логических дочерних элементов данного элемента.</summary>
        <value>Перечислитель для логических дочерних элементов данного элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.LogicalChildren%2A> позволяет перебирать дочерние элементы. Это полезно для элементов, которые не могут иметь определенную выделенную коллекцию, но по-прежнему содержат более одного дочернего элемента, особенно <xref:System.Windows.FrameworkContentElement> дочерние элементы.  
  
 Дополнительные сведения об использовании <xref:System.Windows.FrameworkElement.LogicalChildren%2A> и <xref:System.Windows.FrameworkElement.AddLogicalChild%2A>см. в разделе [деревья в WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/c5358e14-d24c-44c7-b5eb-6062a4fd981c">Расширение разметки x:Array</related>
      </Docs>
    </Member>
    <Member MemberName="Margin">
      <MemberSignature Language="C#" Value="public System.Windows.Thickness Margin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Thickness Margin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Margin" />
      <MemberSignature Language="VB.NET" Value="Public Property Margin As Thickness" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Thickness Margin { System::Windows::Thickness get(); void set(System::Windows::Thickness value); };" />
      <MemberSignature Language="F#" Value="member this.Margin : System.Windows.Thickness with get, set" Usage="System.Windows.FrameworkElement.Margin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Thickness</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение внешнего поля элемента.</summary>
        <value>Предоставляет значения полей для элемента. Значение по умолчанию — <see cref="T:System.Windows.Thickness" />. Все свойства равны 0 (нулю).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поле — это пространство между этим элементом и другими элементами, которые будут смежными, когда макет создает [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]. Общие элементы могут быть одноранговыми (например, другими элементами в коллекции общего родительского элемента управления) или же родительским элементом.  
  
 <xref:System.Windows.FrameworkElement.Margin%2A> задается как структура <xref:System.Windows.Thickness>, а не как число, чтобы поле можно было установить асимметрично. Структура <xref:System.Windows.Thickness> сама по себе поддерживает преобразование строкового типа, чтобы можно было указать асимметричную <xref:System.Windows.FrameworkElement.Margin%2A> в синтаксисе [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] атрибутов.  
  
 Ненулевое поле применяет пространство за пределами <xref:System.Windows.FrameworkElement.ActualWidth%2A> и <xref:System.Windows.FrameworkElement.ActualHeight%2A>макета элемента.  
  
 Поля являются аддитивными для одноуровневых элементов в макете. Например, два соседних элемента с полем, равным 30, задаются на соседнем крае, будут иметь 60 единиц пространства между ними.  
  
 Элементы, имеющие заданный набор полей, обычно не ограничивают размер указанного <xref:System.Windows.FrameworkElement.Margin%2A>, если выделенное прямоугольное пространство недостаточно велико для поля плюс область содержимого элемента. Вместо этого область содержимого элемента будет ограничена при вычислении макета. Единственный случай, когда поля будут ограничены, также имеет значение, если содержимое уже ограничено нулем.  
  
<a name="xamlAttributeUsage_Margin"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```xaml  
<object Margin="left,top,right,bottom"/>  
```

- или -

```xaml
<object Margin="left,top"/>  
```

- или -  

```xaml
<object Margin="thicknessReference"/>  
```

<a name="xamlPropertyElementUsage_Margin"></a>   
## <a name="xaml-property-element-usage"></a>Использование элемента свойства XAML  
  
```  
<object>  
  <object.Margin>  
    <Thickness Left="left" Top="top" Right="right" Bottom="bottom"/>  
  </object.Margin>  
</object>  
```  
  
<a name="xamlValues_Margin"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *слева, сверху, справа, снизу*  
 Числовые значения в диапазоне от 0 до <xref:System.Double.PositiveInfinity>, указывающие четыре возможных свойства измерения структуры <xref:System.Windows.Thickness>.  
  
 Использование атрибута также позволит принимать сокращенные значения, которые применяются в указанном порядке (симметрично и логически). Например, `Margin="20"` будет интерпретироваться как <xref:System.Windows.Thickness> со всеми свойствами, для которых задано значение 20. `Margin="20,50"` будет интерпретироваться как <xref:System.Windows.Thickness> с <xref:System.Windows.Thickness.Left%2A>, а <xref:System.Windows.Thickness.Right%2A> равным 20, а <xref:System.Windows.Thickness.Top%2A> и <xref:System.Windows.Thickness.Bottom%2A> — 50.  
  
 Единица по умолчанию для <xref:System.Windows.Thickness> меры — [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]. Кроме того, можно указать другие единицы, добавив строки типа единиц измерения `cm`, `in`или `pt` в любую меру.  
  
 Числовые значения, указанные в качестве [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] атрибутов, не должны указывать десятичные разделители (0 является приемлемым, не обязательно предоставляться как 0,0). Дополнительные сведения об использовании [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] см. в разделе <xref:System.Windows.Thickness>.  
  
 *сиккнессреференце*  
 Ссылка на существующий <xref:System.Windows.Thickness>. Это может быть `}`, или `}` ссылку. Дополнительные сведения об использовании [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] см. в разделе <xref:System.Windows.Thickness>.  
  
<a name="dependencyPropertyInfo_Margin"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.MarginProperty>|  
|Для свойств метаданных задано значение `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Thickness" />
      </Docs>
    </Member>
    <Member MemberName="MarginProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MarginProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MarginProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MarginProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MarginProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MarginProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MarginProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MarginProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.Margin" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxHeight">
      <MemberSignature Language="C#" Value="public double MaxHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MaxHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MaxHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MaxHeight { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MaxHeight : double with get, set" Usage="System.Windows.FrameworkElement.MaxHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение или установка максимально допустимой высоты элемента.</summary>
        <value>Максимальная высота элемента в [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Значение по умолчанию — <see cref="F:System.Double.PositiveInfinity" />. Это значение может быть больше или равно 0,0. Значение <see cref="F:System.Double.PositiveInfinity" /> также допустимо.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это одно из трех свойств <xref:System.Windows.FrameworkElement>, определяющих сведения о высоте. Два других — <xref:System.Windows.FrameworkElement.MinHeight%2A> и <xref:System.Windows.FrameworkElement.Height%2A>.  Если между этими значениями возникает конфликт, то порядок приложений для определения фактической высоты сначала <xref:System.Windows.FrameworkElement.MinHeight%2A> должен учитываться, затем <xref:System.Windows.FrameworkElement.MaxHeight%2A>и, если все они находятся в пределах границ, <xref:System.Windows.FrameworkElement.Height%2A>.  
  
 Ограничения по значению для <xref:System.Double> значения применяются механизмом <xref:System.Windows.ValidateValueCallback>. При попытке задать недопустимое значение возникает исключение времени выполнения.  
  
<a name="xamlAttributeUsage_MaxHeight"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```xaml  
<object MaxHeight="double"/>  
```

- или -

```xaml
<object MaxHeight ="qualifiedDouble"/>  
```

<a name="xamlValues_MaxHeight"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *double*  
 <xref:System.Double>  
  
 Строковое представление значения <xref:System.Double>, равное или больше 0,0. Это интерпретируется как измерение [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]. Строки не должны явно включать десятичные разделители. Для экземпляра значение `1` приемлемо.  
  
 Действуют те же ограничения диапазона <xref:System.Double>, что и в разделе «значение свойства», за исключением того, что необходимо использовать [расширение разметки x:Static](~/docs/framework/xaml-services/x-static-markup-extension.md) , если необходимо явно задать значение <xref:System.Double.PositiveInfinity>.  
  
 *куалифиеддаубле*  
 Значение *типа Double* , как описано выше, за которым следует одна из следующих строк объявления единицы: `px`, `in`, `cm`, `pt`.  
  
 `px` (по умолчанию) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` в дюймах; 1in = = 96 пикселей  
  
 `cm` — сантиметры; 1cm = = (96/2,54) px  
  
 `pt` — это точки; выбрано 1pt = = (96/72) px  
  
<a name="dependencyPropertyInfo_MaxHeight"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.MaxHeightProperty>|  
|Для свойств метаданных задано значение `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MaxHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MaxHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MaxHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MaxHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MaxHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MaxHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MaxHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.MaxHeight" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxWidth">
      <MemberSignature Language="C#" Value="public double MaxWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MaxWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MaxWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MaxWidth { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MaxWidth : double with get, set" Usage="System.Windows.FrameworkElement.MaxWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение или установка максимально допустимой ширины элемента.</summary>
        <value>Максимальная ширина элемента в [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Значение по умолчанию — <see cref="F:System.Double.PositiveInfinity" />. Это значение может быть больше или равно 0,0. Значение <see cref="F:System.Double.PositiveInfinity" /> также допустимо.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это одно из трех свойств <xref:System.Windows.FrameworkElement>, которые указывают сведения о ширине. Два других — <xref:System.Windows.FrameworkElement.MinWidth%2A> и <xref:System.Windows.FrameworkElement.Width%2A>. Если между этими значениями возникает конфликт, то порядок определения фактической ширины приложения сначала <xref:System.Windows.FrameworkElement.MinWidth%2A> должен учитываться, затем <xref:System.Windows.FrameworkElement.MaxWidth%2A>и, наконец, если все они находятся в пределах границ, <xref:System.Windows.FrameworkElement.Width%2A>.  
  
 Ограничения по значению для <xref:System.Double> значения применяются механизмом <xref:System.Windows.ValidateValueCallback>. При попытке задать недопустимое значение возникает исключение времени выполнения.  
  
<a name="xamlAttributeUsage_MaxWidth"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```xaml 
<object MaxWidth="double"/>  
```

- или -

```xaml
<object MaxWidth="qualifiedDouble"/>  
```

<a name="xamlValues_MaxWidth"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *double*  
 <xref:System.Double>  
  
 Строковое представление значения <xref:System.Double>, равное или больше 0,0. Это интерпретируется как измерение [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]. Строки не должны явно включать десятичные разделители. Для экземпляра значение `1` приемлемо.  
  
 Действуют те же ограничения диапазона <xref:System.Double>, что и в разделе «значение свойства», за исключением того, что необходимо использовать [расширение разметки x:Static](~/docs/framework/xaml-services/x-static-markup-extension.md) , чтобы присвоить значение <xref:System.Double.PositiveInfinity>.  
  
 *куалифиеддаубле*  
 Значение *типа Double* , как описано выше, за которым следует одна из следующих строк объявления единицы: `px`, `in`, `cm`, `pt`.  
  
 `px` (по умолчанию) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` в дюймах; 1in = = 96 пикселей  
  
 `cm` — сантиметры; 1cm = = (96/2,54) px  
  
 `pt` — это точки; выбрано 1pt = = (96/72) px  
  
<a name="dependencyPropertyInfo_MaxWidth"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.MaxWidthProperty>|  
|Для свойств метаданных задано значение `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MaxWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MaxWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MaxWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MaxWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MaxWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MaxWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MaxWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.MaxWidth" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureCore">
      <MemberSignature Language="C#" Value="protected override sealed System.Windows.Size MeasureCore (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureCore(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MeasureCore(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function MeasureCore (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureCore(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="override this.MeasureCore : System.Windows.Size -&gt; System.Windows.Size" Usage="frameworkElement.MeasureCore availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">Доступный размер, который родительский элемент может предоставить дочерним элементам.</param>
        <summary>Реализует базовое поведение системы макета на этапе измерения для <see cref="T:System.Windows.FrameworkElement" />.</summary>
        <returns>Желательный размер этого элемента в макете.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод переопределяет <xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=nameWithType> для подключения реализаций меры макета на уровне ядра WPF и на уровне платформы WPF. Реализация <xref:System.Windows.FrameworkElement> запечатывает метод. Чтобы изменить поведение макета прохода меры для любого элемента, который строится на уровне платформы WPF, вместо этого переопределите <xref:System.Windows.FrameworkElement.MeasureOverride%2A>. Чтобы изменить поведение макета прохода меры для элемента, который намеренно не строится на уровне платформы WPF, или используйте <xref:System.Windows.FrameworkElement>, переопределите <xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Size MeasureOverride (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function MeasureOverride (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Size MeasureOverride(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="abstract member MeasureOverride : System.Windows.Size -&gt; System.Windows.Size&#xA;override this.MeasureOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="frameworkElement.MeasureOverride availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">Доступный размер, который этот элемент может предоставить дочерним элементам. Можно задать бесконечное значение, указав таким образом, что элемент будет масштабироваться в соответствии с любым содержимым.</param>
        <summary>При переопределении в производном классе измеряет размер в структуре, требуемый для дочерних элементов, и определяет размер для класса, производного от <see cref="T:System.Windows.FrameworkElement" />.</summary>
        <returns>Размер, определяемый данным элементом для своих потребностей во время структурирования на основе вычисления размеров дочерних элементов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Переопределите <xref:System.Windows.FrameworkElement.MeasureOverride%2A>, чтобы реализовать поведение пользовательского изменения размера макета для элемента, когда он участвует в системе макета [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]. Ваша реализация должна выполнить следующие действия:  
  
1.  Выполните итерацию определенной коллекции элементов, являющихся частью макета, вызовите <xref:System.Windows.UIElement.Measure%2A> для каждого дочернего элемента.  
  
2.  Немедленно получить <xref:System.Windows.UIElement.DesiredSize%2A> для дочернего элемента (это свойство устанавливается после вызова <xref:System.Windows.UIElement.Measure%2A>).  
  
3.  Вычислите требуемый общий размер родителя на основе измерения дочерних элементов.  
  
 Возвращаемое значение <xref:System.Windows.FrameworkElement.MeasureOverride%2A> должно быть собственным требуемым размером элемента, который затем станет входным значением меры для родительского элемента текущего элемента. Этот процесс проходит через систему макета до тех пор, пока не будет достигнут корневой элемент страницы.  
  
 Во время этого процесса дочерние элементы могут возвращать больший размер <xref:System.Windows.UIElement.DesiredSize%2A>, чем начальный `availableSize`, чтобы указать, что дочернему элементу требуется дополнительное пространство. Это может быть обработано в собственной реализации путем представления прокручиваемой области путем изменения размера родительского элемента управления путем установки определенного способа упорядочения с накоплением или любого числа решений для измерения или упорядочения содержимого.  
  
> [!IMPORTANT]
>  Во время этого процесса элементы должны вызывать <xref:System.Windows.UIElement.Measure%2A> для каждого дочернего элемента, в противном случае размер дочерних элементов будет неверно изменен или упорядочен.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Следующий некомпилируемый код показывает этот шаблон реализации.  <c>VisualChildren</c> представляет свойство перечислимой коллекции дочерних элементов, которые должен определить ваш собственный элемент. Свойству можно присвоить любое имя. <c>VisualChildren</c> — это имя заполнителя для данного примера, <c>VISUALCHILDREN</c> не является API, предоставленным [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] или частью шаблона именования. 
  
[! код-CSharp[корепсеудокоде # фемеасуреоверриде](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#femeasureoverride)] [! code-VB[корепсеудокоде # фемеасуреоверриде](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#femeasureoverride)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="MinHeight">
      <MemberSignature Language="C#" Value="public double MinHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MinHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MinHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property MinHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MinHeight { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MinHeight : double with get, set" Usage="System.Windows.FrameworkElement.MinHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение или установка минимально допустимой высоты элемента.</summary>
        <value>Минимальная высота элемента в [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Значение по умолчанию — 0,0. Это значение может быть больше или равно 0,0. Однако <see cref="F:System.Double.PositiveInfinity" /> и <see cref="F:System.Double.NaN" /> являются недопустимыми.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это одно из трех свойств <xref:System.Windows.FrameworkElement>, определяющих сведения о высоте.  Два других — <xref:System.Windows.FrameworkElement.Height%2A> и <xref:System.Windows.FrameworkElement.MaxHeight%2A>. Если между этими значениями возникает конфликт, то порядок приложений для определения фактической высоты сначала <xref:System.Windows.FrameworkElement.MinHeight%2A> должен учитываться, затем <xref:System.Windows.FrameworkElement.MaxHeight%2A>и, если все они находятся в пределах границ, <xref:System.Windows.FrameworkElement.Height%2A>.  
  
 Ограничения по значению для <xref:System.Double> значения применяются механизмом <xref:System.Windows.ValidateValueCallback>. При попытке задать недопустимое значение возникает исключение времени выполнения.  
  
<a name="xamlAttributeUsage_MinHeight"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```xaml
<object MinHeight="double"/>  
```

- или -

```xaml
<object MinHeight="qualifiedDouble"/>  
```

<a name="xamlValues_MinHeight"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *double*  
 <xref:System.Double>  
  
 Строковое представление значения <xref:System.Double>, равное или больше 0,0. Это интерпретируется как измерение [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]. Строки не должны явно включать десятичные разделители. Для экземпляра значение `1` приемлемо.  
  
 Действуют те же ограничения диапазона <xref:System.Double>, что и в разделе значение свойства.  
  
 *куалифиеддаубле*  
 Значение *типа Double* , как описано выше, за которым следует одна из следующих строк объявления единицы: `px`, `in`, `cm`, `pt`.  
  
 `px` (по умолчанию) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` в дюймах; 1in = = 96 пикселей  
  
 `cm` — сантиметры; 1cm = = (96/2,54) px  
  
 `pt` — это точки; выбрано 1pt = = (96/72) px  
  
<a name="dependencyPropertyInfo_MinHeight"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.MinHeightProperty>|  
|Для свойств метаданных задано значение `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MinHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MinHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MinHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MinHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MinHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MinHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MinHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.MinHeight" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinWidth">
      <MemberSignature Language="C#" Value="public double MinWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MinWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MinWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MinWidth { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MinWidth : double with get, set" Usage="System.Windows.FrameworkElement.MinWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение или установка минимально допустимой ширины элемента.</summary>
        <value>Минимальная ширина элемента в [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Значение по умолчанию — 0,0. Это значение может быть больше или равно 0,0. Однако <see cref="F:System.Double.PositiveInfinity" /> и <see cref="F:System.Double.NaN" /> являются недопустимыми.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это одно из трех свойств <xref:System.Windows.FrameworkElement>, которые указывают сведения о ширине.  Два других — <xref:System.Windows.FrameworkElement.Width%2A> и <xref:System.Windows.FrameworkElement.MaxWidth%2A>.  Если между этими значениями возникает конфликт, то порядок определения фактической ширины приложения сначала <xref:System.Windows.FrameworkElement.MinWidth%2A> должен учитываться, затем <xref:System.Windows.FrameworkElement.MaxWidth%2A>и, наконец, если все они находятся в пределах границ, <xref:System.Windows.FrameworkElement.Width%2A>.  
  
 Ограничения по значению для <xref:System.Double> значения применяются механизмом <xref:System.Windows.ValidateValueCallback>. При попытке задать недопустимое значение возникает исключение времени выполнения.  
  
<a name="xamlAttributeUsage_MinWidth"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```xaml 
<object MinWidth="double"/>  
```

- или -

```xaml
<object MinWidth="qualifiedDouble"/>  
```
  
<a name="xamlValues_MinWidth"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *double*  
 <xref:System.Double>  
  
 Строковое представление значения <xref:System.Double>, равное или больше 0,0. Это интерпретируется как измерение [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]. Строки не должны явно включать десятичные разделители. Для экземпляра значение `1` приемлемо.  
  
 Действуют те же ограничения диапазона <xref:System.Double>, что и в разделе значение свойства.  
  
 *куалифиеддаубле*  
 Значение *типа Double* , как описано выше, за которым следует одна из следующих строк объявления единицы: `px`, `in`, `cm`, `pt`.  
  
 `px` (по умолчанию) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` в дюймах; 1in = = 96 пикселей  
  
 `cm` — сантиметры; 1cm = = (96/2,54) px  
  
 `pt` — это точки; выбрано 1pt = = (96/72) px  
  
<a name="dependencyPropertyInfo_MinWidth"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.MinWidthProperty>|  
|Для свойств метаданных задано значение `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MinWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MinWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MinWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MinWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MinWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MinWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MinWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.MinWidth" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="override this.MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool" Usage="frameworkElement.MoveFocus request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">Направление, в котором перемещается фокус, в виде значения перечисления.</param>
        <summary>Перемещает клавиатурный фокус от данного элемента на другой элемент в указанном направлении обхода.</summary>
        <returns>Возвращает значение <see langword="true" />, если фокус успешно перемещен; <see langword="false" />, если целевого элемента в указанном направлении не существует или на него нельзя установить клавиатурный фокус.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта реализация переопределяет <xref:System.Windows.UIElement.MoveFocus%2A?displayProperty=nameWithType> и запечатывает метод.  
  
   
  
## Examples  
 В следующем примере реализуется обработчик, который обрабатывает несколько возможных входных значений кнопки. Каждая кнопка представляет возможный <xref:System.Windows.Input.FocusNavigationDirection>. Обработчик отслеживает элемент с текущим фокусом клавиатуры и вызывает <xref:System.Windows.FrameworkElement.MoveFocus%2A> для этого элемента, указывая соответствующий <xref:System.Windows.Input.FocusNavigationDirection> как инициализацию для предоставленного параметра типа <xref:System.Windows.Input.TraversalRequest>.  
  
 [!code-csharp[FocusSample#FocusSampleMoveFocus](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSample/CSharp/Window1.xaml.cs#focussamplemovefocus)]
 [!code-vb[FocusSample#FocusSampleMoveFocus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSample/visualbasic/window1.xaml.vb#focussamplemovefocus)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="M:System.Windows.UIElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.FrameworkElement.Name" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IFrameworkInputElement.Name</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Windows.Markup.DesignerSerializationOptions(System.Windows.Markup.DesignerSerializationOptions.SerializeAsAttribute)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает имя, обозначающее элемент. Имя предоставляет ссылку, чтобы код программной части, например код обработчика событий, мог ссылаться на элемент разметки после создания этого элемента в ходе обработки процессором [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</summary>
        <value>Имя элемента. Значение по умолчанию - пустая строка.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Наиболее распространенным применением этого свойства является указание [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] имени элемента в виде атрибута в разметке.  
  
 Это свойство по сути предоставляет удобное свойство уровня инфраструктуры WPF для установки [директивы [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] x:Name](~/docs/framework/xaml-services/x-name-directive.md).  
  
 Имена должны быть уникальными в пределах области имен. Более подробную информацию см. в разделе [Области видимости имен XAML в WPF](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
 Получение <xref:System.Windows.FrameworkElement.Name%2A> при создании элементов в коде не является распространенным. Если в коде уже есть соответствующая ссылка, можно просто вызвать методы и свойства в ссылке на элемент, и в общем случае <xref:System.Windows.FrameworkElement.Name%2A>не потребуется. Исключением является то, что <xref:System.Windows.FrameworkElement.Name%2A> строка имеет некоторое перегруженное значение, например, если полезно отображать это имя в [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]. Установка <xref:System.Windows.FrameworkElement.Name%2A> из кода программной части, если исходная <xref:System.Windows.FrameworkElement.Name%2A> была задана из разметки, также не рекомендуется и изменение свойства после загрузки [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] не приведет к изменению исходной ссылки на объект. Ссылки на объекты создаются только в том случае, если базовые области видимости имен явным образом создаются во время синтаксического анализа. Необходимо специально вызвать <xref:System.Windows.FrameworkElement.RegisterName%2A>, чтобы внести эффективное изменение в свойство <xref:System.Windows.FrameworkElement.Name%2A> уже загруженного элемента.  
  
 Важно отметить, что параметр <xref:System.Windows.FrameworkElement.Name%2A> из кода важен при регистрации имен элементов, для которых будут выполняться раскадровки, чтобы на них можно было ссылаться во время выполнения. Прежде чем можно будет зарегистрировать имя, может также потребоваться создать и назначить экземпляр <xref:System.Windows.NameScope>. См. раздел "пример" или [Общие сведения о раскадровках](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).  
  
 Установка <xref:System.Windows.FrameworkElement.Name%2A> из кода имеет ограниченные приложения, но получение элемента с помощью <xref:System.Windows.FrameworkElement.Name%2A> является более распространенным. Один из сценариев состоит в том, что приложение поддерживает модель навигации, в которой страницы перегружаются в приложение, а код времени выполнения не обязательно определяется кодом программной части для этой страницы. Служебный метод <xref:System.Windows.FrameworkElement.FindName%2A>, который доступен из любого <xref:System.Windows.FrameworkElement>, может найти любой элемент, <xref:System.Windows.FrameworkElement.Name%2A> в логическом дереве для этого элемента, выполняя поиск дерева рекурсивно по мере необходимости. Или можно использовать <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> статический метод <xref:System.Windows.LogicalTreeHelper>, который также принимает в качестве аргумента <xref:System.Windows.FrameworkElement.Name%2A>ную строку.  
  
 Обычно используемые корневые элементы (например,<xref:System.Windows.Window>, <xref:System.Windows.Controls.Page>) реализуют интерфейс <xref:System.Windows.Markup.INameScope>. Реализации этого интерфейса должны обеспечивать однозначность имен в пределах их области. Корневые элементы, определяющие этот интерфейс, также определяют границы поведения области видимости имен для всех связанных интерфейсов API.  
  
 Свойство <xref:System.Windows.FrameworkElement.Name%2A> также служит идентификатором для других процессов. Например, модель автоматизации [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] будет использовать <xref:System.Windows.FrameworkElement.Name%2A> в качестве AutomationId для клиентов и поставщиков.  
  
 Строковые значения, используемые для <xref:System.Windows.FrameworkElement.Name%2A>, имеют некоторые ограничения, накладываемые базовой [директивой x:Name](~/docs/framework/xaml-services/x-name-directive.md) , определенной спецификацией [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]. В первую очередь, <xref:System.Windows.FrameworkElement.Name%2A> должен начинаться с буквы или символа подчеркивания (_) и должен содержать только буквы, цифры или символы подчеркивания. Более подробную информацию см. в разделе [Области видимости имен XAML в WPF](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
 <xref:System.Windows.FrameworkElement.Name%2A> является одним из очень небольшого числа свойств зависимости, которые не могут быть анимированы (<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> `true` в метаданных), так как само имя является крайне важным для целей анимации. Привязка данных <xref:System.Windows.FrameworkElement.Name%2A> технически возможна, но является чрезвычайно нераспространенной ситуацией, поскольку привязанные к данным <xref:System.Windows.FrameworkElement.Name%2A> не могут обслуживать основную цель свойства: для предоставления точки подключения идентификатора для кода программной части.  
  
<a name="dependencyPropertyInfo_Name"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.NameProperty>|  
|Для свойств метаданных задано значение `true`|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|  
  
   
  
## Examples  
 В следующем примере задается свойство <xref:System.Windows.FrameworkElement.Name%2A> в коде, а затем имя регистрируется во вновь созданном <xref:System.Windows.NameScope> путем вызова <xref:System.Windows.FrameworkElement.RegisterName%2A>. Здесь показана методика для анимации с помощью раскадровок, так как раскадровка требует нацеливание на <xref:System.Windows.FrameworkElement.Name%2A>и не может быть нацелена на ссылку на объект.  
  
 [!code-csharp[animateHeight_procedural#FEName](~/samples/snippets/csharp/VS_Snippets_Wpf/animateHeight_procedural/CSharp/AnimatedHeightExample.cs#fename)]
 [!code-vb[animateHeight_procedural#FEName](~/samples/snippets/visualbasic/VS_Snippets_Wpf/animateHeight_procedural/visualbasic/animatedheightexample.vb#fename)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty NameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty NameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.NameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ NameProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable NameProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.NameProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.Name" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnApplyTemplate">
      <MemberSignature Language="C#" Value="public virtual void OnApplyTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnApplyTemplate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnApplyTemplate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnApplyTemplate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnApplyTemplate();" />
      <MemberSignature Language="F#" Value="abstract member OnApplyTemplate : unit -&gt; unit&#xA;override this.OnApplyTemplate : unit -&gt; unit" Usage="frameworkElement.OnApplyTemplate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе вызывается всякий раз, когда код приложения или внутренние процессы вызывают метод <see cref="M:System.Windows.FrameworkElement.ApplyTemplate" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не имеет реализации по умолчанию.  
  
 Шаблоны — это раздел завершенного визуального дерева элемента, который поступает из свойства шаблона <xref:System.Windows.Style>, применяемого к элементу. Более подробную информацию см. в разделе [Стилизация и использование шаблонов](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Производные классы <see cref="T:System.Windows.FrameworkElement" /> могут использовать этот метод в качестве уведомления для различных возможных сценариев: 
— Можно вызвать собственную реализацию кода, который строит оставшуюся часть визуального дерева элемента.  
  
— Можно выполнять код, основанный на визуальном дереве, из примененных шаблонов, например получать ссылки на именованные элементы, поступилные из шаблона.  
  
— Можно создать службы, имеющие смысл, только после того, как будет выполнено визуальное дерево из шаблонов.  
  
— Можно задать состояния и свойства элементов в шаблоне, которые зависят от других факторов. Например, значения свойств могут быть обнаружены только путем знания родительского элемента или когда конкретный производный класс использует общий шаблон.  
  
Разработчики всегда должны вызывать базовую реализацию перед собственной реализацией. у самого <see cref="T:System.Windows.FrameworkElement" /> нет реализации по умолчанию, но промежуточные классы могут.  
  
 <see cref="T:System.Windows.Controls.Control" /> предлагает аналогичное переопределение <see cref="M:System.Windows.Controls.Control.OnTemplateChanged(System.Windows.Controls.ControlTemplate,System.Windows.Controls.ControlTemplate)" />.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuClosing (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuClosing(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkElement.OnContextMenuClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Предоставляет данные о событии.</param>
        <summary>Вызывается, когда необработанное перенаправленное событие <see cref="E:System.Windows.FrameworkElement.ContextMenuClosing" /> достигает этого класса на своем пути. Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не имеет реализации по умолчанию. Следует по-прежнему вызывать базовую реализацию в случае, если промежуточный класс в наследовании реализует этот метод.  
  
 Цель этого метода схожа с шаблоном событий [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] в методах *: он предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра. В этом случае сопоставленное событие является перенаправленным событием. Шаблон реализации для методов On * отличается для перенаправленных событий, так как перенаправленное событие могло быть создано дочерним элементом, а не обязательно элементом, который будет вызывать обработчики, поэтому ваша реализация должна взять источник аргументов события свойства в учетной записи (и не следует пытаться повторно вызывать событие в большинстве случаев). Подклассы <xref:System.Windows.FrameworkElement> могут выдавать вызовы закрытых методов обработчика класса, когда событие получается по маршруту. Один из возможных сценариев состоит в том, чтобы взять аргументы события и намеренно пометить событие как обработанное.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuOpening (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuOpening(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkElement.OnContextMenuOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.Windows.RoutedEventArgs" />, содержащий данные о событии.</param>
        <summary>Вызывается, когда необработанное перенаправленное событие <see cref="E:System.Windows.FrameworkElement.ContextMenuOpening" /> достигает этого класса на своем пути. Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не имеет реализации по умолчанию. Следует по-прежнему вызывать базовую реализацию в случае, если промежуточный класс в наследовании реализует этот метод.  
  
 Цель этого метода схожа с шаблоном событий [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] в методах *: он предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра. В этом случае сопоставленное событие является перенаправленным событием. Шаблон реализации для методов On * отличается для перенаправленных событий, так как перенаправленное событие могло быть создано дочерним элементом, а не обязательно элементом, который будет вызывать обработчики, поэтому ваша реализация должна взять источник аргументов события свойства в учетной записи (и не следует пытаться повторно вызывать событие в большинстве случаев). Подклассы <xref:System.Windows.FrameworkElement> могут выдавать вызовы закрытых методов обработчика класса, когда событие получается по маршруту. Один из возможных сценариев состоит в том, чтобы взять аргументы события и намеренно пометить событие как обработанное.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="frameworkElement.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.Windows.RoutedEventArgs" />, содержащий данные о событии.</param>
        <summary>Вызывается, когда необработанное событие <see cref="E:System.Windows.UIElement.GotFocus" /> достигает этого элемента на своем пути.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В отличие от некоторых других методов *, предоставляемых базовыми элементами, <xref:System.Windows.FrameworkElement.OnGotFocus%2A> имеет реализацию по умолчанию. В частности, у него есть реализация, которая переопределяет реализацию NULL на следующем уровне базового элемента вниз, <xref:System.Windows.UIElement.OnGotFocus%2A>. При вызове <xref:System.Windows.FrameworkElement.OnGotFocus%2A> задает соответствующее поведение фокуса для этого элемента в случаях, когда событие произошло из текущего элемента из-за фокуса клавиатуры. Обработчик <xref:System.Windows.FrameworkElement.OnGotFocus%2A> не помечает аргументы события как обработанные, даже если фокус установлен на текущий элемент. Если источником события был другой элемент в дереве (не текущий элемент), обработчик не выполняет никаких действий.  
  
 Этот метод можно переопределить, чтобы изменить поведение фокуса по умолчанию для элемента, но следует иметь в виду, что изменение поведения фокуса таким образом может быть лучше выполнено, не позволяя элементу получать фокус (см. <xref:System.Windows.UIElement.Focusable%2A>).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Если вы планируете пометить событие как обработанное в аргументах, следует иметь в виду последствия обработки событий в других родительских элементах дерева элементов. Так как этот обработчик работает с событием с восходящей маршрутизацией, установка фокуса на текущий <paramref name="sender" /> для аргументов события может быть неприемлемой. Фокус может потребовать перехода либо к составному дочернему элементу, либо к родительскому элементу в зависимости от композиции определенных элементов управления. Поэтому Пометка события фокуса как обработанного рекомендуется только в том случае, если все визуальное дерево, в котором выполняется маршрутизация события, является частью компоновки разрабатываемого элемента управления.</para></block>
        <altmember cref="P:System.Windows.UIElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="OnInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitialized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInitialized : EventArgs -&gt; unit&#xA;override this.OnInitialized : EventArgs -&gt; unit" Usage="frameworkElement.OnInitialized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.Windows.RoutedEventArgs" />, содержащий данные о событии.</param>
        <summary>Создает событие <see cref="E:System.Windows.FrameworkElement.Initialized" />. Этот метод вызывается всякий раз, когда <see cref="P:System.Windows.FrameworkElement.IsInitialized" /> имеет внутреннее значение <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конкретный метод * не является обработчиком класса. Кроме того, он не соответствует установленному соглашению о методе [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] on *, что соответствующее событие можно подавлять, переопределив этот метод и не вызывая базовую реализацию.  
  
 Обратите внимание, что свойство <xref:System.Windows.FrameworkElement.IsInitialized%2A> доступно только для чтения, поэтому нельзя задать <xref:System.Windows.FrameworkElement.IsInitialized%2A> для принудительного поведения инициализации. Настройка состояния инициализации должна выполняться только платформой [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)].  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Реализация по умолчанию данного виртуального метода вызывает вышеописанное событие. Для поддержания данного режима работы переопределение должно вызывать базовую реализацию. Если не вызвать базовую реализацию, не только будет вызвано событие <see cref="E:System.Windows.FrameworkElement.Initialized" />, как обычно ожидается <see cref="T:System.Windows.FrameworkElement" /> производный класс, но также будут подавлены две важные операции инициализации стиля и стиля темы, которые реализуются этим Базовая реализация.</para></block>
        <altmember cref="M:System.Windows.FrameworkElement.OnApplyTemplate" />
        <altmember cref="E:System.Windows.FrameworkElement.Initialized" />
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="frameworkElement.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Данные события, описывающие измененное свойство, а также старое и новое значения.</param>
        <summary>Вызывается каждый раз, когда обновляется действительное значение любого свойства зависимостей для данного <see cref="T:System.Windows.FrameworkElement" />. Конкретное измененное свойство зависимостей сообщается в параметре аргументов. Переопределяет <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не предназначен для общего обнаружения изменений свойств или недействительностей. Вместо этого он предназначен для изменения общего шаблона недействительности, если определенная информация известна по широким классификациям свойств.  
  
 Этот метод потенциально вызывается много раз в течение жизненного цикла объекта. Таким образом, можно добиться лучшей производительности при переопределении метаданных определенных свойств, а затем присоединить <xref:System.Windows.CoerceValueCallback> или функции <xref:System.Windows.PropertyChangedCallback> для отдельных свойств. Однако этот метод следует использовать, если <xref:System.Windows.FrameworkElement> включает значительное количество свойств зависимостей, связанных со значением, или если оно включает логику, например поведение отрисовки, которая должна быть повторно запущена для нескольких связанных вариантов недопустимых свойств.  
  
 Обратите внимание, что существует аналогично именованный метод `OnPropertyChanged` с другой сигнатурой (тип параметра — <xref:System.ComponentModel.PropertyChangedEventArgs>), который может использоваться в нескольких классах. Это `OnPropertyChanged` используется для уведомлений объектов данных и является частью контракта для <xref:System.ComponentModel.INotifyPropertyChanged>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Всегда вызывайте базовую реализацию в качестве первой операции в реализации. Невыполнение этого действия приведет к значительному отключению всей системы свойств [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], что приводит к сообщению о неправильном значении. Конкретная реализация <see cref="T:System.Windows.FrameworkElement" /> также отвечает за поддержание соответствующего состояния для различных свойств, влияющих на видимый пользовательский интерфейс. К ним относится недействительность визуального дерева на основе изменений стиля в соответствующее время.</para></block>
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
        <altmember cref="T:System.Windows.PropertyChangedCallback" />
      </Docs>
    </Member>
    <Member MemberName="OnRenderSizeChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnRenderSizeChanged (System.Windows.SizeChangedInfo sizeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnRenderSizeChanged(class System.Windows.SizeChangedInfo sizeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnRenderSizeChanged (sizeInfo As SizeChangedInfo)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnRenderSizeChanged(System::Windows::SizeChangedInfo ^ sizeInfo);" />
      <MemberSignature Language="F#" Value="override this.OnRenderSizeChanged : System.Windows.SizeChangedInfo -&gt; unit" Usage="frameworkElement.OnRenderSizeChanged sizeInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sizeInfo" Type="System.Windows.SizeChangedInfo" />
      </Parameters>
      <Docs>
        <param name="sizeInfo">Сведения о старом и новом размерах при изменении.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.FrameworkElement.SizeChanged" />, используя заданную информацию как часть итоговых данных события.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод переопределяет метод <xref:System.Windows.UIElement.OnRenderSizeChanged%2A>. При вызове этого метода выполняется сброс свойства <xref:System.Windows.FrameworkElement.ActualWidth%2A>, свойства <xref:System.Windows.FrameworkElement.ActualHeight%2A> или и того, и другого, в зависимости от того, что указано как измененное в указанных аргументах, и всегда будет вызывать событие.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Не переопределяйте этот метод для типичных сценариев макета. Система макета работает намеренно асинхронно, чтобы гарантировать, что все возможные варианты компоновки и измерения будут учитываться. Методы переопределения системы макета <see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" /> и <see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />, как правило, достаточно для любых требуемых настроек макета. <see cref="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" /> предоставляется как виртуальный. <see cref="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" /> можно переопределить для исключительных случаев, когда изменение поведения во время выполнения, связанное с событиями ввода, в сочетании с рекомпозицией элементов управления в ответе, может дать неточные сведения о макете.  
  
Этот метод все равно можно переопределить в производных классах (он защищен, но не запечатан). Всегда вызывайте базовую реализацию, чтобы сохранить описанное выше поведение, если нет особых причин для отключения поведения отрисовки на уровне платформы WPF по умолчанию. Если при использовании стандартной системы макета уровня платформы WPF не удается вызвать событие <see cref="E:System.Windows.FrameworkElement.SizeChanged" />, это приведет к нестандартному поведению макета.</para></block>
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStyleChanged(class System.Windows.Style oldStyle, class System.Windows.Style newStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStyleChanged (oldStyle As Style, newStyle As Style)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStyleChanged(System::Windows::Style ^ oldStyle, System::Windows::Style ^ newStyle);" />
      <MemberSignature Language="F#" Value="abstract member OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit&#xA;override this.OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit" Usage="frameworkElement.OnStyleChanged (oldStyle, newStyle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldStyle" Type="System.Windows.Style" />
        <Parameter Name="newStyle" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="oldStyle">Старый стиль.</param>
        <param name="newStyle">Новый стиль.</param>
        <summary>Вызывается при изменении текущего стиля данного элемента, что ведет к недействительности структуры.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет реализацию по умолчанию, которая задает внутренний флаг, задающий условие изменения стиля.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Обычно не следует переопределять этот метод. Любое изменение стиля, включающее меру или упорядоченное изменение, уже вызовет другой цикл визуализации, предполагая, что типичная реализация <see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" /> / <see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />или по умолчанию. Переопределения <see cref="M:System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" /> могут быть приемлемыми, если реализации <see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" /> / <see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" /> намеренно оптимизируют или поддерживают частичные обновления, но по-прежнему требовалось применять изменения к стилям более непосредственно. (Частичные обновления попытаются избежать нескольких добавочных вызовов <see cref="M:System.Windows.UIElement.Measure(System.Windows.Size)" /> и <see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" /> в любых дочерних элементах).</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipClosing(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipClosing (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipClosing(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkElement.OnToolTipClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Предоставляет данные о событии.</param>
        <summary>Вызывается, когда необработанное перенаправленное событие <see cref="E:System.Windows.FrameworkElement.ToolTipClosing" /> достигает этого класса на своем пути. Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не имеет реализации по умолчанию. Следует по-прежнему вызывать базовую реализацию в случае, если промежуточный класс в наследовании реализует этот метод.  
  
 Цель этого метода схожа с шаблоном событий [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] в методах *: он предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра. В этом случае сопоставленное событие является перенаправленным событием. Шаблон реализации для методов On * отличается для перенаправленных событий, так как перенаправленное событие могло быть создано дочерним элементом, а не обязательно элементом, который будет вызывать обработчики, поэтому ваша реализация должна взять источник аргументов события свойства в учетной записи (и не следует пытаться повторно вызывать событие в большинстве случаев). Подклассы <xref:System.Windows.FrameworkElement> могут выдавать вызовы закрытых методов обработчика класса, когда событие получается по маршруту. Один из возможных сценариев состоит в том, чтобы взять аргументы события и намеренно пометить событие как обработанное.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipOpening(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipOpening (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipOpening(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkElement.OnToolTipOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Предоставляет данные о событии.</param>
        <summary>Вызывается, когда перенаправленное событие <see cref="E:System.Windows.FrameworkElement.ToolTipOpening" /> достигает этого класса на своем пути. Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не имеет реализации по умолчанию. Следует по-прежнему вызывать базовую реализацию в случае, если промежуточный класс в наследовании реализует этот метод.  
  
 Цель этого метода схожа с шаблоном событий [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] в методах *: он предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра. В этом случае сопоставленное событие является перенаправленным событием. Шаблон реализации для методов On * отличается для перенаправленных событий, так как перенаправленное событие могло быть создано дочерним элементом, а не обязательно элементом, который будет вызывать обработчики, поэтому ваша реализация должна взять источник аргументов события свойства в учетной записи (и не следует пытаться повторно вызывать событие в большинстве случаев). Подклассы <xref:System.Windows.FrameworkElement> могут выдавать вызовы закрытых методов обработчика класса, когда событие получается по маршруту. Одним из возможных сценариев является получение аргументов события и намеренная пометка события как обработанного для сокращения маршрута.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberSignature Language="F#" Value="override this.OnVisualParentChanged : System.Windows.DependencyObject -&gt; unit" Usage="frameworkElement.OnVisualParentChanged oldParent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">Прежний родительский элемент. Может иметь значение <see langword="null" />, чтобы показать, что ранее у элемента не было родительского элемента.</param>
        <summary>Вызывается при изменении родителя данного  элемента в визуальном дереве. Переопределяет <see cref="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Визуальное дерево может отличаться от логического дерева, так как оно опускает элементы, которые не отображаются визуально, например коллекции, и разворачивает некоторые элементы на основе их темы и композиции стилей. Дополнительные сведения см. в разделе [Деревья в WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Реализация этого виртуального метода по умолчанию запрашивает новый родительский объект, создает различные события инициализации и устанавливает внутренние флаги для состояния инициализации <see cref="T:System.Windows.FrameworkElement" /> соответствующим образом. Наконец, он вызывает последовательные базовые реализации, объявленные <see cref="T:System.Windows.UIElement" />, которая, в свою очередь, вызывает свою основу в <see cref="T:System.Windows.Media.Visual" />. Всегда вызывайте базовую реализацию, чтобы сохранить это поведение, в противном случае поведение дерева элементов для этого элемента при объявлении в качестве дочернего для другого элемента может отличаться от ожидаемого.  
  
Несколько существующих [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] классов переопределяют этот метод, например: <see cref="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />, <see cref="M:System.Windows.Controls.ListBoxItem.OnVisualParentChanged(System.Windows.DependencyObject)" />. Наиболее распространенным сценарием является обеспечение того, что новый родительский элемент должен быть определенным типом. Это может привести к созданию исключения, если новый родительский элемент не удалось выполнить какой-либо способ проверки типа. Специализированная версия этого сценария существует в реализациях элементов списка и пунктов меню, которые не имеют смысла за пределами родительского визуального элемента, которому принадлежит соответствующая коллекция для хранения. Обратите внимание, что эти случаи не обязательно вызывают исключения, так как могут существовать сценарии конструктора, которые полагаются на элементы с переродителем, которые находятся в непостоянном виде, без "обычных" родителей.  
  
Этот метод также переопределяется в некоторых элементах, которые обычно являются корневым элементом, например <see cref="T:System.Windows.Window" />. Другой вариант — элементы, которые представляют собой видимый корневой элемент в разметке, но который автоматически создает большую инфраструктуру в скомпилированном логическом дереве (например, <see cref="T:System.Windows.Controls.Page" />). Реализации <see cref="T:System.Windows.Window" /> и <see cref="T:System.Windows.Controls.Page" /> намеренно запечатывать метод.</para></block>
        <altmember cref="M:System.Windows.Media.Visual.OnVisualParentChanged(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyle">
      <MemberSignature Language="C#" Value="public bool OverridesDefaultStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesDefaultStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.OverridesDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesDefaultStyle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesDefaultStyle { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesDefaultStyle : bool with get, set" Usage="System.Windows.FrameworkElement.OverridesDefaultStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение или установка значения, определяющего использование в элементе свойств стиля, заданных в стилях темы.</summary>
        <value>Значение <see langword="true" />, если этот элемент не использует свойства стиля темы; все свойства, определяющие стиль, получаются из локальных стилей приложения, а свойства стиля темы не применяются. Значение <see langword="false" />, если сначала применяются стили приложения, а затем стили тем для свойств, которые не были явным образом заданы в стилях приложения. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Наиболее распространенное использование этого свойства — это косвенное использование в методе задания стиля, который предоставляет стиль темы.  
  
> [!IMPORTANT]
>  Если в элементе управления задать для <xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A> значение `true`, то шаблон элемента управления по умолчанию, предоставляемый стилями темы, будет подавлен. Этот шаблон элемента управления обычно включает в себя представление содержимого и другие составные элементы, предоставляющие базовую [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]ную функциональность и визуализацию для элемента управления. Если необходимо, чтобы элемент управления продолжал поддерживать те же самые функции, что и стили темы по умолчанию, необходимо указать альтернативный стиль с помощью шаблона элемента управления, который реплицирует ту же структуру. Дополнительные сведения см. в разделе [Общие сведения о разработке элементов управления](~/docs/framework/wpf/controls/control-authoring-overview.md).  
  
<a name="dependencyPropertyInfo_OverridesDefaultStyle"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.OverridesDefaultStyleProperty>|  
|Для свойств метаданных задано значение `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OverridesDefaultStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.OverridesDefaultStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OverridesDefaultStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OverridesDefaultStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OverridesDefaultStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.OverridesDefaultStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.OverridesDefaultStyle" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkElement.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает логический родительский элемент этого элемента.</summary>
        <value>Логический родительский объект этого элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Parent%2A> могут быть `null` в случаях, когда был создан экземпляр элемента, но он не присоединен к логическому дереву, который в конечном итоге подключается к корневому элементу уровня страницы или к объекту приложения.  
  
 Обратите внимание, что логический родительский элемент элемента может измениться в зависимости от функциональности приложения, а значение этого свойства не будет отражать это изменение. Как правило, это значение следует получить непосредственно перед тем, как оно понадобится.  
  
 Дополнительные сведения о прохождении логического дерева см. в разделе [деревья в WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md) , а также в сценариях, где используется <xref:System.Windows.FrameworkElement.Parent%2A> в качестве метода обнаружения родительского элемента.  
  
 Подсистема свойств может повторно вычислять все значения свойств элемента при его повторном дочернем элементе, поскольку некоторые свойства наследуют значения через логическое дерево. <xref:System.Windows.FrameworkElement.DataContext%2A>, применяемые к привязкам, также могут изменяться, когда элементы переносятся в родительский элемент.  
  
 Изменение родителя элемента обычно выполняется только посредством манипуляций с коллекциями с помощью выделенных методов Add или Remove или путем установки свойств содержимого элементов.  
  
 Наиболее типичным сценарием использования свойства <xref:System.Windows.FrameworkElement.Parent%2A> является получение ссылки и получение различных значений свойств <xref:System.Windows.FrameworkElement> из родительского элемента. Для шаблонов <xref:System.Windows.FrameworkElement.Parent%2A> шаблона будет `null`. Чтобы перейти к этому моменту и расширить логическое дерево, где фактически применяется шаблон, используйте <xref:System.Windows.FrameworkElement.TemplatedParent%2A>.  
  
 Обратите внимание, что это свойство не сообщает родителей визуального дерева в тех случаях, когда они отличаются от родителей логического дерева. Родители визуального дерева обычно не важны для общих случаев приложений, но могут быть нужными родительскими элементами для определенных вариантов визуального уровня. См. раздел <xref:System.Windows.Media.VisualTreeHelper>.  
  
   
  
## Examples  
 В следующем примере показан код, который проверяет наличие родителя элемента, а затем использует значения свойств из родительского элемента, чтобы задать для него свойства. В этом случае это свойства, влияющие на размер отрисовки.  
  
 [!code-csharp[GeometryDesigner#FEParentProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/GeometryDesigner/CSharp/Window1.xaml.cs#feparentproperty)]
 [!code-vb[GeometryDesigner#FEParentProperty](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GeometryDesigner/visualbasic/window1.xaml.vb#feparentproperty)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.TemplatedParent" />
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="ParentLayoutInvalidated">
      <MemberSignature Language="C#" Value="protected internal virtual void ParentLayoutInvalidated (System.Windows.UIElement child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void ParentLayoutInvalidated(class System.Windows.UIElement child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub ParentLayoutInvalidated (child As UIElement)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void ParentLayoutInvalidated(System::Windows::UIElement ^ child);" />
      <MemberSignature Language="F#" Value="abstract member ParentLayoutInvalidated : System.Windows.UIElement -&gt; unit&#xA;override this.ParentLayoutInvalidated : System.Windows.UIElement -&gt; unit" Usage="frameworkElement.ParentLayoutInvalidated child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="child">Дочерний элемент, сообщающий об изменении.</param>
        <summary>Поддерживает реализации инкрементного макета в специализированных подклассах <see cref="T:System.Windows.FrameworkElement" />. Метод <see cref="M:System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)" /> вызывается, когда дочерний элемент делает недействительным свойство, помеченное в метаданных как влияющее на проходы измерения или компоновки родительского элемента во время структурирования.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается, если этот элемент имеет дочерний элемент, для которого некоторое свойство было недействительным, а свойство было помечено как <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> или <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> в метаданных свойства во время регистрации. Вызов метода уведомляет родительский элемент, какой именно дочерний элемент должен быть повторно измерен, если этот элемент поддерживает частичное (добавочное) обновление макета.  
  
 По умолчанию <xref:System.Windows.FrameworkElement> не поддерживает добавочный макет, а в классе <xref:System.Windows.FrameworkElement> этот метод не имеет реализации по умолчанию. Сценарий, в котором требуется переопределение этого метода, не является распространенным, поскольку он требует изменения поведения системы макета по умолчанию.  
  
 Примером сценария реализации может быть ситуация, когда класс имел ограничения типа для возможных дочерних элементов, которые значительно более ограниченны, чем система макета на уровне платформы WPF. Из-за природы этих пользовательских элементов изменения свойств могут быть намеренно отложены при реализации какого-либо пользовательского поведения макета. Например, переопределения методов Measure/упорядочива, которые пытаются оптимизировать дочерний элемент подготовки к просмотру, могут откладываться для определенных типов изменений, которые обычно приводят к другому проходу макета.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberSignature Language="F#" Value="override this.PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject" Usage="frameworkElement.PredictFocus direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Направление, в котором следует определить перспективное изменение фокуса.</param>
        <summary>Определяет следующий элемент, который получит фокус, относительно данного элемента для указанного направления движения фокуса, но реально фокус не перемещает.</summary>
        <returns>Следующий элемент, на который будет перемещен фокус в случае фактического обхода фокуса. Может возвращать значение <see langword="null" />, если фокус нельзя переместить относительно данного элемента в указанном направлении.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.MoveFocus%2A> — это связанный метод, который фактически перемещает фокус.  
  
   
  
## Examples  
 В следующем примере реализуется обработчик, который обрабатывает несколько возможных входных значений кнопки, каждая из которых представляет собой возможные <xref:System.Windows.Input.FocusNavigationDirection>. Обработчик отслеживает элемент с текущим фокусом клавиатуры и вызывает <xref:System.Windows.FrameworkElement.PredictFocus%2A> для этого элемента и задает соответствующий <xref:System.Windows.Input.FocusNavigationDirection> как инициализацию для предоставленного параметра типа <xref:System.Windows.Input.TraversalRequest>. Вместо перехода к этому элементу по мере <xref:System.Windows.FrameworkElement.MoveFocus%2A>, обработчик изменяет физические размеры целевого назначения прогнозируемого фокуса для целей визуализации.  
  
 [!code-csharp[FocusSample#FEPredictFocus](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSample/CSharp/Window1.xaml.cs#fepredictfocus)]
 [!code-vb[FocusSample#FEPredictFocus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSample/visualbasic/window1.xaml.vb#fepredictfocus)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Одно из следующих направлений, указанное в <see cref="T:System.Windows.Input.TraversalRequest" />: <see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.First" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Last" />. Эти направления недопустимы для метода <see cref="M:System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> (однако допустимы для метода <see cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />).</exception>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="M:System.Windows.UIElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberSignature Language="F#" Value="member this.RegisterName : string * obj -&gt; unit" Usage="frameworkElement.RegisterName (name, scopedElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Имя, используемое для сопоставления указанного имени с объектом.</param>
        <param name="scopedElement">Объект для сопоставления.</param>
        <summary>Предоставляет метод доступа, упрощающий доступ к методу регистрации <see cref="T:System.Windows.NameScope" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод является удобным методом для вызова <xref:System.Windows.NameScope.RegisterName%2A>. Реализация проверяет последовательные родительские элементы до тех пор, пока не найдет соответствующую реализацию <xref:System.Windows.NameScope>, которую можно найти, выполнив поиск элемента, реализующего <xref:System.Windows.Markup.INameScope>. Дополнительные сведения об областях видимости имен см. в разделе [области имен XAML WPF](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
 Чтобы правильно подключить раскадровки анимации для приложений при создании в коде, необходимо вызвать <xref:System.Windows.FrameworkElement.RegisterName%2A>. Это происходит потому, что одно из ключевых свойств раскадровки, <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>, использует поиск имени во время выполнения вместо того, чтобы иметь возможность принимать ссылку на целевой элемент. Это справедливо, даже если этот элемент доступен по ссылке из кода. Дополнительные сведения о том, почему необходимо зарегистрировать имена для целей раскадровки, см. в разделе [Общие сведения о раскадровках](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).  
  
   
  
## Examples  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#NameScopeExample](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/ScopeExample.cs#namescopeexample)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#NameScopeExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/scopeexample.vb#namescopeexample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.NameScope.RegisterName(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void RemoveLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RemoveLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RemoveLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RemoveLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.RemoveLogicalChild : obj -&gt; unit" Usage="frameworkElement.RemoveLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">Подлежащий удалению элемент.</param>
        <summary>Удаляет предоставленный объект из логического дерева этого элемента. <see cref="T:System.Windows.FrameworkElement" /> обновляет затронутые указатели в логическом дереве для синхронизации с данным удалением.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется для реализации коллекций объектов, представляющих логические дочерние элементы элемента. Это можно сделать в методах получения или задания свойств, обработчиков классов `Changed` событий, конструкторов или в самих типах коллекций.  
  
 Для авторов элементов управления логическое дерево на этом уровне не рекомендуется использовать, если только ни одна из моделей содержимого базового класса управления не подходит. Рассмотрите возможность подклассов на уровне <xref:System.Windows.Controls.ContentControl>, <xref:System.Windows.Controls.ItemsControl>и <xref:System.Windows.Controls.HeaderedItemsControl>. Эти классы предоставляют модель содержимого с определенным применением логических дочерних элементов через выделенные API, а также поддержку других функций, которые обычно желательно применять в [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] элементе управления, таком как Стилизация с помощью шаблонов.  
  
   
  
## Examples  
 В следующем примере реализуется свойство `Child` для пользовательского <xref:System.Windows.FrameworkElement>, который выполняет собственную реализацию уровня визуального элемента. Метод задания свойства разрабатывается таким образом, что если значение изменяется, старое значение удаляется из логического дерева, а также из визуальной коллекции, зависящей от класса. Значения кэшируются, а новое значение добавляется как в стандартное логическое дерево уровня платформы WPF, так и в пользовательскую коллекцию пользовательских визуальных элементов.  
  
 [!code-csharp[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/csharp/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/CSharp/ParticleEffectExamples/OverlayRenderDecorator.cs#addremovelogicalchild)]
 [!code-vb[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/visualbasic/particleeffectexamples/overlayrenderdecorator.vb#addremovelogicalchild)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RequestBringIntoView">
      <MemberSignature Language="C#" Value="public event System.Windows.RequestBringIntoViewEventHandler RequestBringIntoView;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RequestBringIntoViewEventHandler RequestBringIntoView" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.RequestBringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RequestBringIntoView As RequestBringIntoViewEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RequestBringIntoViewEventHandler ^ RequestBringIntoView;" />
      <MemberSignature Language="F#" Value="member this.RequestBringIntoView : System.Windows.RequestBringIntoViewEventHandler " Usage="member this.RequestBringIntoView : System.Windows.RequestBringIntoViewEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RequestBringIntoViewEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при вызове метода <see cref="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" /> в данном элементе.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие указывает на родительский <xref:System.Windows.Controls.ScrollViewer> (или производный класс) о том, что элемент, вызывающий событие <xref:System.Windows.FrameworkElement.RequestBringIntoView>, должен быть видимым в прокручиваемой области. Затем <xref:System.Windows.Controls.ScrollViewer> пометит событие <xref:System.Windows.FrameworkElement.RequestBringIntoView> как обработанное с помощью обработки класса события. В общем <xref:System.Windows.FrameworkElement.RequestBringIntoView> данные событий не должны помечаться как обработанные каким-либо классом, который управляет областью прокрутки, или любым обработчиком экземпляра, так как это может помешать целевой цели элемента, вызвавшего <xref:System.Windows.FrameworkElement.BringIntoView%2A>.  
  
<a name="routedEventInfo_RequestBringIntoView"></a>   
## <a name="routed-event-information"></a>Сведения о маршрутизируемом событии  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.RequestBringIntoViewEvent>|  
|Стратегия маршрутизации|Восходящей маршрутизации|  
|делегат|<xref:System.Windows.RequestBringIntoViewEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" />
        <altmember cref="T:System.Windows.Controls.ScrollViewer" />
      </Docs>
    </Member>
    <Member MemberName="RequestBringIntoViewEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent RequestBringIntoViewEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent RequestBringIntoViewEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.RequestBringIntoViewEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly RequestBringIntoViewEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ RequestBringIntoViewEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable RequestBringIntoViewEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.RequestBringIntoViewEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует направленное событие <see cref="E:System.Windows.FrameworkElement.RequestBringIntoView" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.FrameworkElement.Resources" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Markup.IHaveResources.Resources</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает локально определенный словарь ресурсов.</summary>
        <value>Текущий локально определенный словарь ресурсов, где доступ к каждому ресурсу может осуществляться по ключу.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Словари ресурсов, которые могут быть определены полностью или частично в [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)], обычно создаются как элементы свойства и обычно находятся в корневом элементе для любой отдельной страницы или приложения. Размещение словаря ресурсов на этом уровне упрощает поиск из отдельных дочерних элементов на странице (или с любой страницы в случае приложения). В большинстве сценариев приложений рекомендуется, чтобы стили определялись как элементы объекта в словаре ресурсов или были определены как внешние ресурсы, чтобы весь ресурс стиля мог быть самодостаточным (этот подход помогает разделить конструктор ответственность за обязанности разработчиков заключается в разделении физических файлов, которые необходимо изменить.  
  
 Обратите внимание, что это свойство возвращает только словарь ресурсов, объявленный непосредственно внутри этого элемента. Это отличается от фактического процесса уточняющего запроса ресурса, в котором дочерний элемент может получить доступ к любому ресурсу, определенному в каждом родительском элементе, и выполнять рекурсивный поиск.  
  
 На ресурсы также может ссылаться код из коллекции, но следует иметь в виду, что ресурсы, созданные в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], определенно не будут доступны до тех пор, пока не будет вызвано <xref:System.Windows.FrameworkElement.Loaded> элементом, объявляющего словарь. На самом деле, ресурсы анализируются асинхронно, а не даже событие <xref:System.Windows.FrameworkElement.Loaded> является гарантией того, что вы можете ссылаться на [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] определенный ресурс. По этой причине вы обычно должны получить доступ только к [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] определенным ресурсам в рамках кода времени выполнения или с помощью других методов [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], таких как стили или ссылки на расширения ресурсов для значений атрибутов. При доступе к ресурсам с помощью кода он, по сути, эквивалентен ссылке [DynamicResource](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) , созданной из [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 Базовый <xref:System.Windows.ResourceDictionary> поддерживает методы, необходимые для добавления, удаления или запроса ресурсов в коллекции с помощью кода. Свойство <xref:System.Windows.FrameworkElement.Resources%2A> является устанавливаемым для поддержки сценария полной замены коллекции ресурсов элемента на новую или другую <xref:System.Windows.ResourceDictionary>.  
  
 Обратите внимание, что показанный синтаксис [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] не включает элемент для <xref:System.Windows.ResourceDictionary>. Это пример неявного синтаксиса коллекции. тег, представляющий элемент коллекции, можно опустить. Вместо этого задаются элементы, добавляемые в качестве элементов в коллекцию. Дополнительные сведения о неявных коллекциях и [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]см. [в разделе Подробное описание синтаксиса XAML](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md). Один из случаев, когда <xref:System.Windows.ResourceDictionary> по-прежнему указывается явным образом как элемент, если вы представляете Объединенный словарь, в этом случае для этого <xref:System.Windows.ResourceDictionary>обычно не дочерние элементы. Дополнительные сведения см. в разделе [Объединенные словари ресурсов](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).  
  
<a name="xamlPropertyElementUsage_Resources"></a>   
## <a name="xaml-property-element-usage"></a>Использование элемента свойства XAML  
  
```  
<object>  
  <object.Resources>  
    oneOrMoreResourceElements  
  </object.Resources>  
</object>  
```  
  
<a name="xamlValues_Resources"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *онеорморересаурцеелементс*  
 Один или несколько объектных элементов, каждый из которых определяет ресурс. Каждый элемент свойства ресурса в каждой <xref:System.Windows.ResourceDictionary> должен иметь уникальное значение для [директивы x:Key](~/docs/framework/xaml-services/x-key-directive.md), которое служит уникальным ключом при извлечении значений из <xref:System.Windows.ResourceDictionary>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Application.Resources" />
        <related type="Article" href="https://msdn.microsoft.com/library/1985cd45-f197-42d5-b75e-886add64b248">Атрибут x:Key</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBinding">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Присоединяет привязку к этому элементу для указанного свойства зависимостей.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression SetBinding(class System.Windows.DependencyProperty dp, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, path As String) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * string -&gt; System.Windows.Data.BindingExpression" Usage="frameworkElement.SetBinding (dp, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dp">Идентифицирует свойство назначения, к которому следует установить привязку.</param>
        <param name="path">Имя исходного свойства или путь к свойству, используемому для привязки.</param>
        <summary>Прикрепляет привязку к данному элементу на основе указанного имени исходного свойства в виде классификационного пути к источнику данных.</summary>
        <returns>Фиксирует состояния привязки. Это возвращаемое значение можно использовать для проверки ошибок.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод является удобным методом для вызова <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, который передает текущий экземпляр в качестве <xref:System.Windows.DependencyObject>и создает новый <xref:System.Windows.Data.Binding> на основе предоставленного параметра `path`. Эта сигнатура удобнее, если вы устанавливаете простую привязку по умолчанию. Если необходимо указать какие-либо свойства привязки для условий, отличных от Default, или использовать <xref:System.Windows.Data.MultiBinding> или <xref:System.Windows.Data.PriorityBinding>, следует использовать сигнатуру <xref:System.Windows.FrameworkElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29>.  
  
   
  
## Examples  
 В следующем примере задается привязка с использованием определенного пути.  
  
 [!code-csharp[BaseElementsSmorgasbord#SetBindingPath](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#setbindingpath)]
 [!code-vb[BaseElementsSmorgasbord#SetBindingPath](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#setbindingpath)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, binding As BindingBase) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpressionBase ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::Windows::Data::BindingBase ^ binding);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * System.Windows.Data.BindingBase -&gt; System.Windows.Data.BindingExpressionBase" Usage="frameworkElement.SetBinding (dp, binding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="dp">Определяет свойство, которому следует установить привязку.</param>
        <param name="binding">Представляет подробные сведения о привязки данных.</param>
        <summary>Прикрепляет привязку к данному элементу на основе предоставленной привязки объекта.</summary>
        <returns>Фиксирует состояния привязки. Это возвращаемое значение можно использовать для проверки ошибок.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод является удобным методом для вызова <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, который передает текущий экземпляр в качестве <xref:System.Windows.DependencyObject>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetFlowDirection">
      <MemberSignature Language="C#" Value="public static void SetFlowDirection (System.Windows.DependencyObject element, System.Windows.FlowDirection value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetFlowDirection(class System.Windows.DependencyObject element, valuetype System.Windows.FlowDirection value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetFlowDirection(System.Windows.DependencyObject,System.Windows.FlowDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetFlowDirection (element As DependencyObject, value As FlowDirection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetFlowDirection(System::Windows::DependencyObject ^ element, System::Windows::FlowDirection value);" />
      <MemberSignature Language="F#" Value="static member SetFlowDirection : System.Windows.DependencyObject * System.Windows.FlowDirection -&gt; unit" Usage="System.Windows.FrameworkElement.SetFlowDirection (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.FlowDirection" />
      </Parameters>
      <Docs>
        <param name="element">Элемент, указывающий направление потока.</param>
        <param name="value">Значение перечисления, указывающее направление.</param>
        <summary>Задает значение присоединенного свойства <see cref="P:System.Windows.FrameworkElement.FlowDirection" /> указанного элемента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод поддерживает синтаксис присоединенного свойства для свойства <xref:System.Windows.FrameworkElement.FlowDirection%2A>, поэтому дочерние элементы предоставленного <xref:System.Windows.FrameworkElement> указывают направление потока для упорядочения в пределах своего родительского элемента. Чтобы задать значение в текущем <xref:System.Windows.FrameworkElement>, используйте метод доступа Direct [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] <xref:System.Windows.FrameworkElement.FlowDirection%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.FlowDirection" />
      </Docs>
    </Member>
    <Member MemberName="SetResourceReference">
      <MemberSignature Language="C#" Value="public void SetResourceReference (System.Windows.DependencyProperty dp, object name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetResourceReference(class System.Windows.DependencyProperty dp, object name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetResourceReference (dp As DependencyProperty, name As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetResourceReference(System::Windows::DependencyProperty ^ dp, System::Object ^ name);" />
      <MemberSignature Language="F#" Value="member this.SetResourceReference : System.Windows.DependencyProperty * obj -&gt; unit" Usage="frameworkElement.SetResourceReference (dp, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="name" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">Свойство, к которому привязан ресурс.</param>
        <param name="name">Имя ресурса.</param>
        <summary>Выполняет поиск ресурса по указанному имени и устанавливает ссылку на этот ресурс для указанного свойства.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ссылка на ресурс аналогична использованию [расширения разметки DynamicResource](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) в разметке. Ссылка на ресурс создает внутреннее выражение, которое предоставляет значение указанного свойства на отложенной основе времени выполнения. Выражение будет повторно вычислено каждый раз, когда словарь ресурсов указывает измененное значение посредством внутренних событий или когда текущий элемент будет переноситься (родительское изменение изменит путь поиска словаря).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.Application.Resources" />
        <altmember cref="P:System.Windows.FrameworkElement.Resources" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeResources">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeResources" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeResources () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeResources();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeResources : unit -&gt; bool" Usage="frameworkElement.ShouldSerializeResources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает логическое значение, указывающее, следует ли процессам сериализации сериализировать содержимое свойства <see cref="P:System.Windows.FrameworkElement.Resources" />.</summary>
        <returns>Значение <see langword="true" />, если значение свойства <see cref="P:System.Windows.FrameworkElement.Resources" /> подлежит сериализации, в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это приведет к возвращению `true`, если в локальной <xref:System.Windows.FrameworkElement.Resources%2A>есть по крайней мере один ресурс с ключом.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeStyle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeStyle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeStyle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeStyle();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeStyle : unit -&gt; bool" Usage="frameworkElement.ShouldSerializeStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает логическое значение, указывающее, следует ли процессам сериализации сериализировать содержимое свойства <see cref="P:System.Windows.FrameworkElement.Style" />.</summary>
        <returns>Значение <see langword="true" />, если значение свойства <see cref="P:System.Windows.FrameworkElement.Style" /> подлежит сериализации, в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это приведет к возвращению `true`, если <xref:System.Windows.Style> установлен локально.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTriggers">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTriggers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTriggers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeTriggers" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTriggers () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTriggers();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTriggers : unit -&gt; bool" Usage="frameworkElement.ShouldSerializeTriggers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает логическое значение, указывающее, следует ли процессам сериализации сериализировать содержимое свойства <see cref="P:System.Windows.FrameworkElement.Triggers" />.</summary>
        <returns>Значение <see langword="true" />, если значение свойства <see cref="P:System.Windows.FrameworkElement.Triggers" /> подлежит сериализации, в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает `true`, если свойство <xref:System.Windows.FrameworkElement.Triggers%2A> установлено локально.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.SizeChangedEventHandler SizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.SizeChangedEventHandler SizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.SizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SizeChanged As SizeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::SizeChangedEventHandler ^ SizeChanged;" />
      <MemberSignature Language="F#" Value="member this.SizeChanged : System.Windows.SizeChangedEventHandler " Usage="member this.SizeChanged : System.Windows.SizeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SizeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении значения любого из свойств <see cref="P:System.Windows.FrameworkElement.ActualHeight" /> или <see cref="P:System.Windows.FrameworkElement.ActualWidth" /> данного элемента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Прямые перенаправленные события не следуют маршруту, они обрабатываются только в том же элементе, в котором они вызываются. Перенаправленные события поддерживают другое поведение перенаправленного события: они поддерживают коллекцию обработчиков, доступную для доступа, и могут использоваться в качестве <xref:System.Windows.EventTrigger> в стиле.  
  
 Система макета считывает свойства в классе аргумента <xref:System.Windows.SizeChangedEventArgs> этого события, чтобы определить, следует ли учитывать изменения в отчете о размере. Это позволяет системе макета или реализациям макета, относящихся к элементу управления, избежать принудительного изменения макета из-за визуальных незначительных различий между старыми и новыми значениями высоты или ширины. Неощутимые различия могут быть вызваны вычислениями округления или одинаковыми результатами типов данных с плавающей запятой.  
  
<a name="routedEventInfo_SizeChanged"></a>   
## <a name="routed-event-information"></a>Сведения о маршрутизируемом событии  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.SizeChangedEvent>|  
|Стратегия маршрутизации|Direct|  
|делегат|<xref:System.Windows.SizeChangedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Height" />
        <altmember cref="P:System.Windows.FrameworkElement.Width" />
      </Docs>
    </Member>
    <Member MemberName="SizeChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent SizeChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent SizeChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.SizeChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SizeChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ SizeChangedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable SizeChangedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.SizeChangedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует направленное событие <see cref="E:System.Windows.FrameworkElement.SizeChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Идентификаторы перенаправленных событий создаются при их регистрации. Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события. Эти идентификаторы можно использовать для добавления обработчиков классов.  
  
 Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.SourceUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ SourceUpdated;" />
      <MemberSignature Language="F#" Value="member this.SourceUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.SourceUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении исходного значения любого существующего свойства, привязанного к данному элементу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие создает псевдоним для события <xref:System.Windows.Data.Binding.SourceUpdated>, которое вызывается любыми <xref:System.Windows.Data.Binding>, связанными с этим элементом.  
  
<a name="xamlAttributeUsage_SourceUpdated"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object SourceUpdated="eventHandler"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Data.Binding.SourceUpdated" />
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public System.Windows.Style Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ Style { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Style : System.Windows.Style with get, set" Usage="System.Windows.FrameworkElement.Style" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает стиль, который должен использоваться этим элементом при его отрисовке.</summary>
        <value>Примененный стиль не по умолчанию для элемента, если присутствует. В противном случае — значение <see langword="null" />. Значение по умолчанию для созданного по умолчанию <see cref="T:System.Windows.FrameworkElement" /> — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для элементов управления текущий стиль часто предоставляется стилем по умолчанию из элементов управления или из стилей, обычно применяемых к элементам управления этого типа по ресурсам на уровне страницы или приложения (неявный стиль). Это свойство не устанавливает или не возвращает стили по умолчанию (темы), но возвращает либо неявный стиль, либо явный стиль, который обрабатывает элемент. В случае явных или неявных стилей не имеет значения, указан ли стиль в качестве ресурса или определяется локально.  
  
 Установка стилей имеет некоторые ограничения. Можно сбросить все <xref:System.Windows.FrameworkElement.Style%2A> свойства в новое <xref:System.Windows.Style> в любое время, что приведет к перекомпоновке макета. Однако, как только этот стиль будет помещен в элемент, используемый загруженным элементом, <xref:System.Windows.Style> следует считать запечатанным. Попытка изменить любое отдельное свойство используемого стиля (например, что-либо в коллекции <xref:System.Windows.Style.Setters%2A>) приводит к возникновению исключения. Стиль, определенный в разметке, считается используемым, как только он загружается из словаря ресурсов (для ресурсов), или загружается страница, содержащаяся в загрузкой (для встроенных стилей).  
  
 <xref:System.Windows.FrameworkElement.Style%2A> — это свойство зависимостей с особым приоритетом. Локально заданный стиль обычно работает с наивысшим приоритетом в системе свойств. Если на этом этапе <xref:System.Windows.FrameworkElement.Style%2A> имеет значение null, при загрузке системы свойств для неявных стилей в локальных ресурсах или ресурсов приложения, указывающих этот тип, происходит проверка. Если после этого шага стиль по-прежнему имеет значение null, то действующий стиль для целей представления обычно берется из стиля по умолчанию (темы), но стиль по умолчанию не возвращается в значении свойства <xref:System.Windows.FrameworkElement.Style%2A>. См. раздел [Приоритет значения свойства зависимостей](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md) , [а также стилизация и создание шаблонов](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
<a name="xamlAttributeUsage_Style"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object Style="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_Style"></a>   
## <a name="xaml-property-element-usage"></a>Использование элемента свойства XAML  
  
<a name="xamlValues_Style"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *ресаурцеекстенсион*  
 Один из следующих элементов: или. См. раздел [ресурсы XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *стилересаурцекэй*  
 Ключ, определяющий запрашиваемый стиль. Ключ ссылается на существующий ресурс в <xref:System.Windows.ResourceDictionary>.  
  
> [!NOTE]
>  Синтаксис элемента свойства технически возможен, но не рекомендуется для большинства сценариев стиля. См. раздел [встроенные стили и шаблоны](~/docs/framework/wpf/advanced/inline-styles-and-templates.md). Ссылка на привязку с помощью [TemplateBinding](~/docs/framework/wpf/advanced/templatebinding-markup-extension.md) или <xref:System.Windows.Data.Binding> также возможна, но не часто.  
  
<a name="dependencyPropertyInfo_Style"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.StyleProperty>|  
|Для свойств метаданных задано значение `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 В следующем примере определяется стиль в словаре ресурсов.  
  
 [!code-xaml[FEResource#StyleProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty)]  
[!code-xaml[FEResource#StyleProperty2](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty2)]  
[!code-xaml[FEResource#StyleProperty3](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty3)]  
[!code-xaml[FEResource#StyleProperty4](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty StyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty StyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.StyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ StyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable StyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.StyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.Style" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="propertyName">Имя запрошенного внешнего свойства.</param>
        <summary>Описание этого элемента содержится в методе <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" />.</summary>
        <returns>Значение <see langword="true" />, если свойство с именем в параметре <paramref name="propertyName" /> доступно; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Windows.FrameworkElement> приведен к типу интерфейса <xref:System.Windows.Markup.IQueryAmbient>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Windows.FrameworkElement.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение или установка произвольного значения объекта, которое может использоваться для хранения особых сведений об этом элементе.</summary>
        <value>Целевое значение. Это свойство не имеет значения по умолчанию.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство аналогично свойствам тегов в других моделях программирования Майкрософт, таких как Visual Basic для приложений или Windows Forms. <xref:System.Windows.FrameworkElement.Tag%2A> предназначается для предоставления существующего расположения свойств, где можно хранить некоторые базовые пользовательские сведения о любой <xref:System.Windows.FrameworkElement> без необходимости создавать подкласс элемента.  
  
 Поскольку это свойство принимает объект, необходимо использовать использование элемента свойства, чтобы задать свойство <xref:System.Windows.FrameworkElement.Tag%2A> в XAML для любого другого, кроме объекта с известным встроенным преобразовательом типа, например строкой. Объекты, используемые таким способом, обычно не входят в стандартные пространства имен WPF и поэтому могут потребовать сопоставления пространств имен с внешним пространством имен, чтобы они были представлены как элементы XAML. Дополнительные сведения см. в разделе [пространства имен XAML и сопоставление пространств имен для WPF XAML](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md) и [XAML и пользовательские классы для WPF](~/docs/framework/wpf/advanced/xaml-and-custom-classes-for-wpf.md).  
  
<a name="dependencyPropertyInfo_Tag"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.TagProperty>|  
|Для свойств метаданных задано значение `true`|Отсутствуют|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="TagProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TagProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TagProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.TagProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TagProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TagProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TagProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.TagProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.Tag" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.TargetUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TargetUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ TargetUpdated;" />
      <MemberSignature Language="F#" Value="member this.TargetUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.TargetUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении целевого значения для любого свойства, привязанного к этому элементу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие создает псевдоним для события <xref:System.Windows.Data.Binding.TargetUpdated>, которое вызывается любыми <xref:System.Windows.Data.Binding>, связанными с этим элементом. Обычно это означает, что привязка в вопросе является двусторонней, и что привязанное свойство зависимости гарантирует, что предыдущее значение свойства теперь является недопустимым в соответствии с любой схемой проверки или кэширования, которую поддерживает свойство или источник данных.  
  
 Используйте данные события <xref:System.Windows.FrameworkElement.TargetUpdated> события, чтобы определить конкретное свойство, сообщающее об обновлении целевого значения.  
  
<a name="xamlAttributeUsage_TargetUpdated"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object TargetUpdated="eventHandler"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Data.Binding.TargetUpdated" />
      </Docs>
    </Member>
    <Member MemberName="TemplatedParent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject TemplatedParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject TemplatedParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.TemplatedParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TemplatedParent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ TemplatedParent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TemplatedParent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkElement.TemplatedParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает ссылку на родительский объект шаблона данного элемента. Это свойство не актуально, если элемент не был создан с помощью шаблона.</summary>
        <value>Элемент, свойство <see cref="T:System.Windows.FrameworkTemplate" /><see cref="P:System.Windows.FrameworkTemplate.VisualTree" /> которого вызвало создание этого элемента. Это значение часто равно <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.TemplatedParent%2A> часто `null` для объектов, создаваемых в разметке приложения или коде. Это обусловлено тем, что вы создаете эти объекты напрямую, а не через шаблон. Ссылки на объекты, полученные путем прохода по логическому дереву из корневого элемента или по стандартным ссылкам на имена, не поступают из шаблона.  
  
 Случаи, в которых <xref:System.Windows.FrameworkElement.TemplatedParent%2A> могут не `null`, включают такие операции, как проверка попадания, обработка событий для определенных низкоуровневых событий ввода, проход по визуальному дереву с помощью <xref:System.Windows.Media.VisualTreeHelper>или работа с перечислителями, которые могут возвращать элементы, поступилные из шаблонов. Другой случай — если вы явно вызываете <xref:System.Windows.FrameworkTemplate.FindName%2A> для существующего <xref:System.Windows.FrameworkTemplate> и работаете с возвращенным объектом.  
  
 Шаблоны фактически являются общими объектами, где содержимое шаблона создается только один раз. Поэтому при получении ссылки на объект, поступилный из шаблона, может оказаться, что очевидное логическое дерево не достигает корневого элемента страницы. Чтобы подключить такую ссылку на шаблон к логическому дереву страницы, необходимо получить значение <xref:System.Windows.FrameworkElement.TemplatedParent%2A> и продолжить навигацию по этому дереву элементов по своему усмотрению.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTip">
      <MemberSignature Language="C#" Value="public object ToolTip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ToolTip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ToolTip" />
      <MemberSignature Language="VB.NET" Value="Public Property ToolTip As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ToolTip { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ToolTip : obj with get, set" Usage="System.Windows.FrameworkElement.ToolTip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.ToolTip)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает объект подсказки, отображаемый для данного элемента в [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</summary>
        <value>Объект подсказки.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если значение этого свойства имеет тип <xref:System.Windows.Controls.ToolTip>, то это значение является средством-Советом, которое будет использоваться в [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].  Если значение любого другого типа, то оно будет использоваться в качестве *содержимого* для <xref:System.Windows.Controls.ToolTip>, предоставленного (сконструированного) системой. Для получения дополнительной информации см. <xref:System.Windows.Controls.ToolTipService>. Класс службы предоставляет вложенные свойства, которые можно использовать для дальнейшей настройки <xref:System.Windows.Controls.ToolTip>.  
  
<a name="xamlAttributeUsage_ToolTip"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object ToolTip="toolTipContent"/>  
```  
  
<a name="xamlPropertyElementUsage_ToolTip"></a>   
## <a name="xaml-property-element-usage"></a>Использование элемента свойства XAML  
  
```xaml 
<object>  
  <object.ToolTip>  
    <ToolTip .../>  
  </object.ToolTip>  
</object>
```

- или -

```xaml
<object>  
  <object.ToolTip>  
    toolTipObjectContent  
  </object.ToolTip>  
</object>  
```  
  
<a name="xamlValues_ToolTip"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *тултипконтент*  
 Строка, которая преобразуется в отображаемый текст для <xref:System.Windows.FrameworkElement.ToolTip%2A>.  
  
 *тултипобжектконтент*  
 Некоторый объект, указанный в форме объектного элемента, который следует использовать в качестве содержимого для <xref:System.Windows.FrameworkElement>. Обычно это будет <xref:System.Windows.FrameworkElement> или какой-либо другой элемент, создающий композицию макета для <xref:System.Windows.FrameworkElement.ToolTip%2A>, в конечном итоге содержащий текстовое содержимое в композиции. В этом использовании элемент <xref:System.Windows.Controls.ToolTip> создается неявно из проанализированных [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], а содержимое *тултипобжектконтент* задается как свойство <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType>.  
  
 <`ToolTip`.../>  
 См. раздел <xref:System.Windows.Controls.ToolTip>.  
  
<a name="dependencyPropertyInfo_ToolTip"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.ToolTipProperty>|  
|Для свойств метаданных задано значение `true`|Отсутствуют|  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Windows.Controls.ToolTip> в коде, а затем задается свойство <xref:System.Windows.FrameworkElement.ToolTip%2A> элемента управления <xref:System.Windows.Controls.Primitives.StatusBar>.  
  
 [!code-csharp[StatusBar#MakeProgressBar](~/samples/snippets/csharp/VS_Snippets_Wpf/StatusBar/CSharp/Window1.xaml.cs#makeprogressbar)]
 [!code-vb[StatusBar#MakeProgressBar](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StatusBar/visualbasic/window1.xaml.vb#makeprogressbar)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ToolTipClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipClosing As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipClosing;" />
      <MemberSignature Language="F#" Value="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит непосредственно перед закрытием какой-либо подсказки в элементе.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Пометка события <xref:System.Windows.FrameworkElement.ToolTipClosing> как обработанного не отменяет закрытие подсказки. После отображения подсказки закрытие подсказки выполняется только в ответ на взаимодействие пользователя с пользовательским ИНТЕРФЕЙСом.  
  
 Это событие не может быть <xref:System.Windows.EventTrigger> в стиле. Это происходит потому, что поле идентификатора этого события повторно использует реализацию из службы, которая не предоставляет методы добавления или удаления событий для события уровня службы.  
  
<a name="routedEventInfo_ToolTipClosing"></a>   
## <a name="routed-event-information"></a>Сведения о маршрутизируемом событии  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.ToolTipClosingEvent>|  
|Стратегия маршрутизации|Direct|  
|делегат|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
-   Переопределите <xref:System.Windows.FrameworkElement.OnToolTipClosing%2A>, чтобы реализовать обработку класса для этого события в производных классах.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ToolTip" />
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ToolTipClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует направленное событие <see cref="E:System.Windows.FrameworkElement.ToolTipClosing" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Идентификаторы перенаправленных событий создаются при их регистрации. Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события. Эти идентификаторы можно использовать для добавления обработчиков классов.  
  
 Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ToolTipOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipOpening As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipOpening;" />
      <MemberSignature Language="F#" Value="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при открытии любой всплывающей подсказки к элементу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы предотвратить отображение подсказки в пользовательском интерфейсе, обработчик <xref:System.Windows.FrameworkElement.ToolTipOpening> может пометить обрабатываемые данные события <xref:System.Windows.Controls.ToolTipEventArgs>. В противном случае отображается подсказка, в которой используется значение свойства <xref:System.Windows.FrameworkElement.ToolTip%2A> в качестве содержимого подсказки. Другой возможный сценарий заключается в том, что можно написать обработчик, который сбрасывает значение свойства <xref:System.Windows.FrameworkElement.ToolTip%2A> для элемента, который является источником события, непосредственно перед отображением подсказки.  
  
 <xref:System.Windows.FrameworkElement.ToolTipOpening> не будут вызываться, если значение <xref:System.Windows.FrameworkElement.ToolTip%2A> `null` или иным образом не задано. Не устанавливайте <xref:System.Windows.FrameworkElement.ToolTip%2A> `null` во время открытия или открытия всплывающей подсказки; Это не приведет к закрытию подсказки, а вместо этого создаст нежелательный визуальный артефакт в пользовательском интерфейсе.  
  
 Событие <xref:System.Windows.FrameworkElement.ToolTipOpening> не может быть <xref:System.Windows.EventTrigger> в стиле. Это происходит потому, что поле идентификатора этого события повторно использует реализацию из службы, которая не предоставляет методы добавления или удаления событий для события уровня службы.  
  
<a name="routedEventInfo_ToolTipOpening"></a>   
## <a name="routed-event-information"></a>Сведения о маршрутизируемом событии  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.ToolTipOpeningEvent>|  
|Стратегия маршрутизации|Direct|  
|делегат|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
-   Переопределите <xref:System.Windows.FrameworkElement.OnToolTipClosing%2A>, чтобы реализовать обработку класса для этого события в производных классах.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ToolTip" />
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ToolTipOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует направленное событие <see cref="E:System.Windows.FrameworkElement.ToolTipOpening" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Идентификаторы перенаправленных событий создаются при их регистрации. Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события. Эти идентификаторы можно использовать для добавления обработчиков классов.  
  
 Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ToolTipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ToolTipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ToolTipProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ToolTipProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.ToolTip" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Triggers">
      <MemberSignature Language="C#" Value="public System.Windows.TriggerCollection Triggers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.TriggerCollection Triggers" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Triggers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Triggers As TriggerCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TriggerCollection ^ Triggers { System::Windows::TriggerCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Triggers : System.Windows.TriggerCollection" Usage="System.Windows.FrameworkElement.Triggers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.TriggerCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает коллекцию триггеров, установленных непосредственно в этом элементе или в его дочерних элементах.</summary>
        <value>Строго типизированная коллекция объектов <see cref="T:System.Windows.Trigger" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Это свойство можно задать только в [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] с помощью показанного синтаксиса коллекции или путем доступа к объекту коллекции и использования различных методов, таких как Add. Свойство для доступа к объекту коллекции доступно только для чтения, сама коллекция доступна для чтения и записи. Свойство существует только в корневых элементах. попытка найти или задать его в других местах вызовет исключение.  
  
 Это свойство не позволяет проверять триггеры, которые существуют как часть стилей, используемых в этом элементе. Он сообщает только о коллекции триггеров, которые были добавлены в коллекцию в виде разметки или кода. Элементы обычно не имеют существующих элементов по умолчанию (через шаблон для экземпляра); чаще всего триггеры, поступающие из композиции элементов управления, устанавливаются в стилях.  
  
 С точки зрения поведения (и попытки установить, какой из них поступил к объявленной <xref:System.Windows.FrameworkElement.Triggers%2A> коллекции) как условие, вызывающее срабатывание, так и воздействие триггера могут быть на данном элементе или могут находиться в его дочерних элементах в логическом дереве. Обратите внимание, что при использовании событий времени жизни, таких как <xref:System.Windows.FrameworkElement.Loaded> для получения этой коллекции, триггеры дочернего элемента могут быть еще не полностью загружены, а коллекция будет меньше, чем действительно будет во время выполнения.  
  
 Обратите внимание, что коллекция триггеров, установленных в элементе, поддерживает только <xref:System.Windows.EventTrigger>, а не триггеры свойств (<xref:System.Windows.Trigger>). Если требуются триггеры свойств, необходимо поместить их в стиль или шаблон, а затем присвоить этот стиль или шаблон элементу непосредственно через свойство <xref:System.Windows.FrameworkElement.Style%2A> или опосредованно через ссылку на неявный стиль.  
  
<a name="xamlPropertyElementUsage_Triggers"></a>   
## <a name="xaml-property-element-usage"></a>Использование элемента свойства XAML  
  
```  
<object>  
  <object.Triggers>  
    oneOrMoreTriggers  
  </object.Triggers>  
</object>  
```  
  
<a name="xamlValues_Triggers"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *онеорморетригжерс*  
 Один или несколько определенных элементов <xref:System.Windows.EventTrigger>. Каждый такой триггер должен содержать допустимые действия и ссылки раскадровки. Обратите внимание, что эту коллекцию можно установить только в корневом элементе страницы. Дополнительные сведения см. в разделе [Общие сведения о Storyboard](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.EventTrigger" />
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="frameworkElement.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Ключевой идентификатор искомого ресурса.</param>
        <summary>Ищет ресурс с указанным ключом и возвращает его, если он найден.</summary>
        <returns>Найденный ресурс или значение <see langword="null" />, если ресурс с указанным <paramref name="key" /> не обнаружен.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если ресурс не найден в вызывающем элементе, родительский дерево ресурсов ищется вверх по логическому дереву, точно так же, как если бы в дереве был запрошен ресурс по ключу во время выполнения. Метод возвращает `null` только в том случае, если ни один ресурс этого ключа не существовал в дереве ресурсов в соответствии с существующими условиями дерева во время вызова <xref:System.Windows.FrameworkElement.TryFindResource%2A>.  
  
 Обычно возвращаемое значение будет немедленно приведено к типу свойства, которое вы пытались задать с возвращенным значением ресурса.  
  
 Метод <xref:System.Windows.FrameworkElement.FindResource%2A> имеет аналогичное поведение, за исключением того, что он вызывает исключение, если не был возвращен ресурс с указанным ключом.  
  
   
  
## Examples  
 Следующий пример реализуется в виде обработчика кнопки, где нажата кнопка задает для своего фона определенную для ресурса кисть, полученную путем вызова <xref:System.Windows.FrameworkElement.TryFindResource%2A> на самом себе. При этом выполняется обход дерева элементов и поиск ресурса (сам ресурс определяется в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] и не отображается).  
  
 [!code-csharp[BaseElementsSmorgasbord#FETryFindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#fetryfindresource)]
 [!code-vb[BaseElementsSmorgasbord#FETryFindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#fetryfindresource)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Unloaded;" />
      <MemberSignature Language="F#" Value="member this.Unloaded : System.Windows.RoutedEventHandler " Usage="member this.Unloaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при удалении элемента из дерева с загруженными элементами.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Прямые перенаправленные события не следуют маршруту, они обрабатываются только в том же элементе, в котором они вызываются. Перенаправленные события поддерживают другое поведение перенаправленного события: они поддерживают коллекцию обработчиков, доступную для доступа, и могут использоваться в качестве <xref:System.Windows.EventTrigger> в стиле.  
  
 <xref:System.Windows.FrameworkElement.Loaded> и <xref:System.Windows.FrameworkElement.Unloaded> могут быть вызваны в элементах управления в результате изменения пользовательской темы, инициированной пользователем. Изменение темы приводит к недействительности шаблона элемента управления и содержащегося в нем визуального дерева, которое, в свою очередь, приводит к выгрузке и перезагрузке всего элемента управления. Поэтому <xref:System.Windows.FrameworkElement.Unloaded> не может быть предполагается использовать только при переходе от страницы.  
  
 Обратите внимание, что событие <xref:System.Windows.FrameworkElement.Unloaded> не возникает после завершения работы приложения. Завершение работы приложения происходит при возникновении условия, определенного свойством <xref:System.Windows.Application.ShutdownMode%2A>. Если код очистки помещается в обработчик для события <xref:System.Windows.FrameworkElement.Unloaded>, например для <xref:System.Windows.Window> или <xref:System.Windows.Controls.UserControl>, он может не вызываться должным образом.  
  
<a name="routedEventInfo_Unloaded"></a>   
## <a name="routed-event-information"></a>Сведения о маршрутизируемом событии  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.UnloadedEvent>|  
|Стратегия маршрутизации|Direct|  
|делегат|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="UnloadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent UnloadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent UnloadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.UnloadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnloadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ UnloadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnloadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.UnloadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует направленное событие <see cref="E:System.Windows.FrameworkElement.Unloaded" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Идентификаторы перенаправленных событий создаются при их регистрации. Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события. Эти идентификаторы можно использовать для добавления обработчиков классов.  
  
 Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.UnregisterName : string -&gt; unit" Usage="frameworkElement.UnregisterName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Имя пары имя-объект, которую необходимо удалить из текущей области видимости.</param>
        <summary>Упрощает доступ к методу отмены регистрации <see cref="T:System.Windows.NameScope" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Отменить регистрацию имен необходимо только в том случае, если планируется повторно зарегистрировать другой элемент с тем же именем.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.RegisterName(System.String,System.Object)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultStyle">
      <MemberSignature Language="C#" Value="public void UpdateDefaultStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateDefaultStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.UpdateDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateDefaultStyle ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateDefaultStyle();" />
      <MemberSignature Language="F#" Value="member this.UpdateDefaultStyle : unit -&gt; unit" Usage="frameworkElement.UpdateDefaultStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Повторно применяет стиль по умолчанию к текущему объекту <see cref="T:System.Windows.FrameworkElement" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseLayoutRounding">
      <MemberSignature Language="C#" Value="public bool UseLayoutRounding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseLayoutRounding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.UseLayoutRounding" />
      <MemberSignature Language="VB.NET" Value="Public Property UseLayoutRounding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseLayoutRounding { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseLayoutRounding : bool with get, set" Usage="System.Windows.FrameworkElement.UseLayoutRounding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, должно ли применяться округление макета для размера и позиции данного элемента во время структурирования.</summary>
        <value>Значение <see langword="true" />, если округление макета применяется; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если свойство <xref:System.Windows.FrameworkElement.UseLayoutRounding%2A> элемента `true`, все неинтегральные значения пикселей, вычисляемые во время <xref:System.Windows.UIElement.Measure%2A> и <xref:System.Windows.UIElement.Arrange%2A>ных проходов, округляются до целых значений пикселей.  
  
 Это свойство наследуется дочерними элементами.  
  
> [!NOTE]
>  Необходимо задать для <xref:System.Windows.FrameworkElement.UseLayoutRounding%2A> значение `true` корневого элемента. Система макета добавляет дочерние координаты к родительским координатам; Таким образом, если родительские координаты не находятся на границе пикселя, дочерние координаты также не находятся на границе пикселя. Если <xref:System.Windows.FrameworkElement.UseLayoutRounding%2A> нельзя задать в корне, установите <xref:System.Windows.UIElement.SnapsToDevicePixels%2A> для дочернего элемента, чтобы получить нужный результат.  
  
 Рисование объектов на границах пикселей устраняет полупрозрачные края, созданные сглаживанием, когда ребро попадает в середину пикселя устройства. На следующем рисунке показаны выходные данные одной линии с шириной в пикселях, которые попадают в середину пикселя устройства. Линия слева не использует округление макета и сглажена. В строке справа используется округление макета.  
  
 ![Сглаженная&#45;линия по сравнению с однопиксельной линией.](~/add/media/pixelsnaplinecompare.PNG "Сглаженная линия в сравнении с линией из одного пикселя в высоту.")  
  
 При использовании округления макета и <xref:System.Windows.GridUnitType.Star> размера система макета создает небольшие вариации в измерениях столбцов или строк во избежание отрисовки в виде отдельных точек. Например, если сетка имеет суммарную ширину 100 с 3 столбцами <xref:System.Windows.GridUnitType.Star>, то вместо создания трех столбцов, имеющих равную ширину 33,3, система макета создает 2 столбца с шириной в 33 и шириной 34.  
  
> [!NOTE]
>  В .NET 4,6 были внесены изменения в округление макета для сокращения количества экземпляров обрезки в элементах управления с границами. По умолчанию эта функция включена, если требуемая версия .NET Framework — .NET Framework 4,6 или более поздней версии. Приложения, предназначенные для более ранних версий платформы, могут принять участие в новом поведении, добавив следующий параметр в файл App. config: `<runtime><AppContextSwitchOverrides value="Switch.MS.Internal.DoNotApplyLayoutRoundingToMarginsAndBorderThickness=false"/></runtime>` параметр вступает в силу только при выполнении приложения на .NET Framework 4,6.  
  
   
  
## Examples  
 В следующем примере показан результат, когда свойство <xref:System.Windows.FrameworkElement.UseLayoutRounding%2A> имеет одну линию с шириной в пикселях. В строке слева не используется округление макета, а в строке справа используется округление макета. При медленном изменении размера окна можно увидеть разницу, которую делают округление макета.  
  
```xaml  
  
<Page x:Class="LayoutRounding.Lines"  
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"  
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"  
    Title="Lines" Name="linesPage"  
    >  
  <StackPanel Width="150"  Margin="7" Orientation="Horizontal">  
    <!-- Single pixel line with layout rounding turned OFF.-->  
    <Rectangle UseLayoutRounding="False"  
       Width="45.5" Margin="10" Height="1" Fill="Red"/>  
    <!-- Single pixel line with layout rounding turned ON.-->  
    <Rectangle UseLayoutRounding="True"  
      Width="45.5" Margin="10" Height="1" Fill="Red"/>  
  </StackPanel>  
  <!-- Background Grid -->  
  <Page.Background>  
    <DrawingBrush  Viewport="0,0,10,10" ViewportUnits="Absolute" TileMode="Tile">  
      <DrawingBrush.Drawing>  
        <DrawingGroup>  
          <GeometryDrawing Brush="White">  
            <GeometryDrawing.Geometry>  
              <RectangleGeometry Rect="0,0,1,1" />  
            </GeometryDrawing.Geometry>  
          </GeometryDrawing>  
          <GeometryDrawing Geometry="M0,0 L1,0 1,0.1, 0,0.1Z " Brush="#CCCCFF" />  
          <GeometryDrawing Geometry="M0,0 L0,1 0.1,1, 0.1,0Z" Brush="#CCCCFF" />  
        </DrawingGroup>  
      </DrawingBrush.Drawing>  
    </DrawingBrush>  
  </Page.Background>  
</Page>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseLayoutRoundingProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty UseLayoutRoundingProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty UseLayoutRoundingProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.UseLayoutRoundingProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UseLayoutRoundingProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ UseLayoutRoundingProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable UseLayoutRoundingProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.UseLayoutRoundingProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.UseLayoutRounding" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.VerticalAlignment VerticalAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.VerticalAlignment VerticalAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.VerticalAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property VerticalAlignment As VerticalAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::VerticalAlignment VerticalAlignment { System::Windows::VerticalAlignment get(); void set(System::Windows::VerticalAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.VerticalAlignment : System.Windows.VerticalAlignment with get, set" Usage="System.Windows.FrameworkElement.VerticalAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.VerticalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает характеристики выравнивания по вертикали, применяемые к этому элементу при его размещении в родительском элементе, например в панели или элементе управления элементами.</summary>
        <value>Настройка вертикального выравнивания. Значение по умолчанию — <see cref="F:System.Windows.VerticalAlignment.Stretch" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если свойства <xref:System.Windows.FrameworkElement.Height%2A> и <xref:System.Windows.FrameworkElement.Width%2A> явно заданы для элемента, эти измерения имеют приоритет над макетом и отменяют обычные эффекты установки этого свойства в значение <xref:System.Windows.VerticalAlignment.Stretch>.  
  
 <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> — это метод доступа [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] свойства для того, что в действительности является свойством зависимостей. Это конкретное свойство зависимости довольно часто имеет свое видимое значение по умолчанию по-разному в производных классах элементов, особенно элементах управления. Обычно это происходит одним из двух способов: свойство зависимости повторно регистрируется в определенном производном классе, но с разными метаданными для установки значений по умолчанию. или применяется стиль по умолчанию, который устанавливает это значение свойства зависимостей по-разному. Например, очевидным «по умолчанию» <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> для элемента управления <xref:System.Windows.Controls.ComboBoxItem> будет <xref:System.Windows.VerticalAlignment.Center>, несмотря на то, что <xref:System.Windows.Controls.ComboBoxItem> наследует <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> непосредственно от <xref:System.Windows.FrameworkElement>. Это происходит потому, что это значение было сброшено в стиле по умолчанию <xref:System.Windows.Controls.ComboBoxItem>в шаблоне элемента управления стиля.  
  
 <xref:System.Windows.Controls.Canvas> не использует <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> при создании макета, поскольку <xref:System.Windows.Controls.Canvas> основан на абсолютном положении.  
  
 Если наследуется <xref:System.Windows.Controls.ComboBoxItem> или любыми производными классами, <xref:System.Windows.Controls.ComboBoxItem> переопределяет значение по умолчанию этого свойства на <xref:System.Windows.VerticalAlignment.Center>.  
  
<a name="dependencyPropertyInfo_VerticalAlignment"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.VerticalAlignmentProperty>|  
|Для свойств метаданных задано значение `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty VerticalAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty VerticalAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.VerticalAlignmentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VerticalAlignmentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ VerticalAlignmentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable VerticalAlignmentProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.VerticalAlignmentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.VerticalAlignment" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualChildrenCount">
      <MemberSignature Language="C#" Value="protected override int VisualChildrenCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VisualChildrenCount" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.VisualChildrenCount" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property VisualChildrenCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property int VisualChildrenCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VisualChildrenCount : int" Usage="System.Windows.FrameworkElement.VisualChildrenCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает количество визуальных дочерних элементов внутри этого элемента.</summary>
        <value>Количество визуальных дочерних элементов для этого элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> реализация <xref:System.Windows.FrameworkElement.VisualChildrenCount%2A> всегда возвращает либо ноль, либо один. Классы, поддерживающие визуальную дочернюю коллекцию, которая может превышать один, должны переопределять как это свойство, так и <xref:System.Windows.FrameworkElement.GetVisualChild%2A>.  
  
 Это свойство обычно используется для определения верхних границ текущей дочерней коллекции в целях реализации переопределений макета (<xref:System.Windows.FrameworkElement.MeasureOverride%2A>, <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>).  
  
   
  
## Examples  
 В следующем примере показано, как пользовательский декоративный элемент использует значения, объявленные <xref:System.Windows.Media.VisualCollection>, которые он поддерживает для нескольких визуальных дочерних элементов, и передает эти значения с помощью переопределений <xref:System.Windows.FrameworkElement.VisualChildrenCount%2A> и <xref:System.Windows.FrameworkElement.GetVisualChild%2A>.  
  
 [!code-csharp[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverridespre)]
 [!code-vb[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverridespre)]  
[!code-csharp[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverrides)]
[!code-vb[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverrides)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Если ваш класс поддерживает более одного визуального дочернего элемента в коллекции дочерних элементов, Переопределите это свойство, чтобы оно возвращало количество элементов в этой коллекции. Это необходимо сделать, даже если сам объект коллекции возвращает число. Логика макета элемента на уровне платформы WPF предполагает, что все элементы будут возвращать допустимый счетчик через свойство <see cref="P:System.Windows.FrameworkElement.VisualChildrenCount" />.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Width">
      <MemberSignature Language="C#" Value="public double Width { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Width" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Width" />
      <MemberSignature Language="VB.NET" Value="Public Property Width As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Width { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Width : double with get, set" Usage="System.Windows.FrameworkElement.Width" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение или установка ширины элемента.</summary>
        <value>Ширина элемента в [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Значение по умолчанию — <see cref="F:System.Double.NaN" />. Это значение должно быть не меньше 0,0. Сведения о верхней границе см. в разделе "Примечания".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это одно из трех свойств <xref:System.Windows.FrameworkElement>, которые указывают сведения о ширине.  Два других — <xref:System.Windows.FrameworkElement.MinWidth%2A> и <xref:System.Windows.FrameworkElement.MaxWidth%2A>.  Если между этими значениями возникает конфликт, то порядок определения фактической ширины приложения сначала <xref:System.Windows.FrameworkElement.MinWidth%2A> должен учитываться, затем <xref:System.Windows.FrameworkElement.MaxWidth%2A>и, наконец, если все они находятся в пределах границ, <xref:System.Windows.FrameworkElement.Width%2A>.  
  
 Возвращаемое значение этого свойства всегда совпадает с любым значением, заданным для него. В отличие от этого, значение <xref:System.Windows.FrameworkElement.ActualWidth%2A> может отличаться. Возможно, в макете был отклонен предлагаемый размер по какой бы то ни было причине. Кроме того, сама система макета работает асинхронно относительно системного набора свойств <xref:System.Windows.FrameworkElement.Width%2A> и может еще не обработать это конкретное изменение свойства изменения размера.  
  
 Кроме допустимых значений <xref:System.Double>, это свойство также можно <xref:System.Double.NaN?displayProperty=nameWithType>. Таким образом вы указываете поведение автоматического изменения размера. В [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] значение строки "Auto" (без учета регистра) задается для включения автоматического изменения размера. Автоматическое изменение размеров подразумевает, что элемент будет заполнять доступную ширину. Обратите внимание, что определенные элементы управления часто предоставляют значения по умолчанию в своих стилях по умолчанию, которые отключают автоматическое изменение размера, если только они не были специально включены.  
  
 В дополнение к проверке проверки существует недетерминированное верхнее значение, привязанное к <xref:System.Windows.FrameworkElement.Width%2A>, которое применяется системой макета (это очень большое число, которое больше, чем <xref:System.Single.MaxValue?displayProperty=nameWithType>, но меньше <xref:System.Double.MaxValue?displayProperty=nameWithType>). Если превысить эту границу, элемент не будет отображен и исключение не создается. Не устанавливайте для <xref:System.Windows.FrameworkElement.Width%2A> значение, которое значительно превышает максимальный размер любого возможного визуального отображения, или может быть превышена недетерминированная верхняя граница.  
  
<a name="xamlAttributeUsage_Width"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```xaml 
<object Width="double"/>  
```

- или -

```xaml
<object Width ="qualifiedDouble"/>  
```

- или -

```xaml
<object Width ="Auto"/>  
```  

<a name="xamlValues_Width"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *double*  
 <xref:System.Double>  
  
 Строковое представление значения <xref:System.Double>, равное или больше 0,0. Сведения о верхней границе см. в разделе "Примечания". Это значение интерпретируется как измерение [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]. Строки не должны явно включать десятичные разделители. Для экземпляра значение `1` приемлемо.  
  
 *куалифиеддаубле*  
 Значение *типа Double* , как описано выше, за которым следует одна из следующих строк объявления единицы: `px`, `in`, `cm`, `pt`.  
  
 `px` (по умолчанию) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` в дюймах; 1in = = 96 пикселей  
  
 `cm` — сантиметры; 1cm = = (96/2,54) px  
  
 `pt` — это точки; выбрано 1pt = = (96/72) px  
  
 `Auto`  
 Включает режим автоподбора размера. См. заметки.  
  
<a name="dependencyPropertyInfo_Width"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.WidthProperty>|  
|Для свойств метаданных задано значение `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.WidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable WidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.WidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.Width" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
