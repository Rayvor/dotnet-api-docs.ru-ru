<Type Name="CoerceValueCallback" FullName="System.Windows.CoerceValueCallback">
  <Metadata><Meta Name="ms.openlocfilehash" Value="bbc70fa825fb1449321a5aebd633372a4e8df0e5" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70729309" /></Metadata><TypeSignature Language="C#" Value="public delegate object CoerceValueCallback(DependencyObject d, object baseValue);" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed CoerceValueCallback extends System.MulticastDelegate" />
  <TypeSignature Language="DocId" Value="T:System.Windows.CoerceValueCallback" />
  <TypeSignature Language="VB.NET" Value="Public Delegate Function CoerceValueCallback(d As DependencyObject, baseValue As Object) As Object " />
  <TypeSignature Language="C++ CLI" Value="public delegate System::Object ^ CoerceValueCallback(DependencyObject ^ d, System::Object ^ baseValue);" />
  <TypeSignature Language="F#" Value="type CoerceValueCallback = delegate of DependencyObject * obj -&gt; obj" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Delegate</BaseTypeName>
  </Base>
  <Parameters>
    <Parameter Name="d" Type="System.Windows.DependencyObject" />
    <Parameter Name="baseValue" Type="System.Object" />
  </Parameters>
  <ReturnValue>
    <ReturnType>System.Object</ReturnType>
  </ReturnValue>
  <Docs>
    <param name="d"><span data-ttu-id="f25cc-101">Объект, содержащий свойство.</span><span class="sxs-lookup"><span data-stu-id="f25cc-101">The object that the property exists on.</span></span> <span data-ttu-id="f25cc-102">При вызове ответа, система свойств передает это значение.</span><span class="sxs-lookup"><span data-stu-id="f25cc-102">When the callback is invoked, the property system will pass this value.</span></span></param>
    <param name="baseValue"><span data-ttu-id="f25cc-103">Новое значение свойства до применения операции запрета изменения значения.</span><span class="sxs-lookup"><span data-stu-id="f25cc-103">The new value of the property, prior to any coercion attempt.</span></span></param>
    <summary><span data-ttu-id="f25cc-104">Предоставляет шаблон для метода, вызываемого при оценке значения свойства зависимостей и запросе запрета изменения значения.</span><span class="sxs-lookup"><span data-stu-id="f25cc-104">Provides a template for a method that is called whenever a dependency property value is being re-evaluated, or coercion is specifically requested.</span></span></summary>
    <returns><span data-ttu-id="f25cc-105">Запрещенное значение (с соответствующим типом).</span><span class="sxs-lookup"><span data-stu-id="f25cc-105">The coerced value (with appropriate type).</span></span></returns>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f25cc-106">Обратные вызовы, <xref:System.Windows.CoerceValueCallback> основанные на, могут быть назначены свойству зависимостей с помощью нескольких различных методов.</span><span class="sxs-lookup"><span data-stu-id="f25cc-106">Callbacks based on <xref:System.Windows.CoerceValueCallback> can be assigned to a dependency property through several different techniques.</span></span> <span data-ttu-id="f25cc-107">Для каждого из этих методов необходимо сначала создать новый объект метаданных свойства (<xref:System.Windows.PropertyMetadata>или производный класс, такой как <xref:System.Windows.FrameworkPropertyMetadata>).</span><span class="sxs-lookup"><span data-stu-id="f25cc-107">Each of these techniques requires that you first create a new property metadata object (<xref:System.Windows.PropertyMetadata>, or a derived class such as <xref:System.Windows.FrameworkPropertyMetadata>).</span></span> <span data-ttu-id="f25cc-108">Создайте объект метаданных с помощью сигнатуры конструктора, принимающей `coerceValueCallback` параметр, и назначьте этот параметр обработчику обратного вызова.</span><span class="sxs-lookup"><span data-stu-id="f25cc-108">Create the metadata object using a constructor signature that takes the `coerceValueCallback` parameter, and assign that parameter to your callback handler.</span></span> <span data-ttu-id="f25cc-109">Или создайте метаданные по любой сигнатуре и задайте <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> свойство перед размещением используемых метаданных.</span><span class="sxs-lookup"><span data-stu-id="f25cc-109">Or construct the metadata by any signature and set the <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> property prior to putting the metadata in use.</span></span>  
  
 <span data-ttu-id="f25cc-110">При наличии этих метаданных можно:</span><span class="sxs-lookup"><span data-stu-id="f25cc-110">When you have this metadata, you can:</span></span>  
  
-   <span data-ttu-id="f25cc-111">Определите новое свойство зависимостей для нового класса с помощью сигнатуры <xref:System.Windows.DependencyProperty.Register%2A>, предоставляя метаданные в `typeMetadata` качестве значения.</span><span class="sxs-lookup"><span data-stu-id="f25cc-111">Define a new dependency property on a new class, using either signature of  <xref:System.Windows.DependencyProperty.Register%2A>, giving the metadata as the `typeMetadata` value.</span></span>  
  
-   <span data-ttu-id="f25cc-112">Переопределяйте метаданные (Call <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>) для существующего свойства зависимостей при наследовании от класса, владеющего свойством зависимостей.</span><span class="sxs-lookup"><span data-stu-id="f25cc-112">Override the metadata (call <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>) for an existing dependency property, when you derive from the class that owns the dependency property.</span></span>  
  
-   <span data-ttu-id="f25cc-113">Добавление существующего свойства зависимостей в новый <xref:System.Windows.DependencyObject> класс с помощью новых метаданных путем вызова. <xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29></span><span class="sxs-lookup"><span data-stu-id="f25cc-113">Add an existing dependency property to a new <xref:System.Windows.DependencyObject> class, using new metadata, by calling <xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29>.</span></span>  
  
 <span data-ttu-id="f25cc-114">Реализации этого обратного вызова должны проверять значение в `baseValue` и определять его на основе значения или типа, является ли это значение допустимым для дальнейшего приведения.</span><span class="sxs-lookup"><span data-stu-id="f25cc-114">Implementations of this callback should check the value in `baseValue` and determine based on either the value or the type whether this is a value that needs to be further coerced.</span></span>  
  
 <span data-ttu-id="f25cc-115">Для свойства зависимостей вызывается каждый раз, когда система свойств или любые другие вызывающие вызовы вызываются <xref:System.Windows.DependencyObject.CoerceValue%2A> в <xref:System.Windows.DependencyObject> экземпляре `dp`, указывая идентификатор этого свойства в качестве. <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A></span><span class="sxs-lookup"><span data-stu-id="f25cc-115">The <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> for a dependency property is invoked any time that the property system or any other caller calls <xref:System.Windows.DependencyObject.CoerceValue%2A> on a <xref:System.Windows.DependencyObject> instance, specifying that property's identifier as the `dp`.</span></span>  
  
 <span data-ttu-id="f25cc-116">Изменения в значении свойства могут поступать от любого возможного участника в системе свойств.</span><span class="sxs-lookup"><span data-stu-id="f25cc-116">Changes to the property value may have come from any possible participant in the property system.</span></span> <span data-ttu-id="f25cc-117">К ним относятся стили, универсальная недействительность, триггеры, наследование значения свойства и настройка локального значения.</span><span class="sxs-lookup"><span data-stu-id="f25cc-117">This includes styles, generic invalidation, triggers, property value inheritance, and local value setting.</span></span>  
  
 <span data-ttu-id="f25cc-118">Как правило, следует избегать указания более одного <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> значения для любого заданного свойства зависимости (переопределение или добавление с новыми метаданными для свойства зависимостей, которое уже <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>имело значение).</span><span class="sxs-lookup"><span data-stu-id="f25cc-118">Generally you should avoid specifying more than one <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> for any given dependency property (overriding or adding with new metadata for a dependency property that already had a <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>).</span></span> <span data-ttu-id="f25cc-119">Только один из обратных вызовов сможет действовать. Действующий обратный вызов будет применен к наиболее производному классу в наследовании по сравнению <xref:System.Windows.DependencyObject> с вызывающим объектом.</span><span class="sxs-lookup"><span data-stu-id="f25cc-119">Only one of the callbacks will be able to act. The acting callback will be the one that was applied to the most derived class in the inheritance as compared to the <xref:System.Windows.DependencyObject> caller.</span></span> <span data-ttu-id="f25cc-120">Другие обратные вызовы, назначенные метаданным для свойства зависимостей, как оно существовало выше в иерархии владельца, заменяются при переопределении метаданных.</span><span class="sxs-lookup"><span data-stu-id="f25cc-120">Other callbacks as assigned to metadata for the dependency property as it existed higher in the owner hierarchy are replaced when the metadata is overridden.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f25cc-121">Следующий пример включает реализацию этого обратного вызова для приведения сохраненного значения свойства зависимостей на основе других входных данных, например значения другого свойства.</span><span class="sxs-lookup"><span data-stu-id="f25cc-121">The following example includes an implementation of this callback to coerce the stored value of a dependency property based on other inputs, such as another property's value.</span></span> <span data-ttu-id="f25cc-122">В этом случае обратный вызов проверяет, соответствует ли `ShirtType` свойство типу рубашки с кнопками; если это так, он устанавливает начальный цвет по умолчанию `ButtonColor`для, если у типа рубашки нет кнопок `ButtonColor` , он приводит значение вернемся к начальному значению, которое [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] приводит к удалению раскрывающегося списка из действующих вариантов (не показано).</span><span class="sxs-lookup"><span data-stu-id="f25cc-122">In this case, the callback checks to see whether the `ShirtType` property corresponds to a type of shirt that has buttons; if so it establishes a starting default color for the `ButtonColor`, if the shirt type has no buttons, it coerces the `ButtonColor` value back to a starting value, which causes the [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] (not shown) to remove that dropdown from the effective choices.</span></span>  
  
 [!code-csharp[DPCustom#CoerceValueCallback](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCustom/CSharp/default.xaml.cs#coercevaluecallback)]
 [!code-vb[DPCustom#CoerceValueCallback](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCustom/visualbasic/default.xaml.vb#coercevaluecallback)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyProperty" />
  </Docs>
</Type>
