<Type Name="FrameworkContentElement" FullName="System.Windows.FrameworkContentElement">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e4f9b89c1e78b976a214addf4e8d3fdefb105004" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75179815" /></Metadata><TypeSignature Language="C#" Value="public class FrameworkContentElement : System.Windows.ContentElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FrameworkContentElement extends System.Windows.ContentElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement, class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkContentElement" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkContentElement&#xA;Inherits ContentElement&#xA;Implements IFrameworkInputElement, IQueryAmbient, ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkContentElement : System::Windows::ContentElement, System::ComponentModel::ISupportInitialize, System::Windows::IFrameworkInputElement, System::Windows::Markup::IQueryAmbient" />
  <TypeSignature Language="F#" Value="type FrameworkContentElement = class&#xA;    inherit ContentElement&#xA;    interface IFrameworkInputElement&#xA;    interface IInputElement&#xA;    interface ISupportInitialize&#xA;    interface IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.ContentElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IFrameworkInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.RuntimeNameProperty("Name")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;netcore-3.1">
      <AttributeName>System.Windows.Markup.UsableDuringInitialization(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.XmlLangProperty("Language")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><see cref="T:System.Windows.FrameworkContentElement" /> является реализацией уровня платформы WPF и расширением базового класса <see cref="T:System.Windows.ContentElement" />. <see cref="T:System.Windows.FrameworkContentElement" /> добавляет поддержку дополнительных API входных данных (включая подсказки и контекстные меню), раскадровки, контексты данных для привязки, поддержку стилей и вспомогательные API логического дерева.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkContentElement> еще не определяет собственное поведение при отрисовке; экземпляр фактического <xref:System.Windows.FrameworkContentElement> экземпляра класса в коде или разметке возможен, но не отображает ничего в [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] приложении [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]. Логика отрисовки должна предоставляться классами, принимающими <xref:System.Windows.FrameworkContentElement> дочерние элементы в рамках своей модели содержимого, или в <xref:System.Windows.FrameworkContentElement> производных классах.  
  
 <xref:System.Windows.FrameworkContentElement> намеренно параллельно пропараллелить многие из тех же интерфейсов API, что и <xref:System.Windows.FrameworkElement>. Обратите внимание, что некоторые API-интерфейсы, обнаруженные в <xref:System.Windows.FrameworkElement>, не будут иметь <xref:System.Windows.FrameworkContentElement> эквивалент. Некоторые <xref:System.Windows.FrameworkElement> API предназначены для таких функций, как геометрическое представление или макет, которые не относятся к <xref:System.Windows.FrameworkContentElement>.  
  
 Большая часть существующих <xref:System.Windows.FrameworkContentElement> производных классов будет найдена в пространстве имен <xref:System.Windows.Documents>. Многие из этих производных классов реализуют элементы для модели документов нефиксированного формата. Некоторые производные классы, такие как <xref:System.Windows.Documents.Hyperlink>, имеют некоторые функции, схожие с элементами управления, но являются производными от <xref:System.Windows.FrameworkContentElement> таким образом, что элементы, подобные элементам управления, по-прежнему могут участвовать в модели нефиксированного документа.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.FrameworkElement" />
    <altmember cref="T:System.Windows.ContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkContentElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkContentElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.FrameworkContentElement" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void AddLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.AddLogicalChild : obj -&gt; unit" Usage="frameworkContentElement.AddLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">Добавляемый дочерний элемент.</param>
        <summary>Добавляет указанный элемент в качестве дочернего для данного элемента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может вызвать исключение, если вызывается в момент, когда логическое дерево перебирается другим процессом.  
  
 Большинство <xref:System.Windows.FrameworkContentElement> производных классах предоставляют выделенные коллекции, которые отвечают за включение (например, <xref:System.Windows.Documents.Span.Inlines%2A> в классе <xref:System.Windows.Documents.Span>, <xref:System.Windows.Documents.Section.Blocks%2A> в классе <xref:System.Windows.Documents.Section>). Как правило, вы можете избежать каких бы то ни было необходимости манипулировать логическим деревом напрямую, если вместо этого вы наследуете от этих классов. Работа с логическим деревом элементов содержимого — это расширенный сценарий, который может потребовать специализированного средства синтаксического анализа или специализированной <xref:System.Windows.FrameworkElement>, которая выступает в качестве родительского элемента отрисовки (узла содержимого).  
  
 Дополнительные сведения об использовании <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> и <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>см. [в разделе деревья в WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
        <altmember cref="P:System.Windows.FrameworkContentElement.LogicalChildren" />
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="frameworkContentElement.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вызывается перед инициализацией элемента.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Переопределите этот метод, чтобы обеспечить специальную обработку, которая должна произойти перед инициализацией элемента во время загрузки элемента.  
  
Реализация должна вызывать базовую реализацию, так как базовая реализация (по умолчанию) задает некоторые внутренние флаги для наблюдения за инициализацией.  
  
Базовая реализация создает исключение, если <see cref="M:System.Windows.FrameworkContentElement.BeginInit" /> вызывается более одного раза в одном элементе до достижения <see cref="M:System.Windows.FrameworkContentElement.EndInit" />.</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginStoryboard">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Начинает последовательность действий, содержащихся в предоставленной раскадровке.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard -&gt; unit" Usage="frameworkContentElement.BeginStoryboard storyboard" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
      </Parameters>
      <Docs>
        <param name="storyboard">Раскадровка, которая будет начата.</param>
        <summary>Начинает последовательность действий, содержащихся в предоставленной раскадровке.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для сигнатур, которые не используют `isControllable`, параметр или если этот параметр указан `false`, часы временной шкалы, связанные с анимацией, удаляются сразу же после достижения периода заполнения. Поэтому анимация не может быть перезапущена после однократного запуска. Обратите внимание, что для управления анимацией также требуется, чтобы Раскадровка была названа или доступна как экземпляр в коде.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="frameworkContentElement.BeginStoryboard (storyboard, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="storyboard">Раскадровка, которая будет начата.</param>
        <param name="handoffBehavior">Значение перечисления, описывающего поведение в случае, если описанное в раскадровке свойство уже анимировано.</param>
        <summary>Начинает последовательность действий, содержащихся в предоставленной раскадровке, с указанием действий, которые следует выполнить в случае уже анимированного свойства.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для сигнатур, которые не используют `isControllable`, параметр или если этот параметр указан `false`, часы временной шкалы, связанные с анимацией, удаляются сразу же после достижения периода заполнения. Поэтому анимация не может быть перезапущена после однократного запуска. Обратите внимание, что для управления анимацией также требуется, чтобы Раскадровка была названа или доступна как экземпляр в коде.  
  
## <a name="using-the-compose-handoffbehavior"></a>Использование создания HandoffBehavior  
 При применении <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>или <xref:System.Windows.Media.Animation.AnimationClock> к свойству с помощью <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>любые <xref:System.Windows.Media.Animation.Clock> объекты, ранее связанные с этим свойством, продолжают потреблять системные ресурсы. система времени не удаляет часы автоматически.  
  
 Чтобы избежать проблем с производительностью при применении большого количества часов с помощью <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, следует удалить составные часы из анимированного свойства после их завершения. Существует несколько способов удаления часов.  
  
-   Чтобы удалить все часы из свойства, используйте метод <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> или <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> анимированного объекта. Укажите свойство, анимированное в качестве первого параметра, а `null` в качестве второго. Это приведет к удалению всех часов анимации из свойства.  
  
-   Чтобы удалить определенное <xref:System.Windows.Media.Animation.AnimationClock> из списка часов, используйте свойство <xref:System.Windows.Media.Animation.Clock.Controller%2A> <xref:System.Windows.Media.Animation.AnimationClock> для получения <xref:System.Windows.Media.Animation.ClockController>, а затем вызовите метод <xref:System.Windows.Media.Animation.ClockController.Remove%2A> <xref:System.Windows.Media.Animation.ClockController>. Обычно это делается в обработчике событий <xref:System.Windows.Media.Animation.Clock.Completed> для часов. Обратите внимание, что <xref:System.Windows.Media.Animation.ClockController>может управлять только корневыми часами; Свойство <xref:System.Windows.Media.Animation.Clock.Controller%2A> дочернего объекта Clock возвращает `null`. Обратите внимание, что событие <xref:System.Windows.Media.Animation.Clock.Completed> не возникает, если фактическая длительность часов бесконечно.  В этом случае пользователь должен определить, когда следует вызывать <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 В основном это проблема для анимации объектов, имеющих длинное время жизни.  Если объект уничтожается сборщиком мусора, его часы также отключаются и уничтожаются мусором.  
  
 Дополнительные сведения об объектах часов см. в разделе [Общие сведения о анимации и системе управления временем](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="frameworkContentElement.BeginStoryboard (storyboard, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="storyboard">Раскадровка, которая будет начата.</param>
        <param name="handoffBehavior">Значение перечисления, описывающего поведение в случае, если описанное в раскадровке свойство уже анимировано.</param>
        <param name="isControllable">Объявляет, является ли анимация управляемой после запуска (можно ли ее приостановить).</param>
        <summary>Начинает последовательность действий, содержащихся в предоставленной раскадровке, с указанным состоянием управления анимацией после ее запуска.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для сигнатур, которые не используют `isControllable`, параметр или если этот параметр указан `false`, часы временной шкалы, связанные с анимацией, удаляются сразу же после достижения периода заполнения. Поэтому анимация не может быть перезапущена после однократного запуска. Обратите внимание, что для управления анимацией также требуется, чтобы Раскадровка была названа или доступна как экземпляр в коде.  
  
## <a name="using-the-compose-handoffbehavior"></a>Использование создания HandoffBehavior  
 При применении <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>или <xref:System.Windows.Media.Animation.AnimationClock> к свойству с помощью <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>любые <xref:System.Windows.Media.Animation.Clock> объекты, ранее связанные с этим свойством, продолжают потреблять системные ресурсы. система времени не удаляет эти часы автоматически.  
  
 Чтобы избежать проблем с производительностью при применении большого количества часов с помощью <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, следует удалить составные часы из анимированного свойства после их завершения. Существует несколько способов удаления часов.  
  
-   Чтобы удалить все часы из свойства, используйте метод <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> или <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> анимированного объекта. Укажите свойство, анимированное в качестве первого параметра, а `null` в качестве второго. Это приведет к удалению всех часов анимации из свойства.  
  
-   Чтобы удалить определенное <xref:System.Windows.Media.Animation.AnimationClock> из списка часов, используйте свойство <xref:System.Windows.Media.Animation.Clock.Controller%2A> <xref:System.Windows.Media.Animation.AnimationClock> для получения <xref:System.Windows.Media.Animation.ClockController>, а затем вызовите метод <xref:System.Windows.Media.Animation.ClockController.Remove%2A> <xref:System.Windows.Media.Animation.ClockController>. Обычно это делается в обработчике событий <xref:System.Windows.Media.Animation.Clock.Completed> для часов. Обратите внимание, что <xref:System.Windows.Media.Animation.ClockController>может управлять только корневыми часами; Свойство <xref:System.Windows.Media.Animation.Clock.Controller%2A> дочернего объекта Clock возвращает `null`. Обратите внимание, что событие <xref:System.Windows.Media.Animation.Clock.Completed> не возникает, если фактическая длительность часов бесконечно.  В этом случае пользователь должен определить, когда следует вызывать <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 В основном это проблема для анимации объектов, имеющих длинное время жизни.  Если объект уничтожается сборщиком мусора, его часы также отключаются и уничтожаются мусором.  
  
 Дополнительные сведения об объектах часов см. в разделе [Общие сведения о анимации и системе управления временем](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroup">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingGroup BindingGroup { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingGroup BindingGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.BindingGroup" />
      <MemberSignature Language="VB.NET" Value="Public Property BindingGroup As BindingGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingGroup ^ BindingGroup { System::Windows::Data::BindingGroup ^ get(); void set(System::Windows::Data::BindingGroup ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BindingGroup : System.Windows.Data.BindingGroup with get, set" Usage="System.Windows.FrameworkContentElement.BindingGroup" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingGroup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает группу <see cref="T:System.Windows.Data.BindingGroup" />,  которая используется для элемента.</summary>
        <value>Группа <see cref="T:System.Windows.Data.BindingGroup" />, используемая для элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Data.BindingGroup> можно использовать для проверки значений нескольких свойств объекта. Например, предположим, что приложение предлагает пользователю ввести адрес, а затем заполнит объект типа `Address`, содержащий свойства `Street`, `City`, `ZipCode`и `Country`, со значениями, предоставленными пользователем. Приложение содержит панель, содержащую четыре элемента управления <xref:System.Windows.Controls.TextBox>, каждый из которых привязан к одному из свойств объекта. Для проверки объекта `Address` можно использовать <xref:System.Windows.Controls.ValidationRule> в <xref:System.Windows.Data.BindingGroup>. Например, <xref:System.Windows.Controls.ValidationRule> может гарантировать, что почтовый индекс действителен для страны или региона адреса.  
  
 Дочерние элементы наследуют <xref:System.Windows.Data.BindingGroup> от их родительских элементов, как и любые другие наследуемые свойства.  
  
<a name="dependencyPropertyInfo_BindingGroup"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkContentElement.BindingGroupProperty>|  
|Для свойств метаданных задано значение `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroupProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BindingGroupProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BindingGroupProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.BindingGroupProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BindingGroupProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BindingGroupProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BindingGroupProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.BindingGroupProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkContentElement.BindingGroup" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView();" />
      <MemberSignature Language="F#" Value="member this.BringIntoView : unit -&gt; unit" Usage="frameworkContentElement.BringIntoView " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Пытается отобразить данный элемент вместе с содержащимися в нем прокручиваемыми областями.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызывая этот метод, вы фактически вызываете <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> для любой родительской прокручиваемой области, содержащей элемент (родитель может быть, вполне <xref:System.Windows.FrameworkElement>, а не <xref:System.Windows.FrameworkContentElement>). Если этот элемент не содержится в прокручиваемой области, событие по-прежнему вызывается, но не будет действовать.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms752352(v=vs.90)">Как создать ScrollViewer</related>
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ContextMenu ^ ContextMenu { System::Windows::Controls::ContextMenu ^ get(); void set(System::Windows::Controls::ContextMenu ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenu : System.Windows.Controls.ContextMenu with get, set" Usage="System.Windows.FrameworkContentElement.ContextMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает элемент контекстного меню, который должен отображаться каждый раз при запросе контекстного меню через [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] из данного элемента.</summary>
        <value>Контекстное меню, используемое данным элементом.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_ContextMenu"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkContentElement.ContextMenuProperty>|  
|Для свойств метаданных задано значение `true`|Отсутствуют|  
  
   
  
## Examples  
 В следующем примере <xref:System.Windows.Controls.ContextMenu> помещается в <xref:System.Windows.Documents.Paragraph>.  
  
 [!code-xaml[ContentElementsSmorgasbord#ContextMenu](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#contextmenu)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuClosing As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuClosing;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит непосредственно перед закрытием какого-либо контекстного меню в элементе.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы подавить закрытие контекстных меню, обработчики события должны пометить его как обработанное.  
  
 Чтобы использовать это событие в качестве <xref:System.Windows.EventTrigger> в стиле, необходимо указать ссылку на базовый идентификатор события службы:  
  
 [!code-xaml[CorePseudocode#FEContextMenuClosing](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuclosing)]  
  
 (Это необходимо, поскольку реализация события в <xref:System.Windows.FrameworkContentElement>, которая предоставляет базовое событие службы, неправильно сопоставляет идентификатор <xref:System.Windows.FrameworkContentElement.ContextMenuClosing> для использования в триггерах).  
  
<a name="routedEventInfo_ContextMenuClosing"></a>   
## <a name="routed-event-information"></a>Сведения о маршрутизируемом событии  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkContentElement.ContextMenuClosingEvent>|  
|Стратегия маршрутизации|Восходящей маршрутизации|  
|делегат|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
   
  
## Examples  
 В следующем примере реализуется обработчик, который изменяет курсор на именованном регионе `DisplayArea` (не показано). Указания комментариев в <xref:System.Windows.UIElement> использовании, но на самом деле этот пример будет таким же, если `DisplayArea` <xref:System.Windows.FrameworkContentElement>.  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ContextMenuClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> [Обзор маршрутизированных событий](~/docs/framework/wpf/advanced/routed-events-overview.md).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объекты идентификаторов событий создаются при регистрации маршрутизируемых событий (см. <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) и могут использоваться для добавления обработчиков классов (см. <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Объекты идентификаторов содержат идентифицирующее имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод для добавления владельцев для события.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuOpening As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuOpening;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при открытии какого-либо контекстного меню в элементе.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы открыть контекстное меню вручную, обработчики событий должны отметить соответствующее событие как обработанное. В противном случае существующее значение свойства <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> будет использоваться для автоматического открытия контекстного меню. Пометка события как обработанного отменяет действие по умолчанию и может привести к сбросу значения свойства <xref:System.Windows.FrameworkContentElement.ContextMenu%2A>, а затем открыть новый <xref:System.Windows.Controls.ContextMenu>. Однако существует ошибка синхронизации, о которой следует знать. Чтобы полностью заменить контекстное меню с помощью обработчика <xref:System.Windows.FrameworkContentElement.ContextMenuOpening>, исходное контекстное меню не должно быть пустым или иметь значение null. Кроме того, может потребоваться выполнить обработку события, а затем вручную открыть новое контекстное меню. Дополнительные сведения см. в разделе [как обрабатывает событие ContextMenuOpening](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md).  
  
 Чтобы использовать это событие в качестве <xref:System.Windows.EventTrigger> в стиле, необходимо указать ссылку на базовый идентификатор события службы:  
  
 [!code-xaml[CorePseudocode#FEContextMenuOpening](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuopening)]  
  
 (Это необходимо, поскольку реализация события в <xref:System.Windows.FrameworkContentElement>, которая предоставляет базовое событие службы, неправильно сопоставляет идентификатор <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> для использования в триггерах).  
  
<a name="routedEventInfo_ContextMenuOpening"></a>   
## <a name="routed-event-information"></a>Сведения о маршрутизируемом событии  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent>|  
|Стратегия маршрутизации|Восходящей маршрутизации|  
|делегат|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ContextMenuOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> [Обзор маршрутизированных событий](~/docs/framework/wpf/advanced/routed-events-overview.md).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объекты идентификаторов событий создаются при регистрации маршрутизируемых событий (см. <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) и могут использоваться для добавления обработчиков классов (см. <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Объекты идентификаторов содержат идентифицирующее имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод для добавления владельцев для события.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContextMenuProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContextMenuProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContextMenuProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ContextMenuProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkContentElement.ContextMenu" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public System.Windows.Input.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::Cursor ^ Cursor { System::Windows::Input::Cursor ^ get(); void set(System::Windows::Input::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Cursor : System.Windows.Input.Cursor with get, set" Usage="System.Windows.FrameworkContentElement.Cursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение или установка курсора, который отображается при наведении указателя мыши на этот элемент.</summary>
        <value>Отображаемый курсор. Значение по умолчанию определяется как <see langword="null" /> для данного свойства зависимостей. Однако на практике значение по умолчанию во время выполнения зависит от множества факторов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При задании этого свойства в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]процессор [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] использует преобразование типов для класса <xref:System.Windows.Input.Cursor> для вычисления строки. Указанная строка должна иметь значение <xref:System.Windows.Input.CursorType>. Подробные сведения см. в разделе <xref:System.Windows.Input.Cursor>.  
  
 Будет ли курсор, установленный этим свойством, или не будет отображаться, если указатель мыши находится над данным элементом, также зависит от значения свойства <xref:System.Windows.FrameworkContentElement.ForceCursor%2A>. Кроме того, вопросы, связанные с событиями, такие как активное перетаскивание, захват мыши, режимы редактирования текста в элементах управления и т. д., также влияют на курсор с более высоким приоритетом, чем значение, указанное в этом свойстве.  
  
 Чтобы отменить поведение установки этого свойства в конечном итоге, задайте для него значение `null`.  
  
 `null` по умолчанию действительно означает, что определение практического значения курсора будет отложено и должно быть получено из других мест. Если в списке нет программных значений из какого-либо источника, то курсором по умолчанию для [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] приложения будет стрелка.  
  
 Каждое перемещение указателя мыши на [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] приложение вызывает событие <xref:System.Windows.ContentElement.QueryCursor>. Событие пузырьковое, а любой элемент маршрута имеет возможность управлять событием и устанавливать значение курсора с помощью аргументов этого события. В таком случае тот факт, что событие обрабатывается и имеет измененное значение в аргументах, имеет приоритет над значением свойства <xref:System.Windows.FrameworkContentElement.Cursor%2A> на любом уровне, если не задано значение <xref:System.Windows.FrameworkContentElement.ForceCursor%2A>.  
  
 Если не создается настраиваемый курсор, обычно этому свойству присваивается статическое значение свойства <xref:System.Windows.Input.Cursors> класса.  
  
 Установка для <xref:System.Windows.Input.Cursor> пользовательского значения не включена при частичном доверии. Дополнительные сведения о пользовательских курсорах см. в разделе [Общие сведения о входных данных](~/docs/framework/wpf/advanced/input-overview.md).  
  
<a name="dependencyPropertyInfo_Cursor"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkContentElement.CursorProperty>|  
|Для свойств метаданных задано значение `true`|Отсутствуют|  
  
   
  
## Examples  
 В следующем примере для курсора задается пользовательское значение.  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryCursor" />
        <altmember cref="P:System.Windows.FrameworkContentElement.ForceCursor" />
        <altmember cref="P:System.Windows.Input.Mouse.OverrideCursor" />
      </Docs>
    </Member>
    <Member MemberName="CursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.CursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.CursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkContentElement.Cursor" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContext">
      <MemberSignature Language="C#" Value="public object DataContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DataContext" />
      <MemberSignature Language="VB.NET" Value="Public Property DataContext As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataContext { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataContext : obj with get, set" Usage="System.Windows.FrameworkContentElement.DataContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает контекст данных для элемента, участвующего в привязке данных.</summary>
        <value>Объект, используемый в качестве контекста данных.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *Контекст данных* — это концепция, которая позволяет элементам наследовать от своих родительских элементов сведения об источнике привязки, используемом для привязки, а также о других характеристиках привязки, например пути.  
  
 Контекст данных можно задать непосредственно для объекта [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] с привязками, оценивающих свойства этого объекта. Кроме того, можно задать для контекста данных объект <xref:System.Windows.Data.DataSourceProvider>.  
  
 Это свойство зависимости наследует значения свойств. Если имеются дочерние элементы, не имеющие других значений для <xref:System.Windows.FrameworkContentElement.DataContext%2A>, установленных с помощью локальных значений или стилей, система свойств установит значение, которое будет <xref:System.Windows.FrameworkContentElement.DataContext%2A>ным значением ближайшего родительского элемента, которому назначено это значение.  
  
 Кроме того, можно использовать одно из следующих свойств класса <xref:System.Windows.Data.Binding>, чтобы явно указать источник привязки: <xref:System.Windows.Data.Binding.ElementName%2A>, <xref:System.Windows.Data.Binding.Source%2A>или <xref:System.Windows.Data.Binding.RelativeSource%2A>. Дополнительные сведения см. в разделе [инструкции. Указание источника привязки](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md).  
  
 В [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]<xref:System.Windows.FrameworkContentElement.DataContext%2A> чаще всего задается как объявление <xref:System.Windows.Data.Binding>. Можно использовать либо синтаксис элемента свойства, либо синтаксис атрибутов. Синтаксис атрибута показан в примере на этой странице. Можно также задать <xref:System.Windows.FrameworkContentElement.DataContext%2A> в коде.  
  
<a name="xamlPropertyElementUsage_DataContext"></a>   
## <a name="xaml-property-element-usage"></a>Использование элемента свойства XAML  
  
```  
<object>  
  <object.DataContext>  
    <dataContextObject />  
  </object.DataContext>  
</object>  
```  
  
<a name="xamlAttributeUsage_DataContext"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```xaml
<object DataContext="bindingUsage"/>  
```

-или-

```xaml
<object DataContext="{resourceExtension contextResourceKey}"/>  
```

<a name="xamlValues_DataContext"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *датаконтекстобжект*  
 Непосредственно внедренный объект, который служит контекстом данных для любых привязок в родительском элементе. Как правило, этот объект является <xref:System.Windows.Data.Binding> или другим <xref:System.Windows.Data.BindingBase> подклассом. Кроме того, здесь можно разместить необработанные данные любого типа объекта [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)], предназначенного для привязки, с фактическими привязками, определенными далее.  
  
 *биндингусаже*  
 Использование привязки, результатом которого является соответствующий контекст данных. Дополнительные сведения см. в разделе [Привязка расширения разметки](~/docs/framework/wpf/advanced/binding-markup-extension.md).  
  
 *ресаурцеекстенсион*  
 Один из следующих: `StaticResource`или `DynamicResource`. Это использование используется при ссылке на необработанные данные, определенные как объект в ресурсах. См. раздел [ресурсы XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *контекстресаурцекэй*  
 Идентификатор ключа для объекта, запрашиваемого в <xref:System.Windows.ResourceDictionary>.  
  
<a name="dependencyPropertyInfo_DataContext"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkContentElement.DataContextProperty>|  
|Для свойств метаданных задано значение `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 В следующем примере задается привязка для элемента <xref:System.Windows.Documents.Paragraph>, создавая новый пользовательский объект данных, устанавливая этот объект как <xref:System.Windows.FrameworkContentElement.DataContext%2A>и настроив путь привязки на свойство в нем.  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler DataContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.DataContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataContextChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ DataContextChanged;" />
      <MemberSignature Language="F#" Value="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении контекста данных настоящего элемента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Описание контекстов данных и привязки данных см. в разделе [Общие сведения о привязке данных](~/docs/framework/wpf/data/data-binding-overview.md).  
  
> [!IMPORTANT]
>  При изменении <xref:System.Windows.FrameworkContentElement.DataContext%2A> элемента все свойства, привязанные к данным этого элемента, потенциально затрагиваются. Это относится к любым элементам, которые являются потомками текущего элемента, которые наследуют контекст данных, а также от текущего элемента. Все такие привязки повторно преобразуют новый <xref:System.Windows.FrameworkContentElement.DataContext%2A> в соответствии с новым значением в привязках. Не гарантируется порядок этих изменений относительно вызова события <xref:System.Windows.FrameworkContentElement.DataContextChanged>.  Изменения могут происходить до события, после события или в любом сочетании.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DataContextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DataContextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DataContextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DataContextProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ DataContextProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DataContextProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.DataContextProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkContentElement.DataContext" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKey">
      <MemberSignature Language="C#" Value="protected internal object DefaultStyleKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property DefaultStyleKey As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Object ^ DefaultStyleKey { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultStyleKey : obj with get, set" Usage="System.Windows.FrameworkContentElement.DefaultStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает ключ, используемый для поиска шаблона стиля данного элемента управления в темах.</summary>
        <value>Ключ стиля. Для корректной работы этого значения в ходе поиска тематического стиля ожидается, что оно принадлежит к типу <see cref="T:System.Type" /> элемента, к которому применяется стиль. <see langword="null" /> является допустимым значением в определенном случае.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство обычно не устанавливается через какой-либо из его прямых методов задания. Вместо этого переопределяются метаданные этого свойства зависимостей, относящиеся к типу, при каждом создании нового подкласса. При создании подклассов вызовите метод <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> для идентификатора <xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty> в статическом конструкторе подкласса элемента управления.  
  
 Например, встроенный класс, такой как <xref:System.Windows.Documents.Bold>, на самом деле имеет очень малую реализацию, помимо перекрытия метаданных <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> в статическом конструкторе, и предоставляет несколько конструкторов экземпляров. Тот факт, что элементы, заключенные в теге <xref:System.Windows.Documents.Bold>, воздействуют на <xref:System.Windows.Documents.TextElement.FontWeight%2A> свойство <xref:System.Windows.FontWeights.Bold%2A> реализовано в стиле темы, на который была ссылка, путем установки значения по умолчанию <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> на `typeof(Bold)`.  
  
 Если необходимо, чтобы элемент или элемент управления намеренно не использовал стили темы, установите для свойства <xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A> значение `true`.  
  
<a name="dependencyPropertyInfo_DefaultStyleKey"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty>|  
|Для свойств метаданных задано значение `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKeyProperty">
      <MemberSignature Language="C#" Value="protected internal static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly static initonly class System.Windows.DependencyProperty DefaultStyleKeyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared ReadOnly DefaultStyleKeyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="protected public: static initonly System::Windows::DependencyProperty ^ DefaultStyleKeyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultStyleKeyProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.DefaultStyleKeyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="frameworkContentElement.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вызывается сразу после инициализации элемента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализуйте этот метод для предоставления специальной обработки, которая должна выполняться при инициализации элемента во время загрузки элемента.  
  
 Реализация должна вызывать базовую реализацию, так как базовая реализация (по умолчанию) задает некоторые внутренние флаги для наблюдения за инициализацией.  
  
 Если ранее был вызван <xref:System.Windows.FrameworkContentElement.BeginInit%2A>, базовая реализация вызовет событие <xref:System.Windows.FrameworkContentElement.Initialized>. В противном случае, если <xref:System.Windows.FrameworkContentElement.BeginInit%2A> не был вызван или не удалось определить, было ли вызвано <xref:System.Windows.FrameworkContentElement.BeginInit%2A>, событие не будет вызвано.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.FindName : string -&gt; obj" Usage="frameworkContentElement.FindName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Имя искомого элемента.</param>
        <summary>Находит элемент по указанному имени идентификатора.</summary>
        <returns>Запрошенный элемент. Может быть равен <see langword="null" />, если соответствующий элемент не найден.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если этот элемент содержит дочерние элементы, все эти дочерние элементы ищутся рекурсивно для запрошенного именованного элемента.  
  
   
  
## Examples  
 В следующем примере задается свойство элемента, найденного по имени в <xref:System.Windows.Documents.FlowDocument> на странице, на которую указывает ссылка.  
  
 [!code-csharp[ContentElementsSmorgasbord#FindName](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findname)]
 [!code-vb[ContentElementsSmorgasbord#FindName](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findname)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="frameworkContentElement.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Идентификатор ключа искомого ресурса.</param>
        <summary>Ищет ресурс с указанным ключом и вызывает исключение, если запрошенный ресурс не удается найти.</summary>
        <returns>Найденный ресурс или <see langword="null" />, если соответствующий ресурс не найден (но при <see langword="null" /> также будет вызвано исключение).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  При вызове этого метода для ключа, который не удается найти, создается исключение. Если вы не хотите выполнять обработку исключений в этом случае, следует вызвать <xref:System.Windows.FrameworkContentElement.TryFindResource%2A>. <xref:System.Windows.FrameworkContentElement.TryFindResource%2A> возвращает `null`, если ресурс не найден, и не создает исключение.  
  
 Если ресурс не найден в вызывающем элементе, то в родительском дереве выполняется поиск по логическому дереву, точно так же, как если бы в нем был запрошен ресурс по ключу во время выполнения.  
  
 Обычно возвращаемое значение будет немедленно приведено к типу свойства, которое вы пытались задать с возвращенным значением ресурса.  
  
   
  
## Examples  
 В следующем примере выполняется поиск ресурса, определенного в разметке, и применение его к определенному свойству элемента в ответ на перенаправленное событие.  
  
 [!code-csharp[ContentElementsSmorgasbord#FindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findresource)]
 [!code-vb[ContentElementsSmorgasbord#FindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findresource)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">Запрошенный ключ ресурса не найден.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceKey" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Style FocusVisualStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style FocusVisualStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.FocusVisualStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FocusVisualStyle As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ FocusVisualStyle { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FocusVisualStyle : System.Windows.Style with get, set" Usage="System.Windows.FrameworkContentElement.FocusVisualStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает объект, позволяющий настройку внешнего вида, эффектов или других характеристик стиля, применяемых к данному элементу, когда он получает фокус клавиатуры.</summary>
        <value>Требуемый стиль для применения при получении фокуса. Значением по умолчанию, как объявлено в свойстве зависимостей, является пустой статический объект <see cref="T:System.Windows.Style" />. Тем не менее, действительным значением во время выполнения часто (но не всегда) является стиль, представленный поддержкой тем для элементов управления.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При задании этого свойства в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]стили практически всегда определяются как ресурс, а не как встроенные в элемент, и этот ресурс обычно упоминается как <xref:System.Windows.StaticResourceExtension>.  
  
 Обратите внимание, что это свойство влияет на визуальный внешний вид, но не сообщает о них в метаданных. Это связано с тем, что изменение внешнего вида осуществляется на основе событий и может применяться не всегда, и поэтому не должно сообщать о каких-либо визуальных и макетных сведениях в метаданных.  
  
 По сути, визуальное поведение фокуса, применяемого к элементу управления, должно быть согласовано от элемента к элементу. Наиболее разумным способом принудительного применения согласованности является изменение визуального стиля фокуса при составлении целой темы. Задание этого свойства для отдельных стилей, а не как части темы, не является предполагаемым использованием этого свойства, так как оно может привести к путанице в работе пользователя с фокусом клавиатуры. Если вы планируете поведение для конкретного элемента, которое намеренно не согласовано в теме, гораздо лучшим подходом является использование триггеров в стилях для отдельных свойств состояния ввода, таких как <xref:System.Windows.UIElement.IsFocused%2A> или <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>, а также для того, чтобы сделать это не так, чтобы визуально не влияло на любой существующий визуальный стиль фокуса. Дополнительные сведения о намерении разработки <xref:System.Windows.FrameworkContentElement.FocusVisualStyle%2A> и альтернативных свойствах фокуса см. [в разделе Стилизация фокуса в элементах управления и FocusVisualStyle](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md).  
  
<a name="xamlAttributeUsage_FocusVisualStyle"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object FocusVisualStyle="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_FocusVisualStyle"></a>   
## <a name="xaml-property-element-usage"></a>Использование элемента свойства XAML  
  
<a name="xamlValues_FocusVisualStyle"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *ресаурцеекстенсион*  
 Один из следующих элементов: или. См. раздел [ресурсы XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *стилересаурцекэй*  
 Ключ, определяющий запрашиваемый стиль. Ключ ссылается на существующий ресурс в <xref:System.Windows.ResourceDictionary>.  
  
> [!NOTE]
>  Синтаксис элемента свойства технически возможен, но не рекомендуется. См. раздел [встроенные стили и шаблоны](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).  Ссылка на привязку с помощью [TemplateBinding](~/docs/framework/wpf/advanced/templatebinding-markup-extension.md) или <xref:System.Windows.Data.Binding> также возможна, но не часто.  
  
<a name="dependencyPropertyInfo_FocusVisualStyle"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkContentElement.FocusVisualStyleProperty>|  
|Для свойств метаданных задано значение `true`|Отсутствуют|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusVisualStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.FocusVisualStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusVisualStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusVisualStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FocusVisualStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.FocusVisualStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkContentElement.FocusVisualStyle" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursor">
      <MemberSignature Language="C#" Value="public bool ForceCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ForceCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ForceCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property ForceCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ForceCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ForceCursor : bool with get, set" Usage="System.Windows.FrameworkContentElement.ForceCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, должен ли данный <see cref="T:System.Windows.FrameworkContentElement" /> заставлять [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] визуализировать курсор, как объявлено свойством <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> данного экземпляра.</summary>
        <value><see langword="true" /> означает принудительное использование настройки данного экземпляра для презентации курсора, когда он находится над данным элементом (включая все дочерние); в противном случае — <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Установка этого свойства в `true` переопределит настройки курсора, установленные дочерними элементами. Это может показаться непонятным для пользователя [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)], особенно если дочерние элементы пытаются указать курсоры. Параметр <xref:System.Windows.FrameworkElement.ForceCursor%2A> более подходит в сценариях управления подклассами или компоновки.  
  
<a name="dependencyPropertyInfo_ForceCursor"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkContentElement.ForceCursorProperty>|  
|Для свойств метаданных задано значение `true`|Отсутствуют|  
  
   
  
## Examples  
 В следующем примере выполняется принудительное выполнение курсора над элементом.  
  
 [!code-xaml[ForceCursor#ForceCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/ForceCursor/CS/default.xaml#forcecursor)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForceCursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForceCursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ForceCursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForceCursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForceCursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ForceCursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ForceCursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkContentElement.ForceCursor" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBindingExpression (dp As DependencyProperty) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ GetBindingExpression(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetBindingExpression : System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingExpression" Usage="frameworkContentElement.GetBindingExpression dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Целевое <see cref="T:System.Windows.DependencyProperty" />, из которого следует получить привязку.</param>
        <summary>Возвращает <see cref="T:System.Windows.Data.BindingExpression" /> для привязки указанного свойства.</summary>
        <returns>Возвращает <see cref="T:System.Windows.Data.BindingExpression" />, если цель привязана к данным; в противном случае — <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере выполняется получение привязки путем запроса свойства.  
  
 [!code-csharp[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#getbindingexpression)]
 [!code-vb[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#getbindingexpression)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal override System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberSignature Language="F#" Value="override this.GetUIParentCore : unit -&gt; System.Windows.DependencyObject" Usage="frameworkContentElement.GetUIParentCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает альтернативный логический родительский объект для этого элемента при отсутствии визуального родительского объекта. В данном случае родительский объект <see cref="T:System.Windows.FrameworkContentElement" /> всегда имеет то же значение, что и свойство <see cref="P:System.Windows.FrameworkContentElement.Parent" />.</summary>
        <returns>Возвращает нечто, отличное от <see langword="null" />, каждый раз, когда реализация уровня инфраструктуры WPF этого метода имеет подключение без визуального родительского объекта.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию возвращает ожидаемый один визуальный элемент. Пользовательские реализации могут возвращать альтернативные родительские связи.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит во время инициализации данного <see cref="T:System.Windows.FrameworkContentElement" />. Это совпадает со случаями, когда значение свойства <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> меняется с <see langword="false" /> (или неопределенного) на <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие будет вызвано при вызове методов <xref:System.Windows.FrameworkContentElement.EndInit%2A> или <xref:System.Windows.FrameworkContentElement.OnInitialized%2A>. Вызовы этих методов могут быть выполнены с помощью преднамеренного кода или процесса загрузки [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScope">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputScope InputScope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputScope InputScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.InputScope" />
      <MemberSignature Language="VB.NET" Value="Public Property InputScope As InputScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputScope ^ InputScope { System::Windows::Input::InputScope ^ get(); void set(System::Windows::Input::InputScope ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InputScope : System.Windows.Input.InputScope with get, set" Usage="System.Windows.FrameworkContentElement.InputScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает контекст для входных данных, используемых этим элементом <see cref="T:System.Windows.FrameworkContentElement" />.</summary>
        <value>Область ввода, которая изменяет интерпретацию ввода с помощью альтернативных методов. Значение по умолчанию — <see langword="null" /> (что приводит к обработке команд по умолчанию).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство зависимости наследует значения свойств. Если имеются дочерние элементы, не имеющие других значений для <xref:System.Windows.FrameworkElement.InputScope%2A>, установленных с помощью локальных значений или стилей, система свойств установит значение, которое будет <xref:System.Windows.FrameworkElement.InputScope%2A>ным значением ближайшего родительского элемента, которому назначено это значение.  
  
 Несмотря на то что [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] синтаксис указан и является синтаксически разрешенным, установка этого свойства в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] не является распространенной.  
  
<a name="dependencyPropertyInfo_InputScope"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkContentElement.InputScopeProperty>|  
|Для свойств метаданных задано значение `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty InputScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty InputScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.InputScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InputScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ InputScopeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable InputScopeProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.InputScopeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkContentElement.InputScope" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Windows.FrameworkContentElement.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, был ли инициализирован данный элемент, либо путем загрузки в качестве [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)], либо путем явного вызова своего метода <see cref="M:System.Windows.FrameworkContentElement.EndInit" />.</summary>
        <value><see langword="true" />, если элемент инициализирован путем вышеупомянутой загрузки или вызовов метода; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство также может быть `true`, если этот элемент был перемещен в дереве элементов таким образом, что он имеет новый родительский элемент и поэтому снова перезагружен.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoaded { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoaded : bool" Usage="System.Windows.FrameworkContentElement.IsLoaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, загружен ли данный элемент для презентации.</summary>
        <value><see langword="true" />, если текущий элемент прикреплен к дереву элементов и визуализирован; <see langword="false" /> — если элемент никогда не был присоединен к загруженному дереву элементов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Из вновь созданного экземпляра это свойство начинается `false`и остается `true` после того, как оно установлено в `true`, даже если оно впоследствии удаляется кодом.  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Windows.FrameworkContentElement.IsLoaded%2A> в качестве условной проверки, чтобы убедиться, что функция `displayData` (не показана) будет иметь допустимые элементы, загруженные на страницу для работы в, как часть обработчика по запросу. Эта же логика выполняется в качестве обработчика событий для <xref:System.Windows.FrameworkContentElement.Loaded>.  
  
 [!code-csharp[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#isloaded)]
 [!code-vb[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#isloaded)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkContentElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Language">
      <MemberSignature Language="C#" Value="public System.Windows.Markup.XmlLanguage Language { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Markup.XmlLanguage Language" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Language" />
      <MemberSignature Language="VB.NET" Value="Public Property Language As XmlLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Markup::XmlLanguage ^ Language { System::Windows::Markup::XmlLanguage ^ get(); void set(System::Windows::Markup::XmlLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Language : System.Windows.Markup.XmlLanguage with get, set" Usage="System.Windows.FrameworkContentElement.Language" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.XmlLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает сведения о языке локализации и глобализации, который применяется к отдельному элементу.</summary>
        <value>Сведения о языке и региональных параметрах для этого элемента. Значение по умолчанию — экземпляр <see cref="T:System.Windows.Markup.XmlLanguage" /> со значением <see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" />, равным строке "гu-RU".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Форматы строк соответствуют стандарту RFC 3066. Например, Английский (США) — EN-US. Дополнительные сведения о значениях и формате см. в разделе <xref:System.Windows.Markup.XmlLanguage>.  
  
 Это свойство зависимости наследует значения свойств. Если имеются дочерние элементы, не имеющие других значений для <xref:System.Windows.FrameworkElement.Language%2A>, установленных с помощью локальных значений или стилей, система свойств установит значение, которое будет <xref:System.Windows.FrameworkElement.Language%2A>ным значением ближайшего родительского элемента, которому назначено это значение.  
  
<a name="dependencyPropertyInfo_CultureInfo"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkContentElement.LanguageProperty>|  
|Для свойств метаданных задано значение `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LanguageProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LanguageProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LanguageProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LanguageProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LanguageProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LanguageProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.LanguageProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkContentElement.Language" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Loaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Loaded;" />
      <MemberSignature Language="F#" Value="member this.Loaded : System.Windows.RoutedEventHandler " Usage="member this.Loaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, если элемент размещен, отрисован и готов к взаимодействию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Прямые перенаправленные события не следуют маршруту, они обрабатываются только в том же элементе, в котором они вызываются. Перенаправленные события поддерживают другое поведение перенаправленного события: они поддерживают коллекцию обработчиков, доступную для доступа, и могут использоваться в качестве <xref:System.Windows.EventTrigger> в стиле.  
  
<a name="routedEventInfo_Loaded"></a>   
## <a name="routed-event-information"></a>Сведения о маршрутизируемом событии  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkContentElement.LoadedEvent>|  
|Стратегия маршрутизации|Direct|  
|делегат|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LoadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LoadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LoadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LoadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LoadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LoadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.LoadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует <see cref="E:System.Windows.FrameworkContentElement.Loaded" /> [Обзор маршрутизированных событий](~/docs/framework/wpf/advanced/routed-events-overview.md).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объекты идентификаторов событий создаются при регистрации маршрутизируемых событий (см. <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) и могут использоваться для добавления обработчиков классов (см. <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Объекты идентификаторов содержат идентифицирующее имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод для добавления владельцев для события.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.FrameworkContentElement.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает перечислитель для логических дочерних элементов данного элемента.</summary>
        <value>Перечислитель для логических дочерних элементов данного элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения об использовании <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> и <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>см. в разделе [деревья в WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="override this.MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool" Usage="frameworkContentElement.MoveFocus request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">Направление, в котором перемещается фокус, в виде значения перечисления.</param>
        <summary>Перемещает клавиатурный фокус с данного элемента на другой.</summary>
        <returns>Возвращает <see langword="true" />, если фокус перемещен успешно; <see langword="false" />, если целевого элемента в указанном направлении не существует.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.FrameworkContentElement.Name" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IFrameworkInputElement.Name</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает имя, обозначающее элемент. Имя предоставляет ссылку на экземпляр, чтобы код программной части, например код обработчика событий, мог ссылаться на элемент после создания этого элемента во время синтаксического анализа [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</summary>
        <value>Имя элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Наиболее распространенный способ использования этого свойства — при указании имени элемента [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] в разметке.  
  
 Это свойство по сути предоставляет удобное свойство уровня инфраструктуры WPF для установки [директивы [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] x:Name](~/docs/framework/xaml-services/x-name-directive.md).  
  
 Получение <xref:System.Windows.FrameworkContentElement.Name%2A> из кода не является распространенным, так как если у вас уже есть соответствующая ссылка в коде, можно просто вызвать методы и свойства в ссылке на элемент и, как правило, не требуется <xref:System.Windows.FrameworkContentElement.Name%2A>. Исключением является то, что в строке есть перегруженное значение, например, если полезно отобразить это имя в [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]. Установка <xref:System.Windows.FrameworkContentElement.Name%2A> из кода, если исходная <xref:System.Windows.FrameworkContentElement.Name%2A> была задана из разметки, также не рекомендуется, а изменение свойства не приведет к изменению ссылки на объект. Такие ссылки на объекты создаются только в том случае, если базовые области видимости имен создаются явно во время загрузки [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 Необходимо специально вызвать <xref:System.Windows.FrameworkContentElement.RegisterName%2A>, чтобы внести эффективное изменение в свойство <xref:System.Windows.FrameworkContentElement.Name%2A> уже загруженного элемента.  
  
 Один важный случай, когда важнее <xref:System.Windows.FrameworkContentElement.Name%2A> кода, заключается в именовании элементов, для которых будут выполняться раскадровки. Прежде чем можно будет зарегистрировать имя, может также потребоваться создать и назначить экземпляр <xref:System.Windows.NameScope>. См. раздел "пример" или [Общие сведения о раскадровках](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).  
  
 Установка <xref:System.Windows.FrameworkContentElement.Name%2A> из кода имеет ограниченные приложения, но поиск элемента по имени является более распространенным, особенно если используется модель навигации, когда страницы перезагружены в приложение и код времени выполнения не обязательно является вспомогательным кодом соответствующей страницы. Служебный метод <xref:System.Windows.FrameworkContentElement.FindName%2A>, доступный из любого <xref:System.Windows.FrameworkContentElement>, может найти любой элемент, <xref:System.Windows.FrameworkContentElement.Name%2A> рекурсивно в логическом дереве этого элемента. Или можно использовать <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> статический метод <xref:System.Windows.LogicalTreeHelper>, который также принимает в качестве аргумента <xref:System.Windows.FrameworkContentElement.Name%2A>ную строку.  
  
 Часто используемые корневые элементы (например,<xref:System.Windows.Window>, <xref:System.Windows.Controls.Page>) реализуют интерфейс <xref:System.Windows.Markup.INameScope>. Реализации этого интерфейса должны обеспечивать однозначность имен в пределах их области.  
  
<a name="dependencyPropertyInfo_Name"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkContentElement.NameProperty>|  
|Для свойств метаданных задано значение `true`|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="NameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty NameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty NameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.NameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ NameProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable NameProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.NameProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkContentElement.Name" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuClosing (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuClosing(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkContentElement.OnContextMenuClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Предоставляет данные о событии.</param>
        <summary>Вызывается, когда перенаправленное событие <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> достигает этого класса на своем пути. Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не имеет реализации по умолчанию. Следует по-прежнему вызывать базовую реализацию в случае, если промежуточный класс в наследовании реализует этот метод.  
  
 Цель этого метода схожа с шаблоном событий [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] в методах *: он предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра. В этом случае сопоставленное событие является перенаправленным событием. Шаблон реализации методов On * отличается для перенаправленных событий, так как перенаправленное событие может быть вызвано дочерним элементом, а не обязательно элементом, который будет вызывать обработчики. Поэтому ваша реализация должна принять учетные записи свойств источника аргументов событий (и не пытаться повторно вызывать событие в большинстве случаев). Подклассы <xref:System.Windows.FrameworkContentElement> могут выдавать вызовы закрытых методов обработчика класса, когда событие получается по маршруту. Одним из возможных сценариев является получение аргументов события и намеренная пометка события как обработанного для сокращения маршрута.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuOpening (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuOpening(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkContentElement.OnContextMenuOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Данные для события.</param>
        <summary>Вызывается, когда перенаправленное событие <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> достигает этого класса на своем пути. Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не имеет реализации по умолчанию. По-прежнему следует вызывать base (), если промежуточный класс в наследовании реализует этот метод.  
  
 Цель этого метода схожа с шаблоном событий [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] в методах *: он предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра. В этом случае сопоставленное событие является перенаправленным событием. Шаблон реализации методов On * отличается для перенаправленных событий, так как перенаправленное событие могло быть вызвано дочерним элементом, а не обязательно элементом, который будет вызывать обработчики, поэтому ваша реализация должна взять источник аргументов события свойства в учетной записи (и не следует пытаться повторно вызывать событие в большинстве случаев). Подклассы <xref:System.Windows.FrameworkContentElement> могут выдавать вызовы закрытых методов обработчика класса, когда событие получается по маршруту. Одним из возможных сценариев является получение аргументов события и намеренная пометка события как обработанного для сокращения маршрута.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="frameworkContentElement.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Данные для события.</param>
        <summary>Обработчик класса для события <see cref="E:System.Windows.ContentElement.GotFocus" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот обработчик класса задает соответствующее поведение фокуса для данного элемента, если событие произошло из этого элемента. Если источником события был другой элемент в дереве, обработчик не выполняет никаких действий.  
  
 Переопределите этот метод, чтобы изменить поведение фокуса по умолчанию для элемента.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitialized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInitialized : EventArgs -&gt; unit&#xA;override this.OnInitialized : EventArgs -&gt; unit" Usage="frameworkContentElement.OnInitialized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Данные для события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.FrameworkContentElement.Initialized" />. Этот метод вызывается при каждой установке для свойства <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> значения <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация этого виртуального метода по умолчанию вызывает событие, как описано выше в этом разделе. Переопределения должны вызывать base () для сохранения этого поведения.  
  
 Обратите внимание, что свойство <xref:System.Windows.FrameworkContentElement.IsInitialized%2A> доступно только для чтения. Таким образом, нельзя задать принудительное поведение при инициализации. Параметр инициализации должен выполняться только платформой [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)].  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="frameworkContentElement.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Данные события, описывающие измененное свойство, а также старое и новое значения.</param>
        <summary>Вызывается каждый раз, когда обновляется действительное значение любого свойства зависимостей для данного <see cref="T:System.Windows.FrameworkContentElement" />. Конкретное измененное свойство зависимостей сообщается в параметре аргументов. Переопределяет <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не предназначен для общего обнаружения изменений свойств или недействительностей. Вместо этого он предназначен для изменения общего шаблона недействительности, если определенная информация известна по широким классификациям свойств.  
  
 Этот метод потенциально вызывается много раз в течение жизненного цикла объекта. Таким образом, можно добиться лучшей производительности при переопределении метаданных определенных свойств, а затем присоединить <xref:System.Windows.CoerceValueCallback> или функции <xref:System.Windows.PropertyChangedCallback> для отдельных свойств. Однако этот метод следует использовать, если <xref:System.Windows.FrameworkContentElement> включает значительное количество свойств зависимостей, связанных со значениями, или если оно включает логику, например поведение отрисовки, которая должна быть перезапущена для нескольких связанных вариантов недопустимых свойств.  
  
 Обратите внимание, что существует аналогично именованный метод `OnPropertyChanged` с другой сигнатурой (тип параметра — <xref:System.ComponentModel.PropertyChangedEventArgs>), который может использоваться в нескольких классах. Это `OnPropertyChanged` используется для уведомлений объектов данных и является частью контракта для <xref:System.ComponentModel.INotifyPropertyChanged>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Всегда вызывайте базовую реализацию в качестве первой операции в реализации. Невыполнение этого действия приведет к значительному отключению всей системы свойств [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], что приводит к сообщению о неправильном значении.</para></block>
        <altmember cref="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStyleChanged(class System.Windows.Style oldStyle, class System.Windows.Style newStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStyleChanged (oldStyle As Style, newStyle As Style)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStyleChanged(System::Windows::Style ^ oldStyle, System::Windows::Style ^ newStyle);" />
      <MemberSignature Language="F#" Value="abstract member OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit&#xA;override this.OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit" Usage="frameworkContentElement.OnStyleChanged (oldStyle, newStyle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldStyle" Type="System.Windows.Style" />
        <Parameter Name="newStyle" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="oldStyle">Старый стиль.</param>
        <param name="newStyle">Новый стиль.</param>
        <summary>Вызывается при изменении стиля, используемого для данного элемента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет реализацию по умолчанию, которая устанавливает внутренний флаг, указывая на то, что изменилось условие стиля.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Всегда вызывать базовую реализацию; в противном случае стили не могут быть применены. Сценарии переопределения этого метода могут включать в себя, если производный класс имеет специализированный селектор стиля или кэширует значения стиля. Изменения в теме могут вызвать этот метод.</para></block>
        <altmember cref="P:System.Windows.FrameworkContentElement.Style" />
      </Docs>
    </Member>
    <Member MemberName="OnToolTipClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipClosing(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipClosing (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipClosing(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkContentElement.OnToolTipClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Предоставляет данные о событии.</param>
        <summary>Вызывается, когда перенаправленное событие <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> достигает этого класса на своем пути. Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не имеет реализации по умолчанию. По-прежнему следует вызывать base (), если промежуточный класс в наследовании реализует этот метод.  
  
 Цель этого метода схожа с шаблоном событий [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] в методах *: он предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра. В этом случае сопоставленное событие является перенаправленным событием. Шаблон реализации методов On * отличается для перенаправленных событий, так как перенаправленное событие могло быть вызвано дочерним элементом, а не обязательно элементом, который будет вызывать обработчики, поэтому ваша реализация должна взять источник аргументов события свойства в учетной записи (и не следует пытаться повторно вызывать событие в большинстве случаев). Подклассы <xref:System.Windows.FrameworkContentElement> могут выдавать вызовы закрытых методов обработчика класса, когда событие получается по маршруту. Одним из возможных сценариев является получение аргументов события и намеренная пометка события как обработанного для сокращения маршрута.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipOpening(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipOpening (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipOpening(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkContentElement.OnToolTipOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Предоставляет данные о событии.</param>
        <summary>Вызывается, когда перенаправленное событие <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> достигает этого класса на своем пути. Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не имеет реализации по умолчанию. По-прежнему следует вызывать base (), если промежуточный класс в наследовании реализует этот метод.  
  
 Цель этого метода схожа с шаблоном событий [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] в методах *: он предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра. В этом случае сопоставленное событие является перенаправленным событием. Шаблон реализации для методов On * отличается для перенаправленных событий, так как перенаправленное событие могло быть создано дочерним элементом, а не обязательно элементом, который будет вызывать обработчики, поэтому ваша реализация должна взять источник аргументов события свойства в учетной записи (и не следует пытаться повторно вызывать событие в большинстве случаев). Подклассы <xref:System.Windows.FrameworkContentElement> могут выдавать вызовы закрытых методов обработчика класса, когда событие получается по маршруту. Одним из возможных сценариев является получение аргументов события и намеренная пометка события как обработанного для сокращения маршрута.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyle">
      <MemberSignature Language="C#" Value="public bool OverridesDefaultStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesDefaultStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesDefaultStyle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesDefaultStyle { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesDefaultStyle : bool with get, set" Usage="System.Windows.FrameworkContentElement.OverridesDefaultStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, содержит ли данный элемент свойства стиля из тематических стилей.</summary>
        <value>Значение <see langword="true" />, если этот элемент не использует свойства стиля темы; все свойства, определяющие стиль, получаются из локальных стилей приложения, а свойства стиля темы не применяются. Значение <see langword="false" />, если сначала применяются стили приложения, а затем стили тем для свойств, которые не были явным образом заданы в стилях приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Наиболее распространенное использование этого свойства — это косвенное использование в методе задания стиля, который предоставляет стиль темы.  
  
<a name="dependencyPropertyInfo_OverridesDefaultStyle"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty>|  
|Для свойств метаданных задано значение `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OverridesDefaultStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OverridesDefaultStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OverridesDefaultStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OverridesDefaultStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkContentElement.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает родительский объект в логическом дереве для этого элемента.</summary>
        <value>Логический родительский объект для этого элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обратите внимание, что логический родительский элемент элемента может измениться в зависимости от функциональности приложения, а значение этого свойства не будет отражать это изменение. Как правило, это значение следует получить непосредственно перед тем, как оно понадобится.  
  
 Дополнительные сведения об обходе логических деревьев см. в разделе [деревья в WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md) , а также в сценариях, где рекомендуется применять этот подход к обнаружению элементов.  
  
 Система свойств может пересчитать все значения свойств элемента при его повторном дочернем элементе, поскольку некоторые свойства наследуют значения через логическое дерево. <xref:System.Windows.FrameworkContentElement.DataContext%2A>, применяемые к привязкам, также могут изменяться, когда элементы переносятся в родительский элемент.  
  
 Изменение родителя элемента обычно выполняется только посредством манипуляций с коллекциями с помощью выделенных методов Add или Remove или путем установки свойств содержимого элементов.  
  
 Наиболее типичным сценарием использования свойства <xref:System.Windows.FrameworkContentElement.Parent%2A> является получение ссылки и получение различных значений свойств <xref:System.Windows.FrameworkContentElement> из родительского элемента. Для шаблонов <xref:System.Windows.FrameworkContentElement.Parent%2A> шаблона будет `null`. Чтобы перейти к этому моменту и расширить логическое дерево, где фактически применяется шаблон, используйте <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>.  
  
   
  
## Examples  
 В следующем примере проверяется, относится ли <xref:System.Windows.FrameworkContentElement.Parent%2A> <xref:System.Windows.Documents.TextPointer> к определенному типу.  
  
 [!code-csharp[TextPointer_snippets#FCEParent](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#fceparent)]
 [!code-vb[TextPointer_snippets#FCEParent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#fceparent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberSignature Language="F#" Value="override this.PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject" Usage="frameworkContentElement.PredictFocus direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Направление, в котором следует определить перспективное изменение фокуса.</param>
        <summary>Определяет следующий элемент, который получит фокус, относительно данного элемента для указанного направления движения фокуса, но реально фокус не перемещает. Данный метод запечатан и не может быть переопределен.</summary>
        <returns>Следующий элемент, на который будет перемещен фокус в случае фактического обхода фокуса. Может возвращать значение <see langword="null" />, если фокус нельзя переместить относительно данного элемента в указанном направлении.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkContentElement.MoveFocus%2A> — это связанный метод, который фактически перемещает фокус.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Одно из следующих направлений, указанное в <see cref="T:System.Windows.Input.TraversalRequest" />: <see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.First" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Last" />. Эти направления недопустимы для метода <see cref="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> (однако допустимы для метода <see cref="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />).</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberSignature Language="F#" Value="member this.RegisterName : string * obj -&gt; unit" Usage="frameworkContentElement.RegisterName (name, scopedElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Имя, используемое для сопоставления указанного имени с объектом.</param>
        <param name="scopedElement">Объект для сопоставления.</param>
        <summary>Предоставляет метод доступа, упрощающий доступ к методу регистрации <see cref="T:System.Windows.NameScope" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод является удобным методом для вызова <xref:System.Windows.NameScope.RegisterName%2A>. Реализация проверяет последовательные родительские элементы до тех пор, пока не найдет соответствующую реализацию <xref:System.Windows.NameScope>, которую можно найти, выполнив поиск элемента, реализующего <xref:System.Windows.Markup.INameScope>. Дополнительные сведения об областях видимости имен см. в разделе [области имен XAML WPF](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
 Чтобы правильно подключить раскадровки анимации для приложений при создании в коде, необходимо вызвать <xref:System.Windows.FrameworkContentElement.RegisterName%2A>. Это происходит потому, что одно из ключевых свойств раскадровки, <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>, использует поиск имени во время выполнения вместо того, чтобы иметь возможность принимать ссылку на целевой элемент. Это справедливо, даже если этот элемент доступен по ссылке из кода. Дополнительные сведения о том, почему необходимо зарегистрировать имена для целей раскадровки, см. в разделе [Общие сведения о раскадровках](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md). Анимация элементов содержимого менее распространена, чем анимация на элементах управления. [Общие сведения о раскадровках](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md) сосредоточены на сценариях управления.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="RemoveLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void RemoveLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RemoveLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RemoveLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RemoveLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.RemoveLogicalChild : obj -&gt; unit" Usage="frameworkContentElement.RemoveLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">Подлежащий удалению элемент.</param>
        <summary>Удаляет указанный элемент из логического дерева данного элемента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот API в основном относится к сценариям, производным от класса, при добавлении поддержки дочерних коллекций.  
  
 Большинство <xref:System.Windows.FrameworkContentElement> производных классах предоставляют выделенные коллекции, которые отвечают за включение (например, <xref:System.Windows.Documents.Span.Inlines%2A> в классе <xref:System.Windows.Documents.Span>, <xref:System.Windows.Documents.Section.Blocks%2A> в классе <xref:System.Windows.Documents.Section>). Наследование от таких классов обычно может избежать необходимости непосредственного управления логическим деревом.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.FrameworkContentElement.Resources" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;netcore-3.1">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает текущий локально определенный словарь ресурсов.</summary>
        <value>Текущие локально определенные ресурсы. Это словарь ресурсов, доступ к ресурсам которого можно получить по ключу.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Словари ресурсов, которые могут быть определены полностью или частично в [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)], обычно создаются как элементы свойства и обычно находятся в корневом элементе для любой отдельной страницы или приложения. Размещение словаря ресурсов на этом уровне упрощает поиск из отдельных дочерних элементов на странице (или с любой страницы в случае приложения). В большинстве сценариев приложений рекомендуется, чтобы стили определялись как элементы объекта в словаре ресурсов или были определены как внешние ресурсы, чтобы весь ресурс стиля мог быть самодостаточным (этот подход помогает разделить конструктор ответственность за обязанности разработчиков заключается в разделении физических файлов, которые необходимо изменить.  
  
 Обратите внимание, что это свойство возвращает только словарь ресурсов, объявленный непосредственно внутри этого элемента. Это отличается от фактического процесса уточняющего запроса ресурса, в котором дочерний элемент может получить доступ к любому ресурсу, определенному в каждом родительском элементе, и выполнять рекурсивный поиск.  
  
 На ресурсы также может ссылаться код из коллекции, но следует иметь в виду, что ресурсы, созданные в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], определенно не будут доступны до тех пор, пока не будет вызвано <xref:System.Windows.FrameworkContentElement.Loaded> элементом, объявляющего словарь. На самом деле, ресурсы анализируются асинхронно, а даже событие <xref:System.Windows.FrameworkContentElement.Loaded> является гарантией того, что вы можете ссылаться на [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] определенный ресурс. По этой причине вы обычно должны получить доступ только к [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] определенным ресурсам в рамках кода времени выполнения или с помощью других методов [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], таких как стили или ссылки на расширения ресурсов для значений атрибутов. При доступе к ресурсам с помощью кода он, по сути, эквивалентен ссылке [DynamicResource](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) , созданной из [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 Базовый <xref:System.Windows.ResourceDictionary> поддерживает методы, необходимые для добавления, удаления или запроса ресурсов в коллекции с помощью кода. Свойство <xref:System.Windows.FrameworkContentElement.Resources%2A> является устанавливаемым для поддержки сценария полной замены коллекции ресурсов элемента на новую или другую <xref:System.Windows.ResourceDictionary>.  
  
 Обратите внимание, что показанный синтаксис [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] не включает элемент для <xref:System.Windows.ResourceDictionary>. Это пример неявного синтаксиса коллекции. тег, представляющий элемент коллекции, можно опустить. Вместо этого задаются элементы, добавляемые в качестве элементов в коллекцию. Дополнительные сведения о неявных коллекциях и [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]см. [в разделе Подробное описание синтаксиса XAML](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md). Один из случаев, когда <xref:System.Windows.ResourceDictionary> по-прежнему указывается явным образом как элемент, если вы представляете Объединенный словарь, в этом случае для этого <xref:System.Windows.ResourceDictionary>обычно не дочерние элементы. Дополнительные сведения см. в разделе [Объединенные словари ресурсов](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).  
  
<a name="xamlPropertyElementUsage_Resources"></a>   
## <a name="xaml-property-element-usage"></a>Использование элемента свойства XAML  
  
```  
<object>  
  <object.Resources>  
    oneOrMoreResourceElements  
  </object.Resources>  
</object>  
```  
  
<a name="xamlValues_Resources"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *онеорморересаурцеелементс*  
 Один или несколько объектных элементов, каждый из которых определяет ресурс. Каждый элемент свойства ресурса в каждой <xref:System.Windows.ResourceDictionary> должен иметь уникальное значение для [директивы x:Key](~/docs/framework/xaml-services/x-key-directive.md), которое служит уникальным ключом при извлечении значений из <xref:System.Windows.ResourceDictionary>.  
  
   
  
## Examples  
 В следующем примере создается коллекция <xref:System.Windows.FrameworkContentElement.Resources%2A> для корневого элемента <xref:System.Windows.Documents.FlowDocument>. <xref:System.Windows.Documents.FlowDocument> является типичным выбором, так как это один из нескольких <xref:System.Windows.FrameworkContentElement> классов, имеющих смысл в качестве корневого элемента, а ресурсы обычно хранятся в корне страницы или на более высоких уровнях, например в приложении.  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Application.Resources" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBinding">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Присоединяет привязку к этому элементу для указанного свойства зависимостей.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression SetBinding(class System.Windows.DependencyProperty dp, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, path As String) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * string -&gt; System.Windows.Data.BindingExpression" Usage="frameworkContentElement.SetBinding (dp, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dp">Идентифицирует привязанное свойство.</param>
        <param name="path">Имя исходного свойства или путь к свойству, используемому для привязки.</param>
        <summary>Прикрепляет привязку к данному элементу на основе указанного имени исходного свойства в виде классификационного пути к источнику данных.</summary>
        <returns>Фиксирует состояния привязки. Это возвращаемое значение можно использовать для проверки ошибок.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод является удобным методом для вызова <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, который передает текущий экземпляр в качестве <xref:System.Windows.DependencyObject>и создает новый <xref:System.Windows.Data.Binding> на основе предоставленного параметра `path`. Эта сигнатура удобнее, если вы устанавливаете простую привязку по умолчанию. Если необходимо указать какие-либо свойства привязки для условий, отличных от Default, или использовать <xref:System.Windows.Data.MultiBinding> или <xref:System.Windows.Data.PriorityBinding>, следует использовать сигнатуру <xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29>.  
  
   
  
## Examples  
 В следующем примере задается привязка для элемента <xref:System.Windows.Documents.Paragraph>, создавая новый пользовательский объект данных, устанавливая этот объект как <xref:System.Windows.FrameworkContentElement.DataContext%2A>и настроив путь привязки на свойство в нем.  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, binding As BindingBase) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpressionBase ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::Windows::Data::BindingBase ^ binding);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * System.Windows.Data.BindingBase -&gt; System.Windows.Data.BindingExpressionBase" Usage="frameworkContentElement.SetBinding (dp, binding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="dp">Идентифицирует привязанное свойство.</param>
        <param name="binding">Представляет привязку данных.</param>
        <summary>Прикрепляет привязку к данному элементу на основе предоставленной привязки объекта.</summary>
        <returns>Фиксирует состояния привязки. Это возвращаемое значение можно использовать для проверки ошибок.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод является удобным методом для вызова <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, который передает текущий экземпляр в качестве <xref:System.Windows.DependencyObject>.  
  
   
  
## Examples  
 В следующем примере задается привязка для элемента <xref:System.Windows.Documents.Paragraph> путем создания нового <xref:System.Windows.Data.Binding> и присвоения источнику вновь созданного `DateTime` объекта.  
  
 [!code-csharp[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#setbinding)]
 [!code-vb[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#setbinding)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetResourceReference">
      <MemberSignature Language="C#" Value="public void SetResourceReference (System.Windows.DependencyProperty dp, object name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetResourceReference(class System.Windows.DependencyProperty dp, object name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetResourceReference (dp As DependencyProperty, name As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetResourceReference(System::Windows::DependencyProperty ^ dp, System::Object ^ name);" />
      <MemberSignature Language="F#" Value="member this.SetResourceReference : System.Windows.DependencyProperty * obj -&gt; unit" Usage="frameworkContentElement.SetResourceReference (dp, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="name" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">Свойство, к которому привязан ресурс.</param>
        <param name="name">Имя ресурса.</param>
        <summary>Выполняет поиск ресурса по указанному имени и устанавливает ссылку на этот ресурс для указанного свойства.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ссылка на ресурс аналогична использованию [расширения разметки DynamicResource](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) в разметке. Ссылка на ресурс создает внутреннее выражение, которое предоставляет значение указанного свойства на отложенной основе времени выполнения. Выражение будет повторно вычислено каждый раз, когда словарь ресурсов указывает измененное значение посредством внутренних событий или когда текущий элемент будет переноситься (родительское изменение изменит путь поиска словаря).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.Application.Resources" />
        <altmember cref="P:System.Windows.FrameworkElement.Resources" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeResources">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeResources" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeResources () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeResources();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeResources : unit -&gt; bool" Usage="frameworkContentElement.ShouldSerializeResources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает логическое значение, указывающее, следует ли процессам сериализации сериализировать содержимое свойства <see cref="P:System.Windows.FrameworkContentElement.Resources" /> в экземплярах данного класса.</summary>
        <returns>Значение <see langword="true" />, если значение свойства <see cref="P:System.Windows.FrameworkContentElement.Resources" /> подлежит сериализации, в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это приведет к возвращению `true` до тех пор, пока в локальном <xref:System.Windows.FrameworkContentElement.Resources%2A>есть по крайней мере один ресурс с ключом.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeStyle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeStyle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeStyle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeStyle();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeStyle : unit -&gt; bool" Usage="frameworkContentElement.ShouldSerializeStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает логическое значение, указывающее, следует ли процессам сериализации сериализировать содержимое свойства <see cref="P:System.Windows.FrameworkContentElement.Style" /> в экземплярах данного класса.</summary>
        <returns>Значение <see langword="true" />, если значение свойства <see cref="P:System.Windows.FrameworkContentElement.Style" /> подлежит сериализации, в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это приведет к возвращению `true`, если <xref:System.Windows.Style> установлен локально.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.SourceUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ SourceUpdated;" />
      <MemberSignature Language="F#" Value="member this.SourceUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.SourceUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении какого-либо связанного источника данных, участвующего в привязке к данному элементу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие охватывает событие <xref:System.Windows.Data.Binding.SourceUpdated>, которое вызывается любыми <xref:System.Windows.Data.Binding>, связанными с этим элементом.  
  
<a name="xamlAttributeUsage_SourceUpdated"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object SourceUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public System.Windows.Style Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ Style { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Style : System.Windows.Style with get, set" Usage="System.Windows.FrameworkContentElement.Style" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает стиль, который должен использоваться этим элементом.</summary>
        <value>Примененный стиль не по умолчанию для элемента, если присутствует. В противном случае — значение <see langword="null" />. Значение по умолчанию для созданного по умолчанию <see cref="T:System.Windows.FrameworkContentElement" /> — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текущий стиль часто предоставляется стилем по умолчанию или из стилей, обычно применяемых к объектам этого типа по ресурсам на уровне страницы или приложения (неявный стиль). Это свойство не устанавливает или не возвращает стили по умолчанию (темы), но возвращает неявный стиль или явный стиль. В случае явных или неявных стилей не имеет значения, доступен ли стиль как ресурс или определен локально.  
  
 Установка стилей имеет некоторые ограничения. Можно сбросить все <xref:System.Windows.FrameworkContentElement.Style%2A> свойства в новое <xref:System.Windows.Style> в любое время, что приведет к перекомпоновке макета. Однако, как только этот стиль будет помещен в элемент, используемый загруженным элементом, <xref:System.Windows.Style> следует считать запечатанным. Попытка изменить любое отдельное свойство используемого стиля (например, что-либо в коллекции <xref:System.Windows.Style.Setters%2A>) приводит к возникновению исключения. Стиль, определенный в разметке, считается используемым, как только он загружается из словаря ресурсов (для ресурсов), или загружается страница, содержащаяся в загрузкой (для встроенных стилей).  
  
 <xref:System.Windows.FrameworkContentElement.Style%2A> — это свойство зависимостей с особым приоритетом. Локально заданный стиль обычно работает с наивысшим приоритетом в системе свойств. Если на этом этапе <xref:System.Windows.FrameworkContentElement.Style%2A> имеет значение null, при загрузке системы свойств для неявных стилей в качестве определенных ресурсов, указывающих этот тип, происходит проверка. Если после этого шага стиль по-прежнему имеет значение null, то стиль берется из стиля по умолчанию (темы), но стиль по умолчанию не возвращается в значении свойства <xref:System.Windows.FrameworkContentElement.Style%2A>. См. раздел [Приоритет значения свойства зависимостей](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
<a name="xamlAttributeUsage_Style"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object Style="{resourceExtension StyleResourceKey}"/>  
```  
  
<a name="xamlValues_Style"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *ресаурцеекстенсион*  
 Один из следующих элементов: или. См. раздел [ресурсы XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *стилересаурцекэй*  
 Ключ, определяющий запрашиваемый стиль. Ключ ссылается на существующий ресурс в <xref:System.Windows.ResourceDictionary>.  
  
> [!NOTE]
>  Синтаксис элемента свойства технически возможен, но не рекомендуется. См. раздел [встроенные стили и шаблоны](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).  Ссылка на привязку с помощью [TemplateBinding](~/docs/framework/wpf/advanced/templatebinding-markup-extension.md) или <xref:System.Windows.Data.Binding> также возможна, но не часто.  
  
<a name="dependencyPropertyInfo_Style"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkContentElement.StyleProperty>|  
|Для свойств метаданных задано значение `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 В следующем примере создается коллекция <xref:System.Windows.FrameworkContentElement.Resources%2A> для <xref:System.Windows.Documents.FlowDocument> корневого элемента, а затем она ссылается на него как на конкретный стиль для <xref:System.Windows.Documents.Paragraph>.  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty StyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty StyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.StyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ StyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable StyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.StyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkContentElement.Style" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="propertyName">Имя запрошенного внешнего свойства.</param>
        <summary>Описание этого элемента содержится в методе <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" />.</summary>
        <returns>Значение <see langword="true" />, если свойство с именем в параметре <paramref name="propertyName" /> доступно; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Windows.FrameworkContentElement> приведен к типу интерфейса <xref:System.Windows.Markup.IQueryAmbient>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Windows.FrameworkContentElement.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение или установка произвольного значения объекта, которое может использоваться для хранения особых сведений об этом элементе.</summary>
        <value>Целевое значение. Это свойство не имеет значения по умолчанию.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство аналогично свойствам тегов в других моделях программирования Майкрософт, таких как Visual Basic для приложений или Windows Forms. Она предназначается для хранения некоторых основных пользовательских сведений о любом элементе, не требуя от разработчиков приложения создавать подкласс.  
  
<a name="xamlValues_Tag"></a>   
## <a name="xaml-values"></a>Значения XAML  
 Поскольку это свойство принимает объект, необходимо использовать использование элемента свойства, чтобы задать свойство <xref:System.Windows.FrameworkContentElement.Tag%2A> в XAML для любого другого, кроме объекта с известным встроенным преобразовательом типа, например строкой. Объекты, используемые таким способом, обычно не входят в стандартные пространства имен WPF и поэтому могут потребовать сопоставления пространств имен с внешним пространством имен, чтобы они были представлены как элементы XAML.  
  
<a name="dependencyPropertyInfo_Tag"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkContentElement.TagProperty>|  
|Для свойств метаданных задано значение `true`|Отсутствуют|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="TagProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TagProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TagProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.TagProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TagProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TagProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TagProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.TagProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkContentElement.Tag" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.TargetUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TargetUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ TargetUpdated;" />
      <MemberSignature Language="F#" Value="member this.TargetUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.TargetUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении любого связанного целевого свойства, участвующего в привязке в этом элементе.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие охватывает событие <xref:System.Windows.Data.Binding.TargetUpdated>, которое вызывается любыми <xref:System.Windows.Data.Binding>, связанными с этим элементом. Обычно это означает, что привязка, как правило, является двухсторонней, и что привязанное свойство зависимости гарантирует недействительность предыдущего значения свойства для любой схемы проверки или кэширования, которую поддерживает свойство.  
  
 Аргументы события этого события информируют вас о том, какое связанное свойство было изменено.  
  
<a name="xamlAttributeUsage_TargetUpdated"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object TargetUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplatedParent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject TemplatedParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject TemplatedParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TemplatedParent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ TemplatedParent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TemplatedParent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkContentElement.TemplatedParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает ссылку на родительский объект шаблона данного элемента. Это свойство не актуально, если элемент не был создан с помощью шаблона.</summary>
        <value>Элемент, свойство <see cref="T:System.Windows.FrameworkTemplate" /> шаблона <see cref="P:System.Windows.FrameworkTemplate.VisualTree" />  которого вызвало создание данного элемента. Это значение часто равно <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Шаблоны фактически являются общими объектами, где содержимое шаблона создается только один раз. Поэтому при получении ссылки на объект, поступилный из шаблона, может оказаться, что очевидное логическое дерево не достигает корневого элемента страницы. Чтобы подключить такую ссылку на шаблон к логическому дереву страницы, необходимо получить значение <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> и продолжить навигацию по этому дереву элементов по своему усмотрению.  
  
 <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> часто будут `null` для распространенных объектов, так как если вы получили ссылку на объект из страницы в приложении с помощью стандартных средств, этот элемент, вероятно, не был создан из шаблона. Случаи, когда <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> могут не `null`, включают такие операции, как проверка попадания, обработка событий для определенных низкоуровневых событий ввода или работа с перечислителями, которые могут возвращать элементы, поступилные из шаблонов.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTip">
      <MemberSignature Language="C#" Value="public object ToolTip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ToolTip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ToolTip" />
      <MemberSignature Language="VB.NET" Value="Public Property ToolTip As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ToolTip { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ToolTip : obj with get, set" Usage="System.Windows.FrameworkContentElement.ToolTip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает объект подсказки, отображаемый для данного элемента в [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</summary>
        <value>Объект подсказки.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если значение этого свойства имеет тип <xref:System.Windows.Controls.ToolTip>, то это всплывающая подсказка, которая будет использоваться в [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].  Если значение любого другого типа, то оно будет использоваться в качестве *содержимого* для <xref:System.Windows.Controls.ToolTip>, предоставленного (сконструированного) системой. Дополнительные сведения см. в разделе <xref:System.Windows.Controls.ToolTipService>. Класс службы предоставляет вложенные свойства, которые можно использовать для дальнейшей настройки всплывающей подсказки.  
  
<a name="xamlAttributeUsage_ToolTip"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object ToolTip="toolTipContent"/>  
```  
  
<a name="xamlPropertyElementUsage_ToolTip"></a>   
## <a name="xaml-property-element-usage"></a>Использование элемента свойства XAML  
  
```xaml 
<object>  
  <object.ToolTip>  
    <ToolTip .../>  
  </object.ToolTip>  
</object>  
```

-или-

```xaml
<object>  
  <object.ToolTip>  
    toolTipObjectContent  
  </object.ToolTip>  
</object>  
```

<a name="xamlValues_ToolTip"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *тултипконтент*  
 Строка, которая преобразуется в отображаемый текст для <xref:System.Windows.FrameworkContentElement.ToolTip%2A>.  
  
 *тултипобжектконтент*  
 Некоторый объект, указанный в форме объектного элемента, который следует использовать в качестве содержимого для <xref:System.Windows.FrameworkContentElement>. Обычно это будет <xref:System.Windows.FrameworkElement> или какой-либо другой элемент, создающий композицию макета для <xref:System.Windows.FrameworkContentElement.ToolTip%2A>, в конечном итоге содержащий текстовое содержимое в композиции. В этом использовании элемент <xref:System.Windows.Controls.ToolTip> создается неявно из проанализированных [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], а содержимое *тултипобжектконтент* задается как свойство <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType>.  
  
 <`ToolTip`.../>  
 См. раздел <xref:System.Windows.Controls.ToolTip>.  
  
<a name="dependencyPropertyInfo_ToolTip"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkContentElement.ToolTipProperty>|  
|Для свойств метаданных задано значение `true`|Отсутствуют|  
  
   
  
## Examples  
 В следующем примере значение свойства <xref:System.Windows.FrameworkElement.ToolTip%2A> задается непосредственно в виде строки.  
  
 [!code-csharp[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/csharp/VS_Snippets_Wpf/TableSnippets2/CSharp/Window1.xaml.cs#_table_rowgroups_maniprows)]
 [!code-vb[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TableSnippets2/visualbasic/window1.xaml.vb#_table_rowgroups_maniprows)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipClosing As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipClosing;" />
      <MemberSignature Language="F#" Value="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит непосредственно перед закрытием какой-либо подсказки в элементе.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы подавить закрытие подсказки, обработчики события должны пометить его как обработанное.  
  
 Это событие не может быть <xref:System.Windows.EventTrigger> в стиле. Это связано с тем, что поле идентификатора этого события повторно использует реализацию из службы, которая не предоставляет методы Add/Remove для события.  
  
<a name="routedEventInfo_ToolTipClosing"></a>   
## <a name="routed-event-information"></a>Сведения о маршрутизируемом событии  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkContentElement.ToolTipClosingEvent>|  
|Стратегия маршрутизации|Direct|  
|делегат|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ToolTipClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> [Обзор маршрутизированных событий](~/docs/framework/wpf/advanced/routed-events-overview.md).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объекты идентификаторов событий создаются при регистрации маршрутизируемых событий (см. <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) и могут использоваться для добавления обработчиков классов (см. <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Объекты идентификаторов содержат идентифицирующее имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод для добавления владельцев для события.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipOpening As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipOpening;" />
      <MemberSignature Language="F#" Value="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при открытии любой всплывающей подсказки к элементу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вручную открыть подсказки, обработчики событий должны отметить соответствующее событие как обработанное. В противном случае значение свойства <xref:System.Windows.FrameworkContentElement.ToolTip%2A> будет использоваться для автоматического открытия контекстного меню. Пометка события как обработанного отменяет действие по умолчанию и может привести к сбросу значения свойства <xref:System.Windows.FrameworkContentElement.ToolTip%2A>, а затем открыть новый <xref:System.Windows.Controls.ContextMenu>. Обратите внимание, что это событие не будет вызвано, если <xref:System.Windows.FrameworkContentElement.ToolTip%2A> является пустой ссылкой или неопределенным иным образом.  
  
 Это событие не может быть <xref:System.Windows.EventTrigger> в стиле. Это связано с тем, что поле идентификатора этого события повторно использует реализацию из службы, которая не предоставляет методы Add/Remove для события.  
  
<a name="routedEventInfo_ToolTipOpening"></a>   
## <a name="routed-event-information"></a>Сведения о маршрутизируемом событии  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkContentElement.ToolTipOpeningEvent>|  
|Стратегия маршрутизации|Direct|  
|делегат|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ToolTipOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> [Обзор маршрутизированных событий](~/docs/framework/wpf/advanced/routed-events-overview.md).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объекты идентификаторов событий создаются при регистрации маршрутизируемых событий (см. <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) и могут использоваться для добавления обработчиков классов (см. <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Объекты идентификаторов содержат идентифицирующее имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод для добавления владельцев для события.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ToolTipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ToolTipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ToolTipProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ToolTipProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkContentElement.ToolTip" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="frameworkContentElement.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Идентификатор ключа искомого ресурса.</param>
        <summary>Ищет ресурс с указанным ключом и возвращает его, если он найден.</summary>
        <returns>Найденный ресурс. Если не удалось найти ресурс, возвращается <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если ресурс не найден в вызывающем элементе, то в родительском дереве выполняется поиск по логическому дереву, точно так же, как в дереве будет осуществляться поиск, если ссылка на динамический ресурс была запрошена ключом во время выполнения.  
  
 Обычно возвращаемое значение будет немедленно приведено к типу свойства, которое вы пытались задать с возвращенным значением ресурса.  
  
 Метод <xref:System.Windows.FrameworkContentElement.FindResource%2A> имеет аналогичное поведение, за исключением того, что он выдаст исключение в случае, если ресурс не будет найден с помощью предоставленного ключа.  
  
   
  
## Examples  
 В следующем примере выполняется поиск ресурса, определенного в разметке, и применение его к определенному свойству элемента в ответ на перенаправленное событие.  
  
 [!code-csharp[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#tryfindresource)]
 [!code-vb[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#tryfindresource)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Unloaded;" />
      <MemberSignature Language="F#" Value="member this.Unloaded : System.Windows.RoutedEventHandler " Usage="member this.Unloaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при удалении элемента из дерева загруженных элементов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Прямые перенаправленные события не следуют маршруту, они обрабатываются только в том же элементе, в котором они вызываются. Перенаправленные события поддерживают другое поведение перенаправленного события: они поддерживают коллекцию обработчиков, доступную для доступа, и могут использоваться в качестве <xref:System.Windows.EventTrigger> в стиле.  
  
<a name="routedEventInfo_Unloaded"></a>   
## <a name="routed-event-information"></a>Сведения о маршрутизируемом событии  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkContentElement.UnloadedEvent>|  
|Стратегия маршрутизации|Direct|  
|делегат|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnloadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent UnloadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent UnloadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.UnloadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnloadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ UnloadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnloadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.UnloadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует <see cref="E:System.Windows.FrameworkContentElement.Unloaded" /> [Обзор маршрутизированных событий](~/docs/framework/wpf/advanced/routed-events-overview.md).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объекты идентификаторов событий создаются при регистрации маршрутизируемых событий (см. <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) и могут использоваться для добавления обработчиков классов (см. <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Объекты идентификаторов содержат идентифицирующее имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод для добавления владельцев для события.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.UnregisterName : string -&gt; unit" Usage="frameworkContentElement.UnregisterName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Имя пары имя-объект, которую необходимо удалить из текущей области видимости.</param>
        <summary>Упрощает доступ к методу отмены регистрации <see cref="T:System.Windows.NameScope" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Отменить регистрацию имен необходимо только в том случае, если планируется повторно зарегистрировать другой элемент с тем же именем.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultStyle">
      <MemberSignature Language="C#" Value="public void UpdateDefaultStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateDefaultStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UpdateDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateDefaultStyle ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateDefaultStyle();" />
      <MemberSignature Language="F#" Value="member this.UpdateDefaultStyle : unit -&gt; unit" Usage="frameworkContentElement.UpdateDefaultStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Повторно применяет стиль по умолчанию к текущему объекту <see cref="T:System.Windows.FrameworkContentElement" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
