<Type Name="RoutedEventArgs" FullName="System.Windows.RoutedEventArgs">
  <Metadata><Meta Name="ms.openlocfilehash" Value="bcf7dc63deeaebfa62a5b5e0578c3f64cef20e2d" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70639026" /></Metadata><TypeSignature Language="C#" Value="public class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RoutedEventArgs extends System.EventArgs" />
  <TypeSignature Language="DocId" Value="T:System.Windows.RoutedEventArgs" />
  <TypeSignature Language="VB.NET" Value="Public Class RoutedEventArgs&#xA;Inherits EventArgs" />
  <TypeSignature Language="C++ CLI" Value="public ref class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="F#" Value="type RoutedEventArgs = class&#xA;    inherit EventArgs" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.EventArgs</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Содержит информацию о состоянии и данные события, связанные с перенаправленным событием.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Различные <xref:System.Windows.RoutedEventArgs> можно использовать с одним <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>. Этот класс отвечает за упаковку данных событий для <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>, предоставление дополнительных сведений о состоянии событий и используется системой событий для вызова обработчика, связанного с перенаправленным событием.  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
    <altmember cref="T:System.Windows.EventManager" />
    <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.RoutedEventArgs" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.RoutedEventArgs" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании этого конструктора без параметров все открытые свойства нового <xref:System.Windows.RoutedEventArgs> экземпляра принимают следующие значения по умолчанию:  
  
-   <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>по умолчанию `null`имеет значение.  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A>по умолчанию имеет значение`false`  
  
-   <xref:System.Windows.RoutedEventArgs.Source%2A>по умолчанию `null`имеет значение.  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>по умолчанию `null`имеет значение.  
  
 Значения NULL для <xref:System.Windows.RoutedEventArgs.Source%2A> и <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> только означают, <xref:System.Windows.RoutedEventArgs> что данные не попытаются указать источник. Если этот экземпляр используется при вызове функции <xref:System.Windows.UIElement.RaiseEvent%2A> <xref:System.Windows.RoutedEventArgs.Source%2A> , значения и <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> заполняются на основе элемента, вызвавшего событие, и передаются прослушивателям через маршрутизацию.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent);" />
      <MemberSignature Language="F#" Value="new System.Windows.RoutedEventArgs : System.Windows.RoutedEvent -&gt; System.Windows.RoutedEventArgs" Usage="new System.Windows.RoutedEventArgs routedEvent" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
      </Parameters>
      <Docs>
        <param name="routedEvent">Идентификатор маршрутизируемого события для данного экземпляра класса <see cref="T:System.Windows.RoutedEventArgs" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.RoutedEventArgs" /> с помощью переданного идентификатора маршрутизируемого события.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании перегруженного конструктора неопределенные свойства нового <xref:System.Windows.RoutedEventArgs> экземпляра предполагают следующие значения по умолчанию:  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A>по умолчанию имеет значение`false`  
  
-   <xref:System.Windows.RoutedEventArgs.Source%2A>по умолчанию `null`имеет значение.  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>по умолчанию `null`имеет значение.  
  
 Значения NULL для <xref:System.Windows.RoutedEventArgs.Source%2A> и <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> только означают, <xref:System.Windows.RoutedEventArgs> что это не попытается указать источник. Если этот экземпляр используется при вызове функции <xref:System.Windows.UIElement.RaiseEvent%2A> <xref:System.Windows.RoutedEventArgs.Source%2A> , значения и <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> заполняются на основе элемента, вызвавшего событие, и передаются прослушивателям через маршрутизацию.  
  
   
  
## Examples  
 В следующем примере создается новый <xref:System.Windows.RoutedEventArgs> объект для использования в <xref:System.Windows.UIElement.RaiseEvent%2A>вызове метода.  
  
 [!code-csharp[RoutedEventCustom#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#raiseevent)]
 [!code-vb[RoutedEventCustom#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent, object source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent, object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent, System::Object ^ source);" />
      <MemberSignature Language="F#" Value="new System.Windows.RoutedEventArgs : System.Windows.RoutedEvent * obj -&gt; System.Windows.RoutedEventArgs" Usage="new System.Windows.RoutedEventArgs (routedEvent, source)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routedEvent">Идентификатор маршрутизируемого события для данного экземпляра класса <see cref="T:System.Windows.RoutedEventArgs" />.</param>
        <param name="source">Альтернативный источник, который будет сообщен при обработке события. Предварительно заполняет свойство <see cref="P:System.Windows.RoutedEventArgs.Source" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.RoutedEventArgs" /> с помощью переданного идентификатора маршрутизируемого события, предоставляя возможность объявить другой источник события.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании перегруженного конструктора неопределенные свойства нового <xref:System.Windows.RoutedEventArgs> экземпляра предполагают следующие значения по умолчанию:  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A>по умолчанию имеет значение`false`  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>по умолчанию `null`имеет значение.  
  
 Значения NULL для <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> заполняются на основе элемента, который вызвал событие и передается через маршрутизацию, но будут считаться `null` до вызова.  
  
 Используйте эту подпись при передаче <xref:System.Windows.RoutedEventArgs> виртуальным объектам, таким <xref:System.Windows.Controls.Primitives.TextBoxBase.OnSelectionChanged%2A>как, где аргументы используются для внутреннего вызова <xref:System.Windows.UIElement.RaiseEvent%2A> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handled">
      <MemberSignature Language="C#" Value="public bool Handled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Handled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Handled" />
      <MemberSignature Language="VB.NET" Value="Public Property Handled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Handled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Handled : bool with get, set" Usage="System.Windows.RoutedEventArgs.Handled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, обозначающее текущее состояние обработки перенаправленного события при перемещении по маршруту.</summary>
        <value>При настройке задайте значение <see langword="true" /> , если событие нужно пометить как обработанное; в противном случае — значение <see langword="false" />. При считывании данного значения <see langword="true" /> указывает, что обработчик класса или какой-либо обработчик экземпляра на маршруте уже пометил это событие как обработанное. Значение<see langword="false" />указывает, что ни один из обработчиков не пометил событие как обработанное.  
  
Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Пометка события как обработанного приведет к ограничению видимости перенаправленного события прослушивателями в маршруте события. Событие по-прежнему передается в оставшейся части маршрута, но в ответе `HandledEventsToo` будут вызываться только обработчики, специально добавленные `true` в в <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> вызове метода. Обработчики по умолчанию для прослушивателей экземпляров (например [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)], которые выражаются в) не будут вызываться. Обработка событий, которые помечены как обработанные, не является распространенным сценарием.  
  
 Если вы являетесь автором элемента управления, определяющим собственные события, решения, принятые в отношении обработки событий на уровне класса, повлияют на пользователей вашего элемента управления, а также на всех пользователей производных элементов управления и, возможно, на другие элементы, которые либо содержатся в вашем элементе управления. или, содержащий ваш элемент управления. Дополнительные сведения см. в разделе [Маркировка перенаправленных событий как обработанных и обработка классов](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md).  
  
 В редких обстоятельствах рекомендуется выполнять обработку событий, <xref:System.Windows.RoutedEventArgs.Handled%2A> где помечено `true`, и изменять аргументы события, изменяя <xref:System.Windows.RoutedEventArgs.Handled%2A> на `false`. Это может быть необходимо в определенных областях входных событий элементов управления, таких как обработка <xref:System.Windows.UIElement.KeyDown> <xref:System.Windows.UIElement.TextInput> ключей и входных событий низкого уровня и высокого уровня, которые конкурируют за обработку, и каждый пытается работать с другой стратегией маршрутизации.  
  
   
  
## Examples  
 В следующем примере реализуется обработчик событий, помечающий обработанное событие.  
  
 [!code-csharp[ClassHandling#OnStarClassHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ClassHandling/CSharp/SDKSampleLibrary/class1.cs#onstarclasshandler)]
 [!code-vb[ClassHandling#OnStarClassHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ClassHandling/visualbasic/sdksamplelibrary/class1.vb#onstarclasshandler)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeEventHandler">
      <MemberSignature Language="C#" Value="protected virtual void InvokeEventHandler (Delegate genericHandler, object genericTarget);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InvokeEventHandler(class System.Delegate genericHandler, object genericTarget) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InvokeEventHandler (genericHandler As Delegate, genericTarget As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InvokeEventHandler(Delegate ^ genericHandler, System::Object ^ genericTarget);" />
      <MemberSignature Language="F#" Value="abstract member InvokeEventHandler : Delegate * obj -&gt; unit&#xA;override this.InvokeEventHandler : Delegate * obj -&gt; unit" Usage="routedEventArgs.InvokeEventHandler (genericHandler, genericTarget)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericHandler" Type="System.Delegate" />
        <Parameter Name="genericTarget" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="genericHandler">Универсальная реализация обработчика или делегата для вызова.</param>
        <param name="genericTarget">Целевой объект, для которого нужно вызвать предоставленный обработчик.</param>
        <summary>При переопределении в производном классе предоставляет способ вызова обработчиков событий в зависимости от конкретного типа, что может повысить эффективность по сравнению с базовой реализацией.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Базовая реализация включает отражение для определения правильного обработчика для любого случая, когда обработчик не буквально <xref:System.Windows.RoutedEventHandler>, а этот шаг отражения имеет некоторые последствия для производительности. Вызовы можно сделать более эффективными, не полагаясь на отражение. Это сценарий, который является мотивом того, что этот метод доступен для класса аргументов перенаправленного события, который выбирает его переопределение. Реализации не должны вызывать основание для этого метода, так как ваша реализация уже должна отвечать за вызов обработчиков типа "надежный".  
  
   
  
## Examples  
 Ниже приведен псевдокод, иллюстрирующий базовый шаблон, который можно использовать для реализации. Здесь является подклассом  <xref:System.Windows.RoutedEventHandler> .  `MyRoutedEventHandler`  
  
 [!code-csharp[CorePseudocode#RoutedEventArgs](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#routedeventargs)]
 [!code-vb[CorePseudocode#RoutedEventArgs](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#routedeventargs)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Этот метод предназначен для переопределения производными классами данных событий, чтобы обеспечить более эффективный вызов своих делегатов. Реализация должна привести предоставленный <paramref name="genericHandler" /> к конкретному типу делегат, а затем вызвать этот обработчик.  
  
Реализация по умолчанию будет пытаться вызвать предоставленный обработчик, пытаясь привести его как <see cref="T:System.Windows.RoutedEventHandler" />. Если значение <paramref name="genericHandler" /> или <paramref name="genericTarget" /> указано как <see langword="null" />, будут вызваны исключения.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnSetSource">
      <MemberSignature Language="C#" Value="protected virtual void OnSetSource (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSetSource(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSetSource (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSetSource(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member OnSetSource : obj -&gt; unit&#xA;override this.OnSetSource : obj -&gt; unit" Usage="routedEventArgs.OnSetSource source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Новое значение, которое задается для <see cref="P:System.Windows.RoutedEventArgs.Source" />.</param>
        <summary>При переопределении в производном классе предоставляет точку входа обратного вызова для уведомления в случае изменения значения свойства <see cref="P:System.Windows.RoutedEventArgs.Source" /> в экземпляре.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Изменение сообщаемого источника события программным способом может потребовать обновления данных конкретного типа в рамках события. По этой причине <see cref="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" /> метод защищен виртуальным и предназначен для переопределения подклассами <see cref="T:System.Windows.RoutedEventArgs" />.  
  
Этот метод не имеет реализации по умолчанию.</para></block>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="OriginalSource">
      <MemberSignature Language="C#" Value="public object OriginalSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object OriginalSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalSource As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ OriginalSource { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OriginalSource : obj" Usage="System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает исходный источник отчетов, определяемый чистой проверкой нажатия до какой-либо возможной корректировки <see cref="P:System.Windows.RoutedEventArgs.Source" /> родительским классом.</summary>
        <value>Исходный источник отчетов до какой-либо возможной корректировки <see cref="P:System.Windows.RoutedEventArgs.Source" />, произведенной обработкой классов, например, с целью выравнивания деревьев элементов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство получает свое значение один раз перед вызовом обработчиков событий класса или любых обработчиков экземпляров и никогда не настраивается после этого момента. Исходные сведения об исходном источнике доступны только для чтения в обработчиках классов или реализациях классов, так же как и в данных о событиях.  
  
 В типичных случаях, когда источник может быть скорректирован, включает элементы содержимого внутри модели содержимого для элемента управления (например, содержимое элемента списка будет сообщать элементу списка как <xref:System.Windows.RoutedEventArgs.Source%2A> , а фактический элемент в элементе списка будет  <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>.  
  
 Корректировка исходного кода различными элементами и моделями содержимого отличается от класса к классу. Каждый класс, который корректирует источники событий, пытается предвидеть, какой источник является наиболее полезным для отчета о большинстве входных сценариев и сценариях, для которых предназначен класс, а затем устанавливает этот источник как <xref:System.Windows.RoutedEventArgs.Source%2A>. Если это не тот источник, который имеет отношение к обработке события, попробуйте <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> вместо этого проверить, сообщает ли он другой источник, который более подходит. Дополнительные сведения о событиях ввода см. в разделе [Общие сведения о входных](~/docs/framework/wpf/advanced/input-overview.md)данных.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="RoutedEvent">
      <MemberSignature Language="C#" Value="public System.Windows.RoutedEvent RoutedEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.RoutedEvent RoutedEvent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property RoutedEvent As RoutedEvent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::RoutedEvent ^ RoutedEvent { System::Windows::RoutedEvent ^ get(); void set(System::Windows::RoutedEvent ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RoutedEvent : System.Windows.RoutedEvent with get, set" Usage="System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает объект <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />, связанный с этим экземпляром <see cref="T:System.Windows.RoutedEventArgs" />.</summary>
        <value>Идентификатор вызванного события.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это значение нельзя задать для того <xref:System.Windows.RoutedEventArgs> , который уже был направлен (например, если аргументы получены с помощью обработчика). Попытка сделать это приведет к созданию исключения. Его можно задать только в экземпляре, который еще не использовался для создания вызова события.  
  
 Значение параметра <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> не может быть `null` в любой момент времени.  
  
   
  
## Examples  
 В следующем примере создаются новые данные перенаправленного события с исходным конструктором, а <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> затем свойство задается в качестве последующей операции. Перед вызовом <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> перенаправленного события необходимо задать значение.  
  
 [!code-csharp[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/ColorPicker_v2/CSharp/ColorPicker.cs#routedeventargsroutedevent)]
 [!code-vb[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ColorPicker_v2/visualbasic/colorpicker.vb#routedeventargsroutedevent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Попытка изменить значение <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> во время маршрутизации события.</exception>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public object Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Source { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : obj with get, set" Usage="System.Windows.RoutedEventArgs.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает ссылку на объект, создавший событие.</summary>
        <value>Объект, создавший событие.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для любой восходящей маршрутизации перенаправленного события, которое фактически прошло маршрут после элемента, вызвавшего его, и для любого туннелирование перенаправленное событие, не имеющий еще туннелируется вниз до элемента, вызвавшего его значение <xref:System.Windows.RoutedEventArgs.Source%2A> будет отличаться от значения `sender` настроек параметр класс аргументов события. Какой из двух элементов, вовлеченных в событие, является наиболее значимым для любого обработчика (<xref:System.Windows.RoutedEventArgs.Source%2A>, вызвавшего его элемент, или `sender`, элемент, который сейчас обрабатывает его), зависит от логики приложения, в которой находится обработчик. APIPA.  
  
 Задание этого свойства обычно выполняется только при переопределении или реализации другого [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] объекта, который корректирует источники событий, например при обработке события классом. Сброс видимых источников событий из обработчиков экземпляров не рекомендуется, особенно если обработчик не помечает событие как обработанное.  
  
 Если выполнить сброс <xref:System.Windows.RoutedEventArgs.Source%2A> для создания отчета о другом источнике событий <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> , будет продолжать сообщать об источнике, как это было впервые <xref:System.Windows.UIElement.RaiseEvent%2A> вызвано исходным вызовом.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.OriginalSource" />
      </Docs>
    </Member>
  </Members>
</Type>
