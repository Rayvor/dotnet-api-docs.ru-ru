<Type Name="Window" FullName="System.Windows.Window">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8c2eeb6dcd112b17489ea75ca8a7cc72e0cbb1ed" /><Meta Name="ms.sourcegitcommit" Value="a22d0855bbf24d893f43605f8b7e3a44bd9551a5" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70358573" /></Metadata><TypeSignature Language="C#" Value="public class Window : System.Windows.Controls.ContentControl" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Window extends System.Windows.Controls.ContentControl" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Window" />
  <TypeSignature Language="VB.NET" Value="Public Class Window&#xA;Inherits ContentControl" />
  <TypeSignature Language="C++ CLI" Value="public ref class Window : System::Windows::Controls::ContentControl" />
  <TypeSignature Language="F#" Value="type Window = class&#xA;    inherit ContentControl" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.ContentControl</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Ignore)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет возможность создавать, настраивать, показывать обычные и диалоговые окна, а также управлять временем их существования.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Точкой взаимодействия между пользователем и автономным приложением является окно. [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] Окно состоит из двух различных областей:  
  
-   Неклиентская область, в которой размещаются элементы оформления Windows, включая значок, заголовок, системное меню, Кнопка сворачивания, кнопка развертывания, кнопка восстановления, кнопка Закрыть и граница.  
  
-   Клиентская область, в которой размещается содержимое для конкретного приложения.  
  
 На следующем рисунке показано стандартное окно.  
  
 ![Элементы окна] (~/add/media/windowoverviewfigure1.PNG "Элементы окна")  
  
 <xref:System.Windows.Window>инкапсулирует возможность создания, настройки, отображения и управления временем существования окон и диалоговых окон, а также предоставляет следующие ключевые службы:  
  
 **Управление жизненным циклом** <xref:System.Windows.Window.Activate%2A>: <xref:System.Windows.Window.Close%2A> <xref:System.Windows.Window.Activated> <xref:System.Windows.Window.Closed> ,,<xref:System.Windows.Window.Deactivated>,, ,,<xref:System.Windows.Window.Hide%2A> ,<xref:System.Windows.Window.SourceInitialized>,,. <xref:System.Windows.Window.IsActive%2A> <xref:System.Windows.Window.Closing> <xref:System.Windows.Window.Show%2A>  
  
 **Управление окнами**: <xref:System.Windows.Window.GetWindow%2A>, <xref:System.Windows.Window.OwnedWindows%2A>, <xref:System.Windows.Window.Owner%2A>.  
  
 **Внешний вид и поведение** <xref:System.Windows.Window.AllowsTransparency%2A>: <xref:System.Windows.Window.ContentRendered>, <xref:System.Windows.Window.DragMove%2A>, <xref:System.Windows.Window.Icon%2A>, ,<xref:System.Windows.Window.Left%2A>, ,<xref:System.Windows.Window.ResizeMode%2A>, ,<xref:System.Windows.Window.ShowInTaskbar%2A>,,, <xref:System.Windows.Window.ShowActivated%2A> <xref:System.Windows.Window.RestoreBounds%2A> <xref:System.Windows.Window.LocationChanged> <xref:System.Windows.Window.SizeToContent%2A> <xref:System.Windows.Window.StateChanged> , <xref:System.Windows.Window.Title%2A>, <xref:System.Windows.Window.Top%2A>, <xref:System.Windows.Window.Topmost%2A>, <xref:System.Windows.Window.WindowStartupLocation%2A>, <xref:System.Windows.Window.WindowState%2A>,<xref:System.Windows.Window.WindowStyle%2A>  
  
 **Диалоговые окна** <xref:System.Windows.Window.DialogResult%2A>: <xref:System.Windows.Window.ShowDialog%2A>,.  
  
 Кроме того <xref:System.Windows.Application> , предоставляет специальную поддержку управления всеми окнами в приложении:  
  
-   Приложение поддерживает список всех окон, экземпляры которых в настоящее время созданы в приложении. Этот список предоставляется <xref:System.Windows.Application.Windows%2A> свойством.  
  
-   По умолчанию <xref:System.Windows.Application.MainWindow%2A> автоматически устанавливается ссылка на первый <xref:System.Windows.Window> экземпляр, который создается в приложении. Таким образом, это делает окно основным окном приложения.  
  
 <xref:System.Windows.Window> Можно реализовать с помощью разметки, разметки и кода программной части или кода.  
  
 <xref:System.Windows.Window>в основном используется для вывода окон и диалоговых окон для автономных приложений. Однако для приложений, требующих навигации на уровне окна, таких как мастера, можно использовать <xref:System.Windows.Navigation.NavigationWindow> вместо него. является производным <xref:System.Windows.Window> от и расширяет его с помощью поддержки навигации в стиле браузера. <xref:System.Windows.Navigation.NavigationWindow>  
  
> [!NOTE]
>  Острова содержимого, доступного для навигации, можно включить в другое содержимое и <xref:System.Windows.Controls.Frame>контейнеры содержимого с помощью.  
  
 <xref:System.Windows.Window>требуется `UnmanagedCode` разрешение безопасности для создания экземпляра. Это имеет следующие последствия.  
  
-   [!INCLUDE[TLA#tla_clickonce](~/includes/tlasharptla-clickonce-md.md)]— развернутые автономные приложения запрашивают повышение прав при запуске из зон Интернета или локальной интрасети.  
  
-   [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)]Этот запрос не сможет создать экземпляры окон или диалоговых окон, которые меньше, чем полные разрешения.  
  
 Сведения о развертывании автономных приложений и вопросах безопасности см. в разделе [стратегия безопасности WPF — безопасность платформы](~/docs/framework/wpf/wpf-security-strategy-platform-security.md).  
  
 <xref:System.Windows.Window> Объект<xref:System.Windows.Controls.ContentControl>— это, что означает, что он может содержать один объект любого типа (например, строку, изображение или панель). Дополнительные сведения см. в описании класса <xref:System.Windows.Controls.ContentControl>. Кроме того <xref:System.Windows.Window> , является корневым элементом и, следовательно, не может быть частью содержимого другого элемента.  
  
> [!NOTE]
>  <xref:System.Windows.FrameworkElement.Width%2A>Свойства,, и,<xref:System.Windows.Window.Left%2A> заданные в<xref:System.Windows.Window> , с помощью стиля не будут применяться во время выполнения. <xref:System.Windows.Window.Top%2A> <xref:System.Windows.FrameworkElement.Height%2A>  
  
## <a name="customizing-the-window-control"></a>Настройка элемента управления "окно"  
 Чтобы применить одни и те же параметры свойств <xref:System.Windows.Window> к нескольким элементам управления <xref:System.Windows.FrameworkElement.Style%2A> , используйте свойство. Можно изменить значение по умолчанию <xref:System.Windows.Controls.ControlTemplate> , чтобы обеспечить уникальность внешнего вида элемента управления. Дополнительные сведения о создании <xref:System.Windows.Controls.ControlTemplate>см. в разделе [Настройка внешнего вида существующего элемента управления путем создания объекта ControlTemplate](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md).  Для просмотра частей и состояний, относящихся <xref:System.Windows.Window>к, см. раздел [стили и шаблоны окна](~/docs/framework/wpf/controls/window-styles-and-templates.md).  
  
 Свойства зависимостей для этого элемента управления могут быть установлены стилем элемента управления по умолчанию.  Если свойство задано стилем по умолчанию, свойство может измениться по умолчанию, когда элемент управления появится в приложении. Стиль по умолчанию определяется тем, какая тема рабочего стола используется при запуске приложения.  Дополнительные сведения см. в разделе [темы WPF по умолчанию](https://go.microsoft.com/fwlink/?LinkID=158252).  
  
[!INCLUDE[setting-a-visual-property](~/includes/visual-property-note.md)]  
  
## Examples  
 В следующем примере показано, как стандартное окно определяется с использованием только разметки:  
  
 [!code-xaml[WindowSnippets#WindowMARKUPONLY](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MarkupOnlyWindow.xaml#windowmarkuponly)]  
  
 В следующем примере показано, как стандартное окно определяется с использованием только кода:  
  
 [!code-csharp[WindowSnippets#WindowCODEONLY](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/CodeOnlyWindow.cs#windowcodeonly)]
 [!code-vb[WindowSnippets#WindowCODEONLY](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowSnippets/visualbasic/codeonlywindow.vb#windowcodeonly)]  
  
 В следующем примере показано, как определяется стандартное окно с помощью сочетания разметки и кода программной части.  
  
 [!code-xaml[WindowSnippets#WindowXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MainWindow.xaml#windowxaml)]  
  
 [!code-csharp[WindowSnippets#WindowCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MainWindow.xaml.cs#windowcodebehind)]
 [!code-vb[WindowSnippets#WindowCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowSnippets/visualbasic/mainwindow.xaml.vb#windowcodebehind)]  
  
 ]]></format>
    </remarks>
    <altmember cref="M:System.Windows.Window.Show" />
    <altmember cref="M:System.Windows.Window.ShowDialog" />
    <altmember cref="P:System.Windows.Window.DialogResult" />
    <altmember cref="T:System.Windows.Application" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Window ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Window();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.Window" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Конструктор <xref:System.Windows.FrameworkElement.Width%2A>инициализирует свойства, <xref:System.Windows.Window.Top%2A> <xref:System.Windows.FrameworkElement.Height%2A>, и <xref:System.Windows.Window.Left%2A> в значения по умолчанию <xref:System.Windows.Window> .  
  
 Если окно <xref:System.AppDomain> создается внутри <xref:System.Windows.Application> объекта, имеющего объект <xref:System.Windows.Window> , конструктор добавляет объект в набор <xref:System.Windows.Application>управляемых окон с помощью <xref:System.Windows.Application.Windows%2A> свойства <xref:System.Windows.Application> объекта.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">разрешение на вызов ненадежных методов машинного кода для этого объекта. Связанное перечисление:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Activate">
      <MemberSignature Language="C#" Value="public bool Activate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Activate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Activate" />
      <MemberSignature Language="VB.NET" Value="Public Function Activate () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Activate();" />
      <MemberSignature Language="F#" Value="member this.Activate : unit -&gt; bool" Usage="window.Activate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Пытается переместить окно на передний план и активирует его.</summary>
        <returns><see langword="true" />, если окно <see cref="T:System.Windows.Window" /> было успешно активировано; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Правила, определяющие, активируется ли окно, совпадают с правилами, используемыми [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] `SetForegroundWindow` функцией (User32. dll).  
  
 Если окно активируется в Windows Presentation Foundation приложении, которое не является приложением переднего плана пользователя, <xref:System.Windows.Application.Activated> возникает событие.  
  
> [!NOTE]
>  Этот метод не может быть вызван, если окно размещается в браузере.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">разрешение на активацию окна. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Activated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Activated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Activated;" />
      <MemberSignature Language="F#" Value="member this.Activated : EventHandler " Usage="member this.Activated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при выведении окна на передний план.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Окно активируется (становится окном переднего плана) в следующих случаях:  
  
-   Окно сначала открывается.  
  
-   Пользователь переключается в окно, выбирая его с помощью мыши, нажимая клавиши ALT + TAB или из диспетчера задач.  
  
-   Пользователь нажимает кнопку на панели задач в окне.  
  
 Windows, которая должна определить, когда они становятся активными, могут <xref:System.Windows.Window.Activated> справиться с этим событием.  
  
 После первой активации окна оно может быть деактивировано и повторно активировано много раз во время его существования. Если поведение или состояние приложения зависит от состояния активации, оно может проверить <xref:System.Windows.Window.IsActive%2A> , установлено ли состояние активации.  
  
 Приложение может также иметь <xref:System.Windows.Application.Activated>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Deactivated" />
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="AllowsTransparency">
      <MemberSignature Language="C#" Value="public bool AllowsTransparency { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowsTransparency" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.AllowsTransparency" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowsTransparency As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowsTransparency { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowsTransparency : bool with get, set" Usage="System.Windows.Window.AllowsTransparency" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, поддерживает ли клиентская область окна прозрачность.</summary>
        <value><see langword="true" />, если окно поддерживает прозрачность; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если свойству окна присвоено значение прозрачного цвета, то при <xref:System.Windows.Media.Brushes.Transparent%2A> использовании, например, окно остается непрозрачным. <xref:System.Windows.Controls.Control.Background%2A> Это означает, что рабочий стол и все работающие приложения под окном не видны. Чтобы включить этот тип прозрачности, <xref:System.Windows.Window.AllowsTransparency%2A> необходимо `true`задать значение.  
  
 <xref:System.Windows.Window.AllowsTransparency%2A>существует для упрощения создания непрямоугольных окон, и, следовательно <xref:System.Windows.Window.AllowsTransparency%2A> , когда <xref:System.Windows.Window.WindowStyle%2A> свойство имеет `true`значение, свойству окна необходимо присвоить значение <xref:System.Windows.WindowStyle.None>.  
  
<a name="dependencyPropertyInfo_WindowAllowsTransparency"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Window.AllowsTransparencyProperty>|  
|Свойства метаданных, для которых задано значение`true`|Нет|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Окно, значение свойства <see cref="P:System.Windows.Window.WindowStyle" /> которого отлично от <see cref="F:System.Windows.WindowStyle.None" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AllowsTransparencyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AllowsTransparencyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AllowsTransparencyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.AllowsTransparencyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AllowsTransparencyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AllowsTransparencyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AllowsTransparencyProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.AllowsTransparencyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Window.AllowsTransparency" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size ArrangeOverride (System.Windows.Size arrangeBounds);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size arrangeBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ArrangeOverride (arrangeBounds As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size ArrangeOverride(System::Windows::Size arrangeBounds);" />
      <MemberSignature Language="F#" Value="override this.ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="window.ArrangeOverride arrangeBounds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrangeBounds" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="arrangeBounds">Объект <see cref="T:System.Windows.Size" />, отражающий окончательный размер, который следует использовать окну для упорядочения себя и своих дочерних окон.</param>
        <summary>Переопределив данный метод, можно упорядочить окно и его дочерние элементы, а также изменить их размер.</summary>
        <returns>Объект <see cref="T:System.Windows.Size" />, отражающий фактический размер, который использовался.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.ArrangeOverride%2A>метод не вызывается, <xref:System.Windows.UIElement.Visibility%2A> если свойство имеет <xref:System.Windows.Visibility.Collapsed>значение. Если значение <xref:System.Windows.UIElement.Visibility%2A> свойства <xref:System.Windows.Visibility.Hidden> равно или <xref:System.Windows.Visibility.Visible>, <xref:System.Windows.Window.ArrangeOverride%2A> то вызывается.  
  
> [!NOTE]
>  <xref:System.Windows.Window.ShowDialog%2A> <xref:System.Windows.UIElement.Visibility%2A> <xref:System.Windows.Visibility.Visible>При вызове метода <xref:System.Windows.Window.Show%2A> или<xref:System.Windows.Window> , свойству присваивается значение.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="window.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вручную закрывает окно <see cref="T:System.Windows.Window" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window> Можно закрыть с помощью одного из нескольких хорошо известных, предоставляемых системой механизмов, расположенных в его заголовке, в том числе:  
  
-   ALT + F4.  
  
-   &#124; **Закрыть**системное меню.  
  
-   Кнопка " **Закрыть** ".  
  
 Также <xref:System.Windows.Window> можно закрыть с помощью одного из нескольких хорошо известных механизмов в клиентской области, предоставляемых разработчиками, включая:  
  
-   **Файл** &#124; **Выход из** главного окна.  
  
-   **Файл** &#124; Кнопка **"Закрыть" или "** **Закрыть** " в дочернем окне.  
  
> [!NOTE]
>  Кнопки **ОК** и **Отмена** в диалоговом окне также предоставляются разработчиками, хотя, скорее всего, <xref:System.Windows.Window.DialogResult%2A>будет установлено, которое автоматически закроет окно, открытое <xref:System.Windows.Window.ShowDialog%2A>при вызове.  
  
 Эти механизмы потребовали явного вызова <xref:System.Windows.Window.Close%2A> для закрытия окна.  
  
> [!NOTE]
>  Если окно, открытое путем вызова <xref:System.Windows.Window.ShowDialog%2A>, и <xref:System.Windows.Controls.Button> со <xref:System.Windows.Controls.Button.IsCancel%2A> свойством, для которого задано значение true, автоматически закроется при нажатии кнопки, или если нажать клавишу ESC. Если окно было открыто с помощью <xref:System.Windows.Window.Show%2A>, <xref:System.Windows.Window.Close%2A> необходимо явно вызвать метод, например <xref:System.Windows.Controls.Button>из <xref:System.Windows.Controls.Primitives.ButtonBase.Click> обработчика событий для.  
  
 Закрытие окна приводит <xref:System.Windows.Window.Closing> к возникновению события. <xref:System.Windows.Window.Closing> Если событие не отменено, происходит следующее:  
  
-   Удаляется из <xref:System.Windows.Application.Windows%2A?displayProperty=nameWithType> (если <xref:System.Windows.Application> объект существует). <xref:System.Windows.Window>  
  
-   Удаляется из владельца <xref:System.Windows.Window> , если отношение владельца и владелец <xref:System.Windows.Window> было установлено до того, как было отображено и после открытия владельца <xref:System.Windows.Window>. <xref:System.Windows.Window>  
  
-   Возникает событие <xref:System.Windows.Window.Closed>.  
  
-   Неуправляемые ресурсы, созданные объектом <xref:System.Windows.Window> , уничтожаются.  
  
-   Если <xref:System.Windows.Window.ShowDialog%2A> был вызван для <xref:System.Windows.Window>отображения, <xref:System.Windows.Window.ShowDialog%2A> возвращает.  
  
 При закрытии <xref:System.Windows.Window> вызывается закрытие всех окон, которыми он владеет. Кроме того, закрытие <xref:System.Windows.Window> может привести к прекращению работы приложения в зависимости от того, <xref:System.Windows.Application.ShutdownMode%2A?displayProperty=nameWithType> как это свойство задано.  
  
> [!NOTE]
>  Этот метод не может быть вызван, если окно размещается в браузере.  
  
   
  
## Examples  
 В следующем примере показано меню **** &#124; **выхода из** файла, обрабатываемое для явного <xref:System.Windows.Window.Close%2A>вызова.  
  
 [!code-xaml[WindowCloseSnippets#WindowCloseXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowCloseSnippets/CSharp/MainWindow.xaml#windowclosexaml)]  
  
 [!code-csharp[WindowCloseSnippets#WindowCloseCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowCloseSnippets/CSharp/MainWindow.xaml.cs#windowclosecodebehind)]
 [!code-vb[WindowCloseSnippets#WindowCloseCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowCloseSnippets/visualbasic/mainwindow.xaml.vb#windowclosecodebehind)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">разрешение на использование всех окон и событий ввода данных пользователем без ограничений. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Window.Show" />
        <altmember cref="M:System.Windows.Window.ShowDialog" />
        <altmember cref="P:System.Windows.Window.DialogResult" />
        <altmember cref="P:System.Windows.Window.Owner" />
        <altmember cref="P:System.Windows.Window.OwnedWindows" />
      </Docs>
    </Member>
    <Member MemberName="Closed">
      <MemberSignature Language="C#" Value="public event EventHandler Closed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Closed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Closed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Closed;" />
      <MemberSignature Language="F#" Value="member this.Closed : EventHandler " Usage="member this.Closed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда окно готово к закрытию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 После возникновения этого события окно не может быть закрыто.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Задано свойство <see cref="P:System.Windows.UIElement.Visibility" /> либо вызван один из методов <see cref="M:System.Windows.Window.Show" />, <see cref="M:System.Windows.Window.ShowDialog" /> или <see cref="M:System.Windows.Window.Hide" /> во время закрытия окна.</exception>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="E:System.Windows.Window.Closing" />
        <altmember cref="M:System.Windows.Application.Shutdown" />
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.SessionEnding" />
      </Docs>
    </Member>
    <Member MemberName="Closing">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CancelEventHandler Closing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CancelEventHandler Closing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Closing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closing As CancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::CancelEventHandler ^ Closing;" />
      <MemberSignature Language="F#" Value="member this.Closing : System.ComponentModel.CancelEventHandler " Usage="member this.Closing : System.ComponentModel.CancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит непосредственно после вызова метода <see cref="M:System.Windows.Window.Close" /> и может быть обработано с отменой закрытия окна.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.Closing>может обрабатываться для обнаружения закрытия окна (например, при <xref:System.Windows.Window.Close%2A> вызове). Кроме того <xref:System.Windows.Window.Closing> , можно использовать, чтобы предотвратить закрытие окна. Чтобы предотвратить закрытие окна, можно присвоить <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> свойству <xref:System.ComponentModel.CancelEventArgs> аргумента `true`значение.  
  
 Событие возникает при <xref:System.Windows.Window.Close%2A> вызове, если нажата кнопка закрытия окна или если пользователь нажмет Alt + F4. <xref:System.Windows.Window.Closing>  
  
 Если принадлежащее окно было открыто окном-владельцем <xref:System.Windows.Window.Show%2A>с помощью, а окно владельца закрыто, <xref:System.Windows.Window.Closing> событие принадлежащего окна не вызывается. Если владелец окна закрыт (см. раздел <xref:System.Windows.Window.Owner%2A>), <xref:System.Windows.Window.Closing> в принадлежащем окне не создается.  
  
 При <xref:System.Windows.Application.Shutdown%2A> вызове метода <xref:System.Windows.Window.Closing> вызывается событие для каждого окна. Однако если <xref:System.Windows.Window.Closing> операция отменена, то отмена игнорируется.  
  
 Значение, если сеанс завершается из-за того, что пользователь <xref:System.Windows.Window.Closing> выходит из системы или завершает <xref:System.Windows.Application.SessionEnding> работу, не вызывается; обрабатывается для реализации кода, который отменяет закрытие приложения.  
  
 Если вы хотите отображать и скрывать окно несколько раз в течение всего времени существования приложения и вы не хотите повторно создавать экземпляры окна при каждом его отображении, можно <xref:System.Windows.Window.Closing> обойти событие, отменить его и <xref:System.Windows.Window.Hide%2A> вызвать метод. Затем можно вызвать <xref:System.Windows.Window.Show%2A> в том же экземпляре, чтобы снова открыть его.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Windows.Window> , что определяет, требуется ли для закрытия вмешательство пользователя.  
  
 [!code-xaml[WindowClosingSnippets#WindowClosingXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowClosingSnippets/CSharp/DataWindow.xaml#windowclosingxaml1)]  
  
 [!code-csharp[WindowClosingSnippets](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowClosingSnippets/CSharp/DataWindow.xaml.cs)]
 [!code-vb[WindowClosingSnippets](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowClosingSnippets/visualbasic/datawindow.xaml.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Задано свойство <see cref="P:System.Windows.UIElement.Visibility" /> либо вызван один из методов <see cref="M:System.Windows.Window.Show" />, <see cref="M:System.Windows.Window.ShowDialog" /> или <see cref="M:System.Windows.Window.Close" /> во время закрытия окна.</exception>
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="E:System.Windows.Window.Closed" />
      </Docs>
    </Member>
    <Member MemberName="ContentRendered">
      <MemberSignature Language="C#" Value="public event EventHandler ContentRendered;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ContentRendered" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.ContentRendered" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContentRendered As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ContentRendered;" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="F#" Value="member this.ContentRendered : EventHandler " Usage="member this.ContentRendered : System.EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ ContentRendered;" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит после завершения отображения содержимого окна.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если окно не содержит содержимого, это событие не возникает.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.ContentControl.Content" />
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Deactivated">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Deactivated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deactivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Deactivated;" />
      <MemberSignature Language="F#" Value="member this.Deactivated : EventHandler " Usage="member this.Deactivated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при перемещении окна на задний план.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Окно деактивируется (становится фоновым окном) в следующих случаях:  
  
-   Пользователь переключается на другое окно в текущем приложении.  
  
-   Пользователь переключается на окно в другом приложении, используя сочетание клавиш ALT + TAB или диспетчер задач.  
  
-   Пользователь нажимает кнопку на панели задач для окна в другом приложении.  
  
 Окна, для которых необходимо определить, когда они становятся деактивированными, <xref:System.Windows.Window.Deactivated> обрабатывая событие.  
  
 После первой деактивации окна оно может быть повторно активировано и деактивировано много раз во время его существования. Если поведение или состояние приложения зависит от состояния активации, оно может проверить <xref:System.Windows.Window.IsActive%2A> , установлено ли состояние активации.  
  
 Приложение может также иметь <xref:System.Windows.Application.Deactivated>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="DialogResult">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; DialogResult { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;bool&gt; DialogResult" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.DialogResult" />
      <MemberSignature Language="VB.NET" Value="Public Property DialogResult As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Nullable&lt;bool&gt; DialogResult { Nullable&lt;bool&gt; get(); void set(Nullable&lt;bool&gt; value); };" />
      <MemberSignature Language="F#" Value="member this.DialogResult : Nullable&lt;bool&gt; with get, set" Usage="System.Windows.Window.DialogResult" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.DialogResultConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает результирующее значение диалоговое окна, то есть значение, которое будет возвращено методом <see cref="M:System.Windows.Window.ShowDialog" />.</summary>
        <value>Значение <see cref="T:System.Nullable`1" /> типа <see cref="T:System.Boolean" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.DialogResult%2A>можно использовать из кода, который показал диалоговое окно, чтобы определить, принял ли пользователь (`true`) или отменил`false`() это диалоговое окно. Если диалоговое окно было принято, это означает код, который открыл диалоговое окно для получения данных, собранных пользователем, и его обработки. Однако если диалоговое окно было отменено, это означает, что вызывающий код должен закончить дальнейшую обработку.  
  
 По умолчанию диалоговое окно отменяется, когда пользователь выполняет одно из следующих действий:  
  
-   Прессесалт + F4.  
  
-   Нажатие кнопки **Закрыть** .  
  
-   Выбирает пункт **Закрыть** в системном меню.  
  
 Во всех этих случаях <xref:System.Windows.Window.DialogResult%2A> по умолчанию имеет значение. `false`  
  
 Диалоговое окно обычно предоставляет специальную кнопку для отмены диалогового окна, которое является кнопкой, <xref:System.Windows.Controls.Button.IsCancel%2A> свойство которой имеет `true`значение. Кнопка, настроенная таким образом, автоматически закрывает окно при нажатии или при нажатии клавиши ESC. В любом из этих случаев <xref:System.Windows.Window.DialogResult%2A> остается. `false`  
  
 Диалоговое окно также обычно содержит кнопку принять, которая является кнопкой, свойство которой <xref:System.Windows.Controls.Button.IsDefault%2A> имеет `true`значение. Кнопка, настроенная таким образом, вызывает <xref:System.Windows.Controls.Primitives.ButtonBase.Click> событие при нажатии клавиши ВВОД. Однако он не закроет диалоговое окно автоматически и не будет иметь значение <xref:System.Windows.Window.DialogResult%2A>. `true` Необходимо вручную написать этот код, обычно из <xref:System.Windows.Controls.Primitives.ButtonBase.Click> обработчика событий для кнопки по умолчанию.  
  
 <xref:System.Windows.Window.DialogResult%2A>имеет `null` значение, если диалоговое окно отображается, но ни одно из них не принято или отменено.  
  
 После закрытия диалогового окна можно получить результат диалогового окна из значения, возвращаемого <xref:System.Windows.Window.ShowDialog%2A> методом, или путем проверки <xref:System.Windows.Window.DialogResult%2A> свойства.  
  
 <xref:System.Windows.Window.DialogResult%2A>может быть задан только при <xref:System.Windows.Window> открытии с помощью вызова его <xref:System.Windows.Window.ShowDialog%2A> метода.  
  
> [!NOTE]
>  Невозможно задать или получить это свойство, если окно размещается в браузере.  
  
   
  
## Examples  
 В следующем примере показано, как настроить кнопку ОК и кнопку Отмена для возврата соответствующего <xref:System.Windows.Window.DialogResult%2A>значения.  
  
 [!code-xaml[WindowDialogResultSnippets#WindowDialogResultXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDialogResultSnippets/CSharp/DialogBox.xaml#windowdialogresultxaml)]  
  
 [!code-csharp[WindowDialogResultSnippets#WindowDialogResultCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDialogResultSnippets/CSharp/DialogBox.xaml.cs#windowdialogresultcodebehind)]
 [!code-vb[WindowDialogResultSnippets#WindowDialogResultCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowDialogResultSnippets/visualbasic/dialogbox.xaml.vb#windowdialogresultcodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Windows.Window.DialogResult" /> задан, до того как окно открывается путем вызова <see cref="M:System.Windows.Window.ShowDialog" />.  
  
- или - 
 <see cref="P:System.Windows.Window.DialogResult" /> задан для окна, которое открывается путем вызова <see cref="M:System.Windows.Window.Show" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DpiChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DpiChangedEventHandler DpiChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DpiChangedEventHandler DpiChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.DpiChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DpiChanged As DpiChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DpiChangedEventHandler ^ DpiChanged;" />
      <MemberSignature Language="F#" Value="member this.DpiChanged : System.Windows.DpiChangedEventHandler " Usage="member this.DpiChanged : System.Windows.DpiChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DpiChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит после изменения значения DPI для экрана, на котором отображается Window.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DpiChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DpiChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DpiChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.DpiChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DpiChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DpiChangedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DpiChangedEvent : System.Windows.RoutedEvent" Usage="System.Windows.Window.DpiChangedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.RoutedEvent" />, если разрешение (DPI) экрана Window изменяется.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragMove">
      <MemberSignature Language="C#" Value="public void DragMove ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DragMove() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.DragMove" />
      <MemberSignature Language="VB.NET" Value="Public Sub DragMove ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DragMove();" />
      <MemberSignature Language="F#" Value="member this.DragMove : unit -&gt; unit" Usage="window.DragMove " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Позволяет перетаскивать окно мышью с зажатой левой кнопкой над открытой частью клиентской области окна.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При <xref:System.Windows.Window.DragMove%2A> вызове левая кнопка мыши должна быть нажата. Один из способов обнаружить, что нажата левая кнопка мыши, — это обработайте <xref:System.Windows.UIElement.MouseLeftButtonDown> событие.  
  
 При <xref:System.Windows.Window.DragMove%2A> вызове метода левая кнопка мыши должна быть нажата над видимой областью клиентской области окна.  
  
> [!NOTE]
>  Этот метод не может быть вызван, если окно размещается в браузере.  
  
   
  
## Examples  
 В следующем примере показано, как переопределить <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> для вызова <xref:System.Windows.Window.DragMove%2A>.  
  
 [!code-csharp[WindowDragMoveSnippets#CallWindowDragMoveCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDragMoveSnippets/CSharp/MainWindow.xaml.cs#callwindowdragmovecodebehind)]
 [!code-vb[WindowDragMoveSnippets#CallWindowDragMoveCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowDragMoveSnippets/visualbasic/mainwindow.xaml.vb#callwindowdragmovecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Левая кнопка мыши не нажата.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">разрешение на перетаскивание окна. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="E:System.Windows.Window.LocationChanged" />
      </Docs>
    </Member>
    <Member MemberName="GetWindow">
      <MemberSignature Language="C#" Value="public static System.Windows.Window GetWindow (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Window GetWindow(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.GetWindow(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Window ^ GetWindow(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="static member GetWindow : System.Windows.DependencyObject -&gt; System.Windows.Window" Usage="System.Windows.Window.GetWindow dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">Объект зависимостей.</param>
        <summary>Возвращает ссылку на объект <see cref="T:System.Windows.Window" />, содержащий дерево содержимого, в котором расположен объект зависимостей.</summary>
        <returns>Ссылка <see cref="T:System.Windows.Window" /> на окно-хранилище.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="dependencyObject" /> имеет значение null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Hide">
      <MemberSignature Language="C#" Value="public void Hide ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Hide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Hide" />
      <MemberSignature Language="VB.NET" Value="Public Sub Hide ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Hide();" />
      <MemberSignature Language="F#" Value="member this.Hide : unit -&gt; unit" Usage="window.Hide " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Делает окно невидимым.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Окно не закрывается, когда оно скрыто, и не возникает <xref:System.Windows.Window.Closing> ни <xref:System.Windows.Window.Closed> одно событие или. Вместо этого <xref:System.Windows.UIElement.Visibility%2A> свойству окна присваивается <xref:System.Windows.Visibility.Hidden?displayProperty=nameWithType>значение.  
  
 Если окно является приложением <xref:System.Windows.Application.MainWindow%2A> , а <xref:System.Windows.Application.ShutdownMode%2A> приложение — <xref:System.Windows.ShutdownMode.OnMainWindowClose>, приложение не завершит работу. Аналогичным образом приложение не завершает работу, если окно является единственным окном, а режим завершения работы приложения — <xref:System.Windows.ShutdownMode.OnLastWindowClose>.  
  
 Если вы хотите отображать и скрывать окно несколько раз в течение всего времени существования приложения и вы не хотите повторно создавать экземпляр окна при каждом его отображении, можно <xref:System.Windows.Window.Closing> обойти событие, отменить его и <xref:System.Windows.Window.Hide%2A> вызвать метод. Затем можно вызвать <xref:System.Windows.Window.Show%2A> в том же экземпляре, чтобы снова открыть его.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Windows.Window.Hide" /> вызывается для окна, которое закрывается (<see cref="E:System.Windows.Window.Closing" />) или закрыто (<see cref="E:System.Windows.Window.Closed" />).</exception>
        <altmember cref="M:System.Windows.Window.Show" />
        <altmember cref="M:System.Windows.Window.ShowDialog" />
        <altmember cref="M:System.Windows.Window.Close" />
      </Docs>
    </Member>
    <Member MemberName="Icon">
      <MemberSignature Language="C#" Value="public System.Windows.Media.ImageSource Icon { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.ImageSource Icon" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Icon" />
      <MemberSignature Language="VB.NET" Value="Public Property Icon As ImageSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::ImageSource ^ Icon { System::Windows::Media::ImageSource ^ get(); void set(System::Windows::Media::ImageSource ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Icon : System.Windows.Media.ImageSource with get, set" Usage="System.Windows.Window.Icon" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.ImageSource</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение или установка значка окна.</summary>
        <value>Объект <see cref="T:System.Windows.Media.ImageSource" />, представляющий значок.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Изолированные приложения Windows Presentation Foundation (WPF) имеют два типа значков:  
  
-   Один значок сборки, который задается с помощью `<ApplicationIcon>` свойства в файле сборки проекта приложения. Этот значок используется в качестве значка на рабочем столе для сборки.  
  
    > [!NOTE]
    >  При отладке в Visual Studio значок может не отображаться из-за ведущего процесса. Если запустить исполняемый файл, появится значок. Дополнительные сведения см. в статье [Ведущий процесс (vshost.exe)](https://msdn.microsoft.com/library/c6b9e2be-f18d-4d75-ac52-56d55784734b).  
  
-   Один значок на каждое окно, заданное параметром <xref:System.Windows.Window.Icon%2A>. Для каждого окна этот значок используется в строке заголовка, на кнопке панели задач, а также в записи списка выбора приложения с ALT-TAB.  
  
 Окно WPF всегда отображает значок. Если он не предоставляется параметром <xref:System.Windows.Window.Icon%2A>, WPF выбирает отображаемый значок на основе следующих правил:  
  
1.  Используйте значок сборки, если он указан.  
  
2.  Если значок сборки не указан, используйте значок Microsoft Windows по умолчанию.  
  
 При использовании <xref:System.Windows.Window.Icon%2A> для указания пользовательского значка окна можно восстановить значок приложения по умолчанию, задав <xref:System.Windows.Window.Icon%2A> для `null`значение.  
  
 Один значок может использоваться различными способами в Windows, включая отображение в заголовке окна, панель задач для окна, список выбора файлов ALT + TAB. Каждый из них показывает значок, используя другой размер; значок размером 16x16 пикселей отображается в заголовке окна и на панели задач, а значок размером 32x32 пикселя отображается в списке выбора файлов ALT + TAB. Некоторые приложения, например [!INCLUDE[TLA#tla_winexpl](~/includes/tlasharptla-winexpl-md.md)], предоставляют меню « **вид** », позволяющее выбрать размер значка, который вы хотите просмотреть.  
  
 Для использования различных размеров изображения файл значка состоит из одного или нескольких фактических значков, каждый из которых представляет версию значка, предназначенную для определенного размера и глубины цвета. Например, один значок может иметь только один значок 16x16 пикселей с 16 цветами, а другой может содержать значки размером 16x16 пикселей и 32x32 пикселей с 16 цветами и 256 цветами.  
  
 Если значки для всех возможных размеров и глубины цвета существуют в файле значка, <xref:System.Windows.Window> будет использоваться соответствующий значок. Если файл значка содержит только подмножество всех возможных значков, <xref:System.Windows.Window> использует следующий наиболее подходящий значок в порядке уменьшения размеров и глубины цвета.  
  
 В результате всегда будет использоваться <xref:System.Windows.Window>значок, хотя используемый значок может не соответствовать требуемому размеру и глубине цвета. Например, значок 16x16 пикселей с 16 цветами может использоваться для вывода в виде значка размером 32x32 пикселя с 256 цветами. Это может привести к нежелательным визуальным эффектам, таким как пиксилатион, но их можно избежать, создав значки для всех целевых размеров и глубины цвета.  
  
> [!NOTE]
>  Невозможно задать или получить это свойство, если окно размещается в браузере.  
  
<a name="dependencyPropertyInfo_WindowIcon"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Window.IconProperty>|  
|Свойства метаданных, для которых задано значение`true`|Нет|  
  
   
  
## Examples  
 В следующем примере показано, как задать значок окна.  
  
 [!code-xaml[WindowIconSnippets#WindowIconSetXAML](~/samples/snippets/xaml/VS_Snippets_Wpf/WindowIconSnippets/XAML/MainWindow.xaml#windowiconsetxaml)]  
  
 [!code-csharp[WindowIconSnippets#SetWindowIconInCode](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowIconSnippets/CSharp/MainWindow.xaml.cs#setwindowiconincode)]
 [!code-vb[WindowIconSnippets#SetWindowIconInCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowIconSnippets/visualbasic/mainwindow.xaml.vb#setwindowiconincode)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">разрешение на установку значка. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IconProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IconProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IconProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.IconProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IconProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IconProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IconProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.IconProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Window.Icon" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsActive">
      <MemberSignature Language="C#" Value="public bool IsActive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsActive" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.IsActive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsActive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsActive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsActive : bool" Usage="System.Windows.Window.IsActive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, активно ли окно.</summary>
        <value><see langword="true" />, если окно активно; в противном случае — <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Активное окно — это текущее окно переднего плана пользователя с фокусом, которое обозначает активный внешний вид заголовка окна. Активное окно также будет самым верхним из всех окон верхнего уровня, не заданным <xref:System.Windows.Window.Topmost%2A> свойством явным образом.  
  
<a name="dependencyPropertyInfo_WindowIsActive"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Window.IsActiveProperty>|  
|Свойства метаданных, для которых задано значение`true`|Нет|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="IsActiveProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsActiveProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsActiveProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.IsActiveProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsActiveProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsActiveProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsActiveProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.IsActiveProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Window.IsActive" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Left">
      <MemberSignature Language="C#" Value="public double Left { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Left" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Left" />
      <MemberSignature Language="VB.NET" Value="Public Property Left As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Left { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Left : double with get, set" Usage="System.Windows.Window.Left" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает позицию левого края окна относительно рабочего стола.</summary>
        <value>Позиция левого края окна в логических единицах (1/96 дюйма).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда разворачивается или свернется, это значение представляет собой левый конец точки восстановления <xref:System.Windows.Window>для. <xref:System.Windows.Window>  
  
 Это свойство нельзя задать с помощью стиля.  
  
 Если значение не указано, <xref:System.Windows.Window.Left%2A> задается системное значение по умолчанию. Можно также указать системное значение по умолчанию, <xref:System.Windows.Window.Left%2A> задав <xref:System.Double.NaN>для значения. Ни <xref:System.Double.NegativeInfinity> значение <xref:System.Double.PositiveInfinity> , ни не является допустимым значением для <xref:System.Windows.Window.Left%2A>.  
  
> [!NOTE]
>  Невозможно задать или получить это свойство, если окно размещается в браузере.  
  
<a name="dependencyPropertyInfo_WindowLeft"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Window.LeftProperty>|  
|Свойства метаданных, для которых задано значение`true`|Нет|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Top" />
      </Docs>
    </Member>
    <Member MemberName="LeftProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LeftProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LeftProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.LeftProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LeftProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LeftProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LeftProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.LeftProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Window.Left" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LocationChanged">
      <MemberSignature Language="C#" Value="public event EventHandler LocationChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LocationChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.LocationChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LocationChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ LocationChanged;" />
      <MemberSignature Language="F#" Value="member this.LocationChanged : EventHandler " Usage="member this.LocationChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении местоположения окна.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Расположение окна изменяется в следующих случаях:  
  
-   Пользователь перемещает окно, перетаскивая его с заголовком окна.  
  
-   Окно перемещается после <xref:System.Windows.Window.DragMove%2A> вызова метода.  
  
-   <xref:System.Windows.Window.Left%2A> Свойство или <xref:System.Windows.Window.Top%2A> задается программно.  
  
-   Выбран пункт меню « **переместить** » системного меню окна.  
  
-   <xref:System.Windows.Window.WindowState%2A> Свойство изменено.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
        <altmember cref="P:System.Windows.Window.Top" />
        <altmember cref="P:System.Windows.Window.RestoreBounds" />
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.Window.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает перечислитель для логических дочерних элементов окна.</summary>
        <value>Перечислитель <see cref="T:System.Collections.IEnumerator" /> для логических дочерних элементов окна.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.FrameworkElement.LogicalChildren" />
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function MeasureOverride (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="override this.MeasureOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="window.MeasureOverride availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">Объект <see cref="T:System.Windows.Size" />, отражающий доступный размер, который данное окно может выделить своим дочерним окнам. Можно задать бесконечное значение, указав, что окно будет масштабироваться в соответствии с любым содержимым.</param>
        <summary>Переопределив данный метод, можно измерить размер окна.</summary>
        <returns>Объект <see cref="T:System.Windows.Size" />, отражающий размер, потребности в котором данное окно определяет во время структурирования, основываясь на вычисленных размерах дочерних окон.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.MeasureOverride%2A>метод не вызывается, <xref:System.Windows.UIElement.Visibility%2A> если свойство имеет <xref:System.Windows.Visibility.Collapsed>значение. Если значение <xref:System.Windows.UIElement.Visibility%2A> свойства <xref:System.Windows.Visibility.Hidden> равно или <xref:System.Windows.Visibility.Visible>, <xref:System.Windows.Window.MeasureOverride%2A> то вызывается.  
  
> [!NOTE]
>  <xref:System.Windows.Window.ShowDialog%2A> <xref:System.Windows.UIElement.Visibility%2A> <xref:System.Windows.Visibility.Visible>При вызове метода <xref:System.Windows.Window.Show%2A> или<xref:System.Windows.Window> , свойству присваивается значение.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnActivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnActivated : EventArgs -&gt; unit&#xA;override this.OnActivated : EventArgs -&gt; unit" Usage="window.OnActivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Window.Activated" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Window.OnActivated%2A> формирует событие <xref:System.Windows.Window.Activated>.  
  
 Тип, производный от <xref:System.Windows.Window> , может переопределить. <xref:System.Windows.Window.OnActivated%2A> <xref:System.Windows.Window.OnActivated%2A> При<xref:System.Windows.Window.Activated> необходимости переопределенный метод должен вызывать в базовом классе.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnDeactivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnClosed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnClosed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosed(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClosed : EventArgs -&gt; unit&#xA;override this.OnClosed : EventArgs -&gt; unit" Usage="window.OnClosed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Window.Closed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Window.OnClosed%2A> формирует событие <xref:System.Windows.Window.Closed>.  
  
 Тип, производный от <xref:System.Windows.Window> , может переопределить. <xref:System.Windows.Window.OnClosed%2A> <xref:System.Windows.Window.OnClosed%2A> При<xref:System.Windows.Window.Closed> необходимости переопределенный метод должен вызывать в базовом классе.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnClosing(System.ComponentModel.CancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnClosing (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosing(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnClosing(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosing (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosing(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClosing : System.ComponentModel.CancelEventArgs -&gt; unit&#xA;override this.OnClosing : System.ComponentModel.CancelEventArgs -&gt; unit" Usage="window.OnClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.ComponentModel.CancelEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Window.Closing" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Window.OnClosing%2A> формирует событие <xref:System.Windows.Window.Closing>.  
  
 Тип, производный от <xref:System.Windows.Window> , может переопределить. <xref:System.Windows.Window.OnClosing%2A> <xref:System.Windows.Window.OnClosing%2A> При<xref:System.Windows.Window.Closing> необходимости переопределенный метод должен вызывать в базовом классе.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnClosed(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnContentChanged">
      <MemberSignature Language="C#" Value="protected override void OnContentChanged (object oldContent, object newContent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnContentChanged(object oldContent, object newContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnContentChanged(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnContentChanged (oldContent As Object, newContent As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnContentChanged(System::Object ^ oldContent, System::Object ^ newContent);" />
      <MemberSignature Language="F#" Value="override this.OnContentChanged : obj * obj -&gt; unit" Usage="window.OnContentChanged (oldContent, newContent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldContent" Type="System.Object" />
        <Parameter Name="newContent" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="oldContent">Ссылка на корневой элемент старого дерева содержимого.</param>
        <param name="newContent">Ссылка на корневой элемент нового дерева содержимого.</param>
        <summary>Вызывается при изменении свойства <see cref="P:System.Windows.Controls.ContentControl.Content" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContentRendered">
      <MemberSignature Language="C#" Value="protected virtual void OnContentRendered (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContentRendered(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnContentRendered(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContentRendered (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContentRendered(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContentRendered : EventArgs -&gt; unit&#xA;override this.OnContentRendered : EventArgs -&gt; unit" Usage="window.OnContentRendered e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Создает событие <see cref="E:System.Windows.Window.ContentRendered" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Window.OnContentRendered%2A> формирует событие <xref:System.Windows.Window.ContentRendered>.  
  
 Тип, производный от <xref:System.Windows.Window> , может переопределить. <xref:System.Windows.Window.OnContentRendered%2A> <xref:System.Windows.Window.OnContentRendered%2A> При<xref:System.Windows.Window.ContentRendered> необходимости переопределенный метод должен вызывать в базовом классе.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberSignature Language="F#" Value="override this.OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer" Usage="window.OnCreateAutomationPeer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает и возвращает объект <see cref="T:System.Windows.Automation.Peers.WindowAutomationPeer" /> для этого объекта <see cref="T:System.Windows.Window" />.</summary>
        <returns>Объект <see cref="T:System.Windows.Automation.Peers.WindowAutomationPeer" /> для этого объекта <see cref="T:System.Windows.Window" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод переопределяет метод <xref:System.Windows.ContentElement.OnCreateAutomationPeer%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDeactivated">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnDeactivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDeactivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDeactivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDeactivated : EventArgs -&gt; unit&#xA;override this.OnDeactivated : EventArgs -&gt; unit" Usage="window.OnDeactivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Создает событие <see cref="E:System.Windows.Window.Deactivated" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Window.OnDeactivated%2A> формирует событие <xref:System.Windows.Window.Deactivated>.  
  
 Тип, производный от <xref:System.Windows.Window> , может переопределить. <xref:System.Windows.Window.OnDeactivated%2A> <xref:System.Windows.Window.OnDeactivated%2A> При<xref:System.Windows.Window.Deactivated> необходимости переопределенный метод должен вызывать в базовом классе.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnActivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDpiChanged">
      <MemberSignature Language="C#" Value="protected override void OnDpiChanged (System.Windows.DpiScale oldDpi, System.Windows.DpiScale newDpi);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnDpiChanged(valuetype System.Windows.DpiScale oldDpi, valuetype System.Windows.DpiScale newDpi) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnDpiChanged(System.Windows.DpiScale,System.Windows.DpiScale)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnDpiChanged (oldDpi As DpiScale, newDpi As DpiScale)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnDpiChanged(System::Windows::DpiScale oldDpi, System::Windows::DpiScale newDpi);" />
      <MemberSignature Language="F#" Value="override this.OnDpiChanged : System.Windows.DpiScale * System.Windows.DpiScale -&gt; unit" Usage="window.OnDpiChanged (oldDpi, newDpi)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldDpi" Type="System.Windows.DpiScale" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="newDpi" Type="System.Windows.DpiScale" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="oldDpi">Предыдущий параметр масштабирования.</param>
        <param name="newDpi">Новый параметр масштабирования.</param>
        <summary>Вызывается, когда изменяется параметр "точек на дюйм", по которому определяется разрешение окна.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLocationChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnLocationChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLocationChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnLocationChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLocationChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLocationChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLocationChanged : EventArgs -&gt; unit&#xA;override this.OnLocationChanged : EventArgs -&gt; unit" Usage="window.OnLocationChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Window.LocationChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Window.OnLocationChanged%2A> формирует событие <xref:System.Windows.Window.LocationChanged>.  
  
 Тип, производный от <xref:System.Windows.Window> , может переопределить. <xref:System.Windows.Window.OnLocationChanged%2A> <xref:System.Windows.Window.OnLocationChanged%2A> При<xref:System.Windows.Window.LocationChanged> необходимости переопределенный метод должен вызывать в базовом классе.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
        <altmember cref="P:System.Windows.Window.Top" />
      </Docs>
    </Member>
    <Member MemberName="OnManipulationBoundaryFeedback">
      <MemberSignature Language="C#" Value="protected override void OnManipulationBoundaryFeedback (System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnManipulationBoundaryFeedback(class System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnManipulationBoundaryFeedback (e As ManipulationBoundaryFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnManipulationBoundaryFeedback(System::Windows::Input::ManipulationBoundaryFeedbackEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnManipulationBoundaryFeedback : System.Windows.Input.ManipulationBoundaryFeedbackEventArgs -&gt; unit" Usage="window.OnManipulationBoundaryFeedback e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationBoundaryFeedbackEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Данные для события.</param>
        <summary>Вызывается, когда происходит событие <see cref="E:System.Windows.UIElement.ManipulationBoundaryFeedback" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта реализация не изменяет состояние обработки ( <xref:System.Windows.RoutedEventArgs.Handled%2A> свойство) <xref:System.Windows.UIElement.ManipulationBoundaryFeedback> данных события.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении <see cref="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />всегда вызывайте базовую реализацию в своей <see cref="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" /> реализации. Сбой вызова базовой реализации предотвращает обработку события базовыми классами, что может изменить поведение во время выполнения конечного класса. Базовую реализацию можно вызвать как до, так и после специальной обработки в зависимости от требований.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnSourceInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnSourceInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSourceInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnSourceInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSourceInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSourceInitialized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSourceInitialized : EventArgs -&gt; unit&#xA;override this.OnSourceInitialized : EventArgs -&gt; unit" Usage="window.OnSourceInitialized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Window.SourceInitialized" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Window.OnSourceInitialized%2A> формирует событие <xref:System.Windows.Window.SourceInitialized>.  
  
 Тип, производный от <xref:System.Windows.Window> , может переопределить. <xref:System.Windows.Window.OnSourceInitialized%2A> <xref:System.Windows.Window.OnSourceInitialized%2A> При<xref:System.Windows.Window.SourceInitialized> необходимости переопределенный метод должен вызывать в базовом классе.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStateChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnStateChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStateChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnStateChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStateChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStateChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStateChanged : EventArgs -&gt; unit&#xA;override this.OnStateChanged : EventArgs -&gt; unit" Usage="window.OnStateChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Создает событие <see cref="E:System.Windows.Window.StateChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Window.OnStateChanged%2A> формирует событие <xref:System.Windows.Window.StateChanged>.  
  
 Тип, производный от <xref:System.Windows.Window> , может переопределить. <xref:System.Windows.Window.OnStateChanged%2A> <xref:System.Windows.Window.OnStateChanged%2A> При<xref:System.Windows.Window.StateChanged> необходимости переопределенный метод должен вызывать в базовом классе.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualChildrenChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnVisualChildrenChanged (System.Windows.DependencyObject visualAdded, System.Windows.DependencyObject visualRemoved);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualChildrenChanged(class System.Windows.DependencyObject visualAdded, class System.Windows.DependencyObject visualRemoved) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnVisualChildrenChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnVisualChildrenChanged (visualAdded As DependencyObject, visualRemoved As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualChildrenChanged(System::Windows::DependencyObject ^ visualAdded, System::Windows::DependencyObject ^ visualRemoved);" />
      <MemberSignature Language="F#" Value="override this.OnVisualChildrenChanged : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="window.OnVisualChildrenChanged (visualAdded, visualRemoved)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visualAdded" Type="System.Windows.DependencyObject" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.8" />
        <Parameter Name="visualRemoved" Type="System.Windows.DependencyObject" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="visualAdded">Объект <see cref="T:System.Windows.Media.Visual" />, добавленный в коллекцию.</param>
        <param name="visualRemoved">Объект <see cref="T:System.Windows.Media.Visual" />, который был удален из коллекции.</param>
        <summary>Вызывается при изменении коллекции <see cref="T:System.Windows.Media.VisualCollection" /> объекта <see cref="T:System.Windows.Window" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override sealed void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides NotOverridable Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberSignature Language="F#" Value="override this.OnVisualParentChanged : System.Windows.DependencyObject -&gt; unit" Usage="window.OnVisualParentChanged oldParent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">Предыдущий родительский элемент. Устанавливается на null, если у объекта <see cref="T:System.Windows.DependencyObject" /> не было предыдущего родителя.</param>
        <summary>Вызывается при изменении родителя окна.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="OwnedWindows">
      <MemberSignature Language="C#" Value="public System.Windows.WindowCollection OwnedWindows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.WindowCollection OwnedWindows" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.OwnedWindows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnedWindows As WindowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowCollection ^ OwnedWindows { System::Windows::WindowCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnedWindows : System.Windows.WindowCollection" Usage="System.Windows.Window.OwnedWindows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает коллекцию окон, владельцем которых является данное окно.</summary>
        <value>Коллекция <see cref="T:System.Windows.WindowCollection" />, содержащая ссылки на окна, владельцем которых является данное окно.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Владельцем является собственное окно, свойство <xref:System.Windows.Window.Owner%2A> которого задано ссылкой на другое окно, которое называется окном-владельцем. Чтобы найти все окна, которыми владеет окно-владелец, можно перечислить <xref:System.Windows.WindowCollection> значение, возвращаемое <xref:System.Windows.Window.OwnedWindows%2A> свойством.  
  
   
  
## Examples  
 В следующем примере показано, как выполнить перечисление <xref:System.Windows.Window.OwnedWindows%2A>.  
  
 [!code-csharp[WindowOwnerOwnedWindowsSnippets#GetWindowOwnedWindowsCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/CSharp/MainWindow.xaml.cs#getwindowownedwindowscode)]
 [!code-vb[WindowOwnerOwnedWindowsSnippets#GetWindowOwnedWindowsCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/visualbasic/mainwindow.xaml.vb#getwindowownedwindowscode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Owner">
      <MemberSignature Language="C#" Value="public System.Windows.Window Owner { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Window Owner" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Owner" />
      <MemberSignature Language="VB.NET" Value="Public Property Owner As Window" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Window ^ Owner { System::Windows::Window ^ get(); void set(System::Windows::Window ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Owner : System.Windows.Window with get, set" Usage="System.Windows.Window.Owner" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает окно <see cref="T:System.Windows.Window" />, которое владеет данным окном <see cref="T:System.Windows.Window" />.</summary>
        <value>Объект <see cref="T:System.Windows.Window" />, представляющий владельца данного объекта <see cref="T:System.Windows.Window" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда дочернее окно открывается родительским окном путем вызова <xref:System.Windows.Window.ShowDialog%2A>, между родительским и дочерним окном устанавливается неявная связь. Эта связь обеспечивает определенные режимы работы, в том числе в отношении минимизации, максимизации и восстановления.  
  
 При создании дочернего окна в родительском окне путем вызова <xref:System.Windows.Window.Show%2A>, однако дочернее окно не имеет связи с родительским окном. Это означает следующее.  
  
-   Дочернее окно не имеет ссылки на родительское окно.  
  
-   Поведение дочернего окна не зависит от поведения родительского окна. любое окно может охватывать другое, или быть сведенным, развернутым и восстанавливаемым независимо от другого.  
  
 Чтобы можно было создать связь между дочерним и родительским окнами, <xref:System.Windows.Window> поддерживает понятие владение. Владение устанавливается, когда <xref:System.Windows.Window.Owner%2A> свойству окна (принадлежащему окну) задана ссылка на другое окно (окно-владелец).  
  
 После того как связь установлена, демонстрируются следующие поведения:  
  
-   Если окно-владелец является сведенным, все его собственные окна также будут сведены к минимальному объему.  
  
-   Если принадлежащее окно является сведенным, его владелец не уменьшается.  
  
-   Если окно владельца развернуто, восстанавливаются и окно владельца, и его собственные окна.  
  
-   Окно владельца не может охватывать собственное окно.  
  
-   Собственные окна, которые не открывались <xref:System.Windows.Window.ShowDialog%2A> с помощью, не являются модальными. Пользователь по-прежнему может взаимодействовать с окном владельца.  
  
-   Если закрыть окно владельца, его собственные окна также будут закрыты.  
  
-   Если принадлежащее окно было открыто окном-владельцем <xref:System.Windows.Window.Show%2A>с помощью, а окно владельца закрыто, <xref:System.Windows.Window.Closing> событие принадлежащего окна не вызывается.  
  
 При открытии дочернего окна с помощью <xref:System.Windows.Window.ShowDialog%2A>метода необходимо также <xref:System.Windows.Window.Owner%2A> задать свойство дочернего окна. Если этого не сделать, пользователи не смогут восстановить как дочернее окно, так и родительское окно, нажав кнопку панели задач. Вместо этого при нажатии кнопки панели задач будет выдаваться список окон, включая дочернее и родительское окна, чтобы они были выбраны. восстанавливается только выбранное окно.  
  
> [!IMPORTANT]
>  Необходимо также задать <xref:System.Windows.Window.Owner%2A> свойство в окне, которое открывается с помощью вызова <xref:System.Windows.Window.ShowDialog%2A> , чтобы обеспечить правильное поведение с.  
  
> [!NOTE]
>  Невозможно задать или получить это свойство, если окно размещается в браузере.  
  
   
  
## Examples  
 В следующем примере показано, как установить отношение "владелец-принадлежащий".  
  
 [!code-csharp[WindowOwnerOwnedWindowsSnippets#SetWindowOwnerCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/CSharp/MainWindow.xaml.cs#setwindowownercode)]
 [!code-vb[WindowOwnerOwnedWindowsSnippets#SetWindowOwnerCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/visualbasic/mainwindow.xaml.vb#setwindowownercode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Окно пытается стать владельцем самого себя  
  
 -или-  
  
 Два окна пытаются стать владельцами друг друга.</exception>
        <exception cref="T:System.InvalidOperationException">Свойство <see cref="P:System.Windows.Window.Owner" /> установлено на видимое окно, отображенное методом <see cref="M:System.Windows.Window.ShowDialog" />  
  
- или - 
Свойство <see cref="P:System.Windows.Window.Owner" /> установлено на окно, которое ранее не отображалось.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">разрешение на использование всех окон и событий ввода данных пользователем без ограничений. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="P:System.Windows.Window.OwnedWindows" />
      </Docs>
    </Member>
    <Member MemberName="ResizeMode">
      <MemberSignature Language="C#" Value="public System.Windows.ResizeMode ResizeMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.ResizeMode ResizeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ResizeMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ResizeMode As ResizeMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResizeMode ResizeMode { System::Windows::ResizeMode get(); void set(System::Windows::ResizeMode value); };" />
      <MemberSignature Language="F#" Value="member this.ResizeMode : System.Windows.ResizeMode with get, set" Usage="System.Windows.Window.ResizeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ResizeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает режим изменения размеров.</summary>
        <value>Значение <see cref="T:System.Windows.ResizeMode" />, задающее режим изменения размеров.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Существует четыре варианта:  
  
-   **Норесизе**. Пользователь не может изменить размер окна. Прямоугольники развертывания и сворачивания не отображаются.  
  
-   **Канминимизе**. Пользователь может только в свернутом окне и восстановить его с панели задач. Отображаются окна сворачивания и развертывания, но включено только поле сворачивания.  
  
-   **Канресизе**. Пользователь имеет возможность изменять размер окна, используя окна сворачивания и развертывания, а также перетаскивать контур вокруг окна. Флажки сворачивания и развернуть отображаются и включены. (По умолчанию).  
  
-   **Канресизевисгрип**. Этот параметр имеет те же функциональные возможности <xref:System.Windows.ResizeMode.CanResize>, что и, но добавляет захват изменения размера в правый нижний угол окна.  
  
> [!NOTE]
>  Невозможно задать или получить это свойство, если окно размещается в браузере.  
  
<a name="dependencyPropertyInfo_WindowResizeMode"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Window.ResizeModeProperty>|  
|Свойства метаданных, для которых задано значение`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Primitives.ResizeGrip" />
      </Docs>
    </Member>
    <Member MemberName="ResizeModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ResizeModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ResizeModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ResizeModeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ResizeModeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ResizeModeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ResizeModeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.ResizeModeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Window.ResizeMode" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RestoreBounds">
      <MemberSignature Language="C#" Value="public System.Windows.Rect RestoreBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Rect RestoreBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.RestoreBounds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestoreBounds As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Rect RestoreBounds { System::Windows::Rect get(); };" />
      <MemberSignature Language="F#" Value="member this.RestoreBounds : System.Windows.Rect" Usage="System.Windows.Window.RestoreBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает размер и расположение окна перед сворачиванием либо разворачиванием.</summary>
        <value>Объект <see cref="T:System.Windows.Rect" />, задающий размер и расположение окна перед сворачиванием либо разворачиванием.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Прямоугольник восстановления — это область, занимаемая окном до его сворачивания или разворачивания. Можно использовать <xref:System.Windows.Window.RestoreBounds%2A> для сохранения последнего размера и расположения окна перед закрытием приложения и получения этих значений при следующем запуске приложения для восстановления окна до того, как пользователь оставил его.  
  
 Если вы запрашиваете <xref:System.Windows.Window.RestoreBounds%2A> до отображения окна или после его закрытия, <xref:System.Windows.Rect.Empty%2A> возвращается значение.  
  
> [!NOTE]
>  Это свойство нельзя получить, если окно размещается в браузере.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Windows.Window.RestoreBounds%2A> и изолированное хранилище, чтобы гарантировать, что размер и расположение окна будут такими же, как и при предыдущем отображении окна.  
  
 [!code-xaml[WindowRestoreBoundsSnippets#WindowRestoreBoundsXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml#windowrestoreboundsxaml1)]  
[!code-xaml[WindowRestoreBoundsSnippets#WindowRestoreBoundsXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml#windowrestoreboundsxaml2)]  
  
 [!code-csharp[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml.cs#windowrestoreboundscodebehind1)]
 [!code-vb[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/visualbasic/mainwindow.xaml.vb#windowrestoreboundscodebehind1)]  
[!code-csharp[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml.cs#windowrestoreboundscodebehind2)]
[!code-vb[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/visualbasic/mainwindow.xaml.vb#windowrestoreboundscodebehind2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">разрешение на запрос размера и расположения ограничивающего прямоугольника окна. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public void Show ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Show() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Show" />
      <MemberSignature Language="VB.NET" Value="Public Sub Show ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Show();" />
      <MemberSignature Language="F#" Value="member this.Show : unit -&gt; unit" Usage="window.Show " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Открывает окно и возвращается без ожидания закрытия нового открытого окна.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При создании экземпляра класса он не отображается по умолчанию. <xref:System.Windows.Window> <xref:System.Windows.Window.Show%2A>показывает окно и возвращает немедленно, не дожидаясь закрытия окна. Следовательно, открытое окно не мешает пользователям взаимодействовать с другими окнами в приложении. Этот тип окна называется *немодальным* окном. Распространенными примерами немодальных окон являются окна свойств, панели инструментов и палитры. Чтобы запретить пользователю взаимодействие с определенным окном, окно должно быть открыто путем вызова <xref:System.Windows.Window.ShowDialog%2A>.  
  
 Окно, открываемое при вызове <xref:System.Windows.Window.Show%2A> , не имеет автоматически связи с окном, которое его открыло; в частности, открытое окно не знает, какое окно открыло его. Эту связь можно установить с помощью <xref:System.Windows.Window.Owner%2A> свойства и управлять ими <xref:System.Windows.Window.OwnedWindows%2A> с помощью свойства.  
  
 Вызов <xref:System.Windows.Window.Show%2A> достигает того же конечного результата, что и <xref:System.Windows.UIElement.Visibility%2A> свойство <xref:System.Windows.Window> Setting объекта, равным <xref:System.Windows.Visibility.Visible>. Однако существует разница между двумя значениями с точки зрения времени.  
  
 Вызов <xref:System.Windows.Window.Show%2A> — это синхронная операция, которая возвращает только <xref:System.Windows.FrameworkElement.Loaded> после вызова события в дочернем окне:  
  
 [!code-csharp[WindowShowTimingSnippets#ShowSync](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowTimingSnippets/CSharp/Window1.xaml.cs#showsync)]
 [!code-vb[WindowShowTimingSnippets#ShowSync](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowTimingSnippets/visualbasic/window1.xaml.vb#showsync)]  
  
 Однако <xref:System.Windows.UIElement.Visibility%2A>параметр является асинхронной операцией, которая возвращает немедленно.  
  
 [!code-csharp[WindowShowTimingSnippets#ShowASync](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowTimingSnippets/CSharp/Window1.xaml.cs#showasync)]
 [!code-vb[WindowShowTimingSnippets#ShowASync](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowTimingSnippets/visualbasic/window1.xaml.vb#showasync)]  
  
 При установке <xref:System.Windows.UIElement.Visibility%2A>все события окна, регистрируемые до установки <xref:System.Windows.UIElement.Visibility%2A> , могут не вызываться до тех пор, пока не завершится <xref:System.Windows.UIElement.Visibility%2A> выполнение метода, в котором вы установили.  
  
   
  
## Examples  
 В следующем примере показано, как открыть немодальное окно.  
  
 [!code-csharp[WindowShowSnippets#WindowShowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowSnippets/CSharp/MainWindow.xaml.cs#windowshowcode)]
 [!code-vb[WindowShowSnippets#WindowShowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowSnippets/visualbasic/mainwindow.xaml.vb#windowshowcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Windows.Window.Show" /> вызывается для окна, которое закрывается (<see cref="E:System.Windows.Window.Closing" />) или закрыто (<see cref="E:System.Windows.Window.Closed" />).</exception>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="M:System.Windows.Window.Hide" />
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="ShowActivated">
      <MemberSignature Language="C#" Value="public bool ShowActivated { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowActivated" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ShowActivated" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowActivated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowActivated { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowActivated : bool with get, set" Usage="System.Windows.Window.ShowActivated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, активировано ли окно при первом отображении.</summary>
        <value>Значение <see langword="true" />, если окно активируется при первом отображении; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если окно <xref:System.Windows.Window.ShowActivated%2A> , свойство которого `false` имеет значение, открыто, окно не активируется, и его <xref:System.Windows.Window.Activated> событие не возникает, пока пользователь не активирует окно вручную, выбирая его. После выбора окна он активируется и деактивируется обычным образом.  
  
 Чтобы предотвратить <xref:System.Windows.Window.ShowActivated%2A> активацию окна при его открытии, свойство должно быть установлено в `false` значение до отображения окна (путем `false` вызова <xref:System.Windows.Window.Show%2A>); Установка значения <xref:System.Windows.Window.ShowActivated%2A> после отображения окна не оказывает никакого воздействия.  
  
 Установка значения <xref:System.Windows.Window.ShowActivated%2A>вокне , которое открыто модально, вызовет <xref:System.Windows.Window.ShowDialog%2A>, не оказывает никакого влияния. `false` Хотя модальное окно не будет активировано, модальное окно не позволит пользователю активировать все открытые окна приложений.  
  
<a name="dependencyPropertyInfo_WindowShowActivated"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Window.ShowActivatedProperty>|  
|Свойства метаданных, для которых задано значение`true`|Нет|  
  
   
  
## Examples  
 В следующем примере показано, как использовать разметку для настройки открытия окна без активации.  
  
 [!code-xaml[WindowShowActivatedSnippets#ShowUnactivatedMARKUP1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/AWindow.xaml#showunactivatedmarkup1)]  
  
  
 [!code-csharp[WindowShowActivatedSnippets#ShowUnactivatedCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/AWindow.xaml.cs#showunactivatedcodebehind)]
 [!code-vb[WindowShowActivatedSnippets#ShowUnactivatedCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowActivatedSnippets/visualbasic/awindow.xaml.vb#showunactivatedcodebehind)]  
  
 В следующем примере показано, как использовать код для настройки открытия окна без его активации.  
  
 [!code-csharp[WindowShowActivatedSnippets#ShowUnactivatedWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/Window1.xaml.cs#showunactivatedwindowcode)]
 [!code-vb[WindowShowActivatedSnippets#ShowUnactivatedWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowActivatedSnippets/visualbasic/window1.xaml.vb#showunactivatedwindowcode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowActivatedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ShowActivatedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ShowActivatedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ShowActivatedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ShowActivatedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ShowActivatedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ShowActivatedProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.ShowActivatedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Window.ShowActivated" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowDialog">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; ShowDialog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; ShowDialog() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.ShowDialog" />
      <MemberSignature Language="VB.NET" Value="Public Function ShowDialog () As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;bool&gt; ShowDialog();" />
      <MemberSignature Language="F#" Value="member this.ShowDialog : unit -&gt; Nullable&lt;bool&gt;" Usage="window.ShowDialog " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Открывает окно и возвращается только после его закрытия.</summary>
        <returns>Значение <see cref="T:System.Nullable`1" /> типа <see cref="T:System.Boolean" />, определяющее было действие принято (<see langword="true" />) или отменено (<see langword="false" />). Возвращаемое значение представляет собой значение свойства <see cref="P:System.Windows.Window.DialogResult" /> перед закрытием окна.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При создании экземпляра класса он не отображается по умолчанию. <xref:System.Windows.Window> <xref:System.Windows.Window.ShowDialog%2A>показывает окно, отключает все остальные окна в приложении и возвращает, только когда окно закрыто. Этот тип окна называется *модальным* окном.  
  
 Модальные окна в основном используются в качестве диалоговых окон. Диалоговое окно — это специальный тип окна, с помощью которого приложения взаимодействуют с пользователями для выполнения задач, таких как открытие файлов или печать документов. Диалоговые окна обычно позволяют пользователям принимать или отменять задачи, для которых они отображались до закрытия диалогового окна. <xref:System.Windows.Window.ShowDialog%2A><xref:System.Nullable%601> возвращаетзначение,указывающее,былолидействие<xref:System.Boolean> принято или отменено. Возвращаемое значение представляет собой значение свойства <xref:System.Windows.Window.DialogResult%2A> перед закрытием окна. Для получения дополнительной информации см. <xref:System.Windows.Window.DialogResult%2A>.  
  
 Окно, которое открывается путем вызова <xref:System.Windows.Window.ShowDialog%2A> метода, не имеет автоматически связи с окном, которое его открыло; в частности, открытое окно не знает, какое окно открыло его. Эту связь можно установить с помощью <xref:System.Windows.Window.Owner%2A> свойства и управлять ими <xref:System.Windows.Window.OwnedWindows%2A> с помощью свойства. Для поддержки [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] автоматизации (см. раздел [Общие сведения о модели автоматизации пользовательского интерфейса](~/docs/framework/ui-automation/ui-automation-overview.md)) для окна, открытого <xref:System.Windows.Window.ShowDialog%2A>путем вызова метода, <xref:System.Windows.Window.Owner%2A> необходимо задать значение.  
  
 При закрытии [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] модального окна (окна, открытого <xref:System.Windows.Window.ShowDialog%2A>с помощью вызова) ранее активированное окно активируется повторно. Если модальное [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] окно содержит окно-владелец (см <xref:System.Windows.Window.Owner%2A>.), окно владельца не активируется повторно, когда модальное [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] окно закрывается, если оно не было ранее активированным окном.  
  
> [!NOTE]
>  Этот метод не может быть вызван, если окно размещается в браузере.  
  
   
  
## Examples  
 В следующем примере показано, как открыть модальное окно.  
  
 [!code-csharp[WindowShowDialogSnippets#WindowShowDialogCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowDialogSnippets/CSharp/MainWindow.xaml.cs#windowshowdialogcode)]
 [!code-vb[WindowShowDialogSnippets#WindowShowDialogCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowDialogSnippets/visualbasic/mainwindow.xaml.vb#windowshowdialogcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Windows.Window.ShowDialog" /> вызывается для окна, которое закрывается (<see cref="E:System.Windows.Window.Closing" />) или закрыто (<see cref="E:System.Windows.Window.Closed" />).</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">разрешение на активацию окна. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbar">
      <MemberSignature Language="C#" Value="public bool ShowInTaskbar { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowInTaskbar" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ShowInTaskbar" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowInTaskbar As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowInTaskbar { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowInTaskbar : bool with get, set" Usage="System.Windows.Window.ShowInTaskbar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, имеет ли окно кнопку в панели задач.</summary>
        <value><see langword="true" />, если окно имеет кнопку в панели задач; в противном случае — <see langword="false" />. Не применяется, если окно размещено в браузере.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.Windows.Window.ShowInTaskbar%2A> для`true`задано значение, окно также появится в списке выбора приложения ALT + TAB.  
  
 Значок, используемый для кнопки панели задач и списка выбора приложения ALT + TAB, является значением <xref:System.Windows.Window.Icon%2A> свойства.  
  
> [!NOTE]
>  Невозможно задать или получить это свойство, если окно размещается в браузере.  
  
<a name="dependencyPropertyInfo_WindowShowInTaskbar"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Window.ShowInTaskbarProperty>|  
|Свойства метаданных, для которых задано значение`true`|Нет|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbarProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ShowInTaskbarProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ShowInTaskbarProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ShowInTaskbarProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ShowInTaskbarProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ShowInTaskbarProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ShowInTaskbarProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.ShowInTaskbarProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Window.ShowInTaskbar" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeToContent">
      <MemberSignature Language="C#" Value="public System.Windows.SizeToContent SizeToContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.SizeToContent SizeToContent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.SizeToContent" />
      <MemberSignature Language="VB.NET" Value="Public Property SizeToContent As SizeToContent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::SizeToContent SizeToContent { System::Windows::SizeToContent get(); void set(System::Windows::SizeToContent value); };" />
      <MemberSignature Language="F#" Value="member this.SizeToContent : System.Windows.SizeToContent with get, set" Usage="System.Windows.Window.SizeToContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SizeToContent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, изменится ли автоматически размер окна в соответствии с размером его содержимого.</summary>
        <value>Значение <see cref="T:System.Windows.SizeToContent" />. Значение по умолчанию — <see cref="F:System.Windows.SizeToContent.Manual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.Windows.Window.SizeToContent%2A> параметр имеет <xref:System.Windows.SizeToContent.WidthAndHeight>значение, установка параметра <xref:System.Windows.FrameworkElement.Height%2A> или <xref:System.Windows.FrameworkElement.Width%2A> не оказывает никакого влияния; можно задать оба свойства, но значения, которые они задают с помощью, не применяются к окну.  
  
 Если <xref:System.Windows.Window.SizeToContent%2A> параметр имеет <xref:System.Windows.SizeToContent.Height>значение, значение <xref:System.Windows.FrameworkElement.Height%2A> параметра не изменяет высоту окна.  
  
 Если <xref:System.Windows.Window.SizeToContent%2A> имеет <xref:System.Windows.FrameworkElement.Width%2A> значение, параметр не изменяет ширину окна. <xref:System.Windows.SizeToContent.Width>  
  
 Если <xref:System.Windows.Window.SizeToContent%2A> имеет значение, отличное от <xref:System.Windows.SizeToContent.Manual>:  
  
-   <xref:System.Windows.Window.SizeToContent%2A>автоматически устанавливается в <xref:System.Windows.SizeToContent.Manual> значение, если пользователь изменяет размер окна с помощью захвата изменения размера или перетаскивания границы.  
  
-   Если размер содержимого изменяется так, что приводит к изменению размера окна, <xref:System.Windows.FrameworkElement.SizeChanged> возникает исключение.  
  
 Если окно является прозрачным (см <xref:System.Windows.Window.AllowsTransparency%2A>. раздел), следует установить <xref:System.Windows.Window.SizeToContent%2A> для <xref:System.Windows.SizeToContent.WidthAndHeight> параметра значение, чтобы размер окна не превышал его видимого содержимого.  
  
> [!NOTE]
>  Невозможно задать или получить это свойство, если окно размещается в браузере.  
  
<a name="dependencyPropertyInfo_WindowSizeToContent"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Window.SizeToContentProperty>|  
|Свойства метаданных, для которых задано значение`true`|Нет|  
  
   
  
## Examples  
 В следующем примере показано, <xref:System.Windows.Window.SizeToContent%2A> как задать свойство в коде, чтобы указать, как размер окна изменяется в соответствии с содержимым.  
  
 [!code-csharp[HOWTOWindowManagementSnippets#SetWindowSizeToContentPropertyCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/CSharp/MainWindow.xaml.cs#setwindowsizetocontentpropertycode)]
 [!code-vb[HOWTOWindowManagementSnippets#SetWindowSizeToContentPropertyCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/visualbasic/mainwindow.xaml.vb#setwindowsizetocontentpropertycode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="P:System.Windows.Window.ResizeMode" />
      </Docs>
    </Member>
    <Member MemberName="SizeToContentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty SizeToContentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty SizeToContentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.SizeToContentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SizeToContentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ SizeToContentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable SizeToContentProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.SizeToContentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Window.SizeToContent" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceInitialized">
      <MemberSignature Language="C#" Value="public event EventHandler SourceInitialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SourceInitialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.SourceInitialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceInitialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SourceInitialized;" />
      <MemberSignature Language="F#" Value="member this.SourceInitialized : EventHandler " Usage="member this.SourceInitialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Данное событие инициируется для поддержки взаимодействия с [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)]. См. раздел <see cref="T:System.Windows.Interop.HwndSource" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StateChanged">
      <MemberSignature Language="C#" Value="public event EventHandler StateChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler StateChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.StateChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StateChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ StateChanged;" />
      <MemberSignature Language="F#" Value="member this.StateChanged : EventHandler " Usage="member this.StateChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении свойства окна <see cref="P:System.Windows.Window.WindowState" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="TaskbarItemInfo">
      <MemberSignature Language="C#" Value="public System.Windows.Shell.TaskbarItemInfo TaskbarItemInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Shell.TaskbarItemInfo TaskbarItemInfo" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.TaskbarItemInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property TaskbarItemInfo As TaskbarItemInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Shell::TaskbarItemInfo ^ TaskbarItemInfo { System::Windows::Shell::TaskbarItemInfo ^ get(); void set(System::Windows::Shell::TaskbarItemInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TaskbarItemInfo : System.Windows.Shell.TaskbarItemInfo with get, set" Usage="System.Windows.Window.TaskbarItemInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Shell.TaskbarItemInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает эскиз панели задач [!INCLUDE[win7](~/includes/win7-md.md)] для <see cref="T:System.Windows.Window" />.</summary>
        <value>Эскиз панели задач [!INCLUDE[win7](~/includes/win7-md.md)] для <see cref="T:System.Windows.Window" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения об использовании [!INCLUDE[win7](~/includes/win7-md.md)] эскиза панели задач см. в <xref:System.Windows.Shell.TaskbarItemInfo> разделе класс.  
  
 ]]></format>
        </remarks>
        <altmember cref="N:System.Windows.Shell" />
      </Docs>
    </Member>
    <Member MemberName="TaskbarItemInfoProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TaskbarItemInfoProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TaskbarItemInfoProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TaskbarItemInfoProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TaskbarItemInfoProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TaskbarItemInfoProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TaskbarItemInfoProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TaskbarItemInfoProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Window.TaskbarItemInfo" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Title" />
      <MemberSignature Language="VB.NET" Value="Public Property Title As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Title { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Title : string with get, set" Usage="System.Windows.Window.Title" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IWindowService.Title</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Title)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение или установка заголовка окна.</summary>
        <value>Строка <see cref="T:System.String" />, содержащая заголовок окна.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Заголовок <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>или <xref:System.Windows.Controls.Page.WindowTitle%2A?displayProperty=nameWithType>можно также установить с помощью. [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]  
  
<a name="dependencyPropertyInfo_WindowTitle"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Window.TitleProperty>|  
|Свойства метаданных, для которых задано значение`true`|Нет|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TitleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TitleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TitleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TitleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TitleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TitleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TitleProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TitleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Window.Title" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Top">
      <MemberSignature Language="C#" Value="public double Top { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Top" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Top" />
      <MemberSignature Language="VB.NET" Value="Public Property Top As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Top { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Top : double with get, set" Usage="System.Windows.Window.Top" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает позицию верхнего края окна относительно рабочего стола.</summary>
        <value>Позиция верхнего края окна в логических единицах (1/96 дюйма).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда разворачивается или уменьшается, это значение представляет собой верхнюю границу точки восстановления <xref:System.Windows.Window>для. <xref:System.Windows.Window>  
  
 Это свойство нельзя задать с помощью стиля.  
  
 Если значение не указано, <xref:System.Windows.Window.Top%2A> задается системное значение по умолчанию. Можно также указать системное значение по умолчанию, <xref:System.Windows.Window.Top%2A> задав <xref:System.Double.NaN>для значения. Ни <xref:System.Double.NegativeInfinity> значение <xref:System.Double.PositiveInfinity> , ни не является допустимым значением для <xref:System.Windows.Window.Top%2A>.  
  
> [!NOTE]
>  Невозможно задать или получить это свойство, если окно размещается в браузере.  
  
<a name="dependencyPropertyInfo_WindowTop"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Window.TopProperty>|  
|Свойства метаданных, для которых задано значение`true`|Нет|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
      </Docs>
    </Member>
    <Member MemberName="Topmost">
      <MemberSignature Language="C#" Value="public bool Topmost { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Topmost" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Topmost" />
      <MemberSignature Language="VB.NET" Value="Public Property Topmost As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Topmost { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Topmost : bool with get, set" Usage="System.Windows.Window.Topmost" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, отображается ли окно поверх всех окон в Z-порядке.</summary>
        <value>Значение <see langword="true" />, если окно является самым верхним; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Окно, свойство <xref:System.Windows.Window.Topmost%2A> которого установлено для `true` отображения над всеми окнами, <xref:System.Windows.Window.Topmost%2A> для `false`свойств которых задано значение.  
  
 В группе Windows, для <xref:System.Windows.Window.Topmost%2A> `true`которой свойство имеет значение, окно, которое в настоящее время активировано, является самым верхним. Аналогично для группы Windows, у <xref:System.Windows.Window.Topmost%2A> которой свойство имеет `false`значение.  
  
> [!NOTE]
>  Невозможно задать или получить это свойство, если окно размещается в браузере.  
  
<a name="dependencyPropertyInfo_WindowTopmost"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Window.TopmostProperty>|  
|Свойства метаданных, для которых задано значение`true`|Нет|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="TopmostProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TopmostProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TopmostProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TopmostProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TopmostProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TopmostProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TopmostProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TopmostProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Window.Topmost" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TopProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TopProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TopProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TopProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TopProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TopProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TopProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TopProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Window.Top" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStartupLocation">
      <MemberSignature Language="C#" Value="public System.Windows.WindowStartupLocation WindowStartupLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowStartupLocation WindowStartupLocation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowStartupLocation" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowStartupLocation As WindowStartupLocation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowStartupLocation WindowStartupLocation { System::Windows::WindowStartupLocation get(); void set(System::Windows::WindowStartupLocation value); };" />
      <MemberSignature Language="F#" Value="member this.WindowStartupLocation : System.Windows.WindowStartupLocation with get, set" Usage="System.Windows.Window.WindowStartupLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.WindowStartupLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение или установка положения окна при его первом отображении.</summary>
        <value>Значение <see cref="T:System.Windows.WindowStartupLocation" />, указывающее верхнюю/левую позицию окна при первом отображении. Значение по умолчанию — <see cref="F:System.Windows.WindowStartupLocation.Manual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Присвоение <xref:System.Windows.Window.Top%2A> <xref:System.Windows.Window.Left%2A> <xref:System.Windows.WindowStartupLocation.Manual> свойству значения приводит к тому, что окно будет располагаться в соответствии со значениями свойств и. `WindowStartupLocation` Если свойства <xref:System.Windows.Window.Top%2A> или не указаны, их значения определяются Windows. <xref:System.Windows.Window.Left%2A>  
  
 Присвоение `WindowStartupLocation` <xref:System.Windows.WindowStartupLocation.CenterScreen> свойству значения приводит к тому, что окно будет располагаться в центре экрана, содержащего курсор мыши.  
  
 Присвоение `WindowStartupLocation` <xref:System.Windows.Window.Owner%2A?displayProperty=nameWithType>свойству значения приводитктому,чтоокнобудетрасполагатьсявцентреокнаеговладельца(см.),если<xref:System.Windows.WindowStartupLocation.CenterOwner> оно задано. Окно-владелец может быть либо другим окном WPF, либо окном, не являющимся WPF.

> [!NOTE]   
>  Дополнительные сведения о окнах WPF с окнами, отличными от WPF, см. в разделе [взаимодействие WPF и Win32](~/docs/framework/wpf/advanced/wpf-and-win32-interoperation.md) и <xref:System.Windows.Interop.WindowInteropHelper>. 

 Если окно-владелец не указано, то расположение окна определяется таким же образом, как если `WindowStartupLocation` бы свойство было <xref:System.Windows.WindowStartupLocation.Manual>установлено в значение.

> [!NOTE]
>  Нельзя задать или получить значение этого свойства, если окно размещается в браузере.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowState">
      <MemberSignature Language="C#" Value="public System.Windows.WindowState WindowState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowState WindowState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowState" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowState As WindowState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowState WindowState { System::Windows::WindowState get(); void set(System::Windows::WindowState value); };" />
      <MemberSignature Language="F#" Value="member this.WindowState : System.Windows.WindowState with get, set" Usage="System.Windows.Window.WindowState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, восстановлено ли, свернуто или развернуто окно.</summary>
        <value>Состояние <see cref="T:System.Windows.WindowState" />, определяющее, является ли окно восстановленным, свернутым или развернутым. По умолчанию используется значение <see cref="F:System.Windows.WindowState.Normal" /> (восстановлено).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 До сворачивания или разворачивания окна его размер и расположение сохраняются в <xref:System.Windows.Window.RestoreBounds%2A>. При последующем восстановлении окна значения его размера и расположения восстанавливаются значениями из <xref:System.Windows.Window.RestoreBounds%2A>.  
  
 <xref:System.Windows.Window.WindowState%2A> При изменении<xref:System.Windows.Window.StateChanged> свойства вызывается.  
  
> [!NOTE]
>  Невозможно задать или получить это свойство, если окно размещается в браузере.  
  
<a name="dependencyPropertyInfo_WindowWindowState"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Window.WindowStateProperty>|  
|Свойства метаданных, для которых задано значение`true`|<xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.RestoreBounds" />
      </Docs>
    </Member>
    <Member MemberName="WindowStateProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WindowStateProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WindowStateProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.WindowStateProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WindowStateProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WindowStateProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable WindowStateProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.WindowStateProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Window.WindowState" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStyle">
      <MemberSignature Language="C#" Value="public System.Windows.WindowStyle WindowStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowStyle WindowStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowStyle As WindowStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowStyle WindowStyle { System::Windows::WindowStyle get(); void set(System::Windows::WindowStyle value); };" />
      <MemberSignature Language="F#" Value="member this.WindowStyle : System.Windows.WindowStyle with get, set" Usage="System.Windows.Window.WindowStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение или установка стиля границы окна.</summary>
        <value>Объект <see cref="T:System.Windows.WindowStyle" />, задающий стиль границы окна. Значение по умолчанию — <see cref="F:System.Windows.WindowStyle.SingleBorderWindow" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.WindowStyle%2A>может быть одним из <xref:System.Windows.WindowStyle> значений перечисления, включая <xref:System.Windows.WindowStyle.None>, <xref:System.Windows.WindowStyle.ToolWindow>, <xref:System.Windows.WindowStyle.SingleBorderWindow> (по умолчанию) и <xref:System.Windows.WindowStyle.ThreeDBorderWindow>.  
  
 На следующем рисунке показаны стили окна в [!INCLUDE[TLA#tla_longhorn](~/includes/tlasharptla-longhorn-md.md)] (тема Windows Vista Aero с включенным прозрачным стеклом):  
  
 ![Стили окна] (~/add/media/windowoverviewfigure6.PNG "Стили окна")  
  
> [!NOTE]
>  Невозможно задать или получить это свойство, если окно размещается в браузере.  
  
<a name="dependencyPropertyInfo_WindowWindowStyle"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Window.WindowStyleProperty>|  
|Свойства метаданных, для которых задано значение`true`|Нет|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WindowStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WindowStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.WindowStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WindowStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WindowStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable WindowStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.WindowStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Window.WindowStyle" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
