<Type Name="DependencyProperty" FullName="System.Windows.DependencyProperty">
  <Metadata><Meta Name="ms.openlocfilehash" Value="80a9f01be53a2b998e0b5051f60d7a1d2994dddd" /><Meta Name="ms.sourcegitcommit" Value="74239f3977d28923e5020663db2c4e91601bea79" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="07/24/2019" /><Meta Name="ms.locfileid" Value="68439806" /></Metadata><TypeSignature Language="C#" Value="public sealed class DependencyProperty" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DependencyProperty extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyProperty" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DependencyProperty" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyProperty sealed" />
  <TypeSignature Language="F#" Value="type DependencyProperty = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.ValueSerializer(typeof(System.Windows.DependencyPropertyValueSerializer))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет свойство, которое можно задать с помощью методов, например стили, привязки данных, анимации и наследование.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поддерживает следующие возможности в [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]. <xref:System.Windows.DependencyProperty>  
  
-   Свойство может быть задано в стиле. Более подробную информацию см. в разделе [Стилизация и использование шаблонов](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
-   Это свойство можно задать с помощью привязки данных. Дополнительные сведения о свойствах зависимостей привязки данных см. [в разделе как Привяжите свойства двух элементов управления](~/docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md).  
  
-   Для свойства можно задать ссылку на динамический ресурс. Дополнительные сведения см. в разделе [Ресурсы XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
-   Свойство может наследовать свое значение автоматически от родительского элемента в дереве элементов. Дополнительные сведения см. в разделе [Наследование значения свойства](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
-   Свойство может быть анимировано. Более подробную информацию см. в разделе [Общие сведения об эффектах анимации](~/docs/framework/wpf/graphics-multimedia/animation-overview.md).  
  
-   Свойство может сообщать о том, что предыдущее значение свойства было изменено и значение свойства может быть приведено. Дополнительные сведения см. в разделе [Проверка и обратные вызовы свойства зависимостей](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
-   Свойство сообщает сведения [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], например, должно ли изменение значения свойства требовать от системы макета перекомпозицию визуальных элементов для элемента.  
  
-   Свойство получает поддержку в [!INCLUDE[wpfdesigner_current_long](~/includes/wpfdesigner-current-long-md.md)].  Например, свойство можно изменить в окне **Свойства** .  
  
 Дополнительные сведения о свойствах зависимостей см. в разделе [Общие сведения о свойствах зависимостей](~/docs/framework/wpf/advanced/dependency-properties-overview.md). Если требуется, чтобы свойства пользовательских типов поддерживали возможности из предыдущего списка, следует создать свойство зависимостей.  Сведения о создании пользовательских свойств зависимостей см. в разделе [пользовательские свойства зависимостей](~/docs/framework/wpf/advanced/custom-dependency-properties.md).  
  
 Присоединенное свойство — это свойство, которое позволяет любому объекту передавать сведения в тип, определяющий присоединенное свойство. В [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]любой тип, наследующий от <xref:System.Windows.DependencyObject> , может использовать присоединенное свойство независимо от того, наследуется ли тип от типа, определяющего свойство. Присоединенное свойство — это функция [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] языка.  Чтобы задать присоединенное свойство в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], используйте параметр *OwnerType*. *propertyName* , синтаксис. Примером присоединенного свойства является <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> свойство. Если необходимо создать свойство, которое можно использовать для всех <xref:System.Windows.DependencyObject> типов, следует создать присоединенное свойство. Дополнительные сведения о вложенных свойствах, включая способы их создания, см. в разделе [Общие сведения](~/docs/framework/wpf/advanced/attached-properties-overview.md)о вложенных свойствах.  
  
<a name="xamlAttributeUsage_DependencyProperty"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```xaml 
<object property="dependencyPropertyName"/>  
```

-или-

```xaml
<object property="ownerType.dependencyPropertyName"/>  
```

-или-

```xaml
<object property="attachedPropertyOwnerType.attachedPropertyName"/>  
```  
  
<a name="xamlValues_DependencyProperty"></a>   
## <a name="xaml-values"></a>Значения XAML  
 `dependencyPropertyName`  
 Строка, указывающая <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType> требуемое свойство зависимостей. Перед ним может стоять префикс пространства имен XML, если свойство отсутствует в пространстве имен XML по умолчанию (Дополнительные сведения см. в разделе [пространства имен XAML и сопоставление пространств имен для WPF XAML](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).)  
  
 `ownerType`.`dependencyPropertyName`  
 Строка, указывающая тип владельца свойства зависимостей (точка (.)), а затем <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType>. `ownerType`также может предшествовать префикс пространства имен XML. Это использование относится к стилям и шаблонам с поздним связыванием, где владелец свойства зависимостей должен быть указан для контекста синтаксического анализа, `TargetType` поскольку еще не известен. Более подробную информацию см. в разделе [Стилизация и использование шаблонов](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
 `attachedPropertyOwnerType` *.* `attachedPropertyName`  
 Строка, указывающая владельца присоединенного свойства, точки (.), а затем имя присоединенного свойства. `attachedPropertyOwnerType`также может предшествовать префикс пространства имен XML.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyObject" />
    <altmember cref="T:System.Windows.DependencyPropertyHelper" />
  </Docs>
  <Members>
    <MemberGroup MemberName="AddOwner">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Добавляет другой тип в качестве владельца свойства зависимостей, который уже был зарегистрирован для типа.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner ownerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ownerType">Тип для добавления в качестве владельца данного свойства зависимостей.</param>
        <summary>Добавляет другой тип в качестве владельца свойства зависимостей, которое уже зарегистрировано.</summary>
        <returns>Ссылка на исходный идентификатор <see cref="T:System.Windows.DependencyProperty" />, который определяет свойство зависимостей. Этот идентификатор должен быть представлен путем добавления класса в качестве поля <see langword="public static readonly" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод позволяет системе свойств распознать свойство зависимостей для типа, который изначально не зарегистрировал это конкретное свойство зависимостей.  
  
 <xref:System.Windows.DependencyProperty.AddOwner%2A> Обычно используется для добавления свойств зависимостей в классы, которые еще не предоставляют это свойство зависимостей через наследование управляемого класса (наследование класса приведет к тому, что свойства оболочки наследуются производным классом, и, таким образом, будет предоставлять общие члены — доступ к таблицам для свойства зависимостей уже). <xref:System.Windows.DependencyProperty.AddOwner%2A>позволяет системе свойств распознать свойство зависимостей для типа, который не зарегистрировал это свойство зависимостей изначально.  
  
 Эта подпись не позволяет указывать метаданные.  При использовании этого метода метаданные создаются автоматически для нового <xref:System.Windows.DependencyProperty> типа и его владельца. Автоматически созданные метаданные являются результатом Объединенных метаданных из всех базовых типов, для которых определено это свойство. Если объединенные метаданные недоступны, используются метаданные по умолчанию для свойства. Если свойство зарегистрировано с помощью <xref:System.Windows.DependencyProperty.RegisterAttached%2A> метода, то метаданные по умолчанию совпадают с метаданными, созданными при <xref:System.Windows.DependencyProperty.RegisterAttached%2A> вызове. В противном случае <xref:System.Windows.PropertyMetadata.DefaultValue%2A> <xref:System.Windows.PropertyMetadata> `null`объект создается со свойством, установленным в значение по умолчанию для типа свойства, а всем остальным свойствам объекта присваивается значение. <xref:System.Windows.PropertyMetadata> <xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29> Используйте сигнатуру, если хотите предоставить метаданные для версии свойства зависимостей, добавленные в предоставленный тип.  
  
 Возвращаемое значение этого метода обычно используется для объявления и предоставления свойства зависимостей путем сохранения идентификатора свойства зависимости. Идентификатор предоставляет доступ к свойству зависимостей, если необходимо вызвать систему [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] свойств для свойства зависимостей, особенно в том случае, если оно существует в классе добавления владельца. Для указания аналогичной функциональности следует использовать одно и то же имя свойства для исходного владельца и добавленного владельца. Следует использовать <xref:System.Windows.DependencyProperty> возвращаемое значение <xref:System.Windows.DependencyProperty.AddOwner%2A> метода для определения идентификатора свойства зависимости, а также для объявления [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] оболочек свойств для свойств зависимостей, которые добавляются к типам с помощью <xref:System.Windows.DependencyProperty.AddOwner%2A>.  
  
 Методология, Рекомендуемая выше, используется при создании свойств зависимостей, объявленных в [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]. <xref:System.Windows.DependencyProperty.AddOwner%2A> Например, <xref:System.Windows.Controls.Border> и, и <xref:System.Windows.Controls.Control> определяют `BorderBrush` свойство зависимости, имеющее аналогичные функции. <xref:System.Windows.Controls.Control>определяет свое `BorderBrush` свойство для системы свойств путем вызова <xref:System.Windows.DependencyProperty.AddOwner%2A> на основе исходного владельца <xref:System.Windows.Controls.Border> и зарегистрированного <xref:System.Windows.Controls.Border.BorderBrushProperty> идентификатора свойства зависимостей. Возвращаемое значение затем используется для установления нового статического <xref:System.Windows.DependencyProperty> поля (<xref:System.Windows.Controls.Control.BorderBrushProperty>) для этого `BorderBrush` свойства в добавленном владельце, а также объявляется оболочка свойства. <xref:System.Windows.DependencyProperty.AddOwner%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner (ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="ownerType">Тип для добавления в качестве владельца данного свойства зависимостей.</param>
        <param name="typeMetadata">Метаданные, квалифицирующие свойство зависимостей в том виде, в котором оно существует в указанном типе.</param>
        <summary>Добавляет другой тип в качестве владельца свойства зависимостей, который уже был зарегистрирован, предоставляя метаданные свойства зависимости для свойства зависимостей в том виде, в котором оно будет существовать в предоставленном типе владельца.</summary>
        <returns>Ссылка на исходный идентификатор <see cref="T:System.Windows.DependencyProperty" />, который определяет свойство зависимостей. Этот идентификатор должен быть представлен путем добавления класса в качестве поля <see langword="public static readonly" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод позволяет системе свойств распознать свойство зависимостей для типа, который изначально не зарегистрировал это конкретное свойство зависимостей.  
  
 Возвращаемое значение этого метода используется для объявления и предоставления свойства зависимостей, особенно в том случае, если оно существует в классе добавления владельца. Как правило, для указания аналогичной функциональности следует использовать одно и то же имя свойства для исходного владельца и добавленного владельца. Рекомендуется предоставлять идентификаторы, а также новые [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] оболочки свойств для свойств зависимостей, которые добавляются к типам с помощью. <xref:System.Windows.DependencyProperty.AddOwner%2A>  
  
 Методология <xref:System.Windows.DependencyProperty.AddOwner%2A> , Рекомендуемая выше, используется при [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] создании объявления [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]в. Например, <xref:System.Windows.Controls.Border> и, и <xref:System.Windows.Controls.Control> определяют `BorderBrush` свойство зависимости, имеющее аналогичные функции. <xref:System.Windows.Controls.Control>определяет свое `BorderBrush` свойство для системы свойств, вызывая <xref:System.Windows.DependencyProperty.AddOwner%2A> для исходного владельца <xref:System.Windows.Controls.Border> и зарегистрированного <xref:System.Windows.Controls.Border.BorderBrushProperty> идентификатора свойства зависимостей. Возвращаемое значение затем используется для установления статического <xref:System.Windows.DependencyProperty> поля (<xref:System.Windows.Controls.Control.BorderBrushProperty>) для этого `BorderBrush` свойства в добавленном владельце, а также объявляется оболочка свойства. <xref:System.Windows.DependencyProperty.AddOwner%2A>  
  
 Идентификатор свойства зависимостей добавленного владельца следует использовать для таких операций, как <xref:System.Windows.DependencyObject.GetValue%2A>. Однако операции с определенными типами, включающие либо типы, либо экземпляры класса, добавленного в качестве владельца с разными метаданными, по-прежнему будут возвращать ожидаемые результаты, даже если в параметре не указан исходный идентификатор свойства зависимостей (не добавленного владельца). вызывает методы, такие как <xref:System.Windows.DependencyObject.GetValue%2A> или <xref:System.Windows.DependencyProperty.GetMetadata%2A>. Метаданные для добавленного владельца сохраняются с помощью <xref:System.Windows.DependencyProperty.AddOwner%2A> самого вызова, а не обязательно указываются только при добавлении поля идентификатора класса-владельца. Тем не менее, рекомендуется предоставлять идентификатор, а также новые [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] оболочки свойств для свойств зависимостей, которые добавляются к типам с помощью <xref:System.Windows.DependencyProperty.AddOwner%2A>, так как при этом происходит несоответствие между [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] и [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] представления свойств.  
  
 Переданные метаданные объединяются с метаданными свойств для свойства зависимостей в том виде, в котором они существуют в базовом владельце. Все характеристики, заданные в исходных базовых метаданных, сохраняются. Только те характеристики, которые были изменены в новых метаданных, будут переопределять характеристики базовых метаданных. Некоторые характеристики, такие как <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, заменяются, если они указаны в новых метаданных. Другие, например <xref:System.Windows.PropertyChangedCallback>, объединяются. В конечном итоге, поведение слияния зависит от типа метаданных свойства, используемого для переопределения, поэтому описанное здесь поведение предназначено для существующих классов метаданных свойств, используемых [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] свойствами зависимостей. Дополнительные сведения см. в разделе [метаданные свойств зависимостей](~/docs/framework/wpf/advanced/dependency-property-metadata.md) и [метаданные свойств платформы](~/docs/framework/wpf/advanced/framework-property-metadata.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata DefaultMetadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyMetadata DefaultMetadata" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultMetadata As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyMetadata ^ DefaultMetadata { System::Windows::PropertyMetadata ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMetadata : System.Windows.PropertyMetadata" Usage="System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает метаданные свойства зависимостей по умолчанию.</summary>
        <value>Метаданные свойства зависимостей по умолчанию.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метаданные по умолчанию — это метаданные свойства, доступные для данного конкретного объекта, или объект производного типа, в котором альтернативные метаданные не были предоставлены явным <xref:System.Windows.DependencyProperty.Register%2A> вызовом или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> .  
  
 Если исходный владелец применяет метаданные к первому <xref:System.Windows.DependencyProperty.Register%2A> вызову, который установил свойство зависимостей, то эти метаданные возвращаются как. <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>  
  
 Если в исходном <xref:System.Windows.DependencyProperty.Register%2A> вызове не были применены метаданные, в <xref:System.Windows.DependencyProperty.Register%2A> вызове создаются метаданные по умолчанию, а это <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>значение возвращается в виде.  
  
 Основной целью наличия метаданных по умолчанию, связанных с <xref:System.Windows.DependencyProperty> , является предоставление значения по умолчанию для этого свойства в <xref:System.Windows.DependencyObject> любом или производном типе.  
  
 Для неприсоединенных свойств тип метаданных, возвращаемый этим свойством, не может быть приведен к <xref:System.Windows.PropertyMetadata> производным типам, даже если свойство изначально было зарегистрировано с помощью производного типа метаданных. Если вы хотите, чтобы изначально зарегистрированные метаданные, включая исходный, возможно, производный тип метаданных, вызовите <xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29> вместо этого, передав исходный тип регистрации в качестве параметра.  
  
 Для вложенных свойств тип метаданных, возвращаемых этим свойством, будет соответствовать типу, заданному в <xref:System.Windows.DependencyProperty.RegisterAttached%2A> исходном методе регистрации.  
  
   
  
## Examples  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpdefaultvalue)]
[!code-vb[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpdefaultvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dependencyProperty.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает хэш-код для объекта <see cref="T:System.Windows.DependencyProperty" />.</summary>
        <returns>Хэш-код для этого экземпляра <see cref="T:System.Windows.DependencyProperty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Система свойств использует собственный уникальный идентификатор <xref:System.Windows.DependencyProperty.GlobalIndex%2A>, а значение этого свойства <xref:System.Windows.DependencyProperty.GetHashCode%2A>возвращается.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает метаданные, связанные с данным свойством зависимостей в том виде, в котором оно существует для конкретного типа. Это может быть тип, в котором свойство зависимостей было изначально зарегистрировано, тип, к которому оно было добавлено позже, или тип, в котором свойство зависимостей было получено путем наследования, но метаданные были переопределены.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (Type forType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Type forType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMetadata (forType As Type) As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(Type ^ forType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : Type -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata forType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="forType">Конкретный тип, из которого необходимо извлечь метаданные свойства зависимостей.</param>
        <summary>Возвращает метаданные для этого свойства зависимостей в том виде, в котором оно представлено в указанном существующем типе.</summary>
        <returns>Объект метаданных свойств.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Указание типа или ссылки на объект для использования в качестве типа является обязательным, так как метаданные могут отличаться от исходной регистрации из-за <xref:System.Windows.DependencyProperty.AddOwner%2A> или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> вызовов, которые изменяют метаданные свойства зависимостей, как оно существует в типе.  
  
   
  
## Examples  
 В следующем примере показано получение метаданных для свойства зависимости на основе его типа. Тип получается с помощью `typeof` оператора.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatatype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatatype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObject -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">Объект зависимости, проверяемый на наличие типа, чтобы определить, из какой типозависимой версии свойства зависимости нужно использовать метаданные.</param>
        <summary>Возвращает метаданные для этого свойства зависимостей в том виде,в котором оно существует в указанном экземпляре объекта.</summary>
        <returns>Объект метаданных свойств.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Указание типа или ссылки на объект является обязательным, так как метаданные любого заданного свойства зависимости могут отличаться от первоначальной регистрации из-за <xref:System.Windows.DependencyProperty.AddOwner%2A> вызовов или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> , которые могут уточнять метаданные свойств, так как они существуют в Тип.  
  
 При запросе метаданных свойств на основе экземпляра вы действительно передаете экземпляр, чтобы его тип можно было оценивать внутренним образом. Метаданные свойств зависимостей не меняются для каждого экземпляра; оно всегда согласуется с любой заданной комбинацией свойств типа.  
  
   
  
## Examples  
 В следующем примере показано получение метаданных для свойства зависимости на основе конкретного <xref:System.Windows.DependencyObject> экземпляра.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadoinstance)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadoinstance)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObjectType dependencyObjectType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObjectType dependencyObjectType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObjectType ^ dependencyObjectType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObjectType -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObjectType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObjectType" Type="System.Windows.DependencyObjectType" />
      </Parameters>
      <Docs>
        <param name="dependencyObjectType">Специальный объект, который записывает тип объекта зависимости, из которого запрашиваются метаданные свойства зависимостей.</param>
        <summary>Возвращает метаданные для этого свойства зависимостей в том виде, в каком они представлены в указанном типе.</summary>
        <returns>Объект метаданных свойств.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Указание типа или ссылки на объект является обязательным, так как метаданные любого заданного свойства зависимости могут отличаться от первоначальной регистрации из-за <xref:System.Windows.DependencyProperty.AddOwner%2A> вызовов или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> , которые могут уточнять метаданные свойств, так как они существуют в Тип.  
  
   
  
## Examples  
 В следующем примере показано получение метаданных для свойства зависимости на основе его <xref:System.Windows.DependencyObjectType>.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadotype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadotype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GlobalIndex">
      <MemberSignature Language="C#" Value="public int GlobalIndex { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GlobalIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.GlobalIndex" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GlobalIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int GlobalIndex { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalIndex : int" Usage="System.Windows.DependencyProperty.GlobalIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает внутреннее сгенерированное значение, уникальным образом идентифицирующее свойство зависимостей.</summary>
        <value>Уникальный числовой идентификатор.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это значение является целым числом, а не глобальным уникальным идентификатором (GUID). Как правило, использование этого значения индекса не является обязательным и не имеет доступа к таблицам всех свойств зависимостей. Вместо этого на свойства зависимостей должны ссылаться их поля идентификаторов.  
  
 <xref:System.Windows.DependencyProperty.GlobalIndex%2A>используется для внутренних целей для более быстрого доступа к структурам данных, <xref:System.Windows.DependencyProperty.GlobalIndex%2A> в которых используется индекс массива, начинающийся с нуля. Аналогичное использование может иметь приложения для конструкторов или средств.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidType">
      <MemberSignature Language="C#" Value="public bool IsValidType (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidType(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidType (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidType(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidType : obj -&gt; bool" Usage="dependencyProperty.IsValidType value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Проверяемое значение.</param>
        <summary>Определяет, приемлемо ли указанное значение для типа данного свойства зависимостей, проверяя его по типу свойства, указанного при исходной регистрации свойства зависимостей.</summary>
        <returns><see langword="true" />, если указанное значение принадлежит к зарегистрированному типу свойства или приемлемому производному типу; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение `null` является допустимым типом для свойств зависимости ссылочного типа или <xref:System.Nullable%601> для свойства зависимости, а также для возврата `true` в таких случаях. В случаях, когда свойство зависимости не является ни ссылкой, ни <xref:System.Nullable%601> типом, <xref:System.Windows.DependencyProperty.IsValidType%2A> возвращает `false` значение null, а не создает исключение.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Windows.DependencyProperty.IsValidType%2A> в качестве проверки перед вызовом <xref:System.Windows.DependencyObject.SetValue%2A> свойства зависимостей.  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvalue)]
 [!code-vb[PropertySystemEsoterics#TrySetValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidValue">
      <MemberSignature Language="C#" Value="public bool IsValidValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidValue (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidValue : obj -&gt; bool" Usage="dependencyProperty.IsValidValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Проверяемое значение.</param>
        <summary>Определяет, приемлемо ли указанное значение для типа свойства, путем базовой проверки типа, а также, находится ли оно потенциально в пределах разрешенного диапазона значений для данного типа.</summary>
        <returns><see langword="true" />, если значение приемлемо и принадлежит к надлежащему или производному типу; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для свойства зависимостей допустимый диапазон значений для этого типа можно указать с помощью <xref:System.Windows.ValidateValueCallback> , который предоставляется в регистрации свойства зависимостей.  
  
 Этот метод вызывается <xref:System.Windows.DependencyProperty.IsValidType%2A> внутренним образом. Если у рассматриваемого свойства зависимостей нет <xref:System.Windows.ValidateValueCallback>, то вызов этого метода фактически эквивалентен вызову. <xref:System.Windows.DependencyProperty.IsValidType%2A> Если свойство зависимостей имеет <xref:System.Windows.ValidateValueCallback>значение, а если <xref:System.Windows.DependencyProperty.IsValidType%2A> бы возвращалось `true`, то возвращаемое значение будет как реализовано в обратном вызове.  
  
 Значение null является допустимым значением для свойств зависимости ссылочного типа или для <xref:System.Nullable%601> свойства зависимости, а также для возврата `true` в таких случаях. В случаях, когда свойство зависимости не является ни ссылкой, ни <xref:System.Nullable%601> типом, <xref:System.Windows.DependencyProperty.IsValidType%2A> возвращает `false` значение null, а не создает исключение.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Windows.DependencyProperty.IsValidValue%2A> в качестве проверки перед вызовом <xref:System.Windows.DependencyObject.SetValue%2A> свойства зависимостей.  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvaluewithvalidate)]
 [!code-vb[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvaluewithvalidate)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Windows.DependencyProperty.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает имя свойства зависимостей.</summary>
        <value>Имя свойства.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство получает имя, указанное в качестве `name` параметра во время регистрации свойства зависимостей. Это имя является неизменяемым и не может `null` быть пустой строкой. Регистрация повторяющихся имен для одного и того же типа владельца не разрешена, и при попытке зарегистрировать дубликат будет выдаваться исключение.  
  
> [!IMPORTANT]
>  <xref:System.Windows.DependencyProperty.Name%2A> Свойство зависимостей должно соответствовать соглашению, совпадающему с именем идентификатора свойства зависимости, а не суффиксом "свойство". Дополнительные сведения см. в разделе [Пользовательские свойства зависимостей](~/docs/framework/wpf/advanced/custom-dependency-properties.md).  
  
   
  
## Examples  
 В следующем примере запрашиваются различные характеристики идентификатора свойства зависимости, включая <xref:System.Windows.DependencyProperty.Name%2A>.  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OverrideMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Предоставляет альтернативные метаданные для этого свойства зависимостей, когда оно присутствует в экземплярах указанного типа по сравнению с метаданными, предоставленными регистрацией первоначального свойства зависимостей.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="forType">Тип, где это свойство зависимостей наследуется и где будут применены указанные альтернативные метаданные.</param>
        <param name="typeMetadata">Метаданные для применения к свойству зависимостей в переопределяемом типе.</param>
        <summary>Задает альтернативные метаданные для этого свойства зависимостей, если оно присутствует в экземплярах указанного типа, переопределяя метаданные, которые существовали для данного свойства зависимостей в том виде, в котором оно было унаследовано от базовых типов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метаданные свойств зависимостей должны быть переопределены до того, как система свойств будет использовать свойство зависимостей. Это соответствует времени создания конкретных экземпляров с помощью класса, который регистрирует свойство зависимостей. Вызовы должны выполняться только внутри статических конструкторов типа, предоставляющего себя `forType` как параметр данного метода, или с помощью аналогичного экземпляра. <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> Попытка изменить метаданные после существования экземпляров типа owner не вызовет исключения, но приведет к несовместимости поведения в системе свойств.  
  
 После того как метаданные определенного производного класса устанавливаются с помощью этого метода, последующие попытки переопределения метаданных в этом же производном классе вызовут исключение.  
  
 Переданные метаданные объединяются с метаданными свойств для свойства зависимостей в том виде, в котором они существуют в базовом владельце. Все характеристики, заданные в исходных базовых метаданных, сохраняются. только те характеристики, которые были изменены в новых метаданных, будут переопределять характеристики базовых метаданных. Некоторые характеристики, такие <xref:System.Windows.PropertyMetadata.DefaultValue%2A> как, заменяются, если они указаны в новых метаданных. Другие, например <xref:System.Windows.PropertyChangedCallback>, объединяются. В конечном итоге, поведение слияния зависит от типа метаданных свойства, используемого для переопределения, поэтому описанное здесь поведение предназначено для существующих классов метаданных свойств, используемых [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] свойствами зависимостей. Дополнительные сведения см. в разделе [метаданные свойств зависимостей](~/docs/framework/wpf/advanced/dependency-property-metadata.md) и [метаданные свойств платформы](~/docs/framework/wpf/advanced/framework-property-metadata.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Была предпринята попытка переопределения метаданных в доступном только для чтения свойстве зависимости (операция не может быть выполнена с помощью данной сигнатуры).</exception>
        <exception cref="T:System.ArgumentException">Метаданные уже были установлены для данного свойства зависимостей в том виде, в котором оно существует в предоставленном типе.</exception>
      </Docs>
    </Member>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata, System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata, key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::DependencyPropertyKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata * System.Windows.DependencyPropertyKey -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="forType">Тип, где это свойство зависимостей наследуется и где будут применены указанные альтернативные метаданные.</param>
        <param name="typeMetadata">Метаданные для применения к свойству зависимостей в переопределяемом типе.</param>
        <param name="key">Ключ доступа для свойства зависимостей, доступного только для чтения.</param>
        <summary>Предоставляет альтернативные метаданные для свойства зависимостей, доступного только для чтения, когда оно присутствует в экземплярах указанного типа, переопределяя метаданные, предоставленные при первоначальной регистрации свойства зависимостей. Вы должны передать <see cref="T:System.Windows.DependencyPropertyKey" /> для свойства зависимостей, доступного только для чтения, чтобы избежать возникновения исключения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта сигнатура предоставляет базовую реализацию для метода идентификатора свойства зависимостей (<xref:System.Windows.DependencyPropertyKey>), доступного только для чтения. При переопределении метаданных для свойства зависимостей, доступного для чтения и <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>записи, используйте.  
  
 Метаданные свойств зависимостей должны быть переопределены до того, как система свойств будет использовать свойство зависимостей. Это соответствует времени создания конкретных объектов для класса, который регистрирует свойство зависимостей. Вызовы должны выполняться только внутри статических конструкторов типа, предоставляющего себя `forType` как параметр данного метода, или с помощью аналогичного экземпляра. <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> Попытка изменить метаданные после существования экземпляров типа owner не вызовет исключения, но приведет к несовместимости поведения в системе свойств.  
  
 После того как метаданные определенного производного класса устанавливаются с помощью этого метода, последующие попытки переопределения метаданных в этом же производном классе вызовут исключение.  
  
 Переданные метаданные объединяются с метаданными свойств для свойства зависимостей в том виде, в котором они существуют в базовом владельце. Все характеристики, заданные в исходных базовых метаданных, сохраняются. только те характеристики, которые были изменены в новых метаданных, будут переопределять характеристики базовых метаданных. Некоторые характеристики, такие <xref:System.Windows.PropertyMetadata.DefaultValue%2A> как, заменяются, если они указаны в новых метаданных. Другие, например <xref:System.Windows.PropertyChangedCallback>, объединяются. Поведение слияния зависит от типа метаданных свойства, используемого для переопределения. Дополнительные сведения см. в разделе [метаданные свойств зависимостей](~/docs/framework/wpf/advanced/dependency-property-metadata.md) и [метаданные свойств платформы](~/docs/framework/wpf/advanced/framework-property-metadata.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnerType">
      <MemberSignature Language="C#" Value="public Type OwnerType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type OwnerType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.OwnerType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnerType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ OwnerType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnerType : Type" Usage="System.Windows.DependencyProperty.OwnerType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает тип объекта, зарегистрировавшего свойство зависимостей в системе свойств или добавившего себя в качестве владельца свойства.</summary>
        <value>Тип объекта, зарегистрировавшего свойство или добавившего себя в качестве владельца свойства.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это значение было указано во время регистрации свойства. Владельцем будет либо исходный <xref:System.Windows.DependencyProperty> регистрируемый тип в случае идентификатора, созданного <xref:System.Windows.DependencyProperty.Register%2A> из вызова, либо тип, который добавил себя в качестве владельца <xref:System.Windows.DependencyProperty> в случае идентификатора, созданного из <xref:System.Windows.DependencyProperty.AddOwner%2A> вызова.  
  
 В любом заданном <xref:System.Windows.DependencyProperty> случае является неизменяемым и не `null` может быть в <xref:System.Windows.DependencyProperty>допустимом. <xref:System.Windows.DependencyProperty.OwnerType%2A>  
  
   
  
## Examples  
 Следующий пример получает тип владельца на основе идентификатора `dp`свойства зависимости, а затем получает метаданные для типа владельца для этого же идентификатора. Эта операция фактически эквивалентна операции получения <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>. `dp`  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyType">
      <MemberSignature Language="C#" Value="public Type PropertyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type PropertyType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.PropertyType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PropertyType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ PropertyType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PropertyType : Type" Usage="System.Windows.DependencyProperty.PropertyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает тип, используемый свойством зависимостей для его значения.</summary>
        <value><see cref="T:System.Type" /> значения свойства.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство сообщает тип значения свойства, объявленный исходной регистрацией свойства с помощью `propertyType` параметра. <xref:System.Windows.DependencyProperty.Name%2A>Как и в, тип свойства свойства зависимостей неизменяем после регистрации.  
  
   
  
## Examples  
 В следующем примере запрашиваются различные характеристики идентификатора свойства зависимости, включая <xref:System.Windows.DependencyProperty.PropertyType%2A>. Строка имени типа, <xref:System.Windows.DependencyProperty.PropertyType%2A> полученная из возвращаемого <xref:System.Type>объекта.  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public bool ReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadOnly : bool" Usage="System.Windows.DependencyProperty.ReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, является ли свойство зависимостей, идентифицируемое данным экземпляром <see cref="T:System.Windows.DependencyProperty" />, доступным только для чтения.</summary>
        <value><see langword="true" />, если свойство зависимостей доступно только для чтения; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойства зависимостей только для чтения регистрируются в системе свойств путем вызова <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> метода в отличие <xref:System.Windows.DependencyProperty.Register%2A> от метода. Вложенные свойства также могут быть зарегистрированы как доступные только для чтения. см <xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>. раздел.  
  
 Для свойств зависимостей только для чтения требуется <xref:System.Windows.DependencyPropertyKey> идентификатор, а не <xref:System.Windows.DependencyProperty> идентификатор для выполнения операций с метаданными, таких как переопределение метаданных или установка значения. Если коллекция <xref:System.Windows.DependencyProperty> идентификаторов была получена через [!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)] <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> вызов или другой объект, предоставляющий идентификаторы, проверьте <xref:System.Windows.DependencyProperty.ReadOnly%2A> значение, прежде чем пытаться вызвать <xref:System.Windows.DependencyObject.SetValue%2A> или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> использовать его. Идентификатор свойства зависимостей в качестве входного параметра, чтобы убедиться, что свойство зависимостей, представляемое идентификатором, не доступно только для чтения. Если значение <xref:System.Windows.DependencyProperty.ReadOnly%2A> параметра находится `true` в свойстве зависимости, нет программного способа <xref:System.Windows.DependencyPropertyKey> получить ссылку на идентификатор этого <xref:System.Windows.DependencyProperty> свойства зависимостей из метаданных или идентификатора; идентификатор должен быть доступен как статическое поле для вызова <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> свойства зависимостей, доступного только для чтения.  
  
 При создании настраиваемого свойства зависимости и его регистрации в качестве только для чтения необходимо определить только метод доступа get для [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] свойства оболочки. В противном случае класс будет иметь непонятную объектную модель для оболочки свойств по сравнению с доступом к свойству обратной зависимости. Дополнительные сведения см. в разделе [пользовательские свойства зависимости](~/docs/framework/wpf/advanced/custom-dependency-properties.md) или [свойства зависимостей только для чтения](~/docs/framework/wpf/advanced/read-only-dependency-properties.md).  
  
   
  
## Examples  
 Следующий пример получает метаданные по умолчанию и свойства идентификатора свойства зависимости из различных полей свойств зависимости и использует эти сведения для заполнения таблицы для реализации "браузера метаданных".  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Register">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Регистрирует свойство зависимостей.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Имя регистрируемого свойства зависимостей. Имя должно быть уникальным в пределах пространства имен регистрации для типа владельца.</param>
        <param name="propertyType">Тип свойства.</param>
        <param name="ownerType">Тип владельца, регистрирующий свойство зависимостей.</param>
        <summary>Регистрирует свойство зависимостей с указанием имени свойства, типа свойства и типа владельца.</summary>
        <returns>Идентификатор свойства зависимостей, который должен использоваться для задания значения поля <see langword="public static readonly" /> в классе. Затем этот идентификатор используется для ссылки на свойство зависимостей для операций, например задания значения программным образом или получение метаданных.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения о регистрации свойств зависимостей см. в <xref:System.Windows.DependencyProperty>разделе.  
  
   
  
## Examples  
 [!code-csharp[WPFAquariumSln#Register3Param](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#register3param)]
 [!code-vb[WPFAquariumSln#Register3Param](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#register3param)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Имя регистрируемого свойства зависимостей.</param>
        <param name="propertyType">Тип свойства.</param>
        <param name="ownerType">Тип владельца, регистрирующий свойство зависимостей.</param>
        <param name="typeMetadata">Метаданные свойства зависимостей.</param>
        <summary>Регистрирует свойство зависимостей с указанным именем свойства, типом свойства, типом владельца и метаданными свойства.</summary>
        <returns>Идентификатор свойства зависимостей, который должен использоваться для задания значения поля <see langword="public static readonly" /> в классе. Затем этот идентификатор используется для ссылки на свойство зависимостей для операций, например задания значения программным образом или получение метаданных.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения о регистрации свойств зависимостей см. в <xref:System.Windows.DependencyProperty>разделе.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Имя регистрируемого свойства зависимостей.</param>
        <param name="propertyType">Тип свойства.</param>
        <param name="ownerType">Тип владельца, регистрирующий свойство зависимостей.</param>
        <param name="typeMetadata">Метаданные свойства зависимостей.</param>
        <param name="validateValueCallback">Ссылка на обратный вызов, который должен выполнить пользовательскую проверку значения свойства зависимостей после обычной проверки типа.</param>
        <summary>Регистрирует свойство зависимостей с указанным именем свойства, типом свойства, типом владельца, метаданными свойства и обратным вызовом проверки значения для свойства.</summary>
        <returns>Идентификатор свойства зависимостей, который должен использоваться для задания значения поля <see langword="public static readonly" /> в классе. Затем этот идентификатор используется для ссылки на свойство зависимостей для операций, например задания значения программным образом или получение метаданных.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения о регистрации свойств зависимостей см. в <xref:System.Windows.DependencyProperty>разделе.  
  
   
  
## Examples  
 В следующем примере регистрируется свойство зависимости, включая обратный вызов проверки (определение обратного вызова не отображается; дополнительные сведения об определении обратного вызова см <xref:System.Windows.ValidateValueCallback>. в разделе).  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttached">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Регистрирует присоединенное свойство в системе свойств.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Имя регистрируемого свойства зависимостей.</param>
        <param name="propertyType">Тип свойства.</param>
        <param name="ownerType">Тип владельца, регистрирующий свойство зависимостей.</param>
        <summary>Регистрирует присоединенное свойство с указанием имени свойства, типа свойства и типа владельца.</summary>
        <returns>Идентификатор свойства зависимостей, который должен использоваться для задания значения поля <see langword="public static readonly" /> в классе. Затем этот идентификатор используется для ссылки на свойство зависимостей для операций, например задания значения программным образом или получение метаданных.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вложенное свойство — это понятие свойства, [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]определяемое. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]реализует присоединенные свойства как свойства зависимостей. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Поскольку вложенные свойства являются свойствами зависимостей, к ним могут применяться метаданные, которые могут использоваться общей системой свойств для таких операций, как отчеты о характеристиках макета. Дополнительные сведения см. в разделе [Общие сведения о вложенных свойствах](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Дополнительные сведения о регистрации свойств зависимостей см. в <xref:System.Windows.DependencyProperty>разделе.  
  
   
  
## Examples  
 В следующем примере вложенное свойство регистрируется для абстрактного класса с <xref:System.Windows.DependencyProperty.RegisterAttached%2A> помощью этой сигнатуры.  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Имя регистрируемого свойства зависимостей.</param>
        <param name="propertyType">Тип свойства.</param>
        <param name="ownerType">Тип владельца, регистрирующий свойство зависимостей.</param>
        <param name="defaultMetadata">Метаданные свойства зависимостей. Могут включать значение по умолчанию и другие характеристики.</param>
        <summary>Регистрирует присоединенное свойство с указанным именем и типом свойства, типом владельца и метаданными свойства.</summary>
        <returns>Идентификатор свойства зависимостей, который должен использоваться для задания значения поля <see langword="public static readonly" /> в классе. Затем этот идентификатор используется для ссылки на свойство зависимостей для операций, например задания значения программным образом или получение метаданных.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вложенное свойство — это понятие свойства, [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]определяемое. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]реализует присоединенные свойства как свойства зависимостей. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Поскольку вложенные свойства являются свойствами зависимостей, к ним могут применяться метаданные, которые могут использоваться общей системой свойств для таких операций, как отчеты о характеристиках макета. Дополнительные сведения см. в разделе [Общие сведения о вложенных свойствах](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Дополнительные сведения о регистрации свойств зависимостей см. в <xref:System.Windows.DependencyProperty>разделе.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Использование RegisterAttached для наследования значений свойств зависимостей  
 Один из сценариев для регистрации свойства зависимостей с параметром <xref:System.Windows.DependencyProperty.RegisterAttached%2A> <xref:System.Windows.DependencyProperty.Register%2A> вместо — для поддержки наследования значения свойства. Следует регистрировать свойства <xref:System.Windows.DependencyProperty.RegisterAttached%2A> зависимостей, наследуемые значениями, даже если класс определяет методы доступа к оболочке свойств, которые предоставляют свойство зависимостей, и даже если вы не собираетесь предоставлять статические методы get * и Set * для предоставления истинных вложений. методы доступа для поддержки свойств.   Несмотря на то, что наследование значений свойств может работать для неприсоединенных свойств зависимостей, поведение наследования для неприсоединенного свойства через определенные границы элементов в дереве среды выполнения не определено. Регистрация свойства как присоединенного фактически делает присоединенное свойство глобальным свойством системы свойств и гарантирует, что наследование значения свойства работает во всех границах дерева элементов. Всегда используйте <xref:System.Windows.DependencyProperty.RegisterAttached%2A> для регистрации свойств, в которых <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> указывается в метаданных. Дополнительные сведения см. в разделе [Наследование значения свойства](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Имя регистрируемого свойства зависимостей.</param>
        <param name="propertyType">Тип свойства.</param>
        <param name="ownerType">Тип владельца, регистрирующий свойство зависимостей.</param>
        <param name="defaultMetadata">Метаданные свойства зависимостей. Могут включать значение по умолчанию и другие характеристики.</param>
        <param name="validateValueCallback">Ссылка на обратный вызов, который должен выполнить пользовательскую проверку значения свойства зависимостей после обычной проверки типа.</param>
        <summary>Регистрирует присоединенное свойство с указанным типом свойства, типом владельца, метаданными свойства и обратным вызовом для проверки значения свойства.</summary>
        <returns>Идентификатор свойства зависимостей, который должен использоваться для задания значения поля <see langword="public static readonly" /> в классе. Затем этот идентификатор используется для ссылки на свойство зависимостей для операций, например задания значения программным образом или получение метаданных.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вложенное свойство — это понятие свойства, [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]определяемое. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]реализует присоединенные свойства как свойства зависимостей. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Поскольку вложенные свойства являются свойствами зависимостей, к ним могут применяться метаданные, которые могут использоваться общей системой свойств для таких операций, как отчеты о характеристиках макета. Дополнительные сведения см. в разделе [Общие сведения о вложенных свойствах](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Дополнительные сведения о регистрации свойств зависимостей см. в <xref:System.Windows.DependencyProperty>разделе.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Использование RegisterAttached для наследования значений свойств зависимостей  
 Один из сценариев для регистрации свойства зависимостей с параметром <xref:System.Windows.DependencyProperty.RegisterAttached%2A> <xref:System.Windows.DependencyProperty.Register%2A> вместо — для поддержки наследования значения свойства. Следует регистрировать свойства <xref:System.Windows.DependencyProperty.RegisterAttached%2A> зависимостей, наследуемые значениями, даже если класс определяет методы доступа к оболочке свойств, которые предоставляют свойство зависимостей, и даже если вы не собираетесь предоставлять статические методы get * и Set * для предоставления истинных вложений. методы доступа для поддержки свойств.   Несмотря на то, что наследование значений свойств может работать для неприсоединенных свойств зависимостей, поведение наследования для неприсоединенного свойства через определенные границы элементов в дереве среды выполнения не определено. Регистрация свойства как присоединенного фактически делает присоединенное свойство глобальным свойством системы свойств и гарантирует, что наследование значения свойства работает во всех границах дерева элементов. Всегда используйте <xref:System.Windows.DependencyProperty.RegisterAttached%2A> для регистрации свойств, в которых <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> указывается в метаданных. Дополнительные сведения см. в разделе [Наследование значения свойства](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
   
  
## Examples  
 В следующем примере вложенное свойство регистрируется для абстрактного класса с <xref:System.Windows.DependencyProperty.RegisterAttached%2A> помощью этой сигнатуры. Это присоединенное свойство является свойством типа перечисления, и регистрация добавляет обратный вызов проверки, чтобы убедиться, что предоставленное значение является значением перечисления.  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttachedReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Регистрирует присоединенное свойство зависимостей, предназначенное только для чтения.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttachedReadOnly (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Имя регистрируемого свойства зависимостей.</param>
        <param name="propertyType">Тип свойства.</param>
        <param name="ownerType">Тип владельца, регистрирующий свойство зависимостей.</param>
        <param name="defaultMetadata">Метаданные свойства зависимостей.</param>
        <summary>Регистрирует доступное только для чтения присоединенное свойство с указанным типом свойства, типом владельца и метаданными свойства.</summary>
        <returns>Ключ свойства зависимостей, который следует использовать для задания значения статического доступного только для чтения поля в вашем классе, которое затем используется для ссылки на свойство зависимостей.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает тип <xref:System.Windows.DependencyPropertyKey>, <xref:System.Windows.DependencyProperty.RegisterAttached%2A> тогда как возвращает тип <xref:System.Windows.DependencyProperty>. Как правило, ключи, представляющие свойства только для чтения, не являются общедоступными, поскольку ключи можно использовать для установки значения свойства зависимостей путем вызова <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Разработка класса повлияет на ваши требования, но обычно рекомендуется ограничить доступ и видимость любых <xref:System.Windows.DependencyPropertyKey> элементов только теми частями кода, которые необходимы для задания этого свойства зависимостей как части логики класса или приложения. Также рекомендуется предоставить идентификатор свойства зависимостей для свойства зависимостей "только для чтения", предоставив значение <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> в `public static readonly` качестве поля в классе.  
  
 Присоединенные свойства только для чтения являются редким сценарием, поскольку основной сценарий для присоединенного свойства используется в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]. Без открытого метода задания вложенное свойство не может быть задано в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] синтаксисе.  
  
 Дополнительные сведения о регистрации свойств зависимостей см. в <xref:System.Windows.DependencyProperty>разделе.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Использование RegisterAttached для наследования значений свойств зависимостей  
 Одним из сценариев регистрации свойства зависимостей в качестве присоединенных является поддержка наследования значения свойства. Следует регистрировать свойства <xref:System.Windows.DependencyProperty.RegisterAttached%2A> зависимостей, наследуемые значениями, даже если класс определяет методы доступа к оболочке свойств, которые предоставляют свойство зависимостей, и даже если вы не собираетесь предоставлять статические методы get * и Set * для предоставления истинных вложений. методы доступа для поддержки свойств.   Несмотря на то, что наследование значений свойств может работать для неприсоединенных свойств зависимостей, поведение наследования для неприсоединенного свойства через определенные границы элементов в дереве среды выполнения не определено. Регистрация свойства как присоединенного фактически делает присоединенное свойство глобальным свойством системы свойств и гарантирует, что наследование значения свойства работает во всех границах дерева элементов. Всегда используйте <xref:System.Windows.DependencyProperty.RegisterAttached%2A> для регистрации свойств, в которых <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> указывается в метаданных. Дополнительные сведения см. в разделе [Наследование значения свойства](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Имя регистрируемого свойства зависимостей.</param>
        <param name="propertyType">Тип свойства.</param>
        <param name="ownerType">Тип владельца, регистрирующий свойство зависимостей.</param>
        <param name="defaultMetadata">Метаданные свойства зависимостей.</param>
        <param name="validateValueCallback">Ссылка на созданный пользователем обратный вызов, который должен выполнить пользовательскую проверку значения свойства зависимостей после обычной проверки типа.</param>
        <summary>Регистрирует доступное только для чтения присоединенное свойство с указанным типом свойства, типом владельца, метаданными свойства и обратным вызовом для проверки.</summary>
        <returns>Ключ свойства зависимостей, который следует использовать для задания значения статического доступного только для чтения поля в вашем классе, которое затем используется для ссылки на свойство зависимостей.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает тип <xref:System.Windows.DependencyPropertyKey>, <xref:System.Windows.DependencyProperty.RegisterAttached%2A> тогда как возвращает тип <xref:System.Windows.DependencyProperty>. Обычно это ключи, представляющие тип <xref:System.Windows.DependencyProperty>. Как правило, ключи, представляющие свойства только для чтения, не являются общедоступными, поскольку ключи можно использовать для установки значения свойства зависимостей путем вызова <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Разработка класса повлияет на ваши требования, но обычно рекомендуется ограничить доступ и видимость любых <xref:System.Windows.DependencyPropertyKey> элементов только теми частями кода, которые необходимы для задания этого свойства зависимостей как части логики класса или приложения. Также рекомендуется предоставить идентификатор свойства зависимостей для свойства зависимостей "только для чтения", предоставив значение <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> в `public static readonly` качестве поля в классе.  
  
 Присоединенные свойства только для чтения являются редким сценарием, поскольку основной сценарий для присоединенного свойства используется в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]. Без открытого метода задания вложенное свойство не может быть задано в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] синтаксисе.  
  
 Дополнительные сведения о регистрации свойств зависимостей см. в <xref:System.Windows.DependencyProperty>разделе.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Использование RegisterAttached для наследования значений свойств зависимостей  
 Один из <xref:System.Windows.DependencyProperty.Register%2A> сценариев для регистрации свойства зависимостей в качестве присоединенных, а не для поддержки наследования значения свойства. Следует регистрировать свойства <xref:System.Windows.DependencyProperty.RegisterAttached%2A> зависимостей, наследуемые значениями, даже если класс определяет методы доступа к оболочке свойств, которые предоставляют свойство зависимостей, и даже если вы не собираетесь предоставлять статические методы get * и Set * для предоставления истинных вложений. методы доступа для поддержки свойств.   Несмотря на то, что наследование значений свойств может работать для неприсоединенных свойств зависимостей, поведение наследования для неприсоединенного свойства через определенные границы элементов в дереве среды выполнения не определено. Регистрация свойства как присоединенного фактически делает присоединенное свойство глобальным свойством системы свойств и гарантирует, что наследование значения свойства работает во всех границах дерева элементов. Всегда используйте <xref:System.Windows.DependencyProperty.RegisterAttached%2A> для регистрации свойств, в которых <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> указывается в метаданных. Дополнительные сведения см. в разделе [Наследование значения свойства](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Регистрирует свойство зависимостей как свойство зависимостей только для чтения.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterReadOnly (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Имя регистрируемого свойства зависимостей.</param>
        <param name="propertyType">Тип свойства.</param>
        <param name="ownerType">Тип владельца, регистрирующий свойство зависимостей.</param>
        <param name="typeMetadata">Метаданные свойства зависимостей.</param>
        <summary>Регистрирует доступное только для чтения свойство зависимостей с указанным типом свойства, типом владельца и метаданными свойства.</summary>
        <returns>Ключ свойства зависимостей, который следует использовать для задания значения статического доступного только для чтения поля в вашем классе, которое затем используется для ссылки на свойство зависимостей.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает тип <xref:System.Windows.DependencyPropertyKey>, <xref:System.Windows.DependencyProperty.RegisterAttached%2A> тогда как возвращает тип <xref:System.Windows.DependencyProperty>. Как правило, ключи, представляющие свойства только для чтения, не являются общедоступными, поскольку ключи можно использовать для установки значения свойства зависимостей путем вызова <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Разработка класса повлияет на ваши требования, но обычно рекомендуется ограничить доступ и видимость любых <xref:System.Windows.DependencyPropertyKey> элементов только теми частями кода, которые необходимы для задания этого свойства зависимостей как части логики класса или приложения. Также рекомендуется предоставить идентификатор свойства зависимостей для свойства зависимостей "только для чтения", предоставив значение <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> в `public static readonly` качестве поля в классе.  
  
 Свойства зависимостей "только для чтения" являются довольно типичным сценарием как [!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)] в существующих, так и в сценариях настройки, поскольку для других [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] функций может потребоваться свойство зависимости, даже если это свойство не предназначено для использования вызывающим объектам. Значение свойства зависимости, доступное только для чтения, можно использовать в качестве основания для других операций системы свойств, принимающих свойство зависимостей, например <xref:System.Windows.Trigger> для свойства зависимостей в стиле.  
  
 Дополнительные сведения о регистрации свойств зависимостей см. в <xref:System.Windows.DependencyProperty>разделе.  
  
   
  
## Examples  
 В следующем примере свойство `AquariumSize` зависимостей регистрируется как доступное только для чтения. В примере определяется `AquariumSizeKey` как внутренний ключ (чтобы другие классы в сборке могли переопределять метаданные) и предоставляет идентификатор свойства зависимости, основанный на этом `AquariumSizeProperty`ключе. Кроме того, создается оболочка для `AquariumSize`с методом доступа get.  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Имя регистрируемого свойства зависимостей.</param>
        <param name="propertyType">Тип свойства.</param>
        <param name="ownerType">Тип владельца, регистрирующий свойство зависимостей.</param>
        <param name="typeMetadata">Метаданные свойства зависимостей.</param>
        <param name="validateValueCallback">Ссылка на созданный пользователем обратный вызов, который должен выполнить пользовательскую проверку значения свойства зависимостей после обычной проверки типа.</param>
        <summary>Регистрирует доступное только для чтения свойство зависимостей с указанным типом свойства, типом владельца, метаданными свойства и обратным вызовом для проверки.</summary>
        <returns>Ключ свойства зависимостей, который следует использовать для задания значения статического доступного только для чтения поля в вашем классе, которое затем используется для ссылки на свойство зависимостей.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает тип <xref:System.Windows.DependencyPropertyKey>, <xref:System.Windows.DependencyProperty.RegisterAttached%2A> тогда как возвращает тип <xref:System.Windows.DependencyProperty>. Как правило, ключи, представляющие свойства только для чтения, не являются общедоступными, поскольку ключи можно использовать для установки значения свойства зависимостей путем вызова <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Разработка класса повлияет на ваши требования, но обычно рекомендуется ограничить доступ и видимость любых <xref:System.Windows.DependencyPropertyKey> элементов только теми частями кода, которые необходимы для задания этого свойства зависимостей как части логики класса или приложения. Также рекомендуется предоставить идентификатор свойства зависимостей для свойства зависимостей "только для чтения", предоставив значение <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> в `public static readonly` качестве поля в классе.  
  
 Свойства зависимостей только для чтения являются довольно типичным сценарием. Значение свойства зависимости, доступное только для чтения, можно использовать в качестве основания для других операций системы свойств, принимающих свойство зависимостей, например <xref:System.Windows.Trigger> для свойства зависимостей в стиле.  
  
 Дополнительные сведения о регистрации свойств зависимостей см. в <xref:System.Windows.DependencyProperty>разделе.  
  
 Проверка свойства зависимостей, доступного только для чтения, может быть менее важной. Неоткрытый уровень доступа, указанный для ключа, снижает вероятность неправильного ввода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dependencyProperty.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает строковое представление свойства зависимостей.</summary>
        <returns>Строковое представление свойства зависимостей.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта реализация возвращает <xref:System.Windows.DependencyProperty.Name%2A> значение свойства.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.DependencyProperty.Name" />
      </Docs>
    </Member>
    <Member MemberName="UnsetValue">
      <MemberSignature Language="C#" Value="public static readonly object UnsetValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object UnsetValue" />
      <MemberSignature Language="DocId" Value="F:System.Windows.DependencyProperty.UnsetValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnsetValue As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ UnsetValue;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnsetValue : obj" Usage="System.Windows.DependencyProperty.UnsetValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Задает статическое значение, используемое системой свойств [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] вместо <see langword="null" /> для указания того, что свойство существует, но его значение не задано системой свойств.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.DependencyProperty.UnsetValue>значение Sentinel, которое используется в сценариях, когда [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] системе свойств не удается определить запрошенное <xref:System.Windows.DependencyProperty> значение. <xref:System.Windows.DependencyProperty.UnsetValue>используется вместо `null`, поскольку `null` может быть допустимым значением свойства, а также допустимым (и часто используемым) <xref:System.Windows.PropertyMetadata.DefaultValue%2A>.  
  
 <xref:System.Windows.DependencyProperty.UnsetValue>никогда не возвращается из <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType>. При вызове <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType> свойства <xref:System.Windows.DependencyObject> зависимостей в экземпляре применяется одно из следующих условий.  
  
-   Свойство зависимостей имеет значение по умолчанию, установленное в метаданных и возвращаемое значение. Это значение может быть получено из <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.  
  
-   Другое значение было установлено системой свойств, и значение по умолчанию больше не применяется. Дополнительные сведения см. в разделе [Приоритет значений свойств зависимостей](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 <xref:System.Windows.PropertyMetadata.DefaultValue%2A> Установка объекта <xref:System.Windows.DependencyProperty.UnsetValue> явно запрещена.  
  
 <xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=nameWithType>Возвращает <xref:System.Windows.DependencyProperty.UnsetValue> , если запрошенное свойство не задано локально.  
  
 <xref:System.Windows.DependencyProperty.UnsetValue>имеет специальное значение при использовании в качестве возвращаемого значения <xref:System.Windows.CoerceValueCallback>. Дополнительные сведения см. в разделе [обратные вызовы и проверка свойства зависимостей](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
 При привязке к базе данных обратите внимание, <xref:System.Windows.DependencyProperty.UnsetValue> что не <xref:System.DBNull.Value>эквивалентно, аналогично тому, как <xref:System.DBNull.Value> не эквивалентно значению true null.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.ValidateValueCallback ValidateValueCallback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ValidateValueCallback ValidateValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValidateValueCallback As ValidateValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ValidateValueCallback ^ ValidateValueCallback { System::Windows::ValidateValueCallback ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValidateValueCallback : System.Windows.ValidateValueCallback" Usage="System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ValidateValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает обратный вызов для проверки значения свойства зависимостей.</summary>
        <value>Обратный вызов для проверки значения данного свойства зависимостей, указанный параметром <paramref name="validateValueCallback" /> при изначальной регистрации свойства зависимостей.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство будет содержать `null` любое свойство зависимости без зарегистрированного обратного вызова проверки.  
  
 Обратные вызовы проверки значений должны действовать в статическом смысле: Проверка, применяемая <xref:System.Windows.ValidateValueCallback> с помощью, не может определить, является ли предоставленное значение допустимым для любого конкретного экземпляра. Обратный вызов может определить, должны ли все объекты, имеющие свойство зависимости, или не принимать предоставленное значение как допустимое. Если необходимо выполнить проверку, которая основывается на значениях других свойств зависимостей в конкретном экземпляре, используйте <xref:System.Windows.CoerceValueCallback> вместо него. <xref:System.Windows.CoerceValueCallback> Регистрируется как часть метаданных свойства зависимостей, а не непосредственно в идентификаторе свойства зависимостей. Дополнительные сведения см. в разделе [обратные вызовы и проверка свойства зависимостей](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ValidateValueCallback" />
      </Docs>
    </Member>
  </Members>
</Type>