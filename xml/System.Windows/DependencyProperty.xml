<Type Name="DependencyProperty" FullName="System.Windows.DependencyProperty">
  <Metadata><Meta Name="ms.openlocfilehash" Value="98d26600187a9167e7848ac403e5d62c852a04e1" /><Meta Name="ms.sourcegitcommit" Value="0084afad1b3b1cb2c8ad2c142ae3597d08bad4a7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="10/31/2019" /><Meta Name="ms.locfileid" Value="73347794" /></Metadata><TypeSignature Language="C#" Value="public sealed class DependencyProperty" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DependencyProperty extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyProperty" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DependencyProperty" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyProperty sealed" />
  <TypeSignature Language="F#" Value="type DependencyProperty = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.ValueSerializer(typeof(System.Windows.DependencyPropertyValueSerializer))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="2fec7-101">Представляет свойство, которое можно задать с помощью методов, например стили, привязки данных, анимации и наследование.</span><span class="sxs-lookup"><span data-stu-id="2fec7-101">Represents a property that can be set through methods such as, styling, data binding, animation, and inheritance.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2fec7-102"><xref:System.Windows.DependencyProperty> поддерживает следующие возможности в [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)].</span><span class="sxs-lookup"><span data-stu-id="2fec7-102">A <xref:System.Windows.DependencyProperty> supports the following capabilities in [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]:</span></span>  
  
-   <span data-ttu-id="2fec7-103">Свойство может быть задано в стиле.</span><span class="sxs-lookup"><span data-stu-id="2fec7-103">The property can be set in a style.</span></span> <span data-ttu-id="2fec7-104">Более подробную информацию см. в разделе [Стилизация и использование шаблонов](~/docs/framework/wpf/controls/styling-and-templating.md).</span><span class="sxs-lookup"><span data-stu-id="2fec7-104">For more information, see [Styling and Templating](~/docs/framework/wpf/controls/styling-and-templating.md).</span></span>  
  
-   <span data-ttu-id="2fec7-105">Это свойство можно задать с помощью привязки данных.</span><span class="sxs-lookup"><span data-stu-id="2fec7-105">The property can be set through data binding.</span></span> <span data-ttu-id="2fec7-106">Дополнительные сведения о свойствах зависимостей привязки данных см. в разделе [как привязать свойства двух элементов управления](~/docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md).</span><span class="sxs-lookup"><span data-stu-id="2fec7-106">For more information about data binding dependency properties, see [How to: Bind the Properties of Two Controls](~/docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md).</span></span>  
  
-   <span data-ttu-id="2fec7-107">Для свойства можно задать ссылку на динамический ресурс.</span><span class="sxs-lookup"><span data-stu-id="2fec7-107">The property can be set with a dynamic resource reference.</span></span> <span data-ttu-id="2fec7-108">Дополнительные сведения см. в разделе [Ресурсы XAML](~/docs/framework/wpf/advanced/xaml-resources.md).</span><span class="sxs-lookup"><span data-stu-id="2fec7-108">For more information, see [XAML Resources](~/docs/framework/wpf/advanced/xaml-resources.md).</span></span>  
  
-   <span data-ttu-id="2fec7-109">Свойство может наследовать свое значение автоматически от родительского элемента в дереве элементов.</span><span class="sxs-lookup"><span data-stu-id="2fec7-109">The property can inherit its value automatically from a parent element in the element tree.</span></span> <span data-ttu-id="2fec7-110">Дополнительные сведения см. в разделе [Наследование значения свойства](~/docs/framework/wpf/advanced/property-value-inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="2fec7-110">For more information, see [Property Value Inheritance](~/docs/framework/wpf/advanced/property-value-inheritance.md).</span></span>  
  
-   <span data-ttu-id="2fec7-111">Свойство может быть анимировано.</span><span class="sxs-lookup"><span data-stu-id="2fec7-111">The property can be animated.</span></span> <span data-ttu-id="2fec7-112">Более подробную информацию см. в разделе [Общие сведения об эффектах анимации](~/docs/framework/wpf/graphics-multimedia/animation-overview.md).</span><span class="sxs-lookup"><span data-stu-id="2fec7-112">For more information, see [Animation Overview](~/docs/framework/wpf/graphics-multimedia/animation-overview.md).</span></span>  
  
-   <span data-ttu-id="2fec7-113">Свойство может сообщать о том, что предыдущее значение свойства было изменено и значение свойства может быть приведено.</span><span class="sxs-lookup"><span data-stu-id="2fec7-113">The property can report when the previous value of the property has been changed and the property value can be coerced.</span></span> <span data-ttu-id="2fec7-114">Дополнительные сведения см. в разделе [Проверка и обратные вызовы свойства зависимостей](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).</span><span class="sxs-lookup"><span data-stu-id="2fec7-114">For more information, see [Dependency Property Callbacks and Validation](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).</span></span>  
  
-   <span data-ttu-id="2fec7-115">Свойство сообщает сведения [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], например, должно ли изменение значения свойства требовать от системы макета перекомпозицию визуальных элементов для элемента.</span><span class="sxs-lookup"><span data-stu-id="2fec7-115">The property reports information to [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], such as whether changing a property value should require the layout system to recompose the visuals for an element.</span></span>  
  
-   <span data-ttu-id="2fec7-116">Свойство получает поддержку в [!INCLUDE[wpfdesigner_current_long](~/includes/wpfdesigner-current-long-md.md)].</span><span class="sxs-lookup"><span data-stu-id="2fec7-116">The property receives support in the [!INCLUDE[wpfdesigner_current_long](~/includes/wpfdesigner-current-long-md.md)].</span></span>  <span data-ttu-id="2fec7-117">Например, свойство можно изменить в окне **Свойства** .</span><span class="sxs-lookup"><span data-stu-id="2fec7-117">For example, the property can be edited in the **Properties** window.</span></span>  
  
 <span data-ttu-id="2fec7-118">Дополнительные сведения о свойствах зависимостей см. в разделе [Общие сведения о свойствах зависимостей](~/docs/framework/wpf/advanced/dependency-properties-overview.md).</span><span class="sxs-lookup"><span data-stu-id="2fec7-118">To learn more about dependency properties, see [Dependency Properties Overview](~/docs/framework/wpf/advanced/dependency-properties-overview.md).</span></span> <span data-ttu-id="2fec7-119">Если требуется, чтобы свойства пользовательских типов поддерживали возможности из предыдущего списка, следует создать свойство зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-119">If you want properties on your custom types to support the capabilities in the preceding list, you should create a dependency property.</span></span>  <span data-ttu-id="2fec7-120">Сведения о создании пользовательских свойств зависимостей см. в разделе [пользовательские свойства зависимостей](~/docs/framework/wpf/advanced/custom-dependency-properties.md).</span><span class="sxs-lookup"><span data-stu-id="2fec7-120">To learn how to create custom dependency properties, see [Custom Dependency Properties](~/docs/framework/wpf/advanced/custom-dependency-properties.md).</span></span>  
  
 <span data-ttu-id="2fec7-121">Присоединенное свойство — это свойство, которое позволяет любому объекту передавать сведения в тип, определяющий присоединенное свойство.</span><span class="sxs-lookup"><span data-stu-id="2fec7-121">An attached property is a property that enables any object to report information to the type that defines the attached property.</span></span> <span data-ttu-id="2fec7-122">В [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]любой тип, наследующий от <xref:System.Windows.DependencyObject>, может использовать присоединенное свойство независимо от того, наследуется ли тип от типа, определяющего свойство.</span><span class="sxs-lookup"><span data-stu-id="2fec7-122">In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], any type that inherits from <xref:System.Windows.DependencyObject> can use an attached property regardless of whether the type inherits from the type that defines the property.</span></span> <span data-ttu-id="2fec7-123">Присоединенное свойство — это функция языка [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="2fec7-123">An attached property is a feature of the [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] language.</span></span>  <span data-ttu-id="2fec7-124">Чтобы задать присоединенное свойство в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], используйте параметр *OwnerType*. *PropertyName* , синтаксис.</span><span class="sxs-lookup"><span data-stu-id="2fec7-124">To set an attached property in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], use the *ownerType*.*propertyName* syntax.</span></span> <span data-ttu-id="2fec7-125">Примером вложенного свойства является свойство <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-125">An example of an attached property is the <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="2fec7-126">Если необходимо создать свойство, которое можно использовать для всех типов <xref:System.Windows.DependencyObject>, следует создать присоединенное свойство.</span><span class="sxs-lookup"><span data-stu-id="2fec7-126">If you want to create a property that can be used on all <xref:System.Windows.DependencyObject> types, then you should create an attached property.</span></span> <span data-ttu-id="2fec7-127">Дополнительные сведения о вложенных свойствах, включая способы их создания, см. в разделе [Общие сведения о вложенных свойствах](~/docs/framework/wpf/advanced/attached-properties-overview.md).</span><span class="sxs-lookup"><span data-stu-id="2fec7-127">To learn more about attached properties, including how to create them, see [Attached Properties Overview](~/docs/framework/wpf/advanced/attached-properties-overview.md).</span></span>  
  
<a name="xamlAttributeUsage_DependencyProperty"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="2fec7-128">Использование атрибута XAML</span><span class="sxs-lookup"><span data-stu-id="2fec7-128">XAML Attribute Usage</span></span>  
  
```xaml 
<object property="dependencyPropertyName"/>  
```

<span data-ttu-id="2fec7-129">- или -</span><span class="sxs-lookup"><span data-stu-id="2fec7-129">-or-</span></span>

```xaml
<object property="ownerType.dependencyPropertyName"/>  
```

<span data-ttu-id="2fec7-130">- или -</span><span class="sxs-lookup"><span data-stu-id="2fec7-130">-or-</span></span>

```xaml
<object property="attachedPropertyOwnerType.attachedPropertyName"/>  
```  
  
<a name="xamlValues_DependencyProperty"></a>   
## <a name="xaml-values"></a><span data-ttu-id="2fec7-131">Значения XAML</span><span class="sxs-lookup"><span data-stu-id="2fec7-131">XAML Values</span></span>  
 `dependencyPropertyName`  
 <span data-ttu-id="2fec7-132">Строка, указывающая <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType> требуемого свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-132">A string that specifies the <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType> of the desired dependency property.</span></span> <span data-ttu-id="2fec7-133">Перед ним может стоять префикс пространства имен XML, если свойство отсутствует в пространстве имен XML по умолчанию (Дополнительные сведения см. в разделе [пространства имен XAML и сопоставление пространств имен для WPF XAML](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).)</span><span class="sxs-lookup"><span data-stu-id="2fec7-133">This can be preceded by an XML namespace prefix if the property is not in the default XML namespace (for details, see [XAML Namespaces and Namespace Mapping for WPF XAML](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).)</span></span>  
  
 <span data-ttu-id="2fec7-134">`ownerType`.`dependencyPropertyName`</span><span class="sxs-lookup"><span data-stu-id="2fec7-134">`ownerType`.`dependencyPropertyName`</span></span>  
 <span data-ttu-id="2fec7-135">Строка, указывающая тип владельца свойства зависимостей, точка (.), а затем <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-135">A string that specifies an owner type of a dependency property, a dot (.), then the <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="2fec7-136">`ownerType` также может предшествовать префикс пространства имен XML.</span><span class="sxs-lookup"><span data-stu-id="2fec7-136">`ownerType` can also be preceded by an XML namespace prefix.</span></span> <span data-ttu-id="2fec7-137">Это использование относится к стилям и шаблонам с поздним связыванием, где владелец свойства зависимостей должен быть указан для контекста синтаксического анализа, так как `TargetType` еще не известны.</span><span class="sxs-lookup"><span data-stu-id="2fec7-137">This usage is particular to late-bound styles and templates, where the owner of the dependency property must be specified for parsing context because the `TargetType` is not yet known.</span></span> <span data-ttu-id="2fec7-138">Более подробную информацию см. в разделе [Стилизация и использование шаблонов](~/docs/framework/wpf/controls/styling-and-templating.md).</span><span class="sxs-lookup"><span data-stu-id="2fec7-138">For more information, see [Styling and Templating](~/docs/framework/wpf/controls/styling-and-templating.md).</span></span>  
  
 <span data-ttu-id="2fec7-139">`attachedPropertyOwnerType` *.*</span><span class="sxs-lookup"><span data-stu-id="2fec7-139">`attachedPropertyOwnerType` *.*</span></span> `attachedPropertyName`  
 <span data-ttu-id="2fec7-140">Строка, указывающая владельца присоединенного свойства, точки (.), а затем имя присоединенного свойства.</span><span class="sxs-lookup"><span data-stu-id="2fec7-140">A string that specifies  the owner of an attached property, a dot (.), then the attached property name.</span></span> <span data-ttu-id="2fec7-141">`attachedPropertyOwnerType` также может предшествовать префикс пространства имен XML.</span><span class="sxs-lookup"><span data-stu-id="2fec7-141">`attachedPropertyOwnerType` can also be preceded by an XML namespace prefix.</span></span>  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyObject" />
    <altmember cref="T:System.Windows.DependencyPropertyHelper" />
  </Docs>
  <Members>
    <MemberGroup MemberName="AddOwner">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="2fec7-142">Добавляет другой тип в качестве владельца свойства зависимостей, который уже был зарегистрирован для типа.</span><span class="sxs-lookup"><span data-stu-id="2fec7-142">Adds another type as an owner of a dependency property that has already been registered to a type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner ownerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ownerType"><span data-ttu-id="2fec7-143">Тип для добавления в качестве владельца данного свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-143">The type to add as an owner of this dependency property.</span></span></param>
        <summary><span data-ttu-id="2fec7-144">Добавляет другой тип в качестве владельца свойства зависимостей, которое уже зарегистрировано.</span><span class="sxs-lookup"><span data-stu-id="2fec7-144">Adds another type as an owner of a dependency property that has already been registered.</span></span></summary>
        <returns><span data-ttu-id="2fec7-145">Ссылка на исходный идентификатор <see cref="T:System.Windows.DependencyProperty" />, который определяет свойство зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-145">A reference to the original <see cref="T:System.Windows.DependencyProperty" /> identifier that identifies the dependency property.</span></span> <span data-ttu-id="2fec7-146">Этот идентификатор должен быть представлен путем добавления класса в качестве поля <see langword="public static readonly" />.</span><span class="sxs-lookup"><span data-stu-id="2fec7-146">This identifier should be exposed by the adding class as a <see langword="public static readonly" /> field.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2fec7-147">Этот метод позволяет системе свойств распознать свойство зависимостей для типа, который изначально не зарегистрировал это конкретное свойство зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-147">This method enables the property system to recognize a dependency property on a type that did not register that particular dependency property initially.</span></span>  
  
 <span data-ttu-id="2fec7-148">Обычно <xref:System.Windows.DependencyProperty.AddOwner%2A> используется для добавления свойств зависимостей в классы, которые еще не предоставляют это свойство зависимостей через наследование управляемого класса (наследование класса приведет к тому, что свойства оболочки наследуются производным классом, и, таким образом, Предоставьте общие члены — доступ к таблицам для свойства зависимостей уже существует.</span><span class="sxs-lookup"><span data-stu-id="2fec7-148">Typically, <xref:System.Windows.DependencyProperty.AddOwner%2A> is used to add dependency properties to classes that do not already expose that dependency property through managed class inheritance (class inheritance would cause the wrapper properties to be inherited by the derived class, and thus would provide general members-table access to the dependency property already).</span></span> <span data-ttu-id="2fec7-149"><xref:System.Windows.DependencyProperty.AddOwner%2A> позволяет системе свойств распознать свойство зависимостей для типа, который не зарегистрировал это свойство зависимостей изначально.</span><span class="sxs-lookup"><span data-stu-id="2fec7-149"><xref:System.Windows.DependencyProperty.AddOwner%2A> enables the property system to recognize a dependency property on a type that did not register that dependency property initially.</span></span>  
  
 <span data-ttu-id="2fec7-150">Эта подпись не позволяет указывать метаданные.</span><span class="sxs-lookup"><span data-stu-id="2fec7-150">This signature does not allow for specifying metadata.</span></span>  <span data-ttu-id="2fec7-151">При использовании этого метода метаданные создаются автоматически для нового <xref:System.Windows.DependencyProperty> и типа владельца.</span><span class="sxs-lookup"><span data-stu-id="2fec7-151">When you use this method, the metadata is automatically generated for the new <xref:System.Windows.DependencyProperty> and its owner type.</span></span> <span data-ttu-id="2fec7-152">Автоматически созданные метаданные являются результатом Объединенных метаданных из всех базовых типов, для которых определено это свойство.</span><span class="sxs-lookup"><span data-stu-id="2fec7-152">The auto-generated metadata is the result of the merged metadata from all of the base types that have this property defined.</span></span> <span data-ttu-id="2fec7-153">Если объединенные метаданные недоступны, используются метаданные по умолчанию для свойства.</span><span class="sxs-lookup"><span data-stu-id="2fec7-153">If no merged metadata is available, then the default metadata for the property is used.</span></span> <span data-ttu-id="2fec7-154">Если свойство зарегистрировано с помощью метода <xref:System.Windows.DependencyProperty.RegisterAttached%2A>, то метаданные по умолчанию совпадают с метаданными, созданными при вызове <xref:System.Windows.DependencyProperty.RegisterAttached%2A>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-154">If the property is registered by using the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method, then the default metadata is the same as the metadata that is created when <xref:System.Windows.DependencyProperty.RegisterAttached%2A> was called.</span></span> <span data-ttu-id="2fec7-155">В противном случае создается объект <xref:System.Windows.PropertyMetadata> со свойством <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, для которого задано значение по умолчанию для типа свойства, а всем остальным свойствам <xref:System.Windows.PropertyMetadata> присваивается значение `null`.</span><span class="sxs-lookup"><span data-stu-id="2fec7-155">Otherwise, the <xref:System.Windows.PropertyMetadata> object is created with the <xref:System.Windows.PropertyMetadata.DefaultValue%2A> property set to the property type's default and all other properties of the <xref:System.Windows.PropertyMetadata> is set to `null`.</span></span> <span data-ttu-id="2fec7-156">Используйте сигнатуру <xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29>, если хотите предоставить метаданные для версии свойства зависимостей в соответствии с добавлением в предоставленный тип.</span><span class="sxs-lookup"><span data-stu-id="2fec7-156">Use the <xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29> signature if you want to provide metadata for the version of the dependency property as added to the provided type.</span></span>  
  
 <span data-ttu-id="2fec7-157">Возвращаемое значение этого метода обычно используется для объявления и предоставления свойства зависимостей путем сохранения идентификатора свойства зависимости.</span><span class="sxs-lookup"><span data-stu-id="2fec7-157">The return value of this method is typically used to declare and expose the dependency property by storing a dependency property identifier.</span></span> <span data-ttu-id="2fec7-158">Идентификатор предоставляет доступ к свойству зависимостей, если требуется вызывать API системы свойств для свойства зависимостей, особенно в том случае, если оно существует в классе добавления владельца.</span><span class="sxs-lookup"><span data-stu-id="2fec7-158">The identifier provides access to the dependency property if you want to call property system APIs against the dependency property, particularly as it exists on the adding owner class.</span></span> <span data-ttu-id="2fec7-159">Для указания аналогичной функциональности следует использовать одно и то же имя свойства для исходного владельца и добавленного владельца.</span><span class="sxs-lookup"><span data-stu-id="2fec7-159">The same property name for both original owner and added owner should be used to indicate the similar functionality.</span></span> <span data-ttu-id="2fec7-160">Следует использовать <xref:System.Windows.DependencyProperty> возвращаемое значение метода <xref:System.Windows.DependencyProperty.AddOwner%2A>, чтобы определить идентификатор свойства зависимости, а также объявить [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] оболочки свойств для свойств зависимостей, которые добавляются в типы с помощью <xref:System.Windows.DependencyProperty.AddOwner%2A>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-160">You should use the <xref:System.Windows.DependencyProperty> return value of the <xref:System.Windows.DependencyProperty.AddOwner%2A> method to define the dependency property identifier, and also to declare [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] property wrappers, for dependency properties that are added to types using <xref:System.Windows.DependencyProperty.AddOwner%2A>.</span></span>  
  
 <span data-ttu-id="2fec7-161">Описанная выше методика <xref:System.Windows.DependencyProperty.AddOwner%2A> используется при создании свойств зависимостей, объявленных в [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)].</span><span class="sxs-lookup"><span data-stu-id="2fec7-161">The <xref:System.Windows.DependencyProperty.AddOwner%2A> methodology recommended above is used when creating the dependency properties that are declared within [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)].</span></span> <span data-ttu-id="2fec7-162">Например, <xref:System.Windows.Controls.Border> и <xref:System.Windows.Controls.Control> определяют свойство зависимости `BorderBrush`, которое имеет аналогичные функции.</span><span class="sxs-lookup"><span data-stu-id="2fec7-162">For instance, both <xref:System.Windows.Controls.Border> and <xref:System.Windows.Controls.Control> define a `BorderBrush` dependency property, which have similar functionality.</span></span> <span data-ttu-id="2fec7-163"><xref:System.Windows.Controls.Control> определяет свойство `BorderBrush` для системы свойств путем вызова <xref:System.Windows.DependencyProperty.AddOwner%2A> на основе исходного <xref:System.Windows.Controls.Border> владельца и зарегистрированного <xref:System.Windows.Controls.Border.BorderBrushProperty> идентификатора свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-163"><xref:System.Windows.Controls.Control> defines its `BorderBrush` property to the property system by calling <xref:System.Windows.DependencyProperty.AddOwner%2A> based on the original owner <xref:System.Windows.Controls.Border> and its registered <xref:System.Windows.Controls.Border.BorderBrushProperty> dependency property identifer.</span></span> <span data-ttu-id="2fec7-164">Возвращаемое значение <xref:System.Windows.DependencyProperty.AddOwner%2A> используется для установления нового статического поля <xref:System.Windows.DependencyProperty> (<xref:System.Windows.Controls.Control.BorderBrushProperty>) для этого свойства добавленного владельца, а также объявление оболочки свойства `BorderBrush`.</span><span class="sxs-lookup"><span data-stu-id="2fec7-164">The <xref:System.Windows.DependencyProperty.AddOwner%2A> return value is then used to establish a new static <xref:System.Windows.DependencyProperty> field (<xref:System.Windows.Controls.Control.BorderBrushProperty>) for that property on the added owner, and a `BorderBrush` property wrapper is also declared.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner (ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="ownerType"><span data-ttu-id="2fec7-165">Тип для добавления в качестве владельца данного свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-165">The type to add as owner of this dependency property.</span></span></param>
        <param name="typeMetadata"><span data-ttu-id="2fec7-166">Метаданные, квалифицирующие свойство зависимостей в том виде, в котором оно существует в указанном типе.</span><span class="sxs-lookup"><span data-stu-id="2fec7-166">The metadata that qualifies the dependency property as it exists on the provided type.</span></span></param>
        <summary><span data-ttu-id="2fec7-167">Добавляет другой тип в качестве владельца свойства зависимостей, который уже был зарегистрирован, предоставляя метаданные свойства зависимости для свойства зависимостей в том виде, в котором оно будет существовать в предоставленном типе владельца.</span><span class="sxs-lookup"><span data-stu-id="2fec7-167">Adds another type as an owner of a dependency property that has already been registered, providing dependency property metadata for the dependency property as it will exist on the provided owner type.</span></span></summary>
        <returns><span data-ttu-id="2fec7-168">Ссылка на исходный идентификатор <see cref="T:System.Windows.DependencyProperty" />, который определяет свойство зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-168">A reference to the original <see cref="T:System.Windows.DependencyProperty" /> identifier that identifies the dependency property.</span></span> <span data-ttu-id="2fec7-169">Этот идентификатор должен быть представлен путем добавления класса в качестве поля <see langword="public static readonly" />.</span><span class="sxs-lookup"><span data-stu-id="2fec7-169">This identifier should be exposed by the adding class as a <see langword="public static readonly" /> field.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2fec7-170">Этот метод позволяет системе свойств распознать свойство зависимостей для типа, который изначально не зарегистрировал это конкретное свойство зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-170">This method enables the property system to recognize a dependency property on a type that did not register that particular dependency property initially.</span></span>  
  
 <span data-ttu-id="2fec7-171">Возвращаемое значение этого метода используется для объявления и предоставления свойства зависимостей, особенно в том случае, если оно существует в классе добавления владельца.</span><span class="sxs-lookup"><span data-stu-id="2fec7-171">The return value of this method is used to declare and expose the dependency property, particularly as it exists on the adding owner class.</span></span> <span data-ttu-id="2fec7-172">Как правило, для указания аналогичной функциональности следует использовать одно и то же имя свойства для исходного владельца и добавленного владельца.</span><span class="sxs-lookup"><span data-stu-id="2fec7-172">Generally, the same property name for both original owner and added owner should be used to indicate the similar functionality.</span></span> <span data-ttu-id="2fec7-173">Рекомендуется предоставлять идентификаторы, а также новые [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]ные оболочки свойств для свойств зависимостей, которые добавляются в типы с помощью <xref:System.Windows.DependencyProperty.AddOwner%2A>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-173">It is good practice to expose the identifiers, as well as new [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] property wrappers, for dependency properties that are added to types using <xref:System.Windows.DependencyProperty.AddOwner%2A>.</span></span>  
  
 <span data-ttu-id="2fec7-174">Описанная выше методика <xref:System.Windows.DependencyProperty.AddOwner%2A> используется при создании API, объявленных в [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)].</span><span class="sxs-lookup"><span data-stu-id="2fec7-174">The <xref:System.Windows.DependencyProperty.AddOwner%2A> methodology recommended above is used when creating APIs declared within [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)].</span></span> <span data-ttu-id="2fec7-175">Например, <xref:System.Windows.Controls.Border> и <xref:System.Windows.Controls.Control> определяют свойство зависимости `BorderBrush`, которое имеет аналогичные функции.</span><span class="sxs-lookup"><span data-stu-id="2fec7-175">For instance, both <xref:System.Windows.Controls.Border> and <xref:System.Windows.Controls.Control> define a `BorderBrush` dependency property, which have similar functionality.</span></span> <span data-ttu-id="2fec7-176"><xref:System.Windows.Controls.Control> определяет свойство `BorderBrush` для системы свойств, вызывая <xref:System.Windows.DependencyProperty.AddOwner%2A> в исходном <xref:System.Windows.Controls.Border> владельца и зарегистрированный идентификатор свойства <xref:System.Windows.Controls.Border.BorderBrushProperty> зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-176"><xref:System.Windows.Controls.Control> defines its `BorderBrush` property to the property system by calling <xref:System.Windows.DependencyProperty.AddOwner%2A> on original owner <xref:System.Windows.Controls.Border> and its registered <xref:System.Windows.Controls.Border.BorderBrushProperty> dependency property identifer.</span></span> <span data-ttu-id="2fec7-177">Возвращаемое значение <xref:System.Windows.DependencyProperty.AddOwner%2A> используется для установки статического поля <xref:System.Windows.DependencyProperty> (<xref:System.Windows.Controls.Control.BorderBrushProperty>) для этого свойства добавленного владельца, а также объявление оболочки свойства `BorderBrush`.</span><span class="sxs-lookup"><span data-stu-id="2fec7-177">The <xref:System.Windows.DependencyProperty.AddOwner%2A> return value is then used to establish a static <xref:System.Windows.DependencyProperty> field (<xref:System.Windows.Controls.Control.BorderBrushProperty>) for that property on the added owner, and a `BorderBrush` property wrapper is also declared.</span></span>  
  
 <span data-ttu-id="2fec7-178">Идентификатор свойства зависимостей добавленного владельца следует использовать для таких операций, как <xref:System.Windows.DependencyObject.GetValue%2A>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-178">The added owner's dependency property identifier should be used for operations such as <xref:System.Windows.DependencyObject.GetValue%2A>.</span></span> <span data-ttu-id="2fec7-179">Однако операции с определенными типами, включающие либо типы, либо экземпляры класса, добавленного в качестве владельца с разными метаданными, по-прежнему будут возвращать ожидаемые результаты, даже если в параметре не указан исходный идентификатор свойства зависимостей (не добавленного владельца). вызывает методы, такие как <xref:System.Windows.DependencyObject.GetValue%2A> или <xref:System.Windows.DependencyProperty.GetMetadata%2A>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-179">However, type-specific operations involving either types or instances of the class that was added as owner with different metadata will still return the expected results even if the original (not the added owner's) dependency property identifier is specified in calls to methods such as <xref:System.Windows.DependencyObject.GetValue%2A> or <xref:System.Windows.DependencyProperty.GetMetadata%2A>.</span></span> <span data-ttu-id="2fec7-180">Метаданные для добавленного владельца сохраняются с помощью <xref:System.Windows.DependencyProperty.AddOwner%2A> вызове самого себя, а не обязательно ссылаться только на поле идентификатора класса, добавленного владельцем.</span><span class="sxs-lookup"><span data-stu-id="2fec7-180">The metadata for the added owner is perpetuated by the <xref:System.Windows.DependencyProperty.AddOwner%2A> call itself, not necessarily referenced exclusively by the adding owner class identifier field.</span></span> <span data-ttu-id="2fec7-181">Тем не менее, рекомендуется предоставлять идентификатор, а также новые оболочки свойств [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] для свойств зависимостей, которые добавляются к типам с помощью <xref:System.Windows.DependencyProperty.AddOwner%2A>, так как при этом происходит несоответствие между [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] и [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] представления свойств.</span><span class="sxs-lookup"><span data-stu-id="2fec7-181">Nevertheless, it is good practice to expose the  identifier, as well as new [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] property wrappers, for dependency properties that are added to types using <xref:System.Windows.DependencyProperty.AddOwner%2A>, because failing to do so creates disparity between the [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] and [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] representations of your properties.</span></span>  
  
 <span data-ttu-id="2fec7-182">Переданные метаданные объединяются с метаданными свойств для свойства зависимостей в том виде, в котором они существуют в базовом владельце.</span><span class="sxs-lookup"><span data-stu-id="2fec7-182">The supplied metadata is merged with the property metadata for the dependency property as it exists on the base owner.</span></span> <span data-ttu-id="2fec7-183">Все характеристики, заданные в исходных базовых метаданных, сохраняются.</span><span class="sxs-lookup"><span data-stu-id="2fec7-183">Any characteristics that were specified in the original base metadata will persist.</span></span> <span data-ttu-id="2fec7-184">Только те характеристики, которые были изменены в новых метаданных, будут переопределять характеристики базовых метаданных.</span><span class="sxs-lookup"><span data-stu-id="2fec7-184">Only those characteristics that were specifically changed in the new metadata will override the characteristics of the base metadata.</span></span> <span data-ttu-id="2fec7-185">Некоторые характеристики, такие как <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, заменяются, если они указаны в новых метаданных.</span><span class="sxs-lookup"><span data-stu-id="2fec7-185">Some characteristics, such as <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, are replaced if they are specified in the new metadata.</span></span> <span data-ttu-id="2fec7-186">Другие, например <xref:System.Windows.PropertyChangedCallback>, объединяются.</span><span class="sxs-lookup"><span data-stu-id="2fec7-186">Others, such as <xref:System.Windows.PropertyChangedCallback>, are combined.</span></span> <span data-ttu-id="2fec7-187">В конечном итоге, поведение слияния зависит от типа метаданных свойства, используемого для переопределения, поэтому описанное здесь поведение предназначено для существующих классов метаданных свойств, используемых [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] свойствами зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-187">Ultimately, the merge behavior depends on the property metadata type being used for the override, so the behavior described here is for the existing property metadata classes used by [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] dependency properties.</span></span> <span data-ttu-id="2fec7-188">Дополнительные сведения см. в разделе [метаданные свойств зависимостей](~/docs/framework/wpf/advanced/dependency-property-metadata.md) и [метаданные свойств платформы](~/docs/framework/wpf/advanced/framework-property-metadata.md).</span><span class="sxs-lookup"><span data-stu-id="2fec7-188">For details, see [Dependency Property Metadata](~/docs/framework/wpf/advanced/dependency-property-metadata.md) and [Framework Property Metadata](~/docs/framework/wpf/advanced/framework-property-metadata.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata DefaultMetadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyMetadata DefaultMetadata" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultMetadata As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyMetadata ^ DefaultMetadata { System::Windows::PropertyMetadata ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMetadata : System.Windows.PropertyMetadata" Usage="System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2fec7-189">Возвращает метаданные свойства зависимостей по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="2fec7-189">Gets the default metadata of the dependency property.</span></span></summary>
        <value><span data-ttu-id="2fec7-190">Метаданные свойства зависимостей по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="2fec7-190">The default metadata of the dependency property.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2fec7-191">Метаданные по умолчанию — это метаданные свойства, доступные для данного конкретного объекта, или объект производного типа, в котором альтернативные метаданные не были предоставлены явным <xref:System.Windows.DependencyProperty.Register%2A> или вызовом <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-191">The default metadata is the property metadata that is available to that particular object or an object of a derived type where no alternative metadata was supplied by an explicit <xref:System.Windows.DependencyProperty.Register%2A> or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> call.</span></span>  
  
 <span data-ttu-id="2fec7-192">Если исходный владелец применяет метаданные к первому <xref:System.Windows.DependencyProperty.Register%2A> вызову, который установил свойство зависимостей, то метаданные возвращаются как <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-192">If the original owner applied metadata to the first <xref:System.Windows.DependencyProperty.Register%2A> call that established the dependency property, then that metadata is returned as <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.</span></span>  
  
 <span data-ttu-id="2fec7-193">Если в исходном вызове <xref:System.Windows.DependencyProperty.Register%2A> не были применены метаданные, то метаданные по умолчанию создаются из <xref:System.Windows.DependencyProperty.Register%2A> вызова, а это значение возвращается в качестве <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-193">If no metadata was applied in the original <xref:System.Windows.DependencyProperty.Register%2A> call, then default metadata is generated from within the <xref:System.Windows.DependencyProperty.Register%2A> call and this value is returned as the <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.</span></span>  
  
 <span data-ttu-id="2fec7-194">Основная цель наличия метаданных по умолчанию, связанных с <xref:System.Windows.DependencyProperty>, заключается в предоставлении значения по умолчанию для этого свойства в любом <xref:System.Windows.DependencyObject> или производном типе.</span><span class="sxs-lookup"><span data-stu-id="2fec7-194">The main purpose of having default metadata associated with a <xref:System.Windows.DependencyProperty> is to supply a default value for this property on any <xref:System.Windows.DependencyObject> or a derived type.</span></span>  
  
 <span data-ttu-id="2fec7-195">Для неприсоединенных свойств тип метаданных, возвращаемый этим свойством, не может быть приведен к производным типам <xref:System.Windows.PropertyMetadata>ого типа, даже если свойство изначально было зарегистрировано в производном типе метаданных.</span><span class="sxs-lookup"><span data-stu-id="2fec7-195">For nonattached properties, the metadata type returned by this property cannot be cast to derived types of <xref:System.Windows.PropertyMetadata> type, even if the property was originally registered with a derived metadata type.</span></span> <span data-ttu-id="2fec7-196">Если вы хотите, чтобы изначально зарегистрированные метаданные, включая исходный, возможно, производный тип метаданных, вызовите <xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29> вместо этого, передав исходный тип регистрации в качестве параметра.</span><span class="sxs-lookup"><span data-stu-id="2fec7-196">If you want the originally registered metadata including its original possibly derived metadata type, call <xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29> instead, passing the original registering type as a parameter.</span></span>  
  
 <span data-ttu-id="2fec7-197">Для вложенных свойств тип метаданных, возвращаемых этим свойством, будет совпадать с типом, заданным в исходном методе регистрации <xref:System.Windows.DependencyProperty.RegisterAttached%2A>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-197">For attached properties, the type of the metadata returned by this property will match the type given in the original <xref:System.Windows.DependencyProperty.RegisterAttached%2A> registration method.</span></span>  
  
   
  
## Examples  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpdefaultvalue)]
[!code-vb[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpdefaultvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dependencyProperty.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2fec7-198">Возвращает хэш-код для данного свойства <see cref="T:System.Windows.DependencyProperty" />.</span><span class="sxs-lookup"><span data-stu-id="2fec7-198">Returns a hash code for this <see cref="T:System.Windows.DependencyProperty" />.</span></span></summary>
        <returns><span data-ttu-id="2fec7-199">Хэш-код для этого экземпляра <see cref="T:System.Windows.DependencyProperty" />.</span><span class="sxs-lookup"><span data-stu-id="2fec7-199">The hash code for this <see cref="T:System.Windows.DependencyProperty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2fec7-200">Система свойств использует собственный уникальный идентификатор <xref:System.Windows.DependencyProperty.GlobalIndex%2A>, а значение этого свойства возвращается <xref:System.Windows.DependencyProperty.GetHashCode%2A>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-200">The property system uses its own unique identifier <xref:System.Windows.DependencyProperty.GlobalIndex%2A>, and the value of that property is returned by <xref:System.Windows.DependencyProperty.GetHashCode%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="2fec7-201">Возвращает метаданные, связанные с данным свойством зависимостей в том виде, в котором оно существует для конкретного типа.</span><span class="sxs-lookup"><span data-stu-id="2fec7-201">Returns the metadata associated with this dependency property as it exists for a particular type.</span></span> <span data-ttu-id="2fec7-202">Это может быть тип, в котором свойство зависимостей было изначально зарегистрировано, тип, к которому оно было добавлено позже, или тип, в котором свойство зависимостей было получено путем наследования, но метаданные были переопределены.</span><span class="sxs-lookup"><span data-stu-id="2fec7-202">This can be the type where the dependency property was first registered, one to which it was added subsequently, or a type where the dependency property was obtained through inheritance but the metadata was specifically overridden.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (Type forType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Type forType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMetadata (forType As Type) As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(Type ^ forType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : Type -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata forType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="forType"><span data-ttu-id="2fec7-203">Конкретный тип, из которого необходимо извлечь метаданные свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-203">The specific type from which to retrieve the dependency property metadata.</span></span></param>
        <summary><span data-ttu-id="2fec7-204">Возвращает метаданные для этого свойства зависимостей в том виде, в котором оно представлено в указанном существующем типе.</span><span class="sxs-lookup"><span data-stu-id="2fec7-204">Returns the metadata for this dependency property as it exists on a specified existing type.</span></span></summary>
        <returns><span data-ttu-id="2fec7-205">Объект метаданных свойств.</span><span class="sxs-lookup"><span data-stu-id="2fec7-205">A property metadata object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2fec7-206">Указание типа или ссылки на объект для использования в качестве типа является обязательным, так как метаданные могут отличаться от исходной регистрации из-за <xref:System.Windows.DependencyProperty.AddOwner%2A> или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> вызовов, которые изменяют метаданные свойства зависимостей в том виде, в каком они существуют в типе.</span><span class="sxs-lookup"><span data-stu-id="2fec7-206">Specifying either the type or an object reference to use as type is necessary because the metadata can vary from the original registration due either to <xref:System.Windows.DependencyProperty.AddOwner%2A> or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> calls that alter the metadata of the dependency property as it exists on a type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2fec7-207">В следующем примере показано получение метаданных для свойства зависимости на основе его типа.</span><span class="sxs-lookup"><span data-stu-id="2fec7-207">The following example gets metadata for a dependency property based on its type.</span></span> <span data-ttu-id="2fec7-208">Тип получен с помощью оператора `typeof`.</span><span class="sxs-lookup"><span data-stu-id="2fec7-208">The type is obtained by using a `typeof` operator.</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatatype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatatype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObject -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject"><span data-ttu-id="2fec7-209">Объект зависимости, проверяемый на наличие типа, чтобы определить, из какой типозависимой версии свойства зависимости нужно использовать метаданные.</span><span class="sxs-lookup"><span data-stu-id="2fec7-209">A dependency object that is checked for type, to determine which type-specific version of the dependency property the metadata should come from.</span></span></param>
        <summary><span data-ttu-id="2fec7-210">Возвращает метаданные для этого свойства зависимостей в том виде,в котором оно существует в указанном экземпляре объекта.</span><span class="sxs-lookup"><span data-stu-id="2fec7-210">Returns the metadata for this dependency property as it exists on the specified object instance.</span></span></summary>
        <returns><span data-ttu-id="2fec7-211">Объект метаданных свойств.</span><span class="sxs-lookup"><span data-stu-id="2fec7-211">A property metadata object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2fec7-212">Указание типа или ссылки на объект является обязательным, так как метаданные любого заданного свойства зависимости могут отличаться от первоначальной регистрации из-за <xref:System.Windows.DependencyProperty.AddOwner%2A> или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> вызовов, которые могут уточнять метаданные свойств в том виде, в котором они существуют в типе.</span><span class="sxs-lookup"><span data-stu-id="2fec7-212">Specifying either the type or an object reference is necessary because the metadata of any given dependency property can vary from the original registration due either to <xref:System.Windows.DependencyProperty.AddOwner%2A> or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> calls that can refine the property metadata as it exists on a type.</span></span>  
  
 <span data-ttu-id="2fec7-213">При запросе метаданных свойств на основе экземпляра вы действительно передаете экземпляр, чтобы его тип можно было оценивать внутренним образом.</span><span class="sxs-lookup"><span data-stu-id="2fec7-213">When you request property metadata based on an instance, you are really just passing the instance so that its type can be evaluated internally.</span></span> <span data-ttu-id="2fec7-214">Метаданные свойств зависимостей не меняются для каждого экземпляра; оно всегда согласуется с любой заданной комбинацией свойств типа.</span><span class="sxs-lookup"><span data-stu-id="2fec7-214">Dependency property metadata does not vary per instance; it is always consistent for any given type-property combination.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2fec7-215">В следующем примере показано получение метаданных для свойства зависимости на основе определенного экземпляра <xref:System.Windows.DependencyObject>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-215">The following example gets metadata for a dependency property based on a specific <xref:System.Windows.DependencyObject> instance.</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadoinstance)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadoinstance)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObjectType dependencyObjectType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObjectType dependencyObjectType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObjectType ^ dependencyObjectType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObjectType -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObjectType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObjectType" Type="System.Windows.DependencyObjectType" />
      </Parameters>
      <Docs>
        <param name="dependencyObjectType"><span data-ttu-id="2fec7-216">Специальный объект, который записывает тип объекта зависимости, из которого запрашиваются метаданные свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-216">A specific object that records the dependency object type from which the dependency property metadata is desired.</span></span></param>
        <summary><span data-ttu-id="2fec7-217">Возвращает метаданные для этого свойства зависимостей в том виде, в каком они представлены в указанном типе.</span><span class="sxs-lookup"><span data-stu-id="2fec7-217">Returns the metadata for this dependency property as it exists on a specified type.</span></span></summary>
        <returns><span data-ttu-id="2fec7-218">Объект метаданных свойств.</span><span class="sxs-lookup"><span data-stu-id="2fec7-218">A property metadata object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2fec7-219">Указание типа или ссылки на объект является обязательным, так как метаданные любого заданного свойства зависимости могут отличаться от первоначальной регистрации из-за <xref:System.Windows.DependencyProperty.AddOwner%2A> или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> вызовов, которые могут уточнять метаданные свойств в том виде, в котором они существуют в типе.</span><span class="sxs-lookup"><span data-stu-id="2fec7-219">Specifying either the type or an object reference is necessary because the metadata of any given dependency property can vary from the original registration due either to <xref:System.Windows.DependencyProperty.AddOwner%2A> or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> calls that can refine the property metadata as it exists on a type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2fec7-220">В следующем примере показано получение метаданных для свойства зависимости на основе его <xref:System.Windows.DependencyObjectType>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-220">The following example gets metadata for a dependency property based on its <xref:System.Windows.DependencyObjectType>.</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadotype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadotype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GlobalIndex">
      <MemberSignature Language="C#" Value="public int GlobalIndex { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GlobalIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.GlobalIndex" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GlobalIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int GlobalIndex { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalIndex : int" Usage="System.Windows.DependencyProperty.GlobalIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2fec7-221">Возвращает внутреннее сгенерированное значение, уникальным образом идентифицирующее свойство зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-221">Gets an internally generated value that uniquely identifies the dependency property.</span></span></summary>
        <value><span data-ttu-id="2fec7-222">Уникальный числовой идентификатор.</span><span class="sxs-lookup"><span data-stu-id="2fec7-222">A unique numeric identifier.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2fec7-223">Это значение является целым числом, а не глобальным уникальным идентификатором (GUID).</span><span class="sxs-lookup"><span data-stu-id="2fec7-223">This value is an integer, not a globally unique identifier (GUID).</span></span> <span data-ttu-id="2fec7-224">Как правило, использование этого значения индекса не является обязательным и не имеет доступа к таблицам всех свойств зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-224">Generally, using this index value is not required, and there is no index access to tables of all dependency properties.</span></span> <span data-ttu-id="2fec7-225">Вместо этого на свойства зависимостей должны ссылаться их поля идентификаторов.</span><span class="sxs-lookup"><span data-stu-id="2fec7-225">Dependency properties should instead be referenced by their identifier fields.</span></span>  
  
 <span data-ttu-id="2fec7-226"><xref:System.Windows.DependencyProperty.GlobalIndex%2A> используется внутренне для ускорения доступа к структурам данных, которые используют <xref:System.Windows.DependencyProperty.GlobalIndex%2A> как индекс массива, начинающийся с нуля.</span><span class="sxs-lookup"><span data-stu-id="2fec7-226"><xref:System.Windows.DependencyProperty.GlobalIndex%2A> is used internally for faster access to data structures that use the <xref:System.Windows.DependencyProperty.GlobalIndex%2A> as a zero-based array index.</span></span> <span data-ttu-id="2fec7-227">Аналогичное использование может иметь приложения для конструкторов или средств.</span><span class="sxs-lookup"><span data-stu-id="2fec7-227">A similar usage might have applications for designers or tools.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidType">
      <MemberSignature Language="C#" Value="public bool IsValidType (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidType(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidType (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidType(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidType : obj -&gt; bool" Usage="dependencyProperty.IsValidType value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="2fec7-228">Проверяемое значение.</span><span class="sxs-lookup"><span data-stu-id="2fec7-228">The value to check.</span></span></param>
        <summary><span data-ttu-id="2fec7-229">Определяет, приемлемо ли указанное значение для типа данного свойства зависимостей, проверяя его по типу свойства, указанного при исходной регистрации свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-229">Determines whether a specified value is acceptable for this dependency property's type, as checked against the property type provided in the original dependency property registration.</span></span></summary>
        <returns><span data-ttu-id="2fec7-230"><see langword="true" />, если указанное значение принадлежит к зарегистрированному типу свойства или приемлемому производному типу; в противном случае — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="2fec7-230"><see langword="true" /> if the specified value is the registered property type or an acceptable derived type; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2fec7-231">Значение `null` является допустимым типом для свойств зависимости ссылочного типа или для свойства зависимостей <xref:System.Nullable%601>, и будет возвращать `true` в этих случаях.</span><span class="sxs-lookup"><span data-stu-id="2fec7-231">A value of `null` is a valid type for reference type dependency properties, or for a <xref:System.Nullable%601> dependency property, and would return `true` for these cases.</span></span> <span data-ttu-id="2fec7-232">В случаях, когда свойство зависимости не является ни ссылкой, ни типом <xref:System.Nullable%601>, <xref:System.Windows.DependencyProperty.IsValidType%2A> возвратит `false` для значения NULL, а не создает исключение.</span><span class="sxs-lookup"><span data-stu-id="2fec7-232">In cases where the dependency property is neither a reference nor a <xref:System.Nullable%601> type, <xref:System.Windows.DependencyProperty.IsValidType%2A> will return `false` for a null value rather than raise an exception.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2fec7-233">В следующем примере используется <xref:System.Windows.DependencyProperty.IsValidType%2A> в качестве проверки перед вызовом <xref:System.Windows.DependencyObject.SetValue%2A> для свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-233">The following example uses <xref:System.Windows.DependencyProperty.IsValidType%2A> as a check before calling <xref:System.Windows.DependencyObject.SetValue%2A> on the dependency property.</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvalue)]
 [!code-vb[PropertySystemEsoterics#TrySetValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidValue">
      <MemberSignature Language="C#" Value="public bool IsValidValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidValue (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidValue : obj -&gt; bool" Usage="dependencyProperty.IsValidValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="2fec7-234">Проверяемое значение.</span><span class="sxs-lookup"><span data-stu-id="2fec7-234">The value to check.</span></span></param>
        <summary><span data-ttu-id="2fec7-235">Определяет, приемлемо ли указанное значение для типа свойства, путем базовой проверки типа, а также, находится ли оно потенциально в пределах разрешенного диапазона значений для данного типа.</span><span class="sxs-lookup"><span data-stu-id="2fec7-235">Determines whether the provided value is accepted for the type of property through basic type checking, and also potentially if it is within the allowed range of values for that type.</span></span></summary>
        <returns><span data-ttu-id="2fec7-236"><see langword="true" />, если значение приемлемо и принадлежит к надлежащему или производному типу; в противном случае — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="2fec7-236"><see langword="true" /> if the value is acceptable and is of the correct type or a derived type; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2fec7-237">Для свойства зависимостей допустимый диапазон значений для этого типа можно указать с помощью <xref:System.Windows.ValidateValueCallback>, предоставленного в регистрации свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-237">For a dependency property, an allowed range of values for that type can be specified through a <xref:System.Windows.ValidateValueCallback> that is provided in the dependency property registration.</span></span>  
  
 <span data-ttu-id="2fec7-238">Этот метод вызывает <xref:System.Windows.DependencyProperty.IsValidType%2A> внутренним образом.</span><span class="sxs-lookup"><span data-stu-id="2fec7-238">This method calls <xref:System.Windows.DependencyProperty.IsValidType%2A> internally.</span></span> <span data-ttu-id="2fec7-239">Если у рассматриваемого свойства зависимостей нет <xref:System.Windows.ValidateValueCallback>, вызов этого метода фактически эквивалентен вызову <xref:System.Windows.DependencyProperty.IsValidType%2A>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-239">If the dependency property in question has no <xref:System.Windows.ValidateValueCallback>,then calling this method is effectively equivalent to calling <xref:System.Windows.DependencyProperty.IsValidType%2A>.</span></span> <span data-ttu-id="2fec7-240">Если свойство зависимостей имеет <xref:System.Windows.ValidateValueCallback>, и если <xref:System.Windows.DependencyProperty.IsValidType%2A> возвращал `true`, то возвращаемое значение будет реализовано в обратном вызове.</span><span class="sxs-lookup"><span data-stu-id="2fec7-240">If the dependency property does have a <xref:System.Windows.ValidateValueCallback>, and if <xref:System.Windows.DependencyProperty.IsValidType%2A> would have returned `true`, then the value returned will be as implemented in the callback.</span></span>  
  
 <span data-ttu-id="2fec7-241">Значение null является допустимым значением для свойств зависимости ссылочного типа, или для свойства зависимостей <xref:System.Nullable%601>, и будет возвращать `true` в этих случаях.</span><span class="sxs-lookup"><span data-stu-id="2fec7-241">A null value is a valid value for reference type dependency properties, or for a <xref:System.Nullable%601> dependency property, and would return `true` for these cases.</span></span> <span data-ttu-id="2fec7-242">В случаях, когда свойство зависимости не является ни ссылкой, ни типом <xref:System.Nullable%601>, <xref:System.Windows.DependencyProperty.IsValidType%2A> возвратит `false` для значения NULL, а не создает исключение.</span><span class="sxs-lookup"><span data-stu-id="2fec7-242">In cases where the dependency property is neither a reference nor a <xref:System.Nullable%601> type, <xref:System.Windows.DependencyProperty.IsValidType%2A> will return `false` for a null value rather than raise an exception.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2fec7-243">В следующем примере используется <xref:System.Windows.DependencyProperty.IsValidValue%2A> в качестве проверки перед вызовом <xref:System.Windows.DependencyObject.SetValue%2A> для свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-243">The following example uses <xref:System.Windows.DependencyProperty.IsValidValue%2A> as a check before calling <xref:System.Windows.DependencyObject.SetValue%2A> on the dependency property.</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvaluewithvalidate)]
 [!code-vb[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvaluewithvalidate)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Windows.DependencyProperty.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2fec7-244">Возвращает имя свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-244">Gets the name of the dependency property.</span></span></summary>
        <value><span data-ttu-id="2fec7-245">Имя свойства.</span><span class="sxs-lookup"><span data-stu-id="2fec7-245">The name of the property.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2fec7-246">Это свойство получает имя, указанное в качестве параметра `name` во время регистрации свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-246">This property gets the name provided as the `name` parameter during dependency property registration.</span></span> <span data-ttu-id="2fec7-247">Это имя является неизменяемым и не может быть `null` или пустой строкой.</span><span class="sxs-lookup"><span data-stu-id="2fec7-247">This name is immutable, and cannot be `null` or an empty string.</span></span> <span data-ttu-id="2fec7-248">Регистрация повторяющихся имен для одного и того же типа владельца не разрешена, и при попытке зарегистрировать дубликат будет выдаваться исключение.</span><span class="sxs-lookup"><span data-stu-id="2fec7-248">Duplicate name registrations on the same owner type are not permitted, and will throw an exception when you attempt to register the duplicate.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="2fec7-249"><xref:System.Windows.DependencyProperty.Name%2A> свойства зависимостей должно соответствовать соглашению о сопоставлении имени идентификатора свойства зависимости и суффикса "Property".</span><span class="sxs-lookup"><span data-stu-id="2fec7-249">The <xref:System.Windows.DependencyProperty.Name%2A> of a dependency property must follow the convention of matching the name of its dependency property identifier minus the suffix "Property".</span></span> <span data-ttu-id="2fec7-250">Дополнительные сведения см. в разделе [Пользовательские свойства зависимостей](~/docs/framework/wpf/advanced/custom-dependency-properties.md).</span><span class="sxs-lookup"><span data-stu-id="2fec7-250">For details, see [Custom Dependency Properties](~/docs/framework/wpf/advanced/custom-dependency-properties.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2fec7-251">В следующем примере запрашиваются различные характеристики идентификатора свойства зависимости, включая <xref:System.Windows.DependencyProperty.Name%2A>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-251">The following example queries various characteristics of a dependency property identifier, including the <xref:System.Windows.DependencyProperty.Name%2A>.</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OverrideMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="2fec7-252">Предоставляет альтернативные метаданные для этого свойства зависимостей, когда оно присутствует в экземплярах указанного типа по сравнению с метаданными, предоставленными регистрацией первоначального свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-252">Supplies alternate metadata for this dependency property when it is present on instances of a specified type, versus the metadata that was provided in the initial dependency property registration.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="forType"><span data-ttu-id="2fec7-253">Тип, где это свойство зависимостей наследуется и где будут применены указанные альтернативные метаданные.</span><span class="sxs-lookup"><span data-stu-id="2fec7-253">The type where this dependency property is inherited and where the provided alternate metadata will be applied.</span></span></param>
        <param name="typeMetadata"><span data-ttu-id="2fec7-254">Метаданные для применения к свойству зависимостей в переопределяемом типе.</span><span class="sxs-lookup"><span data-stu-id="2fec7-254">The metadata to apply to the dependency property on the overriding type.</span></span></param>
        <summary><span data-ttu-id="2fec7-255">Задает альтернативные метаданные для этого свойства зависимостей, если оно присутствует в экземплярах указанного типа, переопределяя метаданные, которые существовали для данного свойства зависимостей в том виде, в котором оно было унаследовано от базовых типов.</span><span class="sxs-lookup"><span data-stu-id="2fec7-255">Specifies alternate metadata for this dependency property when it is present on instances of a specified type, overriding the metadata that existed for the dependency property as it was inherited from base types.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2fec7-256">Метаданные свойств зависимостей должны быть переопределены до того, как система свойств будет использовать свойство зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-256">Dependency property metadata should be overridden before the property system uses the dependency property.</span></span> <span data-ttu-id="2fec7-257">Это соответствует времени создания конкретных экземпляров с помощью класса, который регистрирует свойство зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-257">This equates to the time that specific instances are created using the class that registers the dependency property.</span></span> <span data-ttu-id="2fec7-258">Вызовы <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> должны выполняться только в статических конструкторах типа, который предоставляет себя как параметр `forType` данного метода или с помощью аналогичного экземпляра.</span><span class="sxs-lookup"><span data-stu-id="2fec7-258">Calls to <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> should only be performed within the static constructors of the type that provides itself as the `forType` parameter of this method, or through similar instantiation.</span></span> <span data-ttu-id="2fec7-259">Попытка изменить метаданные после существования экземпляров типа owner не вызовет исключения, но приведет к несовместимости поведения в системе свойств.</span><span class="sxs-lookup"><span data-stu-id="2fec7-259">Attempting to change metadata after instances of the owner type exist will not raise exceptions, but will result in inconsistent behaviors in the property system.</span></span>  
  
 <span data-ttu-id="2fec7-260">После того как метаданные определенного производного класса устанавливаются с помощью этого метода, последующие попытки переопределения метаданных в этом же производном классе вызовут исключение.</span><span class="sxs-lookup"><span data-stu-id="2fec7-260">After metadata for a particular derived class override is established with this method, subsequent attempts to override metadata on this same derived class will raise an exception.</span></span>  
  
 <span data-ttu-id="2fec7-261">Переданные метаданные объединяются с метаданными свойств для свойства зависимостей в том виде, в котором они существуют в базовом владельце.</span><span class="sxs-lookup"><span data-stu-id="2fec7-261">The supplied metadata is merged with the property metadata for the dependency property as it exists on the base owner.</span></span> <span data-ttu-id="2fec7-262">Все характеристики, заданные в исходных базовых метаданных, сохраняются. только те характеристики, которые были изменены в новых метаданных, будут переопределять характеристики базовых метаданных.</span><span class="sxs-lookup"><span data-stu-id="2fec7-262">Any characteristics that were specified in the original base metadata will persist; only those characteristics that were specifically changed in the new metadata will override the characteristics of the base metadata.</span></span> <span data-ttu-id="2fec7-263">Некоторые характеристики, такие как <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, заменяются, если они указаны в новых метаданных.</span><span class="sxs-lookup"><span data-stu-id="2fec7-263">Some characteristics such as <xref:System.Windows.PropertyMetadata.DefaultValue%2A> are replaced if specified in the new metadata.</span></span> <span data-ttu-id="2fec7-264">Другие, например <xref:System.Windows.PropertyChangedCallback>, объединяются.</span><span class="sxs-lookup"><span data-stu-id="2fec7-264">Others, such as <xref:System.Windows.PropertyChangedCallback>, are combined.</span></span> <span data-ttu-id="2fec7-265">В конечном итоге, поведение слияния зависит от типа метаданных свойства, используемого для переопределения, поэтому описанное здесь поведение предназначено для существующих классов метаданных свойств, используемых [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] свойствами зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-265">Ultimately, the merge behavior depends on the property metadata type being used for the override, so the behavior described here is for the existing property metadata classes used by [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] dependency properties.</span></span> <span data-ttu-id="2fec7-266">Дополнительные сведения см. в разделе [метаданные свойств зависимостей](~/docs/framework/wpf/advanced/dependency-property-metadata.md) и [метаданные свойств платформы](~/docs/framework/wpf/advanced/framework-property-metadata.md).</span><span class="sxs-lookup"><span data-stu-id="2fec7-266">For details, see [Dependency Property Metadata](~/docs/framework/wpf/advanced/dependency-property-metadata.md) and [Framework Property Metadata](~/docs/framework/wpf/advanced/framework-property-metadata.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="2fec7-267">Была предпринята попытка переопределения метаданных в доступном только для чтения свойстве зависимости (операция не может быть выполнена с помощью данной сигнатуры).</span><span class="sxs-lookup"><span data-stu-id="2fec7-267">An attempt was made to override metadata on a read-only dependency property (that operation cannot be done using this signature).</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2fec7-268">Метаданные уже были установлены для данного свойства зависимостей в том виде, в котором оно существует в предоставленном типе.</span><span class="sxs-lookup"><span data-stu-id="2fec7-268">Metadata was already established for the dependency property as it exists on the provided type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata, System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata, key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::DependencyPropertyKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata * System.Windows.DependencyPropertyKey -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="forType"><span data-ttu-id="2fec7-269">Тип, где это свойство зависимостей наследуется и где будут применены указанные альтернативные метаданные.</span><span class="sxs-lookup"><span data-stu-id="2fec7-269">The type where this dependency property is inherited and where the provided alternate metadata will be applied.</span></span></param>
        <param name="typeMetadata"><span data-ttu-id="2fec7-270">Метаданные для применения к свойству зависимостей в переопределяемом типе.</span><span class="sxs-lookup"><span data-stu-id="2fec7-270">The metadata to apply to the dependency property on the overriding type.</span></span></param>
        <param name="key"><span data-ttu-id="2fec7-271">Ключ доступа для свойства зависимостей, доступного только для чтения.</span><span class="sxs-lookup"><span data-stu-id="2fec7-271">The access key for a read-only dependency property.</span></span></param>
        <summary><span data-ttu-id="2fec7-272">Предоставляет альтернативные метаданные для свойства зависимостей, доступного только для чтения, когда оно присутствует в экземплярах указанного типа, переопределяя метаданные, предоставленные при первоначальной регистрации свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-272">Supplies alternate metadata for a read-only dependency property when it is present on instances of a specified type, overriding the metadata that was provided in the initial dependency property registration.</span></span> <span data-ttu-id="2fec7-273">Вы должны передать <see cref="T:System.Windows.DependencyPropertyKey" /> для свойства зависимостей, доступного только для чтения, чтобы избежать возникновения исключения.</span><span class="sxs-lookup"><span data-stu-id="2fec7-273">You must pass the <see cref="T:System.Windows.DependencyPropertyKey" /> for the read-only dependency property to avoid raising an exception.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2fec7-274">Эта сигнатура предоставляет базовую реализацию для метода идентификатора свойства зависимости (<xref:System.Windows.DependencyPropertyKey>), доступного только для чтения.</span><span class="sxs-lookup"><span data-stu-id="2fec7-274">This signature provides underlying implementation for a read-only dependency property identifier (<xref:System.Windows.DependencyPropertyKey>) method.</span></span> <span data-ttu-id="2fec7-275">При переопределении метаданных для свойства зависимости, доступного для чтения и записи, используйте <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-275">If overriding metadata for a read-write dependency property, use <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>.</span></span>  
  
 <span data-ttu-id="2fec7-276">Метаданные свойств зависимостей должны быть переопределены до того, как система свойств будет использовать свойство зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-276">Dependency property metadata should be overridden before the property system uses the dependency property.</span></span> <span data-ttu-id="2fec7-277">Это соответствует времени создания конкретных объектов для класса, который регистрирует свойство зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-277">This equates to the time that specific objects are created for the class that registers the dependency property.</span></span> <span data-ttu-id="2fec7-278">Вызовы <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> должны выполняться только в статических конструкторах типа, который предоставляет себя как параметр `forType` данного метода или с помощью аналогичного экземпляра.</span><span class="sxs-lookup"><span data-stu-id="2fec7-278">Calls to <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> should only be performed within the static constructors of the type that provides itself as the `forType` parameter of this method, or through similar instantiation.</span></span> <span data-ttu-id="2fec7-279">Попытка изменить метаданные после существования экземпляров типа owner не вызовет исключения, но приведет к несовместимости поведения в системе свойств.</span><span class="sxs-lookup"><span data-stu-id="2fec7-279">Attempting to change metadata after instances of the owner type exist will not raise exceptions, but will result in inconsistent behaviors in the property system.</span></span>  
  
 <span data-ttu-id="2fec7-280">После того как метаданные определенного производного класса устанавливаются с помощью этого метода, последующие попытки переопределения метаданных в этом же производном классе вызовут исключение.</span><span class="sxs-lookup"><span data-stu-id="2fec7-280">After metadata for a particular derived class override is established with this method, subsequent attempts to override metadata on this same derived class will raise an exception.</span></span>  
  
 <span data-ttu-id="2fec7-281">Переданные метаданные объединяются с метаданными свойств для свойства зависимостей в том виде, в котором они существуют в базовом владельце.</span><span class="sxs-lookup"><span data-stu-id="2fec7-281">The supplied metadata is merged with the property metadata for the dependency property as it exists on the base owner.</span></span> <span data-ttu-id="2fec7-282">Все характеристики, заданные в исходных базовых метаданных, сохраняются. только те характеристики, которые были изменены в новых метаданных, будут переопределять характеристики базовых метаданных.</span><span class="sxs-lookup"><span data-stu-id="2fec7-282">Any characteristics that were specified in the original base metadata will persist; only those characteristics that were specifically changed in the new metadata will override the characteristics of the base metadata.</span></span> <span data-ttu-id="2fec7-283">Некоторые характеристики, такие как <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, заменяются, если они указаны в новых метаданных.</span><span class="sxs-lookup"><span data-stu-id="2fec7-283">Some characteristics such as <xref:System.Windows.PropertyMetadata.DefaultValue%2A> are replaced if specified in the new metadata.</span></span> <span data-ttu-id="2fec7-284">Другие, например <xref:System.Windows.PropertyChangedCallback>, объединяются.</span><span class="sxs-lookup"><span data-stu-id="2fec7-284">Others, such as <xref:System.Windows.PropertyChangedCallback>, are combined.</span></span> <span data-ttu-id="2fec7-285">Поведение слияния зависит от типа метаданных свойства, используемого для переопределения.</span><span class="sxs-lookup"><span data-stu-id="2fec7-285">The merge behavior depends on the property metadata type being used for the override.</span></span> <span data-ttu-id="2fec7-286">Дополнительные сведения см. в разделе [метаданные свойств зависимостей](~/docs/framework/wpf/advanced/dependency-property-metadata.md) и [метаданные свойств платформы](~/docs/framework/wpf/advanced/framework-property-metadata.md).</span><span class="sxs-lookup"><span data-stu-id="2fec7-286">For details, see [Dependency Property Metadata](~/docs/framework/wpf/advanced/dependency-property-metadata.md) and [Framework Property Metadata](~/docs/framework/wpf/advanced/framework-property-metadata.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnerType">
      <MemberSignature Language="C#" Value="public Type OwnerType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type OwnerType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.OwnerType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnerType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ OwnerType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnerType : Type" Usage="System.Windows.DependencyProperty.OwnerType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2fec7-287">Получает тип объекта, зарегистрировавшего свойство зависимостей в системе свойств или добавившего себя в качестве владельца свойства.</span><span class="sxs-lookup"><span data-stu-id="2fec7-287">Gets the type of the object that registered the dependency property with the property system, or added itself as owner of the property.</span></span></summary>
        <value><span data-ttu-id="2fec7-288">Тип объекта, зарегистрировавшего свойство или добавившего себя в качестве владельца свойства.</span><span class="sxs-lookup"><span data-stu-id="2fec7-288">The type of the object that registered the property or added itself as owner of the property.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2fec7-289">Это значение было указано во время регистрации свойства.</span><span class="sxs-lookup"><span data-stu-id="2fec7-289">This value was provided during property registration.</span></span> <span data-ttu-id="2fec7-290">Владельцем будет либо исходный регистрируемый тип в случае идентификатора <xref:System.Windows.DependencyProperty>, созданного при вызове <xref:System.Windows.DependencyProperty.Register%2A>, либо тип, который добавил себя в качестве владельца в случае идентификатора <xref:System.Windows.DependencyProperty>, созданного из вызова <xref:System.Windows.DependencyProperty.AddOwner%2A>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-290">The owner will be either the original registering type in the case of a <xref:System.Windows.DependencyProperty> identifier generated from a <xref:System.Windows.DependencyProperty.Register%2A> call, or the type that added itself as owner in the case of a <xref:System.Windows.DependencyProperty> identifier generated from an <xref:System.Windows.DependencyProperty.AddOwner%2A> call.</span></span>  
  
 <span data-ttu-id="2fec7-291"><xref:System.Windows.DependencyProperty.OwnerType%2A> на любой заданный <xref:System.Windows.DependencyProperty> является неизменяемым и не может быть `null` в допустимом <xref:System.Windows.DependencyProperty>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-291">The <xref:System.Windows.DependencyProperty.OwnerType%2A> on any given <xref:System.Windows.DependencyProperty> is immutable, and cannot be `null` in a valid <xref:System.Windows.DependencyProperty>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2fec7-292">Следующий пример получает тип владельца на основе идентификатора свойства зависимости `dp`, а затем получает метаданные для типа владельца для этого же идентификатора.</span><span class="sxs-lookup"><span data-stu-id="2fec7-292">The following example gets the owner type based on a dependency property identifier `dp`, and then gets metadata on the owner type for that same identifier.</span></span> <span data-ttu-id="2fec7-293">Эта операция на самом деле эквивалентна получению <xref:System.Windows.DependencyProperty.DefaultMetadata%2A> `dp`.</span><span class="sxs-lookup"><span data-stu-id="2fec7-293">This operation is actually equivalent to getting <xref:System.Windows.DependencyProperty.DefaultMetadata%2A> on `dp`.</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyType">
      <MemberSignature Language="C#" Value="public Type PropertyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type PropertyType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.PropertyType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PropertyType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ PropertyType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PropertyType : Type" Usage="System.Windows.DependencyProperty.PropertyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2fec7-294">Возвращает тип, используемый свойством зависимостей для его значения.</span><span class="sxs-lookup"><span data-stu-id="2fec7-294">Gets the type that the dependency property uses for its value.</span></span></summary>
        <value><span data-ttu-id="2fec7-295"><see cref="T:System.Type" /> значения свойства.</span><span class="sxs-lookup"><span data-stu-id="2fec7-295">The <see cref="T:System.Type" /> of the property value.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2fec7-296">Это свойство сообщает тип значения свойства, объявленный исходной регистрацией свойства, с помощью параметра `propertyType`.</span><span class="sxs-lookup"><span data-stu-id="2fec7-296">This property reports the type of the property's value as declared by the original property registration, through the `propertyType` parameter.</span></span> <span data-ttu-id="2fec7-297">Как и <xref:System.Windows.DependencyProperty.Name%2A>, тип свойства свойства зависимостей неизменяем после регистрации.</span><span class="sxs-lookup"><span data-stu-id="2fec7-297">Similar to the <xref:System.Windows.DependencyProperty.Name%2A>, the property type of a dependency property is immutable after registration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2fec7-298">В следующем примере запрашиваются различные характеристики идентификатора свойства зависимости, включая <xref:System.Windows.DependencyProperty.PropertyType%2A>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-298">The following example queries various characteristics of a dependency property identifier, including the <xref:System.Windows.DependencyProperty.PropertyType%2A>.</span></span> <span data-ttu-id="2fec7-299">Строка имени типа <xref:System.Windows.DependencyProperty.PropertyType%2A> получается из возвращаемого <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-299">The type name string of the <xref:System.Windows.DependencyProperty.PropertyType%2A> is obtained from the returned <xref:System.Type>.</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public bool ReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadOnly : bool" Usage="System.Windows.DependencyProperty.ReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2fec7-300">Возвращает значение, указывающее, является ли свойство зависимостей, идентифицируемое данным экземпляром <see cref="T:System.Windows.DependencyProperty" />, доступным только для чтения.</span><span class="sxs-lookup"><span data-stu-id="2fec7-300">Gets a value that indicates whether the dependency property identified by this <see cref="T:System.Windows.DependencyProperty" /> instance is a read-only dependency property.</span></span></summary>
        <value><span data-ttu-id="2fec7-301"><see langword="true" />, если свойство зависимостей доступно только для чтения; в противном случае — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="2fec7-301"><see langword="true" /> if the dependency property is read-only; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2fec7-302">Свойства зависимостей только для чтения регистрируются в системе свойств путем вызова метода <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A>, а не метода <xref:System.Windows.DependencyProperty.Register%2A>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-302">Read-only dependency properties are registered within the property system by calling the <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> method as opposed to the <xref:System.Windows.DependencyProperty.Register%2A> method.</span></span> <span data-ttu-id="2fec7-303">Вложенные свойства также могут быть зарегистрированы как доступные только для чтения. см. <xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-303">Attached properties can also be registered as read-only; see <xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>.</span></span>  
  
 <span data-ttu-id="2fec7-304">Для свойств зависимостей только для чтения требуется идентификатор <xref:System.Windows.DependencyPropertyKey>, а не <xref:System.Windows.DependencyProperty> идентификатор для выполнения операций с метаданными, таких как переопределение метаданных или установка значения.</span><span class="sxs-lookup"><span data-stu-id="2fec7-304">Read-only dependency properties require a <xref:System.Windows.DependencyPropertyKey> identifier rather than a <xref:System.Windows.DependencyProperty> identifier to perform metadata operations such as overriding the metadata or setting the value.</span></span> <span data-ttu-id="2fec7-305">Если вы получили коллекцию идентификаторов <xref:System.Windows.DependencyProperty> с помощью вызова <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> или другого API, предоставляющего идентификаторы, проверьте значение <xref:System.Windows.DependencyProperty.ReadOnly%2A>, прежде чем пытаться вызвать <xref:System.Windows.DependencyObject.SetValue%2A> или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, используя этот идентификатор свойства зависимостей в качестве входного параметра. , чтобы убедиться, что свойство зависимостей, представляемое идентификатором, не доступно только для чтения.</span><span class="sxs-lookup"><span data-stu-id="2fec7-305">If you obtained a collection of <xref:System.Windows.DependencyProperty> identifiers through a call to <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> or another API that exposes identifiers, check the <xref:System.Windows.DependencyProperty.ReadOnly%2A> value before attempting to call <xref:System.Windows.DependencyObject.SetValue%2A> or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> using that dependency property identifier as an input parameter, to verify that the dependency property that the identifier represents is not read-only.</span></span> <span data-ttu-id="2fec7-306">Если значение <xref:System.Windows.DependencyProperty.ReadOnly%2A> `true` в свойстве зависимости, нет программного способа получить ссылку на <xref:System.Windows.DependencyPropertyKey> идентификатор этого свойства зависимостей из метаданных или идентификатора <xref:System.Windows.DependencyProperty>. Идентификатор должен быть доступен в виде статического поля для вызова <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> для свойства зависимостей, доступного только для чтения.</span><span class="sxs-lookup"><span data-stu-id="2fec7-306">If the value of <xref:System.Windows.DependencyProperty.ReadOnly%2A> is `true` on a dependency property, there is no programmatic way to obtain a reference to the <xref:System.Windows.DependencyPropertyKey> identifier of that dependency property, from the metadata or from the <xref:System.Windows.DependencyProperty> identifier; the identifier must be available as a static field in order to call <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> against a read-only dependency property.</span></span>  
  
 <span data-ttu-id="2fec7-307">При создании настраиваемого свойства зависимости и его регистрации в качестве только для чтения необходимо определить только метод доступа get для свойства оболочки [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)].</span><span class="sxs-lookup"><span data-stu-id="2fec7-307">When you create a custom dependency property, and register it as read-only, you should define only a get accessor for the [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] wrapper property.</span></span> <span data-ttu-id="2fec7-308">В противном случае класс будет иметь непонятную объектную модель для оболочки свойств по сравнению с доступом к свойству обратной зависимости.</span><span class="sxs-lookup"><span data-stu-id="2fec7-308">Otherwise, your class will have a confusing object model for the property wrapper as compared to the access to the backing dependency property.</span></span> <span data-ttu-id="2fec7-309">Дополнительные сведения см. в разделе [пользовательские свойства зависимости](~/docs/framework/wpf/advanced/custom-dependency-properties.md) или [свойства зависимостей только для чтения](~/docs/framework/wpf/advanced/read-only-dependency-properties.md).</span><span class="sxs-lookup"><span data-stu-id="2fec7-309">For details, see [Custom Dependency Properties](~/docs/framework/wpf/advanced/custom-dependency-properties.md) or [Read-Only Dependency Properties](~/docs/framework/wpf/advanced/read-only-dependency-properties.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2fec7-310">Следующий пример получает метаданные по умолчанию и свойства идентификатора свойства зависимости из различных полей свойств зависимости и использует эти сведения для заполнения таблицы для реализации "браузера метаданных".</span><span class="sxs-lookup"><span data-stu-id="2fec7-310">The following example obtains the default metadata and the dependency property identifier properties from various dependency property fields, and uses the information to populate a table to implement a "metadata browser".</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Register">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="2fec7-311">Регистрирует свойство зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-311">Registers a dependency property.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="2fec7-312">Имя регистрируемого свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-312">The name of the dependency property to register.</span></span> <span data-ttu-id="2fec7-313">Имя должно быть уникальным в пределах пространства имен регистрации для типа владельца.</span><span class="sxs-lookup"><span data-stu-id="2fec7-313">The name must be unique within the registration namespace of the owner type.</span></span></param>
        <param name="propertyType"><span data-ttu-id="2fec7-314">Тип свойства.</span><span class="sxs-lookup"><span data-stu-id="2fec7-314">The type of the property.</span></span></param>
        <param name="ownerType"><span data-ttu-id="2fec7-315">Тип владельца, регистрирующий свойство зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-315">The owner type that is registering the dependency property.</span></span></param>
        <summary><span data-ttu-id="2fec7-316">Регистрирует свойство зависимостей с указанием имени свойства, типа свойства и типа владельца.</span><span class="sxs-lookup"><span data-stu-id="2fec7-316">Registers a dependency property with the specified property name, property type, and owner type.</span></span></summary>
        <returns><span data-ttu-id="2fec7-317">Идентификатор свойства зависимостей, который должен использоваться для задания значения поля <see langword="public static readonly" /> в классе.</span><span class="sxs-lookup"><span data-stu-id="2fec7-317">A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class.</span></span> <span data-ttu-id="2fec7-318">Затем этот идентификатор используется для ссылки на свойство зависимостей для операций, например задания значения программным образом или получение метаданных.</span><span class="sxs-lookup"><span data-stu-id="2fec7-318">That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2fec7-319">Дополнительные сведения о регистрации свойств зависимостей см. в разделе <xref:System.Windows.DependencyProperty>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-319">For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.</span></span>  
  
   
  
## Examples  
 [!code-csharp[WPFAquariumSln#Register3Param](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#register3param)]
 [!code-vb[WPFAquariumSln#Register3Param](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#register3param)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="2fec7-320">Имя регистрируемого свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-320">The name of the dependency property to register.</span></span></param>
        <param name="propertyType"><span data-ttu-id="2fec7-321">Тип свойства.</span><span class="sxs-lookup"><span data-stu-id="2fec7-321">The type of the property.</span></span></param>
        <param name="ownerType"><span data-ttu-id="2fec7-322">Тип владельца, регистрирующего свойство зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-322">The owner type that is registering the dependency property.</span></span></param>
        <param name="typeMetadata"><span data-ttu-id="2fec7-323">Метаданные свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-323">Property metadata for the dependency property.</span></span></param>
        <summary><span data-ttu-id="2fec7-324">Регистрирует свойство зависимостей с указанным именем свойства, типом свойства, типом владельца и метаданными свойства.</span><span class="sxs-lookup"><span data-stu-id="2fec7-324">Registers a dependency property with the specified property name, property type, owner type, and property metadata.</span></span></summary>
        <returns><span data-ttu-id="2fec7-325">Идентификатор свойства зависимостей, который должен использоваться для задания значения поля <see langword="public static readonly" /> в классе.</span><span class="sxs-lookup"><span data-stu-id="2fec7-325">A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class.</span></span> <span data-ttu-id="2fec7-326">Затем этот идентификатор используется для ссылки на свойство зависимостей для операций, например задания значения программным образом или получение метаданных.</span><span class="sxs-lookup"><span data-stu-id="2fec7-326">That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2fec7-327">Дополнительные сведения о регистрации свойств зависимостей см. в разделе <xref:System.Windows.DependencyProperty>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-327">For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="2fec7-328">Имя регистрируемого свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-328">The name of the dependency property to register.</span></span></param>
        <param name="propertyType"><span data-ttu-id="2fec7-329">Тип свойства.</span><span class="sxs-lookup"><span data-stu-id="2fec7-329">The type of the property.</span></span></param>
        <param name="ownerType"><span data-ttu-id="2fec7-330">Тип владельца, регистрирующего свойство зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-330">The owner type that is registering the dependency property.</span></span></param>
        <param name="typeMetadata"><span data-ttu-id="2fec7-331">Метаданные свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-331">Property metadata for the dependency property.</span></span></param>
        <param name="validateValueCallback"><span data-ttu-id="2fec7-332">Ссылка на обратный вызов, который должен выполнить пользовательскую проверку значения свойства зависимостей после обычной проверки типа.</span><span class="sxs-lookup"><span data-stu-id="2fec7-332">A reference to a callback that should perform any custom validation of the dependency property value beyond typical type validation.</span></span></param>
        <summary><span data-ttu-id="2fec7-333">Регистрирует свойство зависимостей с указанным именем свойства, типом свойства, типом владельца, метаданными свойства и обратным вызовом проверки значения для свойства.</span><span class="sxs-lookup"><span data-stu-id="2fec7-333">Registers a dependency property with the specified property name, property type, owner type, property metadata, and a value validation callback for the property.</span></span></summary>
        <returns><span data-ttu-id="2fec7-334">Идентификатор свойства зависимостей, который должен использоваться для задания значения поля <see langword="public static readonly" /> в классе.</span><span class="sxs-lookup"><span data-stu-id="2fec7-334">A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class.</span></span> <span data-ttu-id="2fec7-335">Затем этот идентификатор используется для ссылки на свойство зависимостей для операций, например задания значения программным образом или получение метаданных.</span><span class="sxs-lookup"><span data-stu-id="2fec7-335">That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2fec7-336">Дополнительные сведения о регистрации свойств зависимостей см. в разделе <xref:System.Windows.DependencyProperty>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-336">For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2fec7-337">В следующем примере регистрируется свойство зависимости, включая обратный вызов проверки (определение обратного вызова не отображается; дополнительные сведения об определении обратного вызова см. в разделе <xref:System.Windows.ValidateValueCallback>).</span><span class="sxs-lookup"><span data-stu-id="2fec7-337">The following example registers a dependency property, including a validation callback (the callback definition is not shown; for details on the callback definition, see <xref:System.Windows.ValidateValueCallback>).</span></span>  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttached">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="2fec7-338">Регистрирует присоединенное свойство в системе свойств.</span><span class="sxs-lookup"><span data-stu-id="2fec7-338">Registers an attached property with the property system.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="2fec7-339">Имя регистрируемого свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-339">The name of the dependency property to register.</span></span></param>
        <param name="propertyType"><span data-ttu-id="2fec7-340">Тип свойства.</span><span class="sxs-lookup"><span data-stu-id="2fec7-340">The type of the property.</span></span></param>
        <param name="ownerType"><span data-ttu-id="2fec7-341">Тип владельца, регистрирующего свойство зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-341">The owner type that is registering the dependency property.</span></span></param>
        <summary><span data-ttu-id="2fec7-342">Регистрирует присоединенное свойство с указанием имени свойства, типа свойства и типа владельца.</span><span class="sxs-lookup"><span data-stu-id="2fec7-342">Registers an attached property with the specified property name, property type, and owner type.</span></span></summary>
        <returns><span data-ttu-id="2fec7-343">Идентификатор свойства зависимостей, который должен использоваться для задания значения поля <see langword="public static readonly" /> в классе.</span><span class="sxs-lookup"><span data-stu-id="2fec7-343">A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class.</span></span> <span data-ttu-id="2fec7-344">Затем этот идентификатор используется для ссылки на свойство зависимостей для операций, например задания значения программным образом или получение метаданных.</span><span class="sxs-lookup"><span data-stu-id="2fec7-344">That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2fec7-345">Присоединенное свойство — это понятие свойства, определяемое [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="2fec7-345">An attached property is a property concept defined by [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)].</span></span> [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="2fec7-346">реализует присоединенные свойства в качестве свойств зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-346">implements attached properties as dependency properties.</span></span> <span data-ttu-id="2fec7-347">Поскольку вложенные свойства [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] являются свойствами зависимостей, к ним могут применяться метаданные, которые могут использоваться общей системой свойств для таких операций, как отчеты о характеристиках макета.</span><span class="sxs-lookup"><span data-stu-id="2fec7-347">Because the [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] attached properties are dependency properties, they can have metadata applied that can be used by the general property system for operations such as reporting layout characteristics.</span></span> <span data-ttu-id="2fec7-348">Дополнительные сведения см. в разделе [Общие сведения о вложенных свойствах](~/docs/framework/wpf/advanced/attached-properties-overview.md).</span><span class="sxs-lookup"><span data-stu-id="2fec7-348">For more information, see [Attached Properties Overview](~/docs/framework/wpf/advanced/attached-properties-overview.md).</span></span>  
  
 <span data-ttu-id="2fec7-349">Дополнительные сведения о регистрации свойств зависимостей см. в разделе <xref:System.Windows.DependencyProperty>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-349">For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2fec7-350">В следующем примере вложенное свойство регистрируется для абстрактного класса с помощью подписи <xref:System.Windows.DependencyProperty.RegisterAttached%2A>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-350">The following example registers an attached property on an abstract class using this <xref:System.Windows.DependencyProperty.RegisterAttached%2A> signature.</span></span>  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="2fec7-351">Имя регистрируемого свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-351">The name of the dependency property to register.</span></span></param>
        <param name="propertyType"><span data-ttu-id="2fec7-352">Тип свойства.</span><span class="sxs-lookup"><span data-stu-id="2fec7-352">The type of the property.</span></span></param>
        <param name="ownerType"><span data-ttu-id="2fec7-353">Тип владельца, регистрирующего свойство зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-353">The owner type that is registering the dependency property.</span></span></param>
        <param name="defaultMetadata"><span data-ttu-id="2fec7-354">Метаданные свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-354">Property metadata for the dependency property.</span></span> <span data-ttu-id="2fec7-355">Могут включать значение по умолчанию и другие характеристики.</span><span class="sxs-lookup"><span data-stu-id="2fec7-355">This can include the default value as well as other characteristics.</span></span></param>
        <summary><span data-ttu-id="2fec7-356">Регистрирует присоединенное свойство с указанным именем и типом свойства, типом владельца и метаданными свойства.</span><span class="sxs-lookup"><span data-stu-id="2fec7-356">Registers an attached property with the specified property name, property type, owner type, and property metadata.</span></span></summary>
        <returns><span data-ttu-id="2fec7-357">Идентификатор свойства зависимостей, который должен использоваться для задания значения поля <see langword="public static readonly" /> в классе.</span><span class="sxs-lookup"><span data-stu-id="2fec7-357">A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class.</span></span> <span data-ttu-id="2fec7-358">Затем этот идентификатор используется для ссылки на свойство зависимостей для операций, например задания значения программным образом или получение метаданных.</span><span class="sxs-lookup"><span data-stu-id="2fec7-358">That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2fec7-359">Присоединенное свойство — это понятие свойства, определяемое [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="2fec7-359">An attached property is a property concept defined by [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)].</span></span> [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="2fec7-360">реализует присоединенные свойства в качестве свойств зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-360">implements attached properties as dependency properties.</span></span> <span data-ttu-id="2fec7-361">Поскольку вложенные свойства [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] являются свойствами зависимостей, к ним могут применяться метаданные, которые могут использоваться общей системой свойств для таких операций, как отчеты о характеристиках макета.</span><span class="sxs-lookup"><span data-stu-id="2fec7-361">Because the [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] attached properties are dependency properties, they can have metadata applied that can be used by the general property system for operations such as reporting layout characteristics.</span></span> <span data-ttu-id="2fec7-362">Дополнительные сведения см. в разделе [Общие сведения о вложенных свойствах](~/docs/framework/wpf/advanced/attached-properties-overview.md).</span><span class="sxs-lookup"><span data-stu-id="2fec7-362">For more information, see [Attached Properties Overview](~/docs/framework/wpf/advanced/attached-properties-overview.md).</span></span>  
  
 <span data-ttu-id="2fec7-363">Дополнительные сведения о регистрации свойств зависимостей см. в разделе <xref:System.Windows.DependencyProperty>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-363">For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.</span></span>  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a><span data-ttu-id="2fec7-364">Использование RegisterAttached для наследования значений свойств зависимостей</span><span class="sxs-lookup"><span data-stu-id="2fec7-364">Use RegisterAttached for Value-inheriting Dependency Properties</span></span>  
 <span data-ttu-id="2fec7-365">Одним из сценариев регистрации свойства зависимостей с <xref:System.Windows.DependencyProperty.RegisterAttached%2A> вместо <xref:System.Windows.DependencyProperty.Register%2A> является поддержка наследования значения свойства.</span><span class="sxs-lookup"><span data-stu-id="2fec7-365">One particular scenario for registering a dependency property with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> instead of <xref:System.Windows.DependencyProperty.Register%2A> is to support property value inheritance.</span></span> <span data-ttu-id="2fec7-366">Следует регистрировать свойства зависимостей, наследуемые значениями, с <xref:System.Windows.DependencyProperty.RegisterAttached%2A> даже если класс определяет методы доступа к оболочке свойств, которые предоставляют свойство зависимостей, и даже если вы не собираетесь предоставлять статические методы get \* и Set \* для предоставления истинных вложений методы доступа для поддержки свойств.</span><span class="sxs-lookup"><span data-stu-id="2fec7-366">You should register value-inheriting dependency properties with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get\* and Set\* static methods to provide true attached property support accessors.</span></span>   <span data-ttu-id="2fec7-367">Несмотря на то, что наследование значений свойств может работать для неприсоединенных свойств зависимостей, поведение наследования для неприсоединенного свойства через определенные границы элементов в дереве среды выполнения не определено.</span><span class="sxs-lookup"><span data-stu-id="2fec7-367">Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined.</span></span> <span data-ttu-id="2fec7-368">Регистрация свойства как присоединенного фактически делает присоединенное свойство глобальным свойством системы свойств и гарантирует, что наследование значения свойства работает во всех границах дерева элементов.</span><span class="sxs-lookup"><span data-stu-id="2fec7-368">Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree.</span></span> <span data-ttu-id="2fec7-369">Всегда используйте <xref:System.Windows.DependencyProperty.RegisterAttached%2A> для регистрации свойств, в которых указываются <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> в метаданных.</span><span class="sxs-lookup"><span data-stu-id="2fec7-369">Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata.</span></span> <span data-ttu-id="2fec7-370">Дополнительные сведения см. в разделе [Наследование значения свойства](~/docs/framework/wpf/advanced/property-value-inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="2fec7-370">For more information, see [Property Value Inheritance](~/docs/framework/wpf/advanced/property-value-inheritance.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="2fec7-371">Имя регистрируемого свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-371">The name of the dependency property to register.</span></span></param>
        <param name="propertyType"><span data-ttu-id="2fec7-372">Тип свойства.</span><span class="sxs-lookup"><span data-stu-id="2fec7-372">The type of the property.</span></span></param>
        <param name="ownerType"><span data-ttu-id="2fec7-373">Тип владельца, регистрирующего свойство зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-373">The owner type that is registering the dependency property.</span></span></param>
        <param name="defaultMetadata"><span data-ttu-id="2fec7-374">Метаданные свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-374">Property metadata for the dependency property.</span></span> <span data-ttu-id="2fec7-375">Могут включать значение по умолчанию и другие характеристики.</span><span class="sxs-lookup"><span data-stu-id="2fec7-375">This can include the default value as well as other characteristics.</span></span></param>
        <param name="validateValueCallback"><span data-ttu-id="2fec7-376">Ссылка на обратный вызов, который должен выполнить пользовательскую проверку значения свойства зависимостей после обычной проверки типа.</span><span class="sxs-lookup"><span data-stu-id="2fec7-376">A reference to a callback that should perform any custom validation of the dependency property value beyond typical type validation.</span></span></param>
        <summary><span data-ttu-id="2fec7-377">Регистрирует присоединенное свойство с указанным типом свойства, типом владельца, метаданными свойства и обратным вызовом для проверки значения свойства.</span><span class="sxs-lookup"><span data-stu-id="2fec7-377">Registers an attached property with the specified property type, owner type, property metadata, and value validation callback for the property.</span></span></summary>
        <returns><span data-ttu-id="2fec7-378">Идентификатор свойства зависимостей, который должен использоваться для задания значения поля <see langword="public static readonly" /> в классе.</span><span class="sxs-lookup"><span data-stu-id="2fec7-378">A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class.</span></span> <span data-ttu-id="2fec7-379">Затем этот идентификатор используется для ссылки на свойство зависимостей для операций, например задания значения программным образом или получение метаданных.</span><span class="sxs-lookup"><span data-stu-id="2fec7-379">That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2fec7-380">Присоединенное свойство — это понятие свойства, определяемое [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="2fec7-380">An attached property is a property concept defined by [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)].</span></span> [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="2fec7-381">реализует присоединенные свойства в качестве свойств зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-381">implements attached properties as dependency properties.</span></span> <span data-ttu-id="2fec7-382">Поскольку вложенные свойства [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] являются свойствами зависимостей, к ним могут применяться метаданные, которые могут использоваться общей системой свойств для таких операций, как отчеты о характеристиках макета.</span><span class="sxs-lookup"><span data-stu-id="2fec7-382">Because the [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] attached properties are dependency properties, they can have metadata applied that can be used by the general property system for operations such as reporting layout characteristics.</span></span> <span data-ttu-id="2fec7-383">Дополнительные сведения см. в разделе [Общие сведения о вложенных свойствах](~/docs/framework/wpf/advanced/attached-properties-overview.md).</span><span class="sxs-lookup"><span data-stu-id="2fec7-383">For more information, see [Attached Properties Overview](~/docs/framework/wpf/advanced/attached-properties-overview.md).</span></span>  
  
 <span data-ttu-id="2fec7-384">Дополнительные сведения о регистрации свойств зависимостей см. в разделе <xref:System.Windows.DependencyProperty>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-384">For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.</span></span>  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a><span data-ttu-id="2fec7-385">Использование RegisterAttached для наследования значений свойств зависимостей</span><span class="sxs-lookup"><span data-stu-id="2fec7-385">Use RegisterAttached for Value-inheriting Dependency Properties</span></span>  
 <span data-ttu-id="2fec7-386">Одним из сценариев регистрации свойства зависимостей с <xref:System.Windows.DependencyProperty.RegisterAttached%2A> вместо <xref:System.Windows.DependencyProperty.Register%2A> является поддержка наследования значения свойства.</span><span class="sxs-lookup"><span data-stu-id="2fec7-386">One particular scenario for registering a dependency property with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> instead of <xref:System.Windows.DependencyProperty.Register%2A> is to support property value inheritance.</span></span> <span data-ttu-id="2fec7-387">Следует регистрировать свойства зависимостей, наследуемые значениями, с <xref:System.Windows.DependencyProperty.RegisterAttached%2A> даже если класс определяет методы доступа к оболочке свойств, которые предоставляют свойство зависимостей, и даже если вы не собираетесь предоставлять статические методы get \* и Set \* для предоставления истинных вложений методы доступа для поддержки свойств.</span><span class="sxs-lookup"><span data-stu-id="2fec7-387">You should register value-inheriting dependency properties with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get\* and Set\* static methods to provide true attached property support accessors.</span></span>   <span data-ttu-id="2fec7-388">Несмотря на то, что наследование значений свойств может работать для неприсоединенных свойств зависимостей, поведение наследования для неприсоединенного свойства через определенные границы элементов в дереве среды выполнения не определено.</span><span class="sxs-lookup"><span data-stu-id="2fec7-388">Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined.</span></span> <span data-ttu-id="2fec7-389">Регистрация свойства как присоединенного фактически делает присоединенное свойство глобальным свойством системы свойств и гарантирует, что наследование значения свойства работает во всех границах дерева элементов.</span><span class="sxs-lookup"><span data-stu-id="2fec7-389">Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree.</span></span> <span data-ttu-id="2fec7-390">Всегда используйте <xref:System.Windows.DependencyProperty.RegisterAttached%2A> для регистрации свойств, в которых указываются <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> в метаданных.</span><span class="sxs-lookup"><span data-stu-id="2fec7-390">Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata.</span></span> <span data-ttu-id="2fec7-391">Дополнительные сведения см. в разделе [Наследование значения свойства](~/docs/framework/wpf/advanced/property-value-inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="2fec7-391">For more information, see [Property Value Inheritance](~/docs/framework/wpf/advanced/property-value-inheritance.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2fec7-392">В следующем примере вложенное свойство регистрируется для абстрактного класса с помощью подписи <xref:System.Windows.DependencyProperty.RegisterAttached%2A>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-392">The following example registers an attached property on an abstract class using this <xref:System.Windows.DependencyProperty.RegisterAttached%2A> signature.</span></span> <span data-ttu-id="2fec7-393">Это присоединенное свойство является свойством типа перечисления, и регистрация добавляет обратный вызов проверки, чтобы убедиться, что предоставленное значение является значением перечисления.</span><span class="sxs-lookup"><span data-stu-id="2fec7-393">This attached property is an enumeration type property, and the registration adds a validation callback to verify that the provided value is a value of the enumeration.</span></span>  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttachedReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="2fec7-394">Регистрирует присоединенное свойство зависимостей, предназначенное только для чтения.</span><span class="sxs-lookup"><span data-stu-id="2fec7-394">Registers a read-only attached property.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttachedReadOnly (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="2fec7-395">Имя регистрируемого свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-395">The name of the dependency property to register.</span></span></param>
        <param name="propertyType"><span data-ttu-id="2fec7-396">Тип свойства.</span><span class="sxs-lookup"><span data-stu-id="2fec7-396">The type of the property.</span></span></param>
        <param name="ownerType"><span data-ttu-id="2fec7-397">Тип владельца, регистрирующего свойство зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-397">The owner type that is registering the dependency property.</span></span></param>
        <param name="defaultMetadata"><span data-ttu-id="2fec7-398">Метаданные свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-398">Property metadata for the dependency property.</span></span></param>
        <summary><span data-ttu-id="2fec7-399">Регистрирует доступное только для чтения присоединенное свойство с указанным типом свойства, типом владельца и метаданными свойства.</span><span class="sxs-lookup"><span data-stu-id="2fec7-399">Registers a read-only attached property, with the specified property type, owner type, and property metadata.</span></span></summary>
        <returns><span data-ttu-id="2fec7-400">Ключ свойства зависимостей, который следует использовать для задания значения статического доступного только для чтения поля в вашем классе, которое затем используется для ссылки на свойство зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-400">A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property later.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2fec7-401">Этот метод возвращает тип <xref:System.Windows.DependencyPropertyKey>, тогда как <xref:System.Windows.DependencyProperty.RegisterAttached%2A> возвращает <xref:System.Windows.DependencyProperty>типа.</span><span class="sxs-lookup"><span data-stu-id="2fec7-401">This method returns the type <xref:System.Windows.DependencyPropertyKey>, whereas <xref:System.Windows.DependencyProperty.RegisterAttached%2A> returns the type <xref:System.Windows.DependencyProperty>.</span></span> <span data-ttu-id="2fec7-402">Как правило, ключи, представляющие свойства только для чтения, не являются общедоступными, поскольку ключи можно использовать для установки значения свойства зависимостей путем вызова <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-402">Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>.</span></span> <span data-ttu-id="2fec7-403">Разработка класса повлияет на ваши требования, но обычно рекомендуется ограничить доступ и видимость любых <xref:System.Windows.DependencyPropertyKey> только теми частями кода, которые необходимы для установки этого свойства зависимостей как части логики класса или приложения.</span><span class="sxs-lookup"><span data-stu-id="2fec7-403">Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <xref:System.Windows.DependencyPropertyKey> to only those parts of your code that are necessary to set that dependency property as part of class or application logic.</span></span> <span data-ttu-id="2fec7-404">Также рекомендуется предоставить идентификатор свойства зависимостей для свойства зависимостей "только для чтения", предоставив значение <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> в качестве поля `public static readonly` в классе.</span><span class="sxs-lookup"><span data-stu-id="2fec7-404">It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> as a `public static readonly` field on your class.</span></span>  
  
 <span data-ttu-id="2fec7-405">Присоединенные свойства только для чтения являются редким сценарием, поскольку основной сценарий для присоединенного свойства используется в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="2fec7-405">Read-only attached properties are a rare scenario, because the primary scenario for an attached property is its use in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span> <span data-ttu-id="2fec7-406">Без открытого метода задания вложенное свойство не может быть задано в синтаксисе [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="2fec7-406">Without a public setter, an attached property cannot be set in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] syntax.</span></span>  
  
 <span data-ttu-id="2fec7-407">Дополнительные сведения о регистрации свойств зависимостей см. в разделе <xref:System.Windows.DependencyProperty>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-407">For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.</span></span>  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a><span data-ttu-id="2fec7-408">Использование RegisterAttached для наследования значений свойств зависимостей</span><span class="sxs-lookup"><span data-stu-id="2fec7-408">Use RegisterAttached for Value-inheriting Dependency Properties</span></span>  
 <span data-ttu-id="2fec7-409">Одним из сценариев регистрации свойства зависимостей в качестве присоединенных является поддержка наследования значения свойства.</span><span class="sxs-lookup"><span data-stu-id="2fec7-409">One particular scenario for registering a dependency property as attached is to support property value inheritance.</span></span> <span data-ttu-id="2fec7-410">Следует регистрировать свойства зависимостей, наследуемые значениями, с <xref:System.Windows.DependencyProperty.RegisterAttached%2A> даже если класс определяет методы доступа к оболочке свойств, которые предоставляют свойство зависимостей, и даже если вы не собираетесь предоставлять статические методы get \* и Set \* для предоставления истинных вложений методы доступа для поддержки свойств.</span><span class="sxs-lookup"><span data-stu-id="2fec7-410">You should register value-inheriting dependency properties with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get\* and Set\* static methods to provide true attached property support accessors.</span></span>   <span data-ttu-id="2fec7-411">Несмотря на то, что наследование значений свойств может работать для неприсоединенных свойств зависимостей, поведение наследования для неприсоединенного свойства через определенные границы элементов в дереве среды выполнения не определено.</span><span class="sxs-lookup"><span data-stu-id="2fec7-411">Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined.</span></span> <span data-ttu-id="2fec7-412">Регистрация свойства как присоединенного фактически делает присоединенное свойство глобальным свойством системы свойств и гарантирует, что наследование значения свойства работает во всех границах дерева элементов.</span><span class="sxs-lookup"><span data-stu-id="2fec7-412">Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree.</span></span> <span data-ttu-id="2fec7-413">Всегда используйте <xref:System.Windows.DependencyProperty.RegisterAttached%2A> для регистрации свойств, в которых указываются <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> в метаданных.</span><span class="sxs-lookup"><span data-stu-id="2fec7-413">Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata.</span></span> <span data-ttu-id="2fec7-414">Дополнительные сведения см. в разделе [Наследование значения свойства](~/docs/framework/wpf/advanced/property-value-inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="2fec7-414">For more information, see [Property Value Inheritance](~/docs/framework/wpf/advanced/property-value-inheritance.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="2fec7-415">Имя регистрируемого свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-415">The name of the dependency property to register.</span></span></param>
        <param name="propertyType"><span data-ttu-id="2fec7-416">Тип свойства.</span><span class="sxs-lookup"><span data-stu-id="2fec7-416">The type of the property.</span></span></param>
        <param name="ownerType"><span data-ttu-id="2fec7-417">Тип владельца, регистрирующего свойство зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-417">The owner type that is registering the dependency property.</span></span></param>
        <param name="defaultMetadata"><span data-ttu-id="2fec7-418">Метаданные свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-418">Property metadata for the dependency property.</span></span></param>
        <param name="validateValueCallback"><span data-ttu-id="2fec7-419">Ссылка на созданный пользователем обратный вызов, который должен выполнить пользовательскую проверку значения свойства зависимостей после обычной проверки типа.</span><span class="sxs-lookup"><span data-stu-id="2fec7-419">A reference to a user-created callback that should perform any custom validation of the dependency property value beyond typical type validation.</span></span></param>
        <summary><span data-ttu-id="2fec7-420">Регистрирует доступное только для чтения присоединенное свойство с указанным типом свойства, типом владельца, метаданными свойства и обратным вызовом для проверки.</span><span class="sxs-lookup"><span data-stu-id="2fec7-420">Registers a read-only attached property, with the specified property type, owner type, property metadata, and a validation callback.</span></span></summary>
        <returns><span data-ttu-id="2fec7-421">Ключ свойства зависимостей, который следует использовать для задания значения статического доступного только для чтения поля в вашем классе, которое затем используется для ссылки на свойство зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-421">A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2fec7-422">Этот метод возвращает тип <xref:System.Windows.DependencyPropertyKey>, тогда как <xref:System.Windows.DependencyProperty.RegisterAttached%2A> возвращает <xref:System.Windows.DependencyProperty>типа.</span><span class="sxs-lookup"><span data-stu-id="2fec7-422">This method returns the type <xref:System.Windows.DependencyPropertyKey>, whereas <xref:System.Windows.DependencyProperty.RegisterAttached%2A> returns the type <xref:System.Windows.DependencyProperty>.</span></span> <span data-ttu-id="2fec7-423">Как правило, ключи, представляющие тип, <xref:System.Windows.DependencyProperty>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-423">Typically, the keys that represent the type <xref:System.Windows.DependencyProperty>.</span></span> <span data-ttu-id="2fec7-424">Как правило, ключи, представляющие свойства только для чтения, не являются общедоступными, поскольку ключи можно использовать для установки значения свойства зависимостей путем вызова <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-424">Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>.</span></span> <span data-ttu-id="2fec7-425">Разработка класса повлияет на ваши требования, но обычно рекомендуется ограничить доступ и видимость любых <xref:System.Windows.DependencyPropertyKey> только теми частями кода, которые необходимы для установки этого свойства зависимостей как части логики класса или приложения.</span><span class="sxs-lookup"><span data-stu-id="2fec7-425">Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <xref:System.Windows.DependencyPropertyKey> to only those parts of your code that are necessary to set that dependency property as part of class or application logic.</span></span> <span data-ttu-id="2fec7-426">Также рекомендуется предоставить идентификатор свойства зависимостей для свойства зависимостей "только для чтения", предоставив значение <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> в качестве поля `public static readonly` в классе.</span><span class="sxs-lookup"><span data-stu-id="2fec7-426">It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> as a `public static readonly` field on your class.</span></span>  
  
 <span data-ttu-id="2fec7-427">Присоединенные свойства только для чтения являются редким сценарием, поскольку основной сценарий для присоединенного свойства используется в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="2fec7-427">Read-only attached properties are a rare scenario, because the primary scenario for an attached property is its use in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span> <span data-ttu-id="2fec7-428">Без открытого метода задания вложенное свойство не может быть задано в синтаксисе [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="2fec7-428">Without a public setter, an attached property cannot be set in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] syntax.</span></span>  
  
 <span data-ttu-id="2fec7-429">Дополнительные сведения о регистрации свойств зависимостей см. в разделе <xref:System.Windows.DependencyProperty>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-429">For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.</span></span>  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a><span data-ttu-id="2fec7-430">Использование RegisterAttached для наследования значений свойств зависимостей</span><span class="sxs-lookup"><span data-stu-id="2fec7-430">Use RegisterAttached for Value-inheriting Dependency Properties</span></span>  
 <span data-ttu-id="2fec7-431">Один из сценариев для регистрации свойства зависимостей в качестве присоединенного вместо <xref:System.Windows.DependencyProperty.Register%2A> — Поддержка наследования значения свойства.</span><span class="sxs-lookup"><span data-stu-id="2fec7-431">One particular scenario for registering a dependency property as attached instead of <xref:System.Windows.DependencyProperty.Register%2A> is to support property value inheritance.</span></span> <span data-ttu-id="2fec7-432">Следует регистрировать свойства зависимостей, наследуемые значениями, с <xref:System.Windows.DependencyProperty.RegisterAttached%2A> даже если класс определяет методы доступа к оболочке свойств, которые предоставляют свойство зависимостей, и даже если вы не собираетесь предоставлять статические методы get \* и Set \* для предоставления истинных вложений методы доступа для поддержки свойств.</span><span class="sxs-lookup"><span data-stu-id="2fec7-432">You should register value-inheriting dependency properties with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get\* and Set\* static methods to provide true attached property support accessors.</span></span>   <span data-ttu-id="2fec7-433">Несмотря на то, что наследование значений свойств может работать для неприсоединенных свойств зависимостей, поведение наследования для неприсоединенного свойства через определенные границы элементов в дереве среды выполнения не определено.</span><span class="sxs-lookup"><span data-stu-id="2fec7-433">Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined.</span></span> <span data-ttu-id="2fec7-434">Регистрация свойства как присоединенного фактически делает присоединенное свойство глобальным свойством системы свойств и гарантирует, что наследование значения свойства работает во всех границах дерева элементов.</span><span class="sxs-lookup"><span data-stu-id="2fec7-434">Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree.</span></span> <span data-ttu-id="2fec7-435">Всегда используйте <xref:System.Windows.DependencyProperty.RegisterAttached%2A> для регистрации свойств, в которых указываются <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> в метаданных.</span><span class="sxs-lookup"><span data-stu-id="2fec7-435">Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata.</span></span> <span data-ttu-id="2fec7-436">Дополнительные сведения см. в разделе [Наследование значения свойства](~/docs/framework/wpf/advanced/property-value-inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="2fec7-436">For more information, see [Property Value Inheritance](~/docs/framework/wpf/advanced/property-value-inheritance.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="2fec7-437">Регистрирует свойство зависимостей как свойство зависимостей только для чтения.</span><span class="sxs-lookup"><span data-stu-id="2fec7-437">Registers a dependency property as a read-only dependency property.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterReadOnly (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="2fec7-438">Имя регистрируемого свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-438">The name of the dependency property to register.</span></span></param>
        <param name="propertyType"><span data-ttu-id="2fec7-439">Тип свойства.</span><span class="sxs-lookup"><span data-stu-id="2fec7-439">The type of the property.</span></span></param>
        <param name="ownerType"><span data-ttu-id="2fec7-440">Тип владельца, регистрирующего свойство зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-440">The owner type that is registering the dependency property.</span></span></param>
        <param name="typeMetadata"><span data-ttu-id="2fec7-441">Метаданные свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-441">Property metadata for the dependency property.</span></span></param>
        <summary><span data-ttu-id="2fec7-442">Регистрирует доступное только для чтения свойство зависимостей с указанным типом свойства, типом владельца и метаданными свойства.</span><span class="sxs-lookup"><span data-stu-id="2fec7-442">Registers a read-only dependency property, with the specified property type, owner type, and property metadata.</span></span></summary>
        <returns><span data-ttu-id="2fec7-443">Ключ свойства зависимостей, который следует использовать для задания значения статического доступного только для чтения поля в вашем классе, которое затем используется для ссылки на свойство зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-443">A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2fec7-444">Этот метод возвращает тип <xref:System.Windows.DependencyPropertyKey>, тогда как <xref:System.Windows.DependencyProperty.RegisterAttached%2A> возвращает <xref:System.Windows.DependencyProperty>типа.</span><span class="sxs-lookup"><span data-stu-id="2fec7-444">This method returns the type <xref:System.Windows.DependencyPropertyKey>, whereas <xref:System.Windows.DependencyProperty.RegisterAttached%2A> returns the type <xref:System.Windows.DependencyProperty>.</span></span> <span data-ttu-id="2fec7-445">Как правило, ключи, представляющие свойства только для чтения, не являются общедоступными, поскольку ключи можно использовать для установки значения свойства зависимостей путем вызова <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-445">Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>.</span></span> <span data-ttu-id="2fec7-446">Разработка класса повлияет на ваши требования, но обычно рекомендуется ограничить доступ и видимость любых <xref:System.Windows.DependencyPropertyKey> только теми частями кода, которые необходимы для установки этого свойства зависимостей как части логики класса или приложения.</span><span class="sxs-lookup"><span data-stu-id="2fec7-446">Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <xref:System.Windows.DependencyPropertyKey> to only those parts of your code that are necessary to set that dependency property as part of class or application logic.</span></span> <span data-ttu-id="2fec7-447">Также рекомендуется предоставить идентификатор свойства зависимостей для свойства зависимостей "только для чтения", предоставив значение <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> в качестве поля `public static readonly` в классе.</span><span class="sxs-lookup"><span data-stu-id="2fec7-447">It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> as a `public static readonly` field on your class.</span></span>  
  
 <span data-ttu-id="2fec7-448">Свойства зависимостей "только для чтения" являются довольно типичным сценарием как в существующем API, так и в сценариях настройки, поскольку для других функций [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] может потребоваться свойство зависимости, даже если это свойство не предназначено для настройки вызывающими объектами.</span><span class="sxs-lookup"><span data-stu-id="2fec7-448">Read-only dependency properties are a fairly typical scenario both in the existing API and for customization scenarios, because other [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] features might require a dependency property even if that property is not intended to be settable by callers.</span></span> <span data-ttu-id="2fec7-449">Значение свойства зависимости, доступное только для чтения, можно использовать в качестве основания для других операций системы свойств, принимающих свойство зависимостей, например для <xref:System.Windows.Trigger> в свойстве зависимостей в стиле.</span><span class="sxs-lookup"><span data-stu-id="2fec7-449">You can use the value of a read-only dependency property as the basis for other property system operations that take a dependency property, such as basing a <xref:System.Windows.Trigger> on the dependency property in a style.</span></span>  
  
 <span data-ttu-id="2fec7-450">Дополнительные сведения о регистрации свойств зависимостей см. в разделе <xref:System.Windows.DependencyProperty>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-450">For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2fec7-451">В следующем примере свойство зависимостей `AquariumSize` регистрируется как доступное только для чтения.</span><span class="sxs-lookup"><span data-stu-id="2fec7-451">The following example registers an `AquariumSize` dependency property as read-only.</span></span> <span data-ttu-id="2fec7-452">В примере определяется `AquariumSizeKey` как внутренний ключ (чтобы другие классы в сборке могли переопределять метаданные) и предоставляет идентификатор свойства зависимостей на основе этого ключа как `AquariumSizeProperty`.</span><span class="sxs-lookup"><span data-stu-id="2fec7-452">The example defines `AquariumSizeKey` as an internal key (so that other classes in the assembly could override metadata) and exposes the dependency property identifier based on that key as `AquariumSizeProperty`.</span></span> <span data-ttu-id="2fec7-453">Кроме того, создается оболочка для `AquariumSize`с использованием только метода доступа get.</span><span class="sxs-lookup"><span data-stu-id="2fec7-453">Also, a wrapper is created for `AquariumSize`, with only a get accessor.</span></span>  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="2fec7-454">Имя регистрируемого свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-454">The name of the dependency property to register.</span></span></param>
        <param name="propertyType"><span data-ttu-id="2fec7-455">Тип свойства.</span><span class="sxs-lookup"><span data-stu-id="2fec7-455">The type of the property.</span></span></param>
        <param name="ownerType"><span data-ttu-id="2fec7-456">Тип владельца, регистрирующего свойство зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-456">The owner type that is registering the dependency property.</span></span></param>
        <param name="typeMetadata"><span data-ttu-id="2fec7-457">Метаданные свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-457">Property metadata for the dependency property.</span></span></param>
        <param name="validateValueCallback"><span data-ttu-id="2fec7-458">Ссылка на созданный пользователем обратный вызов, который должен выполнить пользовательскую проверку значения свойства зависимостей после обычной проверки типа.</span><span class="sxs-lookup"><span data-stu-id="2fec7-458">A reference to a user-created callback that should perform any custom validation of the dependency property value beyond typical type validation.</span></span></param>
        <summary><span data-ttu-id="2fec7-459">Регистрирует доступное только для чтения свойство зависимостей с указанным типом свойства, типом владельца, метаданными свойства и обратным вызовом для проверки.</span><span class="sxs-lookup"><span data-stu-id="2fec7-459">Registers a read-only dependency property, with the specified property type, owner type, property metadata, and a validation callback.</span></span></summary>
        <returns><span data-ttu-id="2fec7-460">Ключ свойства зависимостей, который следует использовать для задания значения статического доступного только для чтения поля в вашем классе, которое затем используется для ссылки на свойство зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-460">A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property later.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2fec7-461">Этот метод возвращает тип <xref:System.Windows.DependencyPropertyKey>, тогда как <xref:System.Windows.DependencyProperty.RegisterAttached%2A> возвращает <xref:System.Windows.DependencyProperty>типа.</span><span class="sxs-lookup"><span data-stu-id="2fec7-461">This method returns the type <xref:System.Windows.DependencyPropertyKey>, whereas <xref:System.Windows.DependencyProperty.RegisterAttached%2A> returns the type <xref:System.Windows.DependencyProperty>.</span></span> <span data-ttu-id="2fec7-462">Как правило, ключи, представляющие свойства только для чтения, не являются общедоступными, поскольку ключи можно использовать для установки значения свойства зависимостей путем вызова <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-462">Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>.</span></span> <span data-ttu-id="2fec7-463">Разработка класса повлияет на ваши требования, но обычно рекомендуется ограничить доступ и видимость любых <xref:System.Windows.DependencyPropertyKey> только теми частями кода, которые необходимы для установки этого свойства зависимостей как части логики класса или приложения.</span><span class="sxs-lookup"><span data-stu-id="2fec7-463">Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <xref:System.Windows.DependencyPropertyKey> to only those parts of your code that are necessary to set that dependency property as part of class or application logic.</span></span> <span data-ttu-id="2fec7-464">Также рекомендуется предоставить идентификатор свойства зависимостей для свойства зависимостей "только для чтения", предоставив значение <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> в качестве поля `public static readonly` в классе.</span><span class="sxs-lookup"><span data-stu-id="2fec7-464">It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> as a `public static readonly` field on your class.</span></span>  
  
 <span data-ttu-id="2fec7-465">Свойства зависимостей только для чтения являются довольно типичным сценарием.</span><span class="sxs-lookup"><span data-stu-id="2fec7-465">Read-only dependency properties are a fairly typical scenario.</span></span> <span data-ttu-id="2fec7-466">Значение свойства зависимости, доступное только для чтения, можно использовать в качестве основания для других операций системы свойств, принимающих свойство зависимостей, например для <xref:System.Windows.Trigger> в свойстве зависимостей в стиле.</span><span class="sxs-lookup"><span data-stu-id="2fec7-466">You can use the value of a read-only dependency property as the basis for other property system operations that take a dependency property, such as basing a <xref:System.Windows.Trigger> on the dependency property in a style.</span></span>  
  
 <span data-ttu-id="2fec7-467">Дополнительные сведения о регистрации свойств зависимостей см. в разделе <xref:System.Windows.DependencyProperty>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-467">For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.</span></span>  
  
 <span data-ttu-id="2fec7-468">Проверка свойства зависимостей, доступного только для чтения, может быть менее важной.</span><span class="sxs-lookup"><span data-stu-id="2fec7-468">Validation on a read-only dependency property might be less important.</span></span> <span data-ttu-id="2fec7-469">Неоткрытый уровень доступа, указанный для ключа, снижает вероятность неправильного ввода.</span><span class="sxs-lookup"><span data-stu-id="2fec7-469">The nonpublic access level you specify for the key reduces the likelihood for arbitrary invalid input.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dependencyProperty.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2fec7-470">Возвращает строковое представление свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-470">Returns the string representation of the dependency property.</span></span></summary>
        <returns><span data-ttu-id="2fec7-471">Строковое представление свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-471">The string representation of the dependency property.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2fec7-472">Эта реализация возвращает значение свойства <xref:System.Windows.DependencyProperty.Name%2A>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-472">This implementation returns the <xref:System.Windows.DependencyProperty.Name%2A> property value.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.DependencyProperty.Name" />
      </Docs>
    </Member>
    <Member MemberName="UnsetValue">
      <MemberSignature Language="C#" Value="public static readonly object UnsetValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object UnsetValue" />
      <MemberSignature Language="DocId" Value="F:System.Windows.DependencyProperty.UnsetValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnsetValue As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ UnsetValue;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnsetValue : obj" Usage="System.Windows.DependencyProperty.UnsetValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2fec7-473">Задает статическое значение, используемое системой свойств [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] вместо <see langword="null" /> для указания того, что свойство существует, но его значение не задано системой свойств.</span><span class="sxs-lookup"><span data-stu-id="2fec7-473">Specifies a static value that is used by the [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] property system rather than <see langword="null" /> to indicate that the property exists, but does not have its value set by the property system.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2fec7-474"><xref:System.Windows.DependencyProperty.UnsetValue> — это значение Sentinel, которое используется в сценариях, где система свойств [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] не может определить запрошенное значение <xref:System.Windows.DependencyProperty>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-474"><xref:System.Windows.DependencyProperty.UnsetValue> is a sentinel value that is used for scenarios where the [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] property system is unable to determine a requested <xref:System.Windows.DependencyProperty> value.</span></span> <span data-ttu-id="2fec7-475"><xref:System.Windows.DependencyProperty.UnsetValue> используется вместо `null`, так как `null` может быть допустимым значением свойства, а также допустимым (и часто используемым) <xref:System.Windows.PropertyMetadata.DefaultValue%2A>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-475"><xref:System.Windows.DependencyProperty.UnsetValue> is used rather than `null`, because `null` could be a valid property value, as well as a valid (and frequently used) <xref:System.Windows.PropertyMetadata.DefaultValue%2A>.</span></span>  
  
 <span data-ttu-id="2fec7-476"><xref:System.Windows.DependencyProperty.UnsetValue> никогда не возвращается из <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-476"><xref:System.Windows.DependencyProperty.UnsetValue> is never returned out of <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="2fec7-477">При вызове <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType> для свойства зависимости в экземпляре <xref:System.Windows.DependencyObject> применяется одно из следующих условий:</span><span class="sxs-lookup"><span data-stu-id="2fec7-477">When you call <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType> on a dependency property on a <xref:System.Windows.DependencyObject> instance, one of the following applies:</span></span>  
  
-   <span data-ttu-id="2fec7-478">Свойство зависимостей имеет значение по умолчанию, установленное в метаданных и возвращаемое значение.</span><span class="sxs-lookup"><span data-stu-id="2fec7-478">A dependency property has a default value established in metadata and that value is returned.</span></span> <span data-ttu-id="2fec7-479">Это значение может быть получено из <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-479">This value might come from <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.</span></span>  
  
-   <span data-ttu-id="2fec7-480">Другое значение было установлено системой свойств, и значение по умолчанию больше не применяется.</span><span class="sxs-lookup"><span data-stu-id="2fec7-480">Some other value was established by the property system, and the default value is no longer relevant.</span></span> <span data-ttu-id="2fec7-481">Дополнительные сведения см. в разделе [Приоритет значений свойств зависимостей](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).</span><span class="sxs-lookup"><span data-stu-id="2fec7-481">For details, see [Dependency Property Value Precedence](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).</span></span>  
  
 <span data-ttu-id="2fec7-482">Явное задание <xref:System.Windows.PropertyMetadata.DefaultValue%2A> <xref:System.Windows.DependencyProperty.UnsetValue> запрещено.</span><span class="sxs-lookup"><span data-stu-id="2fec7-482">Setting a <xref:System.Windows.PropertyMetadata.DefaultValue%2A> of <xref:System.Windows.DependencyProperty.UnsetValue> is specifically disallowed.</span></span>  
  
 <span data-ttu-id="2fec7-483"><xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=nameWithType> возвращает <xref:System.Windows.DependencyProperty.UnsetValue>, если запрошенное свойство не задано локально.</span><span class="sxs-lookup"><span data-stu-id="2fec7-483"><xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=nameWithType> returns <xref:System.Windows.DependencyProperty.UnsetValue> when the requested property has not been locally set.</span></span>  
  
 <span data-ttu-id="2fec7-484"><xref:System.Windows.DependencyProperty.UnsetValue> имеет специальное значение при использовании в качестве возвращаемого значения <xref:System.Windows.CoerceValueCallback>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-484"><xref:System.Windows.DependencyProperty.UnsetValue> has a special meaning when used as the return value of a <xref:System.Windows.CoerceValueCallback>.</span></span> <span data-ttu-id="2fec7-485">Дополнительные сведения см. в разделе [обратные вызовы и проверка свойства зависимостей](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).</span><span class="sxs-lookup"><span data-stu-id="2fec7-485">For details, see [Dependency Property Callbacks and Validation](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).</span></span>  
  
 <span data-ttu-id="2fec7-486">При привязке к базе данных обратите внимание, что <xref:System.Windows.DependencyProperty.UnsetValue> не эквивалентно <xref:System.DBNull.Value>, аналогично тому, как <xref:System.DBNull.Value> не эквивалентно значению true null.</span><span class="sxs-lookup"><span data-stu-id="2fec7-486">If you are binding to a database, note that <xref:System.Windows.DependencyProperty.UnsetValue> is not equivalent to <xref:System.DBNull.Value>, in a similar way to how <xref:System.DBNull.Value> is not equivalent to a true null.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.ValidateValueCallback ValidateValueCallback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ValidateValueCallback ValidateValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValidateValueCallback As ValidateValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ValidateValueCallback ^ ValidateValueCallback { System::Windows::ValidateValueCallback ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValidateValueCallback : System.Windows.ValidateValueCallback" Usage="System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ValidateValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2fec7-487">Возвращает обратный вызов для проверки значения свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-487">Gets the value validation callback for the dependency property.</span></span></summary>
        <value><span data-ttu-id="2fec7-488">Обратный вызов для проверки значения данного свойства зависимостей, указанный параметром <paramref name="validateValueCallback" /> при изначальной регистрации свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-488">The value validation callback for this dependency property, as provided for the <paramref name="validateValueCallback" /> parameter in the original dependency property registration.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2fec7-489">Это свойство будет содержать `null` для любого свойства зависимости без зарегистрированного обратного вызова проверки.</span><span class="sxs-lookup"><span data-stu-id="2fec7-489">This property will contain `null` for any dependency property with no registered validation callback.</span></span>  
  
 <span data-ttu-id="2fec7-490">Обратные вызовы проверки значений должны действовать в статическом смысле: Проверка, применяемая с помощью <xref:System.Windows.ValidateValueCallback>, не может определить, является ли указанное значение допустимым для какого-либо конкретного экземпляра.</span><span class="sxs-lookup"><span data-stu-id="2fec7-490">Validate value callbacks must act in a static sense: validation applied through the <xref:System.Windows.ValidateValueCallback> cannot determine whether the provided value is valid for any particular instance.</span></span> <span data-ttu-id="2fec7-491">Обратный вызов может определить, должны ли все объекты, имеющие свойство зависимости, или не принимать предоставленное значение как допустимое.</span><span class="sxs-lookup"><span data-stu-id="2fec7-491">The callback can only determine whether all objects that possess the dependency property should or should not accept the provided value as valid.</span></span> <span data-ttu-id="2fec7-492">Если необходимо выполнить проверку, которая основывается на значениях других свойств зависимостей в конкретном экземпляре, используйте вместо этого <xref:System.Windows.CoerceValueCallback>.</span><span class="sxs-lookup"><span data-stu-id="2fec7-492">If you need to perform validation that relies on knowing the values of other dependency properties on a particular instance, use a <xref:System.Windows.CoerceValueCallback> instead.</span></span> <span data-ttu-id="2fec7-493"><xref:System.Windows.CoerceValueCallback> регистрируется как часть метаданных свойства зависимости, а не непосредственно в идентификаторе свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="2fec7-493">The <xref:System.Windows.CoerceValueCallback> is registered as part of dependency property metadata, rather than directly within the dependency property identifier.</span></span> <span data-ttu-id="2fec7-494">Дополнительные сведения см. в разделе [обратные вызовы и проверка свойства зависимостей](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).</span><span class="sxs-lookup"><span data-stu-id="2fec7-494">For details, see [Dependency Property Callbacks and Validation](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ValidateValueCallback" />
      </Docs>
    </Member>
  </Members>
</Type>
