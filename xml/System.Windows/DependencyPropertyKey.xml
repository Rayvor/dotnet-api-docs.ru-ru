<Type Name="DependencyPropertyKey" FullName="System.Windows.DependencyPropertyKey">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d75f53c5f064e0cd1a345a7c3787221dbc49ccdb" /><Meta Name="ms.sourcegitcommit" Value="f1d16425528e237257ca3b58eb49217a514849ea" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="04/24/2019" /><Meta Name="ms.locfileid" Value="64187347" /></Metadata><TypeSignature Language="C#" Value="public sealed class DependencyPropertyKey" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DependencyPropertyKey extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyPropertyKey" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DependencyPropertyKey" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyPropertyKey sealed" />
  <TypeSignature Language="F#" Value="type DependencyPropertyKey = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="6b7d6-101">Предоставляет идентификатор свойства зависимостей для ограниченного доступа на запись к доступному только для чтения свойству зависимостей.</span><span class="sxs-lookup"><span data-stu-id="6b7d6-101">Provides a dependency property identifier for limited write access to a read-only dependency property.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6b7d6-102"><xref:System.Windows.DependencyPropertyKey> экземпляры получаются как возвращаемое значение вызова регистрации свойства зависимостей, с помощью методов <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> или <xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>.</span><span class="sxs-lookup"><span data-stu-id="6b7d6-102"><xref:System.Windows.DependencyPropertyKey> instances are obtained as the return value of a dependency property registration call using the methods <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> or <xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>.</span></span>  
  
 <span data-ttu-id="6b7d6-103">Можно использовать типы, регистрируется свойство зависимости <xref:System.Windows.DependencyPropertyKey> в вызовах <xref:System.Windows.DependencyObject.SetValue%2A> и <xref:System.Windows.DependencyObject.ClearValue%2A> , измените значение свойства как часть логики класса.</span><span class="sxs-lookup"><span data-stu-id="6b7d6-103">The types that register a dependency property can use the <xref:System.Windows.DependencyPropertyKey> in calls to <xref:System.Windows.DependencyObject.SetValue%2A> and <xref:System.Windows.DependencyObject.ClearValue%2A> that adjust the property's value as part of class logic.</span></span> <span data-ttu-id="6b7d6-104">Если разрешено уровнем доступа ключа, связанные классы можно также использовать ключ и свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="6b7d6-104">If permitted by the access level of the key, related classes can use the key and the dependency property also.</span></span> <span data-ttu-id="6b7d6-105">Например можно объявить ключ внутренним и другим типам в той же сборке может также задать это свойство зависимостей.</span><span class="sxs-lookup"><span data-stu-id="6b7d6-105">For instance, you can declare the key as internal, and other types within the same assembly can also set that dependency property.</span></span>  
  
 <span data-ttu-id="6b7d6-106"><xref:System.Windows.DependencyPropertyKey> Возвращаются зависимости только для чтения регистрации свойства нельзя делать открытым, так как открытие ключа делает свойство настраиваемым, подрывая смысл его регистрации в качестве свойства зависимости только для чтения.</span><span class="sxs-lookup"><span data-stu-id="6b7d6-106">The <xref:System.Windows.DependencyPropertyKey> returned by read-only dependency property registration should not be made public, because exposing the key makes the property settable, thus defeating the point of registering it as a read-only dependency property.</span></span> <span data-ttu-id="6b7d6-107">Кроме того, открытие ключа приводит к возникновению рассогласования доступных зависимость поведения свойства и его [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] реализации оболочки свойства, которые имеет недопустимый класс конструктора.</span><span class="sxs-lookup"><span data-stu-id="6b7d6-107">Also, exposing the key causes a mismatch between the available dependency property behaviors and its [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] property wrapper implementations, which is bad class design.</span></span>  
  
 <span data-ttu-id="6b7d6-108">Вместо предоставления самого ключа, вместо этого следует предоставлять <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A> значение <xref:System.Windows.DependencyPropertyKey> как `public static readonly` <xref:System.Windows.DependencyProperty> в классе.</span><span class="sxs-lookup"><span data-stu-id="6b7d6-108">Instead of exposing the key itself, you should instead expose the <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A> value of the <xref:System.Windows.DependencyPropertyKey> as a `public static readonly`<xref:System.Windows.DependencyProperty> on your class.</span></span> <span data-ttu-id="6b7d6-109">Это позволяет возвращать допустимый идентификатор свойства зависимостей для определенных операций системы свойств, таких как отображение локально установленные значения свойства.</span><span class="sxs-lookup"><span data-stu-id="6b7d6-109">This enables the property to return a valid dependency property identifier for certain property system operations such as enumerating locally set values.</span></span> <span data-ttu-id="6b7d6-110">Тем не менее, поэтому полученный идентификатор не поддерживает все возможности <xref:System.Windows.DependencyProperty> для многих операций системы свойств.</span><span class="sxs-lookup"><span data-stu-id="6b7d6-110">However, the identifier thus obtained does not have the full capabilities of a <xref:System.Windows.DependencyProperty> for many property system operations.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6b7d6-111">В следующем примере регистрирует свойство зависимостей только для чтения и также использует ключ для двух целей в других членах класса: реализация «оболочки» get и как идентификатор для защищенной операции определения, задающее значение на основе вычислений значений других свойств.</span><span class="sxs-lookup"><span data-stu-id="6b7d6-111">The following example registers a read-only dependency property, and also uses the key for two purposes in other class members: implementing the get "wrapper", and as the identifier for a protected determination operation that sets the value based on calculations of other property values.</span></span>  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyProperty" />
  </Docs>
  <Members>
    <Member MemberName="DependencyProperty">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty DependencyProperty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyProperty DependencyProperty" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyPropertyKey.DependencyProperty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DependencyProperty As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyProperty ^ DependencyProperty { System::Windows::DependencyProperty ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DependencyProperty : System.Windows.DependencyProperty" Usage="System.Windows.DependencyPropertyKey.DependencyProperty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6b7d6-112">Возвращает идентификатор свойства зависимостей, связанный с данным специализированным идентификатором доступного только для чтения свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="6b7d6-112">Gets the dependency property identifier associated with this specialized read-only dependency property identifier.</span></span></summary>
        <value><span data-ttu-id="6b7d6-113">Соответствующий идентификатор свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="6b7d6-113">The relevant dependency property identifier.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6b7d6-114"><xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A> Значение включает идентификатор свойство только для чтения участвовать в стандартных операций системы свойств, используя некоторые из тех же интерфейсов в качестве используемых для свойств зависимостей чтения и записи.</span><span class="sxs-lookup"><span data-stu-id="6b7d6-114">The <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A> value enables a read-only property's identifier to participate in common property system operations using some of the same interfaces as used for read-write dependency properties.</span></span>  
  
 <span data-ttu-id="6b7d6-115">Чтобы реализовать метод доступа get свойства для свойства зависимостей только для чтения, следует создать и представить <xref:System.Windows.DependencyProperty> идентификатор для класса.</span><span class="sxs-lookup"><span data-stu-id="6b7d6-115">In order to implement the get property accessor for a read-only dependency property, you should create and expose a <xref:System.Windows.DependencyProperty> identifier on your class.</span></span> <span data-ttu-id="6b7d6-116">Это служит двум целям:</span><span class="sxs-lookup"><span data-stu-id="6b7d6-116">This serves two purposes:</span></span>  
  
-   <span data-ttu-id="6b7d6-117">Потребностей класс <xref:System.Windows.DependencyProperty> идентификатор, чтобы реализовать метод доступа get для свойства оболочки.</span><span class="sxs-lookup"><span data-stu-id="6b7d6-117">Your own class needs the <xref:System.Windows.DependencyProperty> identifier in order to implement the get accessor for the property wrapper.</span></span> <span data-ttu-id="6b7d6-118">Использовании <xref:System.Windows.DependencyProperty> как параметр для <xref:System.Windows.DependencyObject.GetValue%2A> вызов, который реализует метод доступа get.</span><span class="sxs-lookup"><span data-stu-id="6b7d6-118">You use the <xref:System.Windows.DependencyProperty> as a parameter for the <xref:System.Windows.DependencyObject.GetValue%2A> call that implements the get accessor.</span></span>  
  
-   <span data-ttu-id="6b7d6-119"><xref:System.Windows.DependencyProperty> Идентификаторы предоставляют свойство зависимости в системе свойств таким образом, чтобы другие методы, основанные на метаданных доступен в стандартную форму.</span><span class="sxs-lookup"><span data-stu-id="6b7d6-119"><xref:System.Windows.DependencyProperty> identifiers expose your dependency property to the property system such that other methods that rely on metadata can access it in a standard form.</span></span> <span data-ttu-id="6b7d6-120">К примеру Если вызван <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> на некоторых <xref:System.Windows.DependencyObject> и получить идентификатор перечисления локально заданных свойств (значения и идентификаторы), возвращенный для свойства зависимостей только для чтения может быть ваш <xref:System.Windows.DependencyProperty> преимущества, а не ключ.</span><span class="sxs-lookup"><span data-stu-id="6b7d6-120">For instance, if you called <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> on some <xref:System.Windows.DependencyObject> and obtained an enumeration of locally set properties (values and identifiers) the identifier returned for a read-only dependency property would be your <xref:System.Windows.DependencyProperty> value rather than the key.</span></span> <span data-ttu-id="6b7d6-121">Отсутствие прямого доступа к <xref:System.Windows.DependencyProperty> идентификатор повышает безопасность свойства зависимостей только для чтения любым способом, он просто выполняет операции, включающие свойство менее удобны для последующих производных классов и экземпляров классов.</span><span class="sxs-lookup"><span data-stu-id="6b7d6-121">Not exposing a <xref:System.Windows.DependencyProperty> identifier does not increase the security of your read-only dependency property in any way, it just makes operations that involve your property more awkward both for subsequent derived classes and class instances.</span></span>  
  
 <span data-ttu-id="6b7d6-122">Для предоставления <xref:System.Windows.DependencyProperty> идентификатор для класса, вы вызываете <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A> непосредственно на ваш ключ.</span><span class="sxs-lookup"><span data-stu-id="6b7d6-122">To expose the  <xref:System.Windows.DependencyProperty> identifier on your class, you call <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A> directly on your key.</span></span> <span data-ttu-id="6b7d6-123">Это значение используется для создания `public static readonly` <xref:System.Windows.DependencyProperty> идентификатор на класс, который соответствует <xref:System.Windows.DependencyPropertyKey>.</span><span class="sxs-lookup"><span data-stu-id="6b7d6-123">Use this value to create a `public static readonly`<xref:System.Windows.DependencyProperty> identifier on the class, which parallels the <xref:System.Windows.DependencyPropertyKey>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6b7d6-124">В следующем примере вызывается <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A> для предоставления <xref:System.Windows.DependencyProperty> идентификатор (`AquariumGraphicProperty`) для `AquariumGraphic` зависимостей только для чтения свойство класса.</span><span class="sxs-lookup"><span data-stu-id="6b7d6-124">The following example calls <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A> to expose the <xref:System.Windows.DependencyProperty> identifier (`AquariumGraphicProperty`) for the `AquariumGraphic` read-only dependency property on a class.</span></span> <span data-ttu-id="6b7d6-125">В примере также показано <xref:System.Windows.DependencyPropertyKey> создания (как внутренний элемент) и метод доступа get для `AquariumGraphic`.</span><span class="sxs-lookup"><span data-stu-id="6b7d6-125">The example also shows the <xref:System.Windows.DependencyPropertyKey> creation (as an internal member) and the get accessor for `AquariumGraphic`.</span></span>  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata -&gt; unit" Usage="dependencyPropertyKey.OverrideMetadata (forType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="forType"><span data-ttu-id="6b7d6-126">Тип, в котором существует данное свойство зависимостей и следует переопределить метаданные.</span><span class="sxs-lookup"><span data-stu-id="6b7d6-126">The type on which this dependency property exists and metadata should be overridden.</span></span></param>
        <param name="typeMetadata"><span data-ttu-id="6b7d6-127">Метаданные, переданные для этого типа.</span><span class="sxs-lookup"><span data-stu-id="6b7d6-127">Metadata supplied for this type.</span></span></param>
        <summary><span data-ttu-id="6b7d6-128">Переопределяет метаданные доступного только для чтения свойства зависимостей, представленного данным идентификатором свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="6b7d6-128">Overrides the metadata of a read-only dependency property that is represented by this dependency property identifier.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6b7d6-129">Переопределение метаданных свойства зависимости только для чтения выполняется по тем же причинам, что переопределение метаданных свойства зависимости для чтения и записи, а также ограничен доступ на уровне ключей, так как поведения, указанные в метаданных можно изменить поведение набора ( значение по умолчанию, например).</span><span class="sxs-lookup"><span data-stu-id="6b7d6-129">Overriding metadata on a read-only dependency property is done for similar reasons as overriding metadata on a read-write dependency property, and is restricted to access at the key level because behaviors specified in the metadata can change the set behavior (the default value, for instance).</span></span>  
  
 <span data-ttu-id="6b7d6-130">Как с помощью свойства зависимости для чтения и записи, переопределение метаданных свойства зависимости только для чтения следует делать только до того, как свойство используется системой свойств (это равно времени, определенные экземпляры объектов, регистрирующие Свойство создаются экземпляры).</span><span class="sxs-lookup"><span data-stu-id="6b7d6-130">As with read-write dependency properties, overriding metadata on a read-only dependency property should only be done prior to that property being placed in use by the property system (this equates to the time that specific instances of objects that register the property are instantiated).</span></span> <span data-ttu-id="6b7d6-131">Вызовы <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> следует выполнять только в статических конструкторах типа, предоставляющего себя в качестве `forType` параметр этого метода или эквивалентные инициализации для этого класса.</span><span class="sxs-lookup"><span data-stu-id="6b7d6-131">Calls to <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> should only be performed within the static constructors of the type that provides itself as the `forType` parameter of this method, or equivalent initialization for that class.</span></span>  
  
 <span data-ttu-id="6b7d6-132">Этот метод фактически передает <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> , передавая <xref:System.Windows.DependencyPropertyKey> экземпляр в качестве параметра ключа.</span><span class="sxs-lookup"><span data-stu-id="6b7d6-132">This method effectively forwards to the <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> method, passing the <xref:System.Windows.DependencyPropertyKey> instance as the key parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6b7d6-133">В приведенном ниже примере переопределяются метаданные для существующего свойства зависимости только для чтения, наследующий класс.</span><span class="sxs-lookup"><span data-stu-id="6b7d6-133">The following example overrides metadata for an existing read-only dependency property that a class inherits.</span></span> <span data-ttu-id="6b7d6-134">В этом случае целью сценария было Добавление принудительного обратного вызова значения, но не имеют метаданных базового свойства.</span><span class="sxs-lookup"><span data-stu-id="6b7d6-134">In this case, the scenario goal was to add a coerce value callback that the base property metadata did not have.</span></span> <span data-ttu-id="6b7d6-135">Можно также переопределить метаданные для любой из других причин, которые обычно переопределения метаданных является подходят (изменение значения по умолчанию, добавление <xref:System.Windows.FrameworkPropertyMetadataOptions> значений и т. д.)</span><span class="sxs-lookup"><span data-stu-id="6b7d6-135">You could also override metadata for any of the other reasons that overriding metadata is typically appropriate (changing default value, adding <xref:System.Windows.FrameworkPropertyMetadataOptions> values, etc.)</span></span>  
  
 [!code-csharp[WPFAquariumSln#RODPOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodpoverride)]
 [!code-vb[WPFAquariumSln#RODPOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodpoverride)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="6b7d6-136">Попытка переопределения метаданных в доступном для чтения и записи свойстве зависимостей (не может быть осуществлена с помощью данной сигнатуры).</span><span class="sxs-lookup"><span data-stu-id="6b7d6-136">Attempted metadata override on a read-write dependency property (cannot be done using this signature).</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6b7d6-137">Метаданные уже были установлены для свойства, так как они существуют в указанном типе.</span><span class="sxs-lookup"><span data-stu-id="6b7d6-137">Metadata was already established for the property as it exists on the provided type.</span></span></exception>
        <altmember cref="T:System.Windows.DependencyProperty" />
        <altmember cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)" />
      </Docs>
    </Member>
  </Members>
</Type>