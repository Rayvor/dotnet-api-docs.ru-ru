<Type Name="DependencyObject" FullName="System.Windows.DependencyObject">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0900b79b76b6508ed950a519c524288ac0c6b191" /><Meta Name="ms.sourcegitcommit" Value="e7974886b08aa83a8fb461e8550f31a7d4331ee3" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="07/23/2019" /><Meta Name="ms.locfileid" Value="68392289" /></Metadata><TypeSignature Language="C#" Value="public class DependencyObject : System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DependencyObject extends System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyObject" />
  <TypeSignature Language="VB.NET" Value="Public Class DependencyObject&#xA;Inherits DispatcherObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyObject : System::Windows::Threading::DispatcherObject" />
  <TypeSignature Language="F#" Value="type DependencyObject = class&#xA;    inherit DispatcherObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeDescriptionProvider(typeof(MS.Internal.ComponentModel.DependencyObjectProvider))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.NameScopeProperty("NameScope", typeof(System.Windows.NameScope))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет объект, участвующий в системе свойств зависимостей.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.DependencyObject> Класс включает[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] системные службы свойств для многих производных классов.  
  
 Основная функция системы свойств — вычисление значений свойств и предоставление системного уведомления об измененных значениях. Другим ключевым классом, участвующим в системе свойств, <xref:System.Windows.DependencyProperty>является. <xref:System.Windows.DependencyProperty>включает регистрацию свойств зависимостей в системе свойств и предоставляет идентификацию и сведения о каждом свойстве зависимостей, тогда <xref:System.Windows.DependencyObject> как базовый класс позволяет объектам использовать свойства зависимостей.  
  
 <xref:System.Windows.DependencyObject>к службам и характеристикам относятся следующие.  
  
-   Поддержка размещения свойств зависимостей. Свойство зависимости регистрируется путем вызова <xref:System.Windows.DependencyProperty.Register%2A> метода и сохранения возвращаемого значения метода в виде открытого статического поля в классе.  
  
-   Поддержка размещения вложенных свойств. Присоединенные свойства регистрируются путем вызова <xref:System.Windows.DependencyProperty.RegisterAttached%2A> метода и сохранения возвращаемого значения метода в виде открытого статического поля только для чтения в классе. (Существуют также дополнительные требования к членам. Обратите внимание, что [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] это представляет конкретную реализацию присоединенных свойств. Дополнительные сведения см. в разделе [Общие сведения о вложенных свойствах](~/docs/framework/wpf/advanced/attached-properties-overview.md).) Затем присоединенное свойство можно задать для любого класса, производного от <xref:System.Windows.DependencyObject>.  
  
-   Методы Get, Set и Clear для значений всех свойств зависимостей, существующих в <xref:System.Windows.DependencyObject>.  
  
-   Метаданные, поддержка приведения значений, уведомление об изменении свойства и обратные вызовы переопределений для свойств зависимостей или присоединенных свойств. Кроме того, <xref:System.Windows.DependencyObject> класс упрощает метаданные свойств каждого владельца для свойства зависимостей.  
  
-   Общий базовый класс для классов, производных <xref:System.Windows.ContentElement>от <xref:System.Windows.Freezable>, или <xref:System.Windows.Media.Visual>. (<xref:System.Windows.UIElement>другой класс базового элемента содержит иерархию классов, включающую <xref:System.Windows.Media.Visual>.)  
  
   
  
## Examples  
 Следующий пример является производным от <xref:System.Windows.DependencyObject> для создания нового абстрактного класса. Затем класс регистрирует присоединенное свойство и включает элементы поддержки для этого присоединенного свойства.  
  
 [!code-csharp[WPFAquariumSln#DOMain](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#domain)]
 [!code-vb[WPFAquariumSln#DOMain](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#domain)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyProperty" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DependencyObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DependencyObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.DependencyObject" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ClearValue">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Очищает локальное значение свойства.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ClearValue">
      <MemberSignature Language="C#" Value="public void ClearValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearValue (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.ClearValue : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.ClearValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Очищаемое свойство зависимости, указанное объектной ссылкой <see cref="T:System.Windows.DependencyProperty" />.</param>
        <summary>Очищает локальное значение свойства. Очищаемое свойство задается идентификатором <see cref="T:System.Windows.DependencyProperty" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Очистка значения свойства путем вызова <xref:System.Windows.DependencyObject.ClearValue%2A> не обязательно дает свойству зависимостей значение по умолчанию, указанное в метаданных свойства зависимостей. Очистка свойства только позволяет очистить любое локальное значение, которое могло быть применено. Дополнительные сведения см. в разделе [Приоритет значений свойств зависимостей](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
   
  
## Examples  
 В следующем примере выполняется перебор всех свойств, для которых заданы локальные значения объекта, а затем <xref:System.Windows.DependencyObject.ClearValue%2A> вызывается метод для очистки значений каждого такого свойства.  
  
 [!code-csharp[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/csharp/VS_Snippets_Wpf/DPClearValue/CSharp/default.xaml.cs#iteratelocalvaluesandclear)]
 [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPClearValue/VisualBasic/default.xaml.vb#iteratelocalvaluesandclear)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Пытается вызвать метод <see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" /> для запечатанного <see cref="T:System.Windows.DependencyObject" />.</exception>
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
        <altmember cref="P:System.Windows.DependencyObject.IsSealed" />
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <Member MemberName="ClearValue">
      <MemberSignature Language="C#" Value="public void ClearValue (System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearValue(class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearValue (key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearValue(System::Windows::DependencyPropertyKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.ClearValue : System.Windows.DependencyPropertyKey -&gt; unit" Usage="dependencyObject.ClearValue key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="key">Ключ для очищаемого свойства зависимостей.</param>
        <summary>Очищает локальное значение свойства, доступного только для чтения. Очищаемое свойство задается объектом <see cref="T:System.Windows.DependencyPropertyKey" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Windows.DependencyPropertyKey> определяет свойство зависимостей "только для чтения" для операций системы свойств. Классы, определяющие свойства зависимостей только для чтения, не должны предоставлять этот ключ с доступом Public. Общедоступный ключ будет предоставлять открытый путь к коду, который инвертирует доступный только для чтения символ свойства, если такие методы, как <xref:System.Windows.DependencyObject.ClearValue%2A> или <xref:System.Windows.DependencyObject.SetValue%2A> , могут быть вызваны вне класса или сборки, ссылающиеся на ключ.  
  
 Очистка значения свойства путем вызова <xref:System.Windows.DependencyObject.ClearValue%2A> не обязательно дает свойству зависимостей значение по умолчанию, указанное в метаданных свойства зависимостей. Очистка значения только позволяет очистить любое локальное значение, которое могло быть применено. Дополнительные сведения см. в разделе [Приоритет значений свойств зависимостей](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Пытается вызвать метод <see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" /> для запечатанного <see cref="T:System.Windows.DependencyObject" />.</exception>
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
        <altmember cref="T:System.Windows.DependencyPropertyKey" />
      </Docs>
    </Member>
    <Member MemberName="CoerceValue">
      <MemberSignature Language="C#" Value="public void CoerceValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CoerceValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CoerceValue (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CoerceValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.CoerceValue : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.CoerceValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Идентификатор приводимого свойства зависимостей.</param>
        <summary>Приводит значение указанного свойства зависимостей. Это осуществляется путем вызова какой-либо функции <see cref="T:System.Windows.CoerceValueCallback" />, указанной в метаданных свойства зависимостей, которое существует в вызывающем объекте <see cref="T:System.Windows.DependencyObject" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В дополнение к явному вызову через вызов <xref:System.Windows.DependencyObject.CoerceValue%2A> <xref:System.Windows.CoerceValueCallback> свойство для свойства зависимостей также вызывается внутренним образом всякий раз, когда значение свойства зависимостей переоценивается [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] системой свойств.  
  
 При вызове <xref:System.Windows.DependencyObject.CoerceValue%2A> метода в конечном итоге вызывается обратный вызов приводимого значения для указанного свойства. Как правило, вызов <xref:System.Windows.DependencyObject.CoerceValue%2A> выполняется только в том случае, если известно, что обратный вызов приводимого значения существует, и если известно, что условия обратного вызова приводятся к приведению.  
  
 Наиболее распространенным сценарием для <xref:System.Windows.DependencyObject.CoerceValue%2A> вызова является обработка класса или обратные вызовы изменения свойств связанных свойств, которые влияют на значения друг друга. Дополнительные сведения см. в разделе [Проверка и обратные вызовы свойства зависимостей](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
   
  
## Examples  
 В следующем примере вызывается <xref:System.Windows.DependencyObject.CoerceValue%2A> <xref:System.Windows.PropertyChangedCallback> в реализации <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> , которая используется в качестве для различных свойств зависимостей в том же классе. Это распространенный шаблон для представления зависимостей значений true между свойствами зависимостей.  
  
 [!code-csharp[DPCallbackOverride#OnPCCurrent](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#onpccurrent)]
 [!code-vb[DPCallbackOverride#OnPCCurrent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#onpccurrent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Указанный параметр <paramref name="dp" /> или его значение недопустимы, или их не существует.</exception>
        <altmember cref="T:System.Windows.CoerceValueCallback" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DependencyObjectType">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObjectType DependencyObjectType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObjectType DependencyObjectType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyObject.DependencyObjectType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DependencyObjectType As DependencyObjectType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObjectType ^ DependencyObjectType { System::Windows::DependencyObjectType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DependencyObjectType : System.Windows.DependencyObjectType" Usage="System.Windows.DependencyObject.DependencyObjectType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObjectType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает <see cref="T:System.Windows.DependencyObjectType" />, который создает обертку для типа [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] данного экземпляра.</summary>
        <value><see cref="T:System.Windows.DependencyObjectType" />, который создает обертку для типа [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] данного экземпляра.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство полезно в том случае, если объект, возвращаемый методом, имеет тип <xref:System.Windows.DependencyObject> возвращаемого значения, и в зависимости от его типа необходимо выполнить определенные операции с системой свойств. Например, более эффективно вызывать <xref:System.Windows.DependencyProperty.GetMetadata%28System.Windows.DependencyObjectType%29> , используя, <xref:System.Windows.DependencyObjectType> а не [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] тип. <xref:System.Windows.DependencyObjectType>ускоряет поиск.  
  
   
  
## Examples  
 В следующем примере `MySubClass` псевдокода предполагается, что дополнительные производные классы могут изменить значение `MyCustom` свойства зависимостей по умолчанию. Класс реализует конструктор без параметров, который может определить фактический производный класс, используя преимущества полиморфизма для <xref:System.Windows.DependencyObjectType> значения всякий раз, когда конструктор используется в качестве экземпляра производного класса.  
  
 `public DOClass() : base()`  
  
 `{`  
  
 `__customPropertyCache = (CustomDP)`  
  
 `CustomDPProperty.GetMetadata(DependencyObjectType).DefaultValue;`  
  
 `}`  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
        <altmember cref="T:System.Windows.DependencyObjectType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override sealed bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="dependencyObject.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><see cref="T:System.Windows.DependencyObject" /> для сравнения с текущим экземпляром.</param>
        <summary>Определяет, является ли указанный <see cref="T:System.Windows.DependencyObject" /> эквивалентом текущего <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns><see langword="true" />, если два экземпляра одинаковы; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта реализация является только ссылочным равенством и не пытается вычислить равенство значений содержащихся в нем свойств.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Windows.DependencyObject" />переопределяет, а затем запечатывает <see cref="T:System.Object" /> два основных <see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /> метода <see cref="M:System.Windows.DependencyObject.GetHashCode" />: и. Переопределения вызывают <see cref="T:System.Object" /> реализации, что приводит к поведению равенства объектов. Назначение этих заменяющих переопределений заключается в предотвращении того, что производные классы не пытаются <see cref="T:System.Windows.DependencyObject" />определить равенство значений для. Значение екуалитиес для <see cref="T:System.Windows.DependencyObject" /> никогда не будет неточным из-за возможностей <see cref="T:System.Windows.DependencyObject" /> изменения значения свойства присущей объекта и его свойств зависимостей. Это включает в [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] себя фундаментальные функции, такие как привязка данных и система свойств.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override sealed int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dependencyObject.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает хэш-код для данного объекта <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>Хэш-код в виде 32-разрядного целого числа со знаком.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Windows.DependencyObject" />переопределяет и затем запечатывает <see cref="T:System.Object" /> два метода <see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /> : <see cref="M:System.Windows.DependencyObject.GetHashCode" />и. Переопределения вызывают <see cref="T:System.Object" /> реализации, что приводит к поведению равенства объектов. Назначение этих заменяющих переопределений заключается в предотвращении того, что производные классы не пытаются <see cref="T:System.Windows.DependencyObject" />определить равенство значений для. Значение екуалитиес для <see cref="T:System.Windows.DependencyObject" /> никогда не будет неточным из-за возможностей <see cref="T:System.Windows.DependencyObject" /> изменения значения свойства присущей объекта и его свойств зависимостей. Это включает в [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] себя фундаментальные функции, такие как привязка данных и система свойств.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetLocalValueEnumerator">
      <MemberSignature Language="C#" Value="public System.Windows.LocalValueEnumerator GetLocalValueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.LocalValueEnumerator GetLocalValueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetLocalValueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLocalValueEnumerator () As LocalValueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::LocalValueEnumerator GetLocalValueEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetLocalValueEnumerator : unit -&gt; System.Windows.LocalValueEnumerator" Usage="dependencyObject.GetLocalValueEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LocalValueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает специализированный перечислитель для определения свойств зависимостей, которые локально установили значения для данного <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>Специализированный перечислитель локальных значений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *Локальное значение* — это любое значение свойства зависимости, установленное <xref:System.Windows.DependencyObject.SetValue%2A>в, в отличие от других аспектов системы свойств.  
  
 Метод, <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> полученный<xref:System.Windows.DependencyObject> путем вызова, может использоваться для перечисления свойств, которые имеют локально заданное значение в экземпляре. <xref:System.Windows.LocalValueEnumerator> Каждое такое свойство представлено в перечислителе <xref:System.Windows.LocalValueEntry> объектом, имеющим свойства, ссылающиеся на определенные <xref:System.Windows.DependencyProperty> и его значения. Этот метод перечисления локально заданных значений можно использовать для оптимизации или для другой обработки локальных значений, например для определения значений свойств, <xref:System.Windows.DependencyObject> которые будут изменены, если они были удалены.  
  
> [!IMPORTANT]
>  Возвращаемые <xref:System.Windows.LocalValueEnumerator> данные могут <xref:System.Windows.LocalValueEntry> содержать записи для свойств зависимостей, доступных только для чтения, или свойства зависимостей, в которых значения рассчитываются системой свойств. Например, элемент Visual Framework с установленной шириной через макет будет сообщать о локальном значении для <xref:System.Windows.FrameworkElement.ActualWidth%2A>. Если вы получаете локальные значения, чтобы сбросить их, проверьте <xref:System.Windows.DependencyProperty.ReadOnly%2A> значение идентификатора свойства каждого <xref:System.Windows.LocalValueEntry> из, чтобы убедиться, что рассматриваемый вопрос не <xref:System.Windows.DependencyProperty> доступен только для чтения.  
  
   
  
## Examples  
 В следующем примере выполняется перебор всех свойств, для которых заданы локальные значения объекта, а затем <xref:System.Windows.DependencyObject.ClearValue%2A> вызывается метод для очистки значений каждого такого свойства.  
  
 [!code-csharp[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/csharp/VS_Snippets_Wpf/DPClearValue/CSharp/default.xaml.cs#iteratelocalvaluesandclear)]
 [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPClearValue/VisualBasic/default.xaml.vb#iteratelocalvaluesandclear)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LocalValueEntry" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetValue : System.Windows.DependencyProperty -&gt; obj" Usage="dependencyObject.GetValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Идентификатор <see cref="T:System.Windows.DependencyProperty" /> свойства, из которого извлекается значение.</param>
        <summary>Возвращает текущее действующее значение свойства зависимостей в этом экземпляре <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>Возвращает текущее действующее значение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *Действующее значение* — это значение свойства, возвращаемое системой свойств любому вызывающему объекту, запрашивающему значение. Действительное значение является результатом системы свойств, которая оценивает все возможные входные данные, участвующие в приоритете значения системы свойств. Сюда входит приведение и анимация. Дополнительные сведения см. в разделе [Приоритет значений свойств зависимостей](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Этот метод никогда не возвращает <xref:System.Windows.DependencyProperty.UnsetValue>. <xref:System.Windows.DependencyProperty.UnsetValue> — Это значение Sentinel для системы свойств, которое используется в различных емкостьх внутренне и иногда также предоставляется посредством обратных вызовов приведения.  
  
 Если вы не уверены, что должен иметь тип свойства, можно запросить идентификатор запрошенного свойства зависимостей, чтобы определить, является ли более конкретное <xref:System.Windows.DependencyProperty.PropertyType%2A> значение, которое может быть преобразовано в.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Указанный параметр <paramref name="dp" /> или его значение были недопустимы, или указанного параметра <paramref name="dp" /> не существует.</exception>
        <altmember cref="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="InvalidateProperty">
      <MemberSignature Language="C#" Value="public void InvalidateProperty (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvalidateProperty(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvalidateProperty (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvalidateProperty(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.InvalidateProperty : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.InvalidateProperty dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Идентификатор <see cref="T:System.Windows.DependencyProperty" /> свойства, которое следует сделать недействительным.</param>
        <summary>Повторно вычисляет действующее значение для указанного свойства зависимостей</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При вызове <xref:System.Windows.DependencyObject.InvalidateProperty%2A>могут быть вызваны все <xref:System.Windows.CoerceValueCallback> связанные <xref:System.Windows.PropertyChangedCallback> и применимые функции или, зарегистрированные для этого свойства зависимостей.  
  
 Вызов <xref:System.Windows.DependencyObject.InvalidateProperty%2A> для свойства, для которого задано локальное значение, не будет действовать, так как локальное значение имеет приоритет над другими входными данными системы свойств, за исключением анимации. Однако можно вызвать <xref:System.Windows.DependencyObject.ClearValue%2A>метод, а затем вызвать <xref:System.Windows.DependencyObject.InvalidateProperty%2A>метод. Дополнительные сведения см. в разделе [Приоритет значений свойств зависимостей](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Вызов <xref:System.Windows.DependencyObject.InvalidateProperty%2A> необязательно применим для многих сценариев свойств зависимостей. Если свойство зависимости станет недействительным из-за изменений значений в любом из составляющих, система свойств сделает недействительным и повторно вычисляет свойство зависимостей автоматически. Однако по-прежнему есть несколько подходящих сценариев <xref:System.Windows.DependencyObject.InvalidateProperty%2A> , где это полезно. В частности, можно использовать <xref:System.Windows.DependencyObject.InvalidateProperty%2A> внутри значения приведения или обратного вызова изменения свойства для другого свойства зависимостей. Также можно использовать <xref:System.Windows.DependencyObject.InvalidateProperty%2A> для принудительной повторной оценки привязки к источнику данных, который не может реализовать рекомендуемый <xref:System.ComponentModel.INotifyPropertyChanged> механизм уведомления (возможно, при использовании классов данных, которые не могут быть производными, или если данные являются статическими элемент).  
  
   
  
## Examples  
 В следующем примере вызывается <xref:System.Windows.DependencyObject.InvalidateProperty%2A> пользовательское свойство, когда изменяются свойства, участвующие в вычислениях недействительного свойства. Это альтернативный метод вызова <xref:System.Windows.DependencyObject.CoerceValue%2A> метода, так как при непроверке свойства также будут вызываться все зарегистрированные. <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>  
  
 [!code-csharp[PropertySystemEsoterics#InvalidateProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/SDKSampleLibrary/class1.cs#invalidateproperty)]
 [!code-vb[PropertySystemEsoterics#InvalidateProperty](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/sdksamplelibrary/class1.vb#invalidateproperty)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.DependencyProperty.UnsetValue" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyObject.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Windows.DependencyObject.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, является ли этот экземпляр в данный момент запечатанным (доступным только для чтения).</summary>
        <value><see langword="true" />, если этот экземпляр запечатан; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это значение задается внутренним образом.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkElementFactory" />
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="dependencyObject.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Данные события, которые содержат интересующий идентификатор свойства зависимости, метаданные свойства для соответствующего типа, а также старое и новое значения.</param>
        <summary>Вызывается каждый раз, когда обновляется действительное значение любого свойства зависимостей для данного <see cref="T:System.Windows.DependencyObject" />. Конкретное свойство зависимости, которое изменилось, сообщается в данных события.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не предназначен для общего обнаружения отдельных изменений свойств или выполнения недействительных свойств для каждого варианта. <xref:System.Windows.DependencyObject.OnPropertyChanged%2A>Вместо этого предназначен для модификации общего шаблона недействительности, если определенная информация известна по широким классификациям свойств. Например, изменения в <xref:System.Windows.Freezable> могут быть внесены в типы значений <xref:System.Windows.Freezable>параметров, или могут быть вложенными свойствами, где изменения находятся в других <xref:System.Windows.Freezable> ссылках. <xref:System.Windows.Freezable> Реализацияпереопределенияиспользуетвнутренниесведения,чтобыопределить,являютсялисвойстваподсвойствами,ипредоставляетсоответствующуюлогикубазовогокласса<xref:System.Windows.DependencyObject.OnPropertyChanged%2A> в любом случае.  
  
 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A>может вызываться много раз в течение жизненного цикла объекта. Таким образом, можно добиться лучшей производительности для общей системы свойств, если переопределить метаданные определенных свойств, а затем присоединить <xref:System.Windows.CoerceValueCallback> функции или <xref:System.Windows.PropertyChangedCallback> к отдельным свойствам. Однако этот метод следует использовать, если <xref:System.Windows.DependencyObject> включает значительное количество свойств зависимостей, взаимосвязанных со значениями, или если оно включает логику, например поведение отрисовки, которая должна быть повторно запущена для нескольких связанных вариантов недопустимых свойств.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Всегда вызывайте базовую реализацию. Невыполнение этого действия приведет к значительному отключению всей [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] системы свойств, что приведет к сообщению о неправильном значении.</para></block>
        <altmember cref="T:System.Windows.FrameworkElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadLocalValue">
      <MemberSignature Language="C#" Value="public object ReadLocalValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object ReadLocalValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLocalValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ ReadLocalValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.ReadLocalValue : System.Windows.DependencyProperty -&gt; obj" Usage="dependencyObject.ReadLocalValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Идентификатор <see cref="T:System.Windows.DependencyProperty" /> свойства, из которого извлекается значение.</param>
        <summary>Возвращает локальное значение свойства зависимостей, если таковое существует.</summary>
        <returns>Возвращает локальное значение, или значение-метку <see cref="F:System.Windows.DependencyProperty.UnsetValue" />, если локальное значение не задано.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для наиболее типичных операций Get для свойства зависимостей следует использовать <xref:System.Windows.DependencyObject.GetValue%2A> . <xref:System.Windows.DependencyObject.ReadLocalValue%2A>не возвращает эффективное значение в ряде случаев, когда значение не было установлено локально.  
  
 Значения, заданные стилями, темами, шаблонами, значениями по умолчанию из метаданных или наследованием значений свойств, не считаются локальными значениями. Однако привязки и другие выражения считаются локальными значениями после их оценки.  
  
 Если локальное значение не задано, этот метод <xref:System.Windows.DependencyProperty.UnsetValue>возвращает.  
  
 Если возвращаемое значение отличается от <xref:System.Windows.DependencyProperty.UnsetValue>, можно запросить метаданные запрошенного свойства зависимости, чтобы определить, существует ли более конкретный тип, в который можно преобразовать возвращаемое значение.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyObject.GetLocalValueEnumerator" />
        <altmember cref="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="SetCurrentValue">
      <MemberSignature Language="C#" Value="public void SetCurrentValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCurrentValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCurrentValue (dp As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCurrentValue(System::Windows::DependencyProperty ^ dp, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetCurrentValue : System.Windows.DependencyProperty * obj -&gt; unit" Usage="dependencyObject.SetCurrentValue (dp, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="value" Type="System.Object" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="dp">Идентификатор задаваемого свойства зависимостей.</param>
        <param name="value">Новое локальное значение.</param>
        <summary>Задает значение свойства зависимостей, не меняя источник значения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется компонентом, который программно задает значение одного из собственных свойств без отключения объявленного в приложении использования свойства. <xref:System.Windows.DependencyObject.SetCurrentValue%2A> Метод изменяет эффективное значение свойства, но существующие триггеры, привязки данных и стили будут продолжать работать.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Попытка изменить доступное только для чтения свойство зависимостей, или свойство в запечатанном <see cref="T:System.Windows.DependencyObject" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> не был корректным типом, зарегистрированным для свойства <paramref name="dp" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Задает локальное значение свойства зависимостей.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (dp As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Windows::DependencyProperty ^ dp, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : System.Windows.DependencyProperty * obj -&gt; unit" Usage="dependencyObject.SetValue (dp, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">Идентификатор задаваемого свойства зависимостей.</param>
        <param name="value">Новое локальное значение.</param>
        <summary>Задает локальное значение свойства зависимостей, указанного идентификатором этого свойства.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если предоставленный тип не соответствует типу, объявленному для свойства зависимостей, как оно было первоначально зарегистрировано, создается исключение. `value` Параметр должен всегда указываться в качестве соответствующего типа.  
  
 На условия исключения могут влиять <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> функции обратного вызова, которые существуют в идентификаторе свойства зависимостей устанавливаемого свойства зависимостей. В противном случае предоставленное значение может привести к сбою общих условий проверки типа (например, передача строки, если собственный тип — Double).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Попытка изменить доступное только для чтения свойство зависимостей, или свойство в запечатанном <see cref="T:System.Windows.DependencyObject" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> не был корректным типом, зарегистрированным для свойства <paramref name="dp" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyPropertyKey key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyPropertyKey key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (key As DependencyPropertyKey, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Windows::DependencyPropertyKey ^ key, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : System.Windows.DependencyPropertyKey * obj -&gt; unit" Usage="dependencyObject.SetValue (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Идентификатор <see cref="T:System.Windows.DependencyPropertyKey" /> задаваемого свойства.</param>
        <param name="value">Новое локальное значение.</param>
        <summary>Задает локальное значение свойства зависимости только для чтения, определяемое идентификатором <see cref="T:System.Windows.DependencyPropertyKey" /> свойства зависимостей.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта сигнатура обычно используется при задании значений для свойств зависимостей, доступных только для чтения и определяемых пользовательскими классами. Как правило <xref:System.Windows.DependencyObject.SetValue%2A> , вызывается только из типа, который зарегистрировал это свойство зависимостей, которое реализует внутреннюю логику, которая предоставляет определенное значение для свойства зависимостей. Дополнительные сведения см. в разделе [Свойства зависимостей "только для чтения"](~/docs/framework/wpf/advanced/read-only-dependency-properties.md).  
  
 Если предоставленный тип не соответствует типу, объявленному для свойства зависимостей, как оно было первоначально зарегистрировано, создается исключение. `value` Параметр должен всегда указываться в качестве соответствующего типа. На условия исключения могут влиять <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> функции обратного вызова, которые существуют в идентификаторе свойства зависимостей устанавливаемого свойства зависимостей.  
  
   
  
## Examples  
 В следующем примере определяется свойство зависимостей, доступное только для чтения, а `public static readonly` также объект <xref:System.Windows.DependencyProperty> , предоставляющий необходимые сведения о доступности для потребителей свойств, а [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] также метод доступа get для оболочки.  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeProperty">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShouldSerializeProperty (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ShouldSerializeProperty(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ShouldSerializeProperty (dp As DependencyProperty) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ShouldSerializeProperty(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeProperty : System.Windows.DependencyProperty -&gt; bool&#xA;override this.ShouldSerializeProperty : System.Windows.DependencyProperty -&gt; bool" Usage="dependencyObject.ShouldSerializeProperty dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Идентификатор для свойства зависимости, которое следует сериализовать.</param>
        <summary>Возвращает значение, которое указывает, следует ли процессам сериализации выполнять сериализацию значения для предоставленного свойства зависимостей.</summary>
        <returns><see langword="true" />, если значение переданного свойства зависимостей следует сериализовать; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию `true` возвращает для всех вариантов, в которых свойство зависимостей имеет локальное значение, <xref:System.Windows.DependencyObject>установленное в.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Переопределения для этого метода могут по-разному управлять определенными свойствами зависимостей.</para></block>
      </Docs>
    </Member>
  </Members>
</Type>