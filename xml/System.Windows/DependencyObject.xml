<Type Name="DependencyObject" FullName="System.Windows.DependencyObject">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6023396816c2ce384f3a4bba180bad7392c9134f" /><Meta Name="ms.sourcegitcommit" Value="c573d537afba2d4c1463538f1095f2f155025464" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="10/16/2019" /><Meta Name="ms.locfileid" Value="72408272" /></Metadata><TypeSignature Language="C#" Value="public class DependencyObject : System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DependencyObject extends System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyObject" />
  <TypeSignature Language="VB.NET" Value="Public Class DependencyObject&#xA;Inherits DispatcherObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyObject : System::Windows::Threading::DispatcherObject" />
  <TypeSignature Language="F#" Value="type DependencyObject = class&#xA;    inherit DispatcherObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.TypeDescriptionProvider(typeof(MS.Internal.ComponentModel.DependencyObjectProvider))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.Windows.Markup.NameScopeProperty("NameScope", typeof(System.Windows.NameScope))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет объект, участвующий в системе свойств зависимостей.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Класс <xref:System.Windows.DependencyObject> позволяет системным службам свойств [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] в различных производных классах.  
  
 Основная функция системы свойств — вычисление значений свойств и предоставление системного уведомления об измененных значениях. Еще один ключевой класс, участвующий в системе свойств, — <xref:System.Windows.DependencyProperty>. <xref:System.Windows.DependencyProperty> включает регистрацию свойств зависимостей в системе свойств, а также предоставляет идентификацию и сведения о каждом свойстве зависимостей, тогда как <xref:System.Windows.DependencyObject> в качестве базового класса позволяет объектам использовать свойства зависимостей.  
  
 к службам и характеристикам <xref:System.Windows.DependencyObject> относятся следующие.  
  
-   Поддержка размещения свойств зависимостей. Свойство зависимости регистрируется путем вызова метода <xref:System.Windows.DependencyProperty.Register%2A> и сохранения возвращаемого значения метода в виде открытого статического поля в классе.  
  
-   Поддержка размещения вложенных свойств. Присоединенные свойства регистрируются путем вызова метода <xref:System.Windows.DependencyProperty.RegisterAttached%2A> и сохранения возвращаемого значения метода в виде открытого статического поля только для чтения в классе. (Существуют также дополнительные требования к членам. Обратите внимание, что это представляет собой конкретную реализацию [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] для присоединенных свойств. Дополнительные сведения см. в разделе [Общие сведения о вложенных свойствах](~/docs/framework/wpf/advanced/attached-properties-overview.md).) Затем присоединенное свойство можно задать для любого класса, производного от <xref:System.Windows.DependencyObject>.  
  
-   Методы Get, Set и Clear для значений всех свойств зависимостей, существующих в <xref:System.Windows.DependencyObject>.  
  
-   Метаданные, поддержка приведения значений, уведомление об изменении свойства и обратные вызовы переопределений для свойств зависимостей или присоединенных свойств. Кроме того, класс <xref:System.Windows.DependencyObject> упрощает метаданные свойств каждого владельца для свойства зависимостей.  
  
-   Общий базовый класс для классов, производных от <xref:System.Windows.ContentElement>, <xref:System.Windows.Freezable> или <xref:System.Windows.Media.Visual>. (<xref:System.Windows.UIElement>, другой класс базового элемента, имеет иерархию классов, которая включает <xref:System.Windows.Media.Visual>).  
  
   
  
## Examples  
 Следующий пример является производным от <xref:System.Windows.DependencyObject> для создания нового абстрактного класса. Затем класс регистрирует присоединенное свойство и включает элементы поддержки для этого присоединенного свойства.  
  
 [!code-csharp[WPFAquariumSln#DOMain](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#domain)]
 [!code-vb[WPFAquariumSln#DOMain](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#domain)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyProperty" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DependencyObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DependencyObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.DependencyObject" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ClearValue">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Очищает локальное значение свойства.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ClearValue">
      <MemberSignature Language="C#" Value="public void ClearValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearValue (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.ClearValue : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.ClearValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Очищаемое свойство зависимости, указанное объектной ссылкой <see cref="T:System.Windows.DependencyProperty" />.</param>
        <summary>Очищает локальное значение свойства. Очищаемое свойство задается идентификатором <see cref="T:System.Windows.DependencyProperty" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Очистка значения свойства путем вызова <xref:System.Windows.DependencyObject.ClearValue%2A> не обязательно дает свойству зависимостей значение по умолчанию, указанное в метаданных свойства зависимостей. Очистка свойства только позволяет очистить любое локальное значение, которое могло быть применено. Дополнительные сведения см. в разделе [Приоритет значений свойств зависимостей](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
   
  
## Examples  
 В следующем примере выполняется перебор всех свойств, для которых заданы локальные значения объекта, затем вызывается <xref:System.Windows.DependencyObject.ClearValue%2A>, чтобы очистить значения каждого из этих свойств.  
  
 [!code-csharp[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/csharp/VS_Snippets_Wpf/DPClearValue/CSharp/default.xaml.cs#iteratelocalvaluesandclear)]
 [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPClearValue/VisualBasic/default.xaml.vb#iteratelocalvaluesandclear)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Предпринята попытка вызова <see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" /> в запечатанном объекте <see cref="T:System.Windows.DependencyObject" />.</exception>
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
        <altmember cref="P:System.Windows.DependencyObject.IsSealed" />
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <Member MemberName="ClearValue">
      <MemberSignature Language="C#" Value="public void ClearValue (System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearValue(class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearValue (key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearValue(System::Windows::DependencyPropertyKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.ClearValue : System.Windows.DependencyPropertyKey -&gt; unit" Usage="dependencyObject.ClearValue key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="key">Ключ для очищаемого свойства зависимостей.</param>
        <summary>Очищает локальное значение свойства, доступного только для чтения. Очищаемое свойство задается ключом <see cref="T:System.Windows.DependencyPropertyKey" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 @No__t-0 определяет свойство зависимостей "только для чтения" для операций системы свойств. Классы, определяющие свойства зависимостей только для чтения, не должны предоставлять этот ключ с доступом Public. Общедоступный ключ будет предоставлять открытый путь к коду, который обращается к символу только для чтения свойства, если такие методы, как <xref:System.Windows.DependencyObject.ClearValue%2A> или <xref:System.Windows.DependencyObject.SetValue%2A>, могут быть вызваны вне класса или сборки, ссылаясь на ключ.  
  
 Очистка значения свойства путем вызова <xref:System.Windows.DependencyObject.ClearValue%2A> не обязательно дает свойству зависимостей значение по умолчанию, указанное в метаданных свойства зависимостей. Очистка значения только позволяет очистить любое локальное значение, которое могло быть применено. Дополнительные сведения см. в разделе [Приоритет значений свойств зависимостей](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Пытается вызвать метод <see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" /> для запечатанного <see cref="T:System.Windows.DependencyObject" />.</exception>
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
        <altmember cref="T:System.Windows.DependencyPropertyKey" />
      </Docs>
    </Member>
    <Member MemberName="CoerceValue">
      <MemberSignature Language="C#" Value="public void CoerceValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CoerceValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CoerceValue (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CoerceValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.CoerceValue : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.CoerceValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Идентификатор приводимого свойства зависимостей.</param>
        <summary>Приводит значение указанного свойства зависимостей. Это осуществляется путем вызова какой-либо функции <see cref="T:System.Windows.CoerceValueCallback" />, указанной в метаданных свойства зависимостей, которое существует в вызывающем объекте <see cref="T:System.Windows.DependencyObject" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В дополнение к явному вызову метода <xref:System.Windows.DependencyObject.CoerceValue%2A> <xref:System.Windows.CoerceValueCallback> для свойства зависимостей также вызывается внутренне при повторной оценке значения свойства зависимостей системой свойств [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)].  
  
 При вызове метода <xref:System.Windows.DependencyObject.CoerceValue%2A> в конечном итоге вызывается обратный вызов приводимого значения для указанного свойства. Обычно <xref:System.Windows.DependencyObject.CoerceValue%2A> вызывается только в том случае, если известно, что обратный вызов приводимого значения существует, и если вы знакомы с критериями обратного вызова для приведения.  
  
 Наиболее распространенным сценарием вызова <xref:System.Windows.DependencyObject.CoerceValue%2A> является обработка класса или обратные вызовы изменения свойств связанных свойств, которые влияют на значения друг друга. Дополнительные сведения см. в разделе [Проверка и обратные вызовы свойства зависимостей](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
   
  
## Examples  
 В следующем примере вызывается <xref:System.Windows.DependencyObject.CoerceValue%2A> в реализации <xref:System.Windows.PropertyChangedCallback>, которая используется в качестве <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> для различных свойств зависимостей в том же классе. Это распространенный шаблон для представления зависимостей значений true между свойствами зависимостей.  
  
 [!code-csharp[DPCallbackOverride#OnPCCurrent](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#onpccurrent)]
 [!code-vb[DPCallbackOverride#OnPCCurrent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#onpccurrent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Указанный параметр <paramref name="dp" /> или его значение недопустимы, или их не существует.</exception>
        <altmember cref="T:System.Windows.CoerceValueCallback" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DependencyObjectType">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObjectType DependencyObjectType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObjectType DependencyObjectType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyObject.DependencyObjectType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DependencyObjectType As DependencyObjectType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObjectType ^ DependencyObjectType { System::Windows::DependencyObjectType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DependencyObjectType : System.Windows.DependencyObjectType" Usage="System.Windows.DependencyObject.DependencyObjectType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObjectType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает <see cref="T:System.Windows.DependencyObjectType" />, который создает обертку для типа [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] данного экземпляра.</summary>
        <value><see cref="T:System.Windows.DependencyObjectType" />, который создает обертку для типа [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] данного экземпляра.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство полезно в том случае, если объект, возвращаемый методом, имеет тип возвращаемого значения <xref:System.Windows.DependencyObject>, и в зависимости от его типа необходимо выполнять операции с системой свойств. Например, более эффективно вызывать <xref:System.Windows.DependencyProperty.GetMetadata%28System.Windows.DependencyObjectType%29>, используя <xref:System.Windows.DependencyObjectType>, а не тип [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]. <xref:System.Windows.DependencyObjectType> упрощает поиск.  
  
   
  
## Examples  
 В следующем примере псевдокода `MySubClass` предполагает, что дополнительные производные классы могут изменить значение по умолчанию свойства зависимостей `MyCustom`. Класс реализует конструктор без параметров, который может определить фактический производный класс, используя преимущества полиморфизма для значения <xref:System.Windows.DependencyObjectType> всякий раз, когда конструктор используется в качестве экземпляра производного класса.  
  
 `public DOClass() : base()`  
  
 `{`  
  
 `__customPropertyCache = (CustomDP)`  
  
 `CustomDPProperty.GetMetadata(DependencyObjectType).DefaultValue;`  
  
 `}`  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
        <altmember cref="T:System.Windows.DependencyObjectType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override sealed bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="dependencyObject.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><see cref="T:System.Windows.DependencyObject" /> для сравнения с текущим экземпляром.</param>
        <summary>Определяет, является ли указанный <see cref="T:System.Windows.DependencyObject" /> эквивалентом текущего <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns><see langword="true" />, если два экземпляра одинаковы; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта реализация является только ссылочным равенством и не пытается вычислить равенство значений содержащихся в нем свойств.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Windows.DependencyObject" /> переопределяет, а затем запечатывает два основных метода <see cref="T:System.Object" />: <see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /> и <see cref="M:System.Windows.DependencyObject.GetHashCode" />. Переопределения вызывают реализацию <see cref="T:System.Object" />, что приводит к поведению равенства объектов. Назначение этих заменяющих переопределений заключается в предотвращении того, что производные классы не пытаются определить равенство значений для <see cref="T:System.Windows.DependencyObject" />. Значение екуалитиес для <see cref="T:System.Windows.DependencyObject" /> никогда не будет неточным из-за возможности изменения значения свойства присущей <see cref="T:System.Windows.DependencyObject" /> и его свойств зависимостей. Сюда входят фундаментальные функции [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], такие как привязка данных и система свойств [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)].</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override sealed int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dependencyObject.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает хэш-код для данного объекта <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>Подписанный хэш-код в виде 32-разрядного целого числа.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Windows.DependencyObject" /> переопределяет, а затем запечатывает два метода <see cref="T:System.Object" />: <see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /> и <see cref="M:System.Windows.DependencyObject.GetHashCode" />. Переопределения вызывают реализацию <see cref="T:System.Object" />, что приводит к поведению равенства объектов. Назначение этих заменяющих переопределений заключается в предотвращении того, что производные классы не пытаются определить равенство значений для <see cref="T:System.Windows.DependencyObject" />. Значение екуалитиес для <see cref="T:System.Windows.DependencyObject" /> никогда не будет неточным из-за возможности изменения значения свойства присущей <see cref="T:System.Windows.DependencyObject" /> и его свойств зависимостей. Сюда входят фундаментальные функции [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], такие как привязка данных и система свойств [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)].</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetLocalValueEnumerator">
      <MemberSignature Language="C#" Value="public System.Windows.LocalValueEnumerator GetLocalValueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.LocalValueEnumerator GetLocalValueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetLocalValueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLocalValueEnumerator () As LocalValueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::LocalValueEnumerator GetLocalValueEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetLocalValueEnumerator : unit -&gt; System.Windows.LocalValueEnumerator" Usage="dependencyObject.GetLocalValueEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LocalValueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает специализированный перечислитель для определения свойств зависимостей, которые локально установили значения для данного <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>Специализированный перечислитель локальных значений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *Локальное значение* — это любое значение свойства зависимости, заданное <xref:System.Windows.DependencyObject.SetValue%2A>, в отличие от других аспектов системы свойств.  
  
 @No__t-0, полученный путем вызова <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A>, можно использовать для перечисления свойств, которые имеют локально заданное значение в экземпляре <xref:System.Windows.DependencyObject>. Каждое такое свойство представлено в перечислителе объектом <xref:System.Windows.LocalValueEntry>, который имеет свойства, ссылающиеся на конкретный <xref:System.Windows.DependencyProperty> и его значения. Этот метод перечисления локально заданных значений можно использовать для оптимизации или для других способов обработки локальных значений, например для определения значений свойств <xref:System.Windows.DependencyObject>, если они были удалены.  
  
> [!IMPORTANT]
>  Возвращаемый <xref:System.Windows.LocalValueEnumerator> может содержать записи <xref:System.Windows.LocalValueEntry> для свойств зависимостей, доступных только для чтения, или свойств зависимостей, где значения рассчитываются системой свойств. Например, элемент Visual Framework с установленной шириной через макет будет сообщать о локальном значении для <xref:System.Windows.FrameworkElement.ActualWidth%2A>. Если вы получаете локальные значения, чтобы сбросить их, проверьте значение <xref:System.Windows.DependencyProperty.ReadOnly%2A> для идентификатора свойства каждого <xref:System.Windows.LocalValueEntry>, чтобы убедиться, что элемент <xref:System.Windows.DependencyProperty> в вопросе не доступен только для чтения.  
  
   
  
## Examples  
 В следующем примере выполняется перебор всех свойств, для которых заданы локальные значения объекта, затем вызывается <xref:System.Windows.DependencyObject.ClearValue%2A>, чтобы очистить значения каждого из этих свойств.  
  
 [!code-csharp[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/csharp/VS_Snippets_Wpf/DPClearValue/CSharp/default.xaml.cs#iteratelocalvaluesandclear)]
 [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPClearValue/VisualBasic/default.xaml.vb#iteratelocalvaluesandclear)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LocalValueEntry" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetValue : System.Windows.DependencyProperty -&gt; obj" Usage="dependencyObject.GetValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Идентификатор <see cref="T:System.Windows.DependencyProperty" /> свойства, значение которого требуется извлечь.</param>
        <summary>Возвращает текущее действующее значение свойства зависимостей в этом экземпляре <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>Возвращает текущее действующее значение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *Действующее значение* — это значение свойства, возвращаемое системой свойств любому вызывающему объекту, запрашивающему значение. Действительное значение является результатом системы свойств, которая оценивает все возможные входные данные, участвующие в приоритете значения системы свойств. Сюда входит приведение и анимация. Дополнительные сведения см. в разделе [Приоритет значений свойств зависимостей](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Этот метод никогда не возвращает <xref:System.Windows.DependencyProperty.UnsetValue>. @No__t-0 — это значение Sentinel для системы свойств, которое используется в различных емкостьх внутренне, а иногда также предоставляется через обратные вызовы приведения.  
  
 Если вы не уверены, что должен иметь тип свойства, можно запросить идентификатор запрошенного свойства зависимостей, чтобы определить, имеется ли более конкретное <xref:System.Windows.DependencyProperty.PropertyType%2A>, что возвращаемое значение может быть преобразовано в.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Указанный параметр <paramref name="dp" /> был недопустим, или его значение было недопустимо, или указанный <paramref name="dp" /> не существует.</exception>
        <altmember cref="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="InvalidateProperty">
      <MemberSignature Language="C#" Value="public void InvalidateProperty (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvalidateProperty(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvalidateProperty (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvalidateProperty(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.InvalidateProperty : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.InvalidateProperty dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Идентификатор <see cref="T:System.Windows.DependencyProperty" /> свойства, которое следует сделать недействительным.</param>
        <summary>Повторно вычисляет действующее значение для указанного свойства зависимостей.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При вызове <xref:System.Windows.DependencyObject.InvalidateProperty%2A> все связанные и применимые функции <xref:System.Windows.CoerceValueCallback> или <xref:System.Windows.PropertyChangedCallback>, зарегистрированные для этого свойства зависимостей, могут быть вызваны.  
  
 Вызов <xref:System.Windows.DependencyObject.InvalidateProperty%2A> для свойства с установленным локальным значением не будет действовать, так как локальное значение имеет приоритет над другими входными данными системы свойств, за исключением анимации. Однако можно вызвать <xref:System.Windows.DependencyObject.ClearValue%2A>, а затем вызвать <xref:System.Windows.DependencyObject.InvalidateProperty%2A>. Дополнительные сведения см. в разделе [Приоритет значений свойств зависимостей](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Вызов <xref:System.Windows.DependencyObject.InvalidateProperty%2A> необязательно применим для многих сценариев свойств зависимостей. Если свойство зависимости станет недействительным из-за изменений значений в любом из составляющих, система свойств сделает недействительным и повторно вычисляет свойство зависимостей автоматически. Однако по-прежнему существуют некоторые подходящие сценарии, в которых <xref:System.Windows.DependencyObject.InvalidateProperty%2A> полезен. В частности, можно использовать <xref:System.Windows.DependencyObject.InvalidateProperty%2A> в приведенном значении или обратном вызове изменения свойства для другого свойства зависимостей. Можно также использовать <xref:System.Windows.DependencyObject.InvalidateProperty%2A> для принудительной повторной оценки привязки к источнику данных, который не может реализовать рекомендуемый механизм уведомления <xref:System.ComponentModel.INotifyPropertyChanged> (возможно, при использовании классов данных, которые не могут быть производными, или если данные являются статическими элементами).  
  
   
  
## Examples  
 В следующем примере вызывается <xref:System.Windows.DependencyObject.InvalidateProperty%2A> для настраиваемого свойства, когда изменяются свойства, участвующие в вычислениях недействительного свойства. Это альтернативный метод вызова метода <xref:System.Windows.DependencyObject.CoerceValue%2A>, так как при непроверке свойства также будет вызван любой зарегистрированный <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>.  
  
 [!code-csharp[PropertySystemEsoterics#InvalidateProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/SDKSampleLibrary/class1.cs#invalidateproperty)]
 [!code-vb[PropertySystemEsoterics#InvalidateProperty](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/sdksamplelibrary/class1.vb#invalidateproperty)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.DependencyProperty.UnsetValue" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyObject.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Windows.DependencyObject.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, является ли этот экземпляр в данный момент запечатанным (доступным только для чтения).</summary>
        <value><see langword="true" />, если этот экземпляр запечатан; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это значение задается внутренним образом.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkElementFactory" />
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="dependencyObject.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Данные события, в которых будет содержаться интересующий идентификатор свойства зависимостей, метаданные свойства для типа, а также старое и новое значения.</param>
        <summary>Вызывается каждый раз, когда обновляется действительное значение любого свойства зависимостей для данного <see cref="T:System.Windows.DependencyObject" />. Конкретное измененное свойство зависимостей сообщается в данных события.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не предназначен для общего обнаружения отдельных изменений свойств или выполнения недействительных свойств для каждого варианта. <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> вместо этого предназначены для изменения шаблона недействительности, если определенная информация известна по широким классификациям свойств. Например, изменения в <xref:System.Windows.Freezable> могут быть внесены в типы значений <xref:System.Windows.Freezable> или подсвойства, где изменения находятся в других ссылках <xref:System.Windows.Freezable>. Реализация переопределения <xref:System.Windows.Freezable> для <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> использует внутреннюю информацию, чтобы определить, являются ли свойства подсвойствами, и предоставляет соответствующую логику базового класса в любом случае.  
  
 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> потенциально вызывается много раз во время жизни объекта. Таким образом, можно добиться лучшей производительности для общей системы свойств, если переопределить метаданные определенных свойств, а затем присоединить функции <xref:System.Windows.CoerceValueCallback> или <xref:System.Windows.PropertyChangedCallback> для отдельных свойств. Однако этот метод следует использовать, если <xref:System.Windows.DependencyObject> включает значительное количество свойств зависимостей, связанных со значением, или если оно включает логику, например поведение отрисовки, которая должна быть повторно запущена для нескольких связанных вариантов недопустимых свойств.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Всегда вызывайте базовую реализацию. Невыполнение этого действия приведет к значительному отключению всей системы свойств [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], что приводит к сообщению о неправильном значении.</para></block>
        <altmember cref="T:System.Windows.FrameworkElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadLocalValue">
      <MemberSignature Language="C#" Value="public object ReadLocalValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object ReadLocalValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLocalValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ ReadLocalValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.ReadLocalValue : System.Windows.DependencyProperty -&gt; obj" Usage="dependencyObject.ReadLocalValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Идентификатор <see cref="T:System.Windows.DependencyProperty" /> свойства, значение которого требуется извлечь.</param>
        <summary>Возвращает локальное значение свойства зависимостей, если таковое существует.</summary>
        <returns>Возвращает локальное значение или значение-метку <see cref="F:System.Windows.DependencyProperty.UnsetValue" />, если локальное значение не задано.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для наиболее типичных операций "Get" для свойства зависимостей следует использовать <xref:System.Windows.DependencyObject.GetValue%2A>. <xref:System.Windows.DependencyObject.ReadLocalValue%2A> не возвращает действующее значение в ряде случаев, когда значение не было установлено локально.  
  
 Значения, заданные стилями, темами, шаблонами, значениями по умолчанию из метаданных или наследованием значений свойств, не считаются локальными значениями. Однако привязки и другие выражения считаются локальными значениями после их оценки.  
  
 Если локальное значение не задано, этот метод возвращает <xref:System.Windows.DependencyProperty.UnsetValue>.  
  
 Если возвращаемое значение отличается от <xref:System.Windows.DependencyProperty.UnsetValue>, можно запросить метаданные запрошенного свойства зависимости, чтобы определить, существует ли более конкретный тип, в который можно преобразовать возвращаемое значение.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyObject.GetLocalValueEnumerator" />
        <altmember cref="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="SetCurrentValue">
      <MemberSignature Language="C#" Value="public void SetCurrentValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCurrentValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCurrentValue (dp As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCurrentValue(System::Windows::DependencyProperty ^ dp, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetCurrentValue : System.Windows.DependencyProperty * obj -&gt; unit" Usage="dependencyObject.SetCurrentValue (dp, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="value" Type="System.Object" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="dp">Идентификатор задаваемого свойства зависимостей.</param>
        <param name="value">Новое локальное значение.</param>
        <summary>Задает значение свойства зависимостей, не меняя источник значения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется компонентом, который программно задает значение одного из собственных свойств без отключения объявленного в приложении использования свойства. Метод <xref:System.Windows.DependencyObject.SetCurrentValue%2A> изменяет эффективное значение свойства, но существующие триггеры, привязки данных и стили будут продолжать работать.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Предпринята попытка изменить доступное только для чтения свойство зависимостей или свойство запечатанного объекта <see cref="T:System.Windows.DependencyObject" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> не является правильным типом, зарегистрированным для свойства <paramref name="dp" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Задает локальное значение свойства зависимостей.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (dp As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Windows::DependencyProperty ^ dp, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : System.Windows.DependencyProperty * obj -&gt; unit" Usage="dependencyObject.SetValue (dp, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">Идентификатор задаваемого свойства зависимостей.</param>
        <param name="value">Новое локальное значение.</param>
        <summary>Задает локальное значение свойства зависимостей, указанного идентификатором этого свойства.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если предоставленный тип не соответствует типу, объявленному для свойства зависимостей, как оно было первоначально зарегистрировано, создается исключение. Параметр `value` всегда должен быть указан в качестве соответствующего типа.  
  
 На условия исключения потенциально влияет обратный вызов <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A>, который существует в идентификаторе свойства зависимостей устанавливаемого свойства зависимостей. В противном случае предоставленное значение может привести к сбою общих условий проверки типа (например, передача строки, если собственный тип — Double).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Предпринята попытка изменить доступное только для чтения свойство зависимостей или свойство запечатанного объекта <see cref="T:System.Windows.DependencyObject" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> не был корректным типом, зарегистрированным для свойства <paramref name="dp" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyPropertyKey key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyPropertyKey key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (key As DependencyPropertyKey, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Windows::DependencyPropertyKey ^ key, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : System.Windows.DependencyPropertyKey * obj -&gt; unit" Usage="dependencyObject.SetValue (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Идентификатор <see cref="T:System.Windows.DependencyPropertyKey" /> задаваемого свойства.</param>
        <param name="value">Новое локальное значение.</param>
        <summary>Задает локальное значение свойства зависимости только для чтения, определяемое идентификатором <see cref="T:System.Windows.DependencyPropertyKey" /> свойства зависимостей.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта сигнатура обычно используется при задании значений для свойств зависимостей, доступных только для чтения и определяемых пользовательскими классами. Как правило, <xref:System.Windows.DependencyObject.SetValue%2A> вызывается только из типа, который зарегистрировал это свойство зависимостей, которое реализует внутреннюю логику, которая предоставляет определенное значение для свойства зависимостей. Дополнительные сведения см. в разделе [Свойства зависимостей "только для чтения"](~/docs/framework/wpf/advanced/read-only-dependency-properties.md).  
  
 Если предоставленный тип не соответствует типу, объявленному для свойства зависимостей, как оно было первоначально зарегистрировано, создается исключение. Параметр `value` всегда должен быть указан в качестве соответствующего типа. На условия исключения потенциально влияет обратный вызов <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A>, который существует в идентификаторе свойства зависимостей устанавливаемого свойства зависимостей.  
  
   
  
## Examples  
 В следующем примере определяется свойство зависимостей, доступное только для чтения, а также `public static readonly` <xref:System.Windows.DependencyProperty>, которое обеспечивает необходимую доступность только для чтения для потребителей свойств и метод доступа get для оболочки [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)].  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeProperty">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShouldSerializeProperty (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ShouldSerializeProperty(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ShouldSerializeProperty (dp As DependencyProperty) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ShouldSerializeProperty(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeProperty : System.Windows.DependencyProperty -&gt; bool&#xA;override this.ShouldSerializeProperty : System.Windows.DependencyProperty -&gt; bool" Usage="dependencyObject.ShouldSerializeProperty dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Идентификатор для сериализуемого свойства зависимостей.</param>
        <summary>Возвращает значение, которое указывает, следует ли процессам сериализации выполнять сериализацию значения для предоставленного свойства зависимостей.</summary>
        <returns>Значение <see langword="true" />, если значение предоставленного свойства зависимостей необходимо сериализовать; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию возвращает `true` для всех случаев, когда свойство зависимостей имеет локальное значение, установленное в <xref:System.Windows.DependencyObject>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Переопределения для этого метода могут по-разному управлять определенными свойствами зависимостей.</para></block>
      </Docs>
    </Member>
  </Members>
</Type>
