<Type Name="PropertyMetadata" FullName="System.Windows.PropertyMetadata">
  <Metadata><Meta Name="ms.openlocfilehash" Value="cfaa68a67cd83c15d520906814bae974a118e88e" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69444310" /></Metadata><TypeSignature Language="C#" Value="public class PropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit PropertyMetadata extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.PropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class PropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class PropertyMetadata" />
  <TypeSignature Language="F#" Value="type PropertyMetadata = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="3b7e1-101">Определяет некоторые аспекты поведения свойства зависимостей применительно к определенному типу, включая условия, в которых оно было зарегистрировано.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-101">Defines certain behavior aspects of a dependency property as it is applied to a specific type, including conditions it was registered with.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3b7e1-102">Метаданные свойства могут быть определены и использованы во время регистрации свойства зависимости при вызове <xref:System.Windows.DependencyProperty.Register%2A> метода (или для присоединенных свойств или свойств зависимостей только для чтения) или после регистрации исходного владельца при вызове <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-102">Property metadata can be defined and used during dependency property registration when calling the <xref:System.Windows.DependencyProperty.Register%2A> method (or variations for attached properties or read-only dependency properties), or after original owner registration when calling the <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> method.</span></span> <span data-ttu-id="3b7e1-103"><xref:System.Windows.DependencyProperty.AddOwner%2A>также принимает метаданные свойства.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-103"><xref:System.Windows.DependencyProperty.AddOwner%2A> also takes property metadata.</span></span>  
  
 <span data-ttu-id="3b7e1-104">Этот класс является конкретным базовым классом, который можно использовать в каждом из этих вызовов.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-104">This class is a concrete base class that can be used in each of these calls.</span></span> <span data-ttu-id="3b7e1-105">Однако очень часто указывать метаданные можно с помощью одного из производных классов, таких как <xref:System.Windows.FrameworkPropertyMetadata>.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-105">However, it is very common to specify metadata using one of the derived classes such as <xref:System.Windows.FrameworkPropertyMetadata>.</span></span> <span data-ttu-id="3b7e1-106">Эти производные классы поддерживают более подробные метаданные, передаваемые в качестве значений логических свойств, которые полезны для обнаружения или включения некоторых поведений системы свойств и макета, реализованных только [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] на уровне платформы.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-106">These derived classes support more detailed metadata carried as Boolean property values, which are useful for either detecting or enabling some property system and layout behaviors that are only implemented at the [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] framework level.</span></span>  
  
 <span data-ttu-id="3b7e1-107">Некоторые свойства этого класса доступны для чтения и записи в объектную модель, но могут быть записаны только до экземпляра, используемого в операции системы свойств, например <xref:System.Windows.DependencyProperty.Register%2A> или. <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A></span><span class="sxs-lookup"><span data-stu-id="3b7e1-107">Several properties of this class are read-write to the object model, but can only be written prior to the instance being used in a property system operation such as <xref:System.Windows.DependencyProperty.Register%2A> or <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A>.</span></span> <span data-ttu-id="3b7e1-108">Каждое из этих свойств также может быть задано конструктором, но предоставлены таким образом <xref:System.Windows.PropertyMetadata.Merge%2A> , чтобы реализации метода могли их задавать.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-108">Each of these properties could also have been set by the constructor but are exposed so that <xref:System.Windows.PropertyMetadata.Merge%2A> method implementations can set them.</span></span>  
  
<a name="xamlTextUsage_PropertyMetadata"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="3b7e1-109">Использование текста XAML</span><span class="sxs-lookup"><span data-stu-id="3b7e1-109">XAML Text Usage</span></span>  
 <span data-ttu-id="3b7e1-110">Этот тип и члены этого типа обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="3b7e1-110">This type, and members of this type, are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3b7e1-111">Инициализирует новый экземпляр класса <see cref="T:System.Windows.PropertyMetadata" />.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-111">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3b7e1-112">Инициализирует новый экземпляр класса <see cref="T:System.Windows.PropertyMetadata" />.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-112">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata defaultValue" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue"><span data-ttu-id="3b7e1-113">Как правило, значение по умолчанию, указанное для свойства зависимостей, представляет собой значение определенного типа.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-113">The default value to specify for a dependency property, usually provided as a value of some specific type.</span></span></param>
        <summary><span data-ttu-id="3b7e1-114">Инициализирует новый экземпляр класса <see cref="T:System.Windows.PropertyMetadata" /> с указанным значением по умолчанию для свойства зависимостей, к которому будут применены метаданные.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-114">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class with a specified default value for the dependency property that this metadata will be applied to.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3b7e1-115">Тип значения, предоставленного для `defaultValue` , должен быть соответствующим или связан с типом, заданным в исходной регистрации свойства зависимостей, к которому будут применяться эти метаданные.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-115">The type of the value provided for `defaultValue` must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="3b7e1-116">Несоответствие между типом значения метаданных по умолчанию и типом свойства зависимостей, к которому он применяется, может быть затруднено в отладке, поскольку несоответствие не обнаруживается во время компиляции (несоответствие вызывает исключение времени выполнения).</span><span class="sxs-lookup"><span data-stu-id="3b7e1-116">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</span></span>  
  
 <span data-ttu-id="3b7e1-117">Хотя это значение по умолчанию для конструктора без параметров, `defaultValue` аргумент типа <xref:System.Windows.DependencyProperty.UnsetValue> не может быть указан.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-117">Although it is the default per the parameterless constructor, a `defaultValue` of <xref:System.Windows.DependencyProperty.UnsetValue> cannot be specified.</span></span> <span data-ttu-id="3b7e1-118">Попытка сделать это вызовет исключение.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-118">Attempting to do so will raise an exception.</span></span>  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3b7e1-119"><paramref name="defaultValue" /> не может иметь значение <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-119"><paramref name="defaultValue" /> cannot be set to the value <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : System.Windows.PropertyChangedCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata propertyChangedCallback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback"><span data-ttu-id="3b7e1-120">Ссылка на реализацию обработчика вызывается системой управления свойствами при каждом изменении значения свойства.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-120">Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</span></span></param>
        <summary><span data-ttu-id="3b7e1-121">Инициализирует новый экземпляр класса <see cref="T:System.Windows.PropertyMetadata" /> с указанной ссылкой реализации <see cref="T:System.Windows.PropertyChangedCallback" />.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-121">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class with the specified <see cref="T:System.Windows.PropertyChangedCallback" /> implementation reference.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj * System.Windows.PropertyChangedCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata (defaultValue, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue"><span data-ttu-id="3b7e1-122">Как правило, значение по умолчанию свойства зависимостей представляет собой значение определенного типа.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-122">The default value of the dependency property, usually provided as a value of some specific type.</span></span></param>
        <param name="propertyChangedCallback"><span data-ttu-id="3b7e1-123">Ссылка на реализацию обработчика вызывается системой управления свойствами при каждом изменении значения свойства.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-123">Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</span></span></param>
        <summary><span data-ttu-id="3b7e1-124">Инициализирует новый экземпляр класса <see cref="T:System.Windows.PropertyMetadata" /> с указанным значением по умолчанию и ссылкой на реализацию <see cref="T:System.Windows.PropertyChangedCallback" />.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-124">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class with the specified default value and <see cref="T:System.Windows.PropertyChangedCallback" /> implementation reference.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3b7e1-125">Тип предоставленного `defaultValue` значения должен совпадать с типом, указанным в исходной регистрации свойства зависимостей, к которому будут применяться эти метаданные, или быть связанным с ним.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-125">The type of the value provided `defaultValue` must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="3b7e1-126">Несоответствие между типом значения метаданных по умолчанию и типом свойства зависимостей, к которому он применяется, может быть затруднено в отладке, поскольку несоответствие не обнаруживается во время компиляции (несоответствие вызывает исключение времени выполнения).</span><span class="sxs-lookup"><span data-stu-id="3b7e1-126">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</span></span>  
  
 <span data-ttu-id="3b7e1-127">Хотя это значение по умолчанию для конструктора без параметров, `defaultValue` аргумент типа <xref:System.Windows.DependencyProperty.UnsetValue> не может быть указан.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-127">Although it is the default per the parameterless constructor, a `defaultValue` of <xref:System.Windows.DependencyProperty.UnsetValue> cannot be specified.</span></span> <span data-ttu-id="3b7e1-128">Попытка сделать это вызовет исключение.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-128">Attempting to do so will raise an exception.</span></span>  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3b7e1-129"><paramref name="defaultValue" /> не может иметь значение <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-129"><paramref name="defaultValue" /> cannot be set to the value <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata (defaultValue, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue"><span data-ttu-id="3b7e1-130">Как правило, значение по умолчанию свойства зависимостей представляет собой значение определенного типа.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-130">The default value of the dependency property, usually provided as a value of some specific type.</span></span></param>
        <param name="propertyChangedCallback"><span data-ttu-id="3b7e1-131">Ссылка на реализацию обработчика вызывается системой управления свойствами при каждом изменении значения свойства.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-131">Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</span></span></param>
        <param name="coerceValueCallback"><span data-ttu-id="3b7e1-132">Ссылка на реализацию обработчика вызывается системой управления свойствами при каждом вызове <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> против данного свойства.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-132">Reference to a handler implementation that is to be called whenever the property system calls <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> against this property.</span></span></param>
        <summary><span data-ttu-id="3b7e1-133">Инициализирует новый экземпляр <see cref="T:System.Windows.PropertyMetadata" /> класса с заданными значением по умолчанию и ответами.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-133">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class with the specified default value and callbacks.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3b7e1-134">Если <xref:System.Windows.CoerceValueCallback> необходимо указать <xref:System.Windows.PropertyChangedCallback>, но не, можно передать `null` параметру значение `propertyChangedCallback` .</span><span class="sxs-lookup"><span data-stu-id="3b7e1-134">If you want to specify a <xref:System.Windows.CoerceValueCallback> but not a <xref:System.Windows.PropertyChangedCallback>, you can pass `null` for the `propertyChangedCallback` parameter.</span></span>  
  
 <span data-ttu-id="3b7e1-135">Тип значения, предоставленного для `defaultValue` , должен быть соответствующим или связан с типом, заданным в исходной регистрации свойства зависимостей, к которому будут применяться эти метаданные.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-135">The type of the value provided for `defaultValue` must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="3b7e1-136">Несоответствие между типом значения метаданных по умолчанию и типом свойства зависимостей, к которому он применяется, может быть затруднено в отладке, поскольку несоответствие не обнаруживается во время компиляции (несоответствие вызывает исключение времени выполнения).</span><span class="sxs-lookup"><span data-stu-id="3b7e1-136">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</span></span>  
  
 <span data-ttu-id="3b7e1-137">Хотя это значение по умолчанию для конструктора без параметров, `defaultValue` аргумент типа <xref:System.Windows.DependencyProperty.UnsetValue> не может быть указан.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-137">Although it is the default per the parameterless constructor, a `defaultValue` of <xref:System.Windows.DependencyProperty.UnsetValue> cannot be specified.</span></span> <span data-ttu-id="3b7e1-138">Попытка сделать это вызовет исключение.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-138">Attempting to do so will raise an exception.</span></span>  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3b7e1-139"><paramref name="defaultValue" /> не может иметь значение <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-139"><paramref name="defaultValue" /> cannot be set to the value <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CoerceValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.CoerceValueCallback CoerceValueCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.CoerceValueCallback CoerceValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.CoerceValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property CoerceValueCallback As CoerceValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::CoerceValueCallback ^ CoerceValueCallback { System::Windows::CoerceValueCallback ^ get(); void set(System::Windows::CoerceValueCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CoerceValueCallback : System.Windows.CoerceValueCallback with get, set" Usage="System.Windows.PropertyMetadata.CoerceValueCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.CoerceValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3b7e1-140">Возвращает или задает ссылку на реализацию <see cref="T:System.Windows.CoerceValueCallback" /> указанную в этих метаданных.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-140">Gets or sets a reference to a <see cref="T:System.Windows.CoerceValueCallback" /> implementation specified in this metadata.</span></span></summary>
        <value><span data-ttu-id="3b7e1-141">Ссылка реализации <see cref="T:System.Windows.CoerceValueCallback" />.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-141">A <see cref="T:System.Windows.CoerceValueCallback" /> implementation reference.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3b7e1-142">Обратные вызовы в метаданных свойств обычно не являются открытыми членами в содержащем типе, поэтому значение этого свойства не имеет значения для большинства сценариев, которые просто используют существующие метаданные свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-142">The callbacks in property metadata are not typically public members on the containing type, so the value of this property is not important for most scenarios that just consume an existing dependency property's metadata.</span></span> <span data-ttu-id="3b7e1-143">Одна из причин, по которой это свойство предоставляется, заключается в <xref:System.Windows.CoerceValueCallback>том, что подклассы метаданных могут выполнять необходимую логику слияния, если базовые метаданные и переопределение/Добавление метаданных указывают.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-143">One reason this property is exposed is so that metadata subclasses can perform their desired merge logic if both base metadata and overriding/adding metadata specify a <xref:System.Windows.CoerceValueCallback>.</span></span> <span data-ttu-id="3b7e1-144">Однако логика слияния по умолчанию для <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> может заменить предыдущую.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-144">However, the default merge logic for a <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> is to replace the previous one.</span></span>  
  
 <span data-ttu-id="3b7e1-145"><xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>определяется в объектной модели как доступная для чтения и записи.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-145"><xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> is defined in the object model as read-write.</span></span> <span data-ttu-id="3b7e1-146">Это можно изменить после инициализации <xref:System.Windows.PropertyMetadata> самого объекта. <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A></span><span class="sxs-lookup"><span data-stu-id="3b7e1-146">This is so <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> can be adjusted after initialization of the <xref:System.Windows.PropertyMetadata> object itself.</span></span> <span data-ttu-id="3b7e1-147">Однако после того, как метаданные будут использоваться в процессе вызова метода <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, система свойств зазапечатана, что экземпляр метаданных и свойства теперь считаются неизменяемыми.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-147">However, once the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and the properties are now considered immutable.</span></span> <span data-ttu-id="3b7e1-148">Попытка задать <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> <xref:System.Windows.PropertyMetadata.IsSealed%2A>одинраз вэтомэкземпляреметаданныхвызоветисключение.`true`</span><span class="sxs-lookup"><span data-stu-id="3b7e1-148">Attempting to set <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> once <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3b7e1-149">Невозможно задать свойство метаданных после того, как оно применено к ориентации свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-149">Cannot set a metadata property once it is applied to a dependency property operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultValue">
      <MemberSignature Language="C#" Value="public object DefaultValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultValue" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.DefaultValue" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultValue As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DefaultValue { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultValue : obj with get, set" Usage="System.Windows.PropertyMetadata.DefaultValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3b7e1-150">Возвращает или задает значение по умолчанию свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-150">Gets or sets the default value of the dependency property.</span></span></summary>
        <value><span data-ttu-id="3b7e1-151">Значение свойства по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-151">The default value of the property.</span></span> <span data-ttu-id="3b7e1-152">Значением по умолчанию для <see cref="T:System.Windows.PropertyMetadata" /> экземпляра, созданного с помощью конструктора без параметров <see cref="F:System.Windows.DependencyProperty.UnsetValue" />, будет.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-152">The default value on a <see cref="T:System.Windows.PropertyMetadata" /> instance created with the parameterless constructor will be <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3b7e1-153"><xref:System.Windows.PropertyMetadata.DefaultValue%2A>определяется в объектной модели как доступная для чтения и записи.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-153"><xref:System.Windows.PropertyMetadata.DefaultValue%2A> is defined in the object model as read-write.</span></span> <span data-ttu-id="3b7e1-154">Это можно изменить после инициализации <xref:System.Windows.PropertyMetadata> самого объекта. <xref:System.Windows.PropertyMetadata.DefaultValue%2A></span><span class="sxs-lookup"><span data-stu-id="3b7e1-154">This is so <xref:System.Windows.PropertyMetadata.DefaultValue%2A> can be adjusted after initialization of the <xref:System.Windows.PropertyMetadata> object itself.</span></span> <span data-ttu-id="3b7e1-155">Однако после того, как метаданные будут использоваться в процессе вызова метода <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, система свойств зазапечатана, что экземпляр метаданных и свойства теперь считаются неизменяемыми.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-155">However, once the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and the properties are now considered immutable.</span></span> <span data-ttu-id="3b7e1-156">Попытка задать <xref:System.Windows.PropertyMetadata.DefaultValue%2A> <xref:System.Windows.PropertyMetadata.IsSealed%2A>одинраз вэтомэкземпляреметаданныхвызоветисключение.`true`</span><span class="sxs-lookup"><span data-stu-id="3b7e1-156">Attempting to set <xref:System.Windows.PropertyMetadata.DefaultValue%2A> once <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
 <span data-ttu-id="3b7e1-157">Хотя это значение по умолчанию для конструктора без параметров, параметр `defaultValue` of <xref:System.Windows.DependencyProperty.UnsetValue> не может быть задан с <xref:System.Windows.PropertyMetadata.DefaultValue%2A> помощью либо конструктора, либо.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-157">Although it is the default per the parameterless constructor, a `defaultValue` of <xref:System.Windows.DependencyProperty.UnsetValue> cannot be set using either <xref:System.Windows.PropertyMetadata.DefaultValue%2A> or the constructor.</span></span> <span data-ttu-id="3b7e1-158">Попытка сделать это вызовет исключение.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-158">Attempting to do so will raise an exception.</span></span>  
  
<a name="xamlTextUsage_PropertyChangedCallback"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="3b7e1-159">Использование текста XAML</span><span class="sxs-lookup"><span data-stu-id="3b7e1-159">XAML Text Usage</span></span>  
 <span data-ttu-id="3b7e1-160">Члены этого типа обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="3b7e1-160">Members of this type are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3b7e1-161">Невозможно задать значение <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> после создания.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-161">Cannot be set to the value <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> once created.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3b7e1-162">Невозможно задать свойство метаданных после того, как оно применено к ориентации свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-162">Cannot set a metadata property once it is applied to a dependency property operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="protected bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Windows.PropertyMetadata.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3b7e1-163">Возвращает значение, определяющее, были ли применены метаданные к свойству, что привело к запрету изменений экземпляра метаданных.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-163">Gets a value that determines whether the metadata has been applied to a property in some way, resulting in the immutable state of that metadata instance.</span></span></summary>
        <value><span data-ttu-id="3b7e1-164"><see langword="true" />, если экземпляр метаданных не подлежит изменениям; в противном случае — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-164"><see langword="true" /> if the metadata instance is immutable; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3b7e1-165">Различные свойства <xref:System.Windows.PropertyMetadata>, такие как <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, определяются в объектной модели как доступные для чтения и записи.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-165">Various properties of <xref:System.Windows.PropertyMetadata>, such as <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, are defined in the object model as read-write.</span></span> <span data-ttu-id="3b7e1-166">Это значит, что эти свойства можно скорректировать после инициализации <xref:System.Windows.PropertyMetadata> самого объекта.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-166">This is so those properties can be adjusted after initialization of the <xref:System.Windows.PropertyMetadata> object itself.</span></span> <span data-ttu-id="3b7e1-167">Однако после применения метаданных к свойству зависимостей в рамках вызова <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, система свойств зазапечатываниет, что экземпляр метаданных и свойства теперь считаются неизменяемыми.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-167">However, once the metadata is applied to a dependency property as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and the properties are now considered immutable.</span></span> <span data-ttu-id="3b7e1-168">Во время одного из этих вызовов <xref:System.Windows.PropertyMetadata.OnApply%2A> вызывается, и значение этого свойства устанавливается равным. `true`</span><span class="sxs-lookup"><span data-stu-id="3b7e1-168">At the time of one of these calls, <xref:System.Windows.PropertyMetadata.OnApply%2A> is called, and the value of this property is set to `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3b7e1-169">В следующем примере выполняется <xref:System.Windows.PropertyMetadata.IsSealed%2A> проверка перед выполнением операции задания пользовательского свойства метаданных.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-169">The following example  checks <xref:System.Windows.PropertyMetadata.IsSealed%2A> prior to a set operation of a custom metadata property.</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected virtual void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit&#xA;override this.Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit" Usage="propertyMetadata.Merge (baseMetadata, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata"><span data-ttu-id="3b7e1-170">Основные метаданные, с которыми следует совместить значения экземпляра.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-170">The base metadata to merge with this instance's values.</span></span></param>
        <param name="dp"><span data-ttu-id="3b7e1-171">Свойство зависимостей, к которому применяются данные метаданные.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-171">The dependency property to which this metadata is being applied.</span></span></param>
        <summary><span data-ttu-id="3b7e1-172">Совмещает эти метаданные с основными.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-172">Merges this metadata with the base metadata.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3b7e1-173">Этот метод используется внутренне при переопределении метаданных (<xref:System.Windows.DependencyProperty.OverrideMetadata%2A> метод).</span><span class="sxs-lookup"><span data-stu-id="3b7e1-173">This method is used internally when metadata is being overridden (<xref:System.Windows.DependencyProperty.OverrideMetadata%2A> method).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3b7e1-174">В следующем примере реализуется слияние для пользовательского типа метаданных, добавляющего дополнительное свойство в метаданные свойства.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-174">The following example implements a merge for a custom metadata type that adds an additional property to the property metadata.</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="3b7e1-175">Реализации классов, производные от <see cref="T:System.Windows.PropertyMetadata" /> , должны переопределять этот метод, чтобы учитывать все свойства метаданных, добавленные в их реализациях.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-175">Class implementations that derive from <see cref="T:System.Windows.PropertyMetadata" /> should override this method to account for any metadata properties they have added in their implementations.</span></span> <span data-ttu-id="3b7e1-176">Например, ваша реализация может добавить новое значение перечисления флагового, а <see cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> реализация должна иметь возможность правильно сочетать эти флаги.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-176">For instance, your implementation might have added a new flagwise enumeration value, and the <see cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implementation should then be able to combine those flags correctly.</span></span>  
  
<span data-ttu-id="3b7e1-177">Всегда вызывайте базовую реализацию до кода реализации, так как базовая реализация выполняет слияние всех свойств, уже определенных для <see cref="T:System.Windows.PropertyMetadata" /> типа.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-177">Always call the base implementation prior to your implementation code, because the base implementation takes care of merging all the properties already defined on the <see cref="T:System.Windows.PropertyMetadata" /> type.</span></span>  
  
<span data-ttu-id="3b7e1-178">Точное поведение слияния — не так.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-178">The exact behavior of the merge is up to you.</span></span> <span data-ttu-id="3b7e1-179">Можно выбрать сочетание значений, вернуться к базовому значению, если производные метаданные остались по умолчанию, или многие другие поведения, основанные на типах свойств, добавленных в определенный класс метаданных, и их значениях.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-179">You could choose to have values combined, revert to base value if the derived metadata were left at the default, or many other behaviors based on the types of properties you have added to your particular metadata class, and their meanings.</span></span></para></block>
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected virtual void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberSignature Language="F#" Value="abstract member OnApply : System.Windows.DependencyProperty * Type -&gt; unit&#xA;override this.OnApply : System.Windows.DependencyProperty * Type -&gt; unit" Usage="propertyMetadata.OnApply (dp, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="3b7e1-180">Свойство зависимостей, к которому были применены эти метаданные.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-180">The dependency property to which the metadata has been applied.</span></span></param>
        <param name="targetType"><span data-ttu-id="3b7e1-181">Тип, связанный с этими метаданными, если это метаданные зависящие от типа.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-181">The type associated with this metadata if this is type-specific metadata.</span></span> <span data-ttu-id="3b7e1-182">Если это метаданные по умолчанию, значением будет нулевая ссылка.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-182">If this is default metadata, this value is a null reference.</span></span></param>
        <summary><span data-ttu-id="3b7e1-183">Вызывается после применения данных метаданных к свойству, указывая на запечатывание метаданных.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-183">Called when this metadata has been applied to a property, which indicates that the metadata is being sealed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3b7e1-184">Подклассы должны гарантировать, что любое значение структуры <xref:System.Windows.PropertyMetadata> данных подкласса должно быть помечено как неизменяемое после <xref:System.Windows.PropertyMetadata.OnApply%2A> вызова метода.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-184">Subclasses should assure that any mutability of the data structure of a <xref:System.Windows.PropertyMetadata> subclass should be marked as immutable once <xref:System.Windows.PropertyMetadata.OnApply%2A> is called.</span></span> <span data-ttu-id="3b7e1-185">Он будет вызываться после применения метаданных к операции системы свойств (регистрация, добавление владельца, переопределение метаданных).</span><span class="sxs-lookup"><span data-stu-id="3b7e1-185">This will be called once the metadata is applied to a property system operation (register, add owner, override metadata).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyChangedCallback">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyChangedCallback PropertyChangedCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyChangedCallback PropertyChangedCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.PropertyChangedCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property PropertyChangedCallback As PropertyChangedCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyChangedCallback ^ PropertyChangedCallback { System::Windows::PropertyChangedCallback ^ get(); void set(System::Windows::PropertyChangedCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PropertyChangedCallback : System.Windows.PropertyChangedCallback with get, set" Usage="System.Windows.PropertyMetadata.PropertyChangedCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyChangedCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3b7e1-186">Возвращает или задает ссылку на реализацию <see cref="T:System.Windows.PropertyChangedCallback" /> указанную в этих метаданных.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-186">Gets or sets a reference to a <see cref="T:System.Windows.PropertyChangedCallback" /> implementation specified in this metadata.</span></span></summary>
        <value><span data-ttu-id="3b7e1-187">Ссылка реализации <see cref="T:System.Windows.PropertyChangedCallback" />.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-187">A <see cref="T:System.Windows.PropertyChangedCallback" /> implementation reference.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3b7e1-188">Обратные вызовы в метаданных свойств обычно не являются открытыми членами в определяющем типе, поэтому значение этого свойства не имеет значения для большинства сценариев, которые просто используют существующие метаданные свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-188">The callbacks in property metadata are not typically public members on the defining type, so the value of this property is not important for most scenarios that just consume an existing dependency property's metadata.</span></span> <span data-ttu-id="3b7e1-189">Одна из причин, по которой это свойство предоставляется, заключается в <xref:System.Windows.PropertyChangedCallback>том, что классы метаданных могут выполнять необходимую логику слияния, если базовые метаданные и переопределение/Добавление метаданных указывают.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-189">One reason this property is exposed is so that metadata classes can perform their desired merge logic if both base metadata and overriding/adding metadata specify a <xref:System.Windows.PropertyChangedCallback>.</span></span> <span data-ttu-id="3b7e1-190">Логика слияния по умолчанию для заключается в <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> обслуживании всех реализаций в таблице и вызове каждой из них с обратными вызовами, установленными самым глубоким классом в иерархии, выполняемым первыми.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-190">The default merge logic for is to maintain all <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> implementations in a table and call each of them, with callbacks established by the deepest class in hierarchy running first.</span></span>  
  
 <span data-ttu-id="3b7e1-191"><xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>определяется в объектной модели как доступная для чтения и записи.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-191"><xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> is defined in the object model as read-write.</span></span> <span data-ttu-id="3b7e1-192">Это можно изменить после инициализации <xref:System.Windows.PropertyMetadata> самого объекта. <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A></span><span class="sxs-lookup"><span data-stu-id="3b7e1-192">This is so <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> can be adjusted after initialization of the <xref:System.Windows.PropertyMetadata> object itself.</span></span> <span data-ttu-id="3b7e1-193">Однако после того, как метаданные будут использоваться в процессе вызова метода <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, система свойств зазапечатана, что экземпляр метаданных и свойства теперь считаются неизменяемыми.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-193">However, once the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and the properties are now considered immutable.</span></span> <span data-ttu-id="3b7e1-194">Попытка задать <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> <xref:System.Windows.PropertyMetadata.IsSealed%2A>одинраз вэтомэкземпляреметаданныхвызоветисключение.`true`</span><span class="sxs-lookup"><span data-stu-id="3b7e1-194">Attempting to set <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> once <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3b7e1-195">Невозможно задать свойство метаданных после того, как оно применено к ориентации свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="3b7e1-195">Cannot set a metadata property once it is applied to a dependency property operation.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>
