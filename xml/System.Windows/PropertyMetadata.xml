<Type Name="PropertyMetadata" FullName="System.Windows.PropertyMetadata">
  <Metadata><Meta Name="ms.openlocfilehash" Value="cfaa68a67cd83c15d520906814bae974a118e88e" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69444310" /></Metadata><TypeSignature Language="C#" Value="public class PropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit PropertyMetadata extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.PropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class PropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class PropertyMetadata" />
  <TypeSignature Language="F#" Value="type PropertyMetadata = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Определяет некоторые аспекты поведения свойства зависимостей применительно к определенному типу, включая условия, в которых оно было зарегистрировано.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метаданные свойства могут быть определены и использованы во время регистрации свойства зависимости при вызове <xref:System.Windows.DependencyProperty.Register%2A> метода (или для присоединенных свойств или свойств зависимостей только для чтения) или после регистрации исходного владельца при вызове <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> метод. <xref:System.Windows.DependencyProperty.AddOwner%2A>также принимает метаданные свойства.  
  
 Этот класс является конкретным базовым классом, который можно использовать в каждом из этих вызовов. Однако очень часто указывать метаданные можно с помощью одного из производных классов, таких как <xref:System.Windows.FrameworkPropertyMetadata>. Эти производные классы поддерживают более подробные метаданные, передаваемые в качестве значений логических свойств, которые полезны для обнаружения или включения некоторых поведений системы свойств и макета, реализованных только [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] на уровне платформы.  
  
 Некоторые свойства этого класса доступны для чтения и записи в объектную модель, но могут быть записаны только до экземпляра, используемого в операции системы свойств, например <xref:System.Windows.DependencyProperty.Register%2A> или. <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> Каждое из этих свойств также может быть задано конструктором, но предоставлены таким образом <xref:System.Windows.PropertyMetadata.Merge%2A> , чтобы реализации метода могли их задавать.  
  
<a name="xamlTextUsage_PropertyMetadata"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Этот тип и члены этого типа обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.PropertyMetadata" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.PropertyMetadata" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata defaultValue" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Как правило, значение по умолчанию, указанное для свойства зависимостей, представляет собой значение определенного типа.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.PropertyMetadata" /> с указанным значением по умолчанию для свойства зависимостей, к которому будут применены метаданные.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Тип значения, предоставленного для `defaultValue` , должен быть соответствующим или связан с типом, заданным в исходной регистрации свойства зависимостей, к которому будут применяться эти метаданные. Несоответствие между типом значения метаданных по умолчанию и типом свойства зависимостей, к которому он применяется, может быть затруднено в отладке, поскольку несоответствие не обнаруживается во время компиляции (несоответствие вызывает исключение времени выполнения).  
  
 Хотя это значение по умолчанию для конструктора без параметров, `defaultValue` аргумент типа <xref:System.Windows.DependencyProperty.UnsetValue> не может быть указан. Попытка сделать это вызовет исключение.  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> не может иметь значение <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : System.Windows.PropertyChangedCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata propertyChangedCallback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">Ссылка на реализацию обработчика вызывается системой управления свойствами при каждом изменении значения свойства.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.PropertyMetadata" /> с указанной ссылкой реализации <see cref="T:System.Windows.PropertyChangedCallback" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj * System.Windows.PropertyChangedCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata (defaultValue, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Как правило, значение по умолчанию свойства зависимостей представляет собой значение определенного типа.</param>
        <param name="propertyChangedCallback">Ссылка на реализацию обработчика вызывается системой управления свойствами при каждом изменении значения свойства.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.PropertyMetadata" /> с указанным значением по умолчанию и ссылкой на реализацию <see cref="T:System.Windows.PropertyChangedCallback" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Тип предоставленного `defaultValue` значения должен совпадать с типом, указанным в исходной регистрации свойства зависимостей, к которому будут применяться эти метаданные, или быть связанным с ним. Несоответствие между типом значения метаданных по умолчанию и типом свойства зависимостей, к которому он применяется, может быть затруднено в отладке, поскольку несоответствие не обнаруживается во время компиляции (несоответствие вызывает исключение времени выполнения).  
  
 Хотя это значение по умолчанию для конструктора без параметров, `defaultValue` аргумент типа <xref:System.Windows.DependencyProperty.UnsetValue> не может быть указан. Попытка сделать это вызовет исключение.  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> не может иметь значение <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata (defaultValue, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Как правило, значение по умолчанию свойства зависимостей представляет собой значение определенного типа.</param>
        <param name="propertyChangedCallback">Ссылка на реализацию обработчика вызывается системой управления свойствами при каждом изменении значения свойства.</param>
        <param name="coerceValueCallback">Ссылка на реализацию обработчика вызывается системой управления свойствами при каждом вызове <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> против данного свойства.</param>
        <summary>Инициализирует новый экземпляр <see cref="T:System.Windows.PropertyMetadata" /> класса с заданными значением по умолчанию и ответами.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.Windows.CoerceValueCallback> необходимо указать <xref:System.Windows.PropertyChangedCallback>, но не, можно передать `null` параметру значение `propertyChangedCallback` .  
  
 Тип значения, предоставленного для `defaultValue` , должен быть соответствующим или связан с типом, заданным в исходной регистрации свойства зависимостей, к которому будут применяться эти метаданные. Несоответствие между типом значения метаданных по умолчанию и типом свойства зависимостей, к которому он применяется, может быть затруднено в отладке, поскольку несоответствие не обнаруживается во время компиляции (несоответствие вызывает исключение времени выполнения).  
  
 Хотя это значение по умолчанию для конструктора без параметров, `defaultValue` аргумент типа <xref:System.Windows.DependencyProperty.UnsetValue> не может быть указан. Попытка сделать это вызовет исключение.  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> не может иметь значение <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CoerceValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.CoerceValueCallback CoerceValueCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.CoerceValueCallback CoerceValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.CoerceValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property CoerceValueCallback As CoerceValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::CoerceValueCallback ^ CoerceValueCallback { System::Windows::CoerceValueCallback ^ get(); void set(System::Windows::CoerceValueCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CoerceValueCallback : System.Windows.CoerceValueCallback with get, set" Usage="System.Windows.PropertyMetadata.CoerceValueCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.CoerceValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает ссылку на реализацию <see cref="T:System.Windows.CoerceValueCallback" /> указанную в этих метаданных.</summary>
        <value>Ссылка реализации <see cref="T:System.Windows.CoerceValueCallback" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обратные вызовы в метаданных свойств обычно не являются открытыми членами в содержащем типе, поэтому значение этого свойства не имеет значения для большинства сценариев, которые просто используют существующие метаданные свойства зависимостей. Одна из причин, по которой это свойство предоставляется, заключается в <xref:System.Windows.CoerceValueCallback>том, что подклассы метаданных могут выполнять необходимую логику слияния, если базовые метаданные и переопределение/Добавление метаданных указывают. Однако логика слияния по умолчанию для <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> может заменить предыдущую.  
  
 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>определяется в объектной модели как доступная для чтения и записи. Это можно изменить после инициализации <xref:System.Windows.PropertyMetadata> самого объекта. <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> Однако после того, как метаданные будут использоваться в процессе вызова метода <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, система свойств зазапечатана, что экземпляр метаданных и свойства теперь считаются неизменяемыми. Попытка задать <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> <xref:System.Windows.PropertyMetadata.IsSealed%2A>одинраз вэтомэкземпляреметаданныхвызоветисключение.`true`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Невозможно задать свойство метаданных после того, как оно применено к ориентации свойства зависимостей.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultValue">
      <MemberSignature Language="C#" Value="public object DefaultValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultValue" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.DefaultValue" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultValue As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DefaultValue { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultValue : obj with get, set" Usage="System.Windows.PropertyMetadata.DefaultValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение по умолчанию свойства зависимостей.</summary>
        <value>Значение свойства по умолчанию. Значением по умолчанию для <see cref="T:System.Windows.PropertyMetadata" /> экземпляра, созданного с помощью конструктора без параметров <see cref="F:System.Windows.DependencyProperty.UnsetValue" />, будет.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.PropertyMetadata.DefaultValue%2A>определяется в объектной модели как доступная для чтения и записи. Это можно изменить после инициализации <xref:System.Windows.PropertyMetadata> самого объекта. <xref:System.Windows.PropertyMetadata.DefaultValue%2A> Однако после того, как метаданные будут использоваться в процессе вызова метода <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, система свойств зазапечатана, что экземпляр метаданных и свойства теперь считаются неизменяемыми. Попытка задать <xref:System.Windows.PropertyMetadata.DefaultValue%2A> <xref:System.Windows.PropertyMetadata.IsSealed%2A>одинраз вэтомэкземпляреметаданныхвызоветисключение.`true`  
  
 Хотя это значение по умолчанию для конструктора без параметров, параметр `defaultValue` of <xref:System.Windows.DependencyProperty.UnsetValue> не может быть задан с <xref:System.Windows.PropertyMetadata.DefaultValue%2A> помощью либо конструктора, либо. Попытка сделать это вызовет исключение.  
  
<a name="xamlTextUsage_PropertyChangedCallback"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Члены этого типа обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Невозможно задать значение <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> после создания.</exception>
        <exception cref="T:System.InvalidOperationException">Невозможно задать свойство метаданных после того, как оно применено к ориентации свойства зависимостей.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="protected bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Windows.PropertyMetadata.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, определяющее, были ли применены метаданные к свойству, что привело к запрету изменений экземпляра метаданных.</summary>
        <value><see langword="true" />, если экземпляр метаданных не подлежит изменениям; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Различные свойства <xref:System.Windows.PropertyMetadata>, такие как <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, определяются в объектной модели как доступные для чтения и записи. Это значит, что эти свойства можно скорректировать после инициализации <xref:System.Windows.PropertyMetadata> самого объекта. Однако после применения метаданных к свойству зависимостей в рамках вызова <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, система свойств зазапечатываниет, что экземпляр метаданных и свойства теперь считаются неизменяемыми. Во время одного из этих вызовов <xref:System.Windows.PropertyMetadata.OnApply%2A> вызывается, и значение этого свойства устанавливается равным. `true`  
  
   
  
## Examples  
 В следующем примере выполняется <xref:System.Windows.PropertyMetadata.IsSealed%2A> проверка перед выполнением операции задания пользовательского свойства метаданных.  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected virtual void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit&#xA;override this.Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit" Usage="propertyMetadata.Merge (baseMetadata, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata">Основные метаданные, с которыми следует совместить значения экземпляра.</param>
        <param name="dp">Свойство зависимостей, к которому применяются данные метаданные.</param>
        <summary>Совмещает эти метаданные с основными.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется внутренне при переопределении метаданных (<xref:System.Windows.DependencyProperty.OverrideMetadata%2A> метод).  
  
   
  
## Examples  
 В следующем примере реализуется слияние для пользовательского типа метаданных, добавляющего дополнительное свойство в метаданные свойства.  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Реализации классов, производные от <see cref="T:System.Windows.PropertyMetadata" /> , должны переопределять этот метод, чтобы учитывать все свойства метаданных, добавленные в их реализациях. Например, ваша реализация может добавить новое значение перечисления флагового, а <see cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> реализация должна иметь возможность правильно сочетать эти флаги.  
  
Всегда вызывайте базовую реализацию до кода реализации, так как базовая реализация выполняет слияние всех свойств, уже определенных для <see cref="T:System.Windows.PropertyMetadata" /> типа.  
  
Точное поведение слияния — не так. Можно выбрать сочетание значений, вернуться к базовому значению, если производные метаданные остались по умолчанию, или многие другие поведения, основанные на типах свойств, добавленных в определенный класс метаданных, и их значениях.</para></block>
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected virtual void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberSignature Language="F#" Value="abstract member OnApply : System.Windows.DependencyProperty * Type -&gt; unit&#xA;override this.OnApply : System.Windows.DependencyProperty * Type -&gt; unit" Usage="propertyMetadata.OnApply (dp, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp">Свойство зависимостей, к которому были применены эти метаданные.</param>
        <param name="targetType">Тип, связанный с этими метаданными, если это метаданные зависящие от типа. Если это метаданные по умолчанию, значением будет нулевая ссылка.</param>
        <summary>Вызывается после применения данных метаданных к свойству, указывая на запечатывание метаданных.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Подклассы должны гарантировать, что любое значение структуры <xref:System.Windows.PropertyMetadata> данных подкласса должно быть помечено как неизменяемое после <xref:System.Windows.PropertyMetadata.OnApply%2A> вызова метода. Он будет вызываться после применения метаданных к операции системы свойств (регистрация, добавление владельца, переопределение метаданных).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyChangedCallback">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyChangedCallback PropertyChangedCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyChangedCallback PropertyChangedCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.PropertyChangedCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property PropertyChangedCallback As PropertyChangedCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyChangedCallback ^ PropertyChangedCallback { System::Windows::PropertyChangedCallback ^ get(); void set(System::Windows::PropertyChangedCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PropertyChangedCallback : System.Windows.PropertyChangedCallback with get, set" Usage="System.Windows.PropertyMetadata.PropertyChangedCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyChangedCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает ссылку на реализацию <see cref="T:System.Windows.PropertyChangedCallback" /> указанную в этих метаданных.</summary>
        <value>Ссылка реализации <see cref="T:System.Windows.PropertyChangedCallback" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обратные вызовы в метаданных свойств обычно не являются открытыми членами в определяющем типе, поэтому значение этого свойства не имеет значения для большинства сценариев, которые просто используют существующие метаданные свойства зависимостей. Одна из причин, по которой это свойство предоставляется, заключается в <xref:System.Windows.PropertyChangedCallback>том, что классы метаданных могут выполнять необходимую логику слияния, если базовые метаданные и переопределение/Добавление метаданных указывают. Логика слияния по умолчанию для заключается в <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> обслуживании всех реализаций в таблице и вызове каждой из них с обратными вызовами, установленными самым глубоким классом в иерархии, выполняемым первыми.  
  
 <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>определяется в объектной модели как доступная для чтения и записи. Это можно изменить после инициализации <xref:System.Windows.PropertyMetadata> самого объекта. <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> Однако после того, как метаданные будут использоваться в процессе вызова метода <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, система свойств зазапечатана, что экземпляр метаданных и свойства теперь считаются неизменяемыми. Попытка задать <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> <xref:System.Windows.PropertyMetadata.IsSealed%2A>одинраз вэтомэкземпляреметаданныхвызоветисключение.`true`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Невозможно задать свойство метаданных после того, как оно применено к ориентации свойства зависимостей.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
