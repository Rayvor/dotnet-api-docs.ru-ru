<Type Name="PropertyMetadata" FullName="System.Windows.PropertyMetadata">
  <Metadata><Meta Name="ms.openlocfilehash" Value="aa346bc4cec7efcd2bae97ad77e668f7e1e9263e" /><Meta Name="ms.sourcegitcommit" Value="f1d16425528e237257ca3b58eb49217a514849ea" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="04/24/2019" /><Meta Name="ms.locfileid" Value="64185155" /></Metadata><TypeSignature Language="C#" Value="public class PropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit PropertyMetadata extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.PropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class PropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class PropertyMetadata" />
  <TypeSignature Language="F#" Value="type PropertyMetadata = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Определяет некоторые аспекты поведения свойства зависимостей применительно к определенному типу, включая условия, в которых оно было зарегистрировано.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метаданные свойства могут быть определены и используется во время регистрации свойства зависимостей, при вызове <xref:System.Windows.DependencyProperty.Register%2A> метод (или вариантами для присоединенных свойств или свойств зависимостей только для чтения) или после исходной регистрации владелец при вызове <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> метод. <xref:System.Windows.DependencyProperty.AddOwner%2A> также принимает метаданные свойства.  
  
 Этот класс является конкретного базового класса, который может использоваться в каждом из этих вызовов. Тем не менее, очень характерно для указания метаданных, таких как с помощью одного из производных классов <xref:System.Windows.FrameworkPropertyMetadata>. Эти производные классы поддерживают более подробные метаданные, передающиеся как значения логического свойства, которые можно использовать для определения или некоторые свойства поведения системы и макет, реализованных в [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] уровне платформы.  
  
 Некоторые свойства этого класса являются чтения и записи к объектной модели, но может быть написан только до экземпляра, который используется в операции системы свойств, таких как <xref:System.Windows.DependencyProperty.Register%2A> или <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A>. Каждое из этих свойств может также заданы с помощью конструктора, а предоставляются, чтобы <xref:System.Windows.PropertyMetadata.Merge%2A> реализации методов можно установить их.  
  
<a name="xamlTextUsage_PropertyMetadata"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Этот тип и члены этого типа обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.PropertyMetadata" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.PropertyMetadata" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata defaultValue" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Как правило, значение по умолчанию, указанное для свойства зависимостей, представляет собой значение определенного типа.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.PropertyMetadata" /> с указанным значением по умолчанию для свойства зависимостей, к которому будут применены метаданные.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Тип значения, заданного для `defaultValue` должны быть согласованы или относиться к типу, указанному в исходной регистрации свойства зависимостей, которые применяются эти метаданные. Несоответствия между тип значения метаданных по умолчанию и типом свойства зависимостей, к которому он применяется к может быть трудно отлаживаемыми, поскольку рассогласования не удается обнаружить во время компиляции (несовпадение вызовет исключение времени выполнения).  
  
 Несмотря на то, что он используется по умолчанию на конструктор без параметров, `defaultValue` из <xref:System.Windows.DependencyProperty.UnsetValue> нельзя использовать. Попытка выполнить такую операцию вызовет исключение.  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> не может иметь значение <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : System.Windows.PropertyChangedCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata propertyChangedCallback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">Ссылка на реализацию обработчика вызывается системой управления свойствами при каждом изменении значения свойства.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.PropertyMetadata" /> с указанной ссылкой реализации <see cref="T:System.Windows.PropertyChangedCallback" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj * System.Windows.PropertyChangedCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata (defaultValue, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Как правило, значение по умолчанию свойства зависимостей представляет собой значение определенного типа.</param>
        <param name="propertyChangedCallback">Ссылка на реализацию обработчика вызывается системой управления свойствами при каждом изменении значения свойства.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.PropertyMetadata" /> с указанным значением по умолчанию и ссылкой на реализацию <see cref="T:System.Windows.PropertyChangedCallback" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Тип значения, заданного `defaultValue` должны быть согласованы или относиться к типу, указанному в исходной регистрации свойства зависимостей, которые применяются эти метаданные. Несоответствия между тип значения метаданных по умолчанию и типом свойства зависимостей, к которому он применяется к может быть трудно отлаживаемыми, поскольку рассогласования не удается обнаружить во время компиляции (несовпадение вызовет исключение времени выполнения).  
  
 Несмотря на то, что он используется по умолчанию на конструктор без параметров, `defaultValue` из <xref:System.Windows.DependencyProperty.UnsetValue> нельзя использовать. Попытка выполнить такую операцию вызовет исключение.  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> не может иметь значение <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata (defaultValue, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Как правило, значение по умолчанию свойства зависимостей представляет собой значение определенного типа.</param>
        <param name="propertyChangedCallback">Ссылка на реализацию обработчика вызывается системой управления свойствами при каждом изменении значения свойства.</param>
        <param name="coerceValueCallback">Ссылка на реализацию обработчика вызывается системой управления свойствами при каждом вызове <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> против данного свойства.</param>
        <summary>Инициализирует новый экземпляр <see cref="T:System.Windows.PropertyMetadata" /> класса с заданными значением по умолчанию и ответами.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы хотите указать <xref:System.Windows.CoerceValueCallback> , но не <xref:System.Windows.PropertyChangedCallback>, вы можете передать `null` для `propertyChangedCallback` параметра.  
  
 Тип значения, заданного для `defaultValue` должны быть согласованы или относиться к типу, указанному в исходной регистрации свойства зависимостей, которые применяются эти метаданные. Несоответствия между тип значения метаданных по умолчанию и типом свойства зависимостей, к которому он применяется к может быть трудно отлаживаемыми, поскольку рассогласования не удается обнаружить во время компиляции (несовпадение вызовет исключение времени выполнения).  
  
 Несмотря на то, что он используется по умолчанию на конструктор без параметров, `defaultValue` из <xref:System.Windows.DependencyProperty.UnsetValue> нельзя использовать. Попытка выполнить такую операцию вызовет исключение.  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> не может иметь значение <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CoerceValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.CoerceValueCallback CoerceValueCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.CoerceValueCallback CoerceValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.CoerceValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property CoerceValueCallback As CoerceValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::CoerceValueCallback ^ CoerceValueCallback { System::Windows::CoerceValueCallback ^ get(); void set(System::Windows::CoerceValueCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CoerceValueCallback : System.Windows.CoerceValueCallback with get, set" Usage="System.Windows.PropertyMetadata.CoerceValueCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.CoerceValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает ссылку на реализацию <see cref="T:System.Windows.CoerceValueCallback" /> указанную в этих метаданных.</summary>
        <value>Ссылка реализации <see cref="T:System.Windows.CoerceValueCallback" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обратные вызовы свойства метаданных не обычно открытые члены во вмещающем типе, поэтому значение этого свойства не является важным для большинства сценариев, которые просто поглощают метаданных существующего свойства зависимости. Одна из причин, это свойство представляется — таким образом, чтобы подклассы метаданных может выполнить необходимую логику совмещения, если основные метаданные и переопределение: Добавление метаданных укажите <xref:System.Windows.CoerceValueCallback>. Тем не менее, по умолчанию слияния логику для <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> заключается в замене предыдущей.  
  
 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> определен в модели объектов чтения и записи. Это происходит оттого, <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> можно изменить после инициализации <xref:System.Windows.PropertyMetadata> сам объект. Однако после исчерпания метаданные как часть вызова <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, система свойств будет запечатать этот экземпляр метаданных и свойств, теперь считаются неизменяемыми. Попытка задать <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> после <xref:System.Windows.PropertyMetadata.IsSealed%2A> является `true` на эти метаданные экземпляра будет выдано исключение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Невозможно задать свойство метаданных после того, как оно применено к ориентации свойства зависимостей.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultValue">
      <MemberSignature Language="C#" Value="public object DefaultValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultValue" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.DefaultValue" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultValue As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DefaultValue { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultValue : obj with get, set" Usage="System.Windows.PropertyMetadata.DefaultValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение по умолчанию свойства зависимостей.</summary>
        <value>Значение свойства по умолчанию. Значение по умолчанию <see cref="T:System.Windows.PropertyMetadata" /> экземпляр, созданный с помощью конструктора без параметров будет <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.PropertyMetadata.DefaultValue%2A> определен в модели объектов чтения и записи. Это происходит оттого, <xref:System.Windows.PropertyMetadata.DefaultValue%2A> можно изменить после инициализации <xref:System.Windows.PropertyMetadata> сам объект. Однако после исчерпания метаданные как часть вызова <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, система свойств будет запечатать этот экземпляр метаданных и свойств, теперь считаются неизменяемыми. Попытка задать <xref:System.Windows.PropertyMetadata.DefaultValue%2A> после <xref:System.Windows.PropertyMetadata.IsSealed%2A> является `true` на эти метаданные экземпляра будет выдано исключение.  
  
 Несмотря на то, что он используется по умолчанию на конструктор без параметров, `defaultValue` из <xref:System.Windows.DependencyProperty.UnsetValue> нельзя установить с помощью <xref:System.Windows.PropertyMetadata.DefaultValue%2A> или конструктора. Попытка выполнить такую операцию вызовет исключение.  
  
<a name="xamlTextUsage_PropertyChangedCallback"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Члены этого типа обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Невозможно задать значение <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> после создания.</exception>
        <exception cref="T:System.InvalidOperationException">Невозможно задать свойство метаданных после того, как оно применено к ориентации свойства зависимостей.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="protected bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Windows.PropertyMetadata.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, определяющее, были ли применены метаданные к свойству, что привело к запрету изменений экземпляра метаданных.</summary>
        <value><see langword="true" />, если экземпляр метаданных не подлежит изменениям; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Различные свойства <xref:System.Windows.PropertyMetadata>, такие как <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, определенных в модели объекта в виде чтения и записи. Это так, что эти свойства можно изменить после инициализации <xref:System.Windows.PropertyMetadata> сам объект. Тем не менее после применения метаданных к свойству зависимостей как часть вызова <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, система свойств будет запечатать этот экземпляр метаданных и свойств, теперь считаются неизменяемыми. Во время одного из этих вызовов <xref:System.Windows.PropertyMetadata.OnApply%2A> вызывается, и это свойство имеет значение `true`.  
  
   
  
## Examples  
 В следующем примере проверяется <xref:System.Windows.PropertyMetadata.IsSealed%2A> до операции задания свойства пользовательских метаданных.  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected virtual void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit&#xA;override this.Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit" Usage="propertyMetadata.Merge (baseMetadata, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata">Основные метаданные, с которыми следует совместить значения экземпляра.</param>
        <param name="dp">Свойство зависимостей, к которому применяются данные метаданные.</param>
        <summary>Совмещает эти метаданные с основными.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется внутренне, при переопределении метаданных (<xref:System.Windows.DependencyProperty.OverrideMetadata%2A> метод).  
  
   
  
## Examples  
 В следующем примере реализуется слияния для типа пользовательских метаданных, который добавляет дополнительное свойство, к метаданным свойства.  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Класс реализации, которые являются производными от <see cref="T:System.Windows.PropertyMetadata" /> должны переопределять этот метод, чтобы учесть все свойства метаданных, добавленных в их реализации. Например, реализация может добавлять новое значение флагового перечисления и <see cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> реализации затем должны иметь возможность правильно объединить эти флаги.  
  
Всегда вызывать базовую реализацию до код реализации, так как берет на себя все свойства, которые уже определены в базовой реализации <see cref="T:System.Windows.PropertyMetadata" /> типа.  
  
Точное поведение объединения зависит от пользователя. Вы можете иметь объединенные значения, возвращаются к базовое значение, если производные метаданные не были удалены по умолчанию или много приемов, исходя из типов свойств, добавленных в класс метаданных и их значения.</para></block>
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected virtual void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberSignature Language="F#" Value="abstract member OnApply : System.Windows.DependencyProperty * Type -&gt; unit&#xA;override this.OnApply : System.Windows.DependencyProperty * Type -&gt; unit" Usage="propertyMetadata.OnApply (dp, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp">Свойство зависимостей, к которому были применены эти метаданные.</param>
        <param name="targetType">Тип, связанный с этими метаданными, если это метаданные зависящие от типа. Если это метаданные по умолчанию, значением будет нулевая ссылка.</param>
        <summary>Вызывается после применения данных метаданных к свойству, указывая на запечатывание метаданных.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Подклассы должны убедиться, что все изменения структуры данных <xref:System.Windows.PropertyMetadata> подкласс должен быть помечен как к неизменяемым один раз <xref:System.Windows.PropertyMetadata.OnApply%2A> вызывается. Вызывается после применения метаданных к операции системы свойств (регистрация, добавление владельца, переопределение метаданных).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyChangedCallback">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyChangedCallback PropertyChangedCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyChangedCallback PropertyChangedCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.PropertyChangedCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property PropertyChangedCallback As PropertyChangedCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyChangedCallback ^ PropertyChangedCallback { System::Windows::PropertyChangedCallback ^ get(); void set(System::Windows::PropertyChangedCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PropertyChangedCallback : System.Windows.PropertyChangedCallback with get, set" Usage="System.Windows.PropertyMetadata.PropertyChangedCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyChangedCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает ссылку на реализацию <see cref="T:System.Windows.PropertyChangedCallback" /> указанную в этих метаданных.</summary>
        <value>Ссылка реализации <see cref="T:System.Windows.PropertyChangedCallback" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обратные вызовы свойства метаданных не обычно открытых членов, определяющего типа, поэтому значение этого свойства не является важным для большинства сценариев, которые просто поглощают метаданных существующего свойства зависимости. Одна из причин, это свойство представляется — таким образом, чтобы классы метаданных можно выполнять необходимую логику совмещения, если основные метаданные и переопределение: Добавление метаданных укажите <xref:System.Windows.PropertyChangedCallback>. Логика слияния по умолчанию содержится для поддержания всех <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> реализаций в таблице и вызова каждого из них, с помощью обратных вызовов, установить самой глубокой классом в иерархии под управлением первого.  
  
 <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> определен в модели объектов чтения и записи. Это происходит оттого, <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> можно изменить после инициализации <xref:System.Windows.PropertyMetadata> сам объект. Однако после исчерпания метаданные как часть вызова <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, система свойств будет запечатать этот экземпляр метаданных и свойств, теперь считаются неизменяемыми. Попытка задать <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> после <xref:System.Windows.PropertyMetadata.IsSealed%2A> является `true` на эти метаданные экземпляра будет выдано исключение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Невозможно задать свойство метаданных после того, как оно применено к ориентации свойства зависимостей.</exception>
      </Docs>
    </Member>
  </Members>
</Type>