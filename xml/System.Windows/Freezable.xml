<Type Name="Freezable" FullName="System.Windows.Freezable">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7c169b181ce31b1d4363a95a06b500bd451cc235" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70721179" /></Metadata><TypeSignature Language="C#" Value="public abstract class Freezable : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Freezable extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Freezable" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Freezable&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class Freezable abstract : System::Windows::DependencyObject" />
  <TypeSignature Language="F#" Value="type Freezable = class&#xA;    inherit DependencyObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Определяет объект, имеющий изменяемое состояние и состояние только для чтения (зафиксированное). Классы, производные от <see cref="T:System.Windows.Freezable" />, предоставляют подробные уведомления об изменениях, могут быть неизменяемыми и могут копировать себя.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Freezable> Класс предоставляет специальные функции, которые могут помочь повысить производительность приложения при использовании объектов, которые требуют изменения или копирования. К примерам <xref:System.Windows.Freezable> объектов относятся следующие.  
  
-   <xref:System.Windows.Media.Brush>  
  
-   <xref:System.Windows.Media.Pen>  
  
-   <xref:System.Windows.Media.Geometry>  
  
-   <xref:System.Windows.Media.Transform>  
  
-   <xref:System.Windows.Media.Animation.AnimationTimeline>  
  
## <a name="deriving-from-freezable"></a>Наследование от Freezable  
 Класс, производный от <xref:System.Windows.Freezable> , получает следующие функции:  
  
-   Особые состояния: состояние "только для чтения" (замороженное) и состояние, доступное для записи.  
  
-   Потокобезопасность. замороженный <xref:System.Windows.Freezable> объект может совместно использоваться несколькими потоками.  
  
-   Подробное уведомление об изменении. в <xref:System.Windows.DependencyObject> <xref:System.Windows.Freezable> отличие от других объектов, объект предоставляет уведомления об изменениях при изменении значений подсвойств.  
  
-   Простое клонирование: класс Freezable уже реализовал несколько методов, создающих глубокие клоны.  
  
 Сведения об использовании и создании собственных <xref:System.Windows.Freezable> объектов см. в разделе [Общие сведения об объектах Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).  
  
 ]]></format>
    </remarks>
    <threadsafe>Все открытые <see langword="static" /> члены этого типа являются потокобезопасными. Потокобезопасность членов экземпляров не гарантируется.  
  
Если свойство имеет <see langword="false" />значение, <see cref="T:System.Windows.Freezable" /> доступ к объекту может осуществляться только из потока, в котором он был создан. <see cref="P:System.Windows.Freezable.IsFrozen" /> Попытка доступа к нему из другого потока вызывает <see cref="T:System.InvalidOperationException" />исключение. Методы <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> и <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" />  обеспечивают поддержку упаковки в нужный поток.  
  
Если их <see cref="P:System.Windows.Freezable.IsFrozen" /> свойство имеет <see langword="true" />значение <see cref="T:System.Windows.Freezable" /> , объекты являются свободными потоками.  Дополнительные сведения см. в разделе [Общие сведения об объектах класса Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Freezable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Freezable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр производного класса <see cref="T:System.Windows.Freezable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это конструктор защищенного доступа абстрактного класса.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanFreeze">
      <MemberSignature Language="C#" Value="public bool CanFreeze { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanFreeze" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.CanFreeze" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanFreeze As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanFreeze { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanFreeze : bool" Usage="System.Windows.Freezable.CanFreeze" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, которое указывает, можно ли сделать объект неизменяемым.</summary>
        <value>Значение <see langword="true" />, если текущий объект можно сделать неизменяемым или если он уже является неизменяемым; в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Эта <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> реализация метода использует метод со <paramref name="isChecking" /> значением <see langword="true" /> , равным, чтобы определить <see cref="T:System.Windows.Freezable" /> , можно ли сделать неизменяемым. Чтобы изменить способ, которым данное свойство ведет себя в производном классе, переопределите <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> метод.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event EventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Freezable.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : EventHandler " Usage="member this.Changed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда изменяется класс <see cref="T:System.Windows.Freezable" /> или объект, который входит в его состав.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При попытке добавить или удалить обработчики событий, если текущий объект не является изменяемым (если <xref:System.Windows.Freezable.IsFrozen%2A> свойство имеет `true`значение), возникает исключение.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ Clone();" />
      <MemberSignature Language="F#" Value="member this.Clone : unit -&gt; System.Windows.Freezable" Usage="freezable.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает редактируемую копию объекта <see cref="T:System.Windows.Freezable" />, что позволяет выполнить глубокое копирование значений объекта. При копировании свойств зависимостей объекта этот метод копирует выражения (которые могут уже не быть разрешимыми), но не копирует анимации и их текущие значения.</summary>
        <returns>Изменяемая копия текущего объекта. Свойство <see cref="P:System.Windows.Freezable.IsFrozen" /> клонированного объекта имеет значение <see langword="false" />, даже если свойство <see cref="P:System.Windows.Freezable.IsFrozen" /> исходного объекта имеет значение <see langword="true." />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Freezable> <xref:System.Windows.Freezable> Методы <xref:System.Windows.Freezable.Clone%2A> и <xref:System.Windows.Freezable.CloneCurrentValue%2A> создают изменяемые клоны замороженных объектов (методы также копируют объекты, которые не являются замороженными). Клон фактически является глубокой копией текущего объекта.  
  
 В следующей таблице приведены различия между <xref:System.Windows.Freezable.Clone%2A> методами и. <xref:System.Windows.Freezable.CloneCurrentValue%2A>  
  
|Действие|Поведение метода Clone|Поведение метода Клонекуррентвалуе|  
|------------|---------------------------|---------------------------------------|  
|Копирование свойства зависимостей, имеющего выражение|Выражение копируется, но может больше не разрешаться. Дополнительные сведения см. в разделе [Общие сведения об объектах класса Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).|Текущее значение выражения копируется, но не само выражение.|  
|Копирование анимированного свойства зависимостей|Копируется базовое (не анимационное) значение свойства. Анимации не копируются.|Копируется текущее анимированное значение свойства. Анимации не копируются.|  
  
 Обратите внимание, что неопределенные свойства не копируются. Если неопределенное свойство имеет зафиксированное <xref:System.Windows.Freezable>значение по умолчанию, то значение этого свойства остается замороженным в неизменяемом клоне с другим значением.  
  
## <a name="move-a-freezable-between-threads"></a>Перемещение объекта Freezable между потоками  
 Этот метод может быть полезен для перемещения <xref:System.Windows.Freezable> между потоками. Сначала сделайте <xref:System.Windows.Freezable> неизменяемым, вызвав его <xref:System.Windows.Freezable.Freeze%2A> метод. Теперь другой поток может получить доступ <xref:System.Windows.Freezable> к и сделать локальную <xref:System.Windows.Freezable.Clone%2A> , к которой он имеет доступ.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Этот метод использует <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> для создания клона. Чтобы изменить поведение этого метода в производном классе, переопределите <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> метод.</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
        <altmember cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Объект, используемый для клонирования.</param>
        <summary>Делает экземпляр клоном (глубокой копией) указанного объекта <see cref="T:System.Windows.Freezable" />, используя базовые (без анимации) значения свойств.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается <xref:System.Windows.Freezable.Clone%2A> методом и не должен вызываться непосредственно из кода, за исключением случаев вызова базовой реализации при переопределении этого метода. Чтобы создать изменяемую копию текущего объекта, вызовите <xref:System.Windows.Freezable.Clone%2A> метод вместо вызова этого метода напрямую.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Если вы наследуете <see cref="T:System.Windows.Freezable" />от, может потребоваться переопределить этот метод. Ниже перечислены причины переопределения. 
-У производного класса есть данные, которые не предоставляются через свойства зависимостей.  
  
— Ваш производный класс должен выполнять дополнительные операции инициализации, которые не могут быть выполнены путем <see cref="M:System.Windows.Freezable.CreateInstanceCore" />простого переопределения. Например, это применимо, если производный класс <see cref="T:System.ComponentModel.ISupportInitialize" />реализует.  
  
Классы, хранящие все свои данные в свойствах зависимостей и не требующие дополнительной работы по инициализации, не нуждаются в переопределении <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />.  
  
Важно, чтобы все реализации вызывали базовую реализацию этого метода. Реализации должны выполнять только работу, которая не выполняется реализацией по умолчанию. Реализация по умолчанию делает глубокие копии всех доступных для записи, локально заданных свойств, включая внутренние выражения.  
  
Если объект имеет свойства зависимостей, привязанные к данным, выражения копируются, но могут больше не разрешаться. Дополнительные сведения о клонировании объектов, привязанных к данным, см. в разделе [Общие сведения об объектах Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md). Если объект имеет анимированные свойства зависимостей, копируется базовое (не анимационное) значение этих свойств. Анимации не копируются.  
  
Обратите внимание, что неопределенные свойства не копируются и не являются свойствами только для чтения. Если такое свойство имеет зафиксированное <see cref="T:System.Windows.Freezable" />значение по умолчанию, значение этого свойства остается замороженным в случае неизменяемого клона.  
  
В следующем списке приводится сводка ожидаемого поведения для этого метода: 
— Созданная копия содержит копии всех <see cref="T:System.Windows.Freezable" /> подобъектов.  
  
-Не задавайте и свойства только для чтения не копируются.  
  
-Выражения копируются.  
  
— Ни один из этих вложенных объектов не замораживается при создании.  
  
— Сама копия не заморожена.  
  
-Анимации не копируются.  
  
— Копируются только базовые значения свойств, а не текущие анимированные значения.</para></block>
        <altmember cref="M:System.Windows.Freezable.Clone" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValue" />
      <MemberSignature Language="VB.NET" Value="Public Function CloneCurrentValue () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ CloneCurrentValue();" />
      <MemberSignature Language="F#" Value="member this.CloneCurrentValue : unit -&gt; System.Windows.Freezable" Usage="freezable.CloneCurrentValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает редактируемую копию (глубокую копию) объекта <see cref="T:System.Windows.Freezable" /> с использованием его текущих значений.</summary>
        <returns>Изменяемая копия текущего объекта. Свойство <see cref="P:System.Windows.Freezable.IsFrozen" /> клонированного объекта имеет значение <see langword="false" />, даже если свойство <see cref="P:System.Windows.Freezable.IsFrozen" /> исходного объекта имеет значение <see langword="true." />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Freezable> <xref:System.Windows.Freezable> Методы <xref:System.Windows.Freezable.Clone%2A> и <xref:System.Windows.Freezable.CloneCurrentValue%2A> создают изменяемые клоны замороженных объектов (методы также копируют объекты, которые не являются замороженными). Клон фактически является глубокой копией текущего объекта.  
  
 В следующей таблице приведены различия между <xref:System.Windows.Freezable.Clone%2A> методами и. <xref:System.Windows.Freezable.CloneCurrentValue%2A>  
  
|Действие|Поведение метода Clone|Поведение метода Клонекуррентвалуе|  
|------------|---------------------------|---------------------------------------|  
|Копирование свойства зависимостей, имеющего выражение|Выражение копируется, но может больше не разрешаться. Дополнительные сведения см. в разделе [Общие сведения об объектах класса Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).|Текущее значение выражения копируется, но не само выражение.|  
|Копирование анимированного свойства зависимостей|Копируется базовое (не анимационное) значение свойства. Анимации не копируются.|Копируется текущее анимированное значение свойства. Анимации не копируются.|  
  
 Обратите внимание, что неопределенные свойства не копируются. Если неопределенное свойство имеет зафиксированное <xref:System.Windows.Freezable>значение по умолчанию, то значение этого свойства остается замороженным в неизменяемом клоне с другим значением.  
  
## <a name="move-a-freezable-between-threads"></a>Перемещение объекта Freezable между потоками  
 Этот метод может быть полезен для перемещения <xref:System.Windows.Freezable> между потоками. Сначала сделайте его <xref:System.Windows.Freezable> неизменяемым <xref:System.Windows.Freezable.Freeze%2A> с помощью метода. Теперь другой поток может получить доступ <xref:System.Windows.Freezable> к и сделать локальный клон, к которому он имеет доступ.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Этот метод использует <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> метод для создания клона; разработчикам, переопределяющим <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> , необходимо обеспечить, чтобы копия не зависла при создании. <see cref="T:System.Windows.Freezable" /></para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCurrentValueCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCurrentValueCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCurrentValueCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Элемент привязки <see cref="T:System.Windows.Freezable" />, точную копию которого необходимо создать.</param>
        <summary>Создает экземпляр редактируемой копии (глубокой копии) заданного объекта <see cref="T:System.Windows.Freezable" />, используя текущие значения свойства.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается <xref:System.Windows.Freezable.CloneCurrentValue%2A> методом и не должен вызываться непосредственно из кода, за исключением случаев вызова базовой реализации при переопределении этого метода. Чтобы создать изменяемую копию текущего объекта, вызовите <xref:System.Windows.Freezable.CloneCurrentValue%2A> метод вместо вызова этого метода напрямую.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Если вы наследуете <see cref="T:System.Windows.Freezable" />от, может потребоваться переопределить этот метод. Ниже перечислены причины переопределения. 
-У производного класса есть данные, которые не предоставляются через свойства зависимостей.  
  
— Ваш производный класс должен выполнять дополнительные операции инициализации, которые не могут быть выполнены путем <see cref="M:System.Windows.Freezable.CreateInstanceCore" />простого переопределения. Например, это применимо, если производный класс <see cref="T:System.ComponentModel.ISupportInitialize" />реализует.  
  
Классы, хранящие все свои данные в свойствах зависимостей и не требующие дополнительной работы по инициализации, не нуждаются в переопределении <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />.  
  
Важно, чтобы все реализации вызывали базовую реализацию этого метода. Реализации должны выполнять только работу, которая не выполняется реализацией по умолчанию. Реализация по умолчанию делает глубокие копии всех доступных для записи, локально заданных свойств. Если объект содержит свойства зависимостей с выражениями (например, с привязкой данных), то текущее значение выражения копируется, но не само выражение.  
  
Если объект имеет анимированные свойства зависимостей, то текущее анимированное значение этих свойств копируется, но анимация не выполняется.  
  
Обратите внимание, что неопределенные свойства не копируются и не являются свойствами только для чтения. Если такое свойство имеет зафиксированное <see cref="T:System.Windows.Freezable" />значение по умолчанию, значение этого свойства остается замороженным в случае неизменяемого клона.  
  
В следующем списке приводится сводка ожидаемого поведения для этого метода.  
  
— Созданная копия содержит копии всех <see cref="T:System.Windows.Freezable" /> подобъектов.  
  
-Не задавайте и свойства только для чтения не копируются.  
  
— Если свойство анимировано, копируется его текущее значение, а сама анимация — нет.  
  
— Ни один из этих вложенных объектов не замораживается при создании.  
  
— Сама копия не заморожена.</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected System.Windows.Freezable CreateInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Windows.Freezable CreateInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Function CreateInstance () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Freezable ^ CreateInstance();" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.Freezable" />.</summary>
        <returns>Новый экземпляр.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это защищенный метод, и фактические реализации конкретного объекта для поведения зависят от реализации <xref:System.Windows.Freezable.CreateInstanceCore%2A> метода, который этот метод вызывает внутренне.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Freezable.CreateInstanceCore" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected abstract System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Если реализуется в производном классе, создает новый экземпляр производного класса <see cref="T:System.Windows.Freezable" />.</summary>
        <returns>Новый экземпляр.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не вызывайте этот метод напрямую (за исключением вызова Base в реализации). Этот метод вызывается внутри <xref:System.Windows.Freezable.CreateInstance%2A> метода всякий раз, когда создается новый экземпляр <xref:System.Windows.Freezable> класса.  
  
   
  
## Examples  
 В следующем примере показана типичная реализация <xref:System.Windows.Freezable.CreateInstanceCore%2A>.  
  
 [!code-csharp[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/csharp/VS_Snippets_Wpf/freezablesample_procedural/CSharp/freezablesample.cs#createinstancecoreexample)]
 [!code-vb[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/freezablesample_procedural/visualbasic/freezablesample.vb#createinstancecoreexample)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Каждый <see cref="T:System.Windows.Freezable" /> производный класс должен реализовывать этот метод. Типичная реализация заключается в простом вызове конструктора без параметров и возврате результата.</para></block>
        <altmember cref="M:System.Windows.Freezable.CreateInstance" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Freeze">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Делает объект <see cref="T:System.Windows.Freezable" /> нередактируемым и определяет для его свойства <see cref="P:System.Windows.Freezable.IsFrozen" /> значение <see langword="true" /> или проверяет, можно ли объект <see cref="T:System.Windows.Freezable" /> сделать нередактируемым.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="public void Freeze ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Freeze() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze" />
      <MemberSignature Language="VB.NET" Value="Public Sub Freeze ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Freeze();" />
      <MemberSignature Language="F#" Value="member this.Freeze : unit -&gt; unit" Usage="freezable.Freeze " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Делает текущий объект неизменяемым и присваивает его свойству <see cref="P:System.Windows.Freezable.IsFrozen" /> значение <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы избежать возможности <xref:System.InvalidOperationException> при вызове этого метода, <xref:System.Windows.Freezable.CanFreeze%2A> проверьте свойство, чтобы определить, <xref:System.Windows.Freezable> можно ли сделать неизменяемым перед вызовом этого метода.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Объект <see cref="T:System.Windows.Freezable" /> невозможно сделать неизменяемым.</exception>
        <block subset="none" type="overrides"><para>Этот метод использует <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> метод, чтобы <see cref="T:System.Windows.Freezable" /> сделать неизменяемым. Чтобы изменить поведение замораживания, переопределите <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> метод.</para></block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="protected internal static bool Freeze (System.Windows.Freezable freezable, bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig bool Freeze(class System.Windows.Freezable freezable, bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static bool Freeze(System::Windows::Freezable ^ freezable, bool isChecking);" />
      <MemberSignature Language="F#" Value="static member Freeze : System.Windows.Freezable * bool -&gt; bool" Usage="System.Windows.Freezable.Freeze (freezable, isChecking)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="freezable" Type="System.Windows.Freezable" />
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="freezable">Объект, который необходимо проверить или сделать нередактируемым. Если параметр <paramref name="isChecking" /> имеет значение <see langword="true" />, объект проверяется, чтобы определить, можно ли его сделать нередактируемым. Если параметр <paramref name="isChecking" /> имеет значение <see langword="false" />, объект делается нередактируемым, если это возможно.</param>
        <param name="isChecking">Значение <see langword="true" /> показывает, что объект можно заморозить (замораживание на самом деле не выполняется); значение <see langword="false" /> показывает, что объект замораживается на самом деле.</param>
        <summary>Если параметр <paramref name="isChecking" /> имеет значение <see langword="true" />, данный метод показывает, можно ли сделать заданный объект <see cref="T:System.Windows.Freezable" /> нередактируемым. Если параметр <paramref name="isChecking" /> имеет значение <see langword="false" />, данный метод пытается сделать заданный объект <see cref="T:System.Windows.Freezable" /> нередактируемым и показывает, была ли операция успешной.</summary>
        <returns>Если параметр <paramref name="isChecking" /> имеет значение <see langword="true" />, этот метод возвращает значение <see langword="true" />, если заданный объект <see cref="T:System.Windows.Freezable" /> можно сделать нередактируемым, или значение <see langword="false" />, если такая возможность отсутствует. Если параметр <paramref name="isChecking" /> имеет значение <see langword="false" />, этот метод возвращает значение <see langword="true" />, если заданный объект <see cref="T:System.Windows.Freezable" /> сейчас является нередактируемым, или значение <see langword="false" />, если его нельзя сделать нередактируемым.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не вызывайте этот метод, если не выполняется наследование <xref:System.Windows.Freezable> от и <xref:System.Windows.Freezable.FreezeCore%2A> переопределение метода.  Этот метод можно использовать в <xref:System.Windows.Freezable.FreezeCore%2A> методе, чтобы заморозить члены данных класса, <xref:System.Windows.Freezable> являющиеся объектами.  
  
 Этот метод <xref:System.Windows.Freezable> хорошо вызывается для объекта, который уже заморожен (неизменяемый).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Если параметр <paramref name="isChecking" /> имеет значение <see langword="false" />, это показывает, что попытка сделать объект <paramref name="freezable" /> была безуспешной; теперь объект имеет неизвестное состояние (он может быть частично заморожен).</exception>
        <block subset="none" type="overrides"><para>Этот метод использует <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> метод, чтобы <see cref="T:System.Windows.Freezable" /> сделать неизменяемым. Чтобы изменить поведение замораживания, переопределите <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> метод.</para></block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected virtual bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function FreezeCore (isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool FreezeCore(bool isChecking);" />
      <MemberSignature Language="F#" Value="abstract member FreezeCore : bool -&gt; bool&#xA;override this.FreezeCore : bool -&gt; bool" Usage="freezable.FreezeCore isChecking" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking">Значение <see langword="true" /> показывает, что объект можно заморозить (замораживание на самом деле не выполняется); значение <see langword="false" /> показывает, что объект замораживается на самом деле.</param>
        <summary>Делает объект <see cref="T:System.Windows.Freezable" /> нередактируемым или проверяет, можно ли его сделать нередактируемым.</summary>
        <returns>Если параметр <paramref name="isChecking" /> имеет значение <see langword="true" />, этот метод возвращает значение <see langword="true" />, если данный объект <see cref="T:System.Windows.Freezable" /> можно сделать нередактируемым, или значение <see langword="false" />, если такая возможность отсутствует. Если параметр <paramref name="isChecking" /> имеет значение <see langword="false" />, этот метод возвращает значение <see langword="true" />, если заданный объект <see cref="T:System.Windows.Freezable" /> сейчас является нередактируемым, или значение <see langword="false" />, если его нельзя сделать нередактируемым.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не вызывайте этот метод напрямую (за исключением вызова Base в реализации). Этот метод <xref:System.Windows.Freezable.CanFreeze%2A> вызывается внутренним образом свойством (со `isChecking` значением, `true` <xref:System.Windows.Freezable.Freeze%2A> равным `false`) и методом ( `isChecking` со значением).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Windows.Freezable" />Разработчики должны переопределить этот метод, если класс содержит данные, которые не хранятся с помощью свойств зависимостей.  
  
Типичная реализация вызывает Base, затем вызывает статический <see cref="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" /> метод для всех <see cref="T:System.Windows.Freezable" /> типизированных свойств, содержащихся в классе, и <see langword="true" /> возвращает, только если все свойства были заморожены (или могут быть заморожены) в случае указания <see langword="true" /> для <paramref name="isChecking" /> ).</para></block>
        <altmember cref="M:System.Windows.Freezable.Freeze" />
        <altmember cref="P:System.Windows.Freezable.CanFreeze" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает фиксированную копию объекта <see cref="T:System.Windows.Freezable" />, используя базовые (не анимационные) значения свойств. Так как копия является фиксированной, копируются только ссылки на фиксированные вложенные объекты.</summary>
        <returns>Фиксированная копия объекта <see cref="T:System.Windows.Freezable" />. Свойство копии <see cref="P:System.Windows.Freezable.IsFrozen" /> имеет значение <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Перед вызовом этого <xref:System.Windows.Freezable.CanFreeze%2A> метода следует проверить свойство, чтобы убедиться, что <xref:System.Windows.Freezable> объект может быть заморожен. Использование этого метода аналогично созданию копии с помощью, <xref:System.Windows.Freezable.Clone%2A> а затем замораживанию <xref:System.Windows.Freezable.Freeze%2A> с помощью метода.  
  
 Методы <xref:System.Windows.Freezable.GetAsFrozen%2A> <xref:System.Windows.Freezable> и <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> могут повысить производительность при копировании, поскольку не клонировать подобъекты, которые уже заморожены. они копируют только их по ссылке.  
  
 В следующей таблице приведены различия между <xref:System.Windows.Freezable.GetAsFrozen%2A> методами и. <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>  
  
|Действие|Поведение метода Жетасфрозен|Поведение метода Жеткуррентвалуеасфрозен|  
|------------|---------------------------------|---------------------------------------------|  
|Копирование свойства зависимостей, имеющего выражение|Метод создает исключение, <xref:System.InvalidOperationException> поскольку не может <xref:System.Windows.Freezable.Freeze%2A> быть свойством.|Текущее значение выражения копируется, но не само выражение.|  
|Копирование анимированного свойства зависимостей|Копируется базовое (не анимационное) значение свойства. Анимации не копируются.|Копируется текущее анимированное значение свойства. Анимации не копируются.|  
  
 Обратите внимание, что неопределенные свойства не копируются и не являются свойствами только для чтения.  
  
 Чтобы создать копию <xref:System.Windows.Freezable> незамороженного объекта, <xref:System.Windows.Freezable.Clone%2A> используйте метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Объект <see cref="T:System.Windows.Freezable" /> нельзя заморозить, так как он включает выражения или анимационные свойства.</exception>
        <block subset="none" type="overrides"><para>Этот метод использует виртуальный <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" /> метод для создания клона.</para></block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Экземпляр, который копируется.</param>
        <summary>Создает экземпляр фиксированной копии заданного объекта <see cref="T:System.Windows.Freezable" />, используя базовые (не анимационные) значения свойства.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается <xref:System.Windows.Freezable.GetAsFrozen%2A> методом и не должен вызываться непосредственно из кода, за исключением случаев вызова базовой реализации при переопределении этого метода. Чтобы создать замороженную копию текущего объекта, вызовите <xref:System.Windows.Freezable.GetAsFrozen%2A> метод вместо вызова этого метода напрямую.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При наследовании от <see cref="T:System.Windows.Freezable" /> может потребоваться переопределить этот метод. Ниже перечислены причины переопределения. 
-У производного класса есть данные, которые не предоставляются через свойства зависимостей.  
  
— Ваш производный класс должен выполнять дополнительные операции инициализации, которые не могут быть выполнены путем <see cref="M:System.Windows.Freezable.CreateInstanceCore" />простого переопределения. Например, это применимо, если производный класс <see cref="T:System.ComponentModel.ISupportInitialize" />реализует.  
  
Классы, хранящие все свои данные в свойствах зависимостей и не требующие дополнительной работы по инициализации, не нуждаются в переопределении <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />.  
  
Важно, чтобы все реализации вызывали базовую реализацию этого метода. Реализации должны выполнять только работу, которая не выполняется реализацией по умолчанию. Реализация по умолчанию создает глубокие копии всех незамороженных элементов Freezable и поверхностных копий всех других доступных для записи свойств, которые задаются локально. Если объект имеет свойства зависимостей, привязанные к данным, выражения копируются, но могут больше не разрешаться; Дополнительные сведения о клонировании объектов, привязанных к данным, см. в разделе [Общие сведения об объектах Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md). Если объект имеет анимированные свойства зависимостей, копируются базовые (неанимированные) значения этих свойств. Анимации не копируются.  
  
Обратите внимание, что неопределенные свойства не копируются и не являются свойствами только для чтения.  
  
При переопределении этого метода необходимо вызвать базовую реализацию.  
  
При копировании <see cref="M:System.Windows.Freezable.Freeze" /> значения не нужны.  Результат зафиксируется <see cref="M:System.Windows.Freezable.GetAsFrozen" /> перед возвратом.</para></block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozen" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetCurrentValueAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetCurrentValueAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentValueAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetCurrentValueAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentValueAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetCurrentValueAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает фиксированную копию объекта <see cref="T:System.Windows.Freezable" /> с использованием текущих значений свойств. Так как копия является фиксированной, копируются только ссылки на фиксированные вложенные объекты.</summary>
        <returns>Фиксированная копия объекта <see cref="T:System.Windows.Freezable" />. Свойство копии <see cref="P:System.Windows.Freezable.IsFrozen" /> имеет значение <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Использование этого метода аналогично созданию копии с помощью, <xref:System.Windows.Freezable.CloneCurrentValue%2A> а затем замораживанию <xref:System.Windows.Freezable.Freeze%2A> с помощью метода.  
  
 Методы <xref:System.Windows.Freezable.GetAsFrozen%2A> <xref:System.Windows.Freezable> и <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> могут повысить производительность при копировании, поскольку не клонировать подобъекты, которые уже заморожены. они копируют только их по ссылке.  
  
 В следующей таблице приведены различия между <xref:System.Windows.Freezable.GetAsFrozen%2A> методами и. <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>  
  
|Действие|Поведение метода Жетасфрозен|Поведение метода Жеткуррентвалуеасфрозен|  
|------------|---------------------------------|---------------------------------------------|  
|Копирование свойства зависимостей, имеющего выражение|Метод создает исключение, <xref:System.InvalidOperationException> поскольку не может <xref:System.Windows.Freezable.Freeze%2A> быть свойством.|Текущее значение выражения копируется, но не само выражение.|  
|Копирование анимированного свойства зависимостей|Копируется базовое (не анимационное) значение свойства. Анимации не копируются.|Копируется текущее анимированное значение свойства. Анимации не копируются.|  
  
 Обратите внимание, что неопределенные свойства не копируются и не являются свойствами только для чтения.  
  
 Чтобы создать копию <xref:System.Windows.Freezable> незамороженного объекта, <xref:System.Windows.Freezable.CloneCurrentValue%2A> используйте метод.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Этот метод использует виртуальный <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" /> метод для создания клона.</para></block>
        <altmember cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetCurrentValueAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Объект <see cref="T:System.Windows.Freezable" />, который необходимо скопировать и заморозить.</param>
        <summary>Создает текущий экземпляр замороженной копии указанного объекта <see cref="T:System.Windows.Freezable" />. Если объект имеет анимированные свойства зависимостей, копируются их текущие анимированные значения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> методом и не должен вызываться непосредственно из кода, за исключением случаев вызова базовой реализации при переопределении этого метода. Чтобы создать замороженную копию текущего объекта, вызовите <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> метод вместо вызова этого метода напрямую.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Если вы наследуете <see cref="T:System.Windows.Freezable" />от, может потребоваться переопределить этот метод. Ниже перечислены причины переопределения. 
-У производного класса есть данные, которые не предоставляются через свойства зависимостей.  
  
— Ваш производный класс должен выполнять дополнительные операции инициализации, которые не могут быть выполнены путем <see cref="M:System.Windows.Freezable.CreateInstanceCore" />простого переопределения. Например, это применимо, если производный класс <see cref="T:System.ComponentModel.ISupportInitialize" />реализует.  
  
Классы, хранящие все свои данные в свойствах зависимостей и не требующие дополнительной работы по инициализации, не нуждаются в переопределении <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />.  
  
Важно, чтобы все реализации вызывали базовую реализацию этого метода. Реализации должны выполнять только работу, которая не выполняется реализацией по умолчанию. Реализация по умолчанию создает новый <see cref="T:System.Windows.Freezable" /> <see cref="M:System.Windows.Freezable.CreateInstance" /> метод с помощью метода и создает глубокие копии незамороженных зафиксированных элементов Freezable и неполные копии всех остальных доступных для записи свойств, которые в нем содержатся локально. Если объект имеет свойства зависимостей, привязанные к данным, привязки данных копируются, но могут больше не разрешаться; Дополнительные сведения о клонировании объектов, привязанных к данным, см. в разделе [Общие сведения об объектах Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md). Если объект имеет анимированные свойства зависимостей, то текущее анимированное значение этих свойств копируется, но анимация не выполняется.  
  
Свойства зависимостей, доступные только для чтения <see cref="T:System.Windows.Freezable" /> в, не копируются этой реализацией по умолчанию.  
  
При переопределении этого метода необходимо вызвать базовую реализацию.  
  
При копировании <see cref="M:System.Windows.Freezable.Freeze" /> значения не нужны.  Результат зафиксируется <see cref="M:System.Windows.Freezable.GetAsFrozen" /> перед возвратом.</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="IsFrozen">
      <MemberSignature Language="C#" Value="public bool IsFrozen { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFrozen" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.IsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFrozen As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFrozen { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFrozen : bool" Usage="System.Windows.Freezable.IsFrozen" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, доступен ли объект для изменения в настоящее время.</summary>
        <value>Значение <see langword="true" />, если объект заморожен и не может быть изменен; значение <see langword="false" />, если объект может быть изменен.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Попытка изменить объект, <xref:System.Windows.Freezable.IsFrozen%2A> `true` если его свойство создает <xref:System.InvalidOperationException>исключение.  
  
 Это свойство доступно только для чтения с точки зрения объектной модели. В некоторых документах о <xref:System.Windows.Freezable> поведении может упоминаться «установка `true` <xref:System.Windows.Freezable.IsFrozen%2A> в» или аналогичного языка <xref:System.Windows.Freezable>при обсуждении поведения других методов, но такое поведение происходит внутри экземпляров класса, когда методы экземпляра управляют закрытыми переменными, которые существуют в абстрактном классе. Чтобы задать значение этого свойства, следует вызвать метод <xref:System.Windows.Freezable.Freeze%2A>. Это является одноразовой операцией для изменения <xref:System.Windows.Freezable.IsFrozen%2A> свойства из первоначального состояния по умолчанию `false` на `true` состояние. Нет доступных средств для установки значения обратно `false`. Вместо этого можно изменить любую глубокую копию из исходной (см <xref:System.Windows.Freezable.Clone%2A> . метод). Это характерно и то, как любой производный класс должен вести себя при применении к случаям <xref:System.Windows.Freezable> , когда шаблон полезен.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChanged() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnChanged ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnChanged();" />
      <MemberSignature Language="F#" Value="abstract member OnChanged : unit -&gt; unit&#xA;override this.OnChanged : unit -&gt; unit" Usage="freezable.OnChanged " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вызывается при изменении текущего объекта <see cref="T:System.Windows.Freezable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается при каждом <xref:System.Windows.Freezable.Changed> возникновении события.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При реализации класса, производного от <see cref="T:System.Windows.Freezable" />, этот метод можно переопределить для выполнения задач.</para></block>
        <altmember cref="E:System.Windows.Freezable.Changed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OnFreezablePropertyChanged">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Обеспечивает создание соответствующих указателей контекста для элемента данных типа <see cref="T:System.Windows.DependencyObject" />, который был изменен.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldValue">Предыдущее значение элемента данных.</param>
        <param name="newValue">Текущее значение элемента данных.</param>
        <summary>Обеспечивает создание соответствующих указателей контекста для элемента данных типа <see cref="T:System.Windows.DependencyObjectType" />, который был только что задан.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод должен вызываться <xref:System.Windows.Freezable> наследниками каждый <xref:System.Windows.DependencyObject> раз, когда задается элемент данных, не хранящийся в виде <xref:System.Windows.DependencyProperty> .  
  
 Этот метод не требуется вызывать для <xref:System.Windows.DependencyObject> элементов данных, которые хранятся <xref:System.Windows.DependencyProperty>с помощью.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue, System.Windows.DependencyProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue, class System.Windows.DependencyProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject, property As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue, System::Windows::DependencyProperty ^ property);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue, property)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="property" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="oldValue">Предыдущее значение элемента данных.</param>
        <param name="newValue">Текущее значение элемента данных.</param>
        <param name="property">Измененное свойство.</param>
        <summary>Этот член поддерживает инфраструктуру [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] и не предназначен для непосредственного использования из кода.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="freezable.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Данные события, содержащие сведения об изменении свойства и его старое и новое значения.</param>
        <summary>Переопределяет реализацию <see cref="T:System.Windows.DependencyObject" /> для <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />, чтобы также вызвать любой обработчик <see cref="E:System.Windows.Freezable.Changed" /> в ответ на изменение свойства зависимостей типа <see cref="T:System.Windows.Freezable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данные события содержат сведения только <xref:System.Windows.Freezable> о самом себе. Все сведения о подсвойствах должны быть получены с <xref:System.Windows.Freezable.Changed> помощью обработчиков.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadPreamble">
      <MemberSignature Language="C#" Value="protected void ReadPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ReadPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.ReadPreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ReadPreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ReadPreamble();" />
      <MemberSignature Language="F#" Value="member this.ReadPreamble : unit -&gt; unit" Usage="freezable.ReadPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Обеспечивает доступ к <see cref="T:System.Windows.Freezable" /> из допустимого потока. Наследники объекта <see cref="T:System.Windows.Freezable" /> должны вызывать данный метод в начале любого [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)], который считывает элементы данных, не являющиеся свойствами зависимостей.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Классы, производные от <see cref="T:System.Windows.Freezable" /> , должны <see cref="M:System.Windows.Freezable.ReadPreamble" /> вызывать метод перед попыткой получить доступ к любым элементам, которые не являются свойствами зависимостей. <see cref="M:System.Windows.Freezable.WritePreamble" /> Метод должен вызываться до того, как будут записаны все такие члены.  
  
Этот метод фактически делает ничего больше, чем <see cref="M:System.Windows.Threading.DispatcherObject.VerifyAccess" />вызов.</para></block>
        <altmember cref="M:System.Windows.Freezable.WritePreamble" />
      </Docs>
    </Member>
    <Member MemberName="WritePostscript">
      <MemberSignature Language="C#" Value="protected void WritePostscript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePostscript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePostscript" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePostscript ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePostscript();" />
      <MemberSignature Language="F#" Value="member this.WritePostscript : unit -&gt; unit" Usage="freezable.WritePostscript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вызывает событие <see cref="E:System.Windows.Freezable.Changed" /> для объекта <see cref="T:System.Windows.Freezable" /> и вызывает его метод <see cref="M:System.Windows.Freezable.OnChanged" />. Классы, производные от <see cref="T:System.Windows.Freezable" />, должны вызывать этот метод в конце любого API, который изменяет члены класса, не сохраненные в виде свойств зависимостей.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Классы, производные от <see cref="T:System.Windows.Freezable" /> , должны вызывать этот метод в конце любого API-интерфейса, изменяющего член класса, который не хранится в <see cref="T:System.Windows.DependencyProperty" />виде.</para></block>
      </Docs>
    </Member>
    <Member MemberName="WritePreamble">
      <MemberSignature Language="C#" Value="protected void WritePreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePreamble();" />
      <MemberSignature Language="F#" Value="member this.WritePreamble : unit -&gt; unit" Usage="freezable.WritePreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Проверяет, что объект <see cref="T:System.Windows.Freezable" /> не заморожен и доступ к нему осуществляется из допустимого контекста потока. Наследники объекта <see cref="T:System.Windows.Freezable" /> должны вызывать данный метод в начале любого [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)], который выполняет запись в элементах данных, не являющихся свойствами зависимостей.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывает <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> , чтобы проверить, доступен <xref:System.Windows.Freezable> ли контекст потоковой обработки, и создает исключение, если экземпляр уже заморожен.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Экземпляр <see cref="T:System.Windows.Freezable" /> заморожен, и запись в его члены невозможна.</exception>
        <block subset="none" type="overrides"><para>Классы, производные от <see cref="T:System.Windows.Freezable" /> , должны <see cref="M:System.Windows.Freezable.WritePreamble" /> вызываться перед попыткой записи в любые члены, не являющиеся свойствами зависимостей. При вызове <see cref="M:System.Windows.Freezable.WritePreamble" /> [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] в <see cref="M:System.Windows.Freezable.ReadPreamble" /> можно опустить вызов.</para></block>
        <altmember cref="M:System.Windows.Freezable.ReadPreamble" />
      </Docs>
    </Member>
  </Members>
</Type>
