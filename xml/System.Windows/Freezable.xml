<Type Name="Freezable" FullName="System.Windows.Freezable">
  <Metadata><Meta Name="ms.openlocfilehash" Value="666b4c45528d1a4fc25516699cd25e3d50389a70" /><Meta Name="ms.sourcegitcommit" Value="7845f124909a0999a19cc65f40feab5e75cd9b8d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="05/06/2019" /><Meta Name="ms.locfileid" Value="65064726" /></Metadata><TypeSignature Language="C#" Value="public abstract class Freezable : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Freezable extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Freezable" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Freezable&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class Freezable abstract : System::Windows::DependencyObject" />
  <TypeSignature Language="F#" Value="type Freezable = class&#xA;    inherit DependencyObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Определяет объект, имеющий изменяемое состояние и состояние только для чтения (зафиксированное). Классы, производные от <see cref="T:System.Windows.Freezable" />, предоставляют подробные уведомления об изменениях, могут быть неизменяемыми и могут копировать себя.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Freezable> Класс предоставляет специальные функции, которые могут помочь повысить производительность приложений при работе с объектами, которые могут изменять или копировать. Примеры <xref:System.Windows.Freezable> объектам относятся следующие:  
  
-   <xref:System.Windows.Media.Brush>  
  
-   <xref:System.Windows.Media.Pen>  
  
-   <xref:System.Windows.Media.Geometry>  
  
-   <xref:System.Windows.Media.Transform>  
  
-   <xref:System.Windows.Media.Animation.AnimationTimeline>  
  
## <a name="deriving-from-freezable"></a>Наследование от класса Freezable  
 Класс, производный от <xref:System.Windows.Freezable> поддерживает следующие функции:  
  
-   Особые состояния: состояние только для чтения (зафиксированное) и состояние для записи.  
  
-   Потокобезопасность: зафиксированный <xref:System.Windows.Freezable> объект может использоваться несколькими потоками.  
  
-   Подробные уведомления об изменениях: В отличие от других <xref:System.Windows.DependencyObject> объектов, <xref:System.Windows.Freezable> объект предоставляет уведомления об изменениях, при изменении значений вложенных свойств.  
  
-   Удобное клонирование: Freezable класс уже реализовал несколько методов, которые обеспечивают большую глубину клонирования.  
  
 Сведения об использовании и создании собственных <xref:System.Windows.Freezable> объектов, см. в разделе [Freezable Общие сведения об объектах](~/docs/framework/wpf/advanced/freezable-objects-overview.md).  
  
 ]]></format>
    </remarks>
    <threadsafe>Любые открытые <see langword="static" /> члены этого типа являются потокобезопасными. Потокобезопасность членов экземпляров не гарантируется.  
  
Когда <see cref="P:System.Windows.Freezable.IsFrozen" /> свойство <see langword="false" />, <see cref="T:System.Windows.Freezable" /> объектов может осуществляться только из потока, в котором он был создан. Попытка доступа к нему из другой поток вызывает <see cref="T:System.InvalidOperationException" />. <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> И <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> методы предоставляют поддержку для маршалинга в нужный поток.  
  
При их <see cref="P:System.Windows.Freezable.IsFrozen" /> свойство <see langword="true" />, <see cref="T:System.Windows.Freezable" /> объекты доступны из любого потока.  Дополнительные сведения см. в разделе [Общие сведения об объектах класса Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Freezable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Freezable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.Freezable" /> производного класса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это защищенный конструктор абстрактного класса.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanFreeze">
      <MemberSignature Language="C#" Value="public bool CanFreeze { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanFreeze" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.CanFreeze" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanFreeze As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanFreeze { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanFreeze : bool" Usage="System.Windows.Freezable.CanFreeze" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, которое указывает, можно ли сделать объект неизменяемым.</summary>
        <value>Значение <see langword="true" />, если текущий объект можно сделать неизменяемым или если он уже является неизменяемым; в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>В этой реализации метода используется <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> метод с <paramref name="isChecking" /> присвоено <see langword="true" /> для определения ли <see cref="T:System.Windows.Freezable" /> может быть сделан неизменяемым. Чтобы изменить способ, это свойство работает в производном классе, переопределять <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> метод.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event EventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Freezable.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : EventHandler " Usage="member this.Changed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при <see cref="T:System.Windows.Freezable" /> или изменении объекта он содержит.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При попытке добавления или удаления обработчиков событий в том случае, если текущий объект не является изменяемым (когда <xref:System.Windows.Freezable.IsFrozen%2A> свойство `true`), создается исключение.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ Clone();" />
      <MemberSignature Language="F#" Value="member this.Clone : unit -&gt; System.Windows.Freezable" Usage="freezable.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает изменяемый клон данного объекта <see cref="T:System.Windows.Freezable" />, делая глубокие копии значений этого объекта. При копировании свойств зависимостей объекта этот метод копирует выражения (которые могут уже не быть разрешимыми), но не копирует анимации и их текущие значения.</summary>
        <returns>Изменяемая копия текущего объекта. Свойство <see cref="P:System.Windows.Freezable.IsFrozen" /> клонированного объекта имеет значение <see langword="false" />, даже если свойство <see cref="P:System.Windows.Freezable.IsFrozen" /> исходного объекта имеет значение <see langword="true." />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Freezable.Clone%2A> И <xref:System.Windows.Freezable.CloneCurrentValue%2A> методы производят изменяемые клоны замороженный <xref:System.Windows.Freezable> объектов (методы также клонировать <xref:System.Windows.Freezable> объекты, которые не зафиксированы). Копия является фактически глубокую копию текущего объекта.  
  
 В следующей таблице перечислены различия между <xref:System.Windows.Freezable.Clone%2A> и <xref:System.Windows.Freezable.CloneCurrentValue%2A> методы.  
  
|Действие|Поведение метода клона|Поведение метода CloneCurrentValue|  
|------------|---------------------------|---------------------------------------|  
|Копирует свойство зависимостей, которое содержит выражение|Выражение копируется, но могут уже не быть разрешимыми. Дополнительные сведения см. в разделе [Общие сведения об объектах класса Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).|Копируется текущее значение выражения, но не само выражение.|  
|Копирование также анимированными свойствами зависимостей|Копируется базовое значение свойства (не анимационные). Анимации не копируются.|Копируется текущее анимированное значение свойства. Анимации не копируются.|  
  
 Обратите внимание, что неопределенные свойства не копируются. Если не задано свойство имеет значение по умолчанию, который является зафиксированного <xref:System.Windows.Freezable>, что значение свойства остается фиксированным, в противном случае редактируется.  
  
## <a name="move-a-freezable-between-threads"></a>Переместить Freezable между потоками  
 Этот метод может быть полезен при перемещении <xref:System.Windows.Freezable> между потоками. Во-первых, <xref:System.Windows.Freezable> нередактируемым, вызвав его <xref:System.Windows.Freezable.Freeze%2A> метод. Теперь можно получить доступ к другим потоком <xref:System.Windows.Freezable> и сделать локальный <xref:System.Windows.Freezable.Clone%2A> , можно получить доступ.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Этот метод использует <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> для создания клона. Чтобы изменить поведение этого метода в производном классе, переопределять <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> метод.</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
        <altmember cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Объект, используемый для клонирования.</param>
        <summary>Делает экземпляр клоном (глубокой копией) указанного объекта <see cref="T:System.Windows.Freezable" />, используя базовые (без анимации) значения свойств.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается <xref:System.Windows.Freezable.Clone%2A> метода и не должен вызываться непосредственно из программного кода, за исключением при вызове базовой реализации при переопределении данного метода. Чтобы создать изменяемая копия текущего объекта, вызовите <xref:System.Windows.Freezable.Clone%2A> вместо прямого вызова этого метода.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Если вы наследуете от <see cref="T:System.Windows.Freezable" />, может потребоваться переопределить этот метод. Чтобы переопределить следующие причины: 
— Производный класс включает данные, которые не предоставляются через свойства зависимостей.  
  
-Производного класса необходимо выполнить дополнительную инициализацию работы, которая не может быть выполнен, просто переопределив метод <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Например, это применимо, если производный класс реализует <see cref="T:System.ComponentModel.ISupportInitialize" />.  
  
Классы, в которых хранятся все свои данные в свойствах зависимости и, не обязательно для выполнения дополнительной инициализации не требуется переопределять <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />.  
  
Очень важно, что все реализации вызывать базовую реализацию этого метода. Реализации должны выполнять работу, выполняемую в реализации по умолчанию не только. Реализация по умолчанию делает глубокие копии все записи, локально заданного свойства, включая внутренние выражения.  
  
Если объект имеет свойства зависимостей с привязкой к данным, выражения копируются, но могут уже не быть разрешимыми. Дополнительные сведения о клонировании объектов с привязкой к данным, см. в разделе [Freezable Общие сведения об объектах](~/docs/framework/wpf/advanced/freezable-objects-overview.md). Если объект имеет анимированные свойства зависимостей, копируется базовое значение (не анимационные) из этих свойств. Анимации не копируются.  
  
Обратите внимание, что неопределенные свойства не копируются, а также доступны только для чтения. Если такое свойство имеет значение по умолчанию, который является зафиксированного <see cref="T:System.Windows.Freezable" />, что значение свойства остается фиксированным, в противном случае редактируется.  
  
В следующем списке перечислены ожидаемое поведение для этого метода: 
— Копирование созданных содержит копии всех <see cref="T:System.Windows.Freezable" /> вложенные объекты.  
  
-Свойства unset, только для чтения, не копируются.  
  
-Выражения копируются.  
  
-Ни один из этих вложенных объектов фиксируются при создании.  
  
-Сама копия не зафиксирован.  
  
-Анимации не копируются.  
  
-Только базовые значения свойств являются копируются, а не текущие анимированные значения.</para></block>
        <altmember cref="M:System.Windows.Freezable.Clone" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValue" />
      <MemberSignature Language="VB.NET" Value="Public Function CloneCurrentValue () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ CloneCurrentValue();" />
      <MemberSignature Language="F#" Value="member this.CloneCurrentValue : unit -&gt; System.Windows.Freezable" Usage="freezable.CloneCurrentValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает модифицируемый клон (глубокой копией) <see cref="T:System.Windows.Freezable" /> с использованием его текущих значений.</summary>
        <returns>Изменяемая копия текущего объекта. Свойство <see cref="P:System.Windows.Freezable.IsFrozen" /> клонированного объекта имеет значение <see langword="false" />, даже если свойство <see cref="P:System.Windows.Freezable.IsFrozen" /> исходного объекта имеет значение <see langword="true." />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Freezable.Clone%2A> И <xref:System.Windows.Freezable.CloneCurrentValue%2A> методы производят изменяемые клоны замороженный <xref:System.Windows.Freezable> объектов (методы также клонировать <xref:System.Windows.Freezable> объекты, которые не зафиксированы). Копия является фактически глубокую копию текущего объекта.  
  
 В следующей таблице перечислены различия между <xref:System.Windows.Freezable.Clone%2A> и <xref:System.Windows.Freezable.CloneCurrentValue%2A> методы.  
  
|Действие|Поведение метода клона|Поведение метода CloneCurrentValue|  
|------------|---------------------------|---------------------------------------|  
|Копирует свойство зависимостей, которое содержит выражение|Выражение копируется, но могут уже не быть разрешимыми. Дополнительные сведения см. в разделе [Общие сведения об объектах класса Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).|Копируется текущее значение выражения, но не само выражение.|  
|Копирование также анимированными свойствами зависимостей|Копируется базовое значение свойства (не анимационные). Анимации не копируются.|Копируется текущее анимированное значение свойства. Анимации не копируются.|  
  
 Обратите внимание, что неопределенные свойства не копируются. Если не задано свойство имеет значение по умолчанию, который является зафиксированного <xref:System.Windows.Freezable>, что значение свойства остается фиксированным, в противном случае редактируется.  
  
## <a name="move-a-freezable-between-threads"></a>Переместить Freezable между потоками  
 Этот метод может быть полезен при перемещении <xref:System.Windows.Freezable> между потоками. Во-первых, <xref:System.Windows.Freezable> нередактируемым, используя его <xref:System.Windows.Freezable.Freeze%2A> метод. Теперь можно получить доступ к другим потоком <xref:System.Windows.Freezable> и локального клона, можно получить доступ.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Этот метод использует <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> метод для создания клона; <see cref="T:System.Windows.Freezable" /> разработчиков, переопределить <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> необходимо убедиться, что копия не является фиксированной при создании.</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCurrentValueCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCurrentValueCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCurrentValueCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Элемент привязки <see cref="T:System.Windows.Freezable" />, точную копию которого необходимо создать.</param>
        <summary>Делает экземпляр изменяемым клоном (глубокой копией) указанного объекта <see cref="T:System.Windows.Freezable" /> с использованием текущих значений свойств.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается <xref:System.Windows.Freezable.CloneCurrentValue%2A> метода и не должен вызываться непосредственно из программного кода, за исключением при вызове базовой реализации при переопределении данного метода. Чтобы создать изменяемая копия текущего объекта, вызовите <xref:System.Windows.Freezable.CloneCurrentValue%2A> вместо прямого вызова этого метода.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Если вы наследуете от <see cref="T:System.Windows.Freezable" />, может потребоваться переопределить этот метод. Чтобы переопределить следующие причины: 
— Производный класс включает данные, которые не предоставляются через свойства зависимостей.  
  
-Производного класса необходимо выполнить дополнительную инициализацию работы, которая не может быть выполнен, просто переопределив метод <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Например, это применимо, если производный класс реализует <see cref="T:System.ComponentModel.ISupportInitialize" />.  
  
Классы, в которых хранятся все свои данные в свойствах зависимости и, не обязательно для выполнения дополнительной инициализации не требуется переопределять <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />.  
  
Очень важно, что все реализации вызывать базовую реализацию этого метода. Реализации должны выполнять работу, выполняемую в реализации по умолчанию не только. Реализация по умолчанию делает глубокие копии все записи, локально заданного свойства. Если объект содержит свойств зависимостей с помощью выражения (например, привязка данных), но не само выражение копируется текущее значение выражения.  
  
Если объект имеет анимированные свойства зависимостей, копируется текущее анимированное значение этих свойств, но не сами анимации.  
  
Обратите внимание, что неопределенные свойства не копируются, а также доступны только для чтения. Если такое свойство имеет значение по умолчанию, который является зафиксированного <see cref="T:System.Windows.Freezable" />, что значение свойства остается фиксированным, в противном случае редактируется.  
  
В следующем списке перечислены ожидаемое поведение для этого метода.  
  
— Копирование созданных содержит копии всех <see cref="T:System.Windows.Freezable" /> вложенные объекты.  
  
-Свойства unset, только для чтения, не копируются.  
  
— Если свойство анимируется, его текущее значение копируется, но не сама анимация.  
  
-Ни один из этих вложенных объектов фиксируются при создании.  
  
-Сама копия не зафиксирован.</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected System.Windows.Freezable CreateInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Windows.Freezable CreateInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Function CreateInstance () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Freezable ^ CreateInstance();" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.Freezable" />.</summary>
        <returns>Новый экземпляр.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это защищенный метод, и фактические реализации отдельных объектов для поведения зависят от переопределения <xref:System.Windows.Freezable.CreateInstanceCore%2A> метод, который внутренне вызывает этот метод.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Freezable.CreateInstanceCore" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected abstract System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При реализации в производном классе создает новый экземпляр класса <see cref="T:System.Windows.Freezable" /> производного класса.</summary>
        <returns>Новый экземпляр.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не вызывайте этот метод напрямую (за исключением случаев вызова базового метода в реализации). Этот метод вызывается функцией <xref:System.Windows.Freezable.CreateInstance%2A> метод всякий раз, когда новый экземпляр класса <xref:System.Windows.Freezable> создается.  
  
   
  
## Examples  
 Пример типичной реализации <xref:System.Windows.Freezable.CreateInstanceCore%2A>.  
  
 [!code-csharp[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/csharp/VS_Snippets_Wpf/freezablesample_procedural/CSharp/freezablesample.cs#createinstancecoreexample)]
 [!code-vb[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/freezablesample_procedural/visualbasic/freezablesample.vb#createinstancecoreexample)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Каждый <see cref="T:System.Windows.Freezable" /> производный класс должен реализовывать этот метод. Типичная реализация — это просто вызов конструктора по умолчанию и возвращается результат.</para></block>
        <altmember cref="M:System.Windows.Freezable.CreateInstance" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Freeze">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Делает <see cref="T:System.Windows.Freezable" /> нередактируемым и устанавливает его <see cref="P:System.Windows.Freezable.IsFrozen" /> свойства <see langword="true" />, или тесты ли <see cref="T:System.Windows.Freezable" /> объект может быть сделан неизменяемым.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="public void Freeze ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Freeze() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze" />
      <MemberSignature Language="VB.NET" Value="Public Sub Freeze ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Freeze();" />
      <MemberSignature Language="F#" Value="member this.Freeze : unit -&gt; unit" Usage="freezable.Freeze " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Делает текущий объект неизменяемым и присваивает его свойству <see cref="P:System.Windows.Freezable.IsFrozen" /> значение <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы защититься от <xref:System.InvalidOperationException> при вызове этого метода, проверьте <xref:System.Windows.Freezable.CanFreeze%2A> свойства, чтобы определить ли <xref:System.Windows.Freezable> может быть сделан неизменяемым перед вызовом этого метода.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Объект <see cref="T:System.Windows.Freezable" /> невозможно сделать неизменяемым.</exception>
        <block subset="none" type="overrides"><para>Этот метод использует <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> метод для приготовления <see cref="T:System.Windows.Freezable" /> неизменяемым. Чтобы изменить блокированием, переопределить <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> метод.</para></block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="protected internal static bool Freeze (System.Windows.Freezable freezable, bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig bool Freeze(class System.Windows.Freezable freezable, bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static bool Freeze(System::Windows::Freezable ^ freezable, bool isChecking);" />
      <MemberSignature Language="F#" Value="static member Freeze : System.Windows.Freezable * bool -&gt; bool" Usage="System.Windows.Freezable.Freeze (freezable, isChecking)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="freezable" Type="System.Windows.Freezable" />
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="freezable">Объект, который необходимо проверить или сделать нередактируемым. Если <paramref name="isChecking" /> является <see langword="true" />, объект проверяется, чтобы определить, может ли он быть сделан неизменяемым. Если <paramref name="isChecking" /> является <see langword="false" />, объект делается нередактируемым, если это возможно.</param>
        <param name="isChecking"><see langword="true" /> Чтобы показывает, является ли объект можно заморозить (без замораживание на самом деле он); <see langword="false" /> фактически Закрепление объекта.</param>
        <summary>Если <paramref name="isChecking" /> параметр <see langword="true" />, этот метод указывает ли указанный <see cref="T:System.Windows.Freezable" /> может быть сделан неизменяемым. Если <paramref name="isChecking" /> параметр <see langword="false" />, этот метод пытается сделать заданный <see cref="T:System.Windows.Freezable" /> нередактируемым и показывает, успешно ли выполнена операция.</summary>
        <returns>Если <paramref name="isChecking" /> — <see langword="true" />, этот метод возвращает <see langword="true" /> Если указанного <see cref="T:System.Windows.Freezable" /> можно сделать нередактируемым, или <see langword="false" /> если его невозможно сделать неизменяемым. Если <paramref name="isChecking" /> — <see langword="false" />, этот метод возвращает <see langword="true" /> Если указанного <see cref="T:System.Windows.Freezable" /> сейчас является нередактируемым, или <see langword="false" /> если его невозможно сделать неизменяемым.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не вызывается, если при наследовании от <xref:System.Windows.Freezable> и переопределение <xref:System.Windows.Freezable.FreezeCore%2A> метод.  Этот метод может использоваться в <xref:System.Windows.Freezable.FreezeCore%2A> метод, чтобы закрепить данные-члены класса, которые сами <xref:System.Windows.Freezable> объектов.  
  
 Можно снова вызвать этот метод для <xref:System.Windows.Freezable> объект, который уже был заморожен (неизменяемым).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Когда <paramref name="isChecking" /> — <see langword="false" />, что попытка сделать <paramref name="freezable" /> была безуспешной; теперь объект имеет неизвестное состояние (он может быть частично заморожен).</exception>
        <block subset="none" type="overrides"><para>Этот метод использует <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> метод для приготовления <see cref="T:System.Windows.Freezable" /> неизменяемым. Чтобы изменить блокированием, переопределить <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> метод.</para></block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected virtual bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function FreezeCore (isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool FreezeCore(bool isChecking);" />
      <MemberSignature Language="F#" Value="abstract member FreezeCore : bool -&gt; bool&#xA;override this.FreezeCore : bool -&gt; bool" Usage="freezable.FreezeCore isChecking" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking"><see langword="true" /> Чтобы показывает, является ли объект можно заморозить (без замораживание на самом деле он); <see langword="false" /> фактически Закрепление объекта.</param>
        <summary>Делает <see cref="T:System.Windows.Freezable" /> объекта нередактируемым или проверяет, является ли его сделать нередактируемым.</summary>
        <returns>Если <paramref name="isChecking" /> — <see langword="true" />, этот метод возвращает <see langword="true" /> Если <see cref="T:System.Windows.Freezable" /> можно сделать нередактируемым, или <see langword="false" /> если его невозможно сделать неизменяемым. Если <paramref name="isChecking" /> — <see langword="false" />, этот метод возвращает <see langword="true" /> Если if указанного <see cref="T:System.Windows.Freezable" /> сейчас является нередактируемым, или <see langword="false" /> если его невозможно сделать неизменяемым.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не вызывайте этот метод напрямую (за исключением случаев вызова базового метода в реализации). Этот метод вызывается функцией <xref:System.Windows.Freezable.CanFreeze%2A> свойства (с `isChecking` равным `true`) и <xref:System.Windows.Freezable.Freeze%2A> метод (с `isChecking` равным `false`).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Windows.Freezable" /> реализации должны переопределять этот метод, если класс содержит данные, которые не хранятся с использованием свойств зависимостей.  
  
Типичная реализация будет вызывать базовый, а затем вызовите статический <see cref="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" /> метод на всех <see cref="T:System.Windows.Freezable" /> типизированные свойства, которые содержит класс, возвращая <see langword="true" /> только в том случае, если все свойства были заморожены (или может быть заморожены в случае указания <see langword="true" /> для <paramref name="isChecking" />).</para></block>
        <altmember cref="M:System.Windows.Freezable.Freeze" />
        <altmember cref="P:System.Windows.Freezable.CanFreeze" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает фиксированную копию объекта <see cref="T:System.Windows.Freezable" />, используя базовые (не анимационные) значения свойств. Так как копия является фиксированной, фиксированные вложенные объекты копируются по ссылке.</summary>
        <returns>Фиксированную копию объекта <see cref="T:System.Windows.Freezable" />. Копии <see cref="P:System.Windows.Freezable.IsFrozen" /> свойству <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Следует проверить <xref:System.Windows.Freezable.CanFreeze%2A> свойство перед вызовом этого метода, чтобы убедиться, что <xref:System.Windows.Freezable> может быть зафиксирована. С помощью этого метода похоже на создание копий с помощью <xref:System.Windows.Freezable.Clone%2A> фиксирование и затем с помощью <xref:System.Windows.Freezable.Freeze%2A> метод.  
  
 <xref:System.Windows.Freezable.GetAsFrozen%2A> И <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> методы может повысить производительность копирования, так как они не клонируйте <xref:System.Windows.Freezable> подчиненных объектах, уже зафиксированы; они только скопировать их по ссылке.  
  
 В следующей таблице перечислены различия между <xref:System.Windows.Freezable.GetAsFrozen%2A> и <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> методы.  
  
|Действие|Поведение метода GetAsFrozen|Поведение метода GetCurrentValueAsFrozen|  
|------------|---------------------------------|---------------------------------------------|  
|Копирует свойство зависимостей, которое содержит выражение|Метод вызывает <xref:System.InvalidOperationException> , так как он не может <xref:System.Windows.Freezable.Freeze%2A> свойство.|Копируется текущее значение выражения, но не само выражение.|  
|Копирование также анимированными свойствами зависимостей|Копируется базовое значение свойства (не анимационные). Анимации не копируются.|Копируется текущее анимированное значение свойства. Анимации не копируются.|  
  
 Обратите внимание, что неопределенные свойства не копируются, а также доступны только для чтения.  
  
 Чтобы создать копию <xref:System.Windows.Freezable> то есть не зафиксирована, используйте <xref:System.Windows.Freezable.Clone%2A> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Windows.Freezable" /> Не может быть заморожена, поскольку он содержит выражения или анимационные свойства.</exception>
        <block subset="none" type="overrides"><para>Этот метод использует виртуальный <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" /> метод для создания клона.</para></block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Копируемый экземпляр.</param>
        <summary>Делает экземпляр зафиксированной копией указанного <see cref="T:System.Windows.Freezable" />, используя базовые (без анимации) значения свойств.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается <xref:System.Windows.Freezable.GetAsFrozen%2A> метода и не должен вызываться непосредственно из программного кода, за исключением при вызове базовой реализации при переопределении данного метода. Чтобы создать фиксированную копию текущего объекта, вызовите <xref:System.Windows.Freezable.GetAsFrozen%2A> вместо прямого вызова этого метода.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Если вы наследуете от <see cref="T:System.Windows.Freezable" /> может потребоваться переопределить этот метод. Чтобы переопределить следующие причины: 
— Производный класс включает данные, которые не предоставляются через свойства зависимостей.  
  
-Производного класса необходимо выполнить дополнительную инициализацию работы, которая не может быть выполнен, просто переопределив метод <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Например, это применимо, если производный класс реализует <see cref="T:System.ComponentModel.ISupportInitialize" />.  
  
Классы, в которых хранятся все свои данные в свойствах зависимости и, не обязательно для выполнения дополнительной инициализации не требуется переопределять <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />.  
  
Очень важно, что все реализации вызывать базовую реализацию этого метода. Реализации должны выполнять работу, выполняемую в реализации по умолчанию не только. Реализация по умолчанию делает глубокие копии любой нефиксированных объектах Freezable и неполные копии всех остальных, локально набор свойств, содержащихся в нем. Если объект имеет свойства зависимостей с привязкой к данным, выражения копируются, но могут уже не быть разрешимыми; Дополнительные сведения о клонировании объектов с привязкой к данным, см. в разделе [Freezable Общие сведения об объектах](~/docs/framework/wpf/advanced/freezable-objects-overview.md). Если объект имеет анимированные свойства зависимостей, копируются базовые (не анимационные) значения этих свойств. Анимации не копируются.  
  
Обратите внимание, что неопределенные свойства не копируются, а также доступны только для чтения.  
  
При переопределении этого метода необходимо вызвать базовую реализацию.  
  
Не нужно <see cref="M:System.Windows.Freezable.Freeze" /> значения, они копируются.  Результат заморожен <see cref="M:System.Windows.Freezable.GetAsFrozen" /> перед возвращением.</para></block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozen" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetCurrentValueAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetCurrentValueAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentValueAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetCurrentValueAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentValueAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetCurrentValueAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает фиксированную копию объекта <see cref="T:System.Windows.Freezable" /> с использованием текущих значений свойств. Так как копия является фиксированной, фиксированные вложенные объекты копируются по ссылке.</summary>
        <returns>Фиксированную копию объекта <see cref="T:System.Windows.Freezable" />. Копии <see cref="P:System.Windows.Freezable.IsFrozen" /> свойству <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 С помощью этого метода похоже на создание копий с помощью <xref:System.Windows.Freezable.CloneCurrentValue%2A> фиксирование и затем с помощью <xref:System.Windows.Freezable.Freeze%2A> метод.  
  
 <xref:System.Windows.Freezable.GetAsFrozen%2A> И <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> методы может повысить производительность копирования, так как они не клонируйте <xref:System.Windows.Freezable> подчиненных объектах, уже зафиксированы; они только скопировать их по ссылке.  
  
 В следующей таблице перечислены различия между <xref:System.Windows.Freezable.GetAsFrozen%2A> и <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> методы.  
  
|Действие|Поведение метода GetAsFrozen|Поведение метода GetCurrentValueAsFrozen|  
|------------|---------------------------------|---------------------------------------------|  
|Копирует свойство зависимостей, которое содержит выражение|Метод вызывает <xref:System.InvalidOperationException> , так как он не может <xref:System.Windows.Freezable.Freeze%2A> свойство.|Копируется текущее значение выражения, но не само выражение.|  
|Копирование также анимированными свойствами зависимостей|Копируется базовое значение свойства (не анимационные). Анимации не копируются.|Копируется текущее анимированное значение свойства. Анимации не копируются.|  
  
 Обратите внимание, что неопределенные свойства не копируются, а также доступны только для чтения.  
  
 Чтобы создать копию <xref:System.Windows.Freezable> то есть не зафиксирована, используйте <xref:System.Windows.Freezable.CloneCurrentValue%2A> метод.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Этот метод использует виртуальный <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" /> метод для создания клона.</para></block>
        <altmember cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetCurrentValueAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Объект <see cref="T:System.Windows.Freezable" />, который необходимо скопировать и заморозить.</param>
        <summary>Создает текущий экземпляр замороженной копии указанного объекта <see cref="T:System.Windows.Freezable" />. Если объект имеет анимированные свойства зависимостей, копируются их текущие анимированные значения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> метода и не должен вызываться непосредственно из программного кода, за исключением при вызове базовой реализации при переопределении данного метода. Чтобы создать фиксированную копию текущего объекта, вызовите <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> вместо прямого вызова этого метода.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Если вы наследуете от <see cref="T:System.Windows.Freezable" />, может потребоваться переопределить этот метод. Чтобы переопределить следующие причины: 
— Производный класс включает данные, которые не предоставляются через свойства зависимостей.  
  
-Производного класса необходимо выполнить дополнительную инициализацию работы, которая не может быть выполнен, просто переопределив метод <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Например, это применимо, если производный класс реализует <see cref="T:System.ComponentModel.ISupportInitialize" />.  
  
Классы, в которых хранятся все свои данные в свойствах зависимости и, не обязательно для выполнения дополнительной инициализации не требуется переопределять <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />.  
  
Очень важно, что все реализации вызывать базовую реализацию этого метода. Реализации должны выполнять работу, выполняемую в реализации по умолчанию не только. Реализация по умолчанию создает новую <see cref="T:System.Windows.Freezable" /> с помощью <see cref="M:System.Windows.Freezable.CreateInstance" /> метод и делает глубокие копии нефиксированных объектах Freezable и неполные копии всех остальных, локально установить свойства, он содержит. Если объект имеет свойства зависимостей с привязкой к данным, привязки данных копируются, но могут уже не быть разрешимыми; Дополнительные сведения о клонировании объектов с привязкой к данным, см. в разделе [Freezable Общие сведения об объектах](~/docs/framework/wpf/advanced/freezable-objects-overview.md). Если объект имеет анимированные свойства зависимостей, копируется текущее анимированное значение этих свойств, но не сами анимации.  
  
Свойства зависимостей только для чтения в <see cref="T:System.Windows.Freezable" /> не копируются данной реализацией по умолчанию.  
  
При переопределении этого метода необходимо вызвать базовую реализацию.  
  
Не нужно <see cref="M:System.Windows.Freezable.Freeze" /> значения, они копируются.  Результат заморожен <see cref="M:System.Windows.Freezable.GetAsFrozen" /> перед возвращением.</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="IsFrozen">
      <MemberSignature Language="C#" Value="public bool IsFrozen { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFrozen" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.IsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFrozen As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFrozen { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFrozen : bool" Usage="System.Windows.Freezable.IsFrozen" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, доступен ли объект для изменения в настоящее время.</summary>
        <value>Значение <see langword="true" />, если объект заморожен и не может быть изменен; значение <see langword="false" />, если объект может быть изменен.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Попытка изменить объект при его <xref:System.Windows.Freezable.IsFrozen%2A> свойство `true` вызывает <xref:System.InvalidOperationException>.  
  
 Это свойство только для чтения с точки зрения объектной модели. Некоторые сведения о <xref:System.Windows.Freezable> поведения могут содержать «задает <xref:System.Windows.Freezable.IsFrozen%2A> для `true`"или подобный язык при обсуждении поведение других методов <xref:System.Windows.Freezable>, но это поведение происходит внутренне в экземпляры классов, Если методы экземпляра манипулировать закрытые переменные, которые существуют в абстрактный класс. Чтобы задать значение этого свойства, следует вызвать <xref:System.Windows.Freezable.Freeze%2A>. Это одноразовая операция для изменения эффективного <xref:System.Windows.Freezable.IsFrozen%2A> свойства из первоначальное значение по умолчанию `false` состояние `true` состояние. Нет отсутствуют доступные средства для задания значения обратно в `false`. Вместо этого можно изменить любое глубокое копирование из исходного (см. в разделе <xref:System.Windows.Freezable.Clone%2A> метод). Это сделано намеренно и поведение любого производного класса при применении к вариантам где <xref:System.Windows.Freezable> шаблон полезен.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChanged() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnChanged ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnChanged();" />
      <MemberSignature Language="F#" Value="abstract member OnChanged : unit -&gt; unit&#xA;override this.OnChanged : unit -&gt; unit" Usage="freezable.OnChanged " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вызывается при изменении текущего объекта <see cref="T:System.Windows.Freezable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается всякий раз, когда <xref:System.Windows.Freezable.Changed> событием.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При реализации класса, производного от <see cref="T:System.Windows.Freezable" />, могут переопределять этот метод для выполнения задачи.</para></block>
        <altmember cref="E:System.Windows.Freezable.Changed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OnFreezablePropertyChanged">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Обеспечивает создание соответствующих указателей контекста для элемента данных типа <see cref="T:System.Windows.DependencyObject" /> , только что был изменен.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldValue">Предыдущее значение элемента данных.</param>
        <param name="newValue">Текущее значение элемента данных.</param>
        <summary>Обеспечивает создание соответствующих указателей контекста для <see cref="T:System.Windows.DependencyObjectType" /> данные-член, который был только что задан.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод должен вызываться <xref:System.Windows.Freezable> наследники каждый раз <xref:System.Windows.DependencyObject> член данных, не хранятся в виде <xref:System.Windows.DependencyProperty> имеет значение.  
  
 Этот метод не должен вызываться для <xref:System.Windows.DependencyObject> данные-члены, которые хранятся с использованием <xref:System.Windows.DependencyProperty>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue, System.Windows.DependencyProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue, class System.Windows.DependencyProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject, property As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue, System::Windows::DependencyProperty ^ property);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue, property)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="property" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="oldValue">Предыдущее значение элемента данных.</param>
        <param name="newValue">Текущее значение элемента данных.</param>
        <param name="property">Измененное свойство.</param>
        <summary>Этот член поддерживает инфраструктуру [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] и не предназначен для непосредственного использования из кода.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="freezable.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Данные события, содержащие сведения об изменении свойства и его старое и новое значения.</param>
        <summary>Переопределяет реализацию <see cref="T:System.Windows.DependencyObject" /> для <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />, чтобы также вызвать любой обработчик <see cref="E:System.Windows.Freezable.Changed" /> в ответ на изменение свойства зависимостей типа <see cref="T:System.Windows.Freezable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данные события содержат сведения о только <xref:System.Windows.Freezable> сам. Все сведения о подчиненных свойств должен быть получен с помощью <xref:System.Windows.Freezable.Changed> обработчиков.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadPreamble">
      <MemberSignature Language="C#" Value="protected void ReadPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ReadPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.ReadPreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ReadPreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ReadPreamble();" />
      <MemberSignature Language="F#" Value="member this.ReadPreamble : unit -&gt; unit" Usage="freezable.ReadPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Гарантирует, что <see cref="T:System.Windows.Freezable" /> осуществляется из допустимого потока. Разработчики производных классов <see cref="T:System.Windows.Freezable" /> необходимо вызвать этот метод в начале любого [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] , считывающий данные-члены, которые не являются свойствами зависимостей.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Классы, производные от <see cref="T:System.Windows.Freezable" /> должны вызывать <see cref="M:System.Windows.Freezable.ReadPreamble" /> метод, перед тем как пытаться доступ к любым элементам, которые не являются свойствами зависимостей. <see cref="M:System.Windows.Freezable.WritePreamble" /> Метод должен вызываться перед записью таких членов.  
  
Этот метод фактически ничего не делает больше, чем вызов <see cref="M:System.Windows.Threading.DispatcherObject.VerifyAccess" />.</para></block>
        <altmember cref="M:System.Windows.Freezable.WritePreamble" />
      </Docs>
    </Member>
    <Member MemberName="WritePostscript">
      <MemberSignature Language="C#" Value="protected void WritePostscript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePostscript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePostscript" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePostscript ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePostscript();" />
      <MemberSignature Language="F#" Value="member this.WritePostscript : unit -&gt; unit" Usage="freezable.WritePostscript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вызывает событие <see cref="E:System.Windows.Freezable.Changed" /> для объекта <see cref="T:System.Windows.Freezable" /> и вызывает его метод <see cref="M:System.Windows.Freezable.OnChanged" />. Классы, производные от <see cref="T:System.Windows.Freezable" />, должны вызывать этот метод в конце любого API, который изменяет члены класса, не сохраненные в виде свойств зависимостей.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Классы, производные от <see cref="T:System.Windows.Freezable" /> следует вызывать этот метод в конце любого API, который изменяет член класса, который не хранятся в виде <see cref="T:System.Windows.DependencyProperty" />.</para></block>
      </Docs>
    </Member>
    <Member MemberName="WritePreamble">
      <MemberSignature Language="C#" Value="protected void WritePreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePreamble();" />
      <MemberSignature Language="F#" Value="member this.WritePreamble : unit -&gt; unit" Usage="freezable.WritePreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Проверяет, что <see cref="T:System.Windows.Freezable" /> не заморожен и что он осуществляется из допустимого контекста потока. <see cref="T:System.Windows.Freezable" /> Разработчики производных классов должны вызывать этот метод в начале любого [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] , записывающего на данные-члены, которые не являются свойствами зависимостей.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывает метод <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> чтобы убедиться в том контексте потоков доступен, и выдает исключение, если <xref:System.Windows.Freezable> экземпляр уже был заморожен.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Windows.Freezable" /> Экземпляр заморожен и не может иметь его члены запись.</exception>
        <block subset="none" type="overrides"><para>Классы, производные от <see cref="T:System.Windows.Freezable" /> должны вызывать <see cref="M:System.Windows.Freezable.WritePreamble" /> перед попыткой записи к любым элементам, которые не являются свойствами зависимостей. При вызове метода <see cref="M:System.Windows.Freezable.WritePreamble" /> в [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)], можно опустить вызова <see cref="M:System.Windows.Freezable.ReadPreamble" />.</para></block>
        <altmember cref="M:System.Windows.Freezable.ReadPreamble" />
      </Docs>
    </Member>
  </Members>
</Type>