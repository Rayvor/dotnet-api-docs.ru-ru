<Type Name="Freezable" FullName="System.Windows.Freezable">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c03f12064cd349151d64fa19a969b0fd5691feef" /><Meta Name="ms.sourcegitcommit" Value="0084afad1b3b1cb2c8ad2c142ae3597d08bad4a7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="10/31/2019" /><Meta Name="ms.locfileid" Value="73330752" /></Metadata><TypeSignature Language="C#" Value="public abstract class Freezable : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Freezable extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Freezable" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Freezable&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class Freezable abstract : System::Windows::DependencyObject" />
  <TypeSignature Language="F#" Value="type Freezable = class&#xA;    inherit DependencyObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Определяет объект, имеющий изменяемое состояние и состояние только для чтения (зафиксированное). Классы, производные от <see cref="T:System.Windows.Freezable" />, предоставляют подробные уведомления об изменениях, могут быть неизменяемыми и могут копировать себя.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Класс <xref:System.Windows.Freezable> предоставляет специальные функции, которые могут помочь повысить производительность приложения при использовании объектов, требующих изменения или копирования. Примеры объектов <xref:System.Windows.Freezable> включают следующее.  
  
-   <xref:System.Windows.Media.Brush>  
  
-   <xref:System.Windows.Media.Pen>  
  
-   <xref:System.Windows.Media.Geometry>  
  
-   <xref:System.Windows.Media.Transform>  
  
-   <xref:System.Windows.Media.Animation.AnimationTimeline>  
  
## <a name="deriving-from-freezable"></a>Наследование от Freezable  
 Класс, производный от <xref:System.Windows.Freezable>, получит следующие функции:  
  
-   Особые состояния: состояние "только для чтения" (замороженное) и состояние, доступное для записи.  
  
-   Безопасность потоков. замороженный <xref:System.Windows.Freezable> объект может совместно использоваться несколькими потоками.  
  
-   Подробное уведомление об изменении. в отличие от других объектов <xref:System.Windows.DependencyObject>, объект <xref:System.Windows.Freezable> предоставляет уведомления об изменениях при изменении значений подсвойств.  
  
-   Простое клонирование: класс Freezable уже реализовал несколько методов, создающих глубокие клоны.  
  
 Сведения об использовании и создании собственных объектов <xref:System.Windows.Freezable> см. в разделе [Общие сведения об объектах Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).  
  
 ]]></format>
    </remarks>
    <threadsafe>Все открытые <see langword="static" /> членов этого типа являются потокобезопасными. Потокобезопасность членов экземпляров не гарантируется.  
  
Если свойство <see cref="P:System.Windows.Freezable.IsFrozen" /> <see langword="false" />, доступ к объекту <see cref="T:System.Windows.Freezable" /> может осуществляться только из потока, в котором он был создан. Попытка доступа к нему из другого потока вызывает исключение <see cref="T:System.InvalidOperationException" />. Методы <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> и <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> обеспечивают поддержку упаковки в нужный поток.  
  
Если их свойство <see cref="P:System.Windows.Freezable.IsFrozen" /> <see langword="true" />, то <see cref="T:System.Windows.Freezable" /> объекты являются свободными потоками.  Дополнительные сведения см. в разделе [Общие сведения об объектах класса Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Freezable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Freezable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр производного класса <see cref="T:System.Windows.Freezable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это конструктор защищенного доступа абстрактного класса.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanFreeze">
      <MemberSignature Language="C#" Value="public bool CanFreeze { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanFreeze" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.CanFreeze" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanFreeze As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanFreeze { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanFreeze : bool" Usage="System.Windows.Freezable.CanFreeze" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, которое указывает, можно ли сделать объект неизменяемым.</summary>
        <value>Значение <see langword="true" />, если текущий объект можно сделать неизменяемым или если он уже является неизменяемым; в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Эта реализация метода использует метод <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> с <paramref name="isChecking" /> установленным в значение <see langword="true" />, чтобы определить, можно ли сделать <see cref="T:System.Windows.Freezable" /> неизменяемыми. Чтобы изменить способ, которым данное свойство ведет себя в производном классе, переопределите метод <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event EventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Freezable.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : EventHandler " Usage="member this.Changed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда изменяется класс <see cref="T:System.Windows.Freezable" /> или объект, который входит в его состав.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При попытке добавить или удалить обработчики событий, если текущий объект не является изменяемым (если свойство <xref:System.Windows.Freezable.IsFrozen%2A> имеет значение `true`), возникает исключение.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ Clone();" />
      <MemberSignature Language="F#" Value="member this.Clone : unit -&gt; System.Windows.Freezable" Usage="freezable.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает изменяемый клон данного объекта <see cref="T:System.Windows.Freezable" />, делая глубокие копии значений этого объекта. При копировании свойств зависимостей объекта этот метод копирует выражения (которые могут уже не быть разрешимыми), но не копирует анимации и их текущие значения.</summary>
        <returns>Изменяемая копия текущего объекта. Свойство <see cref="P:System.Windows.Freezable.IsFrozen" /> клонированного объекта имеет значение <see langword="false" />, даже если свойство <see cref="P:System.Windows.Freezable.IsFrozen" /> исходного объекта имеет значение <see langword="true." />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Методы <xref:System.Windows.Freezable.Clone%2A> и <xref:System.Windows.Freezable.CloneCurrentValue%2A> создают изменяемые клоны зафиксированных <xref:System.Windows.Freezable> объектов (методы также могут клонировать <xref:System.Windows.Freezable> объекты, которые не заморожены). Клон фактически является глубокой копией текущего объекта.  
  
 В следующей таблице приведены различия между методами <xref:System.Windows.Freezable.Clone%2A> и <xref:System.Windows.Freezable.CloneCurrentValue%2A>.  
  
|Действие|Поведение метода Clone|Поведение метода Клонекуррентвалуе|  
|------------|---------------------------|---------------------------------------|  
|Копирование свойства зависимостей, имеющего выражение|Выражение копируется, но может больше не разрешаться. Дополнительные сведения см. в разделе [Общие сведения об объектах класса Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).|Текущее значение выражения копируется, но не само выражение.|  
|Копирование анимированного свойства зависимостей|Копируется базовое (не анимационное) значение свойства. Анимации не копируются.|Копируется текущее анимированное значение свойства. Анимации не копируются.|  
  
 Обратите внимание, что неопределенные свойства не копируются. Если неопределенное свойство имеет значение по умолчанию, которое является замороженным <xref:System.Windows.Freezable>, то значение этого свойства остается замороженным в случае неизменяемого клона.  
  
## <a name="move-a-freezable-between-threads"></a>Перемещение объекта Freezable между потоками  
 Этот метод может быть полезен для перемещения <xref:System.Windows.Freezable> между потоками. Сначала сделайте <xref:System.Windows.Freezable> неизменяемым, вызвав его метод <xref:System.Windows.Freezable.Freeze%2A>. Теперь другой поток может получить доступ к <xref:System.Windows.Freezable> и сделать локальную <xref:System.Windows.Freezable.Clone%2A>, к которой он имеет доступ.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Этот метод использует <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> для создания клона. Чтобы изменить поведение этого метода в производном классе, переопределите метод <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />.</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
        <altmember cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Объект, используемый для клонирования.</param>
        <summary>Делает экземпляр клоном (глубокой копией) указанного объекта <see cref="T:System.Windows.Freezable" />, используя базовые (без анимации) значения свойств.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается методом <xref:System.Windows.Freezable.Clone%2A> и не должен вызываться непосредственно из кода, за исключением случаев вызова базовой реализации при переопределении этого метода. Чтобы создать изменяемую копию текущего объекта, вызовите <xref:System.Windows.Freezable.Clone%2A> вместо непосредственного вызова этого метода.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Если вы наследуете от <see cref="T:System.Windows.Freezable" />, может потребоваться переопределить этот метод. Ниже перечислены причины переопределения. 
-У производного класса есть данные, которые не предоставляются через свойства зависимостей.  
  
— Ваш производный класс должен выполнять дополнительные операции инициализации, которые не могут быть выполнены путем простого переопределения <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Например, это применимо, если производный класс реализует <see cref="T:System.ComponentModel.ISupportInitialize" />.  
  
Классы, хранящие все свои данные в свойствах зависимостей и не требующие дополнительной работы по инициализации, не нуждаются в переопределении <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />.  
  
Важно, чтобы все реализации вызывали базовую реализацию этого метода. Реализации должны выполнять только работу, которая не выполняется реализацией по умолчанию. Реализация по умолчанию делает глубокие копии всех доступных для записи, локально заданных свойств, включая внутренние выражения.  
  
Если объект имеет свойства зависимостей, привязанные к данным, выражения копируются, но могут больше не разрешаться. Дополнительные сведения о клонировании объектов, привязанных к данным, см. в разделе [Общие сведения об объектах Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md). Если объект имеет анимированные свойства зависимостей, копируется базовое (не анимационное) значение этих свойств. Анимации не копируются.  
  
Обратите внимание, что неопределенные свойства не копируются и не являются свойствами только для чтения. Если такое свойство имеет значение по умолчанию, которое является замороженным <see cref="T:System.Windows.Freezable" />, то значение этого свойства остается замороженным в другой, изменяемой клоне.  
  
В следующем списке приводится сводка ожидаемого поведения для этого метода: 
— Созданная копия содержит копии всех <see cref="T:System.Windows.Freezable" /> дочерних объектов.  
  
-Не задавайте и свойства только для чтения не копируются.  
  
-Выражения копируются.  
  
— Ни один из этих вложенных объектов не замораживается при создании.  
  
— Сама копия не заморожена.  
  
-Анимации не копируются.  
  
— Копируются только базовые значения свойств, а не текущие анимированные значения.</para></block>
        <altmember cref="M:System.Windows.Freezable.Clone" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValue" />
      <MemberSignature Language="VB.NET" Value="Public Function CloneCurrentValue () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ CloneCurrentValue();" />
      <MemberSignature Language="F#" Value="member this.CloneCurrentValue : unit -&gt; System.Windows.Freezable" Usage="freezable.CloneCurrentValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает редактируемую копию (глубокую копию) объекта <see cref="T:System.Windows.Freezable" /> с использованием его текущих значений.</summary>
        <returns>Изменяемая копия текущего объекта. Свойство <see cref="P:System.Windows.Freezable.IsFrozen" /> клонированного объекта имеет значение <see langword="false" />, даже если свойство <see cref="P:System.Windows.Freezable.IsFrozen" /> исходного объекта имеет значение <see langword="true." />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Методы <xref:System.Windows.Freezable.Clone%2A> и <xref:System.Windows.Freezable.CloneCurrentValue%2A> создают изменяемые клоны зафиксированных <xref:System.Windows.Freezable> объектов (методы также могут клонировать <xref:System.Windows.Freezable> объекты, которые не заморожены). Клон фактически является глубокой копией текущего объекта.  
  
 В следующей таблице приведены различия между методами <xref:System.Windows.Freezable.Clone%2A> и <xref:System.Windows.Freezable.CloneCurrentValue%2A>.  
  
|Действие|Поведение метода Clone|Поведение метода Клонекуррентвалуе|  
|------------|---------------------------|---------------------------------------|  
|Копирование свойства зависимостей, имеющего выражение|Выражение копируется, но может больше не разрешаться. Дополнительные сведения см. в разделе [Общие сведения об объектах класса Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).|Текущее значение выражения копируется, но не само выражение.|  
|Копирование анимированного свойства зависимостей|Копируется базовое (не анимационное) значение свойства. Анимации не копируются.|Копируется текущее анимированное значение свойства. Анимации не копируются.|  
  
 Обратите внимание, что неопределенные свойства не копируются. Если неопределенное свойство имеет значение по умолчанию, которое является замороженным <xref:System.Windows.Freezable>, то значение этого свойства остается замороженным в случае неизменяемого клона.  
  
## <a name="move-a-freezable-between-threads"></a>Перемещение объекта Freezable между потоками  
 Этот метод может быть полезен для перемещения <xref:System.Windows.Freezable> между потоками. Сначала сделайте <xref:System.Windows.Freezable> неизменяемыми с помощью метода <xref:System.Windows.Freezable.Freeze%2A>. Теперь другой поток может получить доступ к <xref:System.Windows.Freezable> и сделать локальный клон, к которому он имеет доступ.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Для создания клона в этом методе используется метод <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />. <see cref="T:System.Windows.Freezable" /> разработчиков, переопределяющих <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />, должны гарантировать, что копия не будет заморожена при создании.</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCurrentValueCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCurrentValueCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCurrentValueCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Элемент привязки <see cref="T:System.Windows.Freezable" />, точную копию которого необходимо создать.</param>
        <summary>Делает экземпляр изменяемым клоном (глубокой копией) указанного объекта <see cref="T:System.Windows.Freezable" /> с использованием текущих значений свойств.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается методом <xref:System.Windows.Freezable.CloneCurrentValue%2A> и не должен вызываться непосредственно из кода, за исключением случаев вызова базовой реализации при переопределении этого метода. Чтобы создать изменяемую копию текущего объекта, вызовите <xref:System.Windows.Freezable.CloneCurrentValue%2A> вместо непосредственного вызова этого метода.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Если вы наследуете от <see cref="T:System.Windows.Freezable" />, может потребоваться переопределить этот метод. Ниже перечислены причины переопределения. 
-У производного класса есть данные, которые не предоставляются через свойства зависимостей.  
  
— Ваш производный класс должен выполнять дополнительные операции инициализации, которые не могут быть выполнены путем простого переопределения <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Например, это применимо, если производный класс реализует <see cref="T:System.ComponentModel.ISupportInitialize" />.  
  
Классы, хранящие все свои данные в свойствах зависимостей и не требующие дополнительной работы по инициализации, не нуждаются в переопределении <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />.  
  
Важно, чтобы все реализации вызывали базовую реализацию этого метода. Реализации должны выполнять только работу, которая не выполняется реализацией по умолчанию. Реализация по умолчанию делает глубокие копии всех доступных для записи, локально заданных свойств. Если объект содержит свойства зависимостей с выражениями (например, с привязкой данных), то текущее значение выражения копируется, но не само выражение.  
  
Если объект имеет анимированные свойства зависимостей, то текущее анимированное значение этих свойств копируется, но анимация не выполняется.  
  
Обратите внимание, что неопределенные свойства не копируются и не являются свойствами только для чтения. Если такое свойство имеет значение по умолчанию, которое является замороженным <see cref="T:System.Windows.Freezable" />, то значение этого свойства остается замороженным в другой, изменяемой клоне.  
  
В следующем списке приводится сводка ожидаемого поведения для этого метода.  
  
— Созданная копия содержит копии всех <see cref="T:System.Windows.Freezable" /> дочерних объектов.  
  
-Не задавайте и свойства только для чтения не копируются.  
  
— Если свойство анимировано, копируется его текущее значение, а сама анимация — нет.  
  
— Ни один из этих вложенных объектов не замораживается при создании.  
  
— Сама копия не заморожена.</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected System.Windows.Freezable CreateInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Windows.Freezable CreateInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Function CreateInstance () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Freezable ^ CreateInstance();" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.Freezable" />.</summary>
        <returns>Новый экземпляр.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это защищенный метод, и фактические реализации конкретного объекта для поведения зависят от реализации метода <xref:System.Windows.Freezable.CreateInstanceCore%2A>, который этот метод вызывает внутренне.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Freezable.CreateInstanceCore" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected abstract System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Если реализуется в производном классе, создает новый экземпляр производного класса <see cref="T:System.Windows.Freezable" />.</summary>
        <returns>Новый экземпляр.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не вызывайте этот метод напрямую (за исключением вызова Base в реализации). Этот метод вызывается внутренним методом <xref:System.Windows.Freezable.CreateInstance%2A> при каждом создании нового экземпляра <xref:System.Windows.Freezable>.  
  
   
  
## Examples  
 В следующем примере показана типичная реализация <xref:System.Windows.Freezable.CreateInstanceCore%2A>.  
  
 [!code-csharp[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/csharp/VS_Snippets_Wpf/freezablesample_procedural/CSharp/freezablesample.cs#createinstancecoreexample)]
 [!code-vb[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/freezablesample_procedural/visualbasic/freezablesample.vb#createinstancecoreexample)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Каждый производный класс <see cref="T:System.Windows.Freezable" /> должен реализовывать этот метод. Типичная реализация заключается в простом вызове конструктора без параметров и возврате результата.</para></block>
        <altmember cref="M:System.Windows.Freezable.CreateInstance" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Freeze">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Делает объект <see cref="T:System.Windows.Freezable" /> нередактируемым и определяет для его свойства <see cref="P:System.Windows.Freezable.IsFrozen" /> значение <see langword="true" /> или проверяет, можно ли объект <see cref="T:System.Windows.Freezable" /> сделать нередактируемым.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="public void Freeze ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Freeze() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze" />
      <MemberSignature Language="VB.NET" Value="Public Sub Freeze ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Freeze();" />
      <MemberSignature Language="F#" Value="member this.Freeze : unit -&gt; unit" Usage="freezable.Freeze " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Делает текущий объект неизменяемым и присваивает его свойству <see cref="P:System.Windows.Freezable.IsFrozen" /> значение <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы избежать возможности <xref:System.InvalidOperationException> при вызове этого метода, проверьте свойство <xref:System.Windows.Freezable.CanFreeze%2A>, чтобы определить, можно ли сделать <xref:System.Windows.Freezable> неизменяемыми перед вызовом этого метода.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Объект <see cref="T:System.Windows.Freezable" /> невозможно сделать неизменяемым.</exception>
        <block subset="none" type="overrides"><para>Этот метод использует метод <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />, чтобы сделать <see cref="T:System.Windows.Freezable" /> неизменяемыми. Чтобы изменить поведение замораживания, переопределите метод <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />.</para></block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="protected internal static bool Freeze (System.Windows.Freezable freezable, bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig bool Freeze(class System.Windows.Freezable freezable, bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static bool Freeze(System::Windows::Freezable ^ freezable, bool isChecking);" />
      <MemberSignature Language="F#" Value="static member Freeze : System.Windows.Freezable * bool -&gt; bool" Usage="System.Windows.Freezable.Freeze (freezable, isChecking)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="freezable" Type="System.Windows.Freezable" />
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="freezable">Объект, который необходимо проверить или сделать нередактируемым. Если параметр <paramref name="isChecking" /> имеет значение <see langword="true" />, объект проверяется, чтобы определить, можно ли его сделать нередактируемым. Если параметр <paramref name="isChecking" /> имеет значение <see langword="false" />, объект делается нередактируемым, если это возможно.</param>
        <param name="isChecking">Значение <see langword="true" /> показывает, что объект можно заморозить (замораживание на самом деле не выполняется); значение <see langword="false" /> показывает, что объект замораживается на самом деле.</param>
        <summary>Если параметр <paramref name="isChecking" /> имеет значение <see langword="true" />, данный метод показывает, можно ли сделать заданный объект <see cref="T:System.Windows.Freezable" /> нередактируемым. Если параметр <paramref name="isChecking" /> имеет значение <see langword="false" />, данный метод пытается сделать заданный объект <see cref="T:System.Windows.Freezable" /> нередактируемым и показывает, была ли операция успешной.</summary>
        <returns>Если параметр <paramref name="isChecking" /> имеет значение <see langword="true" />, этот метод возвращает значение <see langword="true" />, если заданный объект <see cref="T:System.Windows.Freezable" /> можно сделать нередактируемым, или значение <see langword="false" />, если такая возможность отсутствует. Если параметр <paramref name="isChecking" /> имеет значение <see langword="false" />, этот метод возвращает значение <see langword="true" />, если заданный объект <see cref="T:System.Windows.Freezable" /> сейчас является нередактируемым, или значение <see langword="false" />, если его нельзя сделать нередактируемым.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не вызывайте этот метод, если не выполняется наследование от <xref:System.Windows.Freezable> и переопределение метода <xref:System.Windows.Freezable.FreezeCore%2A>.  Этот метод можно использовать в методе <xref:System.Windows.Freezable.FreezeCore%2A>, чтобы заморозить члены данных класса, которые сами <xref:System.Windows.Freezable> объекты.  
  
 Этот метод хорошо вызывается для объекта <xref:System.Windows.Freezable>, который уже заморожен (неизменяемый).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Если параметр <paramref name="isChecking" /> имеет значение <see langword="false" />, это показывает, что попытка сделать объект <paramref name="freezable" /> была безуспешной; теперь объект имеет неизвестное состояние (он может быть частично заморожен).</exception>
        <block subset="none" type="overrides"><para>Этот метод использует метод <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />, чтобы сделать <see cref="T:System.Windows.Freezable" /> неизменяемыми. Чтобы изменить поведение замораживания, переопределите метод <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />.</para></block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected virtual bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function FreezeCore (isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool FreezeCore(bool isChecking);" />
      <MemberSignature Language="F#" Value="abstract member FreezeCore : bool -&gt; bool&#xA;override this.FreezeCore : bool -&gt; bool" Usage="freezable.FreezeCore isChecking" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking">Значение <see langword="true" /> показывает, что объект можно заморозить (замораживание на самом деле не выполняется); значение <see langword="false" /> показывает, что объект замораживается на самом деле.</param>
        <summary>Делает объект <see cref="T:System.Windows.Freezable" /> нередактируемым или проверяет, можно ли его сделать нередактируемым.</summary>
        <returns>Если параметр <paramref name="isChecking" /> имеет значение <see langword="true" />, этот метод возвращает значение <see langword="true" />, если данный объект <see cref="T:System.Windows.Freezable" /> можно сделать нередактируемым, или значение <see langword="false" />, если такая возможность отсутствует. Если параметр <paramref name="isChecking" /> имеет значение <see langword="false" />, этот метод возвращает значение <see langword="true" />, если заданный объект <see cref="T:System.Windows.Freezable" /> сейчас является нередактируемым, или значение <see langword="false" />, если его нельзя сделать нередактируемым.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не вызывайте этот метод напрямую (за исключением вызова Base в реализации). Этот метод вызывается внутренним образом свойством <xref:System.Windows.Freezable.CanFreeze%2A> (с `isChecking`, равным `true`) и методом <xref:System.Windows.Freezable.Freeze%2A> (с `isChecking`, равным `false`).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Разработчики 
            <see cref="T:System.Windows.Freezable" /> должны переопределять этот метод, если класс содержит данные, которые не хранятся с помощью свойств зависимостей.  
  
Типичная реализация вызовет base, а затем вызывает статический метод <see cref="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" /> для всех <see cref="T:System.Windows.Freezable" /> типизированных свойств, содержащихся в классе, и возвращает <see langword="true" /> только в том случае, если все свойства были заморожены (или могут быть заморожены в случае указания <see langword="true" /> для @no_ _t_4_ ).<paramref name="isChecking" /></para></block>
        <altmember cref="M:System.Windows.Freezable.Freeze" />
        <altmember cref="P:System.Windows.Freezable.CanFreeze" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает фиксированную копию объекта <see cref="T:System.Windows.Freezable" />, используя базовые (не анимационные) значения свойств. Так как копия является фиксированной, копируются только ссылки на фиксированные вложенные объекты.</summary>
        <returns>Фиксированная копия объекта <see cref="T:System.Windows.Freezable" />. Свойство копии <see cref="P:System.Windows.Freezable.IsFrozen" /> имеет значение <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Перед вызовом этого метода следует проверить свойство <xref:System.Windows.Freezable.CanFreeze%2A>, чтобы убедиться, что <xref:System.Windows.Freezable> можно заморозить. Использование этого метода аналогично созданию копии с помощью <xref:System.Windows.Freezable.Clone%2A> и последующей фиксации с помощью метода <xref:System.Windows.Freezable.Freeze%2A>.  
  
 Методы <xref:System.Windows.Freezable.GetAsFrozen%2A> и <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> могут повысить производительность копирования, поскольку они не клонированы <xref:System.Windows.Freezable> подобъектов, которые уже заморожены. они копируются только по ссылке.  
  
 В следующей таблице приведены различия между методами <xref:System.Windows.Freezable.GetAsFrozen%2A> и <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>.  
  
|Действие|Поведение метода Жетасфрозен|Поведение метода Жеткуррентвалуеасфрозен|  
|------------|---------------------------------|---------------------------------------------|  
|Копирование свойства зависимостей, имеющего выражение|Метод создает исключение <xref:System.InvalidOperationException>, так как не может <xref:System.Windows.Freezable.Freeze%2A> свойство.|Текущее значение выражения копируется, но не само выражение.|  
|Копирование анимированного свойства зависимостей|Копируется базовое (не анимационное) значение свойства. Анимации не копируются.|Копируется текущее анимированное значение свойства. Анимации не копируются.|  
  
 Обратите внимание, что неопределенные свойства не копируются и не являются свойствами только для чтения.  
  
 Чтобы создать копию незамороженного <xref:System.Windows.Freezable>, используйте метод <xref:System.Windows.Freezable.Clone%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Объект <see cref="T:System.Windows.Freezable" /> нельзя заморозить, так как он включает выражения или анимационные свойства.</exception>
        <block subset="none" type="overrides"><para>Этот метод использует метод Virtual <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" /> для создания клона.</para></block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Копируемый экземпляр.</param>
        <summary>Делает экземпляр зафиксированной копией указанного <see cref="T:System.Windows.Freezable" />, используя базовые (без анимации) значения свойств.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается методом <xref:System.Windows.Freezable.GetAsFrozen%2A> и не должен вызываться непосредственно из кода, за исключением случаев вызова базовой реализации при переопределении этого метода. Чтобы создать замороженную копию текущего объекта, вызовите <xref:System.Windows.Freezable.GetAsFrozen%2A> вместо непосредственного вызова этого метода.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Если вы наследуете от <see cref="T:System.Windows.Freezable" />, может потребоваться переопределить этот метод. Ниже перечислены причины переопределения. 
-У производного класса есть данные, которые не предоставляются через свойства зависимостей.  
  
— Ваш производный класс должен выполнять дополнительные операции инициализации, которые не могут быть выполнены путем простого переопределения <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Например, это применимо, если производный класс реализует <see cref="T:System.ComponentModel.ISupportInitialize" />.  
  
Классы, хранящие все свои данные в свойствах зависимостей и не требующие дополнительной работы по инициализации, не нуждаются в переопределении <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />.  
  
Важно, чтобы все реализации вызывали базовую реализацию этого метода. Реализации должны выполнять только работу, которая не выполняется реализацией по умолчанию. Реализация по умолчанию создает глубокие копии всех незамороженных элементов Freezable и поверхностных копий всех других доступных для записи свойств, которые задаются локально. Если объект имеет свойства зависимостей, привязанные к данным, выражения копируются, но могут больше не разрешаться; Дополнительные сведения о клонировании объектов, привязанных к данным, см. в разделе [Общие сведения об объектах Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md). Если объект имеет анимированные свойства зависимостей, копируются базовые (неанимированные) значения этих свойств. Анимации не копируются.  
  
Обратите внимание, что неопределенные свойства не копируются и не являются свойствами только для чтения.  
  
При переопределении этого метода необходимо вызвать базовую реализацию.  
  
При копировании не требуется <see cref="M:System.Windows.Freezable.Freeze" /> значений.  Результат зафиксирован <see cref="M:System.Windows.Freezable.GetAsFrozen" /> перед возвратом.</para></block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozen" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetCurrentValueAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetCurrentValueAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentValueAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetCurrentValueAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentValueAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetCurrentValueAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает фиксированную копию объекта <see cref="T:System.Windows.Freezable" /> с использованием текущих значений свойств. Так как копия является фиксированной, копируются только ссылки на фиксированные вложенные объекты.</summary>
        <returns>Фиксированная копия объекта <see cref="T:System.Windows.Freezable" />. Свойство копии <see cref="P:System.Windows.Freezable.IsFrozen" /> имеет значение <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Использование этого метода аналогично созданию копии с помощью <xref:System.Windows.Freezable.CloneCurrentValue%2A> и последующей фиксации с помощью метода <xref:System.Windows.Freezable.Freeze%2A>.  
  
 Методы <xref:System.Windows.Freezable.GetAsFrozen%2A> и <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> могут повысить производительность копирования, поскольку они не клонированы <xref:System.Windows.Freezable> подобъектов, которые уже заморожены. они копируются только по ссылке.  
  
 В следующей таблице приведены различия между методами <xref:System.Windows.Freezable.GetAsFrozen%2A> и <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>.  
  
|Действие|Поведение метода Жетасфрозен|Поведение метода Жеткуррентвалуеасфрозен|  
|------------|---------------------------------|---------------------------------------------|  
|Копирование свойства зависимостей, имеющего выражение|Метод создает исключение <xref:System.InvalidOperationException>, так как не может <xref:System.Windows.Freezable.Freeze%2A> свойство.|Текущее значение выражения копируется, но не само выражение.|  
|Копирование анимированного свойства зависимостей|Копируется базовое (не анимационное) значение свойства. Анимации не копируются.|Копируется текущее анимированное значение свойства. Анимации не копируются.|  
  
 Обратите внимание, что неопределенные свойства не копируются и не являются свойствами только для чтения.  
  
 Чтобы создать копию незамороженного <xref:System.Windows.Freezable>, используйте метод <xref:System.Windows.Freezable.CloneCurrentValue%2A>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Этот метод использует метод Virtual <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" /> для создания клона.</para></block>
        <altmember cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetCurrentValueAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Объект <see cref="T:System.Windows.Freezable" />, который необходимо скопировать и заморозить.</param>
        <summary>Создает текущий экземпляр замороженной копии указанного объекта <see cref="T:System.Windows.Freezable" />. Если объект имеет анимированные свойства зависимостей, копируются их текущие анимированные значения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается методом <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> и не должен вызываться непосредственно из кода, за исключением случаев вызова базовой реализации при переопределении этого метода. Чтобы создать замороженную копию текущего объекта, вызовите <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> вместо непосредственного вызова этого метода.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Если вы наследуете от <see cref="T:System.Windows.Freezable" />, может потребоваться переопределить этот метод. Ниже перечислены причины переопределения. 
-У производного класса есть данные, которые не предоставляются через свойства зависимостей.  
  
— Ваш производный класс должен выполнять дополнительные операции инициализации, которые не могут быть выполнены путем простого переопределения <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Например, это применимо, если производный класс реализует <see cref="T:System.ComponentModel.ISupportInitialize" />.  
  
Классы, хранящие все свои данные в свойствах зависимостей и не требующие дополнительной работы по инициализации, не нуждаются в переопределении <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />.  
  
Важно, чтобы все реализации вызывали базовую реализацию этого метода. Реализации должны выполнять только работу, которая не выполняется реализацией по умолчанию. Реализация по умолчанию создает новый <see cref="T:System.Windows.Freezable" /> с помощью метода <see cref="M:System.Windows.Freezable.CreateInstance" /> и создает глубокие копии незамороженных зафиксированных элементов Freezable и неполные копии всех других доступных для записи свойств, которые в нем содержатся локально. Если объект имеет свойства зависимостей, привязанные к данным, привязки данных копируются, но могут больше не разрешаться; Дополнительные сведения о клонировании объектов, привязанных к данным, см. в разделе [Общие сведения об объектах Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md). Если объект имеет анимированные свойства зависимостей, то текущее анимированное значение этих свойств копируется, но анимация не выполняется.  
  
Свойства зависимостей "только для чтения" в <see cref="T:System.Windows.Freezable" /> не копируются этой реализацией по умолчанию.  
  
При переопределении этого метода необходимо вызвать базовую реализацию.  
  
При копировании не требуется <see cref="M:System.Windows.Freezable.Freeze" /> значений.  Результат зафиксирован <see cref="M:System.Windows.Freezable.GetAsFrozen" /> перед возвратом.</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="IsFrozen">
      <MemberSignature Language="C#" Value="public bool IsFrozen { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFrozen" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.IsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFrozen As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFrozen { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFrozen : bool" Usage="System.Windows.Freezable.IsFrozen" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, доступен ли объект для изменения в настоящее время.</summary>
        <value>Значение <see langword="true" />, если объект заморожен и не может быть изменен; значение <see langword="false" />, если объект может быть изменен.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Попытка изменить объект, если его свойство <xref:System.Windows.Freezable.IsFrozen%2A> `true` вызывает <xref:System.InvalidOperationException>.  
  
 Это свойство доступно только для чтения с точки зрения объектной модели. В некоторых документах, посвященных поведению <xref:System.Windows.Freezable>, может упоминаться «установка <xref:System.Windows.Freezable.IsFrozen%2A> `true`» или аналогичный язык при обсуждении поведения других методов <xref:System.Windows.Freezable>, но это происходит внутри экземпляров класса, когда методы экземпляр управляет закрытыми переменными, которые существуют в абстрактном классе. Чтобы задать значение этого свойства, следует вызвать <xref:System.Windows.Freezable.Freeze%2A>. Это является одноразовой операцией для изменения свойства <xref:System.Windows.Freezable.IsFrozen%2A> из начального состояния `false` по умолчанию на состояние `true`. Нет доступных средств для установки значения обратно в `false`. Вместо этого можно изменить любую глубокую копию из оригинала (см. метод <xref:System.Windows.Freezable.Clone%2A>). Это характерно и то, как любой производный класс должен вести себя при применении к случаям, когда шаблон <xref:System.Windows.Freezable> полезен.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChanged() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnChanged ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnChanged();" />
      <MemberSignature Language="F#" Value="abstract member OnChanged : unit -&gt; unit&#xA;override this.OnChanged : unit -&gt; unit" Usage="freezable.OnChanged " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вызывается при изменении текущего объекта <see cref="T:System.Windows.Freezable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается при каждом возникновении события <xref:System.Windows.Freezable.Changed>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При реализации класса, производного от <see cref="T:System.Windows.Freezable" />, этот метод можно переопределить для выполнения задач.</para></block>
        <altmember cref="E:System.Windows.Freezable.Changed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OnFreezablePropertyChanged">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Обеспечивает создание соответствующих указателей контекста для элемента данных типа <see cref="T:System.Windows.DependencyObject" />, который был изменен.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldValue">Предыдущее значение элемента данных.</param>
        <param name="newValue">Текущее значение элемента данных.</param>
        <summary>Обеспечивает создание соответствующих указателей контекста для элемента данных типа <see cref="T:System.Windows.DependencyObjectType" />, который был только что задан.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод должен вызываться <xref:System.Windows.Freezable> наследниками каждый раз, когда задается элемент данных <xref:System.Windows.DependencyObject>, не хранящийся в виде <xref:System.Windows.DependencyProperty>.  
  
 Этот метод не требуется вызывать для <xref:System.Windows.DependencyObject>ных элементов данных, которые хранятся с помощью <xref:System.Windows.DependencyProperty>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue, System.Windows.DependencyProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue, class System.Windows.DependencyProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject, property As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue, System::Windows::DependencyProperty ^ property);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue, property)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="property" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="oldValue">Предыдущее значение элемента данных.</param>
        <param name="newValue">Текущее значение элемента данных.</param>
        <param name="property">Измененное свойство.</param>
        <summary>Этот член поддерживает инфраструктуру [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] и не предназначен для непосредственного использования из кода.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="freezable.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Данные события, содержащие сведения об изменении свойства и его старое и новое значения.</param>
        <summary>Переопределяет реализацию <see cref="T:System.Windows.DependencyObject" /> для <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />, чтобы также вызвать любой обработчик <see cref="E:System.Windows.Freezable.Changed" /> в ответ на изменение свойства зависимостей типа <see cref="T:System.Windows.Freezable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данные события содержат сведения только о самом <xref:System.Windows.Freezable>. Все сведения о подсвойствах должны быть получены с помощью обработчиков <xref:System.Windows.Freezable.Changed>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadPreamble">
      <MemberSignature Language="C#" Value="protected void ReadPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ReadPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.ReadPreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ReadPreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ReadPreamble();" />
      <MemberSignature Language="F#" Value="member this.ReadPreamble : unit -&gt; unit" Usage="freezable.ReadPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Обеспечивает доступ к <see cref="T:System.Windows.Freezable" /> из допустимого потока. Наследники объекта <see cref="T:System.Windows.Freezable" /> должны вызывать данный метод в начале любого API, который считывает элементы данных, не являющиеся свойствами зависимостей.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Классы, производные от <see cref="T:System.Windows.Freezable" />, должны вызывать метод <see cref="M:System.Windows.Freezable.ReadPreamble" />, прежде чем они пытаются получить доступ к любым элементам, которые не являются свойствами зависимостей. Метод <see cref="M:System.Windows.Freezable.WritePreamble" /> должен вызываться до того, как будут записаны все такие члены.  
  
Этот метод эффективно делает ничего больше, чем вызов <see cref="M:System.Windows.Threading.DispatcherObject.VerifyAccess" />.</para></block>
        <altmember cref="M:System.Windows.Freezable.WritePreamble" />
      </Docs>
    </Member>
    <Member MemberName="WritePostscript">
      <MemberSignature Language="C#" Value="protected void WritePostscript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePostscript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePostscript" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePostscript ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePostscript();" />
      <MemberSignature Language="F#" Value="member this.WritePostscript : unit -&gt; unit" Usage="freezable.WritePostscript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вызывает событие <see cref="E:System.Windows.Freezable.Changed" /> для объекта <see cref="T:System.Windows.Freezable" /> и вызывает его метод <see cref="M:System.Windows.Freezable.OnChanged" />. Классы, производные от <see cref="T:System.Windows.Freezable" />, должны вызывать этот метод в конце любого API, который изменяет члены класса, не сохраненные в виде свойств зависимостей.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Классы, производные от <see cref="T:System.Windows.Freezable" />, должны вызывать этот метод в конце любого API-интерфейса, изменяющего член класса, который не хранится в качестве <see cref="T:System.Windows.DependencyProperty" />.</para></block>
      </Docs>
    </Member>
    <Member MemberName="WritePreamble">
      <MemberSignature Language="C#" Value="protected void WritePreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePreamble();" />
      <MemberSignature Language="F#" Value="member this.WritePreamble : unit -&gt; unit" Usage="freezable.WritePreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Проверяет, что объект <see cref="T:System.Windows.Freezable" /> не заморожен и доступ к нему осуществляется из допустимого контекста потока. Наследники объекта <see cref="T:System.Windows.Freezable" /> должны вызывать данный метод в начале любого API, который выполняет запись в элементах данных, не являющихся свойствами зависимостей.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывает <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A>, чтобы проверить, доступен ли контекст потоковой обработки, и создает исключение, если экземпляр <xref:System.Windows.Freezable> уже заморожен.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Экземпляр <see cref="T:System.Windows.Freezable" /> заморожен, и запись в его члены невозможна.</exception>
        <block subset="none" type="overrides"><para>Классы, производные от <see cref="T:System.Windows.Freezable" />, должны вызывать <see cref="M:System.Windows.Freezable.WritePreamble" /> перед попыткой записи в любые члены, не являющиеся свойствами зависимостей. При вызове <see cref="M:System.Windows.Freezable.WritePreamble" /> в API можно опустить вызов <see cref="M:System.Windows.Freezable.ReadPreamble" />.</para></block>
        <altmember cref="M:System.Windows.Freezable.ReadPreamble" />
      </Docs>
    </Member>
  </Members>
</Type>
