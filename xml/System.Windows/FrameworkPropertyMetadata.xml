<Type Name="FrameworkPropertyMetadata" FullName="System.Windows.FrameworkPropertyMetadata">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ba99bda134572e938946c434092cc0e4d72af0a5" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70484820" /></Metadata><TypeSignature Language="C#" Value="public class FrameworkPropertyMetadata : System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FrameworkPropertyMetadata extends System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkPropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkPropertyMetadata&#xA;Inherits UIPropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkPropertyMetadata : System::Windows::UIPropertyMetadata" />
  <TypeSignature Language="F#" Value="type FrameworkPropertyMetadata = class&#xA;    inherit UIPropertyMetadata" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.UIPropertyMetadata</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Сообщает или применяет метаданные для свойства зависимостей, добавляя характеристики системы свойств, специфичные для платформы.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот класс является производным <xref:System.Windows.PropertyMetadata> от ( <xref:System.Windows.UIPropertyMetadata>с до). Для большинства целей <xref:System.Windows.FrameworkPropertyMetadata> разработки приложений на уровне среды WPF — это тип, используемый для метаданных свойств зависимостей, а не базовых типов <xref:System.Windows.PropertyMetadata> метаданных или <xref:System.Windows.UIPropertyMetadata>. Это справедливо и для существующих свойств зависимостей, и для большинства сценариев настраиваемых свойств зависимостей.  
  
 Члены, объявленные этим классом, дополняют <xref:System.Windows.PropertyMetadata> базовый класс, включают различные логические свойства, указывающие поведение системы свойств на уровне платформы WPF, например наследование свойств, привязку данных и макет.  
  
 Несколько подписей конструктора для создания <xref:System.Windows.FrameworkPropertyMetadata> экземпляра <xref:System.Windows.FrameworkPropertyMetadataOptions> принимают параметр. Перечисление используется только для указания начального поведения в конструкторе и не является открытым иным образом после  <xref:System.Windows.FrameworkPropertyMetadata> создания. <xref:System.Windows.FrameworkPropertyMetadataOptions> Из сконструированного экземпляра можно получить или задать соответствующие сведения с помощью различных свойств, которые совместно используют имена значений перечисления, используемых при вызове конструктора.  
  
<a name="xamlTextUsage_FrameworkPropertyMetadata"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Этот класс обычно не используется в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 В следующем примере показано получение метаданных для свойства зависимости определенного владельца в качестве первоначального базового <xref:System.Windows.PropertyMetadata> типа. Эти метаданные приводятся <xref:System.Windows.FrameworkPropertyMetadata>к типу. Если приведение вернуло допустимое <xref:System.Windows.FrameworkPropertyMetadata>значение, то различные <xref:System.Windows.FrameworkPropertyMetadata> значения свойств передаются через простой пользовательский интерфейс (не показано).  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.PropertyMetadata" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.FrameworkPropertyMetadata" />.</summary>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.FrameworkPropertyMetadata" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта подпись инициализирует все значения <xref:System.Windows.FrameworkPropertyMetadata.%23ctor%2A> свойств по умолчанию. <xref:System.Windows.PropertyMetadata.DefaultValue%2A>будет иметь `null`значение, а различные <xref:System.Windows.FrameworkPropertyMetadata> логические свойства будут `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata defaultValue" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Как правило, значение по умолчанию свойства зависимостей представляет собой значение определенного типа.</param>
        <summary>Выполняет инициализацию нового экземпляра класса <see cref="T:System.Windows.FrameworkPropertyMetadata" /> с заданным по умолчанию значением.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Тип значения, предоставленного для `defaultValue` , должен соответствовать типу, указанному в исходной регистрации свойства зависимостей, к которому будут применяться эти метаданные, или быть связанным с ним. Несоответствие между типом значения метаданных по умолчанию и типом свойства зависимости, к которому он применяется, может быть затруднено в отладке, так как во время компиляции несоответствие не обнаруживается. Система свойств не вычисляет действительное значение свойства до времени выполнения, поэтому результатом несоответствия типа значения по умолчанию или типа свойства является ошибка времени выполнения.  
  
 Значение <xref:System.Windows.DependencyProperty.UnsetValue> имеет особое значение в системе свойств и не может использоваться как значение свойства зависимости по умолчанию.  
  
   
  
## Examples  
 В следующем примере вызывается сигнатура этого конструктора:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметру <paramref name="defaultValue" /> задается значение <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata propertyChangedCallback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">Ссылка на реализацию обработчика, который система управления свойствами будет вызывать при изменении значения этого свойства.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.FrameworkPropertyMetadata" /> с указанным ответом <see cref="T:System.Windows.PropertyChangedCallback" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере вызывается сигнатура этого конструктора:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, flags As FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Как правило, значение по умолчанию свойства зависимостей представляет собой значение определенного типа.</param>
        <param name="flags">Параметры флагов метаданных (комбинация значений <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" />). Данные параметры определяют характеристики свойства зависимостей, взаимодействующего с системой, такие как структура и привязка данных.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.FrameworkPropertyMetadata" /> с указанным значением по умолчанию и параметрами метаданных уровня платформы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Тип значения, предоставленного для `defaultValue` , должен соответствовать типу, указанному в исходной регистрации свойства зависимостей, к которому будут применяться эти метаданные, или быть связанным с ним. Несоответствие между типом значения метаданных по умолчанию и типом свойства зависимости, к которому он применяется, может быть затруднено в отладке, так как во время компиляции несоответствие не обнаруживается. Система свойств не вычисляет действительное значение свойства до времени выполнения, поэтому результатом несоответствия типа значения по умолчанию или типа свойства является ошибка времени выполнения.  
  
 Значение <xref:System.Windows.DependencyProperty.UnsetValue> имеет особое значение в системе свойств и не может использоваться как значение свойства зависимости по умолчанию.  
  
 Значения, помеченные как флаги `flags` Set в параметре, будут задавать <xref:System.Windows.FrameworkPropertyMetadata> логические значения свойств, <xref:System.Windows.FrameworkPropertyMetadataOptions> соответствующих имени `true`этого флага. Впоследствии можно изменить значения свойств в метаданных при условии, что метаданные еще не были применены к определенной операции системы свойств.  
  
   
  
## Examples  
 В следующем примере вызывается сигнатура этого конструктора:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметру <paramref name="defaultValue" /> задается значение <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Как правило, значение по умолчанию свойства зависимостей представляет собой значение определенного типа.</param>
        <param name="propertyChangedCallback">Ссылка на реализацию обработчика, который система управления свойствами будет вызывать при изменении значения этого свойства.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.FrameworkPropertyMetadata" /> с заданными значением по умолчанию и ответом <see cref="T:System.Windows.PropertyChangedCallback" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Тип значения, предоставленного для `defaultValue` , должен соответствовать типу, указанному в исходной регистрации свойства зависимостей, к которому будут применяться эти метаданные, или быть связанным с ним. Несоответствие между типом значения метаданных по умолчанию и типом свойства зависимости, к которому он применяется, может быть затруднено в отладке, так как во время компиляции несоответствие не обнаруживается. Система свойств не вычисляет действительное значение свойства до времени выполнения, поэтому результатом несоответствия типа значения по умолчанию или типа свойства является ошибка времени выполнения.  
  
 Значение <xref:System.Windows.DependencyProperty.UnsetValue> имеет особое значение в системе свойств и не может использоваться как значение свойства зависимости по умолчанию.  
  
   
  
## Examples  
 В следующем примере вызывается сигнатура этого конструктора:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметру <paramref name="defaultValue" /> задается значение <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">Ссылка на реализацию обработчика, который система управления свойствами будет вызывать при изменении значения этого свойства.</param>
        <param name="coerceValueCallback">Ссылка на реализацию обработчика вызывается системой управления свойствами при каждом вызове <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> для данного свойства.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.FrameworkPropertyMetadata" /> с указанными ответами.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта реализация вызывает базовый инициализатор, а затем добавляет `coerceValueCallback` , задавая свойство для базового экземпляра.  
  
   
  
## Examples  
 В следующем примере вызывается сигнатура этого конструктора:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Как правило, значение по умолчанию свойства зависимостей представляет собой значение определенного типа.</param>
        <param name="flags">Параметры флагов метаданных (комбинация значений <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" />). Данные параметры определяют характеристики свойства зависимостей, взаимодействующего с системой, такие как структура и привязка данных.</param>
        <param name="propertyChangedCallback">Ссылка на реализацию обработчика, который система управления свойствами будет вызывать при изменении значения этого свойства.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.FrameworkPropertyMetadata" /> с указанным значением по умолчанию, параметрами метаданных платформы и ответами <see cref="T:System.Windows.PropertyChangedCallback" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Тип значения, предоставленного для `defaultValue` , должен соответствовать типу, указанному в исходной регистрации свойства зависимостей, к которому будут применяться эти метаданные, или быть связанным с ним. Несоответствие между типом значения метаданных по умолчанию и типом свойства зависимости, к которому он применяется, может быть затруднено в отладке, так как во время компиляции несоответствие не обнаруживается. Система свойств не вычисляет действительное значение свойства до времени выполнения, поэтому результатом несоответствия типа значения по умолчанию или типа свойства является ошибка времени выполнения.  
  
 Значение <xref:System.Windows.DependencyProperty.UnsetValue> имеет особое значение в системе свойств и не может использоваться как значение свойства зависимости по умолчанию.  
  
 Значения, помеченные как флаги `flags` Set в параметре, будут задавать <xref:System.Windows.FrameworkPropertyMetadata> логические значения свойств, <xref:System.Windows.FrameworkPropertyMetadataOptions> соответствующих имени `true`этого флага. Можно по-прежнему изменять значения свойств в метаданных, если метаданные еще не были применены к определенной операции системы свойств.  
  
   
  
## Examples  
 В следующем примере вызывается сигнатура этого конструктора:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметру <paramref name="defaultValue" /> задается значение <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Как правило, значение по умолчанию свойства зависимостей представляет собой определенный тип.</param>
        <param name="propertyChangedCallback">Ссылка на реализацию обработчика, который система управления свойствами будет вызывать при изменении значения этого свойства.</param>
        <param name="coerceValueCallback">Ссылка на реализацию обработчика вызывается системой управления свойствами при каждом вызове <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> для данного свойства.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.FrameworkPropertyMetadata" /> с заданными значением по умолчанию и ответами.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Тип значения, предоставленного для `defaultValue` , должен соответствовать типу, указанному в исходной регистрации свойства зависимостей, к которому будут применяться эти метаданные, или быть связанным с ним. Несоответствие между типом значения метаданных по умолчанию и типом свойства зависимости, к которому он применяется, может быть затруднено в отладке, так как во время компиляции несоответствие не обнаруживается. Система свойств не вычисляет действительное значение свойства до времени выполнения, поэтому результатом несоответствия типа значения по умолчанию или типа свойства является ошибка времени выполнения.  
  
 Значение <xref:System.Windows.DependencyProperty.UnsetValue> имеет особое значение в системе свойств и не может использоваться как значение свойства зависимости по умолчанию.  
  
   
  
## Examples  
 В следующем примере вызывается сигнатура этого конструктора:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметру <paramref name="defaultValue" /> задается значение <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Как правило, значение по умолчанию свойства зависимостей представляет собой определенный тип.</param>
        <param name="flags">Параметры флагов метаданных (комбинация значений <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" />). Данные параметры определяют характеристики свойства зависимостей, взаимодействующего с системой, такие как структура и привязка данных.</param>
        <param name="propertyChangedCallback">Ссылка на реализацию обработчика, который система управления свойствами будет вызывать при изменении значения этого свойства.</param>
        <param name="coerceValueCallback">Ссылка на реализацию обработчика вызывается системой управления свойствами при каждом вызове <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> против данного свойства.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.FrameworkPropertyMetadata" /> с указанным значением по умолчанию, параметрами метаданных платформы и ответами.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Тип значения, предоставленного для `defaultValue` , должен соответствовать типу, указанному в исходной регистрации свойства зависимостей, к которому будут применяться эти метаданные, или быть связанным с ним. Несоответствие между типом значения метаданных по умолчанию и типом свойства зависимости, к которому он применяется, может быть затруднено в отладке, так как во время компиляции несоответствие не обнаруживается. Система свойств не вычисляет действительное значение свойства до времени выполнения, поэтому результатом несоответствия типа значения по умолчанию или типа свойства является ошибка времени выполнения.  
  
 Значение <xref:System.Windows.DependencyProperty.UnsetValue> имеет особое значение в системе свойств и не может использоваться как значение свойства зависимости по умолчанию.  
  
 Значения, помеченные как флаги `flags` Set в параметре, будут задавать <xref:System.Windows.FrameworkPropertyMetadata> логические значения свойств, <xref:System.Windows.FrameworkPropertyMetadataOptions> соответствующих имени `true`этого флага. Можно по-прежнему изменять значения свойств в метаданных, если метаданные еще не были применены к определенной операции системы свойств.  
  
   
  
## Examples  
 В следующем примере вызывается сигнатура этого конструктора:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметру <paramref name="defaultValue" /> задается значение <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback * bool -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Как правило, значение по умолчанию свойства зависимостей представляет собой определенный тип.</param>
        <param name="flags">Параметры флагов метаданных (комбинация значений <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" />). Данные параметры определяют характеристики свойства зависимостей, взаимодействующего с системой, такие как структура и привязка данных.</param>
        <param name="propertyChangedCallback">Ссылка на реализацию обработчика, который система управления свойствами будет вызывать при изменении значения этого свойства.</param>
        <param name="coerceValueCallback">Ссылка на реализацию обработчика вызывается системой управления свойствами при каждом вызове <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> данного свойства.</param>
        <param name="isAnimationProhibited">Чтобы запретить системе управления свойствами воспроизводить анимацию для свойства, относящегося к данным метаданным, установите <see langword="true" />. Подобные свойства вызывают исключения во время выполнения, проистекающие из системы управления свойствами при попытке применения к ним анимаций. Для разрешения анимации свойства следует установить значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.FrameworkPropertyMetadata" /> с указанным значением по умолчанию и установками метаданных платформы, указанными ответами и логическим значением, которое может быть использовано для предотвращения анимации свойства.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Тип значения, предоставленного для `defaultValue` , должен соответствовать типу, указанному в исходной регистрации свойства зависимостей, к которому будут применяться эти метаданные, или быть связанным с ним. Несоответствие между типом значения метаданных по умолчанию и типом свойства зависимости, к которому он применяется, может быть затруднено в отладке, так как во время компиляции несоответствие не обнаруживается. Система свойств не вычисляет действительное значение свойства до времени выполнения, поэтому результатом несоответствия типа значения по умолчанию или типа свойства является ошибка времени выполнения.  
  
 Значение <xref:System.Windows.DependencyProperty.UnsetValue> имеет особое значение в системе свойств и не может использоваться как значение свойства зависимости по умолчанию.  
  
 Параметр задает начальное значение <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> свойства, объявленного непосредственно базовым <xref:System.Windows.UIPropertyMetadata> классом. `isAnimationProhibited`  
  
 Значения, помеченные как флаги `flags` Set в параметре, будут задавать <xref:System.Windows.FrameworkPropertyMetadata> логические значения свойств, <xref:System.Windows.FrameworkPropertyMetadataOptions> соответствующих имени `true`этого флага. Можно по-прежнему изменять значения свойств в метаданных, если метаданные еще не были применены к определенной операции системы свойств.  
  
   
  
## Examples  
 В следующем примере вызывается сигнатура этого конструктора:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметру <paramref name="defaultValue" /> задается значение <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, valuetype System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited, System::Windows::Data::UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback * bool * System.Windows.Data.UpdateSourceTrigger -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited, defaultUpdateSourceTrigger)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
        <Parameter Name="defaultUpdateSourceTrigger" Type="System.Windows.Data.UpdateSourceTrigger" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Как правило, значение по умолчанию свойства зависимостей представляет собой определенный тип.</param>
        <param name="flags">Параметры флагов метаданных (комбинация значений <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" />). Данные параметры определяют характеристики свойства зависимостей, взаимодействующего с системой, такие как структура и привязка данных.</param>
        <param name="propertyChangedCallback">Ссылка на реализацию обработчика, который система управления свойствами будет вызывать при изменении значения этого свойства.</param>
        <param name="coerceValueCallback">Ссылка на реализацию обработчика вызывается системой управления свойствами при каждом вызове <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> против данного свойства.</param>
        <param name="isAnimationProhibited">Чтобы запретить системе управления свойствами воспроизводить анимацию для свойства, относящегося к данным метаданным, установите <see langword="true" />. Подобные свойства вызывают исключения во время выполнения, проистекающие из системы управления свойствами при попытке применения к ним анимаций. Значение по умолчанию — <see langword="false" />.</param>
        <param name="defaultUpdateSourceTrigger"><see cref="T:System.Windows.Data.UpdateSourceTrigger" /> для использования, когда привязки, примененные к данному свойству имеют <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> со значением <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.FrameworkPropertyMetadata" /> с указанным значением по умолчанию и установками метаданных платформы, указанными ответами, логическим значением, которое может быть использовано для предотвращения анимации свойства и триггером обновления привязки данных по умолчанию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Тип значения, предоставленного для `defaultValue` , должен соответствовать типу, указанному в исходной регистрации свойства зависимостей, к которому будут применяться эти метаданные, или быть связанным с ним. Несоответствие между типом значения метаданных по умолчанию и типом свойства зависимости, к которому он применяется, может быть затруднено в отладке, так как во время компиляции несоответствие не обнаруживается. Система свойств не вычисляет действительное значение свойства до времени выполнения, поэтому результатом несоответствия типа значения по умолчанию или типа свойства является ошибка времени выполнения.  
  
 Значение <xref:System.Windows.DependencyProperty.UnsetValue> имеет особое значение в системе свойств и не может использоваться как значение свойства зависимости по умолчанию.  
  
 Параметр задает начальное значение <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> свойства, объявленного непосредственно базовым <xref:System.Windows.UIPropertyMetadata> классом. `isAnimationProhibited`  
  
 Дополнительные сведения о поведении источника обновлений для привязок см. в разделе [Общие сведения о привязке данных](~/docs/framework/wpf/data/data-binding-overview.md).  
  
 Значения, помеченные как флаги `flags` Set в параметре, будут задавать <xref:System.Windows.FrameworkPropertyMetadata> логические значения свойств, <xref:System.Windows.FrameworkPropertyMetadataOptions> соответствующих имени `true`этого флага. Можно по-прежнему изменять значения свойств в метаданных, если метаданные еще не были применены к определенной операции системы свойств.  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP_DUST](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap_dust)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметру <paramref name="defaultValue" /> задается значение <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName="AffectsArrange">
      <MemberSignature Language="C#" Value="public bool AffectsArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsArrange { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsArrange : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, может ли свойство зависимостей влиять на порядок размещения во время операций обработчика макета.</summary>
        <value>Значение <see langword="true" />, если свойство зависимостей, в котором существуют эти метаданные, может влиять на порядок размещения; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement>и <xref:System.Windows.FrameworkContentElement> включают <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>  реализацию, которая отслеживает действующие изменения значений для всех свойств зависимостей, существующих в элементе. В рамках этой логики свойства зависимостей, которые изменяют эффективное значение и имеют <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> метаданные со `true` значением, будут инициировать отложенный запрос на недействительность визуальных <xref:System.Windows.UIElement.InvalidateArrange%2A>элементов для этого элемента (вызов). Поскольку такая реализация на уровне платформы WPF уже существует, вам обычно не нужно искать свойства <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> зависимостей, если только вы не заменили или не измените поведение макета на уровне платформы WPF.  
  
 В <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> пользовательских реализациях может возникать схожее поведение при изменении свойств зависимостей <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> , `true`где свойство имеет значение.  
  
 Свойства в производных классах <xref:System.Windows.PropertyMetadata> обычно определяются в объектной модели как доступные для чтения и записи. Это значит, что их можно скорректировать после инициализации экземпляра. Однако после того, как метаданные будут потреблены как часть вызова метода <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, система свойств зазапечатана, что экземпляр метаданных и свойства, передающие особенности метаданных, теперь считаются неизменяемыми. Попытка установить это свойство после <xref:System.Windows.PropertyMetadata.IsSealed%2A> `true` в этом экземпляре метаданных вызовет исключение.  
  
<a name="xamlTextUsage_AffectsArrange"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Члены этого класса обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 Следующий пример получает метаданные по умолчанию из различных полей свойств зависимости, запрашивает значения различных <xref:System.Windows.FrameworkPropertyMetadata> свойств в нем и использует эти сведения для заполнения таблицы для реализации "браузера метаданных".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsMeasure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsMeasure : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, может ли свойство зависимостей влиять на передачу измерения во время операций обработчика макета.</summary>
        <value>Значение <see langword="true" />, если свойство зависимостей, в котором существуют эти метаданные, может влиять на передачу измерения; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement>и <xref:System.Windows.FrameworkContentElement> включают <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>  реализацию, которая отслеживает действующие изменения значений для всех свойств зависимостей, существующих в элементе. В рамках этой логики свойства зависимостей, которые изменяют эффективное значение и имеют <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> метаданные со `true` значением, будут инициировать отложенный запрос на недействительность визуальных элементов для этого элемента. Поскольку такая реализация на уровне платформы WPF уже существует, вам обычно не нужно искать свойства <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> зависимостей, если только вы не заменили или не измените поведение макета на уровне платформы WPF.  
  
 В <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> пользовательских реализациях может возникать схожее поведение при изменении свойств зависимостей <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> , `true`где свойство имеет значение.  
  
 Свойства в производных классах <xref:System.Windows.PropertyMetadata> обычно определяются в объектной модели как доступные для чтения и записи. Это значит, что их можно скорректировать после инициализации экземпляра. Однако после того, как метаданные будут потреблены как часть вызова метода <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, система свойств зазапечатана, что экземпляр метаданных и свойства, передающие особенности метаданных, теперь считаются неизменяемыми. Попытка установить это свойство после <xref:System.Windows.PropertyMetadata.IsSealed%2A> `true` в этом экземпляре метаданных вызовет исключение.  
  
<a name="xamlTextUsage_AffectsMeasure"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Члены этого класса обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 Следующий пример получает метаданные по умолчанию из различных полей свойств зависимости, запрашивает значения различных <xref:System.Windows.FrameworkPropertyMetadata> свойств в нем и использует эти сведения для заполнения таблицы для реализации "браузера метаданных".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentArrange">
      <MemberSignature Language="C#" Value="public bool AffectsParentArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentArrange { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsParentArrange : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, может ли свойство зависимостей влиять на передачу размещения разметки родительского элемента во время операций обработчика разметки.</summary>
        <value>Значение <see langword="true" />, если свойство зависимостей, в котором существуют метаданные, влияет на передачу размещения непосредственно в родительском элементе; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement>и <xref:System.Windows.FrameworkContentElement> включают <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>  реализацию, которая отслеживает действующие изменения значений для всех свойств зависимостей, существующих в элементе. В рамках этой логики свойства зависимостей, которые изменяют эффективное значение и имеют <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> метаданные со `true` значением, будут инициировать отложенный запрос на недействительность визуальных элементов для родительского элемента.  
  
 Как правило, нет необходимости <xref:System.Windows.FrameworkElement> сообщать об изменениях свойства в родительский элемент с помощью <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> , так как сам элемент уже имеет свой собственный <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> как `true`. Обычно это достаточно, поскольку изменения в дочернем элементе обычно инициируют родительский элемент при необходимости. <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>иногда используется для <xref:System.Windows.FrameworkContentElement> производного класса. В этом случае дочерний элемент задает свойство, но <xref:System.Windows.FrameworkContentElement> производный класс не управляет его собственной отрисовкой. Отрисовка обрабатывается <xref:System.Windows.FrameworkElement> родительским элементом, который выступает в качестве узла содержимого. Например, изменение значения <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> присоединенного свойства дочерним элементом сделает недействительным расположение родителя, так как должно быть изменено расположение дочернего элемента в родительском элементе. Поэтому присоединенное свойство имеет метаданные, где <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> имеет  `true` значение.  <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> Другой пример: <xref:System.Windows.Controls.Control.Padding%2A>при изменении этого свойства родительский элемент может изменить положение дочернего элемента в зависимости от доступного пространства.  
  
 Поскольку такая реализация на уровне платформы WPF уже существует, вам обычно не нужно искать свойства <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> зависимостей, если только вы не заменили или не измените поведение макета на уровне платформы WPF.  
  
 В <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> пользовательских реализациях может возникать схожее поведение при изменении свойств зависимостей <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> , `true`где свойство имеет значение.  
  
 Свойства в любых производных классах <xref:System.Windows.PropertyMetadata> обычно определяются в объектной модели как доступные для чтения и записи. Это значит, что их можно скорректировать после инициализации экземпляра. Однако после того, как метаданные будут потреблены как часть вызова метода <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, система свойств зазапечатана, что экземпляр метаданных и свойства, передающие особенности метаданных, теперь считаются неизменяемыми. Попытка установить это свойство после <xref:System.Windows.PropertyMetadata.IsSealed%2A> `true` в этом экземпляре метаданных вызовет исключение.  
  
<a name="xamlTextUsage_AffectsParentArrange"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Члены этого класса обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsParentMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentMeasure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsParentMeasure : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, может ли свойство зависимостей потенциально влиять на передачу показателей разметки родительского элемента во время операций обработчика разметки.</summary>
        <value>Значение <see langword="true" />, если свойство зависимостей, в котором существуют метаданные, влияет на передачу измерений непосредственно на родительском элементе; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement>и <xref:System.Windows.FrameworkContentElement> включают <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>  реализацию, которая отслеживает действующие изменения значений для всех свойств зависимостей, существующих в элементе. В рамках этой логики свойства зависимостей, которые изменяют эффективное значение и имеют <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> метаданные со `true` значением, будут инициировать отложенный запрос на недействительность визуальных элементов для родительского элемента. Поскольку такая реализация на уровне платформы WPF уже существует, вам обычно не нужно искать свойства <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> зависимостей, если только вы не заменили или не измените поведение макета на уровне платформы WPF.  
  
 Как правило, нет необходимости <xref:System.Windows.FrameworkElement> сообщать об изменениях свойства в родительский элемент с помощью <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> , так как сам элемент уже имеет свой собственный <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> как `true`. Как правило, это достаточно, так как изменения в дочернем элементе, как правило, инициируют этап родительской меры, если это уместно. <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>иногда используется для <xref:System.Windows.FrameworkContentElement> производного класса. В этом случае дочерний элемент задает свойство, но <xref:System.Windows.FrameworkContentElement> производный класс не управляет его собственной отрисовкой. Отрисовка обрабатывается <xref:System.Windows.FrameworkElement> родительским элементом, который выступает в качестве узла содержимого. Например, изменение значения <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> свойства на дочернем элементе делает недействительной меру родителя, поскольку относительный отступ абзацев может измениться и может увеличить или уменьшить размер узла содержимого. Поэтому свойство имеет метаданные, где <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> имеет `true`значение. <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType>  
  
 Элементы узла содержимого также часто ищут изменения в свойствах зависимостей, <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> где `true`— это часть логики отрисовки узла содержимого. Например, <xref:System.Windows.Controls.TextBox> элемент должен отвечать на определенные изменения в тексте, который может потребовать изменения ограничивающего прямоугольника <xref:System.Windows.Controls.TextBox> самого себя.  
  
 В <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> пользовательских реализациях может возникать схожее поведение при изменении свойств зависимостей <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> , `true`где свойство имеет значение.  
  
 Свойства в любых производных классах <xref:System.Windows.PropertyMetadata> обычно определяются в объектной модели как доступные для чтения и записи. Это значит, что их можно скорректировать после инициализации экземпляра. Однако после того, как метаданные будут потреблены как часть вызова метода <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, система свойств зазапечатана, что экземпляр метаданных и свойства, передающие особенности метаданных, теперь считаются неизменяемыми. Попытка установить это свойство после <xref:System.Windows.PropertyMetadata.IsSealed%2A> `true` в этом экземпляре метаданных вызовет исключение.  
  
<a name="xamlTextUsage_AffectsParentMeasure"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Члены этого класса обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsRender">
      <MemberSignature Language="C#" Value="public bool AffectsRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsRender { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsRender : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, может ли свойство зависимостей влиять на общий макет таким способом, который не оказывает специального воздействия на расположение или размеры, но требует перерисовку.</summary>
        <value>Значение <see langword="true" />, если свойство зависимостей, в котором существуют эти метаданные, влияет на отрисовку; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement>и <xref:System.Windows.FrameworkContentElement> включают <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>  реализацию, которая отслеживает действующие изменения значений для всех свойств зависимостей, существующих в элементе. В рамках этой логики свойства зависимостей, которые изменяют эффективное значение и имеют <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> метаданные со `true` значением, будут инициировать отложенный запрос на недействительность визуальных элементов для этого элемента. Поскольку такая реализация на уровне платформы WPF уже существует, вам обычно не нужно искать свойства <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> зависимостей, если только вы не заменили или не измените поведение макета на уровне платформы WPF.  
  
 В <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> пользовательских реализациях может возникать схожее поведение при изменении свойств зависимостей <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> , `true`где свойство имеет значение.  
  
 Свойства в любых производных классах <xref:System.Windows.PropertyMetadata> обычно определяются в объектной модели как доступные для чтения и записи. Это значит, что их можно скорректировать после инициализации экземпляра. Однако после того, как метаданные будут потреблены как часть вызова метода <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, система свойств зазапечатана, что экземпляр метаданных и свойства, передающие особенности метаданных, теперь считаются неизменяемыми. Попытка установить это свойство после <xref:System.Windows.PropertyMetadata.IsSealed%2A> `true` в этом экземпляре метаданных вызовет исключение.  
  
<a name="xamlTextUsage_AffectsRender"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Члены этого класса обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 Следующий пример получает метаданные по умолчанию из различных полей свойств зависимости, запрашивает значения различных <xref:System.Windows.FrameworkPropertyMetadata> свойств в нем и использует эти сведения для заполнения таблицы для реализации "браузера метаданных".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="BindsTwoWayByDefault">
      <MemberSignature Language="C#" Value="public bool BindsTwoWayByDefault { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BindsTwoWayByDefault" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberSignature Language="VB.NET" Value="Public Property BindsTwoWayByDefault As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BindsTwoWayByDefault { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BindsTwoWayByDefault : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, создает ли свойство двухсторонние привязки по умолчанию.</summary>
        <value>Значение <see langword="true" />, если свойство зависимостей, в котором существуют эти метаданные, создает двухсторонние привязки по умолчанию; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В отсутствие этого свойства `true`Привязка обновлений по умолчанию является односторонней на основе поведения <xref:System.Windows.Data.Binding> конструкторов или эквивалентного [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] синтаксиса по умолчанию.  
  
 В существующих элементах, как правило, этому свойству присваивается значение `true` в метаданных для свойств зависимостей, например <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=nameWithType>, состояние отчета и изменяемые пользователем действия.  
  
 Это свойство сообщает только о характеристиках обновления привязки по умолчанию свойства зависимостей в целом. Любой набор привязок для этого свойства в экземпляре служб может локально <xref:System.Windows.Data.Binding.Mode%2A> задать свойство привязки и изменить это значение по умолчанию.  
  
 Свойства в любых производных классах <xref:System.Windows.PropertyMetadata> обычно определяются в объектной модели как доступные для чтения и записи. Это значит, что их можно скорректировать после инициализации экземпляра. Однако после того, как метаданные будут потреблены как часть вызова метода <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, система свойств зазапечатана, что экземпляр метаданных и свойства, передающие особенности метаданных, теперь считаются неизменяемыми. Попытка установить это свойство после <xref:System.Windows.PropertyMetadata.IsSealed%2A> `true` в этом экземпляре метаданных вызовет исключение.  
  
<a name="xamlTextUsage_BindsTwoWayByDefault"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Члены этого класса обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 Следующий пример получает метаданные по умолчанию из различных полей свойств зависимости, запрашивает значения различных <xref:System.Windows.FrameworkPropertyMetadata> свойств в нем и использует эти сведения для заполнения таблицы для реализации "браузера метаданных".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="DefaultUpdateSourceTrigger">
      <MemberSignature Language="C#" Value="public System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultUpdateSourceTrigger As UpdateSourceTrigger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::UpdateSourceTrigger DefaultUpdateSourceTrigger { System::Windows::Data::UpdateSourceTrigger get(); void set(System::Windows::Data::UpdateSourceTrigger value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultUpdateSourceTrigger : System.Windows.Data.UpdateSourceTrigger with get, set" Usage="System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.UpdateSourceTrigger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение по умолчанию для <see cref="T:System.Windows.Data.UpdateSourceTrigger" />, который используется при привязке свойства к которому применены данные метаданные, с <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> имеющими значение <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</summary>
        <value>Значение перечисления, кроме как <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойства в производных классах <xref:System.Windows.PropertyMetadata> обычно определяются в объектной модели как доступные для чтения и записи. Это значит, что их можно скорректировать после инициализации экземпляра. Однако после того, как метаданные будут потреблены как часть вызова метода <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, система свойств зазапечатана, что экземпляр метаданных и свойства, передающие особенности метаданных, теперь считаются неизменяемыми. Попытка установить это свойство после <xref:System.Windows.PropertyMetadata.IsSealed%2A> `true` в этом экземпляре метаданных вызовет исключение.  
  
<a name="xamlTextUsage_DefaultUpdateSourceTrigger"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Члены этого класса обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Данному свойству присвоено значение <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />; указанное значение будет считаться значением по умолчанию при получении запросов от привязок.</exception>
        <exception cref="T:System.InvalidOperationException">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</exception>
      </Docs>
    </Member>
    <Member MemberName="Inherits">
      <MemberSignature Language="C#" Value="public bool Inherits { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Inherits" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberSignature Language="VB.NET" Value="Public Property Inherits As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Inherits { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Inherits : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, которое указывает, наследуется ли значение свойства зависимостей.</summary>
        <value>Значение <see langword="true" />, если значение свойства может быть унаследовано; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Наследование значений свойств — это функция [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] системы свойств на уровне платформы WPF, с помощью которой определенные свойства зависимостей могут быть заданы локально на элементе в корне [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] дерева элементов или рядом с ним, а значения наследуются все элементы в логическом дереве дочерних элементов, которые также обладают этим свойством. Наследование значений свойств не включено по умолчанию, и включение этого параметра влияет на производительность. Подробнее см. в разделе [Наследование значения свойства](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
> [!NOTE]
>  Несмотря на то, что наследование значений свойств может работать для неприсоединенных свойств зависимостей, поведение наследования для неприсоединенного свойства через определенные подразделения объектов в дереве среды выполнения не определено. Всегда используйте <xref:System.Windows.DependencyProperty.RegisterAttached%2A> для регистрации свойств, в которых <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> указывается в метаданных.  
  
 Свойства в производных классах <xref:System.Windows.PropertyMetadata> обычно определяются в объектной модели как доступные для чтения и записи. Это значит, что их можно скорректировать после инициализации экземпляра. Однако после того, как метаданные будут потреблены как часть вызова метода <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, система свойств зазапечатана, что экземпляр метаданных и свойства, передающие особенности метаданных, теперь считаются неизменяемыми. Попытка установить это свойство после <xref:System.Windows.PropertyMetadata.IsSealed%2A> `true` в этом экземпляре метаданных вызовет исключение.  
  
<a name="xamlTextUsage_Inherits"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Члены этого класса обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 Следующий пример получает метаданные по умолчанию из различных полей свойств зависимости, запрашивает значения различных <xref:System.Windows.FrameworkPropertyMetadata> свойств в нем и использует эти сведения для заполнения таблицы для реализации "браузера метаданных".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsDataBindingAllowed">
      <MemberSignature Language="C#" Value="public bool IsDataBindingAllowed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDataBindingAllowed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDataBindingAllowed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDataBindingAllowed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDataBindingAllowed : bool" Usage="System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, поддерживается ли привязка данных для свойства зависимостей.</summary>
        <value>Значение <see langword="true" />, если привязка данных поддерживается для свойства зависимостей, к которому применяются эти метаданные; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство сообщает `false` одно из двух возможных условий: привязка данных к свойству зависимости не разрешена, так как свойство зависимостей доступно только для чтения (как указано в идентификаторе свойства зависимостей, а не в метаданных) или значение другое свойство метаданных, <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>имеет `true` значение в этих метаданных. Это свойство предоставляется в качестве удобства, поэтому вызывающим объектам не нужно проверять оба <xref:System.Windows.DependencyProperty.ReadOnly%2A> значения и. <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>  
  
 Если вы пытаетесь создать метаданные, указывающие, что в противном случае свойство для чтения и записи не должно поддерживать привязку данных, <xref:System.Windows.FrameworkPropertyMetadataOptions.NotDataBindable> укажите флаг (Обратите внимание на незначительное различие соглашений об именовании и <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>).  
  
<a name="xamlTextUsage_IsDataBindingAllowed"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Члены этого класса обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 Следующий пример получает метаданные по умолчанию из различных полей свойств зависимости, запрашивает значения различных <xref:System.Windows.FrameworkPropertyMetadata> свойств в нем и использует эти сведения для заполнения таблицы для реализации "браузера метаданных".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsNotDataBindable">
      <MemberSignature Language="C#" Value="public bool IsNotDataBindable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotDataBindable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberSignature Language="VB.NET" Value="Public Property IsNotDataBindable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotDataBindable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsNotDataBindable : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, которое указывает, поддерживает ли свойство зависимостей привязку данных.</summary>
        <value>Значение <see langword="true" />, если свойство не поддерживает привязку данных; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обратите внимание, что это свойство метаданных `true` имеет значение исключительно для свойств, которые не должны поддерживать привязку данных, несмотря на свойства, доступные для чтения и записи. Ожидание заключается в том, что в большинстве случаев, когда объявляется свойство зависимости, требуется привязка данных, поскольку привязка данных является одним из ключевых сценариев, в которых свойство зависимостей полезно. В отличие <xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>от этого, это не просто изменяет значение по умолчанию, которое впоследствии может быть изменено в конкретной привязке. Задание этого свойства `true` в метаданных для метаданных свойства зависимости приведет к отключению всех привязок к применению их значений через выражения к этому свойству зависимостей.  
  
 Свойства зависимостей только для чтения не поддерживают привязку данных (так как они не имеют метода задания, который может применить измененные значения), но `false` по <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>-прежнему будет сообщать о. Это связано с тем, что свойства, <xref:System.Windows.FrameworkPropertyMetadataOptions> соответствующие значениям, будут сообщать о том, как метаданные фактически были установлены, а не всегда сообщать о поведении, которое может предположить именование свойства. Чтобы определить, допускает ли данное свойство зависимости привязку данных, обычно следует <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> проверять. <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A>является удобным для проверки <xref:System.Windows.DependencyProperty.ReadOnly%2A> и <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A> в качестве одной операции, выдавая ожидаемый результат.  
  
 Свойства в производных классах <xref:System.Windows.PropertyMetadata> обычно определяются в объектной модели как доступные для чтения и записи. Это значит, что их можно скорректировать после инициализации экземпляра. Однако после того, как метаданные будут потреблены как часть вызова метода <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, система свойств зазапечатана, что экземпляр метаданных и свойства, передающие особенности метаданных, теперь считаются неизменяемыми. Попытка установить это свойство после <xref:System.Windows.PropertyMetadata.IsSealed%2A> `true` в этом экземпляре метаданных вызовет исключение.  
  
<a name="xamlTextUsage_IsNotDataBindable"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Члены этого класса обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</exception>
        <altmember cref="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="Journal">
      <MemberSignature Language="C#" Value="public bool Journal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Journal" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberSignature Language="VB.NET" Value="Public Property Journal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Journal { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Journal : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, содержит ли это свойство сведения о ведении журнала, которые приложения могут или должны хранить как часть реализации процесса ведения журнала.</summary>
        <value>Значение <see langword="true" />, если ведение журнала должно быть выполнено для свойства зависимостей, к которому применяются эти метаданные; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойства в производных классах <xref:System.Windows.PropertyMetadata> обычно определяются в объектной модели как доступные для чтения и записи. Это значит, что их можно скорректировать после инициализации экземпляра. Однако после того, как метаданные будут потреблены как часть вызова метода <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, система свойств зазапечатана, что экземпляр метаданных и свойства, передающие особенности метаданных, теперь считаются неизменяемыми. Попытка установить это свойство после <xref:System.Windows.PropertyMetadata.IsSealed%2A> `true` в этом экземпляре метаданных вызовет исключение.  
  
<a name="xamlTextUsage_Journal"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Члены этого класса обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="T:System.Windows.Navigation.JournalEntry" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected override void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="override this.Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit" Usage="frameworkPropertyMetadata.Merge (baseMetadata, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata">Базовые метаданные для слияния.</param>
        <param name="dp">Свойство зависимостей, к которому применяются эти метаданные.</param>
        <summary>Обеспечивает слияние исходных метаданных с базовыми.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется внутренне при переопределении метаданных.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Классы, производные от <see cref="T:System.Windows.PropertyMetadata" /> (или особенно), должны переопределять этот метод, чтобы учитывать все свойства метаданных, добавленные в их реализациях. Например, ваша реализация может добавить новое значение перечисления флагового, а <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> реализация должна иметь возможность правильно сочетать эти флаги.  
  
Всегда вызывайте базовую реализацию перед собственной реализацией, так как базовая реализация выполняет слияние всех свойств, уже определенных в предыдущих типах в иерархии.  
  
Поведение, добавленное <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> реализацией в <see cref="T:System.Windows.FrameworkPropertyMetadata" /> , заключается в том, что определенные свойства уровня среды WPF в метаданных <see cref="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" /> , такие как, объединяются в битовой операции или.  
  
Поведение также реализует поведение при переопределении метаданных свойства в существующем свойстве зависимости путем вызова <see cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />, с использованием метаданных переопределения, которые имеют значение  <see cref="T:System.Windows.FrameworkPropertyMetadata" /> .  <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /></para></block>
        <altmember cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected override void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberSignature Language="F#" Value="override this.OnApply : System.Windows.DependencyProperty * Type -&gt; unit" Usage="frameworkPropertyMetadata.OnApply (dp, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp">Свойство зависимостей, к которому были применены эти метаданные.</param>
        <param name="targetType">Тип, связанный с этими метаданными, если это метаданные зависящие от типа. В случае с метаданными по умолчанию, значение может быть <see langword="null" />.</param>
        <summary>Вызывается после применения данных метаданных к свойству, указывая на запечатывание метаданных.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При вызове этого метода все изменяемые <xref:System.Windows.FrameworkPropertyMetadata> структуры данных экземпляра должны быть помечены как неизменные.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see cref="T:System.Windows.FrameworkPropertyMetadata" /> Реализация этого метода не делает ничего, кроме вызова базовой реализации.</para></block>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OverridesInheritanceBehavior">
      <MemberSignature Language="C#" Value="public bool OverridesInheritanceBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesInheritanceBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesInheritanceBehavior As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesInheritanceBehavior { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesInheritanceBehavior : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, должно ли вычисление наследования значения свойства охватывать определенные границы содержимого в логическом дереве элементов.</summary>
        <value>Значение <see langword="true" />, если наследование значения свойства должно охватывать определенные границы содержимого; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эти метаданные сообщают о нередком изменении поведения наследования значений свойств через специальные границы родительского элемента-потомков. Каноническим примером такой границы является содержимое <xref:System.Windows.Controls.Frame>, <xref:System.Windows.Controls.Frame> где содержимое может быть перезагружено независимо от существования <xref:System.Windows.Controls.Frame>. Требуемое поведение системы свойств заключается в том, что наследование значения свойства не должно передаваться <xref:System.Windows.Controls.Frame>в содержимое, поскольку это содержимое может быть элементом, который приложение, в котором размещается кадр, не владеет и не контролируется. Указание метаданных с <xref:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior%2A> `true`параметром, равным, а <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> также `true`с указанием AS, приведет к тому, что свойство, к которому применяются метаданные, будет <xref:System.Windows.Controls.Frame> наследоваться даже через границы или аналогичные границы.  
  
 Свойства в производных классах <xref:System.Windows.PropertyMetadata> обычно определяются в объектной модели как доступные для чтения и записи. Это значит, что их можно скорректировать после инициализации экземпляра. Однако после того, как метаданные будут потреблены как часть вызова метода <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, система свойств зазапечатана, что экземпляр метаданных и свойства, передающие особенности метаданных, теперь считаются неизменяемыми. Попытка установить это свойство после <xref:System.Windows.PropertyMetadata.IsSealed%2A> `true` в этом экземпляре метаданных вызовет исключение.  
  
<a name="xamlTextUsage_OverridesInheritanceBehavior"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Члены этого класса обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="SubPropertiesDoNotAffectRender">
      <MemberSignature Language="C#" Value="public bool SubPropertiesDoNotAffectRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="VB.NET" Value="Public Property SubPropertiesDoNotAffectRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SubPropertiesDoNotAffectRender { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SubPropertiesDoNotAffectRender : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, влияют ли подсвойства свойства зависимостей на отрисовку вмещающего объекта.</summary>
        <value>Значение <see langword="true" />, если изменения значений подсвойств не влияют на отрисовку; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот параметр метаданных имеет отношение к свойствам зависимостей, которые являются ссылочными типами, где у этого типа есть собственные значения свойств. Как правило, логика системы макета предполагает, что любое свойство зависимости с подсвойствами может повлиять на макет, так как проверка всех подсвойств для изменений занимает больше времени, чем фактическое выполнение другого прохода визуализации. Установка этого параметра в `true` применяется для оптимизации производительности реализации системы макета на уровне платформы WPF.  
  
 Свойства в производных классах <xref:System.Windows.PropertyMetadata> обычно определяются в объектной модели как доступные для чтения и записи. Это значит, что их можно скорректировать после инициализации экземпляра. Однако после того, как метаданные будут потреблены как часть вызова метода <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, система свойств зазапечатана, что экземпляр метаданных и свойства, передающие особенности метаданных, теперь считаются неизменяемыми. Попытка установить это свойство после <xref:System.Windows.PropertyMetadata.IsSealed%2A> `true` в этом экземпляре метаданных вызовет исключение.  
  
<a name="xamlTextUsage_SubPropertiesDoNotAffectRender"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Члены этого класса обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</exception>
        <altmember cref="T:System.Windows.Freezable" />
      </Docs>
    </Member>
  </Members>
</Type>
