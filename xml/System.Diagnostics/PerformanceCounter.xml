<Type Name="PerformanceCounter" FullName="System.Diagnostics.PerformanceCounter">
  <Metadata><Meta Name="ms.openlocfilehash" Value="bd0c55ee21dffb374e584dc23c8bc744d5198395" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75137552" /></Metadata><TypeSignature Language="C#" Value="public sealed class PerformanceCounter : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit PerformanceCounter extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.PerformanceCounter" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class PerformanceCounter&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class PerformanceCounter sealed : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type PerformanceCounter = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Diagnostics.PerformanceCounterInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.PerformanceCounterDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.PerformanceCounterInstaller,System.Configuration.Install, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.PerformanceCounterInstaller,System.Configuration.Install, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.PerformanceCounterInstaller,System.Configuration.Install, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет компонент счетчика производительности Windows NT.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Компонент <xref:System.Diagnostics.PerformanceCounter> можно использовать для считывания существующих предопределенных или пользовательских счетчиков и публикации (записи) данных производительности в пользовательские счетчики.  
  
 В [диалоговом окне Добавление счетчиков](https://go.microsoft.com/fwlink/p/?LinkId=257854)в системном мониторе Windows имеется множество предопределенных счетчиков. Дополнительные сведения о счетчиках производительности .NET Framework см. в разделе [счетчики производительности](~/docs/framework/debug-trace-profile/performance-counters.md).  
  
 Этот тип реализует интерфейс <xref:System.IDisposable>. По окончании использования выдаленную ему память следует прямо или косвенно освободить. Чтобы сделать это прямо, вызовите его метод <xref:System.IDisposable.Dispose%2A> в блоке `try`/`catch`. Чтобы сделать это косвенно, используйте языковые конструкции, такие как `using` (в C#) или `Using` (в Visual Basic). Дополнительные сведения см. в разделе "Использование объекта, реализующего IDisposable" в статье об интерфейсе <xref:System.IDisposable>.  
  
> [!IMPORTANT]
>  В версиях 1,0 и 1,1 .NET Framework этот класс требует, чтобы непосредственные вызывающие объекты были полностью доверенными. Начиная с версии .NET Framework 2,0 этот класс требует <xref:System.Diagnostics.PerformanceCounterPermission> для определенных действий. Настоятельно рекомендуется <xref:System.Diagnostics.PerformanceCounterPermission> не предоставлять частично доверенному коду.  Возможность чтения и записи счетчиков производительности позволяет коду выполнять такие действия, как перечисление выполняющихся процессов и получение сведений о них.  
>   
>  Кроме того, передача объекта <xref:System.Diagnostics.PerformanceCounter> в код с меньшим доверием может привести к проблемам безопасности. Никогда не передавайте объекты счетчиков производительности, например <xref:System.Diagnostics.PerformanceCounterCategory> или <xref:System.Diagnostics.PerformanceCounter>, в менее надежный код.  
  
 Чтобы считать данные из счетчика производительности, создайте экземпляр класса <xref:System.Diagnostics.PerformanceCounter>, задайте <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>и, при необходимости, свойства <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> или <xref:System.Diagnostics.PerformanceCounter.MachineName%2A>, а затем вызовите метод <xref:System.Diagnostics.PerformanceCounter.NextValue%2A>, чтобы получить показания счетчика производительности.  
  
 Чтобы опубликовать данные счетчика производительности, создайте один или несколько пользовательских счетчиков с помощью метода <xref:System.Diagnostics.PerformanceCounterCategory.Create%2A?displayProperty=nameWithType>, создайте экземпляр класса <xref:System.Diagnostics.PerformanceCounter>, задайте свойства <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> и, при необходимости <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> или <xref:System.Diagnostics.PerformanceCounter.MachineName%2A>, а затем вызовите методы <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>, <xref:System.Diagnostics.PerformanceCounter.Increment%2A>или <xref:System.Diagnostics.PerformanceCounter.Decrement%2A> или задайте свойство <xref:System.Diagnostics.PerformanceCounter.RawValue%2A>, чтобы изменить значение пользовательского счетчика.  
  
> [!NOTE]
>  Методы <xref:System.Diagnostics.PerformanceCounter.Increment%2A>, <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>и <xref:System.Diagnostics.PerformanceCounter.Decrement%2A> используют взаимоблокировки для обновления значения счетчика. Это позволяет точно синхронизировать значение счетчика в многопоточных или многопроцессных сценариях, но также приводит к снижению производительности. Если точность, предоставляемая блокируемыми операциями, не нужна, можно обновить свойство <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> напрямую в 5 раз, чтобы улучшить производительность.  Однако в многопоточных сценариях некоторые обновления значения счетчика могут игнорироваться, что приводит к неточности данных.  
  
 Счетчик — это механизм, с помощью которого собираются данные о производительности. В реестре хранятся имена всех счетчиков, каждый из которых связан с определенной областью функциональных возможностей системы. К примерам относятся время занятости процессора, использование памяти или число байтов, полученных через сетевое подключение.  
  
 Каждый счетчик однозначно определяется по его имени и расположению. Так же, как путь к файлу включает диск, каталог, один или несколько подкаталогов и имя файла, сведения о счетчике состоят из четырех элементов: компьютера, категории, экземпляра категории и имени счетчика.  
  
 Данные счетчика должны включать категорию или объект производительности, который счетчик измеряет данные. К категориям компьютера относятся физические компоненты, такие как процессоры, диски и память. Существуют также системные категории, такие как процессы и потоки. Каждая категория связана с функциональным элементом на компьютере и имеет набор стандартных счетчиков, назначенных ему. Эти объекты перечислены в раскрывающемся списке "объект производительности" диалогового окна Добавление счетчиков в системном мониторе Windows 2000, и их необходимо включить в путь к счетчику. Данные производительности группируются по категории, к которой он относится.  
  
 В некоторых случаях могут существовать несколько копий одной и той же категории. Например, несколько процессов и потоков выполняются одновременно, и некоторые компьютеры содержат более одного процессора. Копии категорий называются экземплярами категорий, и каждому экземпляру назначается набор стандартных счетчиков. Если категория может иметь более одного экземпляра, в данные счетчика необходимо добавить спецификацию экземпляра.  
  
 Чтобы получить данные о производительности для счетчиков, для которых требуется начальное или предыдущее значение для выполнения необходимого вычисления, вызовите метод <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> дважды и используйте возвращенную информацию, как требуется приложению.  
  
> [!NOTE]
>  Категории счетчиков производительности, установленные с [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] используют отдельную общую память, каждая из категорий счетчиков производительности имеет собственную память. Можно указать размер отдельной общей памяти, создав DWORD с именем Филемаппингсизе в разделе реестра HKEY_LOCAL_MACHINE \Систем\куррентконтролсет\сервицес\\*\<Category name >* \перформанце. Значение Филемаппингсизе устанавливается равным общему объему памяти для категории. Размер по умолчанию — 131072 десятичный. Если значение Филемаппингсизе отсутствует, используется значение атрибута `fileMappingSize` для элемента `performanceCounters`, указанного в файле Machine. config, что приводит к дополнительным издержкам на обработку файла конфигурации. Можно повысить производительность при запуске приложения, задав размер сопоставления файлов в реестре. Дополнительные сведения о размере сопоставления файлов см. в разделе [&lt;performancecounters&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/performancecounters-element.md).  
  
   
  
## Examples  
 В следующем примере кода показано использование класса <xref:System.Diagnostics.PerformanceCounter> для создания и использования типа счетчика <xref:System.Diagnostics.PerformanceCounterType.AverageCount64>. Пример создает категории, настраивает счетчики, собирает данные из счетчиков и вызывает класс <xref:System.Diagnostics.CounterSampleCalculator> для интерпретации данных счетчика производительности. Промежуточные и окончательные результаты отображаются в окне консоли. Дополнительные примеры других типов счетчиков производительности см. в разделе Перечисление <xref:System.Diagnostics.PerformanceCounterType>.  
  
 [!code-cpp[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CPP/averagecount32.cpp#1)]
 [!code-csharp[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CS/averagecount32.cs#1)]
 [!code-vb[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/VB/averagecount32.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Diagnostics.PerformanceCounterType" />
    <altmember cref="T:System.Diagnostics.CounterCreationData" />
    <altmember cref="T:System.Diagnostics.CounterCreationDataCollection" />
    <altmember cref="T:System.Diagnostics.CounterSample" />
    <altmember cref="T:System.Diagnostics.CounterSampleCalculator" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот класс нельзя использовать в частично доверенном коде.</permission>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Diagnostics.PerformanceCounter" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Выполняет инициализацию нового, доступного только для чтения экземпляра класса <see cref="T:System.Diagnostics.PerformanceCounter" />, не связывая этот экземпляр с каким-нибудь системным или определенным пользователем счетчиком производительности.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка конструктора устанавливает свойства <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>и <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> в пустые строки ("") и устанавливает свойство <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> на локальный компьютер (".").  
  
 Этот конструктор не инициализирует счетчик производительности, поэтому он не связывает экземпляр с существующим счетчиком на локальном компьютере. Чтобы указать конкретный счетчик производительности, задайте <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>и (необязательно) свойства <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> и <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> перед чтением любых других свойств или попыткой чтения из счетчика. Чтобы записать данные в счетчик производительности, задайте для свойства <xref:System.Diagnostics.PerformanceCounter.ReadOnly%2A> значение `false`.  
  
> [!NOTE]
>  Атрибут <xref:System.Security.Permissions.HostProtectionAttribute>, применяемый к этому элементу, имеет следующее <xref:System.Security.Permissions.HostProtectionAttribute.Resources%2A> значение свойства &#124; : <xref:System.Security.Permissions.HostProtectionResource.Synchronization> <xref:System.Security.Permissions.HostProtectionResource.SharedState>. Атрибут <xref:System.Security.Permissions.HostProtectionAttribute> не оказывает влияния на настольные приложения (обычно запускаемые двойным щелчком значка, вводом команды или URL-адреса в браузере). Дополнительные сведения см. в разделе <xref:System.Security.Permissions.HostProtectionAttribute> класс или [SQL Server атрибуты защиты узла](~/docs/framework/performance/sql-server-programming-and-host-protection-attributes.md).  
  
   
  
## Examples  
 В следующем примере кода создается экземпляр класса <xref:System.Diagnostics.PerformanceCounter> по умолчанию. После создания экземпляра задаются значения свойств <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>и <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>, а также отображаются результаты вызова метода <xref:System.Diagnostics.PerformanceCounter.NextValue%2A>.  
  
 [!code-cpp[PerfCounter#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerfCounter/CPP/perfcounter.cpp#1)]
 [!code-csharp[PerfCounter#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerfCounter/CS/perfcounter.cs#1)]
 [!code-vb[PerfCounter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerfCounter/VB/perfcounter.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">для записи категории счетчика производительности, если свойство <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> имеет значение <see langword="false" />. Связанное перечисление: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter (string categoryName, string counterName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string counterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, counterName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter(System::String ^ categoryName, System::String ^ counterName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.PerformanceCounter : string * string -&gt; System.Diagnostics.PerformanceCounter" Usage="new System.Diagnostics.PerformanceCounter (categoryName, counterName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="categoryName">Имя категории счетчика производительности (объект производительности), которому соответствует этот счетчик производительности.</param>
        <param name="counterName">Имя счетчика производительности.</param>
        <summary>Выполняет инициализацию нового, доступного только для чтения экземпляра класса <see cref="T:System.Diagnostics.PerformanceCounter" /> и связывает этот экземпляр с конкретным системным или определенным пользователем счетчиком производительности на локальном компьютере. Этот конструктор требует, чтобы категория имела единственный экземпляр.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В строках параметров регистр не учитывается.  
  
 Используйте эту перегрузку для доступа к счетчику на локальном компьютере, который принадлежит к категории, содержащей один экземпляр категории счетчика производительности. При попытке использовать этот конструктор для указания <xref:System.Diagnostics.PerformanceCounter> экземпляра на категорию, содержащую несколько экземпляров, конструктор выдает исключение. Эта перегрузка может обращаться к любому счетчику только для чтения или чтения и записи, но делает это в режиме только для чтения. Экземпляр <xref:System.Diagnostics.PerformanceCounter>, созданный с помощью этой перегрузки, не может записывать в счетчик, даже если сам счетчик доступен для чтения и записи.  
  
 Эта перегрузка конструктора задает для свойств <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A> и <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> значения, которые вы передали, устанавливает свойство <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> на локальный компьютер, "." и устанавливает для свойства <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> пустую строку ("").  
  
 Этот конструктор инициализирует счетчик производительности и связывает экземпляр с существующим счетчиком (системой или пользовательским счетчиком) на локальном компьютере. Значения, передаваемые для свойств <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A> и <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, должны указывать на существующий счетчик производительности на локальном компьютере.  
  
> [!NOTE]
>  Для чтения счетчиков производительности в Windows Vista, Windows XP Professional x64 Edition или Windows Server 2003 необходимо быть членом группы "Пользователи системного монитора" или обладать правами администратора.  
>   
>  Чтобы не допустить повышения привилегий для доступа к счетчикам производительности в Windows Vista, добавьте себя в группу Пользователи системного монитора.  
>   
>  В Windows Vista привилегии пользователя определяются контролем учетных записей (UAC). Члену встроенной группы "Администраторы" присваивается два маркера доступа на время выполнения: маркер доступа обычного пользователя и маркер доступа администратора. По умолчанию назначена роль обычного пользователя. Чтобы выполнить код, обращающийся к счетчикам производительности, необходимо сначала повысить привилегии обычного пользователя до администратора. Это можно сделать при запуске приложения, , щелкнув значок приложения правой кнопкой мыши и указав, что приложение должно запускаться от имени администратора.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Параметр <paramref name="categoryName" /> является пустой строкой ("").  
  
-или- 
 Параметр <paramref name="counterName" /> является пустой строкой ("").  
  
-или- 
Указанная категория не существует.  
  
-или- 
Указанная категория отмечается как многоэкземплярная и требует создания счетчика производительности с именем экземпляра.  
  
-или- 
 Параметры <paramref name="categoryName" /> и <paramref name="counterName" /> были локализованы на разных языках.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="categoryName" /> или <paramref name="counterName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Произошла ошибка при обращении к API-интерфейсу системы.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Код, выполняющийся без привилегий администратора, предпринял попытку считывания значения счетчика производительности.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">для записи категории счетчика производительности, если свойство <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> имеет значение <see langword="false" />. Связанное перечисление: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter (string categoryName, string counterName, bool readOnly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string counterName, bool readOnly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, counterName As String, readOnly As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter(System::String ^ categoryName, System::String ^ counterName, bool readOnly);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.PerformanceCounter : string * string * bool -&gt; System.Diagnostics.PerformanceCounter" Usage="new System.Diagnostics.PerformanceCounter (categoryName, counterName, readOnly)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
        <Parameter Name="readOnly" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="categoryName">Имя категории счетчика производительности (объект производительности), которому соответствует этот счетчик производительности.</param>
        <param name="counterName">Имя счетчика производительности.</param>
        <param name="readOnly">Значение <see langword="true" /> для доступа к счетчику в режиме только для чтения (хотя сам счетчик может быть для чтения/записи); значение <see langword="false" /> для доступа к счетчику в режиме чтения/записи.</param>
        <summary>Выполняет инициализацию нового, доступного только для чтения или для чтения и записи экземпляра класса <see cref="T:System.Diagnostics.PerformanceCounter" /> и связывает этот экземпляр с конкретным системным или определенным пользователем счетчиком производительности на локальном компьютере. Этот конструктор требует, чтобы категория содержала единственный экземпляр.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В строках параметров регистр не учитывается.  
  
 Используйте эту перегрузку для доступа к счетчику только для чтения или чтения и записи на локальном компьютере, который принадлежит к категории, содержащей один экземпляр категории счетчика производительности. При попытке использовать этот конструктор для указания <xref:System.Diagnostics.PerformanceCounter> экземпляра на категорию, содержащую несколько экземпляров, конструктор выдает исключение.  
  
 Эта перегрузка конструктора задает для свойств <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>и <xref:System.Diagnostics.PerformanceCounter.ReadOnly%2A> значения, которые вы передали, устанавливает свойство <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> на локальный компьютер, "." и задает для свойства <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> пустую строку ("").  
  
 Этот конструктор инициализирует счетчик производительности и связывает экземпляр с существующим счетчиком (системой или пользовательским счетчиком) на локальном компьютере. Значения, передаваемые для свойств <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A> и <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, должны указывать на существующий счетчик производительности на локальном компьютере. Если экземпляр счетчика производительности, на который указывает, является недопустимым, вызов конструктора выдаст исключение.  
  
> [!NOTE]
>  Эту перегрузку можно использовать для подключения к системному счетчику, но нельзя записывать в системный счетчик. Поэтому при установке значения `readOnly` `false` при подключении к системному счетчику конструктор создает исключение.  
  
> [!NOTE]
>  Для чтения счетчиков производительности в Windows Vista, Windows XP Professional x64 Edition или Windows Server 2003 необходимо быть членом группы "Пользователи системного монитора" или обладать правами администратора.  
>   
>  Чтобы не допустить повышения привилегий для доступа к счетчикам производительности в Windows Vista, добавьте себя в группу Пользователи системного монитора.  
>   
>  В Windows Vista привилегии пользователя определяются контролем учетных записей (UAC). Члену встроенной группы "Администраторы" присваивается два маркера доступа на время выполнения: маркер доступа обычного пользователя и маркер доступа администратора. По умолчанию назначена роль обычного пользователя. Чтобы выполнить код, обращающийся к счетчикам производительности, необходимо сначала повысить привилегии обычного пользователя до администратора. Это можно сделать при запуске приложения, , щелкнув значок приложения правой кнопкой мыши и указав, что приложение должно запускаться от имени администратора.  
  
   
  
## Examples  
 В следующем примере кода создается экземпляр класса <xref:System.Diagnostics.PerformanceCounter>. В примере передаются имена категорий, имена счетчиков и значение флага, указывающее, что счетчик не доступен только для чтения. Этот пример кода является частью более крупного примера для класса <xref:System.Diagnostics.PerformanceCounter>.  
  
 [!code-cpp[PerformanceCounterType.AverageCounter64#2](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CPP/averagecount32.cpp#2)]
 [!code-csharp[PerformanceCounterType.AverageCounter64#2](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CS/averagecount32.cs#2)]
 [!code-vb[PerformanceCounterType.AverageCounter64#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/VB/averagecount32.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Значением параметра <paramref name="categoryName" /> является пустая строка ("").  
  
-или- 
Значением параметра <paramref name="counterName" /> является пустая строка ("").  
  
-или- 
Указанная категория не существует. (если <paramref name="readOnly" /> равен <see langword="true" />).  
  
-или- 
Заданная категория не является определенной пользователем .NET Framework категорией (если <paramref name="readOnly" /> равен <see langword="false" />).  
  
-или- 
Указанная категория отмечается как многоэкземплярная и требует создания счетчика производительности с именем экземпляра.  
  
-или- 
 Параметры <paramref name="categoryName" /> и <paramref name="counterName" /> были локализованы на разных языках.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="categoryName" /> или <paramref name="counterName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Произошла ошибка при обращении к API-интерфейсу системы.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Код, выполняющийся без привилегий администратора, предпринял попытку считывания значения счетчика производительности.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">для записи категории счетчика производительности, если свойство <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> имеет значение <see langword="false" />. Связанное перечисление: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter (string categoryName, string counterName, string instanceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string counterName, string instanceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, counterName As String, instanceName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter(System::String ^ categoryName, System::String ^ counterName, System::String ^ instanceName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.PerformanceCounter : string * string * string -&gt; System.Diagnostics.PerformanceCounter" Usage="new System.Diagnostics.PerformanceCounter (categoryName, counterName, instanceName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
        <Parameter Name="instanceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="categoryName">Имя категории счетчика производительности (объект производительности), которому соответствует этот счетчик производительности.</param>
        <param name="counterName">Имя счетчика производительности.</param>
        <param name="instanceName">Имя экземпляра категории счетчика производительности или пустая строка (""), если категория содержит единственный экземпляр.</param>
        <summary>Выполняет инициализацию нового, доступного только для чтения экземпляра класса <see cref="T:System.Diagnostics.PerformanceCounter" /> и связывает этот экземпляр с конкретным системным или определенным пользователем счетчиком производительности и экземпляром категории на локальном компьютере.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В строках параметров регистр не учитывается.  
  
 Эта перегрузка конструктора задает для свойств <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>и <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> значения, которые вы передали, и задает для свойства <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> локальный компьютер ".".  
  
 Этот конструктор инициализирует счетчик производительности и связывает экземпляр с существующим счетчиком (системой или пользовательским счетчиком) на локальном компьютере. Значения, передаваемые для свойств <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>и <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>, должны указывать на существующий счетчик производительности на локальном компьютере. Если экземпляр счетчика производительности, на который указывает, является недопустимым, вызов конструктора выдаст исключение.  
  
 Эта перегрузка может обращаться к любому счетчику только для чтения или чтения и записи, но делает это в режиме только для чтения. Экземпляр <xref:System.Diagnostics.PerformanceCounter>, созданный с помощью этой перегрузки, не может записывать в счетчик, даже если сам счетчик доступен для чтения и записи.  
  
 Чтобы создать экземпляр категории производительности, укажите `instanceName` в конструкторе <xref:System.Diagnostics.PerformanceCounter.%23ctor%2A>. Если экземпляр категории, заданный с помощью `instanceName`, уже существует, новый объект будет ссылаться на существующий экземпляр категории.  
  
> [!NOTE]
>  Для чтения счетчиков производительности в Windows Vista, Windows XP Professional x64 Edition или Windows Server 2003 необходимо быть членом группы "Пользователи системного монитора" или обладать правами администратора.  
>   
>  Чтобы не допустить повышения привилегий для доступа к счетчикам производительности в Windows Vista, добавьте себя в группу Пользователи системного монитора.  
>   
>  В Windows Vista привилегии пользователя определяются контролем учетных записей (UAC). Члену встроенной группы "Администраторы" присваивается два маркера доступа на время выполнения: маркер доступа обычного пользователя и маркер доступа администратора. По умолчанию назначена роль обычного пользователя. Чтобы выполнить код, обращающийся к счетчикам производительности, необходимо сначала повысить привилегии обычного пользователя до администратора. Это можно сделать при запуске приложения, , щелкнув значок приложения правой кнопкой мыши и указав, что приложение должно запускаться от имени администратора.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Параметр <paramref name="categoryName" /> является пустой строкой ("").  
  
-или- 
 Параметр <paramref name="counterName" /> является пустой строкой ("").  
  
-или- 
Задана недопустимая категория.  
  
-или- 
Указанная категория отмечается как многоэкземплярная и требует создания счетчика производительности с именем экземпляра.  
  
-или- 
 Длина параметра <paramref name="instanceName" /> превышает 127 символов.  
  
-или- 
 Параметры <paramref name="categoryName" /> и <paramref name="counterName" /> были локализованы на разных языках.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="categoryName" /> или <paramref name="counterName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Произошла ошибка при обращении к API-интерфейсу системы.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Код, выполняющийся без привилегий администратора, предпринял попытку считывания значения счетчика производительности.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">для записи категории счетчика производительности, если свойство <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> имеет значение <see langword="false" />. Связанное перечисление: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter (string categoryName, string counterName, string instanceName, bool readOnly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string counterName, string instanceName, bool readOnly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, counterName As String, instanceName As String, readOnly As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter(System::String ^ categoryName, System::String ^ counterName, System::String ^ instanceName, bool readOnly);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.PerformanceCounter : string * string * string * bool -&gt; System.Diagnostics.PerformanceCounter" Usage="new System.Diagnostics.PerformanceCounter (categoryName, counterName, instanceName, readOnly)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
        <Parameter Name="instanceName" Type="System.String" />
        <Parameter Name="readOnly" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="categoryName">Имя категории счетчика производительности (объект производительности), которому соответствует этот счетчик производительности.</param>
        <param name="counterName">Имя счетчика производительности.</param>
        <param name="instanceName">Имя экземпляра категории счетчика производительности или пустая строка (""), если категория содержит единственный экземпляр.</param>
        <param name="readOnly">Значение <see langword="true" /> для доступа к счетчику в режиме только для чтения; значение <see langword="false" /> для доступа к счетчику в режиме чтения/записи.</param>
        <summary>Выполняет инициализацию нового, доступного только для чтения или для чтения и записи экземпляра класса <see cref="T:System.Diagnostics.PerformanceCounter" /> и связывает этот экземпляр с конкретным системным или определенным пользователем счетчиком производительности и экземпляром категории на локальном компьютере.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В строках параметров регистр не учитывается.  
  
 Используйте эту перегрузку для доступа к счетчику производительности в режиме только для чтения или чтения и записи.  
  
 Эта перегрузка конструктора задает для свойств <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>и <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> значения, которые вы передали, и задает для свойства <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> локальный компьютер ".".  
  
 Этот конструктор инициализирует счетчик производительности и связывает экземпляр с существующим счетчиком (системой или пользовательским счетчиком) на локальном компьютере. Значения, передаваемые для свойств <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>и <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>, должны указывать на существующий счетчик производительности на локальном компьютере. Если экземпляр счетчика производительности, на который указывает, является недопустимым, вызов конструктора выдаст исключение.  
  
> [!NOTE]
>  Эту перегрузку можно использовать для подключения к системному счетчику, но нельзя записывать в системный счетчик. Поэтому при установке значения `readOnly` `false` при подключении к системному счетчику конструктор создает исключение.  
  
 Чтобы создать экземпляр категории производительности, укажите `instanceName` в конструкторе <xref:System.Diagnostics.PerformanceCounter.%23ctor%2A>. Если экземпляр категории, заданный с помощью `instanceName`, уже существует, новый объект будет ссылаться на существующий экземпляр категории.  
  
> [!NOTE]
>  Для чтения счетчиков производительности в Windows Vista, Windows XP Professional x64 Edition или Windows Server 2003 необходимо быть членом группы "Пользователи системного монитора" или обладать правами администратора.  
>   
>  Чтобы не допустить повышения привилегий для доступа к счетчикам производительности в Windows Vista, добавьте себя в группу Пользователи системного монитора.  
>   
>  В Windows Vista привилегии пользователя определяются контролем учетных записей (UAC). Члену встроенной группы "Администраторы" присваивается два маркера доступа на время выполнения: маркер доступа обычного пользователя и маркер доступа администратора. По умолчанию назначена роль обычного пользователя. Чтобы выполнить код, обращающийся к счетчикам производительности, необходимо сначала повысить привилегии обычного пользователя до администратора. Это можно сделать при запуске приложения, , щелкнув значок приложения правой кнопкой мыши и указав, что приложение должно запускаться от имени администратора.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Параметр <paramref name="categoryName" /> является пустой строкой ("").  
  
-или- 
 Параметр <paramref name="counterName" /> является пустой строкой ("").  
  
-или- 
Запрошенные параметры настройки разрешения на чтение/запись являются недопустимыми для этого счетчика.  
  
-или- 
Указанная категория не существует (если <paramref name="readOnly" /> равен <see langword="true" />).  
  
-или- 
Заданная категория не является определенной пользователем .NET Framework категорией (если <paramref name="readOnly" /> равен <see langword="false" />).  
  
-или- 
Указанная категория отмечается как многоэкземплярная и требует создания счетчика производительности с именем экземпляра.  
  
-или- 
 Длина параметра <paramref name="instanceName" /> превышает 127 символов.  
  
-или- 
 Параметры <paramref name="categoryName" /> и <paramref name="counterName" /> были локализованы на разных языках.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="categoryName" /> или <paramref name="counterName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Произошла ошибка при обращении к API-интерфейсу системы.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Код, выполняющийся без привилегий администратора, предпринял попытку считывания значения счетчика производительности.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">для записи категории счетчика производительности, если свойство <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> имеет значение <see langword="false" />. Связанное перечисление: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter (string categoryName, string counterName, string instanceName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string counterName, string instanceName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, counterName As String, instanceName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter(System::String ^ categoryName, System::String ^ counterName, System::String ^ instanceName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.PerformanceCounter : string * string * string * string -&gt; System.Diagnostics.PerformanceCounter" Usage="new System.Diagnostics.PerformanceCounter (categoryName, counterName, instanceName, machineName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
        <Parameter Name="instanceName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="categoryName">Имя категории счетчика производительности (объект производительности), которому соответствует этот счетчик производительности.</param>
        <param name="counterName">Имя счетчика производительности.</param>
        <param name="instanceName">Имя экземпляра категории счетчика производительности или пустая строка (""), если категория содержит единственный экземпляр.</param>
        <param name="machineName">Компьютер, на котором существуют счетчик производительности и связанная с ним категория.</param>
        <summary>Выполняет инициализацию нового, доступного только для чтения экземпляра класса <see cref="T:System.Diagnostics.PerformanceCounter" /> и связывает этот экземпляр с конкретным системным или определенным пользователем счетчиком производительности на указанном компьютере.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В строках параметров регистр не учитывается.  
  
 Эта перегрузка конструктора задает свойства <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>и <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> передаваемым значениям.  
  
 Этот конструктор инициализирует счетчик производительности и связывает экземпляр с существующим счетчиком (системой или пользовательским счетчиком) на указанном компьютере. Значения, передаваемые для свойств <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> и <xref:System.Diagnostics.PerformanceCounter.MachineName%2A>, должны указывать на существующий счетчик производительности. Если экземпляр счетчика производительности, на который указывает, является недопустимым, вызов конструктора выдаст исключение. Эта перегрузка может обращаться к любому счетчику только для чтения или чтения и записи, но делает это в режиме только для чтения. Экземпляр <xref:System.Diagnostics.PerformanceCounter>, созданный с помощью этой перегрузки, не может записывать в счетчик, даже если сам счетчик доступен для чтения и записи.  
  
> [!NOTE]
>  Нельзя выполнять запись в удаленные счетчики производительности. Не существует перегрузки, которая позволяет указать экземпляр <xref:System.Diagnostics.PerformanceCounter> класса для чтения и записи, который подключается к удаленному компьютеру.  
  
 Чтобы создать экземпляр категории производительности, укажите `instanceName` в конструкторе <xref:System.Diagnostics.PerformanceCounter.%23ctor%2A>. Если экземпляр категории, заданный с помощью `instanceName`, уже существует, новый объект будет ссылаться на существующий экземпляр категории.  
  
> [!NOTE]
>  Для чтения счетчиков производительности в Windows Vista, Windows XP Professional x64 Edition или Windows Server 2003 необходимо быть членом группы "Пользователи системного монитора" или обладать правами администратора.  
>   
>  Чтобы не допустить повышения привилегий для доступа к счетчикам производительности в Windows Vista, добавьте себя в группу Пользователи системного монитора.  
>   
>  В Windows Vista привилегии пользователя определяются контролем учетных записей (UAC). Члену встроенной группы "Администраторы" присваивается два маркера доступа на время выполнения: маркер доступа обычного пользователя и маркер доступа администратора. По умолчанию назначена роль обычного пользователя. Чтобы выполнить код, обращающийся к счетчикам производительности, необходимо сначала повысить привилегии обычного пользователя до администратора. Это можно сделать при запуске приложения, , щелкнув значок приложения правой кнопкой мыши и указав, что приложение должно запускаться от имени администратора.  
  
> [!NOTE]
>  В Windows Vista, когда удаленный компьютер входит в рабочую группу, может потребоваться отключить контроль учетных записей, чтобы учетная запись локального пользователя не была отфильтрована и ее можно было повысить до учетной записи администратора. По соображениям безопасности Отключение UAC должно быть последним средством. Сведения об отключении UAC см. в разделе [Управление учетными записями пользователей и инструментарий WMI](https://go.microsoft.com/fwlink/?LinkId=91617).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Параметр <paramref name="categoryName" /> является пустой строкой ("").  
  
-или- 
 Параметр <paramref name="counterName" /> является пустой строкой ("").  
  
-или- 
Запрошенные параметры настройки разрешения на чтение/запись являются недопустимыми для этого счетчика.  
  
-или- 
Счетчика не существует на указанном компьютере.  
  
-или- 
Указанная категория отмечается как многоэкземплярная и требует создания счетчика производительности с именем экземпляра.  
  
-или- 
 Длина параметра <paramref name="instanceName" /> превышает 127 символов.  
  
-или- 
 Параметры <paramref name="categoryName" /> и <paramref name="counterName" /> были локализованы на разных языках.</exception>
        <exception cref="T:System.ArgumentException">Недопустимый параметр <paramref name="machineName" />.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="categoryName" /> или <paramref name="counterName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Произошла ошибка при обращении к API-интерфейсу системы.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Код, выполняющийся без привилегий администратора, предпринял попытку считывания значения счетчика производительности.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">для записи категории счетчика производительности, если свойство <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> имеет значение <see langword="false" />. Связанное перечисление: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="performanceCounter.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Начинает инициализацию экземпляра <see cref="T:System.Diagnostics.PerformanceCounter" />, используемого в форме или другим компонентом. Инициализация происходит во время выполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Среда разработки [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] использует этот метод для запуска инициализации компонента, используемого в форме или другим компонентом. Метод <xref:System.Diagnostics.PerformanceCounter.EndInit%2A> завершает инициализацию. Использование методов <xref:System.Diagnostics.PerformanceCounter.BeginInit%2A> и <xref:System.Diagnostics.PerformanceCounter.EndInit%2A> предотвращает использование компонента до полной инициализации.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CategoryName">
      <MemberSignature Language="C#" Value="public string CategoryName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CategoryName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.CategoryName" />
      <MemberSignature Language="VB.NET" Value="Public Property CategoryName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CategoryName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CategoryName : string with get, set" Usage="System.Diagnostics.PerformanceCounter.CategoryName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.CategoryValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.CategoryValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.CategoryValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает имя категории счетчика производительности для этого счетчика производительности.</summary>
        <value>Имя категории счетчика производительности (объект производительности), которому соответствует этот счетчик производительности.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A> отображается в поле `Performance Object` оснастки MMC диспетчера счетчиков производительности в `Add Counter` диалоговом окне.  
  
 Счетчик производительности отслеживает поведение категории или объекта производительности на компьютере. Категории включают физические компоненты (например, процессоры, диски и память) и системные объекты (например, процессы и потоки). Системные счетчики, связанные с одним и тем же объектом производительности, группируются в категорию, которая указывает на их общий фокус. При создании экземпляра класса <xref:System.Diagnostics.PerformanceCounter> сначала указывается Категория, с которой будет взаимодействовать компонент, а затем выбирается счетчик из этой категории.  
  
 Например, одна категория счетчиков Windows — это категория памяти. Системные счетчики в этой категории следят за данными памяти, например количеством доступных байтов и числом кэшированных байтов. Если вы хотите работать с кэшированными байтами в приложении, создайте экземпляр компонента <xref:System.Diagnostics.PerformanceCounter>, подключите его к категории памяти, а затем выберите соответствующий счетчик (в данном случае кэшированные байты) из этой категории.  
  
 Несмотря на то что в системе доступно гораздо больше категорий счетчиков, категории, которые, вероятно, взаимодействуют с наиболее часто, — это категории кэш, память, объекты, физический диск, процесс, процессор, сервер, система и поток.  
  
   
  
## Examples  
 В следующем примере кода создается экземпляр класса <xref:System.Diagnostics.PerformanceCounter> по умолчанию. После создания экземпляра задаются значения свойств <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>и <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>, а также отображаются результаты вызова метода <xref:System.Diagnostics.PerformanceCounter.NextValue%2A>.  
  
 [!code-cpp[PerfCounter#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerfCounter/CPP/perfcounter.cpp#1)]
 [!code-csharp[PerfCounter#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerfCounter/CS/perfcounter.cs#1)]
 [!code-vb[PerfCounter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerfCounter/VB/perfcounter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <see cref="P:System.Diagnostics.PerformanceCounter.CategoryName" /> — <see langword="null" />.</exception>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="performanceCounter.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Закрывает счетчик производительности и высвобождает все ресурсы, распределенные под этот экземпляр счетчика производительности.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При связывании этого экземпляра <xref:System.Diagnostics.PerformanceCounter> с счетчиком производительности, который находится на сервере, система инициализирует экземпляр и выделяет память для хранения образца данных счетчика. Метод <xref:System.Diagnostics.PerformanceCounter.Close%2A> освобождает ресурсы, выделенные объектом.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseSharedResources">
      <MemberSignature Language="C#" Value="public static void CloseSharedResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CloseSharedResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.CloseSharedResources" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CloseSharedResources ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CloseSharedResources();" />
      <MemberSignature Language="F#" Value="static member CloseSharedResources : unit -&gt; unit" Usage="System.Diagnostics.PerformanceCounter.CloseSharedResources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Высвобождает разделенное состояние библиотеки счетчика производительности, распределенное под счетчики.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">для чтения категории счетчика производительности. Связанное перечисление: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CounterHelp">
      <MemberSignature Language="C#" Value="public string CounterHelp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CounterHelp" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.CounterHelp" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CounterHelp As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CounterHelp { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CounterHelp : string" Usage="System.Diagnostics.PerformanceCounter.CounterHelp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("A description describing the counter.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("PC_CounterHelp")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает описание для этого счетчика производительности.</summary>
        <value>Описание элемента или количества, которое измеряет этот счетчик производительности.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Диалоговое окно Добавление счетчиков оснастки MMC "Диспетчер счетчиков производительности" отображает <xref:System.Diagnostics.PerformanceCounter.CounterHelp%2A> текст, когда пользователь выбирает счетчик из списка счетчиков и нажимает кнопку объяснить.  
  
 При создании нового счетчика используйте <xref:System.Diagnostics.PerformanceCounter.CounterHelp%2A> текст, чтобы описать, что делает монитор счетчиков, чтобы пользователь мог определить, следует ли добавить счетчик в дисплей системного монитора.  
  
> [!NOTE]
>  Если значение свойства <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> и Категория счетчика производительности была создана с помощью .NET Framework версии 1,0 или 1,1, создается <xref:System.InvalidOperationException>. Категории счетчиков производительности, созданные в более ранних версиях, используют глобальную общую память, а значение для <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> должно быть <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>. Если категория не используется приложениями, работающими в версиях 1,0 или 1,1 .NET Framework, удалите категорию и создайте ее заново.  
  
> [!NOTE]
>  Для чтения счетчиков производительности в Windows Vista, Windows XP Professional x64 Edition или Windows Server 2003 необходимо быть членом группы "Пользователи системного монитора" или обладать правами администратора.  
>   
>  Чтобы не допустить повышения привилегий для доступа к счетчикам производительности в Windows Vista, добавьте себя в группу Пользователи системного монитора.  
>   
>  В Windows Vista привилегии пользователя определяются контролем учетных записей (UAC). Члену встроенной группы "Администраторы" присваивается два маркера доступа на время выполнения: маркер доступа обычного пользователя и маркер доступа администратора. По умолчанию назначена роль обычного пользователя. Чтобы выполнить код, обращающийся к счетчикам производительности, необходимо сначала повысить привилегии обычного пользователя до администратора. Это можно сделать при запуске приложения, , щелкнув значок приложения правой кнопкой мыши и указав, что приложение должно запускаться от имени администратора.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Экземпляр класса <see cref="T:System.Diagnostics.PerformanceCounter" /> не связан со счетчиком производительности.  
  
-или- 
При использовании глобальной общей памяти свойству <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> присваивается значение <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Код, выполняющийся без привилегий администратора, предпринял попытку считывания значения счетчика производительности.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">для чтения категории счетчика производительности. Связанное перечисление: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CounterName">
      <MemberSignature Language="C#" Value="public string CounterName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CounterName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.CounterName" />
      <MemberSignature Language="VB.NET" Value="Public Property CounterName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CounterName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CounterName : string with get, set" Usage="System.Diagnostics.PerformanceCounter.CounterName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.CounterNameConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.CounterNameConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.CounterNameConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает имя категории счетчика производительности, связанного с данным экземпляром <see cref="T:System.Diagnostics.PerformanceCounter" />.</summary>
        <value>Имя счетчика, который описывает подсчитываемое количество. Имя, отображаемое в списке счетчиков закладки диспетчера счетчиков производительности MMC в диалоговом окне "Добавить счетчики".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Список доступных ранее счетчиков можно получить в [диалоговом окне Add Counters (Добавление счетчиков](https://go.microsoft.com/fwlink/p/?LinkId=257854)) диспетчера производительности Windows.  
  
   
  
## Examples  
 В следующем примере кода показано, как задать для свойства <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> обычное имя счетчика.  
  
 [!code-cpp[PerfCounter#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerfCounter/CPP/perfcounter.cpp#1)]
 [!code-csharp[PerfCounter#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerfCounter/CS/perfcounter.cs#1)]
 [!code-vb[PerfCounter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerfCounter/VB/perfcounter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <see cref="P:System.Diagnostics.PerformanceCounter.CounterName" /> — <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CounterType">
      <MemberSignature Language="C#" Value="public System.Diagnostics.PerformanceCounterType CounterType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.PerformanceCounterType CounterType" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.CounterType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CounterType As PerformanceCounterType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::PerformanceCounterType CounterType { System::Diagnostics::PerformanceCounterType get(); };" />
      <MemberSignature Language="F#" Value="member this.CounterType : System.Diagnostics.PerformanceCounterType" Usage="System.Diagnostics.PerformanceCounter.CounterType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The type of the counter.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("PC_CounterType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.PerformanceCounterType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает тип счетчика, с которым связан счетчик производительности.</summary>
        <value>Значение <see cref="T:System.Diagnostics.PerformanceCounterType" />, которое описывает, каким образом счетчик взаимодействует с отслеживающим приложением, и характер значений, которые он содержит (например, подсчитано или не подсчитано).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Перечисление <xref:System.Diagnostics.PerformanceCounterType> содержит типы счетчиков производительности, с которыми можно взаимодействовать. Некоторые типы счетчиков представляют вычисляемые значения, такие как среднее значение измерений счетчика, занимаемое системой. Другие типы представляют необработанные или невычисленные значения. В следующей таблице приведены типы счетчиков, с которыми вы будете взаимодействовать чаще всего.  
  
|Ответственность за счетчик|Значение Перформанцекаунтертипе|Пример|  
|------------------------------|----------------------------------|-------------|  
|Вести простой счетчик элементов или операций.|`NumberOfItems32`|Отслеживание количества заказов, полученных в виде 32-разрядного целого числа.|  
|Поддержка простого счетчика с более высокой емкостью.|`NumberOfItems64`|Отслеживание количества заказов для сайта с очень большим объемом, хранящегося в виде 64-разрядного целого числа.|  
|Следите за количеством элементов или операций в секунду.|`RateOfCountsPerSecond32`|Количество отслеживаемых заказов в секунду на сайте.|  
|Отслеживание количества элементов или операций в секунду с более высокой емкостью.|`RateOfCountsPerSecond64`|Количество отслеживаемых заказов в секунду на сайте с очень большим объемом.|  
|Вычисление среднего времени для выполнения процесса или обработки элемента|`AverageTimer32`|Вычислите среднее время обработки заказа.|  
  
 При создании счетчика, тип которого требует использования соответствующего базового счетчика, необходимо объявить счетчик и базу в <xref:System.Diagnostics.CounterCreationDataCollection>, передаваемых в метод <xref:System.Diagnostics.PerformanceCounterCategory.Create%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Если значение свойства <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> и Категория счетчика производительности была создана с помощью .NET Framework версии 1,0 или 1,1, создается <xref:System.InvalidOperationException>. Категории счетчиков производительности, созданные в более ранних версиях, используют глобальную общую память, а значение для <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> должно быть <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>. Если категория не используется приложениями, работающими в версиях 1,0 или 1,1 .NET Framework, удалите категорию и создайте ее заново.  
  
> [!NOTE]
>  Для чтения счетчиков производительности в Windows Vista, Windows XP Professional x64 Edition или Windows Server 2003 необходимо быть членом группы "Пользователи системного монитора" или обладать правами администратора.  
>   
>  Чтобы не допустить повышения привилегий для доступа к счетчикам производительности в Windows Vista, добавьте себя в группу Пользователи системного монитора.  
>   
>  В Windows Vista привилегии пользователя определяются контролем учетных записей (UAC). Члену встроенной группы "Администраторы" присваивается два маркера доступа на время выполнения: маркер доступа обычного пользователя и маркер доступа администратора. По умолчанию назначена роль обычного пользователя. Чтобы выполнить код, обращающийся к счетчикам производительности, необходимо сначала повысить привилегии обычного пользователя до администратора. Это можно сделать при запуске приложения, , щелкнув значок приложения правой кнопкой мыши и указав, что приложение должно запускаться от имени администратора.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Экземпляр класса, неправильно связанный со счетчиком производительности.  
  
-или- 
При использовании глобальной общей памяти свойству <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> присваивается значение <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Код, выполняющийся без привилегий администратора, предпринял попытку считывания значения счетчика производительности.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">для чтения категории счетчика производительности. Связанное перечисление: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
        <altmember cref="T:System.Diagnostics.PerformanceCounterType" />
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public long Decrement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Decrement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.Decrement" />
      <MemberSignature Language="VB.NET" Value="Public Function Decrement () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Decrement();" />
      <MemberSignature Language="F#" Value="member this.Decrement : unit -&gt; int64" Usage="performanceCounter.Decrement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Уменьшает значение связанного счетчика производительности на единицу через эффективные атомарные операции.</summary>
        <returns>Уменьшенное значение счетчика.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно записывать только в пользовательские счетчики. Все системные счетчики доступны только для чтения.  
  
> [!NOTE]
>  Методы <xref:System.Diagnostics.PerformanceCounter.Increment%2A>, <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>и <xref:System.Diagnostics.PerformanceCounter.Decrement%2A> используют взаимоблокировки для обновления значения счетчика. Это позволяет точно синхронизировать значение счетчика в многопоточных или многопроцессных сценариях, но также приводит к снижению производительности. Если точность, предоставляемая блокируемыми операциями, не нужна, можно обновить свойство <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> напрямую в 5 раз, чтобы улучшить производительность.  Однако в многопоточных сценариях некоторые обновления значения счетчика могут игнорироваться, что приводит к неточности данных.  
  
> [!NOTE]
>  Если значение свойства <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> и Категория счетчика производительности была создана с помощью .NET Framework версии 1,0 или 1,1, создается <xref:System.InvalidOperationException>. Категории счетчиков производительности, созданные в более ранних версиях, используют глобальную общую память, а значение для <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> должно быть <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>. Если категория не используется приложениями, работающими в версиях 1,0 или 1,1 .NET Framework, удалите категорию и создайте ее заново.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Счетчик доступен только для чтения, поэтому приложение не может уменьшить его значение.  
  
-или- 
Экземпляр класса, неправильно связанный со счетчиком производительности.  
  
-или- 
При использовании глобальной общей памяти свойству <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> присваивается значение <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Произошла ошибка при обращении к API-интерфейсу системы.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">для записи категории счетчика производительности, если свойство <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> имеет значение <see langword="false" />. Связанное перечисление: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
        <threadsafe>Этот метод является потокобезопасным.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="DefaultFileMappingSize">
      <MemberSignature Language="C#" Value="public static int DefaultFileMappingSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static int32 DefaultFileMappingSize" />
      <MemberSignature Language="DocId" Value="F:System.Diagnostics.PerformanceCounter.DefaultFileMappingSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared DefaultFileMappingSize As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: static int DefaultFileMappingSize;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultFileMappingSize : int" Usage="System.Diagnostics.PerformanceCounter.DefaultFileMappingSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.1">
          <AttributeName>System.Obsolete("This field has been deprecated and is not used.  Use machine.config or an application configuration file to set the size of the PerformanceCounter file mapping.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Он указывает размер глобальной памяти в байтах, используемой счетчиками производительности. Размер по умолчанию равен 524,288 байт.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="performanceCounter.Dispose disposing" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="performanceCounter.Dispose disposing" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="performanceCounter.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Завершает инициализацию экземпляра <see cref="T:System.Diagnostics.PerformanceCounter" />, используемого в форме или другим компонентом. Инициализация происходит во время выполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Среда разработки [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] использует этот метод для завершения инициализации компонента, используемого в форме или другим компонентом. Метод <xref:System.Diagnostics.PerformanceCounter.BeginInit%2A> запускает инициализацию. Использование методов <xref:System.Diagnostics.PerformanceCounter.BeginInit%2A> и <xref:System.Diagnostics.PerformanceCounter.EndInit%2A> предотвращает использование компонента до полной инициализации.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">для записи категории счетчика производительности, если свойство <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> имеет значение <see langword="false" />. Связанное перечисление: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public long Increment ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Increment() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.Increment" />
      <MemberSignature Language="VB.NET" Value="Public Function Increment () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Increment();" />
      <MemberSignature Language="F#" Value="member this.Increment : unit -&gt; int64" Usage="performanceCounter.Increment " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Увеличивает значение связанного счетчика производительности на единицу через эффективные атомарные операции.</summary>
        <returns>Увеличенное значение счетчика.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно записывать только в пользовательские счетчики. Все системные счетчики доступны только для чтения.  
  
> [!NOTE]
>  Методы <xref:System.Diagnostics.PerformanceCounter.Increment%2A>, <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>и <xref:System.Diagnostics.PerformanceCounter.Decrement%2A> используют взаимоблокировки для обновления значения счетчика. Это позволяет точно синхронизировать значение счетчика в многопоточных или многопроцессных сценариях, но также приводит к снижению производительности. Если точность, предоставляемая блокируемыми операциями, не нужна, можно обновить свойство <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> напрямую в 5 раз, чтобы улучшить производительность.  Однако в многопоточных сценариях некоторые обновления значения счетчика могут игнорироваться, что приводит к неточности данных.  
  
> [!NOTE]
>  Если значение свойства <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> и Категория счетчика производительности была создана с помощью .NET Framework версии 1,0 или 1,1, создается <xref:System.InvalidOperationException>. Категории счетчиков производительности, созданные в более ранних версиях, используют глобальную общую память, а значение для <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> должно быть <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>. Если категория не используется приложениями, работающими в версиях 1,0 или 1,1 .NET Framework, удалите категорию и создайте ее заново.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Счетчик доступен только для чтения, поэтому приложение не может увеличить его значение.  
  
-или- 
Экземпляр класса, неправильно связанный со счетчиком производительности.  
  
-или- 
При использовании глобальной общей памяти свойству <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> присваивается значение <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Произошла ошибка при обращении к API-интерфейсу системы.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">для записи категории счетчика производительности, если свойство <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> имеет значение <see langword="false" />. Связанное перечисление: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
        <threadsafe>Этот метод является потокобезопасным.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="IncrementBy">
      <MemberSignature Language="C#" Value="public long IncrementBy (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 IncrementBy(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.IncrementBy(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function IncrementBy (value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long IncrementBy(long value);" />
      <MemberSignature Language="F#" Value="member this.IncrementBy : int64 -&gt; int64" Usage="performanceCounter.IncrementBy value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Увеличиваемое значение. (Отрицательное значение уменьшает счетчик.)</param>
        <summary>Увеличивает или уменьшает значение связанного счетчика производительности на заданное значение посредством эффективных атомарных операций.</summary>
        <returns>Новое значение счетчика.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно записывать только в пользовательские счетчики. Все системные счетчики доступны только для чтения.  
  
> [!NOTE]
>  Методы <xref:System.Diagnostics.PerformanceCounter.Increment%2A>, <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>и <xref:System.Diagnostics.PerformanceCounter.Decrement%2A> используют взаимоблокировки для обновления значения счетчика. Это позволяет точно синхронизировать значение счетчика в многопоточных или многопроцессных сценариях, но также приводит к снижению производительности. Если точность, предоставляемая блокируемыми операциями, не нужна, можно обновить свойство <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> напрямую в 5 раз, чтобы улучшить производительность.  Однако в многопоточных сценариях некоторые обновления значения счетчика могут игнорироваться, что приводит к неточности данных.  
  
> [!NOTE]
>  Если значение свойства <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> и Категория счетчика производительности была создана с помощью .NET Framework версии 1,0 или 1,1, создается <xref:System.InvalidOperationException>. Категории счетчиков производительности, созданные в более ранних версиях, используют глобальную общую память, а значение для <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> должно быть <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>. Если категория не используется приложениями, работающими в версиях 1,0 или 1,1 .NET Framework, удалите категорию и создайте ее заново.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать метод <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A> для добавления приращений к счетчику. Этот пример кода является частью более крупного примера для класса <xref:System.Diagnostics.PerformanceCounter>.  
  
 [!code-cpp[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CPP/averagecount32.cpp#3)]
 [!code-csharp[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CS/averagecount32.cs#3)]
 [!code-vb[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/VB/averagecount32.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Счетчик доступен только для чтения, поэтому приложение не может увеличить его значение.  
  
-или- 
Экземпляр класса, неправильно связанный со счетчиком производительности.  
  
-или- 
При использовании глобальной общей памяти свойству <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> присваивается значение <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Произошла ошибка при обращении к API-интерфейсу системы.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">для записи категории счетчика производительности, если свойство <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> имеет значение <see langword="false" />. Связанное перечисление: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
        <threadsafe>Этот метод является потокобезопасным.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="InstanceLifetime">
      <MemberSignature Language="C#" Value="public System.Diagnostics.PerformanceCounterInstanceLifetime InstanceLifetime { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.PerformanceCounterInstanceLifetime InstanceLifetime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" />
      <MemberSignature Language="VB.NET" Value="Public Property InstanceLifetime As PerformanceCounterInstanceLifetime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::PerformanceCounterInstanceLifetime InstanceLifetime { System::Diagnostics::PerformanceCounterInstanceLifetime get(); void set(System::Diagnostics::PerformanceCounterInstanceLifetime value); };" />
      <MemberSignature Language="F#" Value="member this.InstanceLifetime : System.Diagnostics.PerformanceCounterInstanceLifetime with get, set" Usage="System.Diagnostics.PerformanceCounter.InstanceLifetime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.PerformanceCounterInstanceLifetime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает время существования процесса.</summary>
        <value>Одно из значений перечисления <see cref="T:System.Diagnostics.PerformanceCounterInstanceLifetime" />. Значение по умолчанию — <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Global" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если категория счетчика производительности создается с .NET Framework версии 1,0 или 1,1, она использует глобальную общую память, а значение для <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> должно быть <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>. Если категория не используется приложениями, работающими в версиях 1,0 или 1,1 .NET Framework, удалите категорию и создайте ее заново.  
  
> [!NOTE]
>  Если значение свойства <xref:System.Diagnostics.PerformanceCounter.CounterType%2A> равно <xref:System.Diagnostics.PerformanceCounterCategoryType.SingleInstance>, значение <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> для счетчика производительности должно быть <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Присвоенное значение не является членом перечисления <see cref="T:System.Diagnostics.PerformanceCounterInstanceLifetime" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> задается после инициализации <see cref="T:System.Diagnostics.PerformanceCounter" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="InstanceName">
      <MemberSignature Language="C#" Value="public string InstanceName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string InstanceName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.InstanceName" />
      <MemberSignature Language="VB.NET" Value="Public Property InstanceName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ InstanceName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InstanceName : string with get, set" Usage="System.Diagnostics.PerformanceCounter.InstanceName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.InstanceNameConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.InstanceNameConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.InstanceNameConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает имя экземпляра для этого счетчика производительности.</summary>
        <value>Имя экземпляра категории счетчика производительности или пустая строка (""), если счетчик является единственным экземпляром.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Длина имен экземпляров должна быть короче 128 символов.  
  
 В некоторых ситуациях категории делятся на экземпляры, которые отправляют данные о нескольких экземплярах объекта, к которому относится Категория. Экземпляры применяются к категории в целом, а не к отдельным счетчикам. Каждый счетчик в категории имеет каждый экземпляр, определенный для категории. Например, Категория процесса содержит экземпляры с именами Idle и System. Таким же, каждый счетчик в категории процесса содержит данные для каждого экземпляра, отображая сведения о процессах простоя или системных процессах.  
  
 Многие категории не содержат несколько экземпляров, поэтому можно оставить это свойство пустым, чтобы указать, что ни один экземпляр не связан с категорией.  
  
 Если этот <xref:System.Diagnostics.PerformanceCounter> экземпляр указывает на непользовательскую категорию, можно выбрать только существующие экземпляры категории. Новые экземпляры категорий можно создавать только в пользовательских категориях, которые позволяют определить столько счетчиков и экземпляров категорий, сколько необходимо.  
  
 Чтобы создать экземпляр категории производительности, укажите `instanceName` в конструкторе <xref:System.Diagnostics.PerformanceCounter.%23ctor%2A>. Если экземпляр категории, заданный с помощью `instanceName`, уже существует, новый объект будет ссылаться на существующий экземпляр категории.  
  
> [!NOTE]
>  Не используйте символы "(", ")", "#", "\\" или "/" в имени экземпляра. Если используется любой из этих символов, то консоль производительности (см. раздел [Профилирование среды выполнения](~/docs/framework/debug-trace-profile/runtime-profiling.md)) может неправильно отображать значения экземпляра.  
  
 Если имя экземпляра создается автоматически и может содержать символы "(", ")", "#", "\\" или "/", используйте сопоставление символов в следующей таблице.  
  
|Знак|Сопоставленный символ|  
|---------------|----------------------|  
|(|[|  
|)|]|  
|#|_|  
|\|_|  
|/|_|  
  
 Свойство <xref:System.AppDomain.FriendlyName%2A> объекта <xref:System.AppDomain>, полученное из свойства <xref:System.AppDomain.CurrentDomain%2A?displayProperty=nameWithType>, является общим источником имен экземпляров, которые могут содержать недопустимые символы.  
  
   
  
## Examples  
 В следующем примере кода создается экземпляр класса <xref:System.Diagnostics.PerformanceCounter> по умолчанию. После создания экземпляра задаются значения свойств <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>и <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>, а также отображаются результаты вызова метода <xref:System.Diagnostics.PerformanceCounter.NextValue%2A>.  
  
 [!code-cpp[PerfCounter#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerfCounter/CPP/perfcounter.cpp#1)]
 [!code-csharp[PerfCounter#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerfCounter/CS/perfcounter.cs#1)]
 [!code-vb[PerfCounter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerfCounter/VB/perfcounter.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string with get, set" Usage="System.Diagnostics.PerformanceCounter.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(".")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("What's the machine name format?")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает имя компьютера для этого счетчика производительности.</summary>
        <value>Сервер, на котором постоянно находятся счетчик производительности и связанная с ним категория.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значения можно записывать только в счетчики, которые находятся на локальном компьютере. Однако можно считывать значения счетчиков с любого компьютера предприятия, для которого у вас есть права доступа.  
  
 При установке свойства <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> для указания на удаленный компьютер экземпляр <xref:System.Diagnostics.PerformanceCounter> пытается открыть счетчик на этом компьютере. Если счетчик не существует, задание этого свойства вызывает исключение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Недопустимый формат <see cref="P:System.Diagnostics.PerformanceCounter.MachineName" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="NextSample">
      <MemberSignature Language="C#" Value="public System.Diagnostics.CounterSample NextSample ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Diagnostics.CounterSample NextSample() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.NextSample" />
      <MemberSignature Language="VB.NET" Value="Public Function NextSample () As CounterSample" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Diagnostics::CounterSample NextSample();" />
      <MemberSignature Language="F#" Value="member this.NextSample : unit -&gt; System.Diagnostics.CounterSample" Usage="performanceCounter.NextSample " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.CounterSample</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает образец счетчика и возвращает начальное или не рассчитанное значение для него.</summary>
        <returns>Тип <see cref="T:System.Diagnostics.CounterSample" />, представляющий следующее начальное значение, которое система получает для этого счетчика.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод обычно используется для счетчиков, содержащих невычисленные значения.  
  
> [!NOTE]
>  Если значение свойства <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> и Категория счетчика производительности была создана с помощью .NET Framework версии 1,0 или 1,1, создается <xref:System.InvalidOperationException>. Категории счетчиков производительности, созданные в более ранних версиях, используют глобальную общую память, а значение для <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> должно быть <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>. Если категория не используется приложениями, работающими в версиях 1,0 или 1,1 .NET Framework, удалите категорию и создайте ее заново.  
  
> [!NOTE]
>  Для чтения счетчиков производительности в Windows Vista, Windows XP Professional x64 Edition или Windows Server 2003 необходимо быть членом группы "Пользователи системного монитора" или обладать правами администратора.  
>   
>  Чтобы не допустить повышения привилегий для доступа к счетчикам производительности в Windows Vista, добавьте себя в группу Пользователи системного монитора.  
>   
>  В Windows Vista привилегии пользователя определяются контролем учетных записей (UAC). Члену встроенной группы "Администраторы" присваивается два маркера доступа на время выполнения: маркер доступа обычного пользователя и маркер доступа администратора. По умолчанию назначена роль обычного пользователя. Чтобы выполнить код, обращающийся к счетчикам производительности, необходимо сначала повысить привилегии обычного пользователя до администратора. Это можно сделать при запуске приложения, , щелкнув значок приложения правой кнопкой мыши и указав, что приложение должно запускаться от имени администратора.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать метод <xref:System.Diagnostics.PerformanceCounter.NextSample%2A> для получения следующего невычисленного значения счетчика. Этот пример кода является частью более крупного примера для класса <xref:System.Diagnostics.PerformanceCounter>.  
  
 [!code-cpp[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CPP/averagecount32.cpp#3)]
 [!code-csharp[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CS/averagecount32.cs#3)]
 [!code-vb[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/VB/averagecount32.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Экземпляр класса, неправильно связанный со счетчиком производительности.  
  
-или- 
При использовании глобальной общей памяти свойству <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> присваивается значение <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Произошла ошибка при обращении к API-интерфейсу системы.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Код, выполняющийся без привилегий администратора, предпринял попытку считывания значения счетчика производительности.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">для чтения категории счетчика производительности. Связанное перечисление: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="NextValue">
      <MemberSignature Language="C#" Value="public float NextValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float32 NextValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.NextValue" />
      <MemberSignature Language="VB.NET" Value="Public Function NextValue () As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; float NextValue();" />
      <MemberSignature Language="F#" Value="member this.NextValue : unit -&gt; single" Usage="performanceCounter.NextValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает образец счетчика и возвращает расчетное значение для него.</summary>
        <returns>Следующее расчетное значение, получаемое системой для этого счетчика.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Если вычисленное значение счетчика зависит от двух операций чтения счетчика, то первая операция считывания возвращает 0,0. Сброс свойств счетчика производительности для указания другого счетчика эквивалентен созданию нового счетчика производительности, а первая операция чтения с новыми свойствами возвращает 0,0. Рекомендуемое время задержки между вызовами метода <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> — одна секунда, позволяющая счетчику выполнить следующее добавочное чтение.  
  
> [!NOTE]
>  Для чтения счетчиков производительности необходимы права администратора. В Windows Vista привилегии пользователя определяются контролем учетных записей (UAC). Члену встроенной группы "Администраторы" присваивается два маркера доступа на время выполнения: маркер доступа обычного пользователя и маркер доступа администратора. По умолчанию назначена роль обычного пользователя. Чтобы выполнить код, обращающийся к счетчикам производительности, необходимо сначала повысить привилегии обычного пользователя до администратора. Это можно сделать при запуске приложения, , щелкнув значок приложения правой кнопкой мыши и указав, что приложение должно запускаться от имени администратора.  
  
   
  
## Examples  
 В следующем примере кода создается счетчик <xref:System.Diagnostics.PerformanceCounterType.ElapsedTime> и используется метод <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> для вывода значений счетчика за период времени.  
  
 [!code-cpp[PerformanceCounterType.ElapsedTime#2](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.ElapsedTime/CPP/elapsedtime.cpp#2)]
 [!code-csharp[PerformanceCounterType.ElapsedTime#2](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.ElapsedTime/CS/elapsedtime.cs#2)]
 [!code-vb[PerformanceCounterType.ElapsedTime#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.ElapsedTime/VB/elapsedtime.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Экземпляр класса, неправильно связанный со счетчиком производительности.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Произошла ошибка при обращении к API-интерфейсу системы.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Код, выполняющийся без привилегий администратора, предпринял попытку считывания значения счетчика производительности.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">для чтения категории счетчика производительности. Связанное перечисление: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="RawValue">
      <MemberSignature Language="C#" Value="public long RawValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 RawValue" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.RawValue" />
      <MemberSignature Language="VB.NET" Value="Public Property RawValue As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long RawValue { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.RawValue : int64 with get, set" Usage="System.Diagnostics.PerformanceCounter.RawValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The raw value of the counter.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("PC_RawValue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает начальное или не рассчитанное значение этого счетчика.</summary>
        <value>Необработанное значение счетчика.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если тип счетчика имеет размер 32 бит и вы пытаетесь задать для этого свойства слишком большое значение, свойство усекает значение до 32 бит. При чтении пользовательских счетчиков на локальном компьютере использование свойства <xref:System.Diagnostics.PerformanceCounter.RawValue%2A>, а не вычисляемого значения, может значительно повысить производительность в сценариях, где необработанное значение достаточно.  
  
 Если показания счетчика доступны только для чтения, то получение свойства <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> выбирает счетчик во время вызова свойства. Это действие эквивалентно выполнению начального вызова метода <xref:System.Diagnostics.PerformanceCounter.NextSample%2A>. При последующем вызове <xref:System.Diagnostics.PerformanceCounter.NextSample%2A>можно выполнять вычисления для значений, возвращаемых обоими вызовами.  
  
 Поскольку системные счетчики доступны только для чтения, можно получить, но не задавать их необработанные значения.  
  
> [!NOTE]
>  Методы <xref:System.Diagnostics.PerformanceCounter.Increment%2A>, <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>и <xref:System.Diagnostics.PerformanceCounter.Decrement%2A> используют взаимоблокировки для обновления значения счетчика. Это позволяет точно синхронизировать значение счетчика в многопоточных или многопроцессных сценариях, но также приводит к снижению производительности. Если точность, предоставляемая блокируемыми операциями, не нужна, можно обновить свойство <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> напрямую в 5 раз, чтобы улучшить производительность.  Однако в многопоточных сценариях некоторые обновления значения счетчика могут игнорироваться, что приводит к неточности данных.  
  
> [!NOTE]
>  Если значение свойства <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> и Категория счетчика производительности была создана с помощью .NET Framework версии 1,0 или 1,1, создается <xref:System.InvalidOperationException>. Категории счетчиков производительности, созданные в более ранних версиях, используют глобальную общую память, а значение для <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> должно быть <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>. Если категория не используется приложениями, работающими в версиях 1,0 или 1,1 .NET Framework, удалите категорию и создайте ее заново.  
  
> [!NOTE]
>  Для чтения счетчиков производительности в Windows Vista, Windows XP Professional x64 Edition или Windows Server 2003 необходимо быть членом группы "Пользователи системного монитора" или обладать правами администратора.  
>   
>  Чтобы не допустить повышения привилегий для доступа к счетчикам производительности в Windows Vista, добавьте себя в группу Пользователи системного монитора.  
>   
>  В Windows Vista привилегии пользователя определяются контролем учетных записей (UAC). Члену встроенной группы "Администраторы" присваивается два маркера доступа на время выполнения: маркер доступа обычного пользователя и маркер доступа администратора. По умолчанию назначена роль обычного пользователя. Чтобы выполнить код, обращающийся к счетчикам производительности, необходимо сначала повысить привилегии обычного пользователя до администратора. Это можно сделать при запуске приложения, , щелкнув значок приложения правой кнопкой мыши и указав, что приложение должно запускаться от имени администратора.  
  
   
  
## Examples  
 В следующем примере класс <xref:System.Diagnostics.CounterSample> используется для вывода значения свойства <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> для счетчика.  
  
 [!code-cpp[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CPP/averagecount32.cpp#1)]
 [!code-csharp[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CS/averagecount32.cs#1)]
 [!code-vb[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/VB/averagecount32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Попытка установить начальное значение счетчика, но счетчик доступен только для чтения.  
  
-или- 
Экземпляр класса, неправильно связанный со счетчиком производительности.  
  
-или- 
При использовании глобальной общей памяти свойству <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> присваивается значение <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Произошла ошибка при обращении к API-интерфейсу системы.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Код, выполняющийся без привилегий администратора, предпринял попытку считывания значения счетчика производительности.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">для записи категории счетчика производительности. Связанное перечисление: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public bool ReadOnly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.ReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReadOnly { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ReadOnly : bool with get, set" Usage="System.Diagnostics.PerformanceCounter.ReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The accessability level of the counter.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("PC_ReadOnly")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, определяющее, доступен ли экземпляр <see cref="T:System.Diagnostics.PerformanceCounter" /> только для чтения.</summary>
        <value>Значение <see langword="true" />, если экземпляр <see cref="T:System.Diagnostics.PerformanceCounter" /> доступен только для чтения (даже если сам счетчик является определенным счетчиком .NET Framework); значение <see langword="false" />, если счетчик работает в режиме чтения/записи. Значение по умолчанию — значение, заданное конструктором.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для системного счетчика <xref:System.Diagnostics.PerformanceCounter.ReadOnly%2A> всегда должна `true`. Запись в системный счетчик невозможна.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveInstance">
      <MemberSignature Language="C#" Value="public void RemoveInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.RemoveInstance" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveInstance ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveInstance();" />
      <MemberSignature Language="F#" Value="member this.RemoveInstance : unit -&gt; unit" Usage="performanceCounter.RemoveInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет экземпляр категории, указанной объектом <see cref="T:System.Diagnostics.PerformanceCounter" /> свойства <see cref="P:System.Diagnostics.PerformanceCounter.InstanceName" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Экземпляр можно удалить только для настраиваемого счетчика. Все системные счетчики доступны только для чтения, поэтому попытка удалить один из них вызовет исключение.  
  
> [!NOTE]
>  Чтобы избежать возможного состояния гонки при освобождении общей памяти счетчика производительности, рекомендуется вызывать метод <xref:System.Diagnostics.PerformanceCounter.RemoveInstance%2A> из обработчика событий <xref:System.AppDomain.DomainUnload>.  
  
 Чтобы создать экземпляр категории производительности, укажите `instanceName` в конструкторе <xref:System.Diagnostics.PerformanceCounter.%23ctor%2A>. Если экземпляр категории, заданный с помощью `instanceName`, уже существует, новый объект будет ссылаться на существующий экземпляр категории.  
  
> [!NOTE]
>  Если значение свойства <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> и Категория счетчика производительности была создана с помощью .NET Framework версии 1,0 или 1,1, создается <xref:System.InvalidOperationException>. Категории счетчиков производительности, созданные в более ранних версиях, используют глобальную общую память, а значение для <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> должно быть <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>. Если категория не используется приложениями, работающими в версиях 1,0 или 1,1 .NET Framework, удалите категорию и создайте ее заново.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Счетчик доступен только для чтения, поэтому любой экземпляр, связанный с данной категорией, не может быть удален.  
  
-или- 
Экземпляр класса, неправильно связанный со счетчиком производительности.  
  
-или- 
При использовании глобальной общей памяти свойству <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> присваивается значение <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Произошла ошибка при обращении к API-интерфейсу системы.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">для записи категории счетчика производительности. Связанное перечисление: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
      </Docs>
    </Member>
  </Members>
</Type>
