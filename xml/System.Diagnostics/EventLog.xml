<Type Name="EventLog" FullName="System.Diagnostics.EventLog">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0ff824b2a8e88519f623df8888db8a53b11a77e2" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70509905" /></Metadata><TypeSignature Language="C#" Value="public class EventLog : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventLog extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.EventLog" />
  <TypeSignature Language="VB.NET" Value="Public Class EventLog&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventLog : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type EventLog = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
      <AttributeName>System.ComponentModel.DefaultEvent("EntryWritten")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Diagnostics.EventLogInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.Diagnostics.MonitoringDescription("Represents an event log")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.EventLogInstallableComponentDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.MonitoringDescription("EventLogDesc")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Обеспечивает взаимодействие с журналами событий Windows.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog>позволяет осуществлять доступ или настраивать журналы событий Windows, которые записывают сведения о важных событиях программного обеспечения или оборудования. С <xref:System.Diagnostics.EventLog>помощью можно выполнять чтение из существующих журналов, записывать записи в журналы, создавать или удалять источники событий, удалять журналы и отвечать на записи журнала. При создании источника событий можно также создать новые журналы.  
  
> [!IMPORTANT]
>  Этот тип реализует интерфейс <xref:System.IDisposable>. По окончании использования выдаленную ему память следует прямо или косвенно освободить. Чтобы сделать это прямо, вызовите его метод <xref:System.IDisposable.Dispose%2A> в блоке `try`/`catch`. Чтобы сделать это косвенно, используйте языковые конструкции, такие как `using` (в C#) или `Using` (в Visual Basic). Дополнительные сведения см. в разделе "Использование объекта, реализующего IDisposable" в статье об интерфейсе <xref:System.IDisposable>.  
  
 Кроме предоставления доступа к отдельным журналам событий и их записям, <xref:System.Diagnostics.EventLog> класс позволяет получить доступ к коллекции всех журналов событий. `static` Члены класса <xref:System.Diagnostics.EventLog>  можно использовать для удаления журналов, получения списков журналов, создания или удаления источника, а также для определения того, содержит ли компьютер определенный источник.  
  
 Существует три журнала событий по умолчанию: приложение, система и безопасность. Журнал безопасности доступен только для чтения. Другие приложения и службы, которые вы устанавливаете, например Active Directory, могут иметь дополнительные журналы событий.  
  
 При использовании <xref:System.Diagnostics.EventLog> класса необходимо учитывать вопросы безопасности. <xref:System.Diagnostics.EventLog>требуются <xref:System.Diagnostics.EventLogPermission> разрешения для определенных действий в .NET Framework 2,0 и более поздних версий или полное доверие в .NET Framework 1,0 и 1,1. <xref:System.Diagnostics.EventLogPermission> Не рекомендуется предоставлять частично доверенному коду.  Никогда не следует передавать объекты журнала событий, включая <xref:System.Diagnostics.EventLogEntryCollection> и <xref:System.Diagnostics.EventLogEntry> , в менее надежный код. Например, создание <xref:System.Diagnostics.EventLog> объекта, запись записи, а затем <xref:System.Diagnostics.EventLog> передача объекта в код с частичным доверием могут создать проблемы безопасности, поскольку возможность чтения и записи в журнал событий позволяет коду выполнять такие действия, как выдача сообщения журнала событий в имени другого приложения.  
  
 Начиная с Windows Vista, Управление учетными записями пользователей (UAC) определяет учетные данные пользователя. Члену встроенной группы "Администраторы" присваивается два маркера доступа на время выполнения: маркер доступа обычного пользователя и маркер доступа администратора. По умолчанию назначена роль обычного пользователя. Чтобы выполнить код, обращающийся к журналу безопасности, необходимо сначала повысить свои учетные данные от обычного пользователя до администратора. Это можно сделать при запуске приложения, открыв контекстное меню для приложения (если вы используете мышь, щелкните правой кнопкой мыши значок приложения) и укажите, что требуется запустить от имени администратора.  
  
 Можно использовать <xref:System.Diagnostics.EventLog> для создания пользовательских журналов событий, которые можно просмотреть с помощью Просмотр событий сервера. <xref:System.Diagnostics.EventLog.RegisterDisplayName%2A> Используйте метод, чтобы отобразить локализованное имя для журнала событий в Просмотр событий. <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> Используйте метод, чтобы настроить поведение журнала событий при достижении максимального размера журнала.  
  
 Для чтения из журнала событий укажите имя журнала (<xref:System.Diagnostics.EventLog.Log%2A> свойство) и имя компьютера сервера (<xref:System.Diagnostics.EventLog.MachineName%2A> свойство для журнала событий. Если не указать имя компьютера сервера, предполагается, что используется локальный компьютер ".". Нет необходимости указывать источник события (<xref:System.Diagnostics.EventLog.Source%2A> свойство), поскольку источник необходим только для записи в журналы. <xref:System.Diagnostics.EventLog.Entries%2A> Свойство автоматически заполняется списком записей журнала событий.  
  
 Для записи в журнал событий укажите или создайте источник события (<xref:System.Diagnostics.EventLog.Source%2A> свойство). Для создания нового источника событий необходимо иметь учетные данные администратора на компьютере. Источник событий регистрирует приложение в журнале событий в качестве допустимого источника записей. Можно использовать источник событий для записи только в один журнал за раз. <xref:System.Diagnostics.EventLog.Source%2A> Свойство может быть любой случайной строкой, но имя должно отличаться от других источников на компьютере. Источником события обычно является имя приложения или другая идентифицирующая строка. При попытке создать повторяющееся <xref:System.Diagnostics.EventLog.Source%2A> значение возникает исключение. Однако один журнал событий может быть связан с несколькими источниками.  
  
 Если источник событий для журнала событий, связанного с <xref:System.Diagnostics.EventLog> экземпляром, не существует, создается новый источник событий. Чтобы создать источник событий в Windows Vista и более поздних версиях или Windows Server 2003, необходимо иметь учетные данные администратора.  
  
 Это требование связано с тем, что необходимо выполнить поиск всех журналов событий, включая журналы безопасности, чтобы определить, является ли источник события уникальным. Начиная с Windows Vista, пользователи не имеют разрешения на доступ к журналу безопасности; <xref:System.Security.SecurityException> поэтому создается исключение.  
  
> [!IMPORTANT]
>  Для создания или удаления источника события требуется синхронизация базового кода с помощью именованного мьютекса. Если приложение с высоким уровнем привилегий блокирует именованный мьютекс, попытка создать или удалить источник события приведет к тому, что приложение перестанет отвечать, пока блокировка не будет снята. Чтобы предотвратить возникновение этой проблемы, никогда <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> не предоставляйте разрешение на ненадежный код. Кроме того, <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> разрешение, потенциально разрешающее обход других разрешений, может быть предоставлено только высоко доверенному коду.  
  
 Приложения и службы должны выполнять запись в журнал приложений или в пользовательский журнал. Драйверы устройств должны записывать в системный журнал. Если <xref:System.Diagnostics.EventLog.Log%2A> свойство не задано явным образом, по умолчанию в журнале событий используется журнал приложений.  
  
> [!NOTE]
>  Нет ничего защищать приложение от записи в качестве зарегистрированного источника.  Если приложению предоставлено <xref:System.Diagnostics.EventLogPermissionAccess.Write> разрешение, оно может записывать события для любого допустимого источника, зарегистрированного на компьютере.  
  
 Используйте методы <xref:System.Diagnostics.EventLog.WriteEntry%2A> и для записи событий в журнал событий. <xref:System.Diagnostics.EventLog.WriteEvent%2A> Для записи событий необходимо указать источник события. перед записью первой записи с источником необходимо создать и настроить источник события.  
  
 Создайте новый источник событий во время установки приложения. Это позволяет операционной системе обновлять свой список зарегистрированных источников событий и их конфигурацию. Если операционная система не обновила список источников событий и вы пытаетесь написать событие с новым источником, операция записи завершится ошибкой. Новый источник можно настроить с помощью <xref:System.Diagnostics.EventLogInstaller> объекта <xref:System.Diagnostics.EventLog.CreateEventSource%2A> или метода. Для создания нового источника событий необходимо иметь учетные данные администратора на компьютере.  
  
 Каждый источник может записывать только один журнал событий; Однако приложение может использовать несколько источников для записи в несколько журналов событий. Например, приложению может потребоваться несколько источников, настроенных для различных журналов событий или разных файлов ресурсов. Чтобы изменить сведения о конфигурации существующего источника, необходимо удалить источник, а затем создать его с новой конфигурацией. Если другие приложения или компоненты используют существующий источник, создайте новый источник с обновленной конфигурацией вместо удаления существующего источника.  
  
 Вы можете зарегистрировать источник событий в локализованных ресурсах для категории событий и строк сообщений. Приложение может записывать записи журнала событий с помощью идентификаторов ресурсов вместо указания фактических строковых значений. Дополнительные сведения о настройке <xref:System.Diagnostics.EventSourceCreationData> источника с помощью файлов ресурсов см. в разделе Классы и. <xref:System.Diagnostics.EventLogInstaller>  
  
 Если приложение записывает строковые значения непосредственно в журнал событий, не нужно задавать свойства файла ресурсов для источника. Источник должен быть настроен либо для записи локализованных записей, либо для записи прямых строк. Если приложение записывает записи, используя как идентификаторы ресурсов, так и строковые значения, необходимо зарегистрировать два отдельных источника. Например, можно настроить один источник с файлами ресурсов, а затем использовать этот источник в <xref:System.Diagnostics.EventLog.WriteEvent%2A> методе для записи записей, использующих идентификаторы ресурсов, в журнал событий. Затем создайте другой источник без файлов ресурсов и используйте этот источник в <xref:System.Diagnostics.EventLog.WriteEntry%2A> методе для записи строк непосредственно в журнал событий с помощью этого источника.  
  
 При записи событий необходимо по крайней мере указать либо строку сообщения, либо идентификатор ресурса для строки сообщения. Другие свойства событий являются необязательными. Примеры необязательных параметров событий включают следующее.  
  
-   Можно задать <xref:System.Diagnostics.EventLogEntryType> , чтобы указать значок, отображаемый Просмотр событий для записи.  
  
-   Можно указать идентификатор категории для события, если приложение использует категории для фильтрации событий.  
  
-   Если требуется связать дополнительные сведения с заданным событием, можно присоединить двоичные данные к записи события.  
  
> [!IMPORTANT]
>  Ведение журнала событий потребляет место на диске, процессорное время и другие системные ресурсы. Важно регистрировать только важную информацию. Рекомендуется размещать вызовы журнала событий в пути ошибки, а не в основном коде кода, чтобы они не влияли на производительность.  
  
 Список начальных значений свойств для экземпляра <xref:System.Diagnostics.EventLog>см. в <xref:System.Diagnostics.EventLog.%23ctor%2A> разделе Конструктор.  
  
   
  
## Examples  
 В следующем примере создается источник `MySource` события, если он еще не существует, и записывается запись в журнал `MyNewLog`событий.  
  
> [!NOTE]
>  Начиная с Windows Vista, это приложение необходимо запускать от имени администратора.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Diagnostics.EventLogInstaller" />
    <altmember cref="T:System.Diagnostics.EventLogEntry" />
    <altmember cref="T:System.Diagnostics.EntryWrittenEventArgs" />
    <altmember cref="T:System.ServiceProcess.ServiceBase" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Diagnostics.EventLog" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Diagnostics.EventLog" />. Не связывает экземпляр с каким-либо журналом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Перед вызовом метода <xref:System.Diagnostics.EventLog.WriteEntry%2A> <xref:System.Diagnostics.EventLog.Source%2A> укажите свойство <xref:System.Diagnostics.EventLog> экземпляра. Если выполняется только чтение <xref:System.Diagnostics.EventLog.Entries%2A> из журнала, можно также указать <xref:System.Diagnostics.EventLog.Log%2A> только свойства и <xref:System.Diagnostics.EventLog.MachineName%2A> .  
  
> [!NOTE]
>  Если не указан <xref:System.Diagnostics.EventLog.MachineName%2A>, предполагается локальный компьютер (".").  
  
 В следующей таблице показаны начальные значения свойств для экземпляра <xref:System.Diagnostics.EventLog>.  
  
|Свойство.|Начальное значение|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Пустая строка ("").|  
|<xref:System.Diagnostics.EventLog.Log%2A>|Пустая строка ("").|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|Локальный компьютер (".").|  
  
   
  
## Examples  
 В следующем примере создается источник `MySource` , если он еще не существует, и записывается запись в журнал `MyNewLog`событий.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog logName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Имя журнала на локальном компьютере.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Diagnostics.EventLog" />. Связывает экземпляр с журналом на локальном компьютере.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка задает <xref:System.Diagnostics.EventLog.Log%2A> `logName` для свойства параметр. Перед вызовом метода <xref:System.Diagnostics.EventLog.WriteEntry%2A> <xref:System.Diagnostics.EventLog.Source%2A> укажите свойство <xref:System.Diagnostics.EventLog> экземпляра. Если выполняется только чтение <xref:System.Diagnostics.EventLog.Entries%2A> из журнала, можно также указать <xref:System.Diagnostics.EventLog.Log%2A> только свойства и <xref:System.Diagnostics.EventLog.MachineName%2A> .  
  
> [!NOTE]
>  Если не указан <xref:System.Diagnostics.EventLog.MachineName%2A>, предполагается локальный компьютер ("."). Эта перегрузка конструктора задает <xref:System.Diagnostics.EventLog.Log%2A> свойство, но его можно изменить перед <xref:System.Diagnostics.EventLog.Entries%2A> чтением свойства.  
  
 Если источник, указанный в <xref:System.Diagnostics.EventLog.Source%2A> свойстве, уникален из других источников на компьютере, то при последующем <xref:System.Diagnostics.EventLog.WriteEntry%2A> вызове метода создается журнал с указанным именем, если он еще не существует.  
  
 В следующей таблице показаны начальные значения свойств для экземпляра <xref:System.Diagnostics.EventLog>.  
  
|Свойство.|Начальное значение|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Пустая строка ("").|  
|<xref:System.Diagnostics.EventLog.Log%2A>|Параметр `logName`.|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|Локальный компьютер (".").|  
  
   
  
## Examples  
 Следующий пример считывает записи в журнале событий myNewLog на локальном компьютере.  
  
 [!code-cpp[Classic EventLog.EventLog1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Имя журнала <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Недопустимое имя журнала.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string * string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog (logName, machineName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Имя журнала на указанном компьютере.</param>
        <param name="machineName">Компьютер, на котором существует журнал.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Diagnostics.EventLog" />. Связывает экземпляр с журналом на указанном компьютере.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка присваивает <xref:System.Diagnostics.EventLog.Log%2A> свойству `logName` значение параметра, `machineName` а <xref:System.Diagnostics.EventLog.MachineName%2A> свойству — параметру. Перед вызовом метода <xref:System.Diagnostics.EventLog.WriteEntry%2A> <xref:System.Diagnostics.EventLog.Source%2A> укажите свойство объекта <xref:System.Diagnostics.EventLog>. Если выполняется только чтение <xref:System.Diagnostics.EventLog.Entries%2A> из журнала, можно также указать <xref:System.Diagnostics.EventLog.Log%2A> только свойства и <xref:System.Diagnostics.EventLog.MachineName%2A> .  
  
> [!NOTE]
>  Эта перегрузка конструктора задает <xref:System.Diagnostics.EventLog.Log%2A> свойства и <xref:System.Diagnostics.EventLog.MachineName%2A> , но вы можете <xref:System.Diagnostics.EventLog.Entries%2A> изменить их перед чтением свойства.  
  
 В следующей таблице показаны начальные значения свойств для экземпляра <xref:System.Diagnostics.EventLog>.  
  
|Свойство.|Начальное значение|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Пустая строка ("").|  
|<xref:System.Diagnostics.EventLog.Log%2A>|Параметр `logName`.|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|Параметр `machineName`.|  
  
   
  
## Examples  
 Следующий пример считывает записи в журнале событий myNewLog на компьютере myServer.  
  
 [!code-cpp[Classic EventLog.EventLog2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Имя журнала <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Недопустимое имя журнала.  
  
 -или-  
  
 Недопустимое имя компьютера.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName, string source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName, string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String, machineName As String, source As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName, System::String ^ machineName, System::String ^ source);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string * string * string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog (logName, machineName, source)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Имя журнала на указанном компьютере</param>
        <param name="machineName">Компьютер, на котором существует журнал.</param>
        <param name="source">Источник записей журнала событий.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Diagnostics.EventLog" />. Связывает экземпляр с журналом на указанном компьютере и создает или присваивает заданный источник классу <see cref="T:System.Diagnostics.EventLog" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog.Log%2A> Этот конструктор задает `logName` для свойства параметр <xref:System.Diagnostics.EventLog.MachineName%2A> <xref:System.Diagnostics.EventLog.Source%2A> , свойство для `source` параметра, а свойство — для параметра. `machineName` <xref:System.Diagnostics.EventLog.Source%2A> Свойство является обязательным при записи в журнал событий. Однако, если выполняется только чтение из журнала событий, требуются только <xref:System.Diagnostics.EventLog.Log%2A> свойства и <xref:System.Diagnostics.EventLog.MachineName%2A> (если журнал событий на сервере имеет уже связанный с ним источник). Если выполняется только чтение из журнала событий, может быть достаточно другой перегрузки конструктора.  
  
 В следующей таблице показаны начальные значения свойств для экземпляра <xref:System.Diagnostics.EventLog>.  
  
|Свойство.|Начальное значение|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Параметр `source`.|  
|<xref:System.Diagnostics.EventLog.Log%2A>|Параметр `logName`.|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|Параметр `machineName`.|  
  
   
  
## Examples  
 В следующем примере запись в журнал событий MyNewLog на локальном компьютере записывается с использованием источника MySource.  
  
 [!code-cpp[Classic EventLog.EventLog3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Имя журнала <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Недопустимое имя журнала.  
  
 - или -  
  
 Недопустимое имя компьютера.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="eventLog.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Начинает инициализацию класса <see cref="T:System.Diagnostics.EventLog" />, используемого в форме или используемого другим компонентом. Инициализация происходит во время выполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Среда [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] разработки использует этот метод для запуска инициализации компонента, используемого в форме или другим компонентом. <xref:System.Diagnostics.EventLog.EndInit%2A> Метод завершает инициализацию. Использование методов <xref:System.Diagnostics.EventLog.EndInit%2A> и запрещает использование элемента управления перед его полной инициализацией. <xref:System.Diagnostics.EventLog.BeginInit%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Diagnostics.EventLog" /> уже инициализирован.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="eventLog.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет все записи из журнала событий.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для журналов событий задаются максимальные размеры, определяющие количество записей, которые могут содержаться в них. Когда журнал событий заполнен, он прекращает запись новых сведений о событиях или начинает перезаписывать предыдущие записи. Если запись событий прекращается, можно использовать этот метод, чтобы очистить журнал существующих записей и разрешить ему снова начать запись событий. Для очистки записей журнала событий необходимо иметь разрешения администратора на компьютере, на котором находится журнал.  
  
 <xref:System.Diagnostics.EventLog.Clear%2A>закрывает журнал событий, освобождает обработчики событий, получает новые дескрипторы чтения и записи и повторно открывает журнал событий. События, полученные после вызова метода, не удаляются вместе с существующими событиями.  
  
   
  
## Examples  
 В следующем примере очищается журнал событий.  
  
> [!CAUTION]
>  Так как приложение, система, безопасность и другие ненастраиваемые журналы могут содержать важную информацию; перед выполнением этого примера кода обязательно укажите пользовательский журнал. В этом примере удаляется пользовательский `myNewLog`журнал.  
  
 [!code-cpp[Classic EventLog.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Создание журнала событий не было завершено успешно.  
  
 - или -  
  
 Невозможно открыть журнал. Код ошибки Windows недоступен.</exception>
        <exception cref="T:System.ArgumentException">Для свойства <see cref="P:System.Diagnostics.EventLog.Log" /> не указано значение. Убедитесь, что имя журнала — не пустая строка.</exception>
        <exception cref="T:System.InvalidOperationException">Журнал не существует.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для администрирования сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="eventLog.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Закрывает журнал событий и удаляет дескрипторы чтения и записи.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод вызывается защищенным  <xref:System.ComponentModel.Component.Dispose%2A> методом. <xref:System.Diagnostics.EventLog.Close%2A> Не требуется вызывать <xref:System.Diagnostics.EventLog.Close%2A> перед вызовом <xref:System.ComponentModel.Component.Dispose%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Дескриптор чтения или записи события не был успешно удален.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateEventSource">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Задает приложение как источник записей для определенного журнала событий в системе.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (System.Diagnostics.EventSourceCreationData sourceData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(class System.Diagnostics.EventSourceCreationData sourceData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (sourceData As EventSourceCreationData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::Diagnostics::EventSourceCreationData ^ sourceData);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : System.Diagnostics.EventSourceCreationData -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource sourceData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceData" Type="System.Diagnostics.EventSourceCreationData" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="sourceData">Свойства конфигурации для источника событий и его целевого журнала событий.</param>
        <summary>Задает допустимый источник событий для записи локализованных сообщений о событиях, используя указанные свойства конфигурации источника событий и соответствующий журнал событий.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для настройки нового источника для записи записей в журнал событий на локальном или удаленном компьютере. Нет необходимости использовать этот метод для чтения из журнала событий.  
  
 `sourceData` Метод использует <xref:System.Diagnostics.EventSourceCreationData.LogName%2A>  входные данные <xref:System.Diagnostics.EventSourceCreationData.Source%2A> и <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A>  свойства для создания значений реестра на целевом компьютере для нового источника и связанного с ним журнала событий. <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Новое имя источника не может совпадать с именем существующего источника или существующим именем журнала событий на целевом компьютере. <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> Если свойство не задано, источник регистрируется для журнала событий приложений. Если параметр <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> не установлен, источник регистрируется на локальном компьютере.  
  
> [!NOTE]
>  Чтобы создать источник событий в Windows Vista и более поздних версиях или Windows Server 2003, необходимо иметь права администратора.  
>   
>  Причина этого требования заключается в том, что необходимо выполнить поиск всех журналов событий, включая систему безопасности, чтобы определить, является ли источник события уникальным. Начиная с Windows Vista, пользователи не имеют разрешения на доступ к журналу безопасности; <xref:System.Security.SecurityException> поэтому создается исключение.  
>   
>  Начиная с Windows Vista, привилегии пользователя определяются контролем учетных записей (UAC). Члену встроенной группы "Администраторы" присваивается два маркера доступа на время выполнения: маркер доступа обычного пользователя и маркер доступа администратора. По умолчанию назначена роль обычного пользователя. Чтобы выполнить код, обращающийся к журналу безопасности, необходимо сначала повысить привилегии обычного пользователя до администратора. Это можно сделать при запуске приложения, , щелкнув значок приложения правой кнопкой мыши и указав, что приложение должно запускаться от имени администратора.  
  
 Используйте <xref:System.Diagnostics.EventLog.WriteEvent%2A> и <xref:System.Diagnostics.EventLog.WriteEntry%2A>  для записи событий в журнал событий. Для записи событий необходимо указать источник события. перед записью первой записи с источником необходимо создать и настроить источник события.  
  
 Создайте новый источник событий во время установки приложения. Это позволяет операционной системе обновлять свой список зарегистрированных источников событий и их конфигурацию. Если операционная система не обновила список источников событий и вы пытаетесь написать событие с новым источником, операция записи завершится ошибкой. Новый источник можно настроить с помощью <xref:System.Diagnostics.EventLogInstaller>или <xref:System.Diagnostics.EventLog.CreateEventSource%2A> с помощью метода. Для создания нового источника событий необходимо иметь права администратора на компьютере.  
  
 Можно создать источник событий для существующего журнала событий или нового журнала событий. При создании нового источника для нового журнала событий система регистрирует источник для этого журнала, но журнал не создается, пока в него не будет записана первая запись.  
  
 В операционной системе журналы событий хранятся в виде файлов. При использовании <xref:System.Diagnostics.EventLogInstaller> или <xref:System.Diagnostics.EventLog.CreateEventSource%2A> для создания нового журнала событий связанный файл сохраняется в каталоге%SystemRoot%\system32\config на указанном компьютере. Имя файла задается путем добавления первых 8 символов <xref:System.Diagnostics.EventLog.Log%2A> свойства к расширению имени файла ". evt".  
  
 Каждый источник может одновременно записывать только в один журнал событий. Однако приложение может использовать несколько источников для записи в несколько журналов событий. Например, приложению может потребоваться несколько источников, настроенных для различных журналов событий или разных файлов ресурсов.  
  
 Вы можете зарегистрировать источник событий с локализованными файлами ресурсов для категорий событий и строк сообщений. Приложение может записывать записи журнала событий с помощью идентификаторов ресурсов вместо того, чтобы указывать фактическую строку. Просмотр событий использует идентификатор ресурса для поиска и вывода соответствующей строки из локализованного файла ресурсов на основе текущих языковых параметров. Можно зарегистрировать отдельный файл для категорий событий, сообщений и строк вставки параметров, либо зарегистрировать один и тот же файл ресурсов для всех трех типов строк. Используйте свойства <xref:System.Diagnostics.EventSourceCreationData.CategoryResourceFile%2A> ,, <xref:System.Diagnostics.EventSourceCreationData.MessageResourceFile%2A>  и <xref:System.Diagnostics.EventSourceCreationData.ParameterResourceFile%2A>  , чтобы настроить источник для записи локализованных записей в журнал событий. <xref:System.Diagnostics.EventSourceCreationData.CategoryCount%2A> Если приложение записывает значения строк непосредственно в журнал событий, задавать эти свойства не нужно.  
  
 Источник должен быть настроен либо для записи локализованных записей, либо для записи прямых строк. Если приложение записывает записи, используя как идентификаторы ресурсов, так и строковые значения, необходимо зарегистрировать два отдельных источника. Например, можно настроить один источник с файлами ресурсов, а затем использовать этот источник в <xref:System.Diagnostics.EventLog.WriteEvent%2A> методе для записи записей, использующих идентификаторы ресурсов, в журнал событий. Затем создайте другой источник без файлов ресурсов и используйте этот источник в <xref:System.Diagnostics.EventLog.WriteEntry%2A> методе для записи строк непосредственно в журнал событий с помощью этого источника.  
  
 Чтобы изменить сведения о конфигурации существующего источника, необходимо удалить источник, а затем создать его с новой конфигурацией. Если другие приложения или компоненты используют существующий источник, создайте новый источник с обновленной конфигурацией, а не удалите существующий источник.  
  
> [!NOTE]
>  Если источник настроен для журнала событий и вы переконфигурируете его для другого журнала событий, необходимо перезагрузить компьютер, чтобы изменения вступили в силу.  
  
   
  
## Examples  
 В следующем примере определяется, зарегистрирован ли источник событий `SampleApplicationSource` с именем на локальном компьютере. Если источник событий не существует, в примере задается файл ресурса сообщения для источника и создается новый источник событий. Наконец, в примере задается локализованное отображаемое имя для журнала событий с использованием значения идентификатора ресурса `DisplayNameMsgId` в и пути к файлу ресурса `messageFile`в.  
  
 [!code-cpp[EventLog_WriteEvent#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog_WriteEvent#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog_WriteEvent#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 В примере используется следующий текстовый файл сообщения, встроенный в библиотеку ресурсов Евентлогмсгс. dll. Текстовый файл сообщения — это источник, из которого создается файл ресурсов сообщения. В текстовом файле сообщения определяются идентификаторы ресурсов и текст для категории, сообщения о событии и строки вставки параметров. В частности, идентификатор ресурса 5001 определен для локализованного имени журнала событий.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Имя компьютера, заданное в <paramref name="sourceData" />, недопустимо.  
  
- или - 
Имя источника, указанное в параметре <paramref name="sourceData" />, равно <see langword="null" />.  
  
- или - 
Имя журнала, заданное в <paramref name="sourceData" /> недопустимо. Имена журналов событий должны содержать печатные символы и не должны содержать символы "*", "?" или "\\".  
  
- или - 
Имя журнала, заданное в <paramref name="sourceData" />, недопустимо для создания пользовательского журнала. Имена AppEvent, SysEvent и SecEvent зарезервированы для системного использования.  
  
-или- 
Имя журнала совпадает с существующим именем источника событий.  
  
- или - 
При таком имени источника, заданном в <paramref name="sourceData" />, длина пути к разделу реестра превышает 254 символа.  
  
-или- 
Первые 8 символов имени журнала, заданные в <paramref name="sourceData" />, не уникальны.  
  
-или- 
Имя источника, заданное в <paramref name="sourceData" />, уже зарегистрировано.  
  
- или - 
Имя источника, заданное в <paramref name="sourceData" />, совпадает с существующим именем журнала событий.</exception>
        <exception cref="T:System.InvalidOperationException">Не удается открыть раздел реестра для журнала событий.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="sourceData" /> имеет значение <see langword="null" />.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для администрирования сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.EventSourceCreationData" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="T:System.Diagnostics.EventLogInstaller" />
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (source As String, logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::String ^ source, System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource (source, logName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Имя источника, по которому приложение регистрируется на локальном компьютере.</param>
        <param name="logName">Имя журнала, в который вносятся записи о событиях источника. Допустимые значения: Application, System или имя пользовательского журнала событий.</param>
        <summary>Задает указанное имя источника в качестве допустимого источника событий для внесения записей в журнал на локальном компьютере. Используя этот метод, можно также создать новый пользовательский журнал на локальном компьютере.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для создания пользовательского журнала или для создания и регистрации <xref:System.Diagnostics.EventLog.Source%2A> в существующем журнале на локальном компьютере.  
  
 Если `logName` параметр `null` имеет значение или является пустой строкой ("") <xref:System.Diagnostics.EventLog.CreateEventSource%2A>при вызове, по умолчанию используется журнал приложения. Если журнал не существует на локальном компьютере, система создает пользовательский журнал и регистрирует приложение в качестве <xref:System.Diagnostics.EventLog.Source%2A> для этого журнала.  
  
> [!NOTE]
>  Чтобы создать источник событий в Windows Vista и более поздних версиях или Windows Server 2003, необходимо иметь права администратора.  
>   
>  Причина этого требования заключается в том, что необходимо выполнить поиск всех журналов событий, включая систему безопасности, чтобы определить, является ли источник события уникальным. Начиная с Windows Vista, пользователи не имеют разрешения на доступ к журналу безопасности; <xref:System.Security.SecurityException> поэтому создается исключение.  
>   
>  В Windows Vista и более поздних версиях права доступа пользователя определяются контролем учетных записей. Члену встроенной группы "Администраторы" присваивается два маркера доступа на время выполнения: маркер доступа обычного пользователя и маркер доступа администратора. По умолчанию назначена роль обычного пользователя. Чтобы выполнить код, обращающийся к журналу безопасности, необходимо сначала повысить привилегии обычного пользователя до администратора. Это можно сделать при запуске приложения, , щелкнув значок приложения правой кнопкой мыши и указав, что приложение должно запускаться от имени администратора.  
  
 При записи в журнал событий необходимо создать только источник событий. Перед записью записи в журнал событий необходимо зарегистрировать источник событий в журнале событий в качестве допустимого источника событий. При написании записи журнала система использует <xref:System.Diagnostics.EventLog.Source%2A> для поиска соответствующего журнала, в котором будет размещена запись. При чтении журнала событий можно указать <xref:System.Diagnostics.EventLog.Source%2A>либо, <xref:System.Diagnostics.EventLog.Log%2A> либо и <xref:System.Diagnostics.EventLog.MachineName%2A>.  
  
> [!NOTE]
>  При подключении к журналу на локальном <xref:System.Diagnostics.EventLog.MachineName%2A> компьютере указывать параметр не требуется. Если <xref:System.Diagnostics.EventLog.MachineName%2A> при чтении из журнала не указано, то предполагается, что используется локальный компьютер (".").  
  
 Используйте <xref:System.Diagnostics.EventLog.WriteEvent%2A> и <xref:System.Diagnostics.EventLog.WriteEntry%2A>  для записи событий в журнал событий. Для записи событий необходимо указать источник события. перед записью первой записи с источником необходимо создать и настроить источник события.  
  
 Создайте новый источник событий во время установки приложения. Это позволяет операционной системе обновлять свой список зарегистрированных источников событий и их конфигурацию. Если операционная система не обновила список источников событий и вы пытаетесь написать событие с новым источником, операция записи завершится ошибкой. Новый источник можно настроить с помощью <xref:System.Diagnostics.EventLogInstaller>или <xref:System.Diagnostics.EventLog.CreateEventSource%2A> с помощью метода. Для создания нового источника событий необходимо иметь права администратора на компьютере.  
  
 Можно создать источник событий для существующего журнала событий или нового журнала событий. При создании нового источника для нового журнала событий система регистрирует источник для этого журнала, но журнал не создается, пока в него не будет записана первая запись.  
  
 В операционной системе журналы событий хранятся в виде файлов. При использовании <xref:System.Diagnostics.EventLogInstaller> или <xref:System.Diagnostics.EventLog.CreateEventSource%2A> для создания нового журнала событий связанный файл сохраняется в каталоге%SystemRoot%\system32\config на указанном компьютере. Имя файла задается путем добавления первых 8 символов <xref:System.Diagnostics.EventLog.Log%2A> свойства к расширению имени файла ". evt".  
  
 Источник должен быть уникальным на локальном компьютере; новое имя источника не может совпадать с существующим именем источника или именем существующего журнала событий. Каждый источник может записывать только один журнал событий; Однако приложение может использовать несколько источников для записи в несколько журналов событий. Например, приложению может потребоваться несколько источников, настроенных для различных журналов событий или разных файлов ресурсов.  
  
 Источник должен быть настроен либо для записи локализованных записей, либо для записи прямых строк. Если приложение записывает записи, используя как идентификаторы ресурсов, так и строковые значения, необходимо зарегистрировать два отдельных источника. Например, можно настроить один источник с файлами ресурсов, а затем использовать этот источник в <xref:System.Diagnostics.EventLog.WriteEvent%2A> методе для записи записей, использующих идентификаторы ресурсов, в журнал событий. Затем создайте другой источник без файлов ресурсов и используйте этот источник в <xref:System.Diagnostics.EventLog.WriteEntry%2A> методе для записи строк непосредственно в журнал событий с помощью этого источника.  
  
 Чтобы изменить сведения о конфигурации существующего источника, необходимо удалить источник, а затем создать его с новой конфигурацией. Если другие приложения или компоненты используют существующий источник, создайте новый источник с обновленной конфигурацией, а не удалите существующий источник.  
  
> [!NOTE]
>  Если источник уже сопоставлен с журналом и вы переменяете его в новый журнал, необходимо перезагрузить компьютер, чтобы изменения вступили в силу.  
  
   
  
## Examples  
 В следующем примере создается источник `MySource` , если он еще не существует, и записывается запись в журнал `MyNewLog`событий.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> является пустой строкой ("") или <see langword="null" />.  
  
- или - 
 <paramref name="logName" /> не является допустимым именем журнала событий. Имена журналов событий должны содержать печатные символы и не должны содержать символы "*", "?" или "\\".  
  
- или - 
 Значение <paramref name="logName" /> недопустимо для создания журнала пользователя. Имена AppEvent, SysEvent и SecEvent зарезервированы для системного использования.  
  
-или- 
Имя журнала совпадает с существующим именем источника событий.  
  
- или - 
При таком имени источника длина пути к разделу реестра превышает 254 символа.  
  
-или- 
Первые 8 символов <paramref name="logName" /> совпадают с первыми 8 символами имени существующего журнала событий.  
  
- или - 
Невозможно зарегистрировать источник, поскольку он уже существует на локальном компьютере.  
  
-или- 
Имя источника совпадает с существующим именем журнала событий.</exception>
        <exception cref="T:System.InvalidOperationException">Раздел реестра для журнала событий не может быть открыт на локальном компьютере.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для администрирования сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (source As String, logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::String ^ source, System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : string * string * string -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource (source, logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("use CreateEventSource(EventSourceCreationData) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.Obsolete("This method has been deprecated.  Please use System.Diagnostics.EventLog.CreateEventSource(EventSourceCreationData sourceData) instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="dotnet-plat-ext-3.0;netcore-3.0">
          <AttributeName>System.Obsolete("This method has been deprecated.  Please use System.Diagnostics.EventLog.CreateEventSource(EventSourceCreationData sourceData) instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Источник, по которому приложение регистрируется на указанном компьютере.</param>
        <param name="logName">Имя журнала, в который вносятся записи о событиях источника. Допустимые значения: Application, System или имя пользовательского журнала событий. Если значение не указано, то параметр <paramref name="logName" /> по умолчанию имеет значение Application.</param>
        <param name="machineName">Имя компьютера, на котором регистрируется источник событий, или значение ".", если используется локальный компьютер.</param>
        <summary>Устанавливает заданное имяисточника в качестве допустимого источника событий для внесения записей в журнал на указанном компьютере. Этот метод можно также использовать для создания нового пользовательского журнала на заданном компьютере.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для создания пользовательского журнала или для создания и регистрации <xref:System.Diagnostics.EventLog.Source%2A> в существующем журнале на указанном компьютере.  
  
 Если `logName` параметр `null` имеет значение или является пустой строкой ("") <xref:System.Diagnostics.EventLog.CreateEventSource%2A>при вызове, по умолчанию используется журнал приложения. Если журнал не существует на указанном компьютере, система создает пользовательский журнал и регистрирует приложение в качестве <xref:System.Diagnostics.EventLog.Source%2A> для этого журнала.  
  
 При записи в журнал событий необходимо создать только источник событий. Перед записью записи в журнал событий необходимо зарегистрировать источник событий в журнале событий в качестве допустимого источника событий. При написании записи журнала система использует <xref:System.Diagnostics.EventLog.Source%2A> для поиска соответствующего журнала, в котором будет размещена запись. При чтении журнала событий можно указать <xref:System.Diagnostics.EventLog.Source%2A>либо, <xref:System.Diagnostics.EventLog.Log%2A> либо и <xref:System.Diagnostics.EventLog.MachineName%2A>.  
  
> [!NOTE]
>  Чтобы создать источник событий в Windows Vista и более поздних версиях или Windows Server 2003, необходимо иметь права администратора.  
>   
>  Причина этого требования заключается в том, что необходимо выполнить поиск всех журналов событий, включая систему безопасности, чтобы определить, является ли источник события уникальным. В Windows Vista и более поздних версиях пользователи не имеют разрешения на доступ к журналу безопасности; <xref:System.Security.SecurityException> поэтому создается исключение.  
>   
>  В Windows Vista и более поздних версиях права доступа пользователя определяются контролем учетных записей. Члену встроенной группы "Администраторы" присваивается два маркера доступа на время выполнения: маркер доступа обычного пользователя и маркер доступа администратора. По умолчанию назначена роль обычного пользователя. Чтобы выполнить код, обращающийся к журналу безопасности, необходимо сначала повысить привилегии обычного пользователя до администратора. Это можно сделать при запуске приложения, , щелкнув значок приложения правой кнопкой мыши и указав, что приложение должно запускаться от имени администратора.  
  
 Используйте <xref:System.Diagnostics.EventLog.WriteEvent%2A> и <xref:System.Diagnostics.EventLog.WriteEntry%2A>  для записи событий в журнал событий. Для записи событий необходимо указать источник события. перед записью первой записи с источником необходимо создать и настроить источник события.  
  
 Создайте новый источник событий во время установки приложения. Это позволяет операционной системе обновлять свой список зарегистрированных источников событий и их конфигурацию. Если операционная система не обновила список источников событий и вы пытаетесь написать событие с новым источником, операция записи завершится ошибкой. Новый источник можно настроить с помощью <xref:System.Diagnostics.EventLogInstaller>или <xref:System.Diagnostics.EventLog.CreateEventSource%2A> с помощью метода. Для создания нового источника событий необходимо иметь права администратора на компьютере.  
  
 Можно создать источник событий для существующего журнала событий или нового журнала событий. При создании нового источника для нового журнала событий система регистрирует источник для этого журнала, но журнал не создается, пока в него не будет записана первая запись.  
  
 В операционной системе журналы событий хранятся в виде файлов. При использовании <xref:System.Diagnostics.EventLogInstaller> или <xref:System.Diagnostics.EventLog.CreateEventSource%2A> для создания нового журнала событий связанный файл сохраняется в каталоге%SystemRoot%\system32\config на указанном компьютере. Имя файла задается путем добавления первых 8 символов <xref:System.Diagnostics.EventLog.Log%2A> свойства к расширению имени файла ". evt".  
  
 Источник должен быть уникальным на локальном компьютере; новое имя источника не может совпадать с существующим именем источника или именем существующего журнала событий. Каждый источник может записывать только один журнал событий; Однако приложение может использовать несколько источников для записи в несколько журналов событий. Например, приложению может потребоваться несколько источников, настроенных для различных журналов событий или разных файлов ресурсов.  
  
 Источник должен быть настроен либо для записи локализованных записей, либо для записи прямых строк. Если приложение записывает записи, используя как идентификаторы ресурсов, так и строковые значения, необходимо зарегистрировать два отдельных источника. Например, можно настроить один источник с файлами ресурсов, а затем использовать этот источник в <xref:System.Diagnostics.EventLog.WriteEvent%2A> методе для записи записей, использующих идентификаторы ресурсов, в журнал событий. Затем создайте другой источник без файлов ресурсов и используйте этот источник в <xref:System.Diagnostics.EventLog.WriteEntry%2A> методе для записи строк непосредственно в журнал событий с помощью этого источника.  
  
 Чтобы изменить сведения о конфигурации существующего источника, необходимо удалить источник, а затем создать его с новой конфигурацией. Если другие приложения или компоненты используют существующий источник, создайте новый источник с обновленной конфигурацией, а не удалите существующий источник.  
  
> [!NOTE]
>  Если источник уже сопоставлен с журналом и вы переменяете его в новый журнал, необходимо перезагрузить компьютер, чтобы изменения вступили в силу.  
  
   
  
## Examples  
 В следующем примере создается источник `MySource` на компьютере `MyServer`и записывается запись в журнал `MyNewLog`событий.  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> не является допустимым именем компьютера.  
  
- или - 
 <paramref name="source" /> является пустой строкой ("") или <see langword="null" />.  
  
- или - 
 <paramref name="logName" /> не является допустимым именем журнала событий. Имена журналов событий должны содержать печатные символы и не должны содержать символы "*", "?" или "\\".  
  
- или - 
 Значение <paramref name="logName" /> недопустимо для создания журнала пользователя. Имена AppEvent, SysEvent и SecEvent зарезервированы для системного использования.  
  
- или - 
Имя журнала совпадает с существующим именем источника событий.  
  
- или - 
При таком имени источника длина пути к разделу реестра превышает 254 символа.  
  
-или- 
Первые 8 символов <paramref name="logName" /> совпадают с первыми 8 символами имени существующего журнала событий на указанном компьютере.  
  
- или - 
Невозможно зарегистрировать источник, так как он уже существует на заданном компьютере.  
  
- или - 
Имя источника совпадает с существующим именем источника событий.</exception>
        <exception cref="T:System.InvalidOperationException">Раздел реестра для журнала событий не может быть открыт на указанном компьютере.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для администрирования сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Delete">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Удаляет ресурс журнала.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.Diagnostics.EventLog.Delete logName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Имя удаляемого журнала. Возможные значения: Application, Security, System или имя пользовательского журнала событий на компьютере.</param>
        <summary>Удаляет журнал событий с локального компьютера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод, если журнал, который вы хотите удалить, находится на локальном компьютере. Вы можете удалить любой журнал на компьютере, если у вас есть соответствующие разрешения в реестре.  
  
 <xref:System.Diagnostics.EventLog.Delete%2A>Удаляет журнал, `logName` указанный с локального компьютера. Если необходимо удалить только источник, зарегистрированный в журнале, вызовите <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. Если нужно только удалить записи журнала, вызовите <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A>методы <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> и `static` являются методами, поэтому их можно вызывать в самом классе. Нет необходимости создавать новый экземпляр <xref:System.Diagnostics.EventLog> для вызова любого из методов.  
  
 Сначала <xref:System.Diagnostics.EventLog.Delete%2A> метод удаляет файл, содержащий содержимое журнала. Затем он обращается к реестру и удаляет все источники событий, зарегистрированные для этого журнала. Если вы повторно создаете журнал позже, необходимо снова зарегистрировать источники событий, если они будут повторно использоваться. Если вы не регистрируете источники событий и другие пользователи выполняют запись в источник событий без указания имени журнала, источник события будет создан в журнале событий приложений. Таким образом, приложения, которые ранее смогли записать записи в удаленный и воссозданный журнал, вместо этого будут записывать данные в журнал приложений, так как теперь он содержит источник событий.  
  
> [!NOTE]
>  Повторное создание журнала событий может быть сложным процессом. Не удаляйте созданные системой журналы событий, например журнал приложений.  
  
 При удалении журнала через вызов <xref:System.Diagnostics.EventLog.Delete%2A> автоматически удаляются источники, зарегистрированные в этом журнале. Это может привести к неработоспособности других приложений, использующих этот журнал.  
  
   
  
## Examples  
 В следующем примере удаляется журнал с локального компьютера. В примере определяется журнал из источника.  
  
> [!NOTE]
>  В журнал событий может записываться более одного источника. Перед удалением настраиваемого журнала убедитесь, что другие источники не выполняют запись в этот журнал.  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="logName" /> является пустой строкой ("") или <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Раздел реестра для журнала событий не может быть открыт на локальном компьютере.  
  
- или -
  
 Журнала на локальном компьютере не существует.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Создание журнала событий не было завершено успешно.  
  
 -или-  
  
 Невозможно открыть журнал. Код ошибки Windows недоступен.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для администрирования сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member Delete : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.Delete (logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Имя удаляемого журнала. Возможные значения: Application, Security, System или имя пользовательского журнала событий на компьютере.</param>
        <param name="machineName">Имя компьютера, с которого удаляется журнал, или значение ".", если используется локальный компьютер.</param>
        <summary>Удаляет журнал событий с указанного компьютера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод, если журнал, который вы хотите удалить, находится на удаленном компьютере. Вы можете удалить любой журнал на компьютере, если у вас есть соответствующие разрешения в реестре.  
  
 <xref:System.Diagnostics.EventLog.Delete%2A>Удаляет журнал, `logName` указанный с компьютера, заданного параметром `machineName`. Если необходимо удалить только источник, зарегистрированный в журнале, вызовите <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. Если нужно только удалить записи журнала, вызовите <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A>методы <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> и `static` являются методами, поэтому их можно вызывать в самом классе. Нет необходимости создавать экземпляр <xref:System.Diagnostics.EventLog> для вызова любого из методов.  
  
 Сначала этот метод удаляет файл, содержащий содержимое журнала. Затем он обращается к реестру и удаляет все источники событий, зарегистрированные для этого журнала. Если вы повторно создаете журнал позже, необходимо снова зарегистрировать источники событий, если они будут повторно использоваться. Если вы не регистрируете источники событий и другие пользователи выполняют запись в источник событий без указания имени журнала, источник события будет создан в журнале событий приложений. Таким образом, приложения, которые ранее смогли записать записи в удаленный и воссозданный журнал, вместо этого будут записывать данные в журнал приложений, так как теперь он содержит источник событий.  
  
> [!NOTE]
>  Повторное создание журнала событий может быть сложным процессом. Не удаляйте созданные системой журналы событий, например журнал приложений.  
  
 При удалении журнала через вызов <xref:System.Diagnostics.EventLog.Delete%2A> автоматически удаляются источники, зарегистрированные в этом журнале. Это может привести к неработоспособности других приложений, использующих этот журнал.  
  
   
  
## Examples  
 В следующем примере удаляется журнал с указанного компьютера. В примере определяется журнал из источника.  
  
> [!NOTE]
>  В журнал событий может записываться более одного источника. Перед удалением настраиваемого журнала убедитесь, что другие источники не выполняют запись в этот журнал.  
  
 [!code-cpp[Classic EventLog.Delete1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="logName" /> является пустой строкой ("") или <see langword="null" />.  
  
-или- 
 Параметр <paramref name="machineName" /> не является допустимым именем компьютера.</exception>
        <exception cref="T:System.InvalidOperationException">Раздел реестра для журнала событий не может быть открыт на указанном компьютере.  
  
- или -
  
 Журнала на указанном компьютере не существует.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Создание журнала событий не было завершено успешно.  
  
 - или -  
  
 Невозможно открыть журнал. Код ошибки Windows недоступен.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для администрирования сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteEventSource">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Удаляет из журнала событий регистрацию источника событий приложения.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteEventSource (source As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteEventSource(System::String ^ source);" />
      <MemberSignature Language="F#" Value="static member DeleteEventSource : string -&gt; unit" Usage="System.Diagnostics.EventLog.DeleteEventSource source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Имя, с которым приложение регистрируется в журнале событий системы.</param>
        <summary>Удаляет регистрацию источника событий из журнала событий на локальном компьютере.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется для удаления регистрации <xref:System.Diagnostics.EventLog.Source%2A> с локального компьютера. <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>обращается к реестру на локальном компьютере и удаляет регистрацию приложения в качестве допустимого источника событий.  
  
 Можно удалить компонент в качестве допустимого источника событий, если он больше не нужен для записи в этот журнал. Например, это можно сделать, если необходимо изменить компонент с одного журнала на другой. Поскольку источник может быть зарегистрирован только в одном журнале за раз, изменение журнала требует удаления текущей регистрации.  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>Удаляет только источник, зарегистрированный в журнале. Если вы хотите удалить сам журнал, вызовите метод <xref:System.Diagnostics.EventLog.Delete%2A>. Если нужно только удалить записи журнала, вызовите <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A>методы <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> и `static` являются методами, поэтому их можно вызывать в самом классе. Нет необходимости создавать экземпляр <xref:System.Diagnostics.EventLog> для вызова любого из методов.  
  
 При удалении журнала через вызов <xref:System.Diagnostics.EventLog.Delete%2A> автоматически удаляются источники, зарегистрированные в этом журнале. Это может привести к неработоспособности других приложений, использующих этот журнал.  
  
> [!NOTE]
>  Если источник уже сопоставлен с журналом и вы переменяете его в новый журнал, необходимо перезагрузить компьютер, чтобы изменения вступили в силу.  
  
   
  
## Examples  
 В следующем примере удаляется источник с локального компьютера. В примере определяется журнал из источника, а затем удаляется журнал.  
  
> [!NOTE]
>  В журнал событий может записываться более одного источника. Перед удалением настраиваемого журнала убедитесь, что другие источники не выполняют запись в этот журнал.  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="source" /> отсутствует в реестре локального компьютера.  
  
- или - 
Отсутствуют права на запись в раздел реестра для журнала событий.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для администрирования сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteEventSource (source As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteEventSource(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member DeleteEventSource : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.DeleteEventSource (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Имя, с которым приложение регистрируется в журнале событий системы.</param>
        <param name="machineName">Имя компьютера, с которого удаляется регистрация, или "." для локального компьютера.</param>
        <summary>Удаляет регистрацию источника событий приложения с указанного компьютера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для удаления регистрации <xref:System.Diagnostics.EventLog.Source%2A> с удаленного компьютера. <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>обращается к реестру на компьютере, указанном параметром `machineName` , и удаляет регистрацию приложения в качестве допустимого источника событий.  
  
 Можно удалить компонент в качестве допустимого источника событий, если он больше не нужен для записи в этот журнал. Например, это можно сделать, если необходимо изменить компонент с одного журнала на другой. Поскольку источник может быть зарегистрирован только в одном журнале за раз, изменение журнала требует удаления текущей регистрации.  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>Удаляет только источник, зарегистрированный в журнале. Если вы хотите удалить сам журнал, вызовите метод <xref:System.Diagnostics.EventLog.Delete%2A>. Если нужно только удалить записи журнала, вызовите <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A>методы <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> и `static` являются методами, поэтому их можно вызывать в самом классе. Нет необходимости создавать экземпляр <xref:System.Diagnostics.EventLog> для вызова любого из методов.  
  
 При удалении журнала через вызов <xref:System.Diagnostics.EventLog.Delete%2A> автоматически удаляются источники, зарегистрированные в этом журнале. Это может привести к неработоспособности других приложений, использующих этот журнал.  
  
> [!NOTE]
>  Если источник уже сопоставлен с журналом и вы переменяете его в новый журнал, необходимо перезагрузить компьютер, чтобы изменения вступили в силу.  
  
   
  
## Examples  
 В следующем примере удаляется источник с указанного компьютера. В примере определяется журнал из источника, а затем удаляется журнал.  
  
> [!NOTE]
>  В журнал событий может записываться более одного источника. Перед удалением настраиваемого журнала убедитесь, что другие источники не выполняют запись в этот журнал.  
  
 [!code-cpp[Classic EventLog.Delete1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="machineName" /> является недопустимым.  
  
-или- 
Параметр <paramref name="source" /> отсутствует в реестре заданного компьютера.  
  
- или - 
Отсутствуют права на запись в раздел реестра для журнала событий.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> не может быть удален, так как в реестре, родительский раздел реестра <paramref name="source" /> не содержит подразделы с тем же именем.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для администрирования сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="eventLog.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Значение <see langword="true" /> позволяет освободить управляемые и неуправляемые ресурсы; значение <see langword="false" /> позволяет освободить только неуправляемые ресурсы.</param>
        <summary>Освобождает неуправляемые ресурсы, используемые журналом <see cref="T:System.Diagnostics.EventLog" />, и при необходимости освобождает также управляемые ресурсы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается открытым `Dispose()` методом <xref:System.Object.Finalize%2A> и методом. `Dispose()`вызывает защищенный `Dispose(Boolean)` метод с параметром `disposing` , для `true`которого задано значение. <xref:System.Object.Finalize%2A>вызывает метод `disposing` `false`с параметром, равным. `Dispose`  
  
 Если параметр имеет значение true, этот метод освобождает все ресурсы, удерживаемые всеми управляемыми объектами <xref:System.Diagnostics.EventLog> , на которые ссылается эта ссылка. `disposing` Этот метод вызывает метод `Dispose()` каждого объекта, на который есть ссылка.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Метод 
            <see langword="Dispose" /> может вызываться несколько раз другими объектами. При переопределении <see langword="Dispose(Boolean)" /> следует избегать ссылок на объекты, которые были удалены ранее при предыдущем <see langword="Dispose" />вызове метода. Дополнительные сведения о реализации <see langword="Dispose(Boolean)" />см. в разделе [Реализация метода Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Дополнительные сведения о <see langword="Dispose" /> и <see cref="M:System.Object.Finalize" />см. в разделе [Очистка неуправляемых ресурсов](~/docs/standard/garbage-collection/unmanaged.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.Diagnostics.EventLog.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("If enabled raises event when a log is written.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogMonitoring")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, определяющее, получает ли класс <see cref="T:System.Diagnostics.EventLog" /> уведомления о событии <see cref="E:System.Diagnostics.EventLog.EntryWritten" />.</summary>
        <value>Значение <see langword="true" />, если класс <see cref="T:System.Diagnostics.EventLog" /> получает уведомления при внесении записи в журнал; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство определяет, <xref:System.Diagnostics.EventLog> вызывает ли событие события при записи записей в журнал. <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> Если свойство имеет `true`значение, компоненты, <xref:System.Diagnostics.EventLog.EntryWritten> получающие событие, получат уведомление при каждом записи записи в журнал <xref:System.Diagnostics.EventLog.Log%2A> , указанный в свойстве. Если <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> имеет `false`значение, события не вызываются.  
  
> [!NOTE]
>  Уведомления о событиях можно получать только в том случае, если записи записываются на локальный компьютер. Вы не можете получать уведомления для записей, записанных на удаленных компьютерах.  
  
   
  
## Examples  
 В следующем примере обрабатывается <xref:System.Diagnostics.EventLog.EntryWritten> событие.  
  
 [!code-cpp[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Журнал событий на удаленном компьютере.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="E:System.Diagnostics.EventLog.EntryWritten" />
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="eventLog.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Завершает инициализацию класса <see cref="T:System.Diagnostics.EventLog" />, используемого в форме или другим компонентом. Инициализация происходит во время выполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Среда [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] разработки использует этот метод для завершения инициализации компонента, используемого в форме или другим компонентом. <xref:System.Diagnostics.EventLog.BeginInit%2A> Метод запускает инициализацию. Использование методов <xref:System.Diagnostics.EventLog.EndInit%2A> и предотвращает использование элемента управления перед его полной инициализацией. <xref:System.Diagnostics.EventLog.BeginInit%2A>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="Entries">
      <MemberSignature Language="C#" Value="public System.Diagnostics.EventLogEntryCollection Entries { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.EventLogEntryCollection Entries" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Entries" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Entries As EventLogEntryCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::EventLogEntryCollection ^ Entries { System::Diagnostics::EventLogEntryCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Entries : System.Diagnostics.EventLogEntryCollection" Usage="System.Diagnostics.EventLog.Entries" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The entries in the log.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogEntries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLogEntryCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает содержимое журнала событий.</summary>
        <value>Класс <see cref="T:System.Diagnostics.EventLogEntryCollection" />, в котором хранятся записи журнала событий. Каждая запись связана с экземпляром класса <see cref="T:System.Diagnostics.EventLogEntry" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog.Entries%2A> Используйте элемент при чтении из журнала событий.  
  
 Поскольку свойство доступно только для чтения, нельзя изменить запись или запись в журнал с помощью <xref:System.Diagnostics.EventLog.Entries%2A>. Вместо этого укажите <xref:System.Diagnostics.EventLog.Source%2A> и вызов <xref:System.Diagnostics.EventLog.WriteEntry%2A> , чтобы записать новую запись в журнал. Можно использовать <xref:System.Diagnostics.EventLog.Entries%2A> для подсчета количества записей в журнале событий и просматривать их <xref:System.Diagnostics.EventLogEntry> в коллекции. Используйте <xref:System.Diagnostics.EventLogEntryCollection.Item%2A> индексированный элемент для получения сведений о конкретной записи, <xref:System.Diagnostics.EventLogEntry.Message%2A>например, <xref:System.Diagnostics.EventLogEntry.Category%2A> <xref:System.Diagnostics.EventLogEntry.TimeWritten%2A>, или <xref:System.Diagnostics.EventLogEntry.EntryType%2A>.  
  
 При чтении из журнала необязательно <xref:System.Diagnostics.EventLog.Source%2A> указывать значение. Для <xref:System.Diagnostics.EventLog> экземпляра можно указать только <xref:System.Diagnostics.EventLog.Log%2A> свойства Name <xref:System.Diagnostics.EventLog.MachineName%2A> и (имя компьютера сервера). В любом случае <xref:System.Diagnostics.EventLog.Entries%2A> элемент автоматически заполняется списком записей журнала событий. Для чтения отдельных записей можно выбрать соответствующий индекс элемента в этом списке.  
  
 Важным различием между чтением и записью записей журнала является необязательное явное обращение к методу Read. После того <xref:System.Diagnostics.EventLog.Log%2A> как <xref:System.Diagnostics.EventLog.MachineName%2A> указаны значения и, <xref:System.Diagnostics.EventLog.Entries%2A> свойство заполняется автоматически. Если изменить значение <xref:System.Diagnostics.EventLog.Log%2A> свойства или <xref:System.Diagnostics.EventLog.MachineName%2A> , <xref:System.Diagnostics.EventLog.Entries%2A> оно будет повторно заполнено при следующем чтении.  
  
> [!NOTE]
>  Указывать значение <xref:System.Diagnostics.EventLog.MachineName%2A> при подключении к журналу не требуется. Если не указать <xref:System.Diagnostics.EventLog.MachineName%2A>, предполагается, что используется локальный компьютер ".".  
  
   
  
## Examples  
 Следующий пример считывает записи в журнале событий MyNewLog на локальном компьютере.  
  
 [!code-cpp[Classic EventLog.Entries Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Entries Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Entries Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">для администрирования сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryCollection" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
      </Docs>
    </Member>
    <Member MemberName="EntryWritten">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.EntryWrittenEventHandler EntryWritten;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.EntryWrittenEventHandler EntryWritten" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.EventLog.EntryWritten" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event EntryWritten As EntryWrittenEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::EntryWrittenEventHandler ^ EntryWritten;" />
      <MemberSignature Language="F#" Value="member this.EntryWritten : System.Diagnostics.EntryWrittenEventHandler " Usage="member this.EntryWritten : System.Diagnostics.EntryWrittenEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Raised for each EventLog entry written.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogEntryWritten")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EntryWrittenEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при внесении записи в журнал событий на локальном компьютере.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для получения уведомлений о событиях необходимо задать для <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> `true`значение. Уведомления о событиях можно получать только при записи записей на локальном компьютере. Вы не можете получать уведомления для записей, записанных на удаленных компьютерах.  
  
 При создании делегата <xref:System.Diagnostics.EventLog.EntryWritten> определяется метод обработки события. Чтобы связать событие с обработчиком событий, нужно добавить в событие экземпляр делегата. Обработчик событий вызывается при каждом возникновении события, пока не будет удален делегат. Дополнительные сведения об обработке событий с помощью делегатов см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Система отвечает <xref:System.Diagnostics.EventLog.WriteEntry%2A> , только если Последнее событие записи произошло по крайней мере через шесть секунд ранее. Это означает, что вы получите только <xref:System.Diagnostics.EventLog.EntryWritten> одно уведомление о событии в течение шести секунд, даже если происходит более одного изменения журнала событий. Если вы вставили достаточно длительный интервал спящего режима (около 10 секунд) <xref:System.Diagnostics.EventLog.WriteEntry%2A>между вызовами, то вероятность пропуска события будет меньше. Однако если события записи происходят чаще, вы можете не получить уведомление о событии до следующего интервала. Как правило, уведомления о пропущенных событиях не теряются, но задерживаются.  
  
   
  
## Examples  
 В следующем примере обрабатывается записанное событие записи.  
  
 [!code-cpp[Classic EventLog.EntryWritten Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EntryWritten Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EntryWritten Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">для администрирования сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.EnableRaisingEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Exists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Определяет существование указанного журнала.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (logName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.Diagnostics.EventLog.Exists logName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Имя журнала, который нужно найти. Возможные значения: Application, Security, System, имена журналов определенных приложений (например службы каталогов Active Directory) или имя любого пользовательского журнала на компьютере.</param>
        <summary>Определяет наличие журнала на локальном компьютере.</summary>
        <returns>Значение <see langword="true" />, если журнал существует на локальном компьютере; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод, чтобы определить, существует ли журнал на локальном компьютере. Если необходимо определить, существует ли источник на локальном компьютере, используйте <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
 Поскольку этот метод обращается к реестру, необходимо иметь соответствующие разрешения на доступ к реестру на локальном компьютере. в противном случае запрос `false`возвращает значение.  
  
 Так как нельзя присвоить новому журналу имя существующего журнала на том же компьютере, используйте этот метод перед созданием нового журнала, чтобы определить, существует ли `logName` уже указанный на локальном компьютере. `logName` Параметр не учитывает регистр.  
  
 <xref:System.Diagnostics.EventLog.Exists%2A>`static` метод является методом, поэтому его можно вызывать для самого класса. Нет необходимости создавать экземпляр <xref:System.Diagnostics.EventLog> для вызова. <xref:System.Diagnostics.EventLog.Exists%2A>  
  
   
  
## Examples  
 [!code-cpp[EventLog_Exists_1#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_Exists_1/CPP/eventlog_exists_1.cpp#1)]
 [!code-csharp[EventLog_Exists_1#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_Exists_1/CS/eventlog_exists_1.cs#1)]
 [!code-vb[EventLog_Exists_1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_Exists_1/VB/eventlog_exists_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр logName принимает значение <see langword="null" /> или пустое значение.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для администрирования сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (logName As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member Exists : string * string -&gt; bool" Usage="System.Diagnostics.EventLog.Exists (logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Журнал, который нужно найти. Возможные значения: Application, Security, System, имена журналов определенных приложений (например службы каталогов Active Directory) или имя любого пользовательского журнала на компьютере.</param>
        <param name="machineName">Имя компьютера, на котором выполняется поиск журнала, или значение ".", если используется локальный компьютер.</param>
        <summary>Определяет наличие журнала на заданном компьютере.</summary>
        <returns>Значение <see langword="true" />, если журнал существует на заданном компьютере; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод, чтобы определить, существует ли журнал на удаленном компьютере. Если необходимо определить, существует ли источник на удаленном компьютере, используйте <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
 Поскольку этот метод обращается к реестру, необходимо иметь соответствующие разрешения на доступ к реестру на указанном компьютере. в противном случае запрос `false`возвращает значение.  
  
 Так как нельзя присвоить новому журналу имя существующего журнала на том же компьютере, используйте этот метод перед созданием нового журнала, чтобы определить, `logName` существует ли на сервере, указанном `machineName` параметром, уже существующий. Параметры `logName` и `machineName`  не учитывают регистр.  
  
 <xref:System.Diagnostics.EventLog.Exists%2A>`static` метод является методом, поэтому его можно вызывать для самого класса. Нет необходимости создавать новый экземпляр <xref:System.Diagnostics.EventLog> для вызова. <xref:System.Diagnostics.EventLog.Exists%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Недопустимый формат параметра <paramref name="machineName" />. Убедитесь, что при поиске на компьютере используется правильный синтаксис.  
  
- или - 
Параметр <paramref name="logName" /> принимает значение <see langword="null" /> или пустое значение.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для администрирования сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEventLogs">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает массив журналов событий.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEventLogs () As EventLog()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::EventLog ^&gt; ^ GetEventLogs();" />
      <MemberSignature Language="F#" Value="static member GetEventLogs : unit -&gt; System.Diagnostics.EventLog[]" Usage="System.Diagnostics.EventLog.GetEventLogs " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Выполняет поиск всех журналов событий на локальном компьютере и создает массив объектов <see cref="T:System.Diagnostics.EventLog" />, содержащих список.</summary>
        <returns>Массив типа <see cref="T:System.Diagnostics.EventLog" />, представляющий журналы на локальном компьютере.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Массив <xref:System.Diagnostics.EventLog> объектов — это моментальный снимок всех журналов событий на локальном компьютере при <xref:System.Diagnostics.EventLog.GetEventLogs%2A> вызове метода. Это не динамическая коллекция, поэтому она не отражает удаление или создание журналов в режиме реального времени. Перед чтением или записью в массив необходимо убедиться, что журнал в нем существует. Массив обычно содержит по крайней мере три журнала: приложение, система и безопасность. Если вы создали пользовательские журналы на локальном компьютере, они также будут отображаться в массиве.  
  
 Чтобы получить список журналов событий, необходимо иметь соответствующие разрешения в реестре. Эти разрешения идентичны тем, которые необходимы для вызова <xref:System.Diagnostics.EventLog.Exists%2A> функций <xref:System.Diagnostics.EventLog.SourceExists%2A>и.  
  
   
  
## Examples  
 В следующем примере перечисляются журналы событий, определенные на локальном компьютере, и отображаются сведения о конфигурации для каждого журнала событий.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">Отсутствуют права на доступ к реестру.  
  
 - или -  
  
 На компьютере отсутствует служба журнала событий.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для администрирования сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEventLogs (machineName As String) As EventLog()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::EventLog ^&gt; ^ GetEventLogs(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetEventLogs : string -&gt; System.Diagnostics.EventLog[]" Usage="System.Diagnostics.EventLog.GetEventLogs machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Компьютер, на котором выполняется поиск журналов событий.</param>
        <summary>Выполняет поиск всех журналов событий на заданном компьютере и создает массив объектов <see cref="T:System.Diagnostics.EventLog" />, содержащих список.</summary>
        <returns>Массив типа <see cref="T:System.Diagnostics.EventLog" />, представляющий журналы на заданном компьютере.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Массив <xref:System.Diagnostics.EventLog> объектов — это моментальный снимок всех журналов событий на компьютере, заданном `machineName` <xref:System.Diagnostics.EventLog.GetEventLogs%2A> параметром, когда выполняется вызов. Это не динамическая коллекция, поэтому она не отражает удаление или создание журналов в режиме реального времени. Перед чтением или записью в массив необходимо убедиться, что журнал в нем существует. Массив обычно содержит по крайней мере три журнала: приложение, система и безопасность. Если на указанном компьютере были созданы пользовательские журналы, они также будут отображаться в массиве.  
  
 <xref:System.Diagnostics.EventLog.GetEventLogs%2A>метод является методом, поэтому его можно вызывать <xref:System.Diagnostics.EventLog> для самого класса. `static` Нет необходимости создавать экземпляр <xref:System.Diagnostics.EventLog> объекта для выполнения вызова метода.  
  
 Чтобы получить список журналов событий, необходимо иметь соответствующие разрешения в реестре. Эти разрешения идентичны тем, которые необходимы для вызова <xref:System.Diagnostics.EventLog.Exists%2A> функций <xref:System.Diagnostics.EventLog.SourceExists%2A>и.  
  
   
  
## Examples  
 В следующем примере возвращается список журналов на компьютере myServer. Затем он выводит имя каждого журнала.  
  
 [!code-cpp[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="machineName" /> содержит недопустимое имя компьютера.</exception>
        <exception cref="T:System.InvalidOperationException">Отсутствуют права на доступ к реестру.  
  
 - или -  
  
 На компьютере отсутствует служба журнала событий.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для администрирования сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public string Log { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Log" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Log" />
      <MemberSignature Language="VB.NET" Value="Public Property Log As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Log { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Log : string with get, set" Usage="System.Diagnostics.EventLog.Log" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the log that is read and written.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogLog")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает имя журнала, из которого производится чтение или запись.</summary>
        <value>Имя журнала. Существуют следующие имена: журнал приложения, журнал системы, журнал безопасности или имя, указанное пользователем. Значение по умолчанию — пустая строка ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 На сервере по умолчанию существуют три файла журнала: приложение, система и безопасность. Приложения и службы используют файл журнала приложений. Драйверы устройств используют файл журнала системы. Система создает события успешного и неуспешного аудита в журнале безопасности при включенном аудите. Если установлены другие приложения, например Active Directory на серверах Windows, могут существовать и другие файлы журнала по умолчанию. Кроме того, можно создавать пользовательские файлы журналов на локальном или удаленном компьютере. Настраиваемые журналы помогают упорядочить записи более подробно, чем разрешено, когда компоненты записывают события в журнал приложений по умолчанию.  
  
> [!NOTE]
>  Длина имен журналов ограничена восемью символами. В соответствии с системой MyLogSample1 и MyLogSample2 являются одним и тем же журналом.  
  
 При записи в журнал событий недостаточно указать <xref:System.Diagnostics.EventLog.Log%2A> свойство. Необходимо связать <xref:System.Diagnostics.EventLog.Source%2A> свойство с ресурсом журнала событий, чтобы подключить его к определенному журналу. Не обязательно указывать значение <xref:System.Diagnostics.EventLog.Source%2A> при чтении из журнала, но источник событий должен быть связан с ресурсом журнала событий в реестре сервера. Для чтения из него можно <xref:System.Diagnostics.EventLog.Log%2A> указать только <xref:System.Diagnostics.EventLog.MachineName%2A> имя и имя компьютера сервера.  
  
> [!NOTE]
>  Указывать значение <xref:System.Diagnostics.EventLog.MachineName%2A> при подключении к журналу не требуется. Если не указать <xref:System.Diagnostics.EventLog.MachineName%2A>, предполагается, что используется локальный компьютер (".").  
  
 Если свойство не задано, <xref:System.Diagnostics.EventLog.Log%2A> вызов возвращает пустую строку, если <xref:System.Diagnostics.EventLog.Log%2A> параметр <xref:System.Diagnostics.EventLog.Log%2A> не был явно задан (путем задания свойства или с помощью конструктора). <xref:System.Diagnostics.EventLog.Source%2A> Если указан <xref:System.Diagnostics.EventLog.Source%2A> параметр, <xref:System.Diagnostics.EventLog.Log%2A> возвращает имя журнала, в который был зарегистрирован этот источник.  
  
 Источник может быть зарегистрирован только в одном журнале за раз. <xref:System.Diagnostics.EventLog.Source%2A> <xref:System.Diagnostics.EventLog.Log%2A> <xref:System.Diagnostics.EventLog> <xref:System.Diagnostics.EventLog> Если свойство было задано для экземпляра, нельзя изменить свойство для этого свойства без изменения значения или вызова <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> First. <xref:System.Diagnostics.EventLog.Source%2A> Если изменить <xref:System.Diagnostics.EventLog.Log%2A> свойство <xref:System.Diagnostics.EventLog.Source%2A> после установки свойства, запись журнала вызывает исключение.  
  
 В операционной системе журналы событий хранятся в виде файлов. При использовании <xref:System.Diagnostics.EventLogInstaller> или <xref:System.Diagnostics.EventLog.CreateEventSource%2A> для создания нового журнала событий связанный файл сохраняется в каталоге%SystemRoot%\system32\config на указанном компьютере. Имя файла задается путем добавления первых 8 символов <xref:System.Diagnostics.EventLog.Log%2A> свойства к расширению имени файла ". evt".  
  
 Нельзя создать новый журнал, <xref:System.Diagnostics.EventLog.Log%2A> используя только свойство (без указания источника для журнала). Можно вызвать <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, передав новое имя журнала в качестве параметра, а затем вызвать <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. Тем не менее намерением обычно является создание (и запись записей) новых журналов для конкретного приложения или чтение из существующих журналов.  
  
 <xref:System.Diagnostics.EventLog.Log%2A> Если значение изменяется, журнал событий закрывается и освобождаются все дескрипторы событий.  
  
> [!CAUTION]
>  Если задать <xref:System.Diagnostics.EventLog.Log%2A> для свойства имя журнала, который не существует, система присоединит его <xref:System.Diagnostics.EventLog> к журналу приложений, но не предупреждает о том, что используется журнал, отличный от указанного вами.  
  
   
  
## Examples  
 Следующий пример считывает записи в журнале событий «Невевентлог» на локальном компьютере.  
  
 [!code-cpp[Classic EventLog.Log Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Log Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Log Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Log Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="T:System.Diagnostics.EventLogEntryCollection" />
      </Docs>
    </Member>
    <Member MemberName="LogDisplayName">
      <MemberSignature Language="C#" Value="public string LogDisplayName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LogDisplayName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.LogDisplayName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogDisplayName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LogDisplayName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogDisplayName : string" Usage="System.Diagnostics.EventLog.LogDisplayName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает понятное имя журнала событий.</summary>
        <value>Имя, представляющее журнал событий в "Просмотре событий".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  В Windows Vista и более поздних версиях пользователи не имеют разрешения на доступ к журналу безопасности. Если вы используете Windows Vista или более поздней версии в качестве пользователя, при попытке получить доступ к отображаемому имени события в журнале безопасности будет получен <xref:System.Security.SecurityException> ответ.  
>   
>  В Windows Vista и более поздних версиях права доступа пользователя определяются контролем учетных записей. Члену встроенной группы "Администраторы" присваивается два маркера доступа на время выполнения: маркер доступа обычного пользователя и маркер доступа администратора. По умолчанию назначена роль обычного пользователя. Чтобы выполнить код, обращающийся к журналу безопасности, необходимо сначала повысить привилегии обычного пользователя до администратора. Это можно сделать при запуске приложения, , щелкнув значок приложения правой кнопкой мыши и указав, что приложение должно запускаться от имени администратора.  
  
   
  
## Examples  
 В следующем примере перечисляются журналы событий, определенные на локальном компьютере, и отображается <xref:System.Diagnostics.EventLog.LogDisplayName%2A> для каждого журнала событий.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Параметр <see cref="P:System.Diagnostics.EventLog.Log" /> отсутствует в реестре для этого компьютера.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для администрирования сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">для возможности чтения указанного раздела реестра. Связанное перечисление:<see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">возможность доступа к указанному разделу реестра, если он является удаленным ключом. Связанное перечисление:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="LogNameFromSourceName">
      <MemberSignature Language="C#" Value="public static string LogNameFromSourceName (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string LogNameFromSourceName(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LogNameFromSourceName (source As String, machineName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LogNameFromSourceName(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member LogNameFromSourceName : string * string -&gt; string" Usage="System.Diagnostics.EventLog.LogNameFromSourceName (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Имя источника событий.</param>
        <param name="machineName">Имя компьютера, на котором выполняется поиск, или значение ".", если используется локальный компьютер.</param>
        <summary>Возвращает имя журнала, в котором зарегистрирован указанный источник.</summary>
        <returns>Имя журнала, связанное с указанным источником в реестре.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Источник события указывает, в каком журнале регистрируется событие. Часто это имя приложения или имя подкомпонента приложения, если приложение велико. Приложения и службы должны записывать в журнал приложений или пользовательский журнал. Драйверы устройств должны записывать в системный журнал.  
  
 При создании нового источника, который может записывать данные только в один журнал, система регистрирует приложение в качестве допустимого источника записей в журнале событий. <xref:System.Diagnostics.EventLog.Source%2A> Свойство может быть любой строкой, но оно не может использоваться другими источниками на компьютере. Попытка создать повторяющееся <xref:System.Diagnostics.EventLog.Source%2A> значение приводит к возникновению исключения. Однако один журнал событий может иметь множество различных источников, в которых осуществляется запись.  
  
   
  
## Examples  
 В следующем примере удаляется источник с локального компьютера. В примере определяется журнал из источника, а затем удаляется журнал.  
  
> [!NOTE]
>  В журнал событий может записываться более одного источника. Перед удалением настраиваемого журнала убедитесь, что другие источники не выполняют запись в этот журнал.  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">для администрирования сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string with get, set" Usage="System.Diagnostics.EventLog.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(".")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the machine that this log get written to.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogMachineName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает имя компьютера, на котором производится чтение или запись событий.</summary>
        <value>Имя сервера, на котором находится журнал событий. Значение по умолчанию — локальный компьютер (".").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При записи в журнал событий необходимо связать <xref:System.Diagnostics.EventLog.Source%2A> объект с объектом журнала событий, чтобы подключить его к определенному журналу. Не обязательно указывать <xref:System.Diagnostics.EventLog.Source%2A> свойство при чтении из журнала. Можно указать только <xref:System.Diagnostics.EventLog.Log%2A> имя и <xref:System.Diagnostics.EventLog.MachineName%2A> (имя компьютера сервера).  
  
> [!NOTE]
>  При подключении к журналу <xref:System.Diagnostics.EventLog.MachineName%2A> указывать не нужно. Если не указать <xref:System.Diagnostics.EventLog.MachineName%2A>, предполагается, что используется локальный компьютер (".").  
  
 Источник может быть зарегистрирован только в одном журнале за раз. <xref:System.Diagnostics.EventLog.Source%2A> <xref:System.Diagnostics.EventLog.MachineName%2A> <xref:System.Diagnostics.EventLog> <xref:System.Diagnostics.EventLog> Если свойство было задано для экземпляра, нельзя изменить свойство для этого свойства без изменения значения или вызова <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> First. <xref:System.Diagnostics.EventLog.Source%2A> При изменении <xref:System.Diagnostics.EventLog.MachineName%2A> свойства <xref:System.Diagnostics.EventLog> команда закрывает все дескрипторы и повторно подключается к журналу и источнику на новом компьютере.  
  
 <xref:System.Diagnostics.EventLog.MachineName%2A> Значение не может быть пустой строкой. Если он не задан явно, по умолчанию используется локальный компьютер (".").  
  
   
  
## Examples  
 Следующий пример считывает записи в журнале событий «Невевентлог» на указанном компьютере.  
  
 [!code-cpp[Classic EventLog.MachineName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.MachineName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.MachineName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Недопустимое имя компьютера.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.GetEventLogs" />
      </Docs>
    </Member>
    <Member MemberName="MaximumKilobytes">
      <MemberSignature Language="C#" Value="public long MaximumKilobytes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumKilobytes" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MaximumKilobytes" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumKilobytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumKilobytes { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumKilobytes : int64 with get, set" Usage="System.Diagnostics.EventLog.MaximumKilobytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или устанавливает максимальный размер журнала событий в килобайтах.</summary>
        <value>Максимальный размер журнала событий в килобайтах. Значение по умолчанию — 512, что означает максимальный размер файла 512 килобайт.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog.MaximumKilobytes%2A> Свойство представляет предельный размер файла журнала событий. Когда журнал событий достигает предельного размера, настроенное <xref:System.Diagnostics.EventLog.OverflowAction%2A> значение определяет, отбрасываются ли новые записи или перезаписывается ли новые записи более старых.  
  
> [!NOTE]
>  Это свойство представляет параметр конфигурации для журнала событий, представленного этим экземпляром. Когда журнал событий достигает максимального размера, это свойство указывает, как операционная система обрабатывает новые записи, записанные всеми источниками событий, зарегистрированными для журнала событий.  
  
   
  
## Examples  
 В следующем примере перечисляются журналы событий, определенные на локальном компьютере, и отображаются сведения о конфигурации для каждого журнала событий.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Указанное значение меньше 64 или больше 4194240 или не кратно 64.</exception>
        <exception cref="T:System.InvalidOperationException">Значение параметра <see cref="P:System.Diagnostics.EventLog.Log" /> является недопустимым именем журнала.  
  
- или - 
Раздел реестра для журнала событий не может быть открыт на конечном компьютере.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для администрирования сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="MinimumRetentionDays">
      <MemberSignature Language="C#" Value="public int MinimumRetentionDays { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MinimumRetentionDays" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MinimumRetentionDays As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MinimumRetentionDays { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MinimumRetentionDays : int" Usage="System.Diagnostics.EventLog.MinimumRetentionDays" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает количество дней, которое записи хранятся в журнале событий.</summary>
        <value>Количество дней, которое записи хранятся в журнале событий. Значение по умолчанию — 7.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> Используйте свойство для проверки текущего значения для журнала событий. Используйте <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> , чтобы изменить минимальное число дней, в течение которых должна храниться каждая запись в журнале событий.  
  
 Это <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> значение зависит от настроенного поведения переполнения журнала событий. Если для <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>свойства журнала событий задано <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> значение, то оно равно 0. <xref:System.Diagnostics.OverflowAction> Если для <xref:System.Diagnostics.OverflowAction.DoNotOverwrite>свойства журнала событий задано <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> значение, то значением является-1. <xref:System.Diagnostics.OverflowAction> Если свойство для журнала событий имеет <xref:System.Diagnostics.OverflowAction.OverwriteOlder>значение, <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> то оно больше нуля и представляет число дней, в течение которых должны храниться записи журнала событий, когда журнал событий заполнен. <xref:System.Diagnostics.OverflowAction>  
  
 Поведение переполнения происходит только при достижении предельного размера журнала событий. Если свойство <xref:System.Diagnostics.EventLog> <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> имеет <xref:System.Diagnostics.EventLog.OverflowAction%2A> значение <xref:System.Diagnostics.OverflowAction.OverwriteOlder> , а журнал событий достигает максимального размера, новые записи записываются только в том случае, если они могут заменить записи, возраст которых превышает период. Сохранение записей событий в течение минимального периода допустимо, если журнал событий архивируется регулярно. В противном случае вы рискуете потерять новые записи при достижении предельного размера журнала событий. Чтобы избежать потери новых сведений о событиях, установите минимальные дни хранения для событий в зависимости от расписания архивации для определенного журнала событий.  
  
   
  
## Examples  
 В следующем примере перечисляются журналы событий, определенные на локальном компьютере, и отображаются сведения о конфигурации для каждого журнала событий.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">для администрирования сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
      </Docs>
    </Member>
    <Member MemberName="ModifyOverflowPolicy">
      <MemberSignature Language="C#" Value="public void ModifyOverflowPolicy (System.Diagnostics.OverflowAction action, int retentionDays);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ModifyOverflowPolicy(valuetype System.Diagnostics.OverflowAction action, int32 retentionDays) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ModifyOverflowPolicy (action As OverflowAction, retentionDays As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ModifyOverflowPolicy(System::Diagnostics::OverflowAction action, int retentionDays);" />
      <MemberSignature Language="F#" Value="member this.ModifyOverflowPolicy : System.Diagnostics.OverflowAction * int -&gt; unit" Usage="eventLog.ModifyOverflowPolicy (action, retentionDays)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Diagnostics.OverflowAction" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="retentionDays" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="action">Поведение при внесении новых записей в журнал событий в случае переполнения.</param>
        <param name="retentionDays">Минимальное количество дней, которое будет храниться каждая запись журнала событий. Этот параметр используется только в том случае, если значение <paramref name="action" /> равно <see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" />.</param>
        <summary>Изменяет поведение при внесении новых записей, когда файл журнала событий достигает максимального размера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поведение переполнения для журнала событий указывает, что происходит при записи новых записей в журнал, достиг максимального размера файла.  
  
> [!NOTE]
>  Поведение переполнения вступает в силу только в том случае, если размер файла журнала событий достигнет максимального размера. Поведение переполнения не влияет на запись новой записи в журнал, который может разместить дополнительные записи журнала событий.  
  
 <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> Метод настраивает поведение переполнения журнала событий. <xref:System.Diagnostics.EventLog>вхождение. После вызова этого метода для журнала событий <xref:System.Diagnostics.EventLog.Log%2A> <xref:System.Diagnostics.EventLog.OverflowAction%2A> , указанного свойством, значения свойств и <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> отражать только что настроенное поведение переполнения.  
  
> [!NOTE]
>  Это свойство представляет параметр конфигурации для журнала событий, представленного этим экземпляром. Когда журнал событий достигает максимального размера, это свойство указывает, как операционная система обрабатывает новые записи, записанные всеми источниками событий, зарегистрированными для журнала событий.  
  
 Задайте для `action` <xref:System.Diagnostics.EventLog> параметра значение, чтобы указать, что новая запись перезаписывает самую старую запись, когда достигается <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>  ее максимальный размер. Если параметр имеет <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>значение, `retentionDays` значение параметра игнорируется. `action`  
  
 Задайте для `action` <xref:System.Diagnostics.EventLog> параметра значение, чтобы указать, что каждая новая запись перезаписывает старые записи при достижении <xref:System.Diagnostics.OverflowAction.OverwriteOlder>  максимального размера. Укажите число дней, в течение которых события должны храниться в журнале с помощью `retentionDays` параметра. События, записанные в пределах диапазона хранения, не перезаписываются новыми записями.  
  
 Задайте для `action` <xref:System.Diagnostics.OverflowAction.DoNotOverwrite> параметра значение, чтобы отменить новые события по достижении максимального размера журнала. Если параметр имеет <xref:System.Diagnostics.OverflowAction.DoNotOverwrite>значение, `retentionDays` значение параметра игнорируется. `action`  
  
> [!CAUTION]
>  Задание политики <xref:System.Diagnostics.OverflowAction.DoNotOverwrite> переполнения указывает, что новые записи будут удалены при заполнении журнала событий. При использовании этого параметра необходимо, чтобы журнал событий был регулярно архивирован и сброшен, чтобы не допустить достижения максимального размера.  
  
   
  
## Examples  
 В следующем примере выводится настроенная политика переполнения для указанного журнала событий, которая позволяет пользователю выбрать новый параметр политики переполнения для журнала событий.  
  
 [!code-cpp[EventLogProperties#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#3)]
 [!code-csharp[EventLogProperties#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#3)]
 [!code-vb[EventLogProperties#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="action" /> не является допустимым значением <see cref="P:System.Diagnostics.EventLog.OverflowAction" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="retentionDays" /> меньше 1 или больше 365.</exception>
        <exception cref="T:System.InvalidOperationException">Значение параметра <see cref="P:System.Diagnostics.EventLog.Log" /> является недопустимым именем журнала.  
  
- или - 
Раздел реестра для журнала событий не может быть открыт на конечном компьютере.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для администрирования сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      </Docs>
    </Member>
    <Member MemberName="OverflowAction">
      <MemberSignature Language="C#" Value="public System.Diagnostics.OverflowAction OverflowAction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.OverflowAction OverflowAction" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.OverflowAction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OverflowAction As OverflowAction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::OverflowAction OverflowAction { System::Diagnostics::OverflowAction get(); };" />
      <MemberSignature Language="F#" Value="member this.OverflowAction : System.Diagnostics.OverflowAction" Usage="System.Diagnostics.EventLog.OverflowAction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.OverflowAction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает поведение при переполнении для хранения новых записей, когда файл журнала событий достигает максимального размера.</summary>
        <value>Значение <see cref="T:System.Diagnostics.OverflowAction" />, которое определяет поведение при переполнении для хранения новых записей, когда файл журнала событий достигает максимального размера. Значение по умолчанию — <see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Размер журналов событий увеличивается по мере записи новых событий. Каждый журнал событий имеет настроенный максимальный размер. <xref:System.Diagnostics.EventLog.MaximumKilobytes%2A> свойство определяет максимальное количество килобайтов, допустимое для размера файла журнала событий.  
  
 Используйте значение <xref:System.Diagnostics.EventLog.OverflowAction%2A> свойства, чтобы проверить настроенное поведение переполнения для журнала событий с максимальным размером. <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> Используйте метод, чтобы изменить поведение переполнения для журнала событий.  
  
> [!NOTE]
>  Поведение переполнения вступает в силу только в том случае, если размер файла журнала событий достигнет максимального размера. Поведение переполнения не влияет на запись новой записи в журнал, который может разместить дополнительные записи журнала событий.  
  
   
  
## Examples  
 В следующем примере перечисляются журналы событий, определенные на локальном компьютере, и отображаются сведения о конфигурации для каждого журнала событий.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">для администрирования сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
        <altmember cref="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      </Docs>
    </Member>
    <Member MemberName="RegisterDisplayName">
      <MemberSignature Language="C#" Value="public void RegisterDisplayName (string resourceFile, long resourceId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterDisplayName(string resourceFile, int64 resourceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterDisplayName (resourceFile As String, resourceId As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterDisplayName(System::String ^ resourceFile, long resourceId);" />
      <MemberSignature Language="F#" Value="member this.RegisterDisplayName : string * int64 -&gt; unit" Usage="eventLog.RegisterDisplayName (resourceFile, resourceId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceFile" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="resourceId" Type="System.Int64" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="resourceFile">Полный путь к локализованному файлу ресурсов.</param>
        <param name="resourceId">Идентификатор ресурса, который индексирует локализованную строку в файле ресурсов.</param>
        <summary>Определяет локализованное имя для журнала событий, которое отображается в "Просмотре событий" сервера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Diagnostics.EventLog.RegisterDisplayName%2A> для регистрации и вывода локализованного имени в Просмотр событий для пользовательских журналов событий.  
  
 Указанный идентификатор ресурса должен соответствовать локализованной строке, определенной в файле ресурсов. Просмотр событий отображает имя пользовательского журнала событий, используя локализованную строку и текущие параметры языка и региональных параметров. Например, можно определить несколько имен журналов событий, локализованных для различных языков и региональных параметров в файле ресурсов. Просмотр событий отображает локализованную строку, соответствующую параметрам языка и региональных параметров текущего пользователя.  
  
 Если Просмотр событий не может загрузить локализованную строку из файла ресурсов или если отображаемое имя не зарегистрировано для журнала событий, Просмотр событий отображает имя журнала событий, определенное в <xref:System.Diagnostics.EventLog.Log%2A>.  
  
> [!NOTE]
>  Для предварительно определенных журналов событий не нужно регистрировать отображаемое имя. Операционная система регистрирует локализованные отображаемые имена для журналов событий приложений, систем и безопасности.  
  
   
  
## Examples  
 В следующем примере определяется, зарегистрирован ли источник событий `SampleApplicationSource` с именем на локальном компьютере. Если источник событий не существует, в примере задается файл ресурса сообщения для источника и создается новый источник событий. Наконец, в примере задается локализованное отображаемое имя для журнала событий с использованием значения идентификатора ресурса `DisplayNameMsgId` в и пути к файлу ресурса `messageFile`в.  
  
 [!code-cpp[EventLog_WriteEvent#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog_WriteEvent#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog_WriteEvent#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 В примере используется следующий текстовый файл сообщения, встроенный в библиотеку ресурсов Евентлогмсгс. dll. Текстовый файл сообщения — это источник, из которого создается файл ресурсов сообщения. В текстовом файле сообщения определяются идентификаторы ресурсов и текст для категории, сообщения о событии и строки вставки параметров. В частности, идентификатор ресурса 5001 определен для локализованного имени журнала событий.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Значение параметра <see cref="P:System.Diagnostics.EventLog.Log" /> является недопустимым именем журнала.  
  
- или - 
Раздел реестра для журнала событий не может быть открыт на конечном компьютере.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="resourceFile" /> имеет значение <see langword="null" />.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для администрирования сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.LogDisplayName" />
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public string Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Source" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Source { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : string with get, set" Usage="System.Diagnostics.EventLog.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The application name that writes the log.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogSource")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает имя источника, регистрируемого в журнале и используемого при записи в журнал событий.</summary>
        <value>Имя, регистрируемое в журнале событий как имя источника записей. Значение по умолчанию — пустая строка ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Источник события указывает, в каком журнале регистрируется событие. Часто это имя приложения или имя подкомпонента приложения, если приложение велико. Приложения и службы должны записывать в журнал приложений или пользовательский журнал. Драйверы устройств должны записывать в системный журнал.  
  
 При записи в журнал событий необходимо указывать только источник событий. Перед записью записи в журнал событий необходимо зарегистрировать источник событий в журнале событий в качестве допустимого источника событий. При написании записи журнала система использует <xref:System.Diagnostics.EventLog.Source%2A> свойство для поиска соответствующего журнала, в котором будет размещена запись. При чтении журнала событий можно указать <xref:System.Diagnostics.EventLog.Source%2A>либо, <xref:System.Diagnostics.EventLog.Log%2A> либо и <xref:System.Diagnostics.EventLog.MachineName%2A>.  
  
> [!NOTE]
>  При подключении к журналу на локальном <xref:System.Diagnostics.EventLog.MachineName%2A> компьютере указывать параметр не требуется. Если не указать <xref:System.Diagnostics.EventLog.MachineName%2A>, предполагается, что используется локальный компьютер (".").  
  
 Используйте <xref:System.Diagnostics.EventLog.WriteEvent%2A> и <xref:System.Diagnostics.EventLog.WriteEntry%2A>  для записи событий в журнал событий. Для записи событий необходимо указать источник события. перед записью первой записи с источником необходимо создать и настроить источник события.  
  
 Создайте новый источник событий во время установки приложения. Это позволяет операционной системе обновлять свой список зарегистрированных источников событий и их конфигурацию. Если операционная система не обновила список источников событий и вы пытаетесь написать событие с новым источником, операция записи завершится ошибкой. Новый источник можно настроить с помощью <xref:System.Diagnostics.EventLogInstaller>или <xref:System.Diagnostics.EventLog.CreateEventSource%2A> с помощью метода. Для создания нового источника событий необходимо иметь права администратора на компьютере.  
  
 Можно создать источник событий для существующего журнала событий или нового журнала событий. При создании нового источника для нового журнала событий система регистрирует источник для этого журнала, но журнал не создается, пока в него не будет записана первая запись.  
  
 Источник должен быть уникальным на локальном компьютере; новое имя источника не может совпадать с существующим именем источника или именем существующего журнала событий. Каждый источник может записывать только один журнал событий; Однако приложение может использовать несколько источников для записи в несколько журналов событий. Например, приложению может потребоваться несколько источников, настроенных для различных журналов событий или разных файлов ресурсов.  
  
 При изменении <xref:System.Diagnostics.EventLog.Source%2A> значения закрывается объект <xref:System.Diagnostics.EventLog> , в который он зарегистрирован, и освобождаются все дескрипторы событий.  
  
 Источник должен быть настроен либо для записи локализованных записей, либо для записи прямых строк. Если приложение записывает записи, используя как идентификаторы ресурсов, так и строковые значения, необходимо зарегистрировать два отдельных источника. Например, можно настроить один источник с файлами ресурсов, а затем использовать этот источник в <xref:System.Diagnostics.EventLog.WriteEvent%2A> методе для записи записей, использующих идентификаторы ресурсов, в журнал событий. Затем создайте другой источник без файлов ресурсов и используйте этот источник в <xref:System.Diagnostics.EventLog.WriteEntry%2A> методе для записи строк непосредственно в журнал событий с помощью этого источника.  
  
 Чтобы изменить сведения о конфигурации существующего источника, необходимо удалить источник, а затем создать его с новой конфигурацией. Если другие приложения или компоненты используют существующий источник, создайте новый источник с обновленной конфигурацией, а не удалите существующий источник.  
  
> [!NOTE]
>  Если источник уже сопоставлен с журналом и вы переменяете его в новый журнал, необходимо перезагрузить компьютер, чтобы изменения вступили в силу.  
  
   
  
## Examples  
 В следующем примере создается источник `MySource` , если он еще не существует, и записывается запись в журнал `MyNewLog`событий.  
  
 [!code-cpp[Classic EventLog.Source Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">При таком имени источника длина пути к разделу реестра превышает 254 символа.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SourceExists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет поиск заданного источника событий в реестре компьютера.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SourceExists (source As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SourceExists(System::String ^ source);" />
      <MemberSignature Language="F#" Value="static member SourceExists : string -&gt; bool" Usage="System.Diagnostics.EventLog.SourceExists source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Имя источника событий.</param>
        <summary>Определяет, зарегистрирован ли источник событий на локальном компьютере.</summary>
        <returns>Значение <see langword="true" />, если источник событий зарегистрирован на локальном компьютере; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод, чтобы определить, существует ли источник событий на локальном компьютере. Если необходимо определить, существует ли журнал на локальном компьютере, используйте <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
 Поскольку этот метод обращается к реестру, необходимо иметь соответствующие разрешения на доступ к реестру на локальном компьютере. в противном случае будет выдано исключение. <xref:System.Security.SecurityException>  
  
> [!NOTE]
>  Для поиска источника событий в Windows Vista и более поздних версиях или Windows Server 2003 необходимо иметь права администратора.  
>   
>  Причина этого требования заключается в том, что необходимо выполнить поиск всех журналов событий, включая систему безопасности, чтобы определить, является ли источник события уникальным. Начиная с Windows Vista, пользователи не имеют разрешения на доступ к журналу безопасности; <xref:System.Security.SecurityException> поэтому создается исключение.  
>   
>  Начиная с Windows Vista, привилегии пользователя определяются контролем учетных записей (UAC). Члену встроенной группы "Администраторы" присваивается два маркера доступа на время выполнения: маркер доступа обычного пользователя и маркер доступа администратора. По умолчанию назначена роль обычного пользователя. Чтобы выполнить код, обращающийся к счетчикам производительности, необходимо сначала повысить привилегии обычного пользователя до администратора. Это можно сделать при запуске приложения, , щелкнув значок приложения правой кнопкой мыши и указав, что приложение должно запускаться от имени администратора.  
  
> [!NOTE]
>  У службы, выполняющейся под <xref:System.ServiceProcess.ServiceAccount.LocalSystem> учетной записью, нет прав, необходимых для выполнения этого метода. Решение заключается в том <xref:System.ServiceProcess.ServiceInstaller>, чтобы проверить, существует ли источник событий в, и если он не существует, для создания источника в установщике.  
  
 Поскольку нельзя присвоить новому источнику имя существующего источника на том же компьютере, используйте этот метод перед попыткой вызова <xref:System.Diagnostics.EventLog.CreateEventSource%2A> , чтобы убедиться, что источник с именем, `source` указанным в, еще не существует на локальном компьютере. `source` Параметр не учитывает регистр.  
  
   
  
## Examples  
 В следующем примере создается источник `MySource` , если он еще не существует, и записывается запись в журнал `MyNewLog`событий.  
  
 [!code-cpp[Classic EventLog.Source Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><paramref name="source" /> не найден, но поиск некоторых или всех журналов событий не был произведен.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
      </Docs>
    </Member>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SourceExists (source As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SourceExists(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member SourceExists : string * string -&gt; bool" Usage="System.Diagnostics.EventLog.SourceExists (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Имя источника событий.</param>
        <param name="machineName">Имя компьютера, на котором выполняется поиск, или значение ".", если используется локальный компьютер.</param>
        <summary>Определяет, зарегистрирован ли источник событий на указанном компьютере.</summary>
        <returns>Значение <see langword="true" />, если источник событий зарегистрирован на заданном компьютере; в противном случае — значение <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод, чтобы определить, существует ли источник событий на компьютере, указанном `machineName` параметром. Если необходимо определить, существует ли журнал на указанном компьютере, используйте <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
 Поскольку этот метод обращается к реестру, необходимо иметь соответствующие разрешения на доступ к реестру на данном сервере. в противном случае будет выдано исключение. <xref:System.Security.SecurityException>  
  
> [!NOTE]
>  Для поиска источника событий в Windows Vista и более поздних версиях или Windows Server 2003 необходимо иметь права администратора.  
>   
>  Причина этого требования заключается в том, что необходимо выполнить поиск всех журналов событий, включая систему безопасности, чтобы определить, является ли источник события уникальным. Начиная с Windows Vista, пользователи не имеют разрешения на доступ к журналу безопасности; <xref:System.Security.SecurityException> поэтому создается исключение.  
>   
>  Начиная с Windows Vista, привилегии пользователя определяются контролем учетных записей (UAC). Члену встроенной группы "Администраторы" присваивается два маркера доступа на время выполнения: маркер доступа обычного пользователя и маркер доступа администратора. По умолчанию назначена роль обычного пользователя. Чтобы выполнить код, обращающийся к счетчикам производительности, необходимо сначала повысить привилегии обычного пользователя до администратора. Это можно сделать при запуске приложения, , щелкнув значок приложения правой кнопкой мыши и указав, что приложение должно запускаться от имени администратора.  
  
> [!NOTE]
>  У службы, выполняющейся под <xref:System.ServiceProcess.ServiceAccount.LocalSystem> учетной записью, нет прав, необходимых для выполнения этого метода. Решение заключается в том <xref:System.ServiceProcess.ServiceInstaller>, чтобы проверить, существует ли источник событий в, и если он не существует, для создания источника в установщике.  
  
 Поскольку нельзя присвоить новому источнику имя существующего источника на том же компьютере, используйте этот метод перед попыткой вызова <xref:System.Diagnostics.EventLog.CreateEventSource%2A> , чтобы убедиться, что источник с именем, `source` указанным в, еще не существует на компьютере. Параметры `source` и `machineName`  не учитывают регистр.  
  
 <xref:System.Diagnostics.EventLog.SourceExists%2A>`static` метод является методом, поэтому его можно вызывать для самого класса. Нет необходимости создавать экземпляр <xref:System.Diagnostics.EventLog> для вызова. <xref:System.Diagnostics.EventLog.SourceExists%2A>  
  
   
  
## Examples  
 В следующем примере создается источник `MySource` на компьютере `MyServer`и записывается запись в журнал `MyNewLog`событий.  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="machineName" /> не является допустимым именем компьютера.</exception>
        <exception cref="T:System.Security.SecurityException"><paramref name="source" /> не найден, но поиск некоторых или всех журналов событий не был произведен.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Diagnostics.EventLog.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("An object that synchronizes event handler calls.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogSynchronizingObject")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает объект, используемый для маршалинга вызовов обработчика событий, возникающих в результате события записи в <see cref="T:System.Diagnostics.EventLog" />.</summary>
        <value>Объект <see cref="T:System.ComponentModel.ISynchronizeInvoke" />, используемый для маршалинга вызовов обработчика событий, возникающих в результате события записи <see cref="E:System.Diagnostics.EventLog.EntryWritten" /> в журнал событий.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> имеет `null`значение, методы, <xref:System.Diagnostics.EventLog.EntryWritten> обрабатывающие событие, вызываются в потоке из пула системных потоков. Дополнительные сведения о пулах системных потоков см. в <xref:System.Threading.ThreadPool>разделе.  
  
 <xref:System.Diagnostics.EventLog.EntryWritten> Если событие обрабатывается компонентом Visual Windows Forms, например кнопкой, доступ к компоненту через пул системных потоков может не работать или может привести к исключению. Это следует избегать, <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> если задать компоненту Windows Forms, в результате чего методы, <xref:System.Diagnostics.EventLog.EntryWritten> обрабатывающие событие, вызываются в том же потоке, в котором был создан компонент.  
  
 Если используется внутри [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] в конструкторе Windows Forms, <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> автоматически задается элемент управления, содержащий  <xref:System.Diagnostics.EventLog> .  <xref:System.Diagnostics.EventLog> Например <xref:System.Diagnostics.EventLog> , при помещении в конструктор для Form1 (который наследуется от <xref:System.Windows.Forms.Form>) <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> свойство объекта <xref:System.Diagnostics.EventLog> задается экземпляром Form1.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="E:System.Diagnostics.EventLog.EntryWritten" />
        <altmember cref="T:System.Threading.ThreadPool" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEntry">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Вносит запись в журнал событий.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string -&gt; unit" Usage="eventLog.WriteEntry message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Строка для записи в журнал событий.</param>
        <summary>Вносит в журнал событий запись сведений с заданным текстом сообщения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется для записи информации в журнал событий, связанный с данным <xref:System.Diagnostics.EventLog> экземпляром. Если вы хотите указать <xref:System.Diagnostics.EventLogEntryType>другое, используйте другую <xref:System.Diagnostics.EventLog.WriteEntry%2A>перегрузку.  
  
> [!NOTE]
>  Строка не может содержать%*n*, где n является целочисленным значением (например,% 1), так как средство просмотра событий обрабатывает его как строку вставки. ** `message` Так как адрес протокола IP версии 6 (IPv6) может содержать эту последовательность символов, нельзя заносить в журнал сообщение о событии, содержащее IPv6-адрес.  
  
 Необходимо задать <xref:System.Diagnostics.EventLog.Source%2A> свойство <xref:System.Diagnostics.EventLog> для компонента, прежде чем можно будет записывать записи в журнал. Перед записью первой записи с источником необходимо создать и настроить источник события.  
  
 Создайте новый источник событий во время установки приложения. Это позволяет операционной системе обновлять свой список зарегистрированных источников событий и их конфигурацию. Если операционная система не обновила список источников событий и вы пытаетесь написать событие с новым источником, операция записи завершится ошибкой. Новый источник можно настроить с помощью <xref:System.Diagnostics.EventLogInstaller>или <xref:System.Diagnostics.EventLog.CreateEventSource%2A> с помощью метода. Для создания нового источника событий необходимо иметь права администратора на компьютере.  
  
 Если источник <xref:System.Diagnostics.EventLog.Source%2A> , указанный в свойстве этого <xref:System.Diagnostics.EventLog> экземпляра, не зарегистрирован на компьютере, в который записывается компонент, <xref:System.Diagnostics.EventLog.WriteEntry%2A> вызывает <xref:System.Diagnostics.EventLog.CreateEventSource%2A> и регистрирует источник.  
  
> [!NOTE]
>  Если <xref:System.Diagnostics.EventLog.MachineName%2A> не указать <xref:System.Diagnostics.EventLog> для экземпляра перед вызовом <xref:System.Diagnostics.EventLog.CreateEventSource%2A> или <xref:System.Diagnostics.EventLog.WriteEntry%2A>, предполагается, что используется локальный компьютер (".").  
  
 Если системе необходимо зарегистрировать <xref:System.Diagnostics.EventLog.Source%2A> с помощью <xref:System.Diagnostics.EventLog.WriteEntry%2A> вызова метода и <xref:System.Diagnostics.EventLog.Log%2A> свойство не было задано в <xref:System.Diagnostics.EventLog> экземпляре, по умолчанию используется журнал приложения.  
  
> [!NOTE]
>  Многие из перечисленных выше исключений создаются ошибками, возникающими в процессе регистрации <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 Источник должен быть настроен либо для записи локализованных записей, либо для записи прямых строк. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Метод записывает заданную строку непосредственно в журнал событий. она не использует файл ресурсов локализуемого сообщения. <xref:System.Diagnostics.EventLog.WriteEvent%2A> Используйте метод для записи событий с помощью файла ресурсов локализованного сообщения.  
  
 Если приложение записывает записи, используя как идентификаторы ресурсов, так и строковые значения, необходимо зарегистрировать два отдельных источника. Например, можно настроить один источник с файлами ресурсов, а затем использовать этот источник в <xref:System.Diagnostics.EventLog.WriteEvent%2A> методе для записи записей, использующих идентификаторы ресурсов, в журнал событий. Затем создайте другой источник без файлов ресурсов и используйте этот источник в <xref:System.Diagnostics.EventLog.WriteEntry%2A> методе для записи строк непосредственно в журнал событий с помощью этого источника.  
  
> [!NOTE]
>  При записи записи на удаленный компьютер значение сообщения (текстовая строка) может отличаться от предполагаемого, если на удаленном компьютере не выполняется .NET Framework.  
  
> [!NOTE]
>  `message` Если параметр содержит символ NUL, сообщение в журнале событий заканчивается символом NUL.  
  
   
  
## Examples  
 В следующем примере создается источник `MySource` , если он еще не существует, и записывается запись в журнал `MyNewLog`событий.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Не задано свойство <see cref="P:System.Diagnostics.EventLog.Source" /> класса <see cref="T:System.Diagnostics.EventLog" />.  
  
-или- 
Метод пытается зарегистрировать новый источник событий, но имя компьютера в <see cref="P:System.Diagnostics.EventLog.MachineName" /> является недопустимым.  
  
-или- 
Источник уже зарегистрирован для различных журналов событий.  
  
-или- 
Строка сообщения превышает 31,839 байт (32,766 байт в операционных системах Windows до Windows Vista).  
  
- или - 
При таком имени источника длина пути к разделу реестра превышает 254 символа.</exception>
        <exception cref="T:System.InvalidOperationException">Не удается открыть раздел реестра для журнала событий.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Операционная система сообщила об ошибке при записи сведений о событии в журнал событий. Код ошибки Windows недоступен.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType -&gt; unit" Usage="eventLog.WriteEntry (message, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="message">Строка для записи в журнал событий.</param>
        <param name="type">Одно из значений перечисления <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <summary>Вносит в журнал событий следующие записи с заданным текстом сообщения: ошибка, предупреждение, сведения, аудит отказов или аудит успехов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется для записи указанного <xref:System.Diagnostics.EventLogEntryType> элемента в журнал событий. `type` Указывает на значок и текст в столбце Тип в Просмотр событий для журнала.  
  
> [!NOTE]
>  Строка не может содержать%*n*, где n является целочисленным значением (например,% 1), так как средство просмотра событий обрабатывает его как строку вставки. ** `message` Так как адрес протокола IP версии 6 (IPv6) может содержать эту последовательность символов, нельзя заносить в журнал сообщение о событии, содержащее IPv6-адрес.  
  
 Необходимо задать <xref:System.Diagnostics.EventLog.Source%2A> свойство <xref:System.Diagnostics.EventLog> для компонента, прежде чем можно будет записывать записи в журнал. Перед записью первой записи с источником необходимо создать и настроить источник события.  
  
 Создайте новый источник событий во время установки приложения. Это позволяет операционной системе обновлять свой список зарегистрированных источников событий и их конфигурацию. Если операционная система не обновила список источников событий и вы пытаетесь написать событие с новым источником, операция записи завершится ошибкой. Новый источник можно настроить с помощью <xref:System.Diagnostics.EventLogInstaller>или <xref:System.Diagnostics.EventLog.CreateEventSource%2A> с помощью метода. Для создания нового источника событий необходимо иметь права администратора на компьютере.  
  
 Если источник <xref:System.Diagnostics.EventLog.Source%2A> , указанный в свойстве этого <xref:System.Diagnostics.EventLog> экземпляра, не зарегистрирован на компьютере, в который записывается компонент, <xref:System.Diagnostics.EventLog.WriteEntry%2A> вызывает <xref:System.Diagnostics.EventLog.CreateEventSource%2A> и регистрирует источник.  
  
> [!NOTE]
>  Если <xref:System.Diagnostics.EventLog.MachineName%2A> не указать <xref:System.Diagnostics.EventLog> для экземпляра перед вызовом <xref:System.Diagnostics.EventLog.CreateEventSource%2A> или <xref:System.Diagnostics.EventLog.WriteEntry%2A>, предполагается, что используется локальный компьютер (".").  
  
 Если системе необходимо зарегистрировать <xref:System.Diagnostics.EventLog.Source%2A> с помощью <xref:System.Diagnostics.EventLog.WriteEntry%2A> вызова метода и <xref:System.Diagnostics.EventLog.Log%2A> свойство не было задано в <xref:System.Diagnostics.EventLog> экземпляре, по умолчанию используется журнал приложения.  
  
> [!NOTE]
>  Многие исключения, перечисленные выше, генерируются ошибками, возникающими в процессе <xref:System.Diagnostics.EventLog.Source%2A>регистрации.  
  
 Источник должен быть настроен либо для записи локализованных записей, либо для записи прямых строк. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Метод записывает заданную строку непосредственно в журнал событий. она не использует файл ресурсов локализуемого сообщения. <xref:System.Diagnostics.EventLog.WriteEvent%2A> Используйте метод для записи событий с помощью файла ресурсов локализованного сообщения.  
  
 Если приложение записывает записи, используя как идентификаторы ресурсов, так и строковые значения, необходимо зарегистрировать два отдельных источника. Например, можно настроить один источник с файлами ресурсов, а затем использовать этот источник в <xref:System.Diagnostics.EventLog.WriteEvent%2A> методе для записи записей, использующих идентификаторы ресурсов, в журнал событий. Затем создайте другой источник без файлов ресурсов и используйте этот источник в <xref:System.Diagnostics.EventLog.WriteEntry%2A> методе для записи строк непосредственно в журнал событий с помощью этого источника.  
  
> [!NOTE]
>  При записи записи на удаленный компьютер значение сообщения (текстовая строка) может отличаться от предполагаемого, если на удаленном компьютере не выполняется .NET Framework.  
  
> [!NOTE]
>  `message` Если параметр содержит символ NUL, сообщение в журнале событий заканчивается символом NUL.  
  
   
  
## Examples  
 В следующем примере запись предупреждения записывается в журнал событий MyNewLog на локальном компьютере.  
  
 [!code-cpp[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Не задано свойство <see cref="P:System.Diagnostics.EventLog.Source" /> класса <see cref="T:System.Diagnostics.EventLog" />.  
  
- или - 
Метод пытается зарегистрировать новый источник событий, но имя компьютера в <see cref="P:System.Diagnostics.EventLog.MachineName" /> является недопустимым.  
  
- или - 
Источник уже зарегистрирован для различных журналов событий.  
  
-или- 
Строка сообщения превышает 31,839 байт (32,766 байт в операционных системах Windows до Windows Vista).  
  
-или- 
При таком имени источника длина пути к разделу реестра превышает 254 символа.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> не является допустимым <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.InvalidOperationException">Не удается открыть раздел реестра для журнала событий.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Операционная система сообщила об ошибке при записи сведений о событии в журнал событий. Код ошибки Windows недоступен.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Источник, по которому приложение регистрируется на указанном компьютере.</param>
        <param name="message">Строка для записи в журнал событий.</param>
        <summary>Вносит в журнал событий запись сведений с заданным текстом сообщения, используя указанный зарегистрированный источник.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для записи информации в журнал событий с помощью источника, который уже зарегистрирован в качестве источника события для соответствующего журнала. Если вы хотите указать <xref:System.Diagnostics.EventLogEntryType>другое, используйте другую <xref:System.Diagnostics.EventLog.WriteEntry%2A>перегрузку.  
  
 Перед записью первой записи с источником необходимо создать и настроить источник события. Создайте новый источник событий во время установки приложения. Это позволяет операционной системе обновлять свой список зарегистрированных источников событий и их конфигурацию. Если операционная система не обновила список источников событий и вы пытаетесь написать событие с новым источником, операция записи завершится ошибкой. Новый источник можно настроить с помощью <xref:System.Diagnostics.EventLogInstaller>или <xref:System.Diagnostics.EventLog.CreateEventSource%2A> с помощью метода. Для создания нового источника событий необходимо иметь права администратора на компьютере.  
  
 Источник должен быть настроен либо для записи локализованных записей, либо для записи прямых строк. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Метод записывает заданную строку непосредственно в журнал событий. она не использует файл ресурсов локализуемого сообщения. <xref:System.Diagnostics.EventLog.WriteEvent%2A> Используйте метод для записи событий с помощью файла ресурсов локализованного сообщения.  
  
 Если приложение записывает записи, используя как идентификаторы ресурсов, так и строковые значения, необходимо зарегистрировать два отдельных источника. Например, можно настроить один источник с файлами ресурсов, а затем использовать этот источник в <xref:System.Diagnostics.EventLog.WriteEvent%2A> методе для записи записей, использующих идентификаторы ресурсов, в журнал событий. Затем создайте другой источник без файлов ресурсов и используйте этот источник в <xref:System.Diagnostics.EventLog.WriteEntry%2A> методе для записи строк непосредственно в журнал событий с помощью этого источника.  
  
> [!NOTE]
>  `message` Если параметр содержит символ NUL, сообщение в журнале событий заканчивается символом NUL.  
>   
>  Строка не может содержать%*n*, где n является целочисленным значением (например,% 1), так как средство просмотра событий обрабатывает его как строку вставки. ** `message` Так как адрес протокола IP версии 6 (IPv6) может содержать эту последовательность символов, нельзя заносить в журнал сообщение о событии, содержащее IPv6-адрес.  
  
   
  
## Examples  
 В следующем примере создается источник `MySource` , если он еще не существует, и записывается запись в журнал `MyNewLog`событий.  
  
 [!code-cpp[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значением <paramref name="source" /> является пустая строка ("").  
  
- или - 
Значение <paramref name="source" /> равно <see langword="null" />.  
  
-или- 
Строка сообщения превышает 31,839 байт (32,766 байт в операционных системах Windows до Windows Vista).  
  
-или- 
При таком имени источника длина пути к разделу реестра превышает 254 символа.</exception>
        <exception cref="T:System.InvalidOperationException">Не удается открыть раздел реестра для журнала событий.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Операционная система сообщила об ошибке при записи сведений о событии в журнал событий. Код ошибки Windows недоступен.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="message">Строка для записи в журнал событий.</param>
        <param name="type">Одно из значений <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <param name="eventID">Идентификатор для события, зависящий от приложения.</param>
        <summary>Вносит в журнал событий запись с заданным текстом сообщения и идентификатором события, который определяется приложением.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для записи записи с приложением, определенным `eventID` в журнале событий. `eventID` Вместе с источником уникально идентифицирует событие. Каждое приложение может определять собственные нумерованные события и строки описания, с которыми они сопоставляются. Средства просмотра событий отображают эти строковые значения, чтобы помочь пользователю понять, что пошло не так, и предложить, какие действия следует предпринять.  
  
> [!NOTE]
>  Строка не может содержать%*n*, где n является целочисленным значением (например,% 1), так как средство просмотра событий обрабатывает его как строку вставки. ** `message` Так как адрес протокола IP версии 6 (IPv6) может содержать эту последовательность символов, нельзя заносить в журнал сообщение о событии, содержащее IPv6-адрес.  
  
 В дополнение к идентификатору события можно указать <xref:System.Diagnostics.EventLogEntryType> для события, записываемого в журнал событий. `type` Указывает на значок и текст в столбце Тип в Просмотр событий для журнала. Этот параметр указывает, является ли тип события "ошибка", "предупреждение", "информация", "успех аудита" или "сбой аудита".  
  
 Необходимо задать <xref:System.Diagnostics.EventLog.Source%2A> свойство <xref:System.Diagnostics.EventLog> для компонента, прежде чем можно будет записывать записи в журнал. Перед записью первой записи с источником необходимо создать и настроить источник события.  
  
 Создайте новый источник событий во время установки приложения. Это позволяет операционной системе обновлять свой список зарегистрированных источников событий и их конфигурацию. Если операционная система не обновила список источников событий и вы пытаетесь написать событие с новым источником, операция записи завершится ошибкой. Новый источник можно настроить с помощью <xref:System.Diagnostics.EventLogInstaller>или <xref:System.Diagnostics.EventLog.CreateEventSource%2A> с помощью метода. Для создания нового источника событий необходимо иметь права администратора на компьютере.  
  
 Если источник <xref:System.Diagnostics.EventLog.Source%2A> , указанный в свойстве этого <xref:System.Diagnostics.EventLog> экземпляра, не зарегистрирован на компьютере, в который записывается компонент, <xref:System.Diagnostics.EventLog.WriteEntry%2A> вызывает <xref:System.Diagnostics.EventLog.CreateEventSource%2A> и регистрирует источник.  
  
> [!NOTE]
>  Если <xref:System.Diagnostics.EventLog.MachineName%2A> не указать <xref:System.Diagnostics.EventLog> для экземпляра перед вызовом <xref:System.Diagnostics.EventLog.CreateEventSource%2A> или <xref:System.Diagnostics.EventLog.WriteEntry%2A>, предполагается, что используется локальный компьютер (".").  
  
 Если системе необходимо зарегистрировать <xref:System.Diagnostics.EventLog.Source%2A> с помощью <xref:System.Diagnostics.EventLog.WriteEntry%2A> вызова метода и <xref:System.Diagnostics.EventLog.Log%2A> свойство не было задано в <xref:System.Diagnostics.EventLog> экземпляре, по умолчанию используется журнал приложения.  
  
> [!NOTE]
>  Многие исключения, перечисленные выше, генерируются ошибками, возникающими в процессе <xref:System.Diagnostics.EventLog.Source%2A>регистрации.  
  
 Источник должен быть настроен либо для записи локализованных записей, либо для записи прямых строк. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Метод записывает заданную строку непосредственно в журнал событий. она не использует файл ресурсов локализуемого сообщения. <xref:System.Diagnostics.EventLog.WriteEvent%2A> Используйте метод для записи событий с помощью файла ресурсов локализованного сообщения.  
  
 Если приложение записывает записи, используя как идентификаторы ресурсов, так и строковые значения, необходимо зарегистрировать два отдельных источника. Например, можно настроить один источник с файлами ресурсов, а затем использовать этот источник в <xref:System.Diagnostics.EventLog.WriteEvent%2A> методе для записи записей, использующих идентификаторы ресурсов, в журнал событий. Затем создайте другой источник без файлов ресурсов и используйте этот источник в <xref:System.Diagnostics.EventLog.WriteEntry%2A> методе для записи строк непосредственно в журнал событий с помощью этого источника.  
  
> [!NOTE]
>  При записи записи на удаленный компьютер значение сообщения (текстовая строка) может отличаться от предполагаемого, если на удаленном компьютере не выполняется .NET Framework.  
  
> [!NOTE]
>  `message` Если параметр содержит символ NUL, сообщение в журнале событий заканчивается символом NUL.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog_WriteEntry_1_3#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog_WriteEntry_1_3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Не задано свойство <see cref="P:System.Diagnostics.EventLog.Source" /> класса <see cref="T:System.Diagnostics.EventLog" />.  
  
- или - 
Метод пытается зарегистрировать новый источник событий, но имя компьютера в <see cref="P:System.Diagnostics.EventLog.MachineName" /> является недопустимым.  
  
-или- 
Источник уже зарегистрирован для различных журналов событий.  
  
- или - 
 <paramref name="eventID" /> меньше нуля или больше <see cref="F:System.UInt16.MaxValue" />.  
  
-или- 
Строка сообщения превышает 31,839 байт (32,766 байт в операционных системах Windows до Windows Vista).  
  
-или- 
При таком имени источника длина пути к разделу реестра превышает 254 символа.</exception>
        <exception cref="T:System.InvalidOperationException">Не удается открыть раздел реестра для журнала событий.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> не является допустимым <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Операционная система сообщила об ошибке при записи сведений о событии в журнал событий. Код ошибки Windows недоступен.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="source">Источник, по которому приложение регистрируется на указанном компьютере.</param>
        <param name="message">Строка для записи в журнал событий.</param>
        <param name="type">Одно из значений перечисления <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <summary>Вносит в журнал событий, используя указанный зарегистрированный источник, следующие записи с заданным текстом сообщения: ошибка, предупреждение, сведения, аудит отказов или аудит успехов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется для записи указанного <xref:System.Diagnostics.EventLogEntryType> элемента в журнал событий с использованием источника, уже зарегистрированного в качестве источника событий для соответствующего журнала. `type` Указывает на значок и текст в столбце Тип в Просмотр событий для журнала.  
  
> [!NOTE]
>  Строка не может содержать%*n*, где n является целочисленным значением (например,% 1), так как средство просмотра событий обрабатывает его как строку вставки. ** `message` Так как адрес протокола IP версии 6 (IPv6) может содержать эту последовательность символов, нельзя заносить в журнал сообщение о событии, содержащее IPv6-адрес.  
  
 Перед записью первой записи с источником необходимо создать и настроить источник события. Создайте новый источник событий во время установки приложения. Это позволяет операционной системе обновлять свой список зарегистрированных источников событий и их конфигурацию. Если операционная система не обновила список источников событий и вы пытаетесь написать событие с новым источником, операция записи завершится ошибкой. Новый источник можно настроить с помощью <xref:System.Diagnostics.EventLogInstaller>или <xref:System.Diagnostics.EventLog.CreateEventSource%2A> с помощью метода. Для создания нового источника событий необходимо иметь права администратора на компьютере.  
  
 Источник должен быть настроен либо для записи локализованных записей, либо для записи прямых строк. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Метод записывает заданную строку непосредственно в журнал событий. она не использует файл ресурсов локализуемого сообщения. <xref:System.Diagnostics.EventLog.WriteEvent%2A> Используйте метод для записи событий с помощью файла ресурсов локализованного сообщения.  
  
 Если приложение записывает записи, используя как идентификаторы ресурсов, так и строковые значения, необходимо зарегистрировать два отдельных источника. Например, можно настроить один источник с файлами ресурсов, а затем использовать этот источник в <xref:System.Diagnostics.EventLog.WriteEvent%2A> методе для записи записей, использующих идентификаторы ресурсов, в журнал событий. Затем создайте другой источник без файлов ресурсов и используйте этот источник в <xref:System.Diagnostics.EventLog.WriteEntry%2A> методе для записи строк непосредственно в журнал событий с помощью этого источника.  
  
> [!NOTE]
>  `message` Если параметр содержит символ NUL, сообщение в журнале событий заканчивается символом NUL.  
  
   
  
## Examples  
 В следующем примере запись предупреждения записывается в журнал событий MyNewLog на локальном компьютере.  
  
 [!code-cpp[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значением <paramref name="source" /> является пустая строка ("").  
  
-или- 
Значение <paramref name="source" /> равно <see langword="null" />.  
  
-или- 
Строка сообщения превышает 31,839 байт (32,766 байт в операционных системах Windows до Windows Vista).  
  
-или- 
При таком имени источника длина пути к разделу реестра превышает 254 символа.</exception>
        <exception cref="T:System.InvalidOperationException">Не удается открыть раздел реестра для журнала событий.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> не является допустимым <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Операционная система сообщила об ошибке при записи сведений о событии в журнал событий. Код ошибки Windows недоступен.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer, category As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int * int16 -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="message">Строка для записи в журнал событий.</param>
        <param name="type">Одно из значений перечисления <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <param name="eventID">Идентификатор для события, зависящий от приложения.</param>
        <param name="category">Подкатегория конкретного приложения, связанная с сообщением.</param>
        <summary>Вносит в журнал событий запись с заданным текстом сообщения, идентификатором события и категорией, которая определяется приложением.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для записи записи с приложением, определенным `category` в журнале событий. Просмотр событий использует категорию для фильтрации событий, записанных источником событий. Просмотр событий может отображать категорию в виде числового значения или использовать категорию в качестве идентификатора ресурса для вывода локализованной строки категории.  
  
> [!NOTE]
>  `category` Параметр должен быть положительным значением. Отрицательные значения категории отображаются в Просмотр событий с дополнительным положительным числом. Например,-10 отображается как 65 526, a – 1 как 65 535.  
  
> [!NOTE]
>  Строка не может содержать%*n*, где n является целочисленным значением (например,% 1), так как средство просмотра событий обрабатывает его как строку вставки. ** `message` Так как адрес протокола IP версии 6 (IPv6) может содержать эту последовательность символов, нельзя заносить в журнал сообщение о событии, содержащее IPv6-адрес.  
  
 Чтобы отобразить локализованные строки категории в Просмотр событий, необходимо использовать источник событий, настроенный с помощью файла ресурсов категории, и задать для `category` него идентификатор ресурса в файле ресурсов категории. Если источник событий не имеет настроенного файла ресурсов категории или указанный `category` объект не индексирует строку в файле ресурсов категории, то Просмотр событий отображает числовое значение категории для этой записи. Настройте файл ресурсов категории вместе с числом строк категории в файле ресурсов, используя <xref:System.Diagnostics.EventLogInstaller> <xref:System.Diagnostics.EventSourceCreationData> класс или.  
  
 В дополнение к категории можно указать идентификатор события для события, записываемого в журнал событий. Идентификаторы событий, а также источник событий однозначно идентифицируют событие. Каждое приложение может определять собственные нумерованные события и строки описания, с которыми они сопоставляются. Средства просмотра событий отображают эти строковые значения, чтобы помочь пользователю понять, что пошло не так, и предложить, какие действия следует предпринять.  
  
 Наконец, можно указать <xref:System.Diagnostics.EventLogEntryType> для события, записываемого в журнал событий. `type` Указывает на значок и текст в столбце Тип в Просмотр событий для журнала. Этот параметр указывает, является ли тип события "ошибка", "предупреждение", "информация", "успех аудита" или "сбой аудита".  
  
 Необходимо задать <xref:System.Diagnostics.EventLog.Source%2A> свойство <xref:System.Diagnostics.EventLog> для компонента, прежде чем можно будет записывать записи в журнал. Перед записью первой записи с источником необходимо создать и настроить источник события.  
  
 Создайте новый источник событий во время установки приложения. Это позволяет операционной системе обновлять свой список зарегистрированных источников событий и их конфигурацию. Если операционная система не обновила список источников событий и вы пытаетесь написать событие с новым источником, операция записи завершится ошибкой. Новый источник можно настроить с помощью <xref:System.Diagnostics.EventLogInstaller>или <xref:System.Diagnostics.EventLog.CreateEventSource%2A> с помощью метода. Для создания нового источника событий необходимо иметь права администратора на компьютере.  
  
 Если источник <xref:System.Diagnostics.EventLog.Source%2A> , указанный в свойстве этого <xref:System.Diagnostics.EventLog> экземпляра, не зарегистрирован на компьютере, в который записывается компонент, <xref:System.Diagnostics.EventLog.WriteEntry%2A> вызывает <xref:System.Diagnostics.EventLog.CreateEventSource%2A> и регистрирует источник.  
  
> [!NOTE]
>  Если <xref:System.Diagnostics.EventLog.MachineName%2A> не указать <xref:System.Diagnostics.EventLog> для экземпляра перед вызовом <xref:System.Diagnostics.EventLog.CreateEventSource%2A> или <xref:System.Diagnostics.EventLog.WriteEntry%2A>, предполагается, что используется локальный компьютер (".").  
  
 Если системе необходимо зарегистрировать <xref:System.Diagnostics.EventLog.Source%2A> с помощью <xref:System.Diagnostics.EventLog.WriteEntry%2A> вызова метода и <xref:System.Diagnostics.EventLog.Log%2A> свойство не было задано в <xref:System.Diagnostics.EventLog> экземпляре, по умолчанию используется журнал приложения.  
  
> [!NOTE]
>  Многие исключения, перечисленные выше, генерируются ошибками, возникающими в процессе <xref:System.Diagnostics.EventLog.Source%2A>регистрации.  
  
 Источник должен быть настроен либо для записи локализованных записей, либо для записи прямых строк. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Метод записывает заданную строку непосредственно в журнал событий. она не использует файл ресурсов локализуемого сообщения. <xref:System.Diagnostics.EventLog.WriteEvent%2A> Используйте метод для записи событий с помощью файла ресурсов локализованного сообщения.  
  
 Если приложение записывает записи, используя как идентификаторы ресурсов, так и строковые значения, необходимо зарегистрировать два отдельных источника. Например, можно настроить один источник с файлами ресурсов, а затем использовать этот источник в <xref:System.Diagnostics.EventLog.WriteEvent%2A> методе для записи записей, использующих идентификаторы ресурсов, в журнал событий. Затем создайте другой источник без файлов ресурсов и используйте этот источник в <xref:System.Diagnostics.EventLog.WriteEntry%2A> методе для записи строк непосредственно в журнал событий с помощью этого источника.  
  
> [!NOTE]
>  При записи записи на удаленный компьютер значение сообщения (текстовая строка) может отличаться от предполагаемого, если на удаленном компьютере не выполняется .NET Framework.  
  
> [!NOTE]
>  `message` Если параметр содержит символ NUL, сообщение в журнале событий заканчивается символом NUL.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog_WriteEntry_1_3#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog_WriteEntry_1_3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Не задано свойство <see cref="P:System.Diagnostics.EventLog.Source" /> класса <see cref="T:System.Diagnostics.EventLog" />.  
  
- или - 
Метод пытается зарегистрировать новый источник событий, но имя компьютера в <see cref="P:System.Diagnostics.EventLog.MachineName" /> является недопустимым.  
  
-или- 
Источник уже зарегистрирован для различных журналов событий.  
  
- или - 
 <paramref name="eventID" /> меньше нуля или больше <see cref="F:System.UInt16.MaxValue" />.  
  
- или - 
Строка сообщения превышает 31,839 байт (32,766 байт в операционных системах Windows до Windows Vista).  
  
- или - 
При таком имени источника длина пути к разделу реестра превышает 254 символа.</exception>
        <exception cref="T:System.InvalidOperationException">Не удается открыть раздел реестра для журнала событий.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> не является допустимым <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Операционная система сообщила об ошибке при записи сведений о событии в журнал событий. Код ошибки Windows недоступен.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Источник, по которому приложение регистрируется на указанном компьютере.</param>
        <param name="message">Строка для записи в журнал событий.</param>
        <param name="type">Одно из значений перечисления <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <param name="eventID">Идентификатор для события, зависящий от приложения.</param>
        <summary>Вносит в журнал событий запись с заданным текстом сообщения и идентификатором события (который определяется приложением), используя указанный зарегистрированный источник событий.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для записи записи с приложением, определенным `eventID` в журнале событий, используя источник, уже зарегистрированный в качестве источника событий для соответствующего журнала. `eventID`Вместе с источником уникально идентифицирует событие. Каждое приложение может определять собственные нумерованные события и строки описания, с которыми они сопоставляются. Средства просмотра событий предоставляют пользователю эти строки, чтобы помочь пользователю понять, что пошло не так, и предложить, какие действия следует предпринять.  
  
> [!NOTE]
>  Строка не может содержать%*n*, где n является целочисленным значением (например,% 1), так как средство просмотра событий обрабатывает его как строку вставки. ** `message` Так как адрес протокола IP версии 6 (IPv6) может содержать эту последовательность символов, нельзя заносить в журнал сообщение о событии, содержащее IPv6-адрес.  
  
 В дополнение к идентификатору события эта перегрузка <xref:System.Diagnostics.EventLog.WriteEntry%2A> позволяет <xref:System.Diagnostics.EventLogEntryType> указать для события, записываемого в журнал событий. `type` Указывает на значок и текст в столбце Тип в Просмотр событий для журнала. Этот параметр указывает, является ли тип события "ошибка", "предупреждение", "информация", "успех аудита" или "сбой аудита".  
  
 Перед записью первой записи с источником необходимо создать и настроить источник события. Создайте новый источник событий во время установки приложения. Это позволяет операционной системе обновлять свой список зарегистрированных источников событий и их конфигурацию. Если операционная система не обновила список источников событий и вы пытаетесь написать событие с новым источником, операция записи завершится ошибкой. Новый источник можно настроить с помощью <xref:System.Diagnostics.EventLogInstaller>или <xref:System.Diagnostics.EventLog.CreateEventSource%2A> с помощью метода. Для создания нового источника событий необходимо иметь права администратора на компьютере.  
  
 Источник должен быть настроен либо для записи локализованных записей, либо для записи прямых строк. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Метод записывает заданную строку непосредственно в журнал событий. она не использует файл ресурсов локализуемого сообщения. <xref:System.Diagnostics.EventLog.WriteEvent%2A> Используйте метод для записи событий с помощью файла ресурсов локализованного сообщения.  
  
 Если приложение записывает записи, используя как идентификаторы ресурсов, так и строковые значения, необходимо зарегистрировать два отдельных источника. Например, можно настроить один источник с файлами ресурсов, а затем использовать этот источник в <xref:System.Diagnostics.EventLog.WriteEvent%2A> методе для записи записей, использующих идентификаторы ресурсов, в журнал событий. Затем создайте другой источник без файлов ресурсов и используйте этот источник в <xref:System.Diagnostics.EventLog.WriteEntry%2A> методе для записи строк непосредственно в журнал событий с помощью этого источника.  
  
> [!NOTE]
>  `message` Если параметр содержит символ NUL, сообщение в журнале событий заканчивается символом NUL.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_4#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_4/CPP/eventlog_writeentry_4.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_4#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_4/CS/eventlog_writeentry_4.cs#1)]
 [!code-vb[EventLog_WriteEntry_4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_4/VB/eventlog_writeentry_4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значением <paramref name="source" /> является пустая строка ("").  
  
-или- 
Значение <paramref name="source" /> равно <see langword="null" />.  
  
- или - 
 <paramref name="eventID" /> меньше нуля или больше <see cref="F:System.UInt16.MaxValue" />.  
  
- или - 
Строка сообщения превышает 31,839 байт (32,766 байт в операционных системах Windows до Windows Vista).  
  
-или- 
При таком имени источника длина пути к разделу реестра превышает 254 символа.</exception>
        <exception cref="T:System.InvalidOperationException">Не удается открыть раздел реестра для журнала событий.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> не является допустимым <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Операционная система сообщила об ошибке при записи сведений о событии в журнал событий. Код ошибки Windows недоступен.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer, category As Short, rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category, cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int * int16 * byte[] -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID, category, rawData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="message">Строка для записи в журнал событий.</param>
        <param name="type">Одно из значений перечисления <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <param name="eventID">Идентификатор для события, зависящий от приложения.</param>
        <param name="category">Подкатегория конкретного приложения, связанная с сообщением.</param>
        <param name="rawData">Массив байтов, в котором хранятся двоичные данные, связанные с записью.</param>
        <summary>Вносит в журнал событий запись с заданным текстом сообщения, идентификатором события и категорией (которые определяются приложением), а затем добавляет в сообщение двоичные данные.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для записи определенных приложением данных о событиях в журнал событий. Просмотр событий не интерпретирует эти данные; Он отображает необработанные данные только в комбинированном шестнадцатеричном и текстовом формате. Данные, относящиеся к событиям, следует использовать экономно, в том числе только в том случае, если вы уверены, что он будет полезен для отладки проблемы. Можно также использовать данные событий для хранения информации, которую приложение может обрабатывать независимо от Просмотр событий. Например, можно написать средство просмотра, предназначенное для событий, или написать программу, которая сканирует файл журнала и создает отчеты, содержащие сведения из данных, относящихся к конкретному событию.  
  
 Помимо двоичных данных, можно указать определяемую приложением категорию и идентификатор события, определяемый приложением. Просмотр событий использует категорию для фильтрации событий, записанных источником событий. Просмотр событий может отображать категорию в виде числового значения или использовать категорию в качестве идентификатора ресурса для вывода локализованной строки категории.  
  
> [!NOTE]
>  Строка не может содержать%*n*, где n является целочисленным значением (например,% 1), так как средство просмотра событий обрабатывает его как строку вставки. ** `message` Так как адрес протокола IP версии 6 (IPv6) может содержать эту последовательность символов, нельзя заносить в журнал сообщение о событии, содержащее IPv6-адрес.  
  
> [!NOTE]
>  `category` Параметр должен быть положительным значением. Отрицательные значения категории отображаются в Просмотр событий с дополнительным положительным числом. Например,-10 отображается как 65 526, a – 1 как 65 535.  
  
 Чтобы отобразить локализованные строки категории в Просмотр событий, необходимо использовать источник событий, настроенный с помощью файла ресурсов категории, и задать для `category` него идентификатор ресурса в файле ресурсов категории. Если источник событий не имеет настроенного файла ресурсов категории или указанный `category` объект не индексирует строку в файле ресурсов категории, то Просмотр событий отображает числовое значение категории для этой записи. Настройте файл ресурсов категории вместе с числом строк категории в файле ресурсов, используя <xref:System.Diagnostics.EventLogInstaller> <xref:System.Diagnostics.EventSourceCreationData> класс или.  
  
 Идентификаторы событий, а также источник событий однозначно идентифицируют событие. Каждое приложение может определять собственные нумерованные события и строки описания, с которыми они сопоставляются. Средства просмотра событий отображают эти строковые значения, чтобы помочь пользователю понять, что пошло не так, и предложить, какие действия следует предпринять.  
  
 Наконец, можно указать <xref:System.Diagnostics.EventLogEntryType> для события, записываемого в журнал событий. `type` Указывает на значок и текст в столбце Тип в Просмотр событий для журнала. Этот параметр указывает, является ли тип события "ошибка", "предупреждение", "информация", "успех аудита" или "сбой аудита".  
  
 Необходимо задать <xref:System.Diagnostics.EventLog.Source%2A> свойство <xref:System.Diagnostics.EventLog> для компонента, прежде чем можно будет записывать записи в журнал. Перед записью первой записи с источником необходимо создать и настроить источник события.  
  
 Создайте новый источник событий во время установки приложения. Это позволяет операционной системе обновлять свой список зарегистрированных источников событий и их конфигурацию. Если операционная система не обновила список источников событий и вы пытаетесь написать событие с новым источником, операция записи завершится ошибкой. Новый источник можно настроить с помощью <xref:System.Diagnostics.EventLogInstaller>или <xref:System.Diagnostics.EventLog.CreateEventSource%2A> с помощью метода. Для создания нового источника событий необходимо иметь права администратора на компьютере.  
  
 Если источник <xref:System.Diagnostics.EventLog.Source%2A> , указанный в свойстве этого <xref:System.Diagnostics.EventLog> экземпляра, не зарегистрирован на компьютере, в который записывается компонент, <xref:System.Diagnostics.EventLog.WriteEntry%2A> вызывает <xref:System.Diagnostics.EventLog.CreateEventSource%2A> и регистрирует источник.  
  
> [!NOTE]
>  Если <xref:System.Diagnostics.EventLog.MachineName%2A> не указать <xref:System.Diagnostics.EventLog> для экземпляра перед вызовом <xref:System.Diagnostics.EventLog.CreateEventSource%2A> или <xref:System.Diagnostics.EventLog.WriteEntry%2A>, предполагается, что используется локальный компьютер (".").  
  
 Если системе необходимо зарегистрировать <xref:System.Diagnostics.EventLog.Source%2A> с помощью <xref:System.Diagnostics.EventLog.WriteEntry%2A> вызова метода и <xref:System.Diagnostics.EventLog.Log%2A> свойство не было задано в <xref:System.Diagnostics.EventLog> экземпляре, по умолчанию используется журнал приложения.  
  
> [!NOTE]
>  Многие исключения, перечисленные выше, генерируются ошибками, возникающими в процессе <xref:System.Diagnostics.EventLog.Source%2A>регистрации.  
  
 Источник должен быть настроен либо для записи локализованных записей, либо для записи прямых строк. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Метод записывает заданную строку непосредственно в журнал событий. она не использует файл ресурсов локализуемого сообщения. <xref:System.Diagnostics.EventLog.WriteEvent%2A> Используйте метод для записи событий с помощью файла ресурсов локализованного сообщения.  
  
 Если приложение записывает записи, используя как идентификаторы ресурсов, так и строковые значения, необходимо зарегистрировать два отдельных источника. Например, можно настроить один источник с файлами ресурсов, а затем использовать этот источник в <xref:System.Diagnostics.EventLog.WriteEvent%2A> методе для записи записей, использующих идентификаторы ресурсов, в журнал событий. Затем создайте другой источник без файлов ресурсов и используйте этот источник в <xref:System.Diagnostics.EventLog.WriteEntry%2A> методе для записи строк непосредственно в журнал событий с помощью этого источника.  
  
> [!NOTE]
>  При записи записи на удаленный компьютер значение сообщения (текстовая строка) может отличаться от предполагаемого, если на удаленном компьютере не выполняется .NET Framework.  
  
> [!NOTE]
>  `message` Если параметр содержит символ NUL, сообщение в журнале событий заканчивается символом NUL.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_5#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_5/CPP/eventlog_writeentry_5.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_5#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_5/CS/eventlog_writeentry_5.cs#1)]
 [!code-vb[EventLog_WriteEntry_5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_5/VB/eventlog_writeentry_5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Не задано свойство <see cref="P:System.Diagnostics.EventLog.Source" /> класса <see cref="T:System.Diagnostics.EventLog" />.  
  
-или- 
Метод пытается зарегистрировать новый источник событий, но имя компьютера в <see cref="P:System.Diagnostics.EventLog.MachineName" /> является недопустимым.  
  
- или - 
Источник уже зарегистрирован для различных журналов событий.  
  
- или - 
 <paramref name="eventID" /> меньше нуля или больше <see cref="F:System.UInt16.MaxValue" />.  
  
-или- 
Строка сообщения превышает 31,839 байт (32,766 байт в операционных системах Windows до Windows Vista).  
  
- или - 
При таком имени источника длина пути к разделу реестра превышает 254 символа.</exception>
        <exception cref="T:System.InvalidOperationException">Не удается открыть раздел реестра для журнала событий.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> не является допустимым <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Операционная система сообщила об ошибке при записи сведений о событии в журнал событий. Код ошибки Windows недоступен.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer, category As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int * int16 -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="source">Источник, по которому приложение регистрируется на указанном компьютере.</param>
        <param name="message">Строка для записи в журнал событий.</param>
        <param name="type">Одно из значений перечисления <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <param name="eventID">Идентификатор для события, зависящий от приложения.</param>
        <param name="category">Подкатегория конкретного приложения, связанная с сообщением.</param>
        <summary>Вносит в журнал событий запись с заданным текстом сообщения и идентификатором события и категорией (которые определяется приложением), используя указанный зарегистрированный источник событий. С помощью <paramref name="category" /> осуществляется фильтрация событий журнала в компоненте "Просмотр событий".</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для записи записи с приложением, определенным `category` в журнале событий, используя источник, который уже зарегистрирован в качестве источника событий для соответствующего журнала. Просмотр событий использует категорию для фильтрации событий, записанных источником событий. Просмотр событий может отображать категорию в виде числового значения или использовать категорию в качестве идентификатора ресурса для вывода локализованной строки категории.  
  
> [!NOTE]
>  `category` Параметр должен быть положительным значением. Отрицательные значения категории отображаются в Просмотр событий с дополнительным положительным числом. Например,-10 отображается как 65 526, a – 1 как 65 535.  
  
 Чтобы отобразить локализованные строки категории в Просмотр событий, необходимо использовать источник событий, настроенный с помощью файла ресурсов категории, и задать для `category` него идентификатор ресурса в файле ресурсов категории. Если источник событий не имеет настроенного файла ресурсов категории или указанный `category` объект не индексирует строку в файле ресурсов категории, то Просмотр событий отображает числовое значение категории для этой записи. Настройте файл ресурсов категории вместе с числом строк категории в файле ресурсов, используя <xref:System.Diagnostics.EventLogInstaller> <xref:System.Diagnostics.EventSourceCreationData> класс или.  
  
 В дополнение к категории можно указать идентификатор события для события, записываемого в журнал событий. Идентификаторы событий, а также источник событий однозначно идентифицируют событие. Каждое приложение может определять собственные нумерованные события и строки описания, с которыми они сопоставляются. Средства просмотра событий отображают эти строковые значения, чтобы помочь пользователю понять, что пошло не так, и предложить, какие действия следует предпринять.  
  
 Наконец, можно указать <xref:System.Diagnostics.EventLogEntryType> для события, записываемого в журнал событий. `type` Указывает на значок и текст в столбце Тип в Просмотр событий для журнала. Этот параметр указывает, является ли тип события "ошибка", "предупреждение", "информация", "успех аудита" или "сбой аудита".  
  
 Перед записью первой записи с источником необходимо создать и настроить источник события. Создайте новый источник событий во время установки приложения. Это позволяет операционной системе обновлять свой список зарегистрированных источников событий и их конфигурацию. Если операционная система не обновила список источников событий и вы пытаетесь написать событие с новым источником, операция записи завершится ошибкой. Новый источник можно настроить с помощью <xref:System.Diagnostics.EventLogInstaller>или <xref:System.Diagnostics.EventLog.CreateEventSource%2A> с помощью метода. Для создания нового источника событий необходимо иметь права администратора на компьютере.  
  
 Источник должен быть настроен либо для записи локализованных записей, либо для записи прямых строк. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Метод записывает заданную строку непосредственно в журнал событий. она не использует файл ресурсов локализуемого сообщения. <xref:System.Diagnostics.EventLog.WriteEvent%2A> Используйте метод для записи событий с помощью файла ресурсов локализованного сообщения.  
  
 Если приложение записывает записи, используя как идентификаторы ресурсов, так и строковые значения, необходимо зарегистрировать два отдельных источника. Например, можно настроить один источник с файлами ресурсов, а затем использовать этот источник в <xref:System.Diagnostics.EventLog.WriteEvent%2A> методе для записи записей, использующих идентификаторы ресурсов, в журнал событий. Затем создайте другой источник без файлов ресурсов и используйте этот источник в <xref:System.Diagnostics.EventLog.WriteEntry%2A> методе для записи строк непосредственно в журнал событий с помощью этого источника.  
  
> [!NOTE]
>  `message` Если параметр содержит символ NUL, сообщение в журнале событий заканчивается символом NUL.  
>   
>  Строка не может содержать%*n*, где n является целочисленным значением (например,% 1), так как средство просмотра событий обрабатывает его как строку вставки. ** `message` Так как адрес протокола IP версии 6 (IPv6) может содержать эту последовательность символов, нельзя заносить в журнал сообщение о событии, содержащее IPv6-адрес.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_1_3#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#1)]
 [!code-vb[EventLog_WriteEntry_1_3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значением <paramref name="source" /> является пустая строка ("").  
  
- или - 
Значение <paramref name="source" /> равно <see langword="null" />.  
  
- или - 
 <paramref name="eventID" /> меньше нуля или больше <see cref="F:System.UInt16.MaxValue" />.  
  
- или - 
Строка сообщения превышает 31,839 байт (32,766 байт в операционных системах Windows до Windows Vista).  
  
- или - 
При таком имени источника длина пути к разделу реестра превышает 254 символа.</exception>
        <exception cref="T:System.InvalidOperationException">Не удается открыть раздел реестра для журнала событий.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> не является допустимым <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Операционная система сообщила об ошибке при записи сведений о событии в журнал событий. Код ошибки Windows недоступен.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer, category As Short, rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category, cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int * int16 * byte[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID, category, rawData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="source">Источник, по которому приложение регистрируется на указанном компьютере.</param>
        <param name="message">Строка для записи в журнал событий.</param>
        <param name="type">Одно из значений перечисления <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <param name="eventID">Идентификатор для события, зависящий от приложения.</param>
        <param name="category">Подкатегория конкретного приложения, связанная с сообщением.</param>
        <param name="rawData">Массив байтов, в котором хранятся двоичные данные, связанные с записью.</param>
        <summary>Вносит в журнал событий запись с заданным текстом сообщения, идентификатором события и категорией (которые определяются приложением), используя указанный зарегистрированный источник событий, а затем добавляет в сообщение двоичные данные.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется для записи определяемых приложением данных событий в журнал событий с использованием источника, уже зарегистрированного в качестве источника событий для соответствующего журнала. Просмотр событий не интерпретирует эти данные; Он отображает необработанные данные только в комбинированном шестнадцатеричном и текстовом формате. Используйте данные событий экономно. включайте его только в том случае, если вы уверены, что он будет полезен. Можно также использовать данные событий для хранения информации, которую приложение может обрабатывать независимо от Просмотр событий. Например, можно написать средство просмотра, предназначенное для событий, или написать программу, которая сканирует файл журнала и создает отчеты, содержащие сведения из данных, относящихся к конкретному событию.  
  
 Помимо двоичных данных, можно указать определяемую приложением категорию и идентификатор события, определяемый приложением. Просмотр событий использует категорию для фильтрации событий, записанных источником событий. Просмотр событий может отображать категорию в виде числового значения или использовать категорию в качестве идентификатора ресурса для вывода локализованной строки категории.  
  
> [!NOTE]
>  `category` Параметр должен быть положительным значением. Отрицательные значения категории отображаются в Просмотр событий с дополнительным положительным числом. Например, значение-10 будет отображаться как 65 526, a – 1 как 65 535.  
  
 Чтобы отобразить локализованные строки категории в Просмотр событий, необходимо использовать источник событий, настроенный с помощью файла ресурсов категории, и задать для `category` него идентификатор ресурса в файле ресурсов категории. Если источник событий не имеет настроенного файла ресурсов категории или указанный `category` объект не индексирует строку в файле ресурсов категории, то Просмотр событий отображает числовое значение категории для этой записи. Настройте файл ресурсов категории вместе с числом строк категории в файле ресурсов, используя <xref:System.Diagnostics.EventLogInstaller> <xref:System.Diagnostics.EventSourceCreationData> класс или.  
  
 Идентификаторы событий вместе с источником событий однозначно идентифицируют событие. Каждое приложение может определять собственные нумерованные события и строки описания, с которыми они сопоставляются. Средства просмотра событий отображают эти строковые значения, чтобы помочь пользователю понять, что пошло не так, и предложить, какие действия следует предпринять.  
  
 Наконец, можно указать <xref:System.Diagnostics.EventLogEntryType> для события, записываемого в журнал событий. `type` Указывает на значок и текст в столбце Тип в Просмотр событий для журнала. Этот параметр указывает, является ли тип события "ошибка", "предупреждение", "информация", "успех аудита" или "сбой аудита".  
  
 Перед записью первой записи с источником необходимо создать и настроить источник события. Создайте новый источник событий во время установки приложения. Это позволяет операционной системе обновлять свой список зарегистрированных источников событий и их конфигурацию. Если операционная система не обновила список источников событий и вы пытаетесь написать событие с новым источником, операция записи завершится ошибкой. Новый источник можно настроить с помощью <xref:System.Diagnostics.EventLogInstaller>или <xref:System.Diagnostics.EventLog.CreateEventSource%2A> с помощью метода. Для создания нового источника событий необходимо иметь права администратора на компьютере.  
  
 Источник должен быть настроен либо для записи локализованных записей, либо для записи прямых строк. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Метод записывает заданную строку непосредственно в журнал событий. она не использует файл ресурсов локализуемого сообщения. <xref:System.Diagnostics.EventLog.WriteEvent%2A> Используйте метод для записи событий с помощью файла ресурсов локализованного сообщения.  
  
 Если приложение записывает записи, используя как идентификаторы ресурсов, так и строковые значения, необходимо зарегистрировать два отдельных источника. Например, можно настроить один источник с файлами ресурсов, а затем использовать этот источник в <xref:System.Diagnostics.EventLog.WriteEvent%2A> методе для записи записей, использующих идентификаторы ресурсов, в журнал событий. Затем создайте другой источник без файлов ресурсов и используйте этот источник в <xref:System.Diagnostics.EventLog.WriteEntry%2A> методе для записи строк непосредственно в журнал событий с помощью этого источника.  
  
> [!NOTE]
>  `message` Если параметр содержит символ NUL, сообщение в журнале событий заканчивается символом NUL.  
>   
>  Строка не может содержать%*n*, где n является целочисленным значением (например,% 1), так как средство просмотра событий обрабатывает его как строку вставки. ** `message` Так как адрес протокола IP версии 6 (IPv6) может содержать эту последовательность символов, нельзя заносить в журнал сообщение о событии, содержащее IPv6-адрес.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#2)]
 [!code-csharp[EventLog_WriteEntry_1_3#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#2)]
 [!code-vb[EventLog_WriteEntry_1_3#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значением <paramref name="source" /> является пустая строка ("").  
  
- или - 
Значение <paramref name="source" /> равно <see langword="null" />.  
  
- или - 
 <paramref name="eventID" /> меньше нуля или больше <see cref="F:System.UInt16.MaxValue" />.  
  
- или - 
Строка сообщения превышает 31,839 байт (32,766 байт в операционных системах Windows до Windows Vista).  
  
-или- 
При таком имени источника длина пути к разделу реестра превышает 254 символа.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> не является допустимым <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.InvalidOperationException">Не удается открыть раздел реестра для журнала событий.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Операционная система сообщила об ошибке при записи сведений о событии в журнал событий. Код ошибки Windows недоступен.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEvent">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Вносит записи локализованных событий в журнал событий.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEvent (instance As EventInstance, ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEvent(System::Diagnostics::EventInstance ^ instance, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : System.Diagnostics.EventInstance * obj[] -&gt; unit" Usage="eventLog.WriteEvent (instance, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Экземпляр <see cref="T:System.Diagnostics.EventInstance" />, который представляет локализованную запись журнала событий.</param>
        <param name="values">Массив строк для слияния в текстовое сообщение записи журнала событий.</param>
        <summary>Вносит локализованные записи в журнал событий.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется для записи локализованной записи в журнал событий. Свойства событий задаются с помощью идентификаторов ресурсов, а не строковых значений. Просмотр событий использует идентификаторы ресурсов для вывода соответствующих строк из локализованного файла ресурсов для <xref:System.Diagnostics.EventLog.Source%2A>. Прежде чем записывать события с помощью идентификаторов ресурсов, необходимо зарегистрировать источник в соответствующем файле ресурсов.  
  
 Входной `instance` экземпляр указывает сообщение и свойства события. <xref:System.Diagnostics.EventInstance.InstanceId%2A> Задает вход для определенного сообщения в `instance`  файле ресурсов исходного сообщения. При необходимости можно задать <xref:System.Diagnostics.EventInstance.CategoryId%2A> и <xref:System.Diagnostics.EventInstance.EntryType%2A> `instance` для входных данных, чтобы определить категорию и тип события для записи события. Можно также указать массив строк, не зависящих от языка, для вставки в текст локализованного сообщения. Задайте `values` значение `null` , если сообщение о событии не содержит заполнителей форматирования для замещающих строк.  
  
 Необходимо задать <xref:System.Diagnostics.EventLog.Source%2A> свойство <xref:System.Diagnostics.EventLog> для компонента перед использованием <xref:System.Diagnostics.EventLog.WriteEvent%2A>. Указанный источник должен быть настроен для записи локализованных записей в журнал; для источника должно быть задано по меньшей мере файл ресурсов сообщения.  
  
 Перед записью первой записи с источником необходимо создать и настроить источник события. Создайте новый источник событий во время установки приложения. Это позволяет операционной системе обновлять свой список зарегистрированных источников событий и их конфигурацию. Если операционная система не обновила список источников событий и вы пытаетесь написать событие с новым источником, операция записи завершится ошибкой. Новый источник можно настроить с помощью <xref:System.Diagnostics.EventLogInstaller>или <xref:System.Diagnostics.EventLog.CreateEventSource%2A> с помощью метода. Для создания нового источника событий необходимо иметь права администратора на компьютере.  
  
 Источник должен быть настроен либо для записи локализованных записей, либо для записи прямых строк. Используйте метод <xref:System.Diagnostics.EventLog.WriteEntry%2A> , если приложение записывает строковые значения непосредственно в журнал событий.  
  
 Если приложение записывает записи, используя как идентификаторы ресурсов, так и строковые значения, необходимо зарегистрировать два отдельных источника. Например, можно настроить один источник с файлами ресурсов, а затем использовать этот источник в <xref:System.Diagnostics.EventLog.WriteEvent%2A> методе для записи записей, использующих идентификаторы ресурсов, в журнал событий. Затем создайте другой источник без файлов ресурсов и используйте этот источник в <xref:System.Diagnostics.EventLog.WriteEntry%2A> методе для записи строк непосредственно в журнал событий с помощью этого источника.  
  
> [!NOTE]
>  При записи записи на удаленный компьютер значение `message` строки может отличаться от предполагаемого, если на удаленном компьютере не выполняется .NET Framework. Кроме того, `message` строка не может содержать%*n*, где *n* — целочисленное значение (например,% 1), поскольку средство просмотра событий обрабатывает его как строку вставки. Так как адрес протокола IP версии 6 (IPv6) может содержать эту последовательность символов, нельзя заносить в журнал сообщение о событии, содержащее IPv6-адрес.  
  
   
  
## Examples  
 В следующем примере две записи аудита записываются в журнал `myNewLog`событий. В примере создается новый источник событий и новый журнал событий, если они не существуют на локальном компьютере. Текст сообщения о событии указывается с помощью идентификатора ресурса в файле ресурсов.  
  
 [!code-cpp[EventLog_WriteEvent#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog_WriteEvent#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog_WriteEvent#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 В примере используется следующий текстовый файл сообщения, встроенный в библиотеку ресурсов Евентлогмсгс. dll. Текстовый файл сообщения — это источник, из которого создается файл ресурсов сообщения. В текстовом файле сообщения определяются идентификаторы ресурсов и текст для категории, сообщения о событии и строки вставки параметров.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Не задано свойство <see cref="P:System.Diagnostics.EventLog.Source" /> класса <see cref="T:System.Diagnostics.EventLog" />.  
  
- или - 
Метод пытается зарегистрировать новый источник событий, но имя компьютера в <see cref="P:System.Diagnostics.EventLog.MachineName" /> является недопустимым.  
  
-или- 
Источник уже зарегистрирован для различных журналов событий.  
  
-или- 
 <paramref name="instance.InstanceId" /> меньше нуля или больше <see cref="F:System.UInt16.MaxValue" />.  
  
- или - 
 <paramref name="values" /> содержит более 256 элементов.  
  
- или - 
Один из элементов <paramref name="values" /> длиннее 32766 байт.  
  
- или - 
При таком имени источника длина пути к разделу реестра превышает 254 символа.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="instance" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Не удается открыть раздел реестра для журнала событий.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Операционная система сообщила об ошибке при записи сведений о событии в журнал событий. Код ошибки Windows недоступен.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, byte[] data, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEvent (instance As EventInstance, data As Byte(), ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEvent(System::Diagnostics::EventInstance ^ instance, cli::array &lt;System::Byte&gt; ^ data, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : System.Diagnostics.EventInstance * byte[] * obj[] -&gt; unit" Usage="eventLog.WriteEvent (instance, data, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="data" Type="System.Byte[]" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Экземпляр <see cref="T:System.Diagnostics.EventInstance" />, который представляет локализованную запись журнала событий.</param>
        <param name="data">Массив байтов, в котором хранятся двоичные данные, связанные с записью.</param>
        <param name="values">Массив строк для слияния в текстовое сообщение записи журнала событий.</param>
        <summary>Заносит записи журнала событий с данными события, строками замещения сообщения и связанными двоичными данными.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для записи локализованной записи с дополнительными данными о событии в журнал событий. Свойства событий задаются с помощью идентификаторов ресурсов, а не строковых значений. Просмотр событий использует идентификаторы ресурсов для вывода соответствующих строк из локализованного файла ресурсов для <xref:System.Diagnostics.EventLog.Source%2A>. Прежде чем записывать события с помощью идентификаторов ресурсов, необходимо зарегистрировать источник в соответствующем файле ресурсов.  
  
 Входной `instance` экземпляр указывает сообщение и свойства события. <xref:System.Diagnostics.EventInstance.InstanceId%2A> Задает вход для определенного сообщения в `instance`  файле ресурсов исходного сообщения. При необходимости можно задать <xref:System.Diagnostics.EventInstance.CategoryId%2A> и <xref:System.Diagnostics.EventInstance.EntryType%2A> `instance` для входных данных, чтобы определить категорию и тип события для записи события. Можно также указать массив строк, не зависящих от языка, для вставки в текст локализованного сообщения. Задайте `values` значение `null` , если сообщение о событии не содержит заполнителей форматирования для замещающих строк.  
  
 Укажите двоичные данные с событием, когда необходимо предоставить дополнительные сведения о событии. Например, используйте `data` параметр, чтобы включить сведения об определенной ошибке. Просмотр событий не интерпретирует связанные данные события; Он отображает данные в комбинированном шестнадцатеричном и текстовом формате. Используйте данные событий экономно. включайте его только в том случае, если вы уверены, что он будет полезен. Можно также использовать данные событий для хранения информации, которую приложение может обрабатывать независимо от Просмотр событий. Например, можно написать средство просмотра, предназначенное для событий, или написать программу, которая просматривает журнал событий и создает отчеты, содержащие сведения из данных, относящихся к конкретному событию.  
  
 Перед использованием компонента необходимо <xref:System.Diagnostics.EventLog.Source%2A> задать свойство <xref:System.Diagnostics.EventLog> в компоненте до его использования <xref:System.Diagnostics.EventLog.WriteEvent%2A>. Указанный источник должен быть настроен для записи локализованных записей в журнал; для источника должно быть задано по меньшей мере файл ресурсов сообщения.  
  
 Перед записью первой записи с источником необходимо создать и настроить источник события. Создайте новый источник событий во время установки приложения. Это позволяет операционной системе обновлять свой список зарегистрированных источников событий и их конфигурацию. Если операционная система не обновила список источников событий и вы пытаетесь написать событие с новым источником, операция записи завершится ошибкой. Новый источник можно настроить с помощью <xref:System.Diagnostics.EventLogInstaller>или <xref:System.Diagnostics.EventLog.CreateEventSource%2A> с помощью метода. Для создания нового источника событий необходимо иметь права администратора на компьютере.  
  
> [!NOTE]
>  Если не указать <xref:System.Diagnostics.EventLog.MachineName%2A> <xref:System.Diagnostics.EventLog> для экземпляра перед вызовом <xref:System.Diagnostics.EventLog.WriteEvent%2A>, предполагается, что используется локальный компьютер (".").  
  
 Источник должен быть настроен либо для записи локализованных записей, либо для записи прямых строк. Используйте метод <xref:System.Diagnostics.EventLog.WriteEntry%2A> , если приложение записывает строковые значения непосредственно в журнал событий.  
  
 Если приложение записывает записи, используя как идентификаторы ресурсов, так и строковые значения, необходимо зарегистрировать два отдельных источника. Например, можно настроить один источник с файлами ресурсов, а затем использовать этот источник в <xref:System.Diagnostics.EventLog.WriteEvent%2A> методе для записи записей, использующих идентификаторы ресурсов, в журнал событий. Затем создайте другой источник без файлов ресурсов и используйте этот источник в <xref:System.Diagnostics.EventLog.WriteEntry%2A> методе для записи строк непосредственно в журнал событий с помощью этого источника.  
  
> [!NOTE]
>  При записи записи на удаленный компьютер значение `message` строки может отличаться от предполагаемого, если на удаленном компьютере не выполняется .NET Framework. Кроме того, `message` строка не может содержать%*n*, где *n* — целочисленное значение (например,% 1), поскольку средство просмотра событий обрабатывает его как строку вставки. Так как адрес протокола IP версии 6 (IPv6) может содержать эту последовательность символов, нельзя заносить в журнал сообщение о событии, содержащее IPv6-адрес.  
  
   
  
## Examples  
 В следующем примере две записи аудита записываются в журнал `myNewLog`событий. В примере создается новый источник событий и новый журнал событий, если они не существуют на локальном компьютере. Текст сообщения о событии указывается с помощью идентификатора ресурса в файле ресурсов.  
  
 [!code-cpp[EventLog_WriteEvent#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog_WriteEvent#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog_WriteEvent#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 В примере используется следующий текстовый файл сообщения, встроенный в библиотеку ресурсов Евентлогмсгс. dll. Текстовый файл сообщения — это источник, из которого создается файл ресурсов сообщения. В текстовом файле сообщения определяются идентификаторы ресурсов и текст для категории, сообщения о событии и строки вставки параметров.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Не задано свойство <see cref="P:System.Diagnostics.EventLog.Source" /> класса <see cref="T:System.Diagnostics.EventLog" />.  
  
- или - 
Метод пытается зарегистрировать новый источник событий, но имя компьютера в <see cref="P:System.Diagnostics.EventLog.MachineName" /> является недопустимым.  
  
- или - 
Источник уже зарегистрирован для различных журналов событий.  
  
-или- 
 <paramref name="instance.InstanceId" /> меньше нуля или больше <see cref="F:System.UInt16.MaxValue" />.  
  
- или - 
 <paramref name="values" /> содержит более 256 элементов.  
  
-или- 
Один из элементов <paramref name="values" /> длиннее 32766 байт.  
  
- или - 
При таком имени источника длина пути к разделу реестра превышает 254 символа.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="instance" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Не удается открыть раздел реестра для журнала событий.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Операционная система сообщила об ошибке при записи сведений о событии в журнал событий. Код ошибки Windows недоступен.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEvent (source As String, instance As EventInstance, ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEvent(System::String ^ source, System::Diagnostics::EventInstance ^ instance, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member WriteEvent : string * System.Diagnostics.EventInstance * obj[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEvent (source, instance, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">Имя источника событий, зарегистрированного для приложения на заданном компьютере.</param>
        <param name="instance">Экземпляр <see cref="T:System.Diagnostics.EventInstance" />, который представляет локализованную запись журнала событий.</param>
        <param name="values">Массив строк для слияния в текстовое сообщение записи журнала событий.</param>
        <summary>Вносит в журнал событий запись с заданными данными сообщения и строками замещения сообщения, используя указанный зарегистрированный источник событий.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется для записи локализованной записи в журнал событий с использованием источника, уже зарегистрированного в качестве источника событий для соответствующего журнала. Свойства событий задаются с помощью идентификаторов ресурсов, а не строковых значений. Просмотр событий использует идентификаторы ресурсов для вывода соответствующих строк из локализованного файла ресурсов для источника. Прежде чем записывать события с помощью идентификаторов ресурсов, необходимо зарегистрировать источник в соответствующем файле ресурсов.  
  
 Входной `instance` экземпляр указывает сообщение и свойства события. <xref:System.Diagnostics.EventInstance.InstanceId%2A> Задает вход для определенного сообщения в `instance`  файле ресурсов исходного сообщения. При необходимости можно задать <xref:System.Diagnostics.EventInstance.CategoryId%2A> и <xref:System.Diagnostics.EventInstance.EntryType%2A> `instance` для входных данных, чтобы определить категорию и тип события для записи события. Можно также указать массив строк, не зависящих от языка, для вставки в текст локализованного сообщения. Задайте `values` значение `null` , если сообщение о событии не содержит заполнителей форматирования для замещающих строк.  
  
 Указанный источник должен быть зарегистрирован для журнала событий перед использованием <xref:System.Diagnostics.EventLog.WriteEvent%2A>. Указанный источник должен быть настроен для записи локализованных записей в журнал; для источника должно быть задано по меньшей мере файл ресурсов сообщения.  
  
 Перед записью первой записи с источником необходимо создать и настроить источник события. Создайте новый источник событий во время установки приложения. Это позволяет операционной системе обновлять свой список зарегистрированных источников событий и их конфигурацию. Если операционная система не обновила список источников событий и вы пытаетесь написать событие с новым источником, операция записи завершится ошибкой. Новый источник можно настроить с помощью <xref:System.Diagnostics.EventLogInstaller>или <xref:System.Diagnostics.EventLog.CreateEventSource%2A> с помощью метода. Для создания нового источника событий необходимо иметь права администратора на компьютере.  
  
 Источник должен быть настроен либо для записи локализованных записей, либо для записи прямых строк. Используйте метод <xref:System.Diagnostics.EventLog.WriteEntry%2A> , если приложение записывает строковые значения непосредственно в журнал событий.  
  
 Если приложение записывает записи, используя как идентификаторы ресурсов, так и строковые значения, необходимо зарегистрировать два отдельных источника. Например, можно настроить один источник с файлами ресурсов, а затем использовать этот источник в <xref:System.Diagnostics.EventLog.WriteEvent%2A> методе для записи записей, использующих идентификаторы ресурсов, в журнал событий. Затем создайте другой источник без файлов ресурсов и используйте этот источник в <xref:System.Diagnostics.EventLog.WriteEntry%2A> методе для записи строк непосредственно в журнал событий с помощью этого источника.  
  
   
  
## Examples  
 В следующем примере запись информационного события и запись события предупреждения записываются в существующий журнал событий. Текст сообщения о событии указывается с помощью идентификатора ресурса в файле ресурсов. В этом примере предполагается, что соответствующий файл ресурсов был зарегистрирован для источника.  
  
 [!code-cpp[EventLog_WriteEvent#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog_WriteEvent#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog_WriteEvent#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 В примере используется следующий текстовый файл сообщения, встроенный в библиотеку ресурсов Евентлогмсгс. dll. Текстовый файл сообщения — это источник, из которого создается файл ресурсов сообщения. В текстовом файле сообщения определяются идентификаторы ресурсов и текст для категории, сообщения о событии и строки вставки параметров.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значением <paramref name="source" /> является пустая строка ("").  
  
-или- 
Значение <paramref name="source" /> равно <see langword="null" />.  
  
- или - 
 <paramref name="instance.InstanceId" /> меньше нуля или больше <see cref="F:System.UInt16.MaxValue" />.  
  
- или - 
 <paramref name="values" /> содержит более 256 элементов.  
  
- или - 
Один из элементов <paramref name="values" /> длиннее 32766 байт.  
  
-или- 
При таком имени источника длина пути к разделу реестра превышает 254 символа.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="instance" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Не удается открыть раздел реестра для журнала событий.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Операционная система сообщила об ошибке при записи сведений о событии в журнал событий. Код ошибки Windows недоступен.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, byte[] data, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEvent (source As String, instance As EventInstance, data As Byte(), ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEvent(System::String ^ source, System::Diagnostics::EventInstance ^ instance, cli::array &lt;System::Byte&gt; ^ data, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member WriteEvent : string * System.Diagnostics.EventInstance * byte[] * obj[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEvent (source, instance, data, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="data" Type="System.Byte[]" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="3" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">Имя источника событий, зарегистрированного для приложения на заданном компьютере.</param>
        <param name="instance">Экземпляр <see cref="T:System.Diagnostics.EventInstance" />, который представляет локализованную запись журнала событий.</param>
        <param name="data">Массив байтов, в котором хранятся двоичные данные, связанные с записью.</param>
        <param name="values">Массив строк для слияния в текстовое сообщение записи журнала событий.</param>
        <summary>Вносит в журнал событий запись с заданными данными сообщения, строками замещения сообщения и связанными двоичными данными, используя указанный зарегистрированный источник событий.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для записи локализованной записи с дополнительными данными о событиях в журнал событий, используя источник, уже зарегистрированный в качестве источника событий для соответствующего журнала. Свойства событий задаются с помощью идентификаторов ресурсов, а не строковых значений. Просмотр событий использует идентификаторы ресурсов для вывода соответствующих строк из локализованного файла ресурсов для источника. Прежде чем записывать события с помощью идентификаторов ресурсов, необходимо зарегистрировать источник в соответствующем файле ресурсов.  
  
 Входной `instance` экземпляр указывает сообщение и свойства события. <xref:System.Diagnostics.EventInstance.InstanceId%2A> Задает вход для определенного сообщения в `instance`  файле ресурсов исходного сообщения. При необходимости можно задать <xref:System.Diagnostics.EventInstance.CategoryId%2A> и <xref:System.Diagnostics.EventInstance.EntryType%2A> `instance` для входных данных, чтобы определить категорию и тип события для записи события. Можно также указать массив строк, не зависящих от языка, для вставки в текст локализованного сообщения. Задайте `values` значение `null` , если сообщение о событии не содержит заполнителей форматирования для замещающих строк.  
  
 Укажите двоичные данные с событием, когда необходимо предоставить дополнительные сведения о событии. Например, используйте `data` параметр, чтобы включить сведения об определенной ошибке. Просмотр событий не интерпретирует связанные данные события; Он отображает данные в комбинированном шестнадцатеричном и текстовом формате. Используйте данные событий экономно. включайте его только в том случае, если вы уверены, что он будет полезен. Можно также использовать данные событий для хранения информации, которую приложение может обрабатывать независимо от Просмотр событий. Например, можно написать средство просмотра, предназначенное для событий, или написать программу, которая просматривает журнал событий и создает отчеты, содержащие сведения из данных, относящихся к конкретному событию.  
  
 Указанный источник должен быть зарегистрирован для журнала событий перед использованием <xref:System.Diagnostics.EventLog.WriteEvent%2A>. Указанный источник должен быть настроен для записи локализованных записей в журнал; для источника должно быть задано по меньшей мере файл ресурсов сообщения.  
  
 Перед записью первой записи с источником необходимо создать и настроить источник события. Создайте новый источник событий во время установки приложения. Это позволяет операционной системе обновлять свой список зарегистрированных источников событий и их конфигурацию. Если операционная система не обновила список источников событий и вы пытаетесь написать событие с новым источником, операция записи завершится ошибкой. Новый источник можно настроить с помощью <xref:System.Diagnostics.EventLogInstaller>или <xref:System.Diagnostics.EventLog.CreateEventSource%2A> с помощью метода. Для создания нового источника событий необходимо иметь права администратора на компьютере.  
  
 Источник должен быть настроен либо для записи локализованных записей, либо для записи прямых строк. Используйте метод <xref:System.Diagnostics.EventLog.WriteEntry%2A> , если приложение записывает строковые значения непосредственно в журнал событий.  
  
 Если приложение записывает записи, используя как идентификаторы ресурсов, так и строковые значения, необходимо зарегистрировать два отдельных источника. Например, можно настроить один источник с файлами ресурсов, а затем использовать этот источник в <xref:System.Diagnostics.EventLog.WriteEvent%2A> методе для записи записей, использующих идентификаторы ресурсов, в журнал событий. Затем создайте другой источник без файлов ресурсов и используйте этот источник в <xref:System.Diagnostics.EventLog.WriteEntry%2A> методе для записи строк непосредственно в журнал событий с помощью этого источника.  
  
   
  
## Examples  
 В следующем примере запись информационного события и запись события предупреждения записываются в существующий журнал событий. Текст сообщения о событии указывается с помощью идентификатора ресурса в файле ресурсов. В этом примере предполагается, что соответствующий файл ресурсов был зарегистрирован для источника.  
  
 [!code-cpp[EventLog_WriteEvent#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog_WriteEvent#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog_WriteEvent#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 В примере используется следующий текстовый файл сообщения, встроенный в библиотеку ресурсов Евентлогмсгс. dll. Текстовый файл сообщения — это источник, из которого создается файл ресурсов сообщения. В текстовом файле сообщения определяются идентификаторы ресурсов и текст для категории, сообщения о событии и строки вставки параметров.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значением <paramref name="source" /> является пустая строка ("").  
  
- или - 
Значение <paramref name="source" /> равно <see langword="null" />.  
  
- или - 
 <paramref name="instance.InstanceId" /> меньше нуля или больше <see cref="F:System.UInt16.MaxValue" />.  
  
- или - 
 <paramref name="values" /> содержит более 256 элементов.  
  
-или- 
Один из элементов <paramref name="values" /> длиннее 32766 байт.  
  
- или - 
При таком имени источника длина пути к разделу реестра превышает 254 символа.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="instance" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Не удается открыть раздел реестра для журнала событий.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Операционная система сообщила об ошибке при записи сведений о событии в журнал событий. Код ошибки Windows недоступен.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи сведений журнала событий на компьютере. Связанное перечисление:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
  </Members>
</Type>
