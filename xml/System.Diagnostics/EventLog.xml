<Type Name="EventLog" FullName="System.Diagnostics.EventLog">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8dbd7c54611eae4fc67bc3cfb380e97f4369f241" /><Meta Name="ms.sourcegitcommit" Value="1bb00d2f4343e73ae8d58668f02297a3cf10a4c1" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="06/15/2019" /><Meta Name="ms.locfileid" Value="63887936" /></Metadata><TypeSignature Language="C#" Value="public class EventLog : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventLog extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.EventLog" />
  <TypeSignature Language="VB.NET" Value="Public Class EventLog&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventLog : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type EventLog = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
      <AttributeName>System.ComponentModel.DefaultEvent("EntryWritten")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Diagnostics.EventLogInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.Diagnostics.MonitoringDescription("Represents an event log")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.EventLogInstallableComponentDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.MonitoringDescription("EventLogDesc")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Обеспечивает взаимодействие с журналами событий Windows.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog> Вы сможете получить доступ к или настроить журналы событий Windows, которые записываются сведения о важных событиях, связанных с оборудования и программного обеспечения. С помощью <xref:System.Diagnostics.EventLog>, можно читать существующие, добавлять записи в журнал, создание или удаление источников событий, удалять журналы и отвечать на записи журнала. Можно также создать новые журналы при создании источника события.  
  
> [!IMPORTANT]
>  Этот тип реализует интерфейс <xref:System.IDisposable>. По окончании использования выдаленную ему память следует прямо или косвенно освободить. Чтобы сделать это прямо, вызовите его метод <xref:System.IDisposable.Dispose%2A> в блоке `try`/`catch`. Чтобы сделать это косвенно, используйте языковые конструкции, такие как `using` (в C#) или `Using` (в Visual Basic). Дополнительные сведения см. в разделе "Использование объекта, реализующего IDisposable" в статье об интерфейсе <xref:System.IDisposable>.  
  
 Помимо предоставления доступа к отдельным журналы событий и записи их <xref:System.Diagnostics.EventLog> класс позволяет получить доступ к коллекции всех журналов событий. Можно использовать `static` членами <xref:System.Diagnostics.EventLog> удалять журналы, получить список журналов, создание или удаление источника или определить, если на компьютере уже есть определенного источника.  
  
 Существует три журнала событий по умолчанию. Приложения, система и безопасность. Журнал безопасности доступен только для чтения. Другими приложениями и службами, которые можно установить, например Active Directory, могут иметь дополнительные журналы событий.  
  
 Есть вопросы безопасности при использовании <xref:System.Diagnostics.EventLog> класса. <xref:System.Diagnostics.EventLog> требуется <xref:System.Diagnostics.EventLogPermission> разрешения для определенных действий в .NET Framework 2.0 и более поздних версий, или полного доверия в .NET Framework 1.0 и 1.1. Мы рекомендуем <xref:System.Diagnostics.EventLogPermission> не были предоставлены частично доверенным кодом.  Никогда не следует передавать любой объект журнала событий, включая <xref:System.Diagnostics.EventLogEntryCollection> и <xref:System.Diagnostics.EventLogEntry> объектов, менее доверенного кода. Например, создание <xref:System.Diagnostics.EventLog> объекта, записи элемента и затем передачу <xref:System.Diagnostics.EventLog> объект для частично доверенного кода можно создать угрозу безопасности, так как возможность чтения и записи в журнал событий позволяет коду выполнять действия, такие как выдача сообщения журнала событий имя другого приложения.  
  
 Начиная с Windows Vista, контроля учетных записей (UAC) определяет учетные данные пользователя. Члену встроенной группы "Администраторы" присваивается два маркера доступа на время выполнения: маркер доступа обычного пользователя и маркер доступа администратора. По умолчанию назначена роль обычного пользователя. Чтобы запустить код, который обращается к в журнал безопасности, необходимо сначала повысить свои учетные данные из обычного пользователя для администратора. Это можно сделать при запуске приложения, открыв контекстное меню для приложения (Если вы используете мышь, щелкните правой кнопкой мыши значок приложения) и означает, что вы хотите запустить от имени администратора.  
  
 Можно использовать <xref:System.Diagnostics.EventLog> для создания пользовательского журнала событий, которые можно просматривать через сервер в средстве просмотра событий. Используйте <xref:System.Diagnostics.EventLog.RegisterDisplayName%2A> метод для отображения локализованное имя для журнала событий в средстве просмотра событий. Используйте <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> метод, чтобы настроить поведение журнала событий, при достижении максимального размера.  
  
 Для чтения из журнала событий, укажите имя журнала (<xref:System.Diagnostics.EventLog.Log%2A> свойства) и имя сервера (<xref:System.Diagnostics.EventLog.MachineName%2A> свойство для журнала событий. Если не указать имя компьютера сервера, локального компьютера, «.», предполагается, что. Нет необходимости указать источник событий (<xref:System.Diagnostics.EventLog.Source%2A> свойство), так как источником является обязательным только для записи в журналы. <xref:System.Diagnostics.EventLog.Entries%2A> Автоматически заполняется список записей в журнале событий.  
  
 Для записи в журнал событий, указать или создать источник событий (<xref:System.Diagnostics.EventLog.Source%2A> свойство). Вам требуются права администратора на компьютере, чтобы создать новый источник событий. Источник события приложение регистрируется в журнале событий как источник записей. Источник события можно использовать для записи только один файл журнала за раз. <xref:System.Diagnostics.EventLog.Source%2A> Свойство может быть любой строкой, но имя должно отличаться от других источников на компьютере. Источник события, обычно — имя приложения или другой идентификатор. Попытка создать дубликат <xref:System.Diagnostics.EventLog.Source%2A> значение возникло исключение. Тем не менее один журнал событий можно связать с несколькими источниками.  
  
 Если источник события для журнала событий, связанная с <xref:System.Diagnostics.EventLog> экземпляр не существует, создается новый источник событий. Для создания источника событий в Windows Vista и более поздних версиях или Windows Server 2003, требуются права администратора.  
  
 Это требование обусловлено тем, необходимо произвести поиск во всех журналов событий, включая журналы безопасности, чтобы определить, является ли источник события уникальным. Начиная с Windows Vista, пользователи не имеют разрешения на доступ к журналу безопасности; Таким образом <xref:System.Security.SecurityException> возникает исключение.  
  
> [!IMPORTANT]
>  Создание или удаление источника событий требует синхронизации основного кода с помощью именованного мьютекса. Если приложение с высоким уровнем привилегий блокирует именованный мьютекс, попытка создания или удаления источника событий вызывает приложение перестает отвечать на запросы, пока блокировка снимается. Чтобы предотвратить эту проблему, никогда не предоставляйте <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> разрешение ненадежному коду. Кроме того <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> разрешение потенциально позволяет обойти другие разрешения и должны предоставляться только высоконадежным кода.  
  
 Приложения и службы следует записывать в журнал приложений или настраиваемого журнала. Драйверы устройств должен записывать в системный журнал. Если не задано явным образом <xref:System.Diagnostics.EventLog.Log%2A> свойство, по умолчанию в журнал событий в журнал приложений.  
  
> [!NOTE]
>  Нет ничего для защиты приложения от записи, как любой зарегистрированный источник.  Если приложению предоставляется <xref:System.Diagnostics.EventLogPermissionAccess.Write> разрешение, он может записывать события для любой допустимый источник, зарегистрированные на компьютере.  
  
 Используйте <xref:System.Diagnostics.EventLog.WriteEvent%2A> и <xref:System.Diagnostics.EventLog.WriteEntry%2A> методы для записи событий в журнал событий. Необходимо указать источник события для записи событий; необходимо создать и настроить источник события перед записью первой записи с источником.  
  
 Создайте новый источник событий во время установки приложения. Это экономит время ОС, чтобы обновить свой список зарегистрированных источников событий и их конфигурации. Если операционная система не обновляется список источников событий и предпринимается попытка записать событие с новым источником, операция записи завершится сбоем. Новый источник можно настроить с помощью <xref:System.Diagnostics.EventLogInstaller> объекта или <xref:System.Diagnostics.EventLog.CreateEventSource%2A> метод. Вам требуются права администратора на компьютере, чтобы создать новый источник событий.  
  
 Каждый источник можно написать только один журнал событий во время. Тем не менее приложение может использовать несколько источников для записи нескольких журналов событий. Например приложению может потребоваться несколько источников, настроенных для различных журналов событий или разным файлам ресурсов. Чтобы изменить сведения о конфигурации существующего источника, необходимо удалить источник и затем создать его с новой конфигурацией. Если другие приложения или компоненты используют существующий источник, создайте новый источник обновленной конфигурации вместо удаления существующего источника.  
  
 Для событий категории и сообщение строк можно зарегистрировать источник событий с локализованными ресурсами. Для внесения записей в журнале событий в приложении, с помощью идентификаторов ресурсов вместо указания сами строковые значения. Ссылаться на <xref:System.Diagnostics.EventLogInstaller> и <xref:System.Diagnostics.EventSourceCreationData> Дополнительные сведения о настройке источника с файлами ресурсов.  
  
 Если приложение записывает строковые значения непосредственно в журнал событий, у вас нет Установка свойств для источника для ресурса. Источник должен быть настроен для записи локализованных или исходных строк. Если приложение записывает операции, используя идентификаторы ресурсов и строковые значения, необходимо зарегистрировать два отдельных источника. Например, настроить один источник с файлами ресурсов, а затем использовать этот источник в <xref:System.Diagnostics.EventLog.WriteEvent%2A> метод для записи, используя идентификаторы ресурсов в журнале событий. Затем создайте другой источник без файлов ресурсов и использующих этот источник в <xref:System.Diagnostics.EventLog.WriteEntry%2A> метод для записи строк непосредственно в журнале событий, с помощью этого источника.  
  
 При записи события, по крайней мере необходимо указать строку сообщения или идентификатор ресурса для строки сообщения. Другие свойства событий являются необязательными. Следующие примеры необязательные параметры события.  
  
-   Можно задать <xref:System.Diagnostics.EventLogEntryType> указать значок, который отображает средство просмотра событий для записи.  
  
-   Можно указать идентификатор категории события, если приложение использует категории для фильтрации событий.  
  
-   Можно присоединить двоичных данных в запись события, если вы хотите связать Дополнительные сведения с данным событием.  
  
> [!IMPORTANT]
>  Ведение журнала событий требует места на диске, процессора и других системных ресурсов. Очень важно выполнять вход только важные сведения. Рекомендуется помещать вызовы журнала событий в путь ошибок вместо пути основной код, поэтому они не повредит производительности.  
  
 Список начальных значений свойств для экземпляра <xref:System.Diagnostics.EventLog>, см. в разделе <xref:System.Diagnostics.EventLog.%23ctor%2A> конструктор.  
  
   
  
## Examples  
 В следующем примере создается источник события `MySource` если он еще не существует и вносит запись в журнал событий `MyNewLog`.  
  
> [!NOTE]
>  Начиная с Windows Vista, это приложение необходимо запустить с правами администратора.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Diagnostics.EventLogInstaller" />
    <altmember cref="T:System.Diagnostics.EventLogEntry" />
    <altmember cref="T:System.Diagnostics.EntryWrittenEventArgs" />
    <altmember cref="T:System.ServiceProcess.ServiceBase" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Diagnostics.EventLog" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Diagnostics.EventLog" />. Не связывает экземпляр с каким-либо журналом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Перед вызовом <xref:System.Diagnostics.EventLog.WriteEntry%2A>, укажите <xref:System.Diagnostics.EventLog.Source%2A> свойство <xref:System.Diagnostics.EventLog> экземпляра. Если используется только для чтения <xref:System.Diagnostics.EventLog.Entries%2A> из журнала, можно указывать только <xref:System.Diagnostics.EventLog.Log%2A> и <xref:System.Diagnostics.EventLog.MachineName%2A> свойства.  
  
> [!NOTE]
>  Если вы не укажете <xref:System.Diagnostics.EventLog.MachineName%2A>, локальный компьютер (".») предполагается, что.  
  
 В следующей таблице представлены исходные значения свойств для экземпляра <xref:System.Diagnostics.EventLog>.  
  
|Свойство.|Начальное значение|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Пустая строка ("").|  
|<xref:System.Diagnostics.EventLog.Log%2A>|Пустая строка ("").|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|Локальный компьютер (».»).|  
  
   
  
## Examples  
 В следующем примере создается источник `MySource` если он еще не существует и вносит запись в журнал событий `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog logName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Имя журнала на локальном компьютере.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Diagnostics.EventLog" />. Связывает экземпляр с журналом на локальном компьютере.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка задает <xref:System.Diagnostics.EventLog.Log%2A> свойства `logName` параметра. Перед вызовом <xref:System.Diagnostics.EventLog.WriteEntry%2A>, укажите <xref:System.Diagnostics.EventLog.Source%2A> свойство <xref:System.Diagnostics.EventLog> экземпляра. Если используется только для чтения <xref:System.Diagnostics.EventLog.Entries%2A> из журнала, можно указывать только <xref:System.Diagnostics.EventLog.Log%2A> и <xref:System.Diagnostics.EventLog.MachineName%2A> свойства.  
  
> [!NOTE]
>  Если вы не укажете <xref:System.Diagnostics.EventLog.MachineName%2A>, локальный компьютер (".») предполагается, что. Эта перегрузка конструктора задает <xref:System.Diagnostics.EventLog.Log%2A> свойство, но вы можете изменить перед чтением <xref:System.Diagnostics.EventLog.Entries%2A> свойство.  
  
 Если источник, указываемое в <xref:System.Diagnostics.EventLog.Source%2A> из других источников на компьютере, последующий вызов свойства уникален <xref:System.Diagnostics.EventLog.WriteEntry%2A> создает журнал с указанным именем, если он еще не существует.  
  
 В следующей таблице представлены исходные значения свойств для экземпляра <xref:System.Diagnostics.EventLog>.  
  
|Свойство.|Начальное значение|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Пустая строка ("").|  
|<xref:System.Diagnostics.EventLog.Log%2A>|Параметр `logName`.|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|Локальный компьютер (».»).|  
  
   
  
## Examples  
 В следующем примере считываются записи в журнале событий «myNewLog», на локальном компьютере.  
  
 [!code-cpp[Classic EventLog.EventLog1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Имя журнала <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Недопустимое имя журнала.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string * string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog (logName, machineName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Имя журнала на указанном компьютере.</param>
        <param name="machineName">Компьютер, на котором существует журнал.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Diagnostics.EventLog" />. Связывает экземпляр с журналом на указанном компьютере.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка задает <xref:System.Diagnostics.EventLog.Log%2A> свойства `logName` параметр и <xref:System.Diagnostics.EventLog.MachineName%2A> свойства `machineName` параметра. Перед вызовом <xref:System.Diagnostics.EventLog.WriteEntry%2A>, укажите <xref:System.Diagnostics.EventLog.Source%2A> свойство <xref:System.Diagnostics.EventLog>. Если используется только для чтения <xref:System.Diagnostics.EventLog.Entries%2A> из журнала, можно указывать только <xref:System.Diagnostics.EventLog.Log%2A> и <xref:System.Diagnostics.EventLog.MachineName%2A> свойства.  
  
> [!NOTE]
>  Эта перегрузка конструктора задает <xref:System.Diagnostics.EventLog.Log%2A> и <xref:System.Diagnostics.EventLog.MachineName%2A> свойства, но можно изменить перед чтением <xref:System.Diagnostics.EventLog.Entries%2A> свойство.  
  
 В следующей таблице представлены исходные значения свойств для экземпляра <xref:System.Diagnostics.EventLog>.  
  
|Свойство.|Начальное значение|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Пустая строка ("").|  
|<xref:System.Diagnostics.EventLog.Log%2A>|Параметр `logName`.|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|Параметр `machineName`.|  
  
   
  
## Examples  
 В следующем примере считываются записи в журнале событий «myNewLog» на сервере «myServer».  
  
 [!code-cpp[Classic EventLog.EventLog2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Имя журнала <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Недопустимое имя журнала.  
  
 -или-  
  
 Недопустимое имя компьютера.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName, string source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName, string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String, machineName As String, source As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName, System::String ^ machineName, System::String ^ source);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string * string * string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog (logName, machineName, source)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Имя журнала на указанном компьютере</param>
        <param name="machineName">Компьютер, на котором существует журнал.</param>
        <param name="source">Источник записей журнала событий.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Diagnostics.EventLog" />. Связывает экземпляр с журналом на указанном компьютере и создает или присваивает заданный источник классу <see cref="T:System.Diagnostics.EventLog" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор задает <xref:System.Diagnostics.EventLog.Log%2A> свойства `logName` параметра <xref:System.Diagnostics.EventLog.MachineName%2A> свойства `machineName` параметра и <xref:System.Diagnostics.EventLog.Source%2A> свойства `source` параметра. <xref:System.Diagnostics.EventLog.Source%2A> Свойство является обязательным при записи в журнал событий. Тем не менее если выполняется только чтение из журнала событий, только <xref:System.Diagnostics.EventLog.Log%2A> и <xref:System.Diagnostics.EventLog.MachineName%2A> свойства являются обязательными (поскольку журнал событий на сервере имеет источник, уже связанных с ним). Если вы не только для чтения из журнала событий, достаточно другую перегрузку конструктора.  
  
 В следующей таблице представлены исходные значения свойств для экземпляра <xref:System.Diagnostics.EventLog>.  
  
|Свойство.|Начальное значение|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Параметр `source`.|  
|<xref:System.Diagnostics.EventLog.Log%2A>|Параметр `logName`.|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|Параметр `machineName`.|  
  
   
  
## Examples  
 Следующий пример вносит запись в журнал событий «MyNewLog», на локальном компьютере, с помощью источника «MySource».  
  
 [!code-cpp[Classic EventLog.EventLog3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Имя журнала <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Недопустимое имя журнала.  
  
 -или-  
  
 Недопустимое имя компьютера.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="eventLog.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Начинает инициализацию класса <see cref="T:System.Diagnostics.EventLog" />, используемого в форме или используемого другим компонентом. Инициализация происходит во время выполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Разработки, среда использует этот метод для запуска инициализации компонента, используемого в форме или другим компонентом. <xref:System.Diagnostics.EventLog.EndInit%2A> Метод завершает инициализацию. С помощью <xref:System.Diagnostics.EventLog.BeginInit%2A> и <xref:System.Diagnostics.EventLog.EndInit%2A> методы предотвращения использования до полной инициализации элемента управления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Diagnostics.EventLog" /> уже инициализирован.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="eventLog.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет все записи из журнала событий.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Журналы событий задаются с помощью максимальный размер, который определяет количество записей, они могут содержать. При заполнении журнала событий, он прекращает запись новых событий или начинается перезапись предыдущих операций. Если запись событий остановится, этот метод можно использовать, чтобы очистить существующие записи из журнала и разрешить его, чтобы снова начать запись событий. Необходимо иметь разрешения администратора на компьютере, на котором находится журнал, чтобы очистить записи журнала событий.  
  
 <xref:System.Diagnostics.EventLog.Clear%2A> Закрывает журнал событий, удаляет дескрипторы событий, получает новые дескрипторы чтения и записи и снова открывает журнал событий. События, полученные после вызова метода, не удаляются вместе с существующих событий.  
  
   
  
## Examples  
 В следующем примере удаляется журнал событий.  
  
> [!CAUTION]
>  Так как приложения, системы, безопасности и другие, не настраиваемые журналы могут содержать важные сведения. не забудьте указать настраиваемый журнал перед выполнением этого примера кода. В этом примере удаляется настраиваемого журнала `myNewLog`.  
  
 [!code-cpp[Classic EventLog.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Создание журнала событий не было завершено успешно.  
  
 -или-  
  
 Невозможно открыть журнал. Код ошибки Windows недоступен.</exception>
        <exception cref="T:System.ArgumentException">Для свойства <see cref="P:System.Diagnostics.EventLog.Log" /> не указано значение. Убедитесь, что имя журнала — не пустая строка.</exception>
        <exception cref="T:System.InvalidOperationException">Журнал не существует.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для администрирования данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="eventLog.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Закрывает журнал событий и удаляет дескрипторы чтения и записи.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog.Close%2A> Вызывается метод защищенным <xref:System.ComponentModel.Component.Dispose%2A> метод. Необходимо вызвать <xref:System.Diagnostics.EventLog.Close%2A> перед вызовом <xref:System.ComponentModel.Component.Dispose%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Дескриптор чтения или записи события не был успешно удален.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateEventSource">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Задает приложение как источник записей для определенного журнала событий в системе.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (System.Diagnostics.EventSourceCreationData sourceData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(class System.Diagnostics.EventSourceCreationData sourceData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (sourceData As EventSourceCreationData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::Diagnostics::EventSourceCreationData ^ sourceData);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : System.Diagnostics.EventSourceCreationData -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource sourceData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceData" Type="System.Diagnostics.EventSourceCreationData" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="sourceData">Свойства конфигурации для источника событий и его целевого журнала событий.</param>
        <summary>Задает допустимый источник событий для записи локализованных сообщений о событиях, используя указанные свойства конфигурации источника событий и соответствующий журнал событий.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка позволяет задать параметры нового источника для внесения записей в журнал событий на локальном компьютере или удаленном компьютере. Это не обязательно использовать этот метод для чтения из журнала событий.  
  
 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Метод использует входные данные `sourceData` <xref:System.Diagnostics.EventSourceCreationData.Source%2A>, <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> и <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> свойства для создания значения реестра на конечном компьютере для нового источника и ее связанный журнал событий. Имя нового источника не может совпадать с существующим именем источника или с существующим именем журнала событий, на целевом компьютере. Если <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> свойство не задано, источник зарегистрирован в журнале событий приложений. Если <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> не задано, источник зарегистрирован на локальном компьютере.  
  
> [!NOTE]
>  Для создания источника событий в Windows Vista и более поздних версиях или Windows Server 2003, необходимо иметь права администратора.  
>   
>  Это требование связано что всех журналов событий, включая безопасность, должно осуществляться до определения уникальности источника события. Начиная с Windows Vista, пользователи не имеют разрешения на доступ к журналу безопасности; Таким образом <xref:System.Security.SecurityException> возникает исключение.  
>   
>  Начиная с Windows Vista, привилегии пользователя определяются контроля учетных записей (UAC). Члену встроенной группы "Администраторы" присваивается два маркера доступа на время выполнения: маркер доступа обычного пользователя и маркер доступа администратора. По умолчанию назначена роль обычного пользователя. Для выполнения кода, который обращается к в журнал безопасности, необходимо сначала повысить свои привилегии от обычного пользователя до администратора. Это можно сделать при запуске приложения, , щелкнув значок приложения правой кнопкой мыши и указав, что приложение должно запускаться от имени администратора.  
  
 Используйте <xref:System.Diagnostics.EventLog.WriteEvent%2A> и <xref:System.Diagnostics.EventLog.WriteEntry%2A> для записи событий в журнал событий. Необходимо указать источник события для записи событий; необходимо создать и настроить источник события перед записью первой записи с источником.  
  
 Создайте новый источник событий во время установки приложения. Это экономит время ОС, чтобы обновить свой список зарегистрированных источников событий и их конфигурации. Если операционная система не обновлялись свой список источников событий и предпринимается попытка записать событие с новым источником, операция записи завершится сбоем. Можно настроить нового источника при помощи <xref:System.Diagnostics.EventLogInstaller>, или с помощью <xref:System.Diagnostics.EventLog.CreateEventSource%2A> метод. Вам необходимы права администратора на компьютере, чтобы создать новый источник событий.  
  
 Можно создать источник событий для существующего журнала событий или журнала событий. При создании нового источника для нового журнала событий система регистрирует источник для этого журнала, но журнал не создается, пока на него будут записаны первой записи.  
  
 Журналы событий сохраняются операционной системой как файлы. При использовании <xref:System.Diagnostics.EventLogInstaller> или <xref:System.Diagnostics.EventLog.CreateEventSource%2A> для создания нового журнала событий, связанный файл сохраняется в каталоге %SystemRoot%\System32\Config на указанном компьютере. Имя файла имеет значение, добавив первые 8 символов <xref:System.Diagnostics.EventLog.Log%2A> свойство с расширением «.evt».  
  
 Каждый источник может записывать только один журнал событий только во время. Тем не менее приложение может использовать несколько источников для записи нескольких журналов событий. Например приложению может потребоваться несколько источников, настроенных для различных журналов событий или разным файлам ресурсов.  
  
 С локализованными файлами ресурсов можно зарегистрировать источник событий для событий категории и сообщение строк. Для внесения записей в журнале событий с использованием идентификаторов ресурсов вместо указания фактической строкой в приложении. Средство просмотра событий использует идентификатор ресурса для поиска и отображения соответствующей строки из локализованного файла ресурсов на основе текущих настроек языка. Можно зарегистрировать отдельный файл для категории событий, сообщения и строки вставки параметров, или же файл ресурсов для всех трех типов строк можно зарегистрировать. Используйте <xref:System.Diagnostics.EventSourceCreationData.CategoryCount%2A>, <xref:System.Diagnostics.EventSourceCreationData.CategoryResourceFile%2A>, <xref:System.Diagnostics.EventSourceCreationData.MessageResourceFile%2A>, и <xref:System.Diagnostics.EventSourceCreationData.ParameterResourceFile%2A> свойства для настройки источника локализованные записи в журнале событий. Если приложение записывает значения строк непосредственно в журнал событий, вы не обязательно должны задать эти свойства.  
  
 Источник должен быть настроен для записи локализованных или исходных строк. Если приложение записывает операции, используя идентификаторы ресурсов и строковые значения, необходимо зарегистрировать два отдельных источника. Например, настроить один источник с файлами ресурсов, а затем использовать этот источник в <xref:System.Diagnostics.EventLog.WriteEvent%2A> метод для записи, используя идентификаторы ресурсов в журнале событий. Затем создайте другой источник без файлов ресурсов и использующих этот источник в <xref:System.Diagnostics.EventLog.WriteEntry%2A> метод для записи строк непосредственно в журнале событий, с помощью этого источника.  
  
 Чтобы изменить сведения о конфигурации существующего источника, необходимо удалить источник и затем создать его с новой конфигурацией. Если другие приложения или компоненты используют существующий источник, создайте новый источник с обновленной конфигурации, вместо удаления существующего источника.  
  
> [!NOTE]
>  Если источник настроен для журнала событий и изменение его конфигурации для другой журнал событий, необходимо перезапустить компьютер, чтобы изменения вступили в силу.  
  
   
  
## Examples  
 В следующем примере определяется, является ли источник события с именем `SampleApplicationSource` зарегистрирован на локальном компьютере. Если источник событий не существует, в примере задает файле ресурсов сообщения для источника и создается новый источник событий. Наконец, пример задает локализованное отображаемое имя для журнала событий, используя значение идентификатора ресурса в `DisplayNameMsgId` и путь к файлу ресурсов в `messageFile`.  
  
 [!code-cpp[EventLog_WriteEvent#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog_WriteEvent#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog_WriteEvent#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 В примере используется следующий текстовый файл сообщения, встроенный в библиотеку ресурсов EventLogMsgs.dll. Текстовый файл сообщения — источник, из которого создается файле ресурсов сообщения. В текстовом файле сообщения определяет, идентификаторы ресурсов и текст категории, сообщения о событии и строки вставки параметров. В частности идентификатор ресурса 5001 определен для локализованное имя журнала событий.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Имя компьютера, заданное в <paramref name="sourceData" />, недопустимо.  
  
-или- 
Имя источника, указанное в параметре <paramref name="sourceData" />, равно <see langword="null" />.  
  
-или- 
Имя журнала, заданное в <paramref name="sourceData" /> недопустимо. Имена журналов событий должны содержать печатные символы и не должны содержать символы "*", "?" или "\\".  
  
-или- 
Имя журнала, заданное в <paramref name="sourceData" />, недопустимо для создания пользовательского журнала. Имена AppEvent, SysEvent и SecEvent зарезервированы для системного использования.  
  
-или- 
Имя журнала совпадает с существующим именем источника событий.  
  
-или- 
При таком имени источника, заданном в <paramref name="sourceData" />, длина пути к разделу реестра превышает 254 символа.  
  
-или- 
Первые 8 символов имени журнала, заданные в <paramref name="sourceData" />, не уникальны.  
  
-или- 
Имя источника, заданное в <paramref name="sourceData" />, уже зарегистрировано.  
  
-или- 
Имя источника, заданное в <paramref name="sourceData" />, совпадает с существующим именем журнала событий.</exception>
        <exception cref="T:System.InvalidOperationException">Не удается открыть раздел реестра для журнала событий.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceData" /> — <see langword="null" />.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для администрирования данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.EventSourceCreationData" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="T:System.Diagnostics.EventLogInstaller" />
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (source As String, logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::String ^ source, System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource (source, logName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Имя источника, по которому приложение регистрируется на локальном компьютере.</param>
        <param name="logName">Имя журнала, в который вносятся записи о событиях источника. Допустимые значения: Application, System или имя пользовательского журнала событий.</param>
        <summary>Задает указанное имя источника в качестве допустимого источника событий для внесения записей в журнал на локальном компьютере. Используя этот метод, можно также создать новый пользовательский журнал на локальном компьютере.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод для создания настраиваемого журнала создать и зарегистрировать <xref:System.Diagnostics.EventLog.Source%2A> в существующий журнал на локальном компьютере.  
  
 Если `logName` — `null` или является пустой строкой ("») при вызове <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, по умолчанию будет использоваться в журнал приложений. Если журнал существует на локальном компьютере, система создаст настраиваемый журнал и регистрирует приложение в качестве <xref:System.Diagnostics.EventLog.Source%2A> для этого журнала.  
  
> [!NOTE]
>  Для создания источника событий в Windows Vista и более поздних версиях или Windows Server 2003, необходимо иметь права администратора.  
>   
>  Это требование связано что всех журналов событий, включая безопасность, должно осуществляться до определения уникальности источника события. Начиная с Windows Vista, пользователи не имеют разрешения на доступ к журналу безопасности; Таким образом <xref:System.Security.SecurityException> возникает исключение.  
>   
>  В Windows Vista и более поздних версиях права доступа пользователя определяются контролем учетных записей. Члену встроенной группы "Администраторы" присваивается два маркера доступа на время выполнения: маркер доступа обычного пользователя и маркер доступа администратора. По умолчанию назначена роль обычного пользователя. Для выполнения кода, который обращается к в журнал безопасности, необходимо сначала повысить свои привилегии от обычного пользователя до администратора. Это можно сделать при запуске приложения, , щелкнув значок приложения правой кнопкой мыши и указав, что приложение должно запускаться от имени администратора.  
  
 Необходимо создать источник событий, при записи в журнал событий. Прежде чем вносить записи в журнал событий, необходимо зарегистрировать источник событий с журналом событий как источник событий. При записи в журнал событий система использует <xref:System.Diagnostics.EventLog.Source%2A> для поиска журнала, в котором нужно сделать запись. Если выполняется чтение журнала событий, можно указать <xref:System.Diagnostics.EventLog.Source%2A>, или <xref:System.Diagnostics.EventLog.Log%2A> и <xref:System.Diagnostics.EventLog.MachineName%2A>.  
  
> [!NOTE]
>  Не обязательно указывать <xref:System.Diagnostics.EventLog.MachineName%2A> при подключении в журнал на локальном компьютере. Если вы не укажете <xref:System.Diagnostics.EventLog.MachineName%2A> при чтении журнала, локальный компьютер (".») предполагается, что.  
  
 Используйте <xref:System.Diagnostics.EventLog.WriteEvent%2A> и <xref:System.Diagnostics.EventLog.WriteEntry%2A> для записи событий в журнал событий. Необходимо указать источник события для записи событий; необходимо создать и настроить источник события перед записью первой записи с источником.  
  
 Создайте новый источник событий во время установки приложения. Это экономит время ОС, чтобы обновить свой список зарегистрированных источников событий и их конфигурации. Если операционная система не обновлялись свой список источников событий и предпринимается попытка записать событие с новым источником, операция записи завершится сбоем. Можно настроить нового источника при помощи <xref:System.Diagnostics.EventLogInstaller>, или с помощью <xref:System.Diagnostics.EventLog.CreateEventSource%2A> метод. Вам необходимы права администратора на компьютере, чтобы создать новый источник событий.  
  
 Можно создать источник событий для существующего журнала событий или журнала событий. При создании нового источника для нового журнала событий система регистрирует источник для этого журнала, но журнал не создается, пока на него будут записаны первой записи.  
  
 Журналы событий сохраняются операционной системой как файлы. При использовании <xref:System.Diagnostics.EventLogInstaller> или <xref:System.Diagnostics.EventLog.CreateEventSource%2A> для создания нового журнала событий, связанный файл сохраняется в каталоге %SystemRoot%\System32\Config на указанном компьютере. Имя файла имеет значение, добавив первые 8 символов <xref:System.Diagnostics.EventLog.Log%2A> свойство с расширением «.evt».  
  
 Источник должен быть уникальным на локальном компьютере. имя нового источника не может совпадать с существующим именем источника или с существующим именем журнала событий. Каждый источник можно написать только один журнал событий во время. Тем не менее приложение может использовать несколько источников для записи нескольких журналов событий. Например приложению может потребоваться несколько источников, настроенных для различных журналов событий или разным файлам ресурсов.  
  
 Источник должен быть настроен для записи локализованных или исходных строк. Если приложение записывает операции, используя идентификаторы ресурсов и строковые значения, необходимо зарегистрировать два отдельных источника. Например, настроить один источник с файлами ресурсов, а затем использовать этот источник в <xref:System.Diagnostics.EventLog.WriteEvent%2A> метод для записи, используя идентификаторы ресурсов в журнале событий. Затем создайте другой источник без файлов ресурсов и использующих этот источник в <xref:System.Diagnostics.EventLog.WriteEntry%2A> метод для записи строк непосредственно в журнале событий, с помощью этого источника.  
  
 Чтобы изменить сведения о конфигурации существующего источника, необходимо удалить источник и затем создать его с новой конфигурацией. Если другие приложения или компоненты используют существующий источник, создайте новый источник с обновленной конфигурации, вместо удаления существующего источника.  
  
> [!NOTE]
>  Если источник уже сопоставлен в журнал, и необходимо отобразить в новый журнал, необходимо перезапустить компьютер, чтобы изменения вступили в силу.  
  
   
  
## Examples  
 В следующем примере создается источник `MySource` если он еще не существует и вносит запись в журнал событий `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> является пустой строкой ("") или <see langword="null" />.  
  
-или- 
 <paramref name="logName" /> не является допустимым именем журнала событий. Имена журналов событий должны содержать печатные символы и не должны содержать символы "*", "?" или "\\".  
  
-или- 
 Значение <paramref name="logName" /> недопустимо для создания журнала пользователя. Имена AppEvent, SysEvent и SecEvent зарезервированы для системного использования.  
  
-или- 
Имя журнала совпадает с существующим именем источника событий.  
  
-или- 
При таком имени источника длина пути к разделу реестра превышает 254 символа.  
  
-или- 
Первые 8 символов <paramref name="logName" /> совпадают с первыми 8 символами имени существующего журнала событий.  
  
-или- 
Невозможно зарегистрировать источник, поскольку он уже существует на локальном компьютере.  
  
-или- 
Имя источника совпадает с существующим именем журнала событий.</exception>
        <exception cref="T:System.InvalidOperationException">Раздел реестра для журнала событий не может быть открыт на локальном компьютере.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для администрирования данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (source As String, logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::String ^ source, System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : string * string * string -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource (source, logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("use CreateEventSource(EventSourceCreationData) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2;netcore-3.0">
          <AttributeName>System.Obsolete("This method has been deprecated.  Please use System.Diagnostics.EventLog.CreateEventSource(EventSourceCreationData sourceData) instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="dotnet-plat-ext-3.0">
          <AttributeName>System.Obsolete("This method has been deprecated.  Please use System.Diagnostics.EventLog.CreateEventSource(EventSourceCreationData sourceData) instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Источник, по которому приложение регистрируется на указанном компьютере.</param>
        <param name="logName">Имя журнала, в который вносятся записи о событиях источника. Допустимые значения: Application, System или имя пользовательского журнала событий. Если значение не указано, то параметр <paramref name="logName" /> по умолчанию имеет значение Application.</param>
        <param name="machineName">Имя компьютера, на котором регистрируется источник событий, или значение ".", если используется локальный компьютер.</param>
        <summary>Устанавливает заданное имяисточника в качестве допустимого источника событий для внесения записей в журнал на указанном компьютере. Этот метод можно также использовать для создания нового пользовательского журнала на заданном компьютере.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод для создания настраиваемого журнала создать и зарегистрировать <xref:System.Diagnostics.EventLog.Source%2A> в существующий журнал на указанном компьютере.  
  
 Если `logName` — `null` или является пустой строкой ("») при вызове <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, по умолчанию будет использоваться в журнал приложений. Если журнал существует на указанном компьютере, система создаст настраиваемый журнал и регистрирует приложение в качестве <xref:System.Diagnostics.EventLog.Source%2A> для этого журнала.  
  
 Необходимо создать источник событий, при записи в журнал событий. Прежде чем вносить записи в журнал событий, необходимо зарегистрировать источник событий с журналом событий как источник событий. При записи в журнал событий система использует <xref:System.Diagnostics.EventLog.Source%2A> для поиска журнала, в котором нужно сделать запись. Если выполняется чтение журнала событий, можно указать <xref:System.Diagnostics.EventLog.Source%2A>, или <xref:System.Diagnostics.EventLog.Log%2A> и <xref:System.Diagnostics.EventLog.MachineName%2A>.  
  
> [!NOTE]
>  Для создания источника событий в Windows Vista и более поздних версиях или Windows Server 2003, необходимо иметь права администратора.  
>   
>  Это требование связано что всех журналов событий, включая безопасность, должно осуществляться до определения уникальности источника события. В Windows Vista и более поздних версий пользователи не имеют разрешения на доступ к журналу безопасности; Таким образом <xref:System.Security.SecurityException> возникает исключение.  
>   
>  В Windows Vista и более поздних версиях права доступа пользователя определяются контролем учетных записей. Члену встроенной группы "Администраторы" присваивается два маркера доступа на время выполнения: маркер доступа обычного пользователя и маркер доступа администратора. По умолчанию назначена роль обычного пользователя. Для выполнения кода, который обращается к в журнал безопасности, необходимо сначала повысить свои привилегии от обычного пользователя до администратора. Это можно сделать при запуске приложения, , щелкнув значок приложения правой кнопкой мыши и указав, что приложение должно запускаться от имени администратора.  
  
 Используйте <xref:System.Diagnostics.EventLog.WriteEvent%2A> и <xref:System.Diagnostics.EventLog.WriteEntry%2A> для записи событий в журнал событий. Необходимо указать источник события для записи событий; необходимо создать и настроить источник события перед записью первой записи с источником.  
  
 Создайте новый источник событий во время установки приложения. Это экономит время ОС, чтобы обновить свой список зарегистрированных источников событий и их конфигурации. Если операционная система не обновлялись свой список источников событий и предпринимается попытка записать событие с новым источником, операция записи завершится сбоем. Можно настроить нового источника при помощи <xref:System.Diagnostics.EventLogInstaller>, или с помощью <xref:System.Diagnostics.EventLog.CreateEventSource%2A> метод. Вам необходимы права администратора на компьютере, чтобы создать новый источник событий.  
  
 Можно создать источник событий для существующего журнала событий или журнала событий. При создании нового источника для нового журнала событий система регистрирует источник для этого журнала, но журнал не создается, пока на него будут записаны первой записи.  
  
 Журналы событий сохраняются операционной системой как файлы. При использовании <xref:System.Diagnostics.EventLogInstaller> или <xref:System.Diagnostics.EventLog.CreateEventSource%2A> для создания нового журнала событий, связанный файл сохраняется в каталоге %SystemRoot%\System32\Config на указанном компьютере. Имя файла имеет значение, добавив первые 8 символов <xref:System.Diagnostics.EventLog.Log%2A> свойство с расширением «.evt».  
  
 Источник должен быть уникальным на локальном компьютере. имя нового источника не может совпадать с существующим именем источника или с существующим именем журнала событий. Каждый источник можно написать только один журнал событий во время. Тем не менее приложение может использовать несколько источников для записи нескольких журналов событий. Например приложению может потребоваться несколько источников, настроенных для различных журналов событий или разным файлам ресурсов.  
  
 Источник должен быть настроен для записи локализованных или исходных строк. Если приложение записывает операции, используя идентификаторы ресурсов и строковые значения, необходимо зарегистрировать два отдельных источника. Например, настроить один источник с файлами ресурсов, а затем использовать этот источник в <xref:System.Diagnostics.EventLog.WriteEvent%2A> метод для записи, используя идентификаторы ресурсов в журнале событий. Затем создайте другой источник без файлов ресурсов и использующих этот источник в <xref:System.Diagnostics.EventLog.WriteEntry%2A> метод для записи строк непосредственно в журнале событий, с помощью этого источника.  
  
 Чтобы изменить сведения о конфигурации существующего источника, необходимо удалить источник и затем создать его с новой конфигурацией. Если другие приложения или компоненты используют существующий источник, создайте новый источник с обновленной конфигурации, вместо удаления существующего источника.  
  
> [!NOTE]
>  Если источник уже сопоставлен в журнал, и необходимо отобразить в новый журнал, необходимо перезапустить компьютер, чтобы изменения вступили в силу.  
  
   
  
## Examples  
 В следующем примере создается источник `MySource` на компьютере `MyServer`и вносит запись в журнал событий `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> не является допустимым именем компьютера.  
  
-или- 
 <paramref name="source" /> является пустой строкой ("") или <see langword="null" />.  
  
-или- 
 <paramref name="logName" /> не является допустимым именем журнала событий. Имена журналов событий должны содержать печатные символы и не должны содержать символы "*", "?" или "\\".  
  
-или- 
 Значение <paramref name="logName" /> недопустимо для создания журнала пользователя. Имена AppEvent, SysEvent и SecEvent зарезервированы для системного использования.  
  
-или- 
Имя журнала совпадает с существующим именем источника событий.  
  
-или- 
При таком имени источника длина пути к разделу реестра превышает 254 символа.  
  
-или- 
Первые 8 символов <paramref name="logName" /> совпадают с первыми 8 символами имени существующего журнала событий на указанном компьютере.  
  
-или- 
Невозможно зарегистрировать источник, так как он уже существует на заданном компьютере.  
  
-или- 
Имя источника совпадает с существующим именем источника событий.</exception>
        <exception cref="T:System.InvalidOperationException">Раздел реестра для журнала событий не может быть открыт на указанном компьютере.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для администрирования данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Delete">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Удаляет ресурс журнала.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.Diagnostics.EventLog.Delete logName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Имя удаляемого журнала. Возможные значения: Application, Security, System или имя пользовательского журнала событий на компьютере.</param>
        <summary>Удаляет журнал событий с локального компьютера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод следует используйте, когда журнал, который вы хотите удалить на локальном компьютере. Вы можете удалить любой журнал на компьютере, при наличии необходимых разрешений для реестра.  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> Удаляет журнал `logName` с локального компьютера. Если вы хотите удалить только источник зарегистрирован в журнал, вызовите <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. Если требуется удалить записи журнала, вызвать <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A> и <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> являются `static` методы, поэтому они могут вызываться в самом классе. Нет необходимости создавать новый экземпляр класса <xref:System.Diagnostics.EventLog> для вызова любого из этих методов.  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> Метод сначала удаляет файл, содержащий содержимое журнала. Затем открывает реестр и удалить все источники событий, зарегистрированные для этого журнала. При повторном создании журнала позднее, следует производить регистрацию источников событий снова, если они будут использоваться повторно. Если не следует регистрировать источники событий и других пользователей записи на источник события, не указывая имя журнала, источник событий будет создан в журнале событий приложений. Таким образом приложений, которые ранее были возможность записи в журнал, вы удалили и заново будет записывать в журнал приложений вместо этого, так как он теперь содержит источник событий.  
  
> [!NOTE]
>  Повторное создание журнала событий может быть нелегко. Избегайте удалил ни один из созданных системой журналы событий, например в журнал приложений.  
  
 Удаление журнала с помощью вызова <xref:System.Diagnostics.EventLog.Delete%2A> автоматически удаляет источниках, зарегистрированных в этот журнал. Это может усложнить другие приложения, использующие этот журнал неработоспособен.  
  
   
  
## Examples  
 В следующем примере удаляется журнал на локальном компьютере. В примере определяется журнала от источника.  
  
> [!NOTE]
>  Больше одного источника может записать в журнал событий. Прежде чем удалить пользовательский журнал, убедитесь, что нет других источников, запись в этот журнал.  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="logName" /> является пустой строкой ("") или <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Раздел реестра для журнала событий не может быть открыт на локальном компьютере.  
  
-или-
  
 Журнала на локальном компьютере не существует.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Создание журнала событий не было завершено успешно.  
  
 -или-  
  
 Невозможно открыть журнал. Код ошибки Windows недоступен.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для администрирования данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member Delete : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.Delete (logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Имя удаляемого журнала. Возможные значения: Application, Security, System или имя пользовательского журнала событий на компьютере.</param>
        <param name="machineName">Имя компьютера, с которого удаляется журнал, или значение ".", если используется локальный компьютер.</param>
        <summary>Удаляет журнал событий с указанного компьютера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод следует используйте, когда журнал, который вы хотите удалить на удаленном компьютере. Вы можете удалить любой журнал на компьютере, при наличии необходимых разрешений для реестра.  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> Удаляет журнал `logName` из компьютеру, заданному параметром `machineName`. Если вы хотите удалить только источник зарегистрирован в журнал, вызовите <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. Если требуется удалить записи журнала, вызвать <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A> и <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> являются `static` методы, поэтому они могут вызываться в самом классе. Нет необходимости создания экземпляра <xref:System.Diagnostics.EventLog> для вызова любого из этих методов.  
  
 Этот метод сначала удаляет файл, содержащий содержимое журнала. Затем открывает реестр и удалить все источники событий, зарегистрированные для этого журнала. При повторном создании журнала позднее, следует производить регистрацию источников событий снова, если они будут использоваться повторно. Если не следует регистрировать источники событий и других пользователей записи на источник события, не указывая имя журнала, источник событий будет создан в журнале событий приложений. Таким образом приложений, которые ранее были возможность записи в журнал, вы удалили и заново будет записывать в журнал приложений вместо этого, так как он теперь содержит источник событий.  
  
> [!NOTE]
>  Повторное создание журнала событий может быть нелегко. Избегайте удалил ни один из созданных системой журналы событий, например в журнал приложений.  
  
 Удаление журнала с помощью вызова <xref:System.Diagnostics.EventLog.Delete%2A> автоматически удаляет источниках, зарегистрированных в этот журнал. Это может усложнить другие приложения, использующие этот журнал неработоспособен.  
  
   
  
## Examples  
 В следующем примере удаляется журнал с указанного компьютера. В примере определяется журнала от источника.  
  
> [!NOTE]
>  Больше одного источника может записать в журнал событий. Прежде чем удалить пользовательский журнал, убедитесь, что нет других источников, запись в этот журнал.  
  
 [!code-cpp[Classic EventLog.Delete1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="logName" /> является пустой строкой ("") или <see langword="null" />.  
  
-или- 
 Параметр <paramref name="machineName" /> не является допустимым именем компьютера.</exception>
        <exception cref="T:System.InvalidOperationException">Раздел реестра для журнала событий не может быть открыт на указанном компьютере.  
  
-или-
  
 Журнала на указанном компьютере не существует.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Создание журнала событий не было завершено успешно.  
  
 -или-  
  
 Невозможно открыть журнал. Код ошибки Windows недоступен.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для администрирования данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteEventSource">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Удаляет из журнала событий регистрацию источника событий приложения.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteEventSource (source As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteEventSource(System::String ^ source);" />
      <MemberSignature Language="F#" Value="static member DeleteEventSource : string -&gt; unit" Usage="System.Diagnostics.EventLog.DeleteEventSource source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Имя, с которым приложение регистрируется в журнале событий системы.</param>
        <summary>Удаляет регистрацию источника событий из журнала событий на локальном компьютере.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод позволяет удалить регистрацию <xref:System.Diagnostics.EventLog.Source%2A> с локального компьютера. <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> обращается к реестра на локальном компьютере, а также удаляется регистрация приложения в качестве допустимого источника событий.  
  
 Если вы больше не нужны для записи в этот журнал, можно удалить компонент как источник событий. Например вы делается, если необходимо перенести компонент из одного журнала на другой. Так как источник может быть зарегистрирован только в один файл журнала за раз, изменения в журнал необходимо удалять текущую регистрацию.  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> Удаляет только источник, зарегистрированного в журнале. Если вы хотите удалить журнал, вызовите <xref:System.Diagnostics.EventLog.Delete%2A>. Если требуется удалить записи журнала, вызвать <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A> и <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> являются `static` методы, поэтому они могут вызываться в самом классе. Нет необходимости создания экземпляра <xref:System.Diagnostics.EventLog> для вызова любого из этих методов.  
  
 Удаление журнала с помощью вызова <xref:System.Diagnostics.EventLog.Delete%2A> автоматически удаляет источниках, зарегистрированных в этот журнал. Это может усложнить другие приложения, использующие этот журнал неработоспособен.  
  
> [!NOTE]
>  Если источник уже сопоставлен в журнал, и необходимо отобразить в новый журнал, необходимо перезапустить компьютер, чтобы изменения вступили в силу.  
  
   
  
## Examples  
 В следующем примере удаляется источник с локального компьютера. Пример определяет журнала от источника, а затем удаляет журнала.  
  
> [!NOTE]
>  Больше одного источника может записать в журнал событий. Прежде чем удалить пользовательский журнал, убедитесь, что нет других источников, запись в этот журнал.  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="source" /> отсутствует в реестре локального компьютера.  
  
-или- 
Отсутствуют права на запись в раздел реестра для журнала событий.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для администрирования данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteEventSource (source As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteEventSource(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member DeleteEventSource : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.DeleteEventSource (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Имя, с которым приложение регистрируется в журнале событий системы.</param>
        <param name="machineName">Имя компьютера, с которого удаляется регистрация, или "." для локального компьютера.</param>
        <summary>Удаляет регистрацию источника событий приложения с указанного компьютера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод для удаления регистрации <xref:System.Diagnostics.EventLog.Source%2A> с удаленного компьютера. <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> обращается к реестра на компьютере, указанном `machineName` и удаляет регистрацию приложения в качестве допустимого источника событий.  
  
 Если вы больше не нужны для записи в этот журнал, можно удалить компонент как источник событий. Например вы делается, если необходимо перенести компонент из одного журнала на другой. Так как источник может быть зарегистрирован только в один файл журнала за раз, изменения в журнал необходимо удалять текущую регистрацию.  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> Удаляет только источник, зарегистрированного в журнале. Если вы хотите удалить журнал, вызовите <xref:System.Diagnostics.EventLog.Delete%2A>. Если требуется удалить записи журнала, вызвать <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A> и <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> являются `static` методы, поэтому они могут вызываться в самом классе. Нет необходимости создания экземпляра <xref:System.Diagnostics.EventLog> для вызова любого из этих методов.  
  
 Удаление журнала с помощью вызова <xref:System.Diagnostics.EventLog.Delete%2A> автоматически удаляет источниках, зарегистрированных в этот журнал. Это может усложнить другие приложения, использующие этот журнал неработоспособен.  
  
> [!NOTE]
>  Если источник уже сопоставлен в журнал, и необходимо отобразить в новый журнал, необходимо перезапустить компьютер, чтобы изменения вступили в силу.  
  
   
  
## Examples  
 В следующем примере удаляется источника с указанного компьютера. Пример определяет журнала от источника, а затем удаляет журнала.  
  
> [!NOTE]
>  Больше одного источника может записать в журнал событий. Прежде чем удалить пользовательский журнал, убедитесь, что нет других источников, запись в этот журнал.  
  
 [!code-cpp[Classic EventLog.Delete1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="machineName" /> является недопустимым.  
  
-или- 
Параметр <paramref name="source" /> отсутствует в реестре заданного компьютера.  
  
-или- 
Отсутствуют права на запись в раздел реестра для журнала событий.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> не может быть удален, так как в реестре, родительский раздел реестра <paramref name="source" /> не содержит подразделы с тем же именем.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для администрирования данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="eventLog.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Значение <see langword="true" /> позволяет освободить управляемые и неуправляемые ресурсы; значение <see langword="false" /> позволяет освободить только неуправляемые ресурсы.</param>
        <summary>Освобождает неуправляемые ресурсы, используемые журналом <see cref="T:System.Diagnostics.EventLog" />, и при необходимости освобождает также управляемые ресурсы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается открытым `Dispose()` метод и <xref:System.Object.Finalize%2A> метод. `Dispose()` вызывает защищенный `Dispose(Boolean)` метод с `disposing` параметру присвоить `true`. <xref:System.Object.Finalize%2A> вызывает `Dispose` с `disposing` присвоено `false`.  
  
 Когда `disposing` параметр имеет значение true, этот метод освобождает все ресурсы, занятые любыми управляемыми объектами, <xref:System.Diagnostics.EventLog> ссылки. Этот метод вызывает метод `Dispose()` каждого объекта, на который есть ссылка.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Метод 
            <see langword="Dispose" /> может вызываться несколько раз другими объектами. При переопределении метода <see langword="Dispose(Boolean)" /> нужно избегать ссылок на объекты, которые были уничтожены предыдущими вызовами <see langword="Dispose" />. Дополнительные сведения о том, как реализовать <see langword="Dispose(Boolean)" />, см. в разделе [реализация метода Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Дополнительные сведения о <see langword="Dispose" /> и <see cref="M:System.Object.Finalize" />, см. в разделе [очистки неуправляемых ресурсов](~/docs/standard/garbage-collection/unmanaged.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.Diagnostics.EventLog.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("If enabled raises event when a log is written.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogMonitoring")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, определяющее, получает ли класс <see cref="T:System.Diagnostics.EventLog" /> уведомления о событии <see cref="E:System.Diagnostics.EventLog.EntryWritten" />.</summary>
        <value>Значение <see langword="true" />, если класс <see cref="T:System.Diagnostics.EventLog" /> получает уведомления при внесении записи в журнал; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> Свойство определяет, является ли <xref:System.Diagnostics.EventLog> инициирует события при записи в журнал. Если это свойство имеет `true`, компонентов, получающих <xref:System.Diagnostics.EventLog.EntryWritten> событий будет получать уведомления об любое время записи в журнал, который указан в <xref:System.Diagnostics.EventLog.Log%2A> свойство. Если <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> является `false`, события не возникают.  
  
> [!NOTE]
>  Вы можете получать уведомления о событиях, только в том случае, если запись вносится в журнал на локальном компьютере. Вы не сможете получать уведомления для записей на удаленных компьютерах.  
  
   
  
## Examples  
 В следующем примере показана обработка <xref:System.Diagnostics.EventLog.EntryWritten> событий.  
  
 [!code-cpp[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Журнал событий на удаленном компьютере.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="E:System.Diagnostics.EventLog.EntryWritten" />
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="eventLog.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Завершает инициализацию класса <see cref="T:System.Diagnostics.EventLog" />, используемого в форме или другим компонентом. Инициализация происходит во время выполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Разработки, среда использует этот метод для завершения инициализации компонента, используемого в форме или другим компонентом. <xref:System.Diagnostics.EventLog.BeginInit%2A> Метод начинает инициализацию. С помощью <xref:System.Diagnostics.EventLog.BeginInit%2A> и <xref:System.Diagnostics.EventLog.EndInit%2A> методы предотвращает использование до полной инициализации элемента управления.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="Entries">
      <MemberSignature Language="C#" Value="public System.Diagnostics.EventLogEntryCollection Entries { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.EventLogEntryCollection Entries" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Entries" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Entries As EventLogEntryCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::EventLogEntryCollection ^ Entries { System::Diagnostics::EventLogEntryCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Entries : System.Diagnostics.EventLogEntryCollection" Usage="System.Diagnostics.EventLog.Entries" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The entries in the log.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogEntries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLogEntryCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает содержимое журнала событий.</summary>
        <value>Класс <see cref="T:System.Diagnostics.EventLogEntryCollection" />, в котором хранятся записи журнала событий. Каждая запись связана с экземпляром класса <see cref="T:System.Diagnostics.EventLogEntry" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Diagnostics.EventLog.Entries%2A> члена при чтении из журнала событий.  
  
 Так как свойство только для чтения, нельзя изменить запись или запись журнала с помощью <xref:System.Diagnostics.EventLog.Entries%2A>. Вместо этого укажите <xref:System.Diagnostics.EventLog.Source%2A> и вызвать <xref:System.Diagnostics.EventLog.WriteEntry%2A> записываемый новую запись журнала. Можно использовать <xref:System.Diagnostics.EventLog.Entries%2A> для подсчета числа записей в журнале событий, а также для просмотра <xref:System.Diagnostics.EventLogEntry> в коллекции. Использовать индексированное <xref:System.Diagnostics.EventLogEntryCollection.Item%2A> член для получения сведений о конкретной операции, такие как <xref:System.Diagnostics.EventLogEntry.Message%2A>, <xref:System.Diagnostics.EventLogEntry.Category%2A>, <xref:System.Diagnostics.EventLogEntry.TimeWritten%2A>, или <xref:System.Diagnostics.EventLogEntry.EntryType%2A>.  
  
 Это не обязательно указывать <xref:System.Diagnostics.EventLog.Source%2A> при чтении журнала. Можно указать только <xref:System.Diagnostics.EventLog.Log%2A> имя и <xref:System.Diagnostics.EventLog.MachineName%2A> свойства (имя сервера) для <xref:System.Diagnostics.EventLog> экземпляра. В любом случае <xref:System.Diagnostics.EventLog.Entries%2A> член автоматически заполняется список записей в журнале событий. В этом списке для чтения отдельных записей, можно выбрать соответствующий индекс для элемента.  
  
 — Это важное различие между чтением и записью в журнал, что нет необходимости явно вызвать метод read. После <xref:System.Diagnostics.EventLog.Log%2A> и <xref:System.Diagnostics.EventLog.MachineName%2A> указаны, <xref:System.Diagnostics.EventLog.Entries%2A> свойство заполняется автоматически. Если изменить значение <xref:System.Diagnostics.EventLog.Log%2A> или <xref:System.Diagnostics.EventLog.MachineName%2A> свойства <xref:System.Diagnostics.EventLog.Entries%2A> свойство не будет заполнен повторно при следующем чтении его.  
  
> [!NOTE]
>  Не обязательно указывать <xref:System.Diagnostics.EventLog.MachineName%2A> при подключении в журнал. Если вы не укажете <xref:System.Diagnostics.EventLog.MachineName%2A>, локальный компьютер «.», предполагается, что.  
  
   
  
## Examples  
 В следующем примере считываются записи в журнале событий «MyNewLog», на локальном компьютере.  
  
 [!code-cpp[Classic EventLog.Entries Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Entries Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Entries Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">для администрирования данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryCollection" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
      </Docs>
    </Member>
    <Member MemberName="EntryWritten">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.EntryWrittenEventHandler EntryWritten;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.EntryWrittenEventHandler EntryWritten" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.EventLog.EntryWritten" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event EntryWritten As EntryWrittenEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::EntryWrittenEventHandler ^ EntryWritten;" />
      <MemberSignature Language="F#" Value="member this.EntryWritten : System.Diagnostics.EntryWrittenEventHandler " Usage="member this.EntryWritten : System.Diagnostics.EntryWrittenEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Raised for each EventLog entry written.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogEntryWritten")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EntryWrittenEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при внесении записи в журнал событий на локальном компьютере.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для получения уведомлений о событиях, необходимо задать <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> для `true`. Уведомления о событиях можно получать только в том случае, если запись вносится в журнал на локальном компьютере. Вы не сможете получать уведомления для записей на удаленных компьютерах.  
  
 При создании делегата <xref:System.Diagnostics.EventLog.EntryWritten> определяется метод обработки события. Чтобы связать событие с обработчиком событий, нужно добавить в событие экземпляр делегата. Обработчик событий вызывается всякий раз, когда происходит событие, пока вы не удалите делегат. Дополнительные сведения об обработке событий с делегатами, см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Система реагирует на <xref:System.Diagnostics.EventLog.WriteEntry%2A> только в том случае, если последняя запись события произошла ранее по крайней мере шесть секунд. Это означает, что вы получите только один <xref:System.Diagnostics.EventLog.EntryWritten> уведомления о событии в течение интервала шести секунд, даже если изменение журнала более чем одно событие происходит. Если вы вставите увеличить интервал (около 10 секунд) между вызовами <xref:System.Diagnostics.EventLog.WriteEntry%2A>, вероятность недопустима. Тем не менее если запись событий происходит чаще, можно не получить уведомление о событии до следующего интервала. Как правило пропущенные уведомления о событиях не потеряны, но задержка.  
  
   
  
## Examples  
 В следующем примере обрабатывается записи события.  
  
 [!code-cpp[Classic EventLog.EntryWritten Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EntryWritten Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EntryWritten Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">для администрирования данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.EnableRaisingEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Exists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Определяет существование указанного журнала.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (logName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.Diagnostics.EventLog.Exists logName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Имя журнала, который нужно найти. Возможные значения: Application, Security, System, имена журналов определенных приложений (например службы каталогов Active Directory) или имя любого пользовательского журнала на компьютере.</param>
        <summary>Определяет наличие журнала на локальном компьютере.</summary>
        <returns>Значение <see langword="true" />, если журнал существует на локальном компьютере; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод позволяет определить, существует ли журнал на локальном компьютере. Если вы хотите определить, существует ли на локальном компьютере, используйте источник <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
 Так как этот метод обращается к реестру, необходимо иметь необходимых разрешений для реестра на локальном компьютере; в противном случае запрос возвращает `false`.  
  
 Новый журнал не могут иметь имя существующего журнала на одном компьютере, используйте этот метод перед созданием нового журнала на предмет указанного `logName` уже существует на локальном компьютере. `logName` Параметр не учитывается регистр.  
  
 <xref:System.Diagnostics.EventLog.Exists%2A> является `static` метод, поэтому его можно вызывать в самом классе. Нет необходимости создания экземпляра <xref:System.Diagnostics.EventLog> для вызова <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
   
  
## Examples  
 [!code-cpp[EventLog_Exists_1#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_Exists_1/CPP/eventlog_exists_1.cpp#1)]
 [!code-csharp[EventLog_Exists_1#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_Exists_1/CS/eventlog_exists_1.cs#1)]
 [!code-vb[EventLog_Exists_1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_Exists_1/VB/eventlog_exists_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр logName принимает значение <see langword="null" /> или пустое значение.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для администрирования данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (logName As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member Exists : string * string -&gt; bool" Usage="System.Diagnostics.EventLog.Exists (logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Журнал, который нужно найти. Возможные значения: Application, Security, System, имена журналов определенных приложений (например службы каталогов Active Directory) или имя любого пользовательского журнала на компьютере.</param>
        <param name="machineName">Имя компьютера, на котором выполняется поиск журнала, или значение ".", если используется локальный компьютер.</param>
        <summary>Определяет наличие журнала на заданном компьютере.</summary>
        <returns>Значение <see langword="true" />, если журнал существует на заданном компьютере; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод позволяет определить, существует ли журнал на удаленном компьютере. Если вы хотите определить, существует ли источник на удаленном компьютере, используйте <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
 Так как этот метод обращается к реестру, необходимо иметь необходимых разрешений для реестра на заданном компьютере; в противном случае запрос возвращает `false`.  
  
 Новый журнал не могут иметь имя существующего журнала на одном компьютере, используйте этот метод перед созданием нового журнала на предмет один с указанным `logName` уже существует на сервере, заданный параметром `machineName` параметр. `logName` И `machineName` параметры не учитывают регистр.  
  
 <xref:System.Diagnostics.EventLog.Exists%2A> является `static` метод, поэтому его можно вызывать в самом классе. Нет необходимости создавать новый экземпляр класса <xref:System.Diagnostics.EventLog> для вызова <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Недопустимый формат параметра <paramref name="machineName" />. Убедитесь, что при поиске на компьютере используется правильный синтаксис.  
  
-или- 
Параметр <paramref name="logName" /> принимает значение <see langword="null" /> или пустое значение.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для администрирования данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEventLogs">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает массив журналов событий.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEventLogs () As EventLog()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::EventLog ^&gt; ^ GetEventLogs();" />
      <MemberSignature Language="F#" Value="static member GetEventLogs : unit -&gt; System.Diagnostics.EventLog[]" Usage="System.Diagnostics.EventLog.GetEventLogs " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Выполняет поиск всех журналов событий на локальном компьютере и создает массив объектов <see cref="T:System.Diagnostics.EventLog" />, содержащих список.</summary>
        <returns>Массив типа <see cref="T:System.Diagnostics.EventLog" />, представляющий журналы на локальном компьютере.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Массив <xref:System.Diagnostics.EventLog> объектов представляет собой моментальный снимок всех журналов событий на локальном компьютере при вызове <xref:System.Diagnostics.EventLog.GetEventLogs%2A> выполняется. Это не динамическую коллекцию, поэтому он не отражает создания журналов в режиме реального времени и удаления. Следует убедиться, что журналов в массиве существует до считывания или записи в него. Обычно, массив содержит по крайней мере три журнала: Приложения, система и безопасность. Если вы создали пользовательские журналы на локальном компьютере, они будут отображаться в массиве, а также.  
  
 Чтобы получить список журналов событий, необходимо иметь необходимых разрешений для реестра. Эти разрешения аналогичны используемым необходимые для вызова <xref:System.Diagnostics.EventLog.Exists%2A> и <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
   
  
## Examples  
 В следующем примере перечисляются журналы событий, определенных на локальном компьютере и отображает сведения о конфигурации для каждого журнала событий.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">Отсутствуют права на доступ к реестру.  
  
 -или-  
  
 На компьютере отсутствует служба журнала событий.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для администрирования данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEventLogs (machineName As String) As EventLog()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::EventLog ^&gt; ^ GetEventLogs(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetEventLogs : string -&gt; System.Diagnostics.EventLog[]" Usage="System.Diagnostics.EventLog.GetEventLogs machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Компьютер, на котором выполняется поиск журналов событий.</param>
        <summary>Выполняет поиск всех журналов событий на заданном компьютере и создает массив объектов <see cref="T:System.Diagnostics.EventLog" />, содержащих список.</summary>
        <returns>Массив типа <see cref="T:System.Diagnostics.EventLog" />, представляющий журналы на заданном компьютере.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Массив <xref:System.Diagnostics.EventLog> объектов представляет собой моментальный снимок всех журналов событий на компьютере, указанном `machineName` параметра при вызове <xref:System.Diagnostics.EventLog.GetEventLogs%2A> выполняется. Это не динамическую коллекцию, поэтому он не отражает создания журналов в режиме реального времени и удаления. Следует убедиться, что журналов в массиве существует до считывания или записи в него. Обычно, массив содержит по крайней мере три журнала: Приложения, система и безопасность. Если вы создали пользовательские журналы на указанном компьютере, они будут отображаться в массиве, а также.  
  
 <xref:System.Diagnostics.EventLog.GetEventLogs%2A> — `static` метод, поэтому он может быть вызван на <xref:System.Diagnostics.EventLog> сам по себе класс. Нет необходимости создания экземпляра <xref:System.Diagnostics.EventLog> объекта, чтобы сделать вызов метода.  
  
 Чтобы получить список журналов событий, необходимо иметь необходимых разрешений для реестра. Эти разрешения аналогичны используемым необходимые для вызова <xref:System.Diagnostics.EventLog.Exists%2A> и <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
   
  
## Examples  
 Следующий пример возвращает список журналов на сервере «myServer». Затем он выводит имя каждого журнала.  
  
 [!code-cpp[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="machineName" /> содержит недопустимое имя компьютера.</exception>
        <exception cref="T:System.InvalidOperationException">Отсутствуют права на доступ к реестру.  
  
 -или-  
  
 На компьютере отсутствует служба журнала событий.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для администрирования данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public string Log { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Log" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Log" />
      <MemberSignature Language="VB.NET" Value="Public Property Log As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Log { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Log : string with get, set" Usage="System.Diagnostics.EventLog.Log" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the log that is read and written.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogLog")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает имя журнала, из которого производится чтение или запись.</summary>
        <value>Имя журнала. Существуют следующие имена: журнал приложения, журнал системы, журнал безопасности или имя, указанное пользователем. Значение по умолчанию — пустая строка ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию на сервере существуют три файла журнала: Приложения, система и безопасность. Используйте файл журнала приложения, приложения и службы. Драйверы устройств используйте файл системного журнала. Когда аудит включен, система создает успешных и неудачных событий аудита в журнале безопасности. Если у вас есть другие приложения, например Active Directory на серверах Windows, могут существовать и другие файлы журналов. Кроме того можно создать файлы пользовательского журнала на локальном или удаленном компьютере. Пользовательские журналы помогут упорядочить записи, с большей детализацией, нежели компонентов записи событий в журнал приложений по умолчанию.  
  
> [!NOTE]
>  Имена журналов ограничено до восьми символов. В соответствии с системой, MyLogSample1 и MyLogSample2 — один журнал.  
  
 При записи в журнал событий, недостаточно для указания <xref:System.Diagnostics.EventLog.Log%2A> свойство. Необходимо связать <xref:System.Diagnostics.EventLog.Source%2A> свойство с ресурсом журнала событий, чтобы подключиться к определенному журналу событий. Это не обязательно указывать <xref:System.Diagnostics.EventLog.Source%2A> при чтении журнала, но источник события должна быть связана с ресурсом журнала событий в реестре сервера. Можно указать только <xref:System.Diagnostics.EventLog.Log%2A> имя и <xref:System.Diagnostics.EventLog.MachineName%2A> (имя сервера) для чтения из него.  
  
> [!NOTE]
>  Не обязательно указывать <xref:System.Diagnostics.EventLog.MachineName%2A> при подключении в журнал. Если вы не укажете <xref:System.Diagnostics.EventLog.MachineName%2A>, локальный компьютер (".») предполагается, что.  
  
 Если <xref:System.Diagnostics.EventLog.Source%2A> свойство не задано, вызов <xref:System.Diagnostics.EventLog.Log%2A> возвращает пустую строку, если <xref:System.Diagnostics.EventLog.Log%2A> не было задано явно (установив <xref:System.Diagnostics.EventLog.Log%2A> свойство, либо при помощи конструктора). Если <xref:System.Diagnostics.EventLog.Source%2A> был указан, <xref:System.Diagnostics.EventLog.Log%2A> возвращает имя журнала, для которой зарегистрирован этот источник.  
  
 Источник может быть зарегистрирован только в один файл журнала за раз. Если <xref:System.Diagnostics.EventLog.Source%2A> свойство задано для экземпляра <xref:System.Diagnostics.EventLog>, нельзя изменить <xref:System.Diagnostics.EventLog.Log%2A> свойства для этого <xref:System.Diagnostics.EventLog> не изменяя значение <xref:System.Diagnostics.EventLog.Source%2A> или вызова <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> первого. При изменении <xref:System.Diagnostics.EventLog.Log%2A> свойства после <xref:System.Diagnostics.EventLog.Source%2A> свойство было задано, записи, запись в журнал исключение.  
  
 Журналы событий сохраняются операционной системой как файлы. При использовании <xref:System.Diagnostics.EventLogInstaller> или <xref:System.Diagnostics.EventLog.CreateEventSource%2A> для создания нового журнала событий, связанный файл сохраняется в каталоге %SystemRoot%\System32\Config на указанном компьютере. Имя файла имеет значение, добавив первые 8 символов <xref:System.Diagnostics.EventLog.Log%2A> свойство с расширением «.evt».  
  
 Не удается создать новый журнал с помощью <xref:System.Diagnostics.EventLog.Log%2A> свойство отдельно (не указывая источник для журнала). Можно вызвать <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, передавая новый журнал с именем параметра, а затем вызвать <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. Тем не менее, обычно является целью для создания (и запись) новые имена журналов определенных приложений, или для чтения из существующих журналов.  
  
 Если <xref:System.Diagnostics.EventLog.Log%2A> значение изменяется, в журнал событий закрывается и освобождаются все дескрипторы событий.  
  
> [!CAUTION]
>  Если задать <xref:System.Diagnostics.EventLog.Log%2A> свойство имя журнала, который не существует, система присоединит <xref:System.Diagnostics.EventLog> в журнал приложений, но не предупреждает пользователя используйте журнал был указан.  
  
   
  
## Examples  
 В следующем примере считываются записи в журнале событий «NewEventLog», на локальном компьютере.  
  
 [!code-cpp[Classic EventLog.Log Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Log Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Log Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Log Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="T:System.Diagnostics.EventLogEntryCollection" />
      </Docs>
    </Member>
    <Member MemberName="LogDisplayName">
      <MemberSignature Language="C#" Value="public string LogDisplayName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LogDisplayName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.LogDisplayName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogDisplayName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LogDisplayName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogDisplayName : string" Usage="System.Diagnostics.EventLog.LogDisplayName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает понятное имя журнала событий.</summary>
        <value>Имя, представляющее журнал событий в "Просмотре событий".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  В Windows Vista и более поздних версиях пользователей отсутствует разрешение для доступа к журналу безопасности. Если вы используете Windows Vista или более поздней версии, как пользователь, вы получите <xref:System.Security.SecurityException> при попытке получить доступ к отображаемое имя для события в журнале безопасности.  
>   
>  В Windows Vista и более поздних версиях права доступа пользователя определяются контролем учетных записей. Члену встроенной группы "Администраторы" присваивается два маркера доступа на время выполнения: маркер доступа обычного пользователя и маркер доступа администратора. По умолчанию назначена роль обычного пользователя. Для выполнения кода, который обращается к в журнал безопасности, необходимо сначала повысить свои привилегии от обычного пользователя до администратора. Это можно сделать при запуске приложения, , щелкнув значок приложения правой кнопкой мыши и указав, что приложение должно запускаться от имени администратора.  
  
   
  
## Examples  
 В следующем примере перечисляются журналы событий, определенных на локальном компьютере и отображает <xref:System.Diagnostics.EventLog.LogDisplayName%2A> для каждого журнала событий.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Параметр <see cref="P:System.Diagnostics.EventLog.Log" /> отсутствует в реестре для этого компьютера.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для администрирования данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">для возможности чтения указанный раздел реестра. Связанное перечисление: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">возможность обращения к ключа указанного реестра, если это удаленный ключ. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="LogNameFromSourceName">
      <MemberSignature Language="C#" Value="public static string LogNameFromSourceName (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string LogNameFromSourceName(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LogNameFromSourceName (source As String, machineName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LogNameFromSourceName(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member LogNameFromSourceName : string * string -&gt; string" Usage="System.Diagnostics.EventLog.LogNameFromSourceName (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Имя источника событий.</param>
        <param name="machineName">Имя компьютера, на котором выполняется поиск, или значение ".", если используется локальный компьютер.</param>
        <summary>Возвращает имя журнала, в котором зарегистрирован указанный источник.</summary>
        <returns>Имя журнала, связанное с указанным источником в реестре.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Источник событий определяет журналы событий. Часто бывает имя приложения, или имя компонента приложения, если приложение имеет большой. Приложения и службы должно вести запись в журнал приложений или настраиваемого журнала. Драйверы устройств должен записывать в системный журнал.  
  
 При создании нового источника для записи в один журнал одновременно, приложение регистрируется в журнале событий как источник записей. <xref:System.Diagnostics.EventLog.Source%2A> Свойство может быть любой строкой, но имя не может использоваться для других источников, на компьютере. При попытке создать дубликат <xref:System.Diagnostics.EventLog.Source%2A> значение возникло исключение. Тем не менее один журнал событий может иметь множество различных источников, записи в него.  
  
   
  
## Examples  
 В следующем примере удаляется источник с локального компьютера. Пример определяет журнала от источника, а затем удаляет журнала.  
  
> [!NOTE]
>  Больше одного источника может записать в журнал событий. Прежде чем удалить пользовательский журнал, убедитесь, что нет других источников, запись в этот журнал.  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">для администрирования данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string with get, set" Usage="System.Diagnostics.EventLog.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(".")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the machine that this log get written to.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogMachineName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает имя компьютера, на котором производится чтение или запись событий.</summary>
        <value>Имя сервера, на котором находится журнал событий. Значение по умолчанию — локальный компьютер (".").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При записи в журнал событий, необходимо связать <xref:System.Diagnostics.EventLog.Source%2A> с объектом журнала событий для их подключения к определенному журналу событий. Это не обязательно указывать <xref:System.Diagnostics.EventLog.Source%2A> свойство при чтении журнала. Можно указать только <xref:System.Diagnostics.EventLog.Log%2A> имя и <xref:System.Diagnostics.EventLog.MachineName%2A> (имя сервера).  
  
> [!NOTE]
>  Не требуется указывать <xref:System.Diagnostics.EventLog.MachineName%2A> при подключении в журнал. Если вы не укажете <xref:System.Diagnostics.EventLog.MachineName%2A>, локальный компьютер (".») предполагается, что.  
  
 Источник может быть зарегистрирован только в один файл журнала за раз. Если <xref:System.Diagnostics.EventLog.Source%2A> свойство задано для экземпляра <xref:System.Diagnostics.EventLog>, нельзя изменить <xref:System.Diagnostics.EventLog.MachineName%2A> свойства для этого <xref:System.Diagnostics.EventLog> не изменяя значение <xref:System.Diagnostics.EventLog.Source%2A> или вызова <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> первого. При изменении <xref:System.Diagnostics.EventLog.MachineName%2A> свойства <xref:System.Diagnostics.EventLog> закрывает все дескрипторы и повторно подключается к журналу и источнику на новом компьютере.  
  
 <xref:System.Diagnostics.EventLog.MachineName%2A> Значение не может быть пустой строкой. Если оно не задано явно, по умолчанию на локальном компьютере (».»).  
  
   
  
## Examples  
 В следующем примере считываются записи в журнале событий «NewEventLog», на указанном компьютере.  
  
 [!code-cpp[Classic EventLog.MachineName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.MachineName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.MachineName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Недопустимое имя компьютера.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.GetEventLogs" />
      </Docs>
    </Member>
    <Member MemberName="MaximumKilobytes">
      <MemberSignature Language="C#" Value="public long MaximumKilobytes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumKilobytes" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MaximumKilobytes" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumKilobytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumKilobytes { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumKilobytes : int64 with get, set" Usage="System.Diagnostics.EventLog.MaximumKilobytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или устанавливает максимальный размер журнала событий в килобайтах.</summary>
        <value>Максимальный размер журнала событий в килобайтах. Значение по умолчанию — 512, что означает максимальный размер файла 512 килобайт.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog.MaximumKilobytes%2A> Свойство представляет ограничение на размер файла журнала событий. Когда файл журнала событий достигает предельного размера, настроенного <xref:System.Diagnostics.EventLog.OverflowAction%2A> значение определяет новые записи игнорируются или ли новые записи перезапись более старые записи.  
  
> [!NOTE]
>  Это свойство представляет параметр конфигурации для журнала событий, представленного этим экземпляром. Когда журнала событий достигает максимального размера, это свойство определяет, как операционная система обрабатывает новые записи, написанной все источники событий, зарегистрированные для журнала событий.  
  
   
  
## Examples  
 В следующем примере перечисляются журналы событий, определенных на локальном компьютере и отображает сведения о конфигурации для каждого журнала событий.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Указанное значение меньше 64 или больше 4194240 или не кратно 64.</exception>
        <exception cref="T:System.InvalidOperationException">Значение параметра <see cref="P:System.Diagnostics.EventLog.Log" /> является недопустимым именем журнала.  
  
-или- 
Раздел реестра для журнала событий не может быть открыт на конечном компьютере.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для администрирования данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="MinimumRetentionDays">
      <MemberSignature Language="C#" Value="public int MinimumRetentionDays { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MinimumRetentionDays" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MinimumRetentionDays As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MinimumRetentionDays { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MinimumRetentionDays : int" Usage="System.Diagnostics.EventLog.MinimumRetentionDays" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает количество дней, которое записи хранятся в журнале событий.</summary>
        <value>Количество дней, которое записи хранятся в журнале событий. Значение по умолчанию — 7.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> свойство, чтобы проверить текущие параметры для журнала событий. Используйте <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> изменение минимальное количество дней, которые должны храниться каждая запись в журнале событий.  
  
 <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> Значение зависит от поведения настроенных переполнения журнала событий. Если <xref:System.Diagnostics.OverflowAction> для журнала событий свойству <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>, а затем <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> значение равно 0. Если <xref:System.Diagnostics.OverflowAction> для журнала событий свойству <xref:System.Diagnostics.OverflowAction.DoNotOverwrite>, а затем <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> значение равно -1. Если <xref:System.Diagnostics.OverflowAction> для журнала событий свойству <xref:System.Diagnostics.OverflowAction.OverwriteOlder>, а затем <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> значение не равно нулю, а также представляет количество дней для хранения записей в журнале событий при заполнении журнала событий.  
  
 Поведение при переполнении возникает только в том случае, когда журнала событий достигает предельного размера. Когда <xref:System.Diagnostics.EventLog> имеет его <xref:System.Diagnostics.EventLog.OverflowAction%2A> присвоено <xref:System.Diagnostics.OverflowAction.OverwriteOlder>и файл журнала событий достигает максимального размера, а затем новые записи записываются только если они могут заменять операции, возраст которых превышает <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> период. Сохранение записей событий для как минимум в течение подходит в том случае, если регулярно архивируется в журнал событий. В противном случае вы рискуете потерять новые записи, когда файл журнала событий достигает предела. Чтобы избежать потери новые сведения о событии, задайте минимальное количество дней хранения для событий на основе вашего расписания архива для определенного журнала событий.  
  
   
  
## Examples  
 В следующем примере перечисляются журналы событий, определенных на локальном компьютере и отображает сведения о конфигурации для каждого журнала событий.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">для администрирования данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
      </Docs>
    </Member>
    <Member MemberName="ModifyOverflowPolicy">
      <MemberSignature Language="C#" Value="public void ModifyOverflowPolicy (System.Diagnostics.OverflowAction action, int retentionDays);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ModifyOverflowPolicy(valuetype System.Diagnostics.OverflowAction action, int32 retentionDays) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ModifyOverflowPolicy (action As OverflowAction, retentionDays As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ModifyOverflowPolicy(System::Diagnostics::OverflowAction action, int retentionDays);" />
      <MemberSignature Language="F#" Value="member this.ModifyOverflowPolicy : System.Diagnostics.OverflowAction * int -&gt; unit" Usage="eventLog.ModifyOverflowPolicy (action, retentionDays)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Diagnostics.OverflowAction" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="retentionDays" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="action">Поведение при внесении новых записей в журнал событий в случае переполнения.</param>
        <param name="retentionDays">Минимальное количество дней, которое будет храниться каждая запись журнала событий. Этот параметр используется только в том случае, если значение <paramref name="action" /> равно <see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" />.</param>
        <summary>Изменяет поведение при внесении новых записей, когда файл журнала событий достигает максимального размера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поведение при переполнении журнала событий указывает, что происходит, когда новые записи будут записываться в журнал, который достиг максимального размера.  
  
> [!NOTE]
>  Поведение при переполнении вступает в силу только в том случае, если журнал событий достигает максимального размера. Поведение при переполнении не влияет на запись новой записи в журнал, который способен обрабатывать дополнительные записи.  
  
 <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> Метод настраивает поведение при переполнении журнала событий. <xref:System.Diagnostics.EventLog> экземпляр. После вызова этого метода для журнала событий, определяемое <xref:System.Diagnostics.EventLog.Log%2A> свойство, <xref:System.Diagnostics.EventLog.OverflowAction%2A> и <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> значения свойств отражают поведение вновь настроенная переполнения.  
  
> [!NOTE]
>  Это свойство представляет параметр конфигурации для журнала событий, представленного этим экземпляром. Когда журнала событий достигает максимального размера, это свойство определяет, как операционная система обрабатывает новые записи, написанной все источники событий, зарегистрированные для журнала событий.  
  
 Задайте `action` параметр <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded> для указания, что новая запись переопределяет самую старую запись при <xref:System.Diagnostics.EventLog> достигает максимального размера. Если `action` параметр имеет значение <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>, `retentionDays` значение параметра учитывается.  
  
 Задайте `action` параметр <xref:System.Diagnostics.OverflowAction.OverwriteOlder> для указания, что каждая новая запись перезаписывает более старые записи при <xref:System.Diagnostics.EventLog> достигает максимального размера. Укажите число дней, которые должны храниться события в журнал с помощью `retentionDays` параметра. События, записанные в пределах диапазона хранения, не перезаписываются, новые записи.  
  
 Задайте `action` параметр <xref:System.Diagnostics.OverflowAction.DoNotOverwrite> отменить новые события, при достижении максимального размера журнала. Если `action` параметр имеет значение <xref:System.Diagnostics.OverflowAction.DoNotOverwrite>, `retentionDays` значение параметра учитывается.  
  
> [!CAUTION]
>  Параметр переполнения <xref:System.Diagnostics.OverflowAction.DoNotOverwrite> указывает, что новые записи игнорируются при заполнении журнала событий. Если вы используете этот параметр, убедитесь в журнал событий регулярно архивируется и очищен достижение максимального размера.  
  
   
  
## Examples  
 В следующем примере отображается Настройка политики переполнения для указанного журнала событий и позволяет пользователю выбрать новый параметр политики переполнения для журнала событий.  
  
 [!code-cpp[EventLogProperties#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#3)]
 [!code-csharp[EventLogProperties#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#3)]
 [!code-vb[EventLogProperties#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="action" /> не является допустимым значением <see cref="P:System.Diagnostics.EventLog.OverflowAction" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="retentionDays" /> меньше 1 или больше 365.</exception>
        <exception cref="T:System.InvalidOperationException">Значение параметра <see cref="P:System.Diagnostics.EventLog.Log" /> является недопустимым именем журнала.  
  
-или- 
Раздел реестра для журнала событий не может быть открыт на конечном компьютере.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для администрирования данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      </Docs>
    </Member>
    <Member MemberName="OverflowAction">
      <MemberSignature Language="C#" Value="public System.Diagnostics.OverflowAction OverflowAction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.OverflowAction OverflowAction" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.OverflowAction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OverflowAction As OverflowAction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::OverflowAction OverflowAction { System::Diagnostics::OverflowAction get(); };" />
      <MemberSignature Language="F#" Value="member this.OverflowAction : System.Diagnostics.OverflowAction" Usage="System.Diagnostics.EventLog.OverflowAction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.OverflowAction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает поведение при переполнении для хранения новых записей, когда файл журнала событий достигает максимального размера.</summary>
        <value>Значение <see cref="T:System.Diagnostics.OverflowAction" />, которое определяет поведение при переполнении для хранения новых записей, когда файл журнала событий достигает максимального размера. Значение по умолчанию — <see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Журналы событий увеличиваются в размерах, как новые события записываются в их. Каждый журнал событий имеет ограничение по максимальному размеру; <xref:System.Diagnostics.EventLog.MaximumKilobytes%2A> свойство определяет максимальное число килобайтов, разрешенное для размера файла журнала событий.  
  
 Используйте <xref:System.Diagnostics.EventLog.OverflowAction%2A> значение свойства к обсуждению поведения настроенных переполнения журнала событий в его максимального размера. Используйте <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> метод, чтобы изменить поведение при переполнении журнала событий.  
  
> [!NOTE]
>  Поведение при переполнении вступает в силу только в том случае, если журнал событий достигает максимального размера. Поведение при переполнении не влияет на запись новой записи в журнал, который способен обрабатывать дополнительные записи.  
  
   
  
## Examples  
 В следующем примере перечисляются журналы событий, определенных на локальном компьютере и отображает сведения о конфигурации для каждого журнала событий.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">для администрирования данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
        <altmember cref="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      </Docs>
    </Member>
    <Member MemberName="RegisterDisplayName">
      <MemberSignature Language="C#" Value="public void RegisterDisplayName (string resourceFile, long resourceId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterDisplayName(string resourceFile, int64 resourceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterDisplayName (resourceFile As String, resourceId As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterDisplayName(System::String ^ resourceFile, long resourceId);" />
      <MemberSignature Language="F#" Value="member this.RegisterDisplayName : string * int64 -&gt; unit" Usage="eventLog.RegisterDisplayName (resourceFile, resourceId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceFile" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="resourceId" Type="System.Int64" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="resourceFile">Полный путь к локализованному файлу ресурсов.</param>
        <param name="resourceId">Идентификатор ресурса, который индексирует локализованную строку в файле ресурсов.</param>
        <summary>Определяет локализованное имя для журнала событий, которое отображается в "Просмотре событий" сервера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Diagnostics.EventLog.RegisterDisplayName%2A> для регистрации и отображать локализованное имя в средстве просмотра событий для пользовательского журнала событий.  
  
 Идентификатор указанного ресурса должно соответствовать локализованную строку, определенные в файле ресурсов. Средство просмотра событий отображает имя пользовательского журнала событий, используя локализованную строку и текущие параметры языка и региональных параметров. Например можно определить несколько имен журналов событий, локализован для различных языков и региональных параметров в файле ресурсов. Средство просмотра событий отображается локализованная строка, соответствующая настройка языка и региональных параметров текущего пользователя.  
  
 Если средство просмотра событий не удается загрузить локализованную строку из файла ресурсов, или если отображаемое имя не был зарегистрирован для журнала событий, в просмотре событий выводятся имя журнала событий, определенных в <xref:System.Diagnostics.EventLog.Log%2A>.  
  
> [!NOTE]
>  Необходимо зарегистрировать отображаемое имя для предопределенных журналов событий. Операционная система регистрирует локализованное отображаемое имя для журналов событий приложений, системы и безопасности.  
  
   
  
## Examples  
 В следующем примере определяется, является ли источник события с именем `SampleApplicationSource` зарегистрирован на локальном компьютере. Если источник событий не существует, в примере задает файле ресурсов сообщения для источника и создается новый источник событий. Наконец, пример задает локализованное отображаемое имя для журнала событий, используя значение идентификатора ресурса в `DisplayNameMsgId` и путь к файлу ресурсов в `messageFile`.  
  
 [!code-cpp[EventLog_WriteEvent#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog_WriteEvent#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog_WriteEvent#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 В примере используется следующий текстовый файл сообщения, встроенный в библиотеку ресурсов EventLogMsgs.dll. Текстовый файл сообщения — источник, из которого создается файле ресурсов сообщения. В текстовом файле сообщения определяет, идентификаторы ресурсов и текст категории, сообщения о событии и строки вставки параметров. В частности идентификатор ресурса 5001 определен для локализованное имя журнала событий.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Значение параметра <see cref="P:System.Diagnostics.EventLog.Log" /> является недопустимым именем журнала.  
  
-или- 
Раздел реестра для журнала событий не может быть открыт на конечном компьютере.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceFile" /> — <see langword="null" />.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для администрирования данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.LogDisplayName" />
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public string Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Source" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Source { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : string with get, set" Usage="System.Diagnostics.EventLog.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The application name that writes the log.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogSource")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает имя источника, регистрируемого в журнале и используемого при записи в журнал событий.</summary>
        <value>Имя, регистрируемое в журнале событий как имя источника записей. Значение по умолчанию — пустая строка ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Источник событий определяет журналы событий. Часто бывает имя приложения, или имя компонента приложения, если приложение имеет большой. Приложения и службы должно вести запись в журнал приложений или настраиваемого журнала. Драйверы устройств должен записывать в системный журнал.  
  
 Необходимо указать источник событий, при записи в журнал событий. Прежде чем вносить записи в журнал событий, необходимо зарегистрировать источник событий с журналом событий как источник событий. При записи в журнал событий система использует <xref:System.Diagnostics.EventLog.Source%2A> свойства для поиска журнала, в котором нужно сделать запись. Если выполняется чтение журнала событий, можно указать <xref:System.Diagnostics.EventLog.Source%2A>, или <xref:System.Diagnostics.EventLog.Log%2A> и <xref:System.Diagnostics.EventLog.MachineName%2A>.  
  
> [!NOTE]
>  Не обязательно указывать <xref:System.Diagnostics.EventLog.MachineName%2A> при подключении в журнал на локальном компьютере. Если вы не укажете <xref:System.Diagnostics.EventLog.MachineName%2A>, локальный компьютер (".») предполагается, что.  
  
 Используйте <xref:System.Diagnostics.EventLog.WriteEvent%2A> и <xref:System.Diagnostics.EventLog.WriteEntry%2A> для записи событий в журнал событий. Необходимо указать источник события для записи событий; необходимо создать и настроить источник события перед записью первой записи с источником.  
  
 Создайте новый источник событий во время установки приложения. Это экономит время ОС, чтобы обновить свой список зарегистрированных источников событий и их конфигурации. Если операционная система не обновлялись свой список источников событий и предпринимается попытка записать событие с новым источником, операция записи завершится сбоем. Можно настроить нового источника при помощи <xref:System.Diagnostics.EventLogInstaller>, или с помощью <xref:System.Diagnostics.EventLog.CreateEventSource%2A> метод. Вам необходимы права администратора на компьютере, чтобы создать новый источник событий.  
  
 Можно создать источник событий для существующего журнала событий или журнала событий. При создании нового источника для нового журнала событий система регистрирует источник для этого журнала, но журнал не создается, пока на него будут записаны первой записи.  
  
 Источник должен быть уникальным на локальном компьютере. имя нового источника не может совпадать с существующим именем источника или с существующим именем журнала событий. Каждый источник можно написать только один журнал событий во время. Тем не менее приложение может использовать несколько источников для записи нескольких журналов событий. Например приложению может потребоваться несколько источников, настроенных для различных журналов событий или разным файлам ресурсов.  
  
 При изменении <xref:System.Diagnostics.EventLog.Source%2A> значение, <xref:System.Diagnostics.EventLog> к которой она зарегистрирована закрывается и освобождаются все дескрипторы событий.  
  
 Источник должен быть настроен для записи локализованных или исходных строк. Если приложение записывает операции, используя идентификаторы ресурсов и строковые значения, необходимо зарегистрировать два отдельных источника. Например, настроить один источник с файлами ресурсов, а затем использовать этот источник в <xref:System.Diagnostics.EventLog.WriteEvent%2A> метод для записи, используя идентификаторы ресурсов в журнале событий. Затем создайте другой источник без файлов ресурсов и использующих этот источник в <xref:System.Diagnostics.EventLog.WriteEntry%2A> метод для записи строк непосредственно в журнале событий, с помощью этого источника.  
  
 Чтобы изменить сведения о конфигурации существующего источника, необходимо удалить источник и затем создать его с новой конфигурацией. Если другие приложения или компоненты используют существующий источник, создайте новый источник с обновленной конфигурации, вместо удаления существующего источника.  
  
> [!NOTE]
>  Если источник уже сопоставлен в журнал, и необходимо отобразить в новый журнал, необходимо перезапустить компьютер, чтобы изменения вступили в силу.  
  
   
  
## Examples  
 В следующем примере создается источник `MySource` если он еще не существует и вносит запись в журнал событий `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.Source Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">При таком имени источника длина пути к разделу реестра превышает 254 символа.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SourceExists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет поиск заданного источника событий в реестре компьютера.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SourceExists (source As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SourceExists(System::String ^ source);" />
      <MemberSignature Language="F#" Value="static member SourceExists : string -&gt; bool" Usage="System.Diagnostics.EventLog.SourceExists source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Имя источника событий.</param>
        <summary>Определяет, зарегистрирован ли источник событий на локальном компьютере.</summary>
        <returns>Значение <see langword="true" />, если источник событий зарегистрирован на локальном компьютере; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод позволяет определить, существует ли источник событий на локальном компьютере. Если вы хотите определить, существует ли журнал на локальном компьютере, используйте <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
 Так как этот метод обращается к реестру, необходимо иметь необходимых разрешений для реестра на локальном компьютере; в противном случае <xref:System.Security.SecurityException> будет создано.  
  
> [!NOTE]
>  Для поиска для источника событий в Windows Vista и более поздних версиях или Windows Server 2003, необходимо иметь права администратора.  
>   
>  Это требование связано что всех журналов событий, включая безопасность, должно осуществляться до определения уникальности источника события. Начиная с Windows Vista, пользователи не имеют разрешения на доступ к журналу безопасности; Таким образом <xref:System.Security.SecurityException> возникает исключение.  
>   
>  Начиная с Windows Vista, привилегии пользователя определяются контроля учетных записей (UAC). Члену встроенной группы "Администраторы" присваивается два маркера доступа на время выполнения: маркер доступа обычного пользователя и маркер доступа администратора. По умолчанию назначена роль обычного пользователя. Чтобы выполнить код, который обращается к счетчики производительности, необходимо сначала повысить свои привилегии от обычного пользователя для администратора. Это можно сделать при запуске приложения, , щелкнув значок приложения правой кнопкой мыши и указав, что приложение должно запускаться от имени администратора.  
  
> [!NOTE]
>  Это служба, которая выполняется под <xref:System.ServiceProcess.ServiceAccount.LocalSystem> учетной записи нет необходимых прав для выполнения этого метода. Решение заключается в проверке того, существует ли источник события в <xref:System.ServiceProcess.ServiceInstaller>, и если он не существует, для создания источника в установщике.  
  
 Новый источник не могут иметь имя существующего источника на том же компьютере, этот метод позволяет прежде чем вызывать <xref:System.Diagnostics.EventLog.CreateEventSource%2A> чтобы убедиться, что источник с именем, указанным `source` еще не существует на локальном компьютере. `source` Параметр не чувствителен к регистру.  
  
   
  
## Examples  
 В следующем примере создается источник `MySource` если он еще не существует и вносит запись в журнал событий `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.Source Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><paramref name="source" /> не найден, но поиск некоторых или всех журналов событий не был произведен.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
      </Docs>
    </Member>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SourceExists (source As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SourceExists(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member SourceExists : string * string -&gt; bool" Usage="System.Diagnostics.EventLog.SourceExists (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Имя источника событий.</param>
        <param name="machineName">Имя компьютера, на котором выполняется поиск, или значение ".", если используется локальный компьютер.</param>
        <summary>Определяет, зарегистрирован ли источник событий на указанном компьютере.</summary>
        <returns>Значение <see langword="true" />, если источник событий зарегистрирован на заданном компьютере; в противном случае — значение <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод позволяет определить, существует ли источник событий на компьютере, указанном по `machineName` параметр. Если вы хотите определить, существует ли журнал на указанном компьютере, используйте <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
 Так как этот метод обращается к реестру, необходимо иметь необходимых разрешений для реестра на данном сервере; в противном случае <xref:System.Security.SecurityException> будет создано.  
  
> [!NOTE]
>  Для поиска для источника событий в Windows Vista и более поздних версиях или Windows Server 2003, необходимо иметь права администратора.  
>   
>  Это требование связано что всех журналов событий, включая безопасность, должно осуществляться до определения уникальности источника события. Начиная с Windows Vista, пользователи не имеют разрешения на доступ к журналу безопасности; Таким образом <xref:System.Security.SecurityException> возникает исключение.  
>   
>  Начиная с Windows Vista, привилегии пользователя определяются контроля учетных записей (UAC). Члену встроенной группы "Администраторы" присваивается два маркера доступа на время выполнения: маркер доступа обычного пользователя и маркер доступа администратора. По умолчанию назначена роль обычного пользователя. Чтобы выполнить код, который обращается к счетчики производительности, необходимо сначала повысить свои привилегии от обычного пользователя для администратора. Это можно сделать при запуске приложения, , щелкнув значок приложения правой кнопкой мыши и указав, что приложение должно запускаться от имени администратора.  
  
> [!NOTE]
>  Это служба, которая выполняется под <xref:System.ServiceProcess.ServiceAccount.LocalSystem> учетной записи нет необходимых прав для выполнения этого метода. Решение заключается в проверке того, существует ли источник события в <xref:System.ServiceProcess.ServiceInstaller>, и если он не существует, для создания источника в установщике.  
  
 Новый источник не могут иметь имя существующего источника на том же компьютере, этот метод позволяет прежде чем вызывать <xref:System.Diagnostics.EventLog.CreateEventSource%2A> чтобы убедиться, что источник с именем, указанным `source` еще не существует на компьютере. `source` И `machineName` параметры не учитывают регистр.  
  
 <xref:System.Diagnostics.EventLog.SourceExists%2A> является `static` метод, поэтому его можно вызывать в самом классе. Нет необходимости создания экземпляра <xref:System.Diagnostics.EventLog> для вызова <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
   
  
## Examples  
 В следующем примере создается источник `MySource` на компьютере `MyServer`и вносит запись в журнал событий `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="machineName" /> не является допустимым именем компьютера.</exception>
        <exception cref="T:System.Security.SecurityException"><paramref name="source" /> не найден, но поиск некоторых или всех журналов событий не был произведен.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Diagnostics.EventLog.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("An object that synchronizes event handler calls.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogSynchronizingObject")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает объект, используемый для маршалинга вызовов обработчика событий, возникающих в результате события записи в <see cref="T:System.Diagnostics.EventLog" />.</summary>
        <value>Объект <see cref="T:System.ComponentModel.ISynchronizeInvoke" />, используемый для маршалинга вызовов обработчика событий, возникающих в результате события записи <see cref="E:System.Diagnostics.EventLog.EntryWritten" /> в журнал событий.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> — `null`, методы, обрабатывающие <xref:System.Diagnostics.EventLog.EntryWritten> событие, называются в поток из системного пула потоков. Дополнительные сведения о системе пулов потоков, см. в разделе <xref:System.Threading.ThreadPool>.  
  
 Когда <xref:System.Diagnostics.EventLog.EntryWritten> событие обрабатывается visual Windows Forms, компонента, например кнопку, обращение к компоненту через пул потоков системы могут работать неправильно, или может привести к исключению. Избежать этого, задав <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> в компонент Windows Forms, который вызывает методы, обрабатывающие <xref:System.Diagnostics.EventLog.EntryWritten> событий, вызываемый в том же потоке, в котором был создан компонент.  
  
 Если <xref:System.Diagnostics.EventLog> используется внутри [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] в конструкторе Windows Forms, <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> автоматически устанавливается в элемент управления, содержащую <xref:System.Diagnostics.EventLog>. Например, если вы поместите <xref:System.Diagnostics.EventLog> в конструкторе Form1 (который наследуется от <xref:System.Windows.Forms.Form>) <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> свойство <xref:System.Diagnostics.EventLog> присваивается экземпляр Form1.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="E:System.Diagnostics.EventLog.EntryWritten" />
        <altmember cref="T:System.Threading.ThreadPool" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEntry">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Вносит запись в журнал событий.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string -&gt; unit" Usage="eventLog.WriteEntry message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Строка для записи в журнал событий.</param>
        <summary>Вносит в журнал событий запись сведений с заданным текстом сообщения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для внесения записи в журнал событий, связанный с данным <xref:System.Diagnostics.EventLog> экземпляра. Если вы хотите указать другой <xref:System.Diagnostics.EventLogEntryType>, воспользуйтесь другой перегрузкой <xref:System.Diagnostics.EventLog.WriteEntry%2A>.  
  
> [!NOTE]
>  `message` Строка не может содержать %*n*, где *n* является целым значением (например, %1), так как средство просмотра событий воспринимает его как строку вставки. Так как протокол Интернета версии 6 (IPv6) адрес может содержать это последовательность символов, не удается войти сообщение о событии, содержащий адрес IPv6.  
  
 Необходимо задать <xref:System.Diagnostics.EventLog.Source%2A> свойство вашей <xref:System.Diagnostics.EventLog> компонента перед предоставлением записи в журнал. Необходимо создать и настроить источник события перед записью первой записи с источником.  
  
 Создайте новый источник событий во время установки приложения. Это экономит время ОС, чтобы обновить свой список зарегистрированных источников событий и их конфигурации. Если операционная система не обновлялись свой список источников событий и предпринимается попытка записать событие с новым источником, операция записи завершится сбоем. Можно настроить нового источника при помощи <xref:System.Diagnostics.EventLogInstaller>, или с помощью <xref:System.Diagnostics.EventLog.CreateEventSource%2A> метод. Вам необходимы права администратора на компьютере, чтобы создать новый источник событий.  
  
 Если источник, указанный в <xref:System.Diagnostics.EventLog.Source%2A> свойства данного объекта <xref:System.Diagnostics.EventLog> экземпляр не зарегистрирован на компьютере, на который осуществляется запись, <xref:System.Diagnostics.EventLog.WriteEntry%2A> вызовы <xref:System.Diagnostics.EventLog.CreateEventSource%2A> и регистрирует источник.  
  
> [!NOTE]
>  Если вы не укажете <xref:System.Diagnostics.EventLog.MachineName%2A> для вашей <xref:System.Diagnostics.EventLog> экземпляра перед вызовом метода <xref:System.Diagnostics.EventLog.CreateEventSource%2A> или <xref:System.Diagnostics.EventLog.WriteEntry%2A>, локальный компьютер (".») предполагается, что.  
  
 Если системе нужно зарегистрировать <xref:System.Diagnostics.EventLog.Source%2A> посредством вызова <xref:System.Diagnostics.EventLog.WriteEntry%2A> и <xref:System.Diagnostics.EventLog.Log%2A> свойство не задано на вашей <xref:System.Diagnostics.EventLog> экземпляра, по умолчанию будет использоваться в журнал приложений.  
  
> [!NOTE]
>  Многие из перечисленных выше исключений создаются ошибками, возникающими в процессе регистрации <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 Источник должен быть настроен для записи локализованных или исходных строк. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Метод записывает заданную строку непосредственно в журнал событий; он не использует файл ресурсов локализуемого сообщения. Используйте <xref:System.Diagnostics.EventLog.WriteEvent%2A> метод для записи событий с помощью локализованного файла ресурсов сообщений.  
  
 Если приложение записывает операции, используя идентификаторы ресурсов и строковые значения, необходимо зарегистрировать два отдельных источника. Например, настроить один источник с файлами ресурсов, а затем использовать этот источник в <xref:System.Diagnostics.EventLog.WriteEvent%2A> метод для записи, используя идентификаторы ресурсов в журнале событий. Затем создайте другой источник без файлов ресурсов и использующих этот источник в <xref:System.Diagnostics.EventLog.WriteEntry%2A> метод для записи строк непосредственно в журнале событий, с помощью этого источника.  
  
> [!NOTE]
>  Если добавить запись к удаленному компьютеру, значение сообщения (строка текста) может оказаться непредвиденным, если на удаленном компьютере не запущена платформа .NET Framework.  
  
> [!NOTE]
>  Если `message` параметр содержит символ NUL, заканчивается на символ NUL сообщение в журнале событий.  
  
   
  
## Examples  
 В следующем примере создается источник `MySource` если он еще не существует и вносит запись в журнал событий `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Не задано свойство <see cref="P:System.Diagnostics.EventLog.Source" /> класса <see cref="T:System.Diagnostics.EventLog" />.  
  
-или- 
Метод пытается зарегистрировать новый источник событий, но имя компьютера в <see cref="P:System.Diagnostics.EventLog.MachineName" /> является недопустимым.  
  
-или- 
Источник уже зарегистрирован для различных журналов событий.  
  
-или- 
Строка сообщения превышает 31,839 байт (32,766 байт в операционных системах Windows до Windows Vista).  
  
-или- 
При таком имени источника длина пути к разделу реестра превышает 254 символа.</exception>
        <exception cref="T:System.InvalidOperationException">Не удается открыть раздел реестра для журнала событий.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Операционная система сообщила об ошибке при записи сведений о событии в журнал событий. Код ошибки Windows недоступен.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType -&gt; unit" Usage="eventLog.WriteEntry (message, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="message">Строка для записи в журнал событий.</param>
        <param name="type">Одно из значений <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <summary>Вносит в журнал событий следующие записи с заданным текстом сообщения: ошибка, предупреждение, сведения, аудит отказов или аудит успехов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для записи указанного <xref:System.Diagnostics.EventLogEntryType> в журнале событий. `type` Указывает значок и текст в столбце типа в средстве просмотра событий для журнала.  
  
> [!NOTE]
>  `message` Строка не может содержать %*n*, где *n* является целым значением (например, %1), так как средство просмотра событий воспринимает его как строку вставки. Так как протокол Интернета версии 6 (IPv6) адрес может содержать это последовательность символов, не удается войти сообщение о событии, содержащий адрес IPv6.  
  
 Необходимо задать <xref:System.Diagnostics.EventLog.Source%2A> свойство вашей <xref:System.Diagnostics.EventLog> компонента перед предоставлением записи в журнал. Необходимо создать и настроить источник события перед записью первой записи с источником.  
  
 Создайте новый источник событий во время установки приложения. Это экономит время ОС, чтобы обновить свой список зарегистрированных источников событий и их конфигурации. Если операционная система не обновлялись свой список источников событий и предпринимается попытка записать событие с новым источником, операция записи завершится сбоем. Можно настроить нового источника при помощи <xref:System.Diagnostics.EventLogInstaller>, или с помощью <xref:System.Diagnostics.EventLog.CreateEventSource%2A> метод. Вам необходимы права администратора на компьютере, чтобы создать новый источник событий.  
  
 Если источник, указанный в <xref:System.Diagnostics.EventLog.Source%2A> свойства данного объекта <xref:System.Diagnostics.EventLog> экземпляр не зарегистрирован на компьютере, на который осуществляется запись, <xref:System.Diagnostics.EventLog.WriteEntry%2A> вызовы <xref:System.Diagnostics.EventLog.CreateEventSource%2A> и регистрирует источник.  
  
> [!NOTE]
>  Если вы не укажете <xref:System.Diagnostics.EventLog.MachineName%2A> для вашей <xref:System.Diagnostics.EventLog> экземпляра перед вызовом метода <xref:System.Diagnostics.EventLog.CreateEventSource%2A> или <xref:System.Diagnostics.EventLog.WriteEntry%2A>, локальный компьютер (".») предполагается, что.  
  
 Если системе нужно зарегистрировать <xref:System.Diagnostics.EventLog.Source%2A> посредством вызова <xref:System.Diagnostics.EventLog.WriteEntry%2A> и <xref:System.Diagnostics.EventLog.Log%2A> свойство не задано на вашей <xref:System.Diagnostics.EventLog> экземпляра, по умолчанию будет использоваться в журнал приложений.  
  
> [!NOTE]
>  Многие описанные выше исключения создаются ошибки, возникшие во время процесса регистрации <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 Источник должен быть настроен для записи локализованных или исходных строк. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Метод записывает заданную строку непосредственно в журнал событий; он не использует файл ресурсов локализуемого сообщения. Используйте <xref:System.Diagnostics.EventLog.WriteEvent%2A> метод для записи событий с помощью локализованного файла ресурсов сообщений.  
  
 Если приложение записывает операции, используя идентификаторы ресурсов и строковые значения, необходимо зарегистрировать два отдельных источника. Например, настроить один источник с файлами ресурсов, а затем использовать этот источник в <xref:System.Diagnostics.EventLog.WriteEvent%2A> метод для записи, используя идентификаторы ресурсов в журнале событий. Затем создайте другой источник без файлов ресурсов и использующих этот источник в <xref:System.Diagnostics.EventLog.WriteEntry%2A> метод для записи строк непосредственно в журнале событий, с помощью этого источника.  
  
> [!NOTE]
>  Если добавить запись к удаленному компьютеру, значение сообщения (строка текста) может оказаться непредвиденным, если на удаленном компьютере не запущена платформа .NET Framework.  
  
> [!NOTE]
>  Если `message` параметр содержит символ NUL, заканчивается на символ NUL сообщение в журнале событий.  
  
   
  
## Examples  
 Следующий пример производит запись предупреждение в журнал событий «MyNewLog», на локальном компьютере.  
  
 [!code-cpp[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Не задано свойство <see cref="P:System.Diagnostics.EventLog.Source" /> класса <see cref="T:System.Diagnostics.EventLog" />.  
  
-или- 
Метод пытается зарегистрировать новый источник событий, но имя компьютера в <see cref="P:System.Diagnostics.EventLog.MachineName" /> является недопустимым.  
  
-или- 
Источник уже зарегистрирован для различных журналов событий.  
  
-или- 
Строка сообщения превышает 31,839 байт (32,766 байт в операционных системах Windows до Windows Vista).  
  
-или- 
При таком имени источника длина пути к разделу реестра превышает 254 символа.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> не является допустимым <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.InvalidOperationException">Не удается открыть раздел реестра для журнала событий.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Операционная система сообщила об ошибке при записи сведений о событии в журнал событий. Код ошибки Windows недоступен.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Источник, по которому приложение регистрируется на указанном компьютере.</param>
        <param name="message">Строка для записи в журнал событий.</param>
        <summary>Вносит в журнал событий запись сведений с заданным текстом сообщения, используя указанный зарегистрированный источник.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно используйте для внесения записи в журнал событий, используя источник, зарегистрированный источник событий соответствующего журнала. Если вы хотите указать другой <xref:System.Diagnostics.EventLogEntryType>, воспользуйтесь другой перегрузкой <xref:System.Diagnostics.EventLog.WriteEntry%2A>.  
  
 Необходимо создать и настроить источник события перед записью первой записи с источником. Создайте новый источник событий во время установки приложения. Это экономит время ОС, чтобы обновить свой список зарегистрированных источников событий и их конфигурации. Если операционная система не обновлялись свой список источников событий и предпринимается попытка записать событие с новым источником, операция записи завершится сбоем. Можно настроить нового источника при помощи <xref:System.Diagnostics.EventLogInstaller>, или с помощью <xref:System.Diagnostics.EventLog.CreateEventSource%2A> метод. Вам необходимы права администратора на компьютере, чтобы создать новый источник событий.  
  
 Источник должен быть настроен для записи локализованных или исходных строк. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Метод записывает заданную строку непосредственно в журнал событий; он не использует файл ресурсов локализуемого сообщения. Используйте <xref:System.Diagnostics.EventLog.WriteEvent%2A> метод для записи событий с помощью локализованного файла ресурсов сообщений.  
  
 Если приложение записывает операции, используя идентификаторы ресурсов и строковые значения, необходимо зарегистрировать два отдельных источника. Например, настроить один источник с файлами ресурсов, а затем использовать этот источник в <xref:System.Diagnostics.EventLog.WriteEvent%2A> метод для записи, используя идентификаторы ресурсов в журнале событий. Затем создайте другой источник без файлов ресурсов и использующих этот источник в <xref:System.Diagnostics.EventLog.WriteEntry%2A> метод для записи строк непосредственно в журнале событий, с помощью этого источника.  
  
> [!NOTE]
>  Если `message` параметр содержит символ NUL, заканчивается на символ NUL сообщение в журнале событий.  
>   
>  `message` Строка не может содержать %*n*, где *n* является целым значением (например, %1), так как средство просмотра событий воспринимает его как строку вставки. Так как протокол Интернета версии 6 (IPv6) адрес может содержать это последовательность символов, не удается войти сообщение о событии, содержащий адрес IPv6.  
  
   
  
## Examples  
 В следующем примере создается источник `MySource` если он еще не существует и вносит запись в журнал событий `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значением <paramref name="source" /> является пустая строка ("").  
  
-или- 
Значение <paramref name="source" /> равно <see langword="null" />.  
  
-или- 
Строка сообщения превышает 31,839 байт (32,766 байт в операционных системах Windows до Windows Vista).  
  
-или- 
При таком имени источника длина пути к разделу реестра превышает 254 символа.</exception>
        <exception cref="T:System.InvalidOperationException">Не удается открыть раздел реестра для журнала событий.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Операционная система сообщила об ошибке при записи сведений о событии в журнал событий. Код ошибки Windows недоступен.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="message">Строка для записи в журнал событий.</param>
        <param name="type">Одно из значений <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <param name="eventID">Идентификатор для события, зависящий от приложения.</param>
        <summary>Вносит в журнал событий запись с заданным текстом сообщения и идентификатором события, который определяется приложением.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для записи с определенной приложением `eventID` в журнале событий. `eventID` Вместе с источником однозначной идентификации события. Каждое приложение можно определить собственные нумерованные события и описание строки, с которыми они сопоставлены. При просмотре событий отображаются эти строковые значения, чтобы помочь пользователю определить, что пошло не так и какие действия предпринять.  
  
> [!NOTE]
>  `message` Строка не может содержать %*n*, где *n* является целым значением (например, %1), так как средство просмотра событий воспринимает его как строку вставки. Так как протокол Интернета версии 6 (IPv6) адрес может содержать это последовательность символов, не удается войти сообщение о событии, содержащий адрес IPv6.  
  
 Помимо идентификатор события, можно указать <xref:System.Diagnostics.EventLogEntryType> для событий, записываемых в журнал событий. `type` Указывает значок и текст в столбце типа в средстве просмотра событий для журнала. Этот параметр указывает, является ли тип события ошибку, предупреждение, сведения, аудит успехов или аудит отказов.  
  
 Необходимо задать <xref:System.Diagnostics.EventLog.Source%2A> свойство вашей <xref:System.Diagnostics.EventLog> компонента перед предоставлением записи в журнал. Необходимо создать и настроить источник события перед записью первой записи с источником.  
  
 Создайте новый источник событий во время установки приложения. Это экономит время ОС, чтобы обновить свой список зарегистрированных источников событий и их конфигурации. Если операционная система не обновлялись свой список источников событий и предпринимается попытка записать событие с новым источником, операция записи завершится сбоем. Можно настроить нового источника при помощи <xref:System.Diagnostics.EventLogInstaller>, или с помощью <xref:System.Diagnostics.EventLog.CreateEventSource%2A> метод. Вам необходимы права администратора на компьютере, чтобы создать новый источник событий.  
  
 Если источник, указанный в <xref:System.Diagnostics.EventLog.Source%2A> свойства данного объекта <xref:System.Diagnostics.EventLog> экземпляр не зарегистрирован на компьютере, на который осуществляется запись, <xref:System.Diagnostics.EventLog.WriteEntry%2A> вызовы <xref:System.Diagnostics.EventLog.CreateEventSource%2A> и регистрирует источник.  
  
> [!NOTE]
>  Если вы не укажете <xref:System.Diagnostics.EventLog.MachineName%2A> для вашей <xref:System.Diagnostics.EventLog> экземпляра перед вызовом метода <xref:System.Diagnostics.EventLog.CreateEventSource%2A> или <xref:System.Diagnostics.EventLog.WriteEntry%2A>, локальный компьютер (".») предполагается, что.  
  
 Если системе нужно зарегистрировать <xref:System.Diagnostics.EventLog.Source%2A> посредством вызова <xref:System.Diagnostics.EventLog.WriteEntry%2A> и <xref:System.Diagnostics.EventLog.Log%2A> свойство не задано на вашей <xref:System.Diagnostics.EventLog> экземпляра, по умолчанию будет использоваться в журнал приложений.  
  
> [!NOTE]
>  Многие описанные выше исключения создаются ошибки, возникшие во время процесса регистрации <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 Источник должен быть настроен для записи локализованных или исходных строк. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Метод записывает заданную строку непосредственно в журнал событий; он не использует файл ресурсов локализуемого сообщения. Используйте <xref:System.Diagnostics.EventLog.WriteEvent%2A> метод для записи событий с помощью локализованного файла ресурсов сообщений.  
  
 Если приложение записывает операции, используя идентификаторы ресурсов и строковые значения, необходимо зарегистрировать два отдельных источника. Например, настроить один источник с файлами ресурсов, а затем использовать этот источник в <xref:System.Diagnostics.EventLog.WriteEvent%2A> метод для записи, используя идентификаторы ресурсов в журнале событий. Затем создайте другой источник без файлов ресурсов и использующих этот источник в <xref:System.Diagnostics.EventLog.WriteEntry%2A> метод для записи строк непосредственно в журнале событий, с помощью этого источника.  
  
> [!NOTE]
>  Если добавить запись к удаленному компьютеру, значение сообщения (строка текста) может оказаться непредвиденным, если на удаленном компьютере не запущена платформа .NET Framework.  
  
> [!NOTE]
>  Если `message` параметр содержит символ NUL, заканчивается на символ NUL сообщение в журнале событий.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog_WriteEntry_1_3#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog_WriteEntry_1_3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Не задано свойство <see cref="P:System.Diagnostics.EventLog.Source" /> класса <see cref="T:System.Diagnostics.EventLog" />.  
  
-или- 
Метод пытается зарегистрировать новый источник событий, но имя компьютера в <see cref="P:System.Diagnostics.EventLog.MachineName" /> является недопустимым.  
  
-или- 
Источник уже зарегистрирован для различных журналов событий.  
  
-или- 
 <paramref name="eventID" /> меньше нуля или больше <see cref="F:System.UInt16.MaxValue" />.  
  
-или- 
Строка сообщения превышает 31,839 байт (32,766 байт в операционных системах Windows до Windows Vista).  
  
-или- 
При таком имени источника длина пути к разделу реестра превышает 254 символа.</exception>
        <exception cref="T:System.InvalidOperationException">Не удается открыть раздел реестра для журнала событий.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> не является допустимым <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Операционная система сообщила об ошибке при записи сведений о событии в журнал событий. Код ошибки Windows недоступен.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="source">Источник, по которому приложение регистрируется на указанном компьютере.</param>
        <param name="message">Строка для записи в журнал событий.</param>
        <param name="type">Одно из значений <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <summary>Вносит в журнал событий, используя указанный зарегистрированный источник, следующие записи с заданным текстом сообщения: ошибка, предупреждение, сведения, аудит отказов или аудит успехов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для записи указанного <xref:System.Diagnostics.EventLogEntryType> в журнал событий, используя в качестве источника зарегистрированный источник событий соответствующего журнала. `type` Указывает значок и текст в столбце типа в средстве просмотра событий для журнала.  
  
> [!NOTE]
>  `message` Строка не может содержать %*n*, где *n* является целым значением (например, %1), так как средство просмотра событий воспринимает его как строку вставки. Так как протокол Интернета версии 6 (IPv6) адрес может содержать это последовательность символов, не удается войти сообщение о событии, содержащий адрес IPv6.  
  
 Необходимо создать и настроить источник события перед записью первой записи с источником. Создайте новый источник событий во время установки приложения. Это экономит время ОС, чтобы обновить свой список зарегистрированных источников событий и их конфигурации. Если операционная система не обновлялись свой список источников событий и предпринимается попытка записать событие с новым источником, операция записи завершится сбоем. Можно настроить нового источника при помощи <xref:System.Diagnostics.EventLogInstaller>, или с помощью <xref:System.Diagnostics.EventLog.CreateEventSource%2A> метод. Вам необходимы права администратора на компьютере, чтобы создать новый источник событий.  
  
 Источник должен быть настроен для записи локализованных или исходных строк. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Метод записывает заданную строку непосредственно в журнал событий; он не использует файл ресурсов локализуемого сообщения. Используйте <xref:System.Diagnostics.EventLog.WriteEvent%2A> метод для записи событий с помощью локализованного файла ресурсов сообщений.  
  
 Если приложение записывает операции, используя идентификаторы ресурсов и строковые значения, необходимо зарегистрировать два отдельных источника. Например, настроить один источник с файлами ресурсов, а затем использовать этот источник в <xref:System.Diagnostics.EventLog.WriteEvent%2A> метод для записи, используя идентификаторы ресурсов в журнале событий. Затем создайте другой источник без файлов ресурсов и использующих этот источник в <xref:System.Diagnostics.EventLog.WriteEntry%2A> метод для записи строк непосредственно в журнале событий, с помощью этого источника.  
  
> [!NOTE]
>  Если `message` параметр содержит символ NUL, заканчивается на символ NUL сообщение в журнале событий.  
  
   
  
## Examples  
 Следующий пример производит запись предупреждение в журнал событий «MyNewLog», на локальном компьютере.  
  
 [!code-cpp[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значением <paramref name="source" /> является пустая строка ("").  
  
-или- 
Значение <paramref name="source" /> равно <see langword="null" />.  
  
-или- 
Строка сообщения превышает 31,839 байт (32,766 байт в операционных системах Windows до Windows Vista).  
  
-или- 
При таком имени источника длина пути к разделу реестра превышает 254 символа.</exception>
        <exception cref="T:System.InvalidOperationException">Не удается открыть раздел реестра для журнала событий.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> не является допустимым <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Операционная система сообщила об ошибке при записи сведений о событии в журнал событий. Код ошибки Windows недоступен.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer, category As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int * int16 -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="message">Строка для записи в журнал событий.</param>
        <param name="type">Одно из значений <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <param name="eventID">Идентификатор для события, зависящий от приложения.</param>
        <param name="category">Подкатегория конкретного приложения, связанная с сообщением.</param>
        <summary>Вносит в журнал событий запись с заданным текстом сообщения, идентификатором события и категорией, которая определяется приложением.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для записи с определенной приложением `category` в журнале событий. Средство просмотра событий использует категории для фильтрации событий, записанных источником события. Категория может отображаться в средстве просмотра событий как числовое значение или его можно использовать категорию как идентификатор ресурсов для отображения локализованной строки категории.  
  
> [!NOTE]
>  `category` Параметр должен быть положительным. Отрицательные значения категории отображаются как дополнительные положительные числа событий средства просмотра. Например -10 отображается как 65,526, значение -1 как 65 535.  
  
> [!NOTE]
>  `message` Строка не может содержать %*n*, где *n* является целым значением (например, %1), так как средство просмотра событий воспринимает его как строку вставки. Так как протокол Интернета версии 6 (IPv6) адрес может содержать это последовательность символов, не удается войти сообщение о событии, содержащий адрес IPv6.  
  
 Для отображения локализованных строк категории в средстве просмотра событий, необходимо использовать источник события с файлом ресурсов категории и задайте `category` идентификатор ресурса в файле ресурсов категории. Если источник события не является файлом ресурсов настроенных категорию, или указанный `category` не индексирует строку в файле ресурсов категории, то в средстве просмотра событий отображается числовое значение категории для этой записи. Настройка в файле ресурсов категории вместе с номером строки категорий в файле ресурсов с помощью <xref:System.Diagnostics.EventLogInstaller> или <xref:System.Diagnostics.EventSourceCreationData> класса.  
  
 В дополнение к данной категории можно указать идентификатор события для событий, записываемых в журнал событий. Идентификаторы событий, а также источник события, однозначно идентифицировать событие. Каждое приложение можно определить собственные нумерованные события и описание строки, с которыми они сопоставлены. При просмотре событий отображаются эти строковые значения, чтобы помочь пользователю определить, что пошло не так и какие действия предпринять.  
  
 Наконец, можно указать <xref:System.Diagnostics.EventLogEntryType> для событий, записываемых в журнал событий. `type` Указывает значок и текст в столбце типа в средстве просмотра событий для журнала. Этот параметр указывает, является ли тип события ошибку, предупреждение, сведения, аудит успехов или аудит отказов.  
  
 Необходимо задать <xref:System.Diagnostics.EventLog.Source%2A> свойство вашей <xref:System.Diagnostics.EventLog> компонента перед предоставлением записи в журнал. Необходимо создать и настроить источник события перед записью первой записи с источником.  
  
 Создайте новый источник событий во время установки приложения. Это экономит время ОС, чтобы обновить свой список зарегистрированных источников событий и их конфигурации. Если операционная система не обновлялись свой список источников событий и предпринимается попытка записать событие с новым источником, операция записи завершится сбоем. Можно настроить нового источника при помощи <xref:System.Diagnostics.EventLogInstaller>, или с помощью <xref:System.Diagnostics.EventLog.CreateEventSource%2A> метод. Вам необходимы права администратора на компьютере, чтобы создать новый источник событий.  
  
 Если источник, указанный в <xref:System.Diagnostics.EventLog.Source%2A> свойства данного объекта <xref:System.Diagnostics.EventLog> экземпляр не зарегистрирован на компьютере, на который осуществляется запись, <xref:System.Diagnostics.EventLog.WriteEntry%2A> вызовы <xref:System.Diagnostics.EventLog.CreateEventSource%2A> и регистрирует источник.  
  
> [!NOTE]
>  Если вы не укажете <xref:System.Diagnostics.EventLog.MachineName%2A> для вашей <xref:System.Diagnostics.EventLog> экземпляра перед вызовом метода <xref:System.Diagnostics.EventLog.CreateEventSource%2A> или <xref:System.Diagnostics.EventLog.WriteEntry%2A>, локальный компьютер (".») предполагается, что.  
  
 Если системе нужно зарегистрировать <xref:System.Diagnostics.EventLog.Source%2A> посредством вызова <xref:System.Diagnostics.EventLog.WriteEntry%2A> и <xref:System.Diagnostics.EventLog.Log%2A> свойство не задано на вашей <xref:System.Diagnostics.EventLog> экземпляра, по умолчанию будет использоваться в журнал приложений.  
  
> [!NOTE]
>  Многие описанные выше исключения создаются ошибки, возникшие во время процесса регистрации <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 Источник должен быть настроен для записи локализованных или исходных строк. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Метод записывает заданную строку непосредственно в журнал событий; он не использует файл ресурсов локализуемого сообщения. Используйте <xref:System.Diagnostics.EventLog.WriteEvent%2A> метод для записи событий с помощью локализованного файла ресурсов сообщений.  
  
 Если приложение записывает операции, используя идентификаторы ресурсов и строковые значения, необходимо зарегистрировать два отдельных источника. Например, настроить один источник с файлами ресурсов, а затем использовать этот источник в <xref:System.Diagnostics.EventLog.WriteEvent%2A> метод для записи, используя идентификаторы ресурсов в журнале событий. Затем создайте другой источник без файлов ресурсов и использующих этот источник в <xref:System.Diagnostics.EventLog.WriteEntry%2A> метод для записи строк непосредственно в журнале событий, с помощью этого источника.  
  
> [!NOTE]
>  Если добавить запись к удаленному компьютеру, значение сообщения (строка текста) может оказаться непредвиденным, если на удаленном компьютере не запущена платформа .NET Framework.  
  
> [!NOTE]
>  Если `message` параметр содержит символ NUL, заканчивается на символ NUL сообщение в журнале событий.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog_WriteEntry_1_3#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog_WriteEntry_1_3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Не задано свойство <see cref="P:System.Diagnostics.EventLog.Source" /> класса <see cref="T:System.Diagnostics.EventLog" />.  
  
-или- 
Метод пытается зарегистрировать новый источник событий, но имя компьютера в <see cref="P:System.Diagnostics.EventLog.MachineName" /> является недопустимым.  
  
-или- 
Источник уже зарегистрирован для различных журналов событий.  
  
-или- 
 <paramref name="eventID" /> меньше нуля или больше <see cref="F:System.UInt16.MaxValue" />.  
  
-или- 
Строка сообщения превышает 31,839 байт (32,766 байт в операционных системах Windows до Windows Vista).  
  
-или- 
При таком имени источника длина пути к разделу реестра превышает 254 символа.</exception>
        <exception cref="T:System.InvalidOperationException">Не удается открыть раздел реестра для журнала событий.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> не является допустимым <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Операционная система сообщила об ошибке при записи сведений о событии в журнал событий. Код ошибки Windows недоступен.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Источник, по которому приложение регистрируется на указанном компьютере.</param>
        <param name="message">Строка для записи в журнал событий.</param>
        <param name="type">Одно из значений <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <param name="eventID">Идентификатор для события, зависящий от приложения.</param>
        <summary>Вносит в журнал событий запись с заданным текстом сообщения и идентификатором события (который определяется приложением), используя указанный зарегистрированный источник событий.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для записи с определенной приложением `eventID` в журнал событий, используя в качестве источника зарегистрированный источник событий соответствующего журнала. `eventID`, И источники однозначной идентификации события. Каждое приложение можно определить собственные нумерованные события и описание строки, с которыми они сопоставлены. При просмотре событий эти строки отображаются пользователю, чтобы помочь пользователю понять, что пошло не так и какие действия предпринять.  
  
> [!NOTE]
>  `message` Строка не может содержать %*n*, где *n* является целым значением (например, %1), так как средство просмотра событий воспринимает его как строку вставки. Так как протокол Интернета версии 6 (IPv6) адрес может содержать это последовательность символов, не удается войти сообщение о событии, содержащий адрес IPv6.  
  
 В дополнение к идентификатор события, данная перегруженная версия <xref:System.Diagnostics.EventLog.WriteEntry%2A> позволяет указать <xref:System.Diagnostics.EventLogEntryType> для событий, записываемых в журнал событий. `type` Указывает значок и текст в столбце типа в средстве просмотра событий для журнала. Этот параметр указывает, является ли тип события ошибку, предупреждение, сведения, аудит успехов или аудит отказов.  
  
 Необходимо создать и настроить источник события перед записью первой записи с источником. Создайте новый источник событий во время установки приложения. Это экономит время ОС, чтобы обновить свой список зарегистрированных источников событий и их конфигурации. Если операционная система не обновлялись свой список источников событий и предпринимается попытка записать событие с новым источником, операция записи завершится сбоем. Можно настроить нового источника при помощи <xref:System.Diagnostics.EventLogInstaller>, или с помощью <xref:System.Diagnostics.EventLog.CreateEventSource%2A> метод. Вам необходимы права администратора на компьютере, чтобы создать новый источник событий.  
  
 Источник должен быть настроен для записи локализованных или исходных строк. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Метод записывает заданную строку непосредственно в журнал событий; он не использует файл ресурсов локализуемого сообщения. Используйте <xref:System.Diagnostics.EventLog.WriteEvent%2A> метод для записи событий с помощью локализованного файла ресурсов сообщений.  
  
 Если приложение записывает операции, используя идентификаторы ресурсов и строковые значения, необходимо зарегистрировать два отдельных источника. Например, настроить один источник с файлами ресурсов, а затем использовать этот источник в <xref:System.Diagnostics.EventLog.WriteEvent%2A> метод для записи, используя идентификаторы ресурсов в журнале событий. Затем создайте другой источник без файлов ресурсов и использующих этот источник в <xref:System.Diagnostics.EventLog.WriteEntry%2A> метод для записи строк непосредственно в журнале событий, с помощью этого источника.  
  
> [!NOTE]
>  Если `message` параметр содержит символ NUL, заканчивается на символ NUL сообщение в журнале событий.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_4#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_4/CPP/eventlog_writeentry_4.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_4#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_4/CS/eventlog_writeentry_4.cs#1)]
 [!code-vb[EventLog_WriteEntry_4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_4/VB/eventlog_writeentry_4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значением <paramref name="source" /> является пустая строка ("").  
  
-или- 
Значение <paramref name="source" /> равно <see langword="null" />.  
  
-или- 
 <paramref name="eventID" /> меньше нуля или больше <see cref="F:System.UInt16.MaxValue" />.  
  
-или- 
Строка сообщения превышает 31,839 байт (32,766 байт в операционных системах Windows до Windows Vista).  
  
-или- 
При таком имени источника длина пути к разделу реестра превышает 254 символа.</exception>
        <exception cref="T:System.InvalidOperationException">Не удается открыть раздел реестра для журнала событий.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> не является допустимым <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Операционная система сообщила об ошибке при записи сведений о событии в журнал событий. Код ошибки Windows недоступен.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer, category As Short, rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category, cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int * int16 * byte[] -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID, category, rawData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="message">Строка для записи в журнал событий.</param>
        <param name="type">Одно из значений <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <param name="eventID">Идентификатор для события, зависящий от приложения.</param>
        <param name="category">Подкатегория конкретного приложения, связанная с сообщением.</param>
        <param name="rawData">Массив байтов, в котором хранятся двоичные данные, связанные с записью.</param>
        <summary>Вносит в журнал событий запись с заданным текстом сообщения, идентификатором события и категорией (которые определяются приложением), а затем добавляет в сообщение двоичные данные.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод для записи определяемые приложением данные событий в журнале событий. Средство просмотра событий не интерпретирует эти данные; необработанные данные отображаются только в комбинированном шестнадцатеричном и текстовом формате. Используйте данные событий в меру, включая его только в том случае, если вы уверены, что она окажется полезной для решения проблемы. Данные событий может использоваться для хранения данных, можно обработать независимо от средство просмотра событий. Например можно написать средство просмотра событий, или написать программу, которая журнала и создает отчеты, содержащие данные, связанных с событием.  
  
 Помимо двоичных данных можно указать категорию и идентификатор события. Средство просмотра событий использует категории для фильтрации событий, записанных источником события. Категория может отображаться в средстве просмотра событий как числовое значение или его можно использовать категорию как идентификатор ресурсов для отображения локализованной строки категории.  
  
> [!NOTE]
>  `message` Строка не может содержать %*n*, где *n* является целым значением (например, %1), так как средство просмотра событий воспринимает его как строку вставки. Так как протокол Интернета версии 6 (IPv6) адрес может содержать это последовательность символов, не удается войти сообщение о событии, содержащий адрес IPv6.  
  
> [!NOTE]
>  `category` Параметр должен быть положительным. Отрицательные значения категории отображаются как дополнительные положительные числа событий средства просмотра. Например -10 отображается как 65,526, значение -1 как 65 535.  
  
 Для отображения локализованных строк категории в средстве просмотра событий, необходимо использовать источник события с файлом ресурсов категории и задайте `category` идентификатор ресурса в файле ресурсов категории. Если источник события не является файлом ресурсов настроенных категорию, или указанный `category` не индексирует строку в файле ресурсов категории, то в средстве просмотра событий отображается числовое значение категории для этой записи. Настройка в файле ресурсов категории вместе с номером строки категорий в файле ресурсов с помощью <xref:System.Diagnostics.EventLogInstaller> или <xref:System.Diagnostics.EventSourceCreationData> класса.  
  
 Идентификаторы событий, а также источник события, однозначно идентифицировать событие. Каждое приложение можно определить собственные нумерованные события и описание строки, с которыми они сопоставлены. При просмотре событий отображаются эти строковые значения, чтобы помочь пользователю определить, что пошло не так и какие действия предпринять.  
  
 Наконец, можно указать <xref:System.Diagnostics.EventLogEntryType> для событий, записываемых в журнал событий. `type` Указывает значок и текст в столбце типа в средстве просмотра событий для журнала. Этот параметр указывает, является ли тип события ошибку, предупреждение, сведения, аудит успехов или аудит отказов.  
  
 Необходимо задать <xref:System.Diagnostics.EventLog.Source%2A> свойство вашей <xref:System.Diagnostics.EventLog> компонента перед предоставлением записи в журнал. Необходимо создать и настроить источник события перед записью первой записи с источником.  
  
 Создайте новый источник событий во время установки приложения. Это экономит время ОС, чтобы обновить свой список зарегистрированных источников событий и их конфигурации. Если операционная система не обновлялись свой список источников событий и предпринимается попытка записать событие с новым источником, операция записи завершится сбоем. Можно настроить нового источника при помощи <xref:System.Diagnostics.EventLogInstaller>, или с помощью <xref:System.Diagnostics.EventLog.CreateEventSource%2A> метод. Вам необходимы права администратора на компьютере, чтобы создать новый источник событий.  
  
 Если источник, указанный в <xref:System.Diagnostics.EventLog.Source%2A> свойства данного объекта <xref:System.Diagnostics.EventLog> экземпляр не зарегистрирован на компьютере, на который осуществляется запись, <xref:System.Diagnostics.EventLog.WriteEntry%2A> вызовы <xref:System.Diagnostics.EventLog.CreateEventSource%2A> и регистрирует источник.  
  
> [!NOTE]
>  Если вы не укажете <xref:System.Diagnostics.EventLog.MachineName%2A> для вашей <xref:System.Diagnostics.EventLog> экземпляра перед вызовом метода <xref:System.Diagnostics.EventLog.CreateEventSource%2A> или <xref:System.Diagnostics.EventLog.WriteEntry%2A>, локальный компьютер (".») предполагается, что.  
  
 Если системе нужно зарегистрировать <xref:System.Diagnostics.EventLog.Source%2A> посредством вызова <xref:System.Diagnostics.EventLog.WriteEntry%2A> и <xref:System.Diagnostics.EventLog.Log%2A> свойство не задано на вашей <xref:System.Diagnostics.EventLog> экземпляра, по умолчанию будет использоваться в журнал приложений.  
  
> [!NOTE]
>  Многие описанные выше исключения создаются ошибки, возникшие во время процесса регистрации <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 Источник должен быть настроен для записи локализованных или исходных строк. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Метод записывает заданную строку непосредственно в журнал событий; он не использует файл ресурсов локализуемого сообщения. Используйте <xref:System.Diagnostics.EventLog.WriteEvent%2A> метод для записи событий с помощью локализованного файла ресурсов сообщений.  
  
 Если приложение записывает операции, используя идентификаторы ресурсов и строковые значения, необходимо зарегистрировать два отдельных источника. Например, настроить один источник с файлами ресурсов, а затем использовать этот источник в <xref:System.Diagnostics.EventLog.WriteEvent%2A> метод для записи, используя идентификаторы ресурсов в журнале событий. Затем создайте другой источник без файлов ресурсов и использующих этот источник в <xref:System.Diagnostics.EventLog.WriteEntry%2A> метод для записи строк непосредственно в журнале событий, с помощью этого источника.  
  
> [!NOTE]
>  Если добавить запись к удаленному компьютеру, значение сообщения (строка текста) может оказаться непредвиденным, если на удаленном компьютере не запущена платформа .NET Framework.  
  
> [!NOTE]
>  Если `message` параметр содержит символ NUL, заканчивается на символ NUL сообщение в журнале событий.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_5#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_5/CPP/eventlog_writeentry_5.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_5#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_5/CS/eventlog_writeentry_5.cs#1)]
 [!code-vb[EventLog_WriteEntry_5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_5/VB/eventlog_writeentry_5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Не задано свойство <see cref="P:System.Diagnostics.EventLog.Source" /> класса <see cref="T:System.Diagnostics.EventLog" />.  
  
-или- 
Метод пытается зарегистрировать новый источник событий, но имя компьютера в <see cref="P:System.Diagnostics.EventLog.MachineName" /> является недопустимым.  
  
-или- 
Источник уже зарегистрирован для различных журналов событий.  
  
-или- 
 <paramref name="eventID" /> меньше нуля или больше <see cref="F:System.UInt16.MaxValue" />.  
  
-или- 
Строка сообщения превышает 31,839 байт (32,766 байт в операционных системах Windows до Windows Vista).  
  
-или- 
При таком имени источника длина пути к разделу реестра превышает 254 символа.</exception>
        <exception cref="T:System.InvalidOperationException">Не удается открыть раздел реестра для журнала событий.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> не является допустимым <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Операционная система сообщила об ошибке при записи сведений о событии в журнал событий. Код ошибки Windows недоступен.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer, category As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int * int16 -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="source">Источник, по которому приложение регистрируется на указанном компьютере.</param>
        <param name="message">Строка для записи в журнал событий.</param>
        <param name="type">Одно из значений <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <param name="eventID">Идентификатор для события, зависящий от приложения.</param>
        <param name="category">Подкатегория конкретного приложения, связанная с сообщением.</param>
        <summary>Вносит в журнал событий запись с заданным текстом сообщения и идентификатором события и категорией (которые определяется приложением), используя указанный зарегистрированный источник событий. С помощью <paramref name="category" /> осуществляется фильтрация событий журнала в компоненте "Просмотр событий".</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для записи с определенной приложением `category` в журнале событий, используя источник уже зарегистрирован как источник события, соответствующего журнала. Средство просмотра событий использует категории для фильтрации событий, записанных источником события. Категория может отображаться в средстве просмотра событий как числовое значение или его можно использовать категорию как идентификатор ресурсов для отображения локализованной строки категории.  
  
> [!NOTE]
>  `category` Параметр должен быть положительным. Отрицательные значения категории отображаются как дополнительные положительные числа событий средства просмотра. Например -10 отображается как 65,526, значение -1 как 65 535.  
  
 Для отображения локализованных строк категории в средстве просмотра событий, необходимо использовать источник события с файлом ресурсов категории и задайте `category` идентификатор ресурса в файле ресурсов категории. Если источник события не является файлом ресурсов настроенных категорию, или указанный `category` не индексирует строку в файле ресурсов категории, то в средстве просмотра событий отображается числовое значение категории для этой записи. Настройка в файле ресурсов категории вместе с номером строки категорий в файле ресурсов с помощью <xref:System.Diagnostics.EventLogInstaller> или <xref:System.Diagnostics.EventSourceCreationData> класса.  
  
 В дополнение к данной категории можно указать идентификатор события для событий, записываемых в журнал событий. Идентификаторы событий, а также источник события, однозначно идентифицировать событие. Каждое приложение можно определить собственные нумерованные события и описание строки, с которыми они сопоставлены. При просмотре событий отображаются эти строковые значения, чтобы помочь пользователю определить, что пошло не так и какие действия предпринять.  
  
 Наконец, можно указать <xref:System.Diagnostics.EventLogEntryType> для событий, записываемых в журнал событий. `type` Указывает значок и текст в столбце типа в средстве просмотра событий для журнала. Этот параметр указывает, является ли тип события ошибку, предупреждение, сведения, аудит успехов или аудит отказов.  
  
 Необходимо создать и настроить источник события перед записью первой записи с источником. Создайте новый источник событий во время установки приложения. Это экономит время ОС, чтобы обновить свой список зарегистрированных источников событий и их конфигурации. Если операционная система не обновлялись свой список источников событий и предпринимается попытка записать событие с новым источником, операция записи завершится сбоем. Можно настроить нового источника при помощи <xref:System.Diagnostics.EventLogInstaller>, или с помощью <xref:System.Diagnostics.EventLog.CreateEventSource%2A> метод. Вам необходимы права администратора на компьютере, чтобы создать новый источник событий.  
  
 Источник должен быть настроен для записи локализованных или исходных строк. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Метод записывает заданную строку непосредственно в журнал событий; он не использует файл ресурсов локализуемого сообщения. Используйте <xref:System.Diagnostics.EventLog.WriteEvent%2A> метод для записи событий с помощью локализованного файла ресурсов сообщений.  
  
 Если приложение записывает операции, используя идентификаторы ресурсов и строковые значения, необходимо зарегистрировать два отдельных источника. Например, настроить один источник с файлами ресурсов, а затем использовать этот источник в <xref:System.Diagnostics.EventLog.WriteEvent%2A> метод для записи, используя идентификаторы ресурсов в журнале событий. Затем создайте другой источник без файлов ресурсов и использующих этот источник в <xref:System.Diagnostics.EventLog.WriteEntry%2A> метод для записи строк непосредственно в журнале событий, с помощью этого источника.  
  
> [!NOTE]
>  Если `message` параметр содержит символ NUL, заканчивается на символ NUL сообщение в журнале событий.  
>   
>  `message` Строка не может содержать %*n*, где *n* является целым значением (например, %1), так как средство просмотра событий воспринимает его как строку вставки. Так как протокол Интернета версии 6 (IPv6) адрес может содержать это последовательность символов, не удается войти сообщение о событии, содержащий адрес IPv6.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_1_3#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#1)]
 [!code-vb[EventLog_WriteEntry_1_3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значением <paramref name="source" /> является пустая строка ("").  
  
-или- 
Значение <paramref name="source" /> равно <see langword="null" />.  
  
-или- 
 <paramref name="eventID" /> меньше нуля или больше <see cref="F:System.UInt16.MaxValue" />.  
  
-или- 
Строка сообщения превышает 31,839 байт (32,766 байт в операционных системах Windows до Windows Vista).  
  
-или- 
При таком имени источника длина пути к разделу реестра превышает 254 символа.</exception>
        <exception cref="T:System.InvalidOperationException">Не удается открыть раздел реестра для журнала событий.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> не является допустимым <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Операционная система сообщила об ошибке при записи сведений о событии в журнал событий. Код ошибки Windows недоступен.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer, category As Short, rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category, cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int * int16 * byte[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID, category, rawData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="source">Источник, по которому приложение регистрируется на указанном компьютере.</param>
        <param name="message">Строка для записи в журнал событий.</param>
        <param name="type">Одно из значений <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <param name="eventID">Идентификатор для события, зависящий от приложения.</param>
        <param name="category">Подкатегория конкретного приложения, связанная с сообщением.</param>
        <param name="rawData">Массив байтов, в котором хранятся двоичные данные, связанные с записью.</param>
        <summary>Вносит в журнал событий запись с заданным текстом сообщения, идентификатором события и категорией (которые определяются приложением), используя указанный зарегистрированный источник событий, а затем добавляет в сообщение двоичные данные.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для записи определяемые приложением данные событий в журнал событий, используя в качестве источника, уже зарегистрированный источник событий соответствующего журнала. Средство просмотра событий не интерпретирует эти данные; необработанные данные отображаются только в комбинированном шестнадцатеричном и текстовом формате. Использовать данные событий, минимально. Включайте только в том случае, если вы уверены, что она окажется полезной. Данные событий может использоваться для хранения данных, можно обработать независимо от средство просмотра событий. Например можно написать средство просмотра событий, или написать программу, которая журнала и создает отчеты, содержащие данные, связанных с событием.  
  
 Помимо двоичных данных можно указать категорию и идентификатор события. Средство просмотра событий использует категории для фильтрации событий, записанных источником события. Категория может отображаться в средстве просмотра событий как числовое значение или его можно использовать категорию как идентификатор ресурсов для отображения локализованной строки категории.  
  
> [!NOTE]
>  `category` Параметр должен быть положительным. Отрицательные значения категории отображаются как дополнительные положительные числа событий средства просмотра. Например -10 будет отображаться как 65,526, значение -1 как 65 535.  
  
 Для отображения локализованных строк категории в средстве просмотра событий, необходимо использовать источник события с файлом ресурсов категории и задайте `category` идентификатор ресурса в файле ресурсов категории. Если источник события не является файлом ресурсов настроенных категорию, или указанный `category` не индексирует строку в файле ресурсов категории, то в средстве просмотра событий отображается числовое значение категории для этой записи. Настройка в файле ресурсов категории вместе с номером строки категорий в файле ресурсов с помощью <xref:System.Diagnostics.EventLogInstaller> или <xref:System.Diagnostics.EventSourceCreationData> класса.  
  
 Идентификаторы событий, вместе с источником события, уникальной идентификации события. Каждое приложение можно определить собственные нумерованные события и описание строки, с которыми они сопоставлены. При просмотре событий отображаются эти строковые значения, чтобы помочь пользователю определить, что пошло не так и какие действия предпринять.  
  
 Наконец, можно указать <xref:System.Diagnostics.EventLogEntryType> для событий, записываемых в журнал событий. `type` Указывает значок и текст в столбце типа в средстве просмотра событий для журнала. Этот параметр указывает, является ли тип события ошибку, предупреждение, сведения, аудит успехов или аудит отказов.  
  
 Необходимо создать и настроить источник события перед записью первой записи с источником. Создайте новый источник событий во время установки приложения. Это экономит время ОС, чтобы обновить свой список зарегистрированных источников событий и их конфигурации. Если операционная система не обновлялись свой список источников событий и предпринимается попытка записать событие с новым источником, операция записи завершится сбоем. Можно настроить нового источника при помощи <xref:System.Diagnostics.EventLogInstaller>, или с помощью <xref:System.Diagnostics.EventLog.CreateEventSource%2A> метод. Вам необходимы права администратора на компьютере, чтобы создать новый источник событий.  
  
 Источник должен быть настроен для записи локализованных или исходных строк. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Метод записывает заданную строку непосредственно в журнал событий; он не использует файл ресурсов локализуемого сообщения. Используйте <xref:System.Diagnostics.EventLog.WriteEvent%2A> метод для записи событий с помощью локализованного файла ресурсов сообщений.  
  
 Если приложение записывает операции, используя идентификаторы ресурсов и строковые значения, необходимо зарегистрировать два отдельных источника. Например, настроить один источник с файлами ресурсов, а затем использовать этот источник в <xref:System.Diagnostics.EventLog.WriteEvent%2A> метод для записи, используя идентификаторы ресурсов в журнале событий. Затем создайте другой источник без файлов ресурсов и использующих этот источник в <xref:System.Diagnostics.EventLog.WriteEntry%2A> метод для записи строк непосредственно в журнале событий, с помощью этого источника.  
  
> [!NOTE]
>  Если `message` параметр содержит символ NUL, заканчивается на символ NUL сообщение в журнале событий.  
>   
>  `message` Строка не может содержать %*n*, где *n* является целым значением (например, %1), так как средство просмотра событий воспринимает его как строку вставки. Так как протокол Интернета версии 6 (IPv6) адрес может содержать это последовательность символов, не удается войти сообщение о событии, содержащий адрес IPv6.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#2)]
 [!code-csharp[EventLog_WriteEntry_1_3#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#2)]
 [!code-vb[EventLog_WriteEntry_1_3#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значением <paramref name="source" /> является пустая строка ("").  
  
-или- 
Значение <paramref name="source" /> равно <see langword="null" />.  
  
-или- 
 <paramref name="eventID" /> меньше нуля или больше <see cref="F:System.UInt16.MaxValue" />.  
  
-или- 
Строка сообщения превышает 31,839 байт (32,766 байт в операционных системах Windows до Windows Vista).  
  
-или- 
При таком имени источника длина пути к разделу реестра превышает 254 символа.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> не является допустимым <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.InvalidOperationException">Не удается открыть раздел реестра для журнала событий.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Операционная система сообщила об ошибке при записи сведений о событии в журнал событий. Код ошибки Windows недоступен.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEvent">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Вносит записи локализованных событий в журнал событий.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEvent (instance As EventInstance, ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEvent(System::Diagnostics::EventInstance ^ instance, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : System.Diagnostics.EventInstance * obj[] -&gt; unit" Usage="eventLog.WriteEvent (instance, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Экземпляр <see cref="T:System.Diagnostics.EventInstance" />, который представляет локализованную запись журнала событий.</param>
        <param name="values">Массив строк для слияния в текстовое сообщение записи журнала событий.</param>
        <summary>Вносит локализованные записи в журнал событий.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для записи локализованные записи в журнал событий. Укажите свойства событий с идентификаторами ресурсов, а не строковые значения. Средство просмотра событий использует идентификаторы ресурсов для отображения соответствующих строк из локализованного файла ресурсов для <xref:System.Diagnostics.EventLog.Source%2A>. Необходимо зарегистрировать источник в соответствующем файле ресурсов, прежде чем писать события, используя идентификаторы ресурсов.  
  
 Входные данные `instance` экземпляр указывает сообщение события и свойства. Задайте <xref:System.Diagnostics.EventInstance.InstanceId%2A> из `instance` входных данных для определенного сообщения в файле ресурсов сообщения источника. При необходимости можно задать <xref:System.Diagnostics.EventInstance.CategoryId%2A> и <xref:System.Diagnostics.EventInstance.EntryType%2A> из `instance` входных данных, чтобы определить тип категории и события записи событий. Можно также указать массив строк независимый от языка для вставки в текст локализованного сообщения. Задайте `values` для `null` Если сообщение о событии не содержит местозаполнители для строки замены.  
  
 Необходимо задать <xref:System.Diagnostics.EventLog.Source%2A> свойство вашей <xref:System.Diagnostics.EventLog> компонента перед использованием <xref:System.Diagnostics.EventLog.WriteEvent%2A>. Указанный источник должен быть настроен для записи локализованных записей в журнал; источник должен как минимум иметь определенный файл ресурсов сообщения.  
  
 Необходимо создать и настроить источник события перед записью первой записи с источником. Создайте новый источник событий во время установки приложения. Это экономит время ОС, чтобы обновить свой список зарегистрированных источников событий и их конфигурации. Если операционная система не обновлялись свой список источников событий и предпринимается попытка записать событие с новым источником, операция записи завершится сбоем. Можно настроить нового источника при помощи <xref:System.Diagnostics.EventLogInstaller>, или с помощью <xref:System.Diagnostics.EventLog.CreateEventSource%2A> метод. Вам необходимы права администратора на компьютере, чтобы создать новый источник событий.  
  
 Источник должен быть настроен для записи локализованных или исходных строк. Используйте <xref:System.Diagnostics.EventLog.WriteEntry%2A> метод, если приложение записывает строковые значения непосредственно в журнал событий.  
  
 Если приложение записывает операции, используя идентификаторы ресурсов и строковые значения, необходимо зарегистрировать два отдельных источника. Например, настроить один источник с файлами ресурсов, а затем использовать этот источник в <xref:System.Diagnostics.EventLog.WriteEvent%2A> метод для записи, используя идентификаторы ресурсов в журнале событий. Затем создайте другой источник без файлов ресурсов и использующих этот источник в <xref:System.Diagnostics.EventLog.WriteEntry%2A> метод для записи строк непосредственно в журнале событий, с помощью этого источника.  
  
> [!NOTE]
>  Если добавить запись к удаленному компьютеру, значение `message` строка не может быть от ожидаемых, если на удаленном компьютере не запущена платформа .NET Framework. Кроме того `message` строка не может содержать %*n*, где *n* является целым значением (например, %1), так как средство просмотра событий воспринимает его как строку вставки. Так как протокол Интернета версии 6 (IPv6) адрес может содержать это последовательность символов, не удается войти сообщение о событии, содержащий адрес IPv6.  
  
   
  
## Examples  
 Следующий пример записывает две записи, в журнал событий аудита `myNewLog`. В примере создается новый источник событий и новый журнал событий, если они не существуют на локальном компьютере. Текст сообщения события задается с помощью идентификатора ресурса в файле ресурсов.  
  
 [!code-cpp[EventLog_WriteEvent#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog_WriteEvent#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog_WriteEvent#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 В примере используется следующий текстовый файл сообщения, встроенный в библиотеку ресурсов EventLogMsgs.dll. Текстовый файл сообщения — источник, из которого создается файле ресурсов сообщения. В текстовом файле сообщения определяет, идентификаторы ресурсов и текст категории, сообщения о событии и строки вставки параметров.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Не задано свойство <see cref="P:System.Diagnostics.EventLog.Source" /> класса <see cref="T:System.Diagnostics.EventLog" />.  
  
-или- 
Метод пытается зарегистрировать новый источник событий, но имя компьютера в <see cref="P:System.Diagnostics.EventLog.MachineName" /> является недопустимым.  
  
-или- 
Источник уже зарегистрирован для различных журналов событий.  
  
-или- 
 <paramref name="instance.InstanceId" /> меньше нуля или больше <see cref="F:System.UInt16.MaxValue" />.  
  
-или- 
 <paramref name="values" /> содержит более 256 элементов.  
  
-или- 
Один из элементов <paramref name="values" /> длиннее 32766 байт.  
  
-или- 
При таком имени источника длина пути к разделу реестра превышает 254 символа.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="instance" /> — <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Не удается открыть раздел реестра для журнала событий.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Операционная система сообщила об ошибке при записи сведений о событии в журнал событий. Код ошибки Windows недоступен.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, byte[] data, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEvent (instance As EventInstance, data As Byte(), ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEvent(System::Diagnostics::EventInstance ^ instance, cli::array &lt;System::Byte&gt; ^ data, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : System.Diagnostics.EventInstance * byte[] * obj[] -&gt; unit" Usage="eventLog.WriteEvent (instance, data, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="data" Type="System.Byte[]" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Экземпляр <see cref="T:System.Diagnostics.EventInstance" />, который представляет локализованную запись журнала событий.</param>
        <param name="data">Массив байтов, в котором хранятся двоичные данные, связанные с записью.</param>
        <param name="values">Массив строк для слияния в текстовое сообщение записи журнала событий.</param>
        <summary>Заносит записи журнала событий с данными события, строками замещения сообщения и связанными двоичными данными.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для записи в журнал событий локализованные записи с использованием дополнительных данных, связанных с событием. Укажите свойства событий с идентификаторами ресурсов, а не строковые значения. Средство просмотра событий использует идентификаторы ресурсов для отображения соответствующих строк из локализованного файла ресурсов для <xref:System.Diagnostics.EventLog.Source%2A>. Необходимо зарегистрировать источник в соответствующем файле ресурсов, прежде чем писать события, используя идентификаторы ресурсов.  
  
 Входные данные `instance` экземпляр указывает сообщение события и свойства. Задайте <xref:System.Diagnostics.EventInstance.InstanceId%2A> из `instance` входных данных для определенного сообщения в файле ресурсов сообщения источника. При необходимости можно задать <xref:System.Diagnostics.EventInstance.CategoryId%2A> и <xref:System.Diagnostics.EventInstance.EntryType%2A> из `instance` входных данных, чтобы определить тип категории и события записи событий. Можно также указать массив строк независимый от языка для вставки в текст локализованного сообщения. Задайте `values` для `null` Если сообщение о событии не содержит местозаполнители для строки замены.  
  
 Укажите двоичные данные с событием, если необходимо предоставить дополнительные данные для события. Например, использовать `data` параметр, чтобы включить сведения о конкретной ошибке. Средство просмотра событий не интерпретирует данные; данные отображаются в комбинированном шестнадцатеричном и текстовом формате. Использовать данные событий, минимально. Включайте только в том случае, если вы уверены, что она окажется полезной. Данные событий может использоваться для хранения данных, можно обработать независимо от средство просмотра событий. Например можно написать средство просмотра событий, или написать программу, которая просматривает журнал событий и создает отчеты, содержащие данные, связанных с событием.  
  
 Необходимо задать <xref:System.Diagnostics.EventLog.Source%2A> свойство вашей <xref:System.Diagnostics.EventLog> компонент перед компонентом перед использованием <xref:System.Diagnostics.EventLog.WriteEvent%2A>. Указанный источник должен быть настроен для записи локализованных записей в журнал; источник должен как минимум иметь определенный файл ресурсов сообщения.  
  
 Необходимо создать и настроить источник события перед записью первой записи с источником. Создайте новый источник событий во время установки приложения. Это экономит время ОС, чтобы обновить свой список зарегистрированных источников событий и их конфигурации. Если операционная система не обновлялись свой список источников событий и предпринимается попытка записать событие с новым источником, операция записи завершится сбоем. Можно настроить нового источника при помощи <xref:System.Diagnostics.EventLogInstaller>, или с помощью <xref:System.Diagnostics.EventLog.CreateEventSource%2A> метод. Вам необходимы права администратора на компьютере, чтобы создать новый источник событий.  
  
> [!NOTE]
>  Если вы не укажете <xref:System.Diagnostics.EventLog.MachineName%2A> для вашей <xref:System.Diagnostics.EventLog> экземпляра перед вызовом метода <xref:System.Diagnostics.EventLog.WriteEvent%2A>, локальный компьютер (".») предполагается, что.  
  
 Источник должен быть настроен для записи локализованных или исходных строк. Используйте <xref:System.Diagnostics.EventLog.WriteEntry%2A> метод, если приложение записывает строковые значения непосредственно в журнал событий.  
  
 Если приложение записывает операции, используя идентификаторы ресурсов и строковые значения, необходимо зарегистрировать два отдельных источника. Например, настроить один источник с файлами ресурсов, а затем использовать этот источник в <xref:System.Diagnostics.EventLog.WriteEvent%2A> метод для записи, используя идентификаторы ресурсов в журнале событий. Затем создайте другой источник без файлов ресурсов и использующих этот источник в <xref:System.Diagnostics.EventLog.WriteEntry%2A> метод для записи строк непосредственно в журнале событий, с помощью этого источника.  
  
> [!NOTE]
>  Если добавить запись к удаленному компьютеру, значение `message` строка не может быть от ожидаемых, если на удаленном компьютере не запущена платформа .NET Framework. Кроме того `message` строка не может содержать %*n*, где *n* является целым значением (например, %1), так как средство просмотра событий воспринимает его как строку вставки. Так как протокол Интернета версии 6 (IPv6) адрес может содержать это последовательность символов, не удается войти сообщение о событии, содержащий адрес IPv6.  
  
   
  
## Examples  
 Следующий пример записывает две записи, в журнал событий аудита `myNewLog`. В примере создается новый источник событий и новый журнал событий, если они не существуют на локальном компьютере. Текст сообщения события задается с помощью идентификатора ресурса в файле ресурсов.  
  
 [!code-cpp[EventLog_WriteEvent#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog_WriteEvent#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog_WriteEvent#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 В примере используется следующий текстовый файл сообщения, встроенный в библиотеку ресурсов EventLogMsgs.dll. Текстовый файл сообщения — источник, из которого создается файле ресурсов сообщения. В текстовом файле сообщения определяет, идентификаторы ресурсов и текст категории, сообщения о событии и строки вставки параметров.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Не задано свойство <see cref="P:System.Diagnostics.EventLog.Source" /> класса <see cref="T:System.Diagnostics.EventLog" />.  
  
-или- 
Метод пытается зарегистрировать новый источник событий, но имя компьютера в <see cref="P:System.Diagnostics.EventLog.MachineName" /> является недопустимым.  
  
-или- 
Источник уже зарегистрирован для различных журналов событий.  
  
-или- 
 <paramref name="instance.InstanceId" /> меньше нуля или больше <see cref="F:System.UInt16.MaxValue" />.  
  
-или- 
 <paramref name="values" /> содержит более 256 элементов.  
  
-или- 
Один из элементов <paramref name="values" /> длиннее 32766 байт.  
  
-или- 
При таком имени источника длина пути к разделу реестра превышает 254 символа.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="instance" /> — <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Не удается открыть раздел реестра для журнала событий.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Операционная система сообщила об ошибке при записи сведений о событии в журнал событий. Код ошибки Windows недоступен.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEvent (source As String, instance As EventInstance, ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEvent(System::String ^ source, System::Diagnostics::EventInstance ^ instance, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member WriteEvent : string * System.Diagnostics.EventInstance * obj[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEvent (source, instance, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">Имя источника событий, зарегистрированного для приложения на заданном компьютере.</param>
        <param name="instance">Экземпляр <see cref="T:System.Diagnostics.EventInstance" />, который представляет локализованную запись журнала событий.</param>
        <param name="values">Массив строк для слияния в текстовое сообщение записи журнала событий.</param>
        <summary>Вносит в журнал событий запись с заданными данными сообщения и строками замещения сообщения, используя указанный зарегистрированный источник событий.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для записи локализованные записи в журнал событий, используя в качестве источника, уже зарегистрированный источник событий соответствующего журнала. Укажите свойства событий с идентификаторами ресурсов, а не строковые значения. Средство просмотра событий использует идентификаторы ресурсов для отображения соответствующих строк из локализованного файла ресурса для источника. Необходимо зарегистрировать источник в соответствующем файле ресурсов, прежде чем писать события, используя идентификаторы ресурсов.  
  
 Входные данные `instance` экземпляр указывает сообщение события и свойства. Задайте <xref:System.Diagnostics.EventInstance.InstanceId%2A> из `instance` входных данных для определенного сообщения в файле ресурсов сообщения источника. При необходимости можно задать <xref:System.Diagnostics.EventInstance.CategoryId%2A> и <xref:System.Diagnostics.EventInstance.EntryType%2A> из `instance` входных данных, чтобы определить тип категории и события записи событий. Можно также указать массив строк независимый от языка для вставки в текст локализованного сообщения. Задайте `values` для `null` Если сообщение о событии не содержит местозаполнители для строки замены.  
  
 Указанный источник должен быть зарегистрирован для журнала событий, прежде чем использовать <xref:System.Diagnostics.EventLog.WriteEvent%2A>. Указанный источник должен быть настроен для записи локализованных записей в журнал; источник должен как минимум иметь определенный файл ресурсов сообщения.  
  
 Необходимо создать и настроить источник события перед записью первой записи с источником. Создайте новый источник событий во время установки приложения. Это экономит время ОС, чтобы обновить свой список зарегистрированных источников событий и их конфигурации. Если операционная система не обновлялись свой список источников событий и предпринимается попытка записать событие с новым источником, операция записи завершится сбоем. Можно настроить нового источника при помощи <xref:System.Diagnostics.EventLogInstaller>, или с помощью <xref:System.Diagnostics.EventLog.CreateEventSource%2A> метод. Вам необходимы права администратора на компьютере, чтобы создать новый источник событий.  
  
 Источник должен быть настроен для записи локализованных или исходных строк. Используйте <xref:System.Diagnostics.EventLog.WriteEntry%2A> метод, если приложение записывает строковые значения непосредственно в журнал событий.  
  
 Если приложение записывает операции, используя идентификаторы ресурсов и строковые значения, необходимо зарегистрировать два отдельных источника. Например, настроить один источник с файлами ресурсов, а затем использовать этот источник в <xref:System.Diagnostics.EventLog.WriteEvent%2A> метод для записи, используя идентификаторы ресурсов в журнале событий. Затем создайте другой источник без файлов ресурсов и использующих этот источник в <xref:System.Diagnostics.EventLog.WriteEntry%2A> метод для записи строк непосредственно в журнале событий, с помощью этого источника.  
  
   
  
## Examples  
 Следующий пример записывает информационного события и запись события предупреждения для существующего журнала событий. Текст сообщения события задается с помощью идентификатора ресурса в файле ресурсов. В примере предполагается, что соответствующий файл ресурсов зарегистрирован для источника.  
  
 [!code-cpp[EventLog_WriteEvent#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog_WriteEvent#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog_WriteEvent#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 В примере используется следующий текстовый файл сообщения, встроенный в библиотеку ресурсов EventLogMsgs.dll. Текстовый файл сообщения — источник, из которого создается файле ресурсов сообщения. В текстовом файле сообщения определяет, идентификаторы ресурсов и текст категории, сообщения о событии и строки вставки параметров.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значением <paramref name="source" /> является пустая строка ("").  
  
-или- 
Значение <paramref name="source" /> равно <see langword="null" />.  
  
-или- 
 <paramref name="instance.InstanceId" /> меньше нуля или больше <see cref="F:System.UInt16.MaxValue" />.  
  
-или- 
 <paramref name="values" /> содержит более 256 элементов.  
  
-или- 
Один из элементов <paramref name="values" /> длиннее 32766 байт.  
  
-или- 
При таком имени источника длина пути к разделу реестра превышает 254 символа.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="instance" /> — <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Не удается открыть раздел реестра для журнала событий.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Операционная система сообщила об ошибке при записи сведений о событии в журнал событий. Код ошибки Windows недоступен.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, byte[] data, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEvent (source As String, instance As EventInstance, data As Byte(), ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEvent(System::String ^ source, System::Diagnostics::EventInstance ^ instance, cli::array &lt;System::Byte&gt; ^ data, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member WriteEvent : string * System.Diagnostics.EventInstance * byte[] * obj[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEvent (source, instance, data, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="data" Type="System.Byte[]" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="3" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">Имя источника событий, зарегистрированного для приложения на заданном компьютере.</param>
        <param name="instance">Экземпляр <see cref="T:System.Diagnostics.EventInstance" />, который представляет локализованную запись журнала событий.</param>
        <param name="data">Массив байтов, в котором хранятся двоичные данные, связанные с записью.</param>
        <param name="values">Массив строк для слияния в текстовое сообщение записи журнала событий.</param>
        <summary>Вносит в журнал событий запись с заданными данными сообщения, строками замещения сообщения и связанными двоичными данными, используя указанный зарегистрированный источник событий.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для записи в журнал событий, используя в качестве источника, уже зарегистрированный источник событий соответствующего журнала локализованные записи с использованием дополнительных данных, связанных с событием. Укажите свойства событий с идентификаторами ресурсов, а не строковые значения. Средство просмотра событий использует идентификаторы ресурсов для отображения соответствующих строк из локализованного файла ресурса для источника. Необходимо зарегистрировать источник в соответствующем файле ресурсов, прежде чем писать события, используя идентификаторы ресурсов.  
  
 Входные данные `instance` экземпляр указывает сообщение события и свойства. Задайте <xref:System.Diagnostics.EventInstance.InstanceId%2A> из `instance` входных данных для определенного сообщения в файле ресурсов сообщения источника. При необходимости можно задать <xref:System.Diagnostics.EventInstance.CategoryId%2A> и <xref:System.Diagnostics.EventInstance.EntryType%2A> из `instance` входных данных, чтобы определить тип категории и события записи событий. Можно также указать массив строк независимый от языка для вставки в текст локализованного сообщения. Задайте `values` для `null` Если сообщение о событии не содержит местозаполнители для строки замены.  
  
 Укажите двоичные данные с событием, если необходимо предоставить дополнительные данные для события. Например, использовать `data` параметр, чтобы включить сведения о конкретной ошибке. Средство просмотра событий не интерпретирует данные; данные отображаются в комбинированном шестнадцатеричном и текстовом формате. Использовать данные событий, минимально. Включайте только в том случае, если вы уверены, что она окажется полезной. Данные событий может использоваться для хранения данных, можно обработать независимо от средство просмотра событий. Например можно написать средство просмотра событий, или написать программу, которая просматривает журнал событий и создает отчеты, содержащие данные, связанных с событием.  
  
 Указанный источник должен быть зарегистрирован для журнала событий, прежде чем использовать <xref:System.Diagnostics.EventLog.WriteEvent%2A>. Указанный источник должен быть настроен для записи локализованных записей в журнал; источник должен как минимум иметь определенный файл ресурсов сообщения.  
  
 Необходимо создать и настроить источник события перед записью первой записи с источником. Создайте новый источник событий во время установки приложения. Это экономит время ОС, чтобы обновить свой список зарегистрированных источников событий и их конфигурации. Если операционная система не обновлялись свой список источников событий и предпринимается попытка записать событие с новым источником, операция записи завершится сбоем. Можно настроить нового источника при помощи <xref:System.Diagnostics.EventLogInstaller>, или с помощью <xref:System.Diagnostics.EventLog.CreateEventSource%2A> метод. Вам необходимы права администратора на компьютере, чтобы создать новый источник событий.  
  
 Источник должен быть настроен для записи локализованных или исходных строк. Используйте <xref:System.Diagnostics.EventLog.WriteEntry%2A> метод, если приложение записывает строковые значения непосредственно в журнал событий.  
  
 Если приложение записывает операции, используя идентификаторы ресурсов и строковые значения, необходимо зарегистрировать два отдельных источника. Например, настроить один источник с файлами ресурсов, а затем использовать этот источник в <xref:System.Diagnostics.EventLog.WriteEvent%2A> метод для записи, используя идентификаторы ресурсов в журнале событий. Затем создайте другой источник без файлов ресурсов и использующих этот источник в <xref:System.Diagnostics.EventLog.WriteEntry%2A> метод для записи строк непосредственно в журнале событий, с помощью этого источника.  
  
   
  
## Examples  
 Следующий пример записывает информационного события и запись события предупреждения для существующего журнала событий. Текст сообщения события задается с помощью идентификатора ресурса в файле ресурсов. В примере предполагается, что соответствующий файл ресурсов зарегистрирован для источника.  
  
 [!code-cpp[EventLog_WriteEvent#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog_WriteEvent#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog_WriteEvent#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 В примере используется следующий текстовый файл сообщения, встроенный в библиотеку ресурсов EventLogMsgs.dll. Текстовый файл сообщения — источник, из которого создается файле ресурсов сообщения. В текстовом файле сообщения определяет, идентификаторы ресурсов и текст категории, сообщения о событии и строки вставки параметров.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значением <paramref name="source" /> является пустая строка ("").  
  
-или- 
Значение <paramref name="source" /> равно <see langword="null" />.  
  
-или- 
 <paramref name="instance.InstanceId" /> меньше нуля или больше <see cref="F:System.UInt16.MaxValue" />.  
  
-или- 
 <paramref name="values" /> содержит более 256 элементов.  
  
-или- 
Один из элементов <paramref name="values" /> длиннее 32766 байт.  
  
-или- 
При таком имени источника длина пути к разделу реестра превышает 254 символа.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="instance" /> — <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Не удается открыть раздел реестра для журнала событий.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Операционная система сообщила об ошибке при записи сведений о событии в журнал событий. Код ошибки Windows недоступен.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">для записи данных журнала событий на компьютере. Связанное перечисление: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
  </Members>
</Type>