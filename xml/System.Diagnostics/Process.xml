<Type Name="Process" FullName="System.Diagnostics.Process">
  <Metadata><Meta Name="ms.openlocfilehash" Value="96bb35a7974092ace0053369ef712dd08404c5fc" /><Meta Name="ms.sourcegitcommit" Value="367e1eae0725e6da7136cd073aaa856ded5d5c29" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="12/13/2019" /><Meta Name="ms.locfileid" Value="75026941" /></Metadata><TypeSignature Language="C#" Value="public class Process : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Process extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Process" />
  <TypeSignature Language="VB.NET" Value="Public Class Process&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Process : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type Process = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
      <AttributeName>System.ComponentModel.DefaultEvent("Exited")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
      <AttributeName>System.ComponentModel.DefaultProperty("StartInfo")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.MonitoringDescription("Provides access to local and remote processes, enabling starting and stopping of local processes.")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.MonitoringDescription("ProcessDesc")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=2.0.5.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет доступ к локальным и удаленным процессам и позволяет запускать и останавливать локальные системные процессы.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Компонент <xref:System.Diagnostics.Process> предоставляет доступ к процессу, который выполняется на компьютере. Процесс, упрощенно говоря, представляет из себя работающее приложение. Поток — это базовая единица, которой операционная система выделяет время процессора. Поток может исполнять любую часть кода процесса, включая части, выполняющиеся в данный момент другим потоком.  
  
 Компонент <xref:System.Diagnostics.Process> — это полезное средство для запуска, остановки, контроля и мониторинга приложений. Компонент <xref:System.Diagnostics.Process> можно использовать для получения списка запущенных процессов или для запуска нового процесса. <xref:System.Diagnostics.Process> используется для доступа к системным процессам. После инициализации компонента <xref:System.Diagnostics.Process> его можно использовать для получения сведений о запущенном процессе. Эти сведения включают в себя набор потоков, загруженные модули (файлы .dll и .exe) и информацию о производительности, например объем памяти, используемой процессом.  
  
 Этот тип реализует интерфейс <xref:System.IDisposable>. По окончании использования выдаленную ему память следует прямо или косвенно освободить. Чтобы сделать это прямо, вызовите его метод <xref:System.IDisposable.Dispose%2A> в блоке `try`/`finally`. Чтобы сделать это косвенно, используйте языковые конструкции, такие как `using` (в C#) или `Using` (в Visual Basic). Дополнительные сведения см. в разделе "Использование объекта, реализующего IDisposable" в статье об интерфейсе <xref:System.IDisposable>.  
  
> [!NOTE]
>  32-разрядные процессы не могут получить доступ к модулям 64-разрядных процессов. При попытке получить сведения о 64-разрядном процессе из 32-разрядного процесса вы получите исключение <xref:System.ComponentModel.Win32Exception>. С другой стороны, 64-разрядный процесс может получить доступ к модулям 32-разрядного процесса.  
  
 Компонент Process получает сведения о группе свойств одновременно. После того, как компонент <xref:System.Diagnostics.Process> получит информацию о хотя бы одном члене любой группы, он будет кэшировать значения для других свойств в этой группе и не будет получать новые сведения о других членах группы до вызова метода <xref:System.Diagnostics.Process.Refresh%2A>. Таким образом, значение свойства не обязательно будет новее, чем в момент последнего вызова метода <xref:System.Diagnostics.Process.Refresh%2A>. Схемы разделения на группы зависят от операционной системы.  
  
 Если в системе объявлен заключенный в кавычки путь в переменной path, при запуске любого процесса из этого расположения необходимо указание полного пути. В противном случае система не найдет этот путь. Например, если в переменной path нет пути `c:\mypath` и он добавляется к ней с использованием кавычек (`path = %path%;"c:\mypath"`), при запуске любого процесса из `c:\mypath` необходимо полностью указывать путь к файлу.  
  
 Системный процесс однозначно идентифицируется в системе идентификатором процесса. Как и многие ресурсы Windows, процесс также идентифицируется его дескриптором, который не обязательно является уникальным в пределах одного компьютера. Дескриптор — это универсальный термин, обозначающий идентификатор ресурса. Операционная система сохраняет дескриптор процесса, доступный через свойство <xref:System.Diagnostics.Process.Handle%2A> компонента <xref:System.Diagnostics.Process>, даже после завершения процесса. Таким образом, можно получить административную информацию о процессе, например <xref:System.Diagnostics.Process.ExitCode%2A> (обычно ноль в случае успешного завершения или ненулевой код ошибки) и <xref:System.Diagnostics.Process.ExitTime%2A>. Дескрипторы являются чрезвычайно важным ресурсом, поэтому утечка дескрипторов более опасна, чем утечка памяти.  
  
> [!NOTE]
>  Этот класс содержит требования связывания и наследования на уровне класса, которые применяются ко всем элементам. Если непосредственно вызывающий оператор или производный класс не имеет разрешения полного доверия, возникает исключение <xref:System.Security.SecurityException>. Дополнительные сведения о требованиях безопасности см. в разделе [Требования связывания](~/docs/framework/misc/link-demands.md).  
  
<a name="Core"></a>   
## <a name="includenet_coreincludesnet-core-mdmd-notes"></a>Примечания по [!INCLUDE[net_core](~/includes/net-core-md.md)]  
 В .NET Framework класс <xref:System.Diagnostics.Process> по умолчанию использует кодировки <xref:System.Console>, которые обычно являются кодовыми страницами, для потоков ввода, вывода и ошибок. Например, в системах, где в настройках языка и региональных параметров установлен английский (США), кодировкой по умолчанию для класса <xref:System.Console> является кодовая страница 437. Однако в [!INCLUDE[net_core](~/includes/net-core-md.md)] может быть доступен только ограниченный набор кодировок. Если это так, в качестве кодировки по умолчанию будет использоваться <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType>.  
  
 Если объект <xref:System.Diagnostics.Process> зависит от конкретных кодовых страниц, вы можете по-прежнему сделать их доступными, выполнив указанные ниже действия *перед* вызовом любых методов класса <xref:System.Diagnostics.Process>:  
  
1.  Добавьте в проект ссылку на сборку System.Text.Encoding.CodePages.dll.  
  
2.  Получите объект <xref:System.Text.EncodingProvider> из свойства <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType>.  
  
3.  Передайте объект <xref:System.Text.EncodingProvider> в метод <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType>, чтобы сделать доступными дополнительные кодировки, поддерживаемые поставщиком кодировки.  
  
 Класс <xref:System.Diagnostics.Process> будет автоматически использовать кодировку системы по умолчанию вместо UTF8 при условии, что вы зарегистрировали поставщик кодировки перед вызовом любых методов класса <xref:System.Diagnostics.Process>.  
  
   
  
## Examples  
 В следующем примере для запуска процесса используется экземпляр класса <xref:System.Diagnostics.Process>.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 В следующем примере для запуска процесса используется сам класс <xref:System.Diagnostics.Process> и его статический метод <xref:System.Diagnostics.Process.Start%2A>.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 В следующем примере на F# задается функция `runProc`, которая запускает процесс, получает все выходные данные и сведения об ошибках и записывает время выполнения процесса в миллисекундах.  Функция `runProc` имеет три параметра: имя запускаемого приложения, аргументы для передачи в приложение и начальный каталог.  
  
 [!code-fsharp[System.Diagnostics.Process#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.diagnostics.process/fs/Start1.fs#1)]  
  
 Код функции `runProc` был написан [ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment) и доступен на условиях лицензии [Microsoft Public License](https://opensource.org/licenses/ms-pl).  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот класс нельзя использовать в частично доверенном коде.</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">Полный уровень доверия для разработчиков производных классов. Этот класс не может наследоваться частично доверенным кодом.</permission>
    <altmember cref="M:System.Diagnostics.Process.Start" />
    <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
    <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
    <altmember cref="M:System.Diagnostics.Process.Kill" />
    <altmember cref="T:System.Diagnostics.ProcessThread" />
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/windowsdesktop/Using-the-NET-Process-Class-d70597ef">Использование класса процессов .NET</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Process ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Process();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Diagnostics.Process" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если не указать свойство <xref:System.Diagnostics.Process.MachineName%2A>, по умолчанию используется локальный компьютер (".").  
  
 Существует два варианта связывания нового компонента <xref:System.Diagnostics.Process> с процессом на компьютере. Первый вариант — использовать конструктор для создания компонента <xref:System.Diagnostics.Process>, задать соответствующие члены свойства <xref:System.Diagnostics.Process.StartInfo%2A> и вызвать <xref:System.Diagnostics.Process.Start%2A>, чтобы связать <xref:System.Diagnostics.Process> с новым системным процессом. Вторым вариантом является связывание <xref:System.Diagnostics.Process> с выполняющимся системным процессом с помощью <xref:System.Diagnostics.Process.GetProcessById%2A> или одного из <xref:System.Diagnostics.Process.GetProcesses%2A> возвращаемых значений.  
  
 При использовании перегрузки `static` метода <xref:System.Diagnostics.Process.Start%2A> для запуска нового системного процесса метод создает новый компонент <xref:System.Diagnostics.Process> и связывает его с процессом.  
  
 Если для свойства <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> задано значение по умолчанию, то `true`можно запускать приложения и документы способом, аналогичным использованию диалогового окна `Run` меню `Start` Windows. Если <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> `false`, можно запускать только исполняемые файлы.  
  
 Любой исполняемый файл, который можно вызвать из командной строки, может быть запущен одним из двух способов: путем установки соответствующих членов свойства <xref:System.Diagnostics.Process.StartInfo%2A> и вызова метода <xref:System.Diagnostics.Process.Start%2A> без параметров или путем передачи соответствующего параметра в `static`элемент <xref:System.Diagnostics.Process.Start%2A>.  
  
 Можно создать <xref:System.Diagnostics.Process> компонент с помощью конструктора, одной из статических <xref:System.Diagnostics.Process.Start%2A> перегрузок или любого из методов <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcesses%2A>или <xref:System.Diagnostics.Process.GetProcessesByName%2A>. После этого вы получите представление о связанном процессе. Это не динамическое представление, которое автоматически обновляется при изменении свойств процесса в памяти. Вместо этого необходимо вызвать <xref:System.Diagnostics.Process.Refresh%2A> для компонента, чтобы обновить сведения о свойствах <xref:System.Diagnostics.Process> в приложении.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BasePriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BasePriority { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int" Usage="System.Diagnostics.Process.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Base process priority.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessBasePriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает базовый приоритет связанного процесса.</summary>
        <value>Базовый приоритет, который вычисляется свойством <see cref="P:System.Diagnostics.Process.PriorityClass" /> связанного процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BasePriority%2A> процесса — это начальный приоритет для потоков, созданных в связанном процессе. Сведения об базовом приоритете можно просмотреть с помощью базового счетчика приоритета системного монитора.  
  
 В зависимости от затраченного времени или других увеличений операционная система может изменить базовый приоритет, когда процесс должен быть помещен впереди других.  
  
 Свойство <xref:System.Diagnostics.Process.BasePriority%2A> позволяет просматривать начальный приоритет, назначенный процессу. Однако, так как он доступен только для чтения, нельзя использовать <xref:System.Diagnostics.Process.BasePriority%2A> для задания приоритета процесса. Чтобы изменить приоритет, используйте свойство <xref:System.Diagnostics.Process.PriorityClass%2A>. <xref:System.Diagnostics.Process.BasePriority%2A> доступен для просмотра с помощью системного монитора, а <xref:System.Diagnostics.Process.PriorityClass%2A> — нет. <xref:System.Diagnostics.Process.BasePriority%2A> и <xref:System.Diagnostics.Process.PriorityClass%2A> можно просматривать программным способом. В следующей таблице показана связь между значениями <xref:System.Diagnostics.Process.BasePriority%2A> и <xref:System.Diagnostics.Process.PriorityClass%2A> значениями.  
  
|басеприорити|PriorityClass значение|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем в примере извлекаются и отображаются различные свойства связанного процесса. В примере обнаруживается, когда процесс завершается, и отображается код завершения процесса.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Процесс завершен.  
  
 - или -  
  
 Процесс не запущен, поэтому нет идентификатора процесса.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
        <altmember cref="T:System.Diagnostics.ThreadPriorityLevel" />
      </Docs>
    </Member>
    <Member MemberName="BeginErrorReadLine">
      <MemberSignature Language="C#" Value="public void BeginErrorReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginErrorReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginErrorReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginErrorReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginErrorReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginErrorReadLine : unit -&gt; unit" Usage="process.BeginErrorReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Начинает операции асинхронного чтения с перенаправленного потока <see cref="P:System.Diagnostics.Process.StandardError" /> приложения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поток <xref:System.Diagnostics.Process.StandardError%2A> может считываться синхронно или асинхронно. Такие методы, как <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>и <xref:System.IO.StreamReader.ReadToEnd%2A> выполняют синхронные операции чтения для потока вывода ошибок процесса. Эти операции синхронного чтения не завершаются, пока связанный <xref:System.Diagnostics.Process> не запишет в свой поток <xref:System.Diagnostics.Process.StandardError%2A> или закроет поток.  
  
 В отличие от этого <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> запускает асинхронные операции чтения в потоке <xref:System.Diagnostics.Process.StandardError%2A>. Этот метод включает назначенный обработчик событий для выходного потока и сразу же возвращает вызывающему объекту, который может выполнять другие действия, пока выходные данные потока направляются в обработчик событий.  
  
 Выполните следующие действия, чтобы выполнить асинхронные операции чтения <xref:System.Diagnostics.Process.StandardError%2A> для <xref:System.Diagnostics.Process>.  
  
1.  Присвойте свойству <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> значение `false`.  
  
2.  Присвойте свойству <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> значение `true`.  
  
3.  Добавьте обработчик событий в событие <xref:System.Diagnostics.Process.ErrorDataReceived>. Обработчик событий должен соответствовать сигнатуре делегата <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType>.  
  
4.  Запустите <xref:System.Diagnostics.Process>.  
  
5.  Вызовите <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> для <xref:System.Diagnostics.Process>. Этот вызов запускает асинхронные операции чтения для <xref:System.Diagnostics.Process.StandardError%2A>.  
  
 При запуске асинхронных операций чтения обработчик событий вызывается каждый раз, когда связанный <xref:System.Diagnostics.Process> записывает строку текста в свой поток <xref:System.Diagnostics.Process.StandardError%2A>.  
  
 Операцию асинхронного чтения можно отменить, вызвав <xref:System.Diagnostics.Process.CancelErrorRead%2A>. Операция чтения может быть отменена вызывающим объектом или обработчиком событий. После отмены можно снова вызвать <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>, чтобы возобновить асинхронные операции чтения.  
  
> [!NOTE]
>  В перенаправленном потоке нельзя смешивать асинхронные и синхронные операции чтения. После открытия перенаправленного потока <xref:System.Diagnostics.Process> в асинхронном или синхронном режиме все последующие операции чтения в этом потоке должны быть в том же режиме. Например, не следует выполнять <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> с вызовом <xref:System.IO.StreamReader.ReadLine%2A> в <xref:System.Diagnostics.Process.StandardError%2A>ном потоке или наоборот. Однако можно считывать два разных потока в разных режимах. Например, можно вызвать <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>, а затем вызвать метод <xref:System.IO.StreamReader.ReadLine%2A> для <xref:System.Diagnostics.Process.StandardOutput%2A> потока.  
  
   
  
## Examples  
 В следующем примере команда `net view` используется для вывода списка доступных сетевых ресурсов на удаленном компьютере. Пользователь предоставляет имя целевого компьютера в качестве аргумента командной строки. Пользователь также может указать имя файла для вывода ошибок. В примере выполняется сбор выходных данных команды NET, ожидание завершения процесса и запись выходных результатов в консоль. Если пользователь предоставляет необязательный файл ошибок, в примере в файл записываются ошибки.  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Значение свойства <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> — <see langword="false" />.  
  
- или - 
Асинхронная операция чтения уже выполняется в потоке <see cref="P:System.Diagnostics.Process.StandardError" />.  
  
- или - 
Поток <see cref="P:System.Diagnostics.Process.StandardError" /> используется синхронной операцией чтения.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
      </Docs>
    </Member>
    <Member MemberName="BeginOutputReadLine">
      <MemberSignature Language="C#" Value="public void BeginOutputReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginOutputReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginOutputReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginOutputReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginOutputReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginOutputReadLine : unit -&gt; unit" Usage="process.BeginOutputReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Начинает операции асинхронного чтения с перенаправленного потока <see cref="P:System.Diagnostics.Process.StandardOutput" /> приложения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поток <xref:System.Diagnostics.Process.StandardOutput%2A> может считываться синхронно или асинхронно. Такие методы, как <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>и <xref:System.IO.StreamReader.ReadToEnd%2A> выполняют синхронные операции чтения в потоке вывода процесса. Эти операции синхронного чтения не завершаются, пока связанный <xref:System.Diagnostics.Process> не запишет в свой поток <xref:System.Diagnostics.Process.StandardOutput%2A> или закроет поток.  
  
 В отличие от этого <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> запускает асинхронные операции чтения в потоке <xref:System.Diagnostics.Process.StandardOutput%2A>. Этот метод включает назначенный обработчик событий для выходного потока и сразу же возвращает вызывающему объекту, который может выполнять другие действия, пока выходные данные потока направляются в обработчик событий.  
  
 Выполните следующие действия, чтобы выполнить асинхронные операции чтения <xref:System.Diagnostics.Process.StandardOutput%2A> для <xref:System.Diagnostics.Process>.  
  
1.  Присвойте свойству <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> значение `false`.  
  
2.  Присвойте свойству <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> значение `true`.  
  
3.  Добавьте обработчик событий в событие <xref:System.Diagnostics.Process.OutputDataReceived>. Обработчик событий должен соответствовать сигнатуре делегата <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType>.  
  
4.  Запустите <xref:System.Diagnostics.Process>.  
  
5.  Вызовите <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> для <xref:System.Diagnostics.Process>. Этот вызов запускает асинхронные операции чтения для <xref:System.Diagnostics.Process.StandardOutput%2A>.  
  
 При запуске асинхронных операций чтения обработчик событий вызывается каждый раз, когда связанный <xref:System.Diagnostics.Process> записывает строку текста в свой поток <xref:System.Diagnostics.Process.StandardOutput%2A>.  
  
 Операцию асинхронного чтения можно отменить, вызвав <xref:System.Diagnostics.Process.CancelOutputRead%2A>. Операция чтения может быть отменена вызывающим объектом или обработчиком событий. После отмены можно снова вызвать <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>, чтобы возобновить асинхронные операции чтения.  
  
> [!NOTE]
>  В перенаправленном потоке нельзя смешивать асинхронные и синхронные операции чтения. После открытия перенаправленного потока <xref:System.Diagnostics.Process> в асинхронном или синхронном режиме все последующие операции чтения в этом потоке должны быть в том же режиме. Например, не следует выполнять <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> с вызовом <xref:System.IO.StreamReader.ReadLine%2A> в <xref:System.Diagnostics.Process.StandardOutput%2A>ном потоке или наоборот. Однако можно считывать два разных потока в разных режимах. Например, можно вызвать <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>, а затем вызвать метод <xref:System.IO.StreamReader.ReadLine%2A> для <xref:System.Diagnostics.Process.StandardError%2A> потока.  
  
   
  
## Examples  
 В следующем примере показано, как выполнять асинхронные операции чтения в перенаправленном <xref:System.Diagnostics.Process.StandardOutput%2A> потоке команды `sort`. Команда `sort` — это консольное приложение, которое считывает и сортирует текстовые данные.  
  
 В примере создается делегат события для обработчика событий `SortOutputHandler` и связывается с событием <xref:System.Diagnostics.Process.OutputDataReceived>. Обработчик событий получает текстовые строки из перенаправленного <xref:System.Diagnostics.Process.StandardOutput%2A> потока, форматирует текст и записывает текст на экран.  
  
 [!code-cpp[Process_AsyncStreams#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/sort_async.cpp#1)]
 [!code-csharp[Process_AsyncStreams#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/sort_async.cs#1)]
 [!code-vb[Process_AsyncStreams#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/sort_async.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Значение свойства <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> — <see langword="false" />.  
  
- или - 
Асинхронная операция чтения уже выполняется в потоке <see cref="P:System.Diagnostics.Process.StandardOutput" />.  
  
- или - 
Поток <see cref="P:System.Diagnostics.Process.StandardOutput" /> используется синхронной операцией чтения.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
      </Docs>
    </Member>
    <Member MemberName="CancelErrorRead">
      <MemberSignature Language="C#" Value="public void CancelErrorRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelErrorRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelErrorRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelErrorRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelErrorRead();" />
      <MemberSignature Language="F#" Value="member this.CancelErrorRead : unit -&gt; unit" Usage="process.CancelErrorRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Отменяет операцию асинхронного чтения в перенаправленном потоке <see cref="P:System.Diagnostics.Process.StandardError" /> приложения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> запускает асинхронную операцию чтения в потоке <xref:System.Diagnostics.Process.StandardError%2A>. <xref:System.Diagnostics.Process.CancelErrorRead%2A> завершает операцию асинхронного чтения.  
  
 После отмены можно возобновить асинхронную операцию чтения, вызвав <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> еще раз.  
  
 При вызове <xref:System.Diagnostics.Process.CancelErrorRead%2A>все выполняющиеся операции чтения для <xref:System.Diagnostics.Process.StandardError%2A> завершаются, а затем обработчик событий отключается. Все последующие перенаправленные выходные данные в <xref:System.Diagnostics.Process.StandardError%2A> будут потеряны. При повторном включении обработчика событий с вызовом <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>асинхронные операции чтения возобновляются. Если вы хотите изменить обработчик событий перед возобновлением асинхронных операций чтения, перед добавлением нового обработчика событий необходимо удалить существующий обработчик событий:  
  
```csharp  
// At this point the DataReceivedEventHandler(ErrorHandler1)   
// has executed a CancelErrorRead.  
  
// Remove the prior event handler.  
process.ErrorDataReceived -=   
    new DataReceivedEventHandler(ErrorHandler1);  
  
// Register a new event handler.  
process.ErrorDataReceived +=   
    new DataReceivedEventHandler(ErrorHandler2);  
  
// Call the corresponding BeginErrorReadLine.  
process.BeginErrorReadLine();  
```  
  
> [!NOTE]
>  В перенаправленном потоке <xref:System.Diagnostics.Process.StandardError%2A> нельзя смешивать асинхронные и синхронные операции чтения. После открытия перенаправленного потока <xref:System.Diagnostics.Process> в асинхронном или синхронном режиме все последующие операции чтения в этом потоке должны быть в том же режиме. Если отменить операцию асинхронного чтения на <xref:System.Diagnostics.Process.StandardError%2A> а затем снова требуется выполнить чтение из потока, необходимо использовать <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> для возобновления асинхронных операций чтения. Не следует <xref:System.Diagnostics.Process.CancelErrorRead%2A> с вызовом синхронных методов чтения <xref:System.Diagnostics.Process.StandardError%2A> например <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>или <xref:System.IO.StreamReader.ReadToEnd%2A>.  
  
   
  
## Examples  
 В следующем примере запускается команда `nmake` с аргументами, переданными пользователем. Потоки ошибок и выходных данных считываются асинхронно; собранные текстовые строки отображаются в консоли, а также записываются в файл журнала. Если выходные данные команды превышают указанное число строк, асинхронные операции чтения отменяются.  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Поток <see cref="P:System.Diagnostics.Process.StandardError" /> не включен для асинхронных операций чтения.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="CancelOutputRead">
      <MemberSignature Language="C#" Value="public void CancelOutputRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelOutputRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelOutputRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelOutputRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelOutputRead();" />
      <MemberSignature Language="F#" Value="member this.CancelOutputRead : unit -&gt; unit" Usage="process.CancelOutputRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Отменяет операцию асинхронного чтения в перенаправленном потоке <see cref="P:System.Diagnostics.Process.StandardOutput" /> приложения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> запускает асинхронную операцию чтения в потоке <xref:System.Diagnostics.Process.StandardOutput%2A>. <xref:System.Diagnostics.Process.CancelOutputRead%2A> завершает операцию асинхронного чтения.  
  
 После отмены можно возобновить асинхронные операции чтения, вызвав <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> еще раз.  
  
 При вызове <xref:System.Diagnostics.Process.CancelOutputRead%2A>все выполняющиеся операции чтения для <xref:System.Diagnostics.Process.StandardOutput%2A> завершаются, а затем обработчик событий отключается. Все последующие перенаправленные выходные данные в <xref:System.Diagnostics.Process.StandardOutput%2A> сохраняются в буфере. При повторном включении обработчика событий с вызовом <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>сохраненные выходные данные отправляются в обработчик событий, а асинхронные операции чтения возобновляются. Если вы хотите изменить обработчик событий перед возобновлением асинхронных операций чтения, перед добавлением нового обработчика событий необходимо удалить существующий обработчик событий:  
  
```csharp  
// At this point the DataReceivedEventHandler(OutputHandler1)   
// has executed a CancelOutputRead.  
  
// Remove the prior event handler.  
process.OutputDataReceived -=   
    new DataReceivedEventHandler(OutputHandler1);  
  
// Register a new event handler.  
process.OutputDataReceived +=   
    new DataReceivedEventHandler(OutputHandler2);  
  
// Call the corresponding BeginOutputReadLine.  
process.BeginOutputReadLine();  
```  
  
> [!NOTE]
>  В перенаправленном потоке <xref:System.Diagnostics.Process.StandardOutput%2A> нельзя смешивать асинхронные и синхронные операции чтения. После открытия перенаправленного потока <xref:System.Diagnostics.Process> в асинхронном или синхронном режиме все последующие операции чтения в этом потоке должны быть в том же режиме. Если отменить операцию асинхронного чтения на <xref:System.Diagnostics.Process.StandardOutput%2A> а затем снова требуется выполнить чтение из потока, необходимо использовать <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> для возобновления асинхронных операций чтения. Не следует <xref:System.Diagnostics.Process.CancelOutputRead%2A> с вызовом синхронных методов чтения <xref:System.Diagnostics.Process.StandardOutput%2A> например <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>или <xref:System.IO.StreamReader.ReadToEnd%2A>.  
  
   
  
## Examples  
 В следующем примере запускается команда `nmake` с аргументами, переданными пользователем. Потоки ошибок и выходных данных считываются асинхронно; собранные текстовые строки отображаются в консоли, а также записываются в файл журнала. Если выходные данные команды превышают указанное число строк, асинхронные операции чтения отменяются.  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Поток <see cref="P:System.Diagnostics.Process.StandardOutput" /> не включен для асинхронных операций чтения.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="process.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает все ресурсы, связанные с этим компонентом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Diagnostics.Process.Close%2A> заставляет процесс прекратить ожидание завершения работы, если он находится в состоянии ожидания, закрывает обработчик процесса и очищает свойства, зависящие от процесса. <xref:System.Diagnostics.Process.Close%2A> не закрывает стандартные средства чтения, ввода и вывода ошибок, а также модули записи, если на них есть ссылки извне.  
  
> [!NOTE]
>  Метод <xref:System.Diagnostics.Process.Dispose%2A> вызывает <xref:System.Diagnostics.Process.Close%2A>. Размещение объекта <xref:System.Diagnostics.Process> в `using`ном блоке уничтожает ресурсы без необходимости вызова <xref:System.Diagnostics.Process.Close%2A>.  
  
   
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем он получает сведения об использовании физической памяти для связанного процесса с интервалом в 2 секунды в течение не более 10 секунд. Пример определяет, завершается ли процесс до 10 секунд. В этом примере процесс закрывается, если он по-прежнему выполняется через 10 секунд.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="CloseMainWindow">
      <MemberSignature Language="C#" Value="public bool CloseMainWindow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CloseMainWindow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CloseMainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Function CloseMainWindow () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CloseMainWindow();" />
      <MemberSignature Language="F#" Value="member this.CloseMainWindow : unit -&gt; bool" Usage="process.CloseMainWindow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Закрывает процесс, имеющий пользовательский интерфейс, посылая сообщение о закрытии главному окну процесса.</summary>
        <returns>Значение <see langword="true" />, если сообщение о закрытии было успешно отправлено; <see langword="false" />, если связанный процесс не имеет главного окна или если главное окно отключено (например, если отображается модальное диалоговое окно).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При выполнении процесса его цикл обработки сообщений находится в состоянии ожидания. Цикл обработки сообщений выполняется каждый раз, когда операционная система отправляет сообщение Windows в процесс. Вызов <xref:System.Diagnostics.Process.CloseMainWindow%2A> отправляет запрос на закрытие главного окна, которое в правильно сформированном приложении закрывает дочерние окна и отменяет все выполняющиеся циклы сообщений для приложения. Запрос на выход из процесса путем вызова <xref:System.Diagnostics.Process.CloseMainWindow%2A> не заставляет приложение завершить работу. Приложение может запросить проверку пользователя перед выходом или отказаться от его завершения. Чтобы принудительно завершить работу приложения, используйте метод <xref:System.Diagnostics.Process.Kill%2A>. Поведение <xref:System.Diagnostics.Process.CloseMainWindow%2A> аналогично тому, как пользователь закрывает главное окно приложения с помощью системного меню. Таким образом, запрос на завершение процесса путем закрытия главного окна не заставляет приложение немедленно завершить работу.  
  
 Данные, измененные процессом или ресурсами, выделенными для процесса, могут быть потеряны при вызове <xref:System.Diagnostics.Process.Kill%2A>. <xref:System.Diagnostics.Process.Kill%2A> вызывает аварийное завершение процесса, и его следует использовать только при необходимости. <xref:System.Diagnostics.Process.CloseMainWindow%2A> обеспечивает упорядоченное завершение процесса и закрывает все окна, поэтому оно является предпочтительным для приложений с интерфейсом. В случае сбоя <xref:System.Diagnostics.Process.CloseMainWindow%2A> можно использовать <xref:System.Diagnostics.Process.Kill%2A> для завершения процесса. <xref:System.Diagnostics.Process.Kill%2A> является единственным способом завершения процессов, не имеющих графических интерфейсов.  
  
 Можно вызвать <xref:System.Diagnostics.Process.Kill%2A> и <xref:System.Diagnostics.Process.CloseMainWindow%2A> только для процессов, запущенных на локальном компьютере. Нельзя вызвать завершение процессов на удаленных компьютерах. Можно просматривать только сведения о процессах, запущенных на удаленных компьютерах.  
  
   
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем он получает сведения об использовании физической памяти для связанного процесса с интервалом в 2 секунды в течение не более 10 секунд. Пример определяет, завершается ли процесс до 10 секунд. В этом примере процесс закрывается, если он по-прежнему выполняется через 10 секунд.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот процесс уже завершился.  
  
- или - 
Нет процессов, связанных с этим объектом <see cref="T:System.Diagnostics.Process" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="process.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="process.Dispose disposing" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="process.Dispose disposing" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Значение <see langword="true" /> позволяет освободить управляемые и неуправляемые ресурсы; значение <see langword="false" /> позволяет освободить только неуправляемые ресурсы.</param>
        <summary>Освобождает все ресурсы, используемые этим процессом.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process component should watch for the associated process to exit, and raise the Exited event.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessEnableRaisingEvents")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, следует ли вызывать событие <see cref="E:System.Diagnostics.Process.Exited" /> при прекращении процесса.</summary>
        <value>Значение<see langword="true" /> , если событие <see cref="E:System.Diagnostics.Process.Exited" /> должно быть вызвано при завершении связанного процесса (выход или вызов метода <see cref="M:System.Diagnostics.Process.Kill" />); в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />. Обратите внимание, что событие <see cref="E:System.Diagnostics.Process.Exited" /> возникает, даже если значение <see cref="P:System.Diagnostics.Process.EnableRaisingEvents" /> <see langword="false" /> при завершении процесса во время или до того, как пользователь выполняет проверку <see cref="P:System.Diagnostics.Process.HasExited" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Свойство <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> указывает, следует ли уведомлять компонент о том, что операционная система завершила процесс. Свойство <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> используется при асинхронной обработке для уведомления приложения о завершении процесса. Чтобы заставить приложение синхронно ожидать событие выхода (которое прерывает обработку приложения до возникновения события Exit), используйте метод <xref:System.Diagnostics.Process.WaitForExit%2A>.

> [!NOTE]
> Если вы используете Visual Studio и дважды щелкнули <xref:System.Diagnostics.Process> компонент в проекте, автоматически создаются делегаты <xref:System.Diagnostics.Process.Exited> событий и обработчики событий. Дополнительный код задает для свойства <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> значение `false`. Необходимо изменить это свойство на `true`, чтобы обработчик событий выполнялся при завершении связанного процесса.

Если значение <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> компонента равно `true`или если <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> `false`, а проверка <xref:System.Diagnostics.Process.HasExited%2A> вызывается компонентом, то компонент может получить доступ к административным сведениям для связанного процесса, который остается в операционной системе. Такие сведения включают <xref:System.Diagnostics.Process.ExitTime%2A> и <xref:System.Diagnostics.Process.ExitCode%2A>.

После завершения связанного процесса <xref:System.Diagnostics.Process.Handle%2A> компонента больше не указывает на существующий ресурс процесса. Вместо этого он может использоваться только для доступа к информации операционной системы о ресурсе процесса. Операционная система осведомлена о том, что существуют дескрипторы для завершенных процессов, которые не были освобождены <xref:System.Diagnostics.Process> компонентами, поэтому <xref:System.Diagnostics.Process.ExitTime%2A> и <xref:System.Diagnostics.Process.Handle%2A> сведения сохраняются в памяти.

Есть затраты, связанные с наблюдением за завершением процесса. Если <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> `true`, событие <xref:System.Diagnostics.Process.Exited> возникает при завершении связанного процесса. В это время выполняются процедуры для события <xref:System.Diagnostics.Process.Exited>.

Иногда приложение запускает процесс, но не требует уведомления о его закрытии. Например, приложение может запустить Блокнот, чтобы позволить пользователю выполнять редактирование текста, но не использовать приложение блокнота. Вы можете избежать уведомления при завершении процесса, поскольку это не относится к продолжающейся работе приложения. Настройка <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> `false` может сэкономить системные ресурсы.

## Examples  
В следующем примере кода создается процесс, который выводит файл. Он устанавливает свойство <xref:System.Diagnostics.Process.EnableRaisingEvents%2A>, чтобы процесс вызывал событие <xref:System.Diagnostics.Process.Exited> при его выходе. Обработчик событий <xref:System.Diagnostics.Process.Exited> отображает сведения о процессе.

[!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]   
[!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]   
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
      </Docs>
    </Member>
    <Member MemberName="EnterDebugMode">
      <MemberSignature Language="C#" Value="public static void EnterDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnterDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.EnterDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnterDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnterDebugMode();" />
      <MemberSignature Language="F#" Value="static member EnterDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.EnterDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Помещает компонент <see cref="T:System.Diagnostics.Process" /> в состояние взаимодействия с работающим системным процессом, выполняющимся в специальном режиме путем включения встроенного свойства <see langword="SeDebugPrivilege" /> в данном потоке.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Некоторые процессы операционной системы выполняются в специальном режиме. Попытка чтения свойств или присоединения к этим процессам невозможна, если в компоненте не вызван <xref:System.Diagnostics.Process.EnterDebugMode%2A>. Вызовите <xref:System.Diagnostics.Process.LeaveDebugMode%2A>, когда вам больше не нужен доступ к этим процессам, выполняемым в специальном режиме.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.LeaveDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="ErrorDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler ErrorDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler ErrorDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.ErrorDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ErrorDataReceived As DataReceivedEventHandler " FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ ErrorDataReceived;" />
      <MemberSignature Language="F#" Value="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event ErrorDataReceived As DataReceivedEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessAssociated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда приложение выполняет запись в свой перенаправленный поток <see cref="P:System.Diagnostics.Process.StandardError" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Событие <xref:System.Diagnostics.Process.ErrorDataReceived> указывает, что связанный процесс записал в перенаправленный поток <xref:System.Diagnostics.Process.StandardError%2A>.  
  
 Это событие возникает только во время асинхронных операций чтения в <xref:System.Diagnostics.Process.StandardError%2A>. Чтобы начать асинхронные операции чтения, необходимо перенаправить поток <xref:System.Diagnostics.Process.StandardError%2A> <xref:System.Diagnostics.Process>, добавить обработчик событий в <xref:System.Diagnostics.Process.ErrorDataReceived> событие и вызвать <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>. После этого <xref:System.Diagnostics.Process.ErrorDataReceived> событие сигнализирует каждый раз, когда процесс записывает строку в перенаправленный поток <xref:System.Diagnostics.Process.StandardError%2A>, пока процесс не завершит работу или не вызовет <xref:System.Diagnostics.Process.CancelErrorRead%2A>.  
  
> [!NOTE]
>  Приложение, обрабатывающее асинхронный вывод, должно вызывать метод <xref:System.Diagnostics.Process.WaitForExit>, чтобы убедиться, что выходной буфер был сброшен. Обратите внимание, что задание времени ожидания с помощью перегрузки <xref:System.Diagnostics.Process.WaitForExit(System.Int32)> *не* гарантирует, что выходной буфер был сброшен.
  
   
  
## Examples  
 В следующем примере команда `net view` используется для вывода списка доступных сетевых ресурсов на удаленном компьютере. Пользователь предоставляет имя целевого компьютера в качестве аргумента командной строки. Пользователь также может указать имя файла для вывода ошибок. В примере выполняется сбор выходных данных команды NET, ожидание завершения процесса и запись выходных результатов в консоль. Если пользователь предоставляет необязательный файл ошибок, в примере в файл записываются ошибки.  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int" Usage="System.Diagnostics.Process.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The value returned from the associated process when it terminated.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExitCode")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, заданное связанным процессом при завершении.</summary>
        <value>Код, который задал связанный процесс при завершении.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Diagnostics.Process.ExitCode%2A>, чтобы получить состояние, возвращенное системным процессом при его завершении. Можно использовать код выхода, похожий на целочисленное значение, возвращаемое процедурой `main()`.  
  
 <xref:System.Diagnostics.Process.ExitCode%2A> значение для процесса отражает конкретное соглашение, реализуемое разработчиком приложения для этого процесса. Если вы используете значение кода выхода для принятия решений в коде, убедитесь, что вы знаете соглашение о коде выхода, используемое процессом приложения.  
  
 Разработчики обычно указывают на Успешный выход на <xref:System.Diagnostics.Process.ExitCode%2A> нулевое значение и обозначают ошибки ненулевыми значениями, которые вызывающий метод может использовать для определения причины аварийного завершения процесса. Не обязательно следовать этим рекомендациям, но они являются соглашением.  
  
 Если попытаться получить <xref:System.Diagnostics.Process.ExitCode%2A> до завершения процесса, то попытка выдаст исключение. Сначала изучите свойство <xref:System.Diagnostics.Process.HasExited%2A>, чтобы проверить, завершился ли связанный процесс.  
  
> [!NOTE]
>  Когда стандартный вывод перенаправляется в асинхронные обработчики событий, обработка выходных данных может не завершиться, когда <xref:System.Diagnostics.Process.HasExited%2A> возвращает `true`. Чтобы обеспечить завершение асинхронной обработки событий, вызовите перегрузку <xref:System.Diagnostics.Process.WaitForExit>, которая не принимает параметр, прежде чем проверять <xref:System.Diagnostics.Process.HasExited%2A>.  
  
 Чтобы завершить работу связанного процесса, можно использовать <xref:System.Diagnostics.Process.CloseMainWindow%2A> или метод <xref:System.Diagnostics.Process.Kill%2A>.  
  
 Существует два способа уведомления о выходе связанного процесса: синхронно и асинхронно. Синхронное уведомление полагается на вызов метода <xref:System.Diagnostics.Process.WaitForExit%2A> для приостановки обработки приложения до тех пор, пока связанный компонент не завершит работу. Асинхронное уведомление зависит от <xref:System.Diagnostics.Process.Exited> события. При использовании асинхронного уведомления <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> должно быть установлено в значение `true`, чтобы компонент <xref:System.Diagnostics.Process> получал уведомление о завершении процесса.  
  
   
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем в примере извлекаются и отображаются различные свойства связанного процесса. В примере обнаруживается, когда процесс завершается, и отображается код завершения процесса.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Процесс не был завершен.  
  
- или - 
Процесс <see cref="P:System.Diagnostics.Process.Handle" /> не является допустимым.</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.ExitCode" /> процесса, запущенного на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
      </Docs>
    </Member>
    <Member MemberName="Exited">
      <MemberSignature Language="C#" Value="public event EventHandler Exited;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Exited" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.Exited" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exited As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Exited;" />
      <MemberSignature Language="F#" Value="member this.Exited : EventHandler " Usage="member this.Exited : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("If the WatchForExit property is set to true, then this event is raised when the associated process exits.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExited")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при завершении процесса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Событие <xref:System.Diagnostics.Process.Exited> указывает, что связанный процесс завершился. Это означает, что процесс завершен (прерван) или успешно закрыт. Это событие может возникать, только если значение свойства <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> равно `true`.  
  
 Существует два способа уведомления о выходе связанного процесса: синхронно и асинхронно. Синхронное уведомление означает вызов метода <xref:System.Diagnostics.Process.WaitForExit%2A> для блокировки текущего потока до завершения процесса. Асинхронное уведомление использует событие <xref:System.Diagnostics.Process.Exited>, которое позволяет вызывающему потоку продолжать выполнение. В последнем случае <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> должно быть установлено в значение `true`, чтобы вызывающее приложение получило событие Exitd.  
  
 Когда операционная система завершает процесс, она уведомляет все другие процессы, которые зарегистрировали обработчики для события Exitd. В настоящее время дескриптор процесса, который просто завершил работу, может использоваться для доступа к некоторым свойствам, таким как <xref:System.Diagnostics.Process.ExitTime%2A>, и <xref:System.Diagnostics.Process.HasExited%2A>, что операционная система обслуживает до полного выхода.  
  
> [!NOTE]
>  Даже если у вас есть обработчик для завершенного процесса, вы не можете снова вызвать <xref:System.Diagnostics.Process.Start%2A> для повторного подключения к тому же процессу. Вызов <xref:System.Diagnostics.Process.Start%2A> автоматически освобождает связанный процесс и подключается к процессу с тем же файлом, но совершенно новым <xref:System.Diagnostics.Process.Handle%2A>.  
  
 Дополнительные сведения об использовании события <xref:System.Diagnostics.Process.Exited> в приложениях Windows Forms см. в описании свойства <xref:System.Diagnostics.Process.SynchronizingObject%2A>.  
  
   
  
## Examples  
 В следующем примере кода создается процесс, который выводит файл. Он вызывает событие <xref:System.Diagnostics.Process.Exited> при завершении процесса, так как свойство <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> было задано при создании процесса. Обработчик событий <xref:System.Diagnostics.Process.Exited> отображает сведения о процессе.  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExitTime">
      <MemberSignature Language="C#" Value="public DateTime ExitTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExitTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExitTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitTime : DateTime" Usage="System.Diagnostics.Process.ExitTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The time that the associated process exited.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExitTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает время завершения связанного процесса.</summary>
        <value>Класс <see cref="T:System.DateTime" />, показывающий время завершения связанного процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если процесс не был завершен, попытка получить свойство <xref:System.Diagnostics.Process.ExitTime%2A> вызывает исключение. Используйте <xref:System.Diagnostics.Process.HasExited%2A> перед получением свойства <xref:System.Diagnostics.Process.ExitTime%2A>, чтобы определить, завершен ли связанный процесс.  
  
   
  
## Examples  
 В следующем примере кода создается процесс, который выводит файл. Процесс вызывает событие <xref:System.Diagnostics.Process.Exited>, когда оно завершает работу, и обработчик событий отображает свойство <xref:System.Diagnostics.Process.ExitTime%2A> и другие сведения о процессе.  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.ExitTime" /> процесса, запущенного на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcess">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetCurrentProcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetCurrentProcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetCurrentProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcess () As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetCurrentProcess();" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcess : unit -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetCurrentProcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает новый компонент <see cref="T:System.Diagnostics.Process" /> и связывает его с активным в данный момент процессом.</summary>
        <returns>Новый компонент <see cref="T:System.Diagnostics.Process" />, связанный с ресурсом выполняющегося процесса в вызывающем приложении.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод, чтобы создать новый экземпляр <xref:System.Diagnostics.Process> и связать его с ресурсом процесса на локальном компьютере.  
  
 Подобно аналогичным методам <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcessesByName%2A>и <xref:System.Diagnostics.Process.GetProcesses%2A>, <xref:System.Diagnostics.Process.GetCurrentProcess%2A> связывает существующий ресурс с новым компонентом <xref:System.Diagnostics.Process>.  
  
   
  
## Examples  
 В следующем примере извлекаются сведения о текущем процессе, процессы, запущенные на локальном компьютере, все экземпляры Блокнота, запущенные на локальном компьютере, и конкретный процесс на локальном компьютере. Затем он получает сведения для тех же процессов на удаленном компьютере.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessById">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает новый компонент <see cref="T:System.Diagnostics.Process" /> и связывает его с существующим заданным ресурсом процесса.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById processId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="processId">Уникальный в системе идентификатор ресурса процесса.</param>
        <summary>Возвращает новый компонент <see cref="T:System.Diagnostics.Process" />, по заданному идентификатору процесса на локальном компьютере.</summary>
        <returns>Компонент <see cref="T:System.Diagnostics.Process" />, связанный с локальным ресурсом процесса, определенного параметром <paramref name="processId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод, чтобы создать новый компонент <xref:System.Diagnostics.Process> и связать его с ресурсом процесса на локальном компьютере. Ресурс процесса уже должен существовать на компьютере, так как <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> не создает системный ресурс, а связывает ресурс с компонентом <xref:System.Diagnostics.Process> компонента, созданным приложением. <xref:System.Diagnostics.Process.Id%2A> процесса можно извлечь только для процесса, который в данный момент выполняется на компьютере. После завершения процесса <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> создает исключение, если передать ему идентификатор с истекшим сроком действия.  
  
 На любом конкретном компьютере идентификатор процесса уникален. <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> возвращает не более одного процесса. Если вы хотите получить все процессы, выполняющие определенное приложение, используйте <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>. Если на компьютере, на котором запущено указанное приложение, существует несколько процессов, <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> возвращает массив, содержащий все связанные процессы. Можно запросить каждый из этих процессов, в свою очередь, для своего идентификатора. Идентификатор процесса можно просмотреть на панели `Processes` диспетчера задач Windows. В столбце `PID` отображается идентификатор процесса, назначенный процессу.  
  
 Параметр `processId` — это <xref:System.Int32> (32-разрядное целое число со знаком), хотя базовый API Windows использует `DWORD` (Неподписанное 32-разрядное целое число) для похожих API. Это по историческим причинам.
  
## Examples  
 В следующем примере извлекаются сведения о текущем процессе, процессы, запущенные на локальном компьютере, все экземпляры Блокнота, запущенные на локальном компьютере, и конкретный процесс на локальном компьютере. Затем он получает сведения для тех же процессов на удаленном компьютере.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Процесс, указанный параметром <paramref name="processId" />, не выполняется. Возможно, истек срок действия идентификатора.</exception>
        <exception cref="T:System.InvalidOperationException">Процесс не был запущен этим объектом.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer, machineName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById (processId, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processId">Уникальный в системе идентификатор ресурса процесса.</param>
        <param name="machineName">Имя компьютера в сети.</param>
        <summary>Возвращает новый компонент <see cref="T:System.Diagnostics.Process" /> по заданному идентификатору процесса и имени компьютера в сети.</summary>
        <returns>Компонент <see cref="T:System.Diagnostics.Process" />, связанный с удаленным ресурсом процесса, определенного параметром <paramref name="processId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод, чтобы создать новый компонент <xref:System.Diagnostics.Process> и связать его с ресурсом процесса на удаленном компьютере в сети. Ресурс процесса уже должен существовать на указанном компьютере, так как <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> не создает системный ресурс, а связывает ресурс с компонентом <xref:System.Diagnostics.Process> компонента, созданным приложением. <xref:System.Diagnostics.Process.Id%2A> процесса можно извлечь только для процесса, который в данный момент выполняется на компьютере. После завершения процесса <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> создает исключение, если передать ему идентификатор с истекшим сроком действия.  
  
 На любом конкретном компьютере идентификатор процесса уникален. <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> возвращает не более одного процесса. Если вы хотите получить все процессы, выполняющие определенное приложение, используйте <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>. Если на компьютере, на котором запущено указанное приложение, существует несколько процессов, <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> возвращает массив, содержащий все связанные процессы. Можно запросить каждый из этих процессов, в свою очередь, для своего идентификатора. Идентификатор процесса можно просмотреть на панели `Processes` диспетчера задач Windows. В столбце `PID` отображается идентификатор процесса, назначенный процессу.  
  
 Если `machineName`не указан, используется локальный компьютер. Кроме того, можно указать локальный компьютер, присвоив параметру `machineName` значение "." или пустую строку ("").  
  
 Параметр `processId` — это <xref:System.Int32> (32-разрядное целое число со знаком), хотя базовый API Windows использует `DWORD` (Неподписанное 32-разрядное целое число) для похожих API. Это по историческим причинам.   
  
## Examples  
 В следующем примере извлекаются сведения о текущем процессе, процессы, запущенные на локальном компьютере, все экземпляры Блокнота, запущенные на локальном компьютере, и конкретный процесс на локальном компьютере. Затем он получает сведения для тех же процессов на удаленном компьютере.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Процесс, указанный параметром <paramref name="processId" />, не выполняется. Возможно, истек срок действия идентификатора.  
  
- или - 
Недопустимый синтаксис параметра <paramref name="machineName" />. Возможно, имя имеет нулевую длину (0).</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="machineName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Процесс не был запущен этим объектом.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcesses">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает массив из новых компонентов <see cref="T:System.Diagnostics.Process" /> и связывает их с существующими ресурсами процесса.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses () As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses();" />
      <MemberSignature Language="F#" Value="static member GetProcesses : unit -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает новый компонент <see cref="T:System.Diagnostics.Process" /> для каждого ресурса процесса на локальном компьютере.</summary>
        <returns>Массив типа <see cref="T:System.Diagnostics.Process" />, представляющий все ресурсы процесса, выполняющегося на локальном компьютере.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод, чтобы создать массив новых компонентов <xref:System.Diagnostics.Process> и связать их со всеми ресурсами процесса на локальном компьютере. Ресурсы процесса должны уже существовать на локальном компьютере, так как <xref:System.Diagnostics.Process.GetProcesses%2A> не создает системные ресурсы, а связывает ресурсы с <xref:System.Diagnostics.Process> компонентами, созданными приложением. Так как сама операционная система выполняет фоновые процессы, этот массив никогда не будет пустым.  
  
 Если вы не хотите получать все процессы, запущенные на компьютере, можно ограничить их число с помощью метода <xref:System.Diagnostics.Process.GetProcessById%2A> или <xref:System.Diagnostics.Process.GetProcessesByName%2A>. <xref:System.Diagnostics.Process.GetProcessById%2A> создает компонент <xref:System.Diagnostics.Process>, связанный с процессом, определенным в системе, по идентификатору процесса, который передается в метод. <xref:System.Diagnostics.Process.GetProcessesByName%2A> создает массив компонентов <xref:System.Diagnostics.Process>, связанные ресурсы процесса которых совместно используют исполняемый файл, передаваемый в метод.  
  
> [!NOTE]
>  В одном экземпляре процесса узла службы можно загрузить несколько служб Windows (svchost. exe). В процессе обработки не определены эти отдельные службы. для этого см. <xref:System.ServiceProcess.ServiceController.GetServices%2A>.  
  
   
  
## Examples  
 В следующем примере извлекаются сведения о текущем процессе, процессы, запущенные на локальном компьютере, все экземпляры Блокнота, запущенные на локальном компьютере, и конкретный процесс на локальном компьютере. Затем он получает сведения для тех же процессов на удаленном компьютере.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses (machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcesses : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Компьютер, из которого читается список процессов.</param>
        <summary>Создает новый компонент <see cref="T:System.Diagnostics.Process" /> для каждого ресурса процесса на указанном компьютере.</summary>
        <returns>Массив типа <see cref="T:System.Diagnostics.Process" />, представляющий все ресурсы процесса, выполняющегося на указанном компьютере.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод, чтобы создать массив новых компонентов <xref:System.Diagnostics.Process> и связать их со всеми ресурсами процесса на указанном (обычно удаленном) компьютере. Ресурсы процесса должны уже существовать на локальном компьютере, так как <xref:System.Diagnostics.Process.GetProcesses%2A> не создает системные ресурсы, а связывает ресурсы с <xref:System.Diagnostics.Process> компонентами, созданными приложением. Так как сама операционная система выполняет фоновые процессы, этот массив никогда не будет пустым.  
  
 Если вы не хотите получать все процессы, запущенные на компьютере, можно ограничить их число с помощью метода <xref:System.Diagnostics.Process.GetProcessById%2A> или <xref:System.Diagnostics.Process.GetProcessesByName%2A>. <xref:System.Diagnostics.Process.GetProcessById%2A> создает компонент <xref:System.Diagnostics.Process>, связанный с процессом, определенным в системе, по идентификатору процесса, который передается в метод. <xref:System.Diagnostics.Process.GetProcessesByName%2A> создает массив компонентов <xref:System.Diagnostics.Process>, связанные ресурсы процесса которых совместно используют исполняемый файл, передаваемый в метод.  
  
 Эта перегрузка метода <xref:System.Diagnostics.Process.GetProcesses%2A> обычно используется для получения списка ресурсов процесса, выполняемых на удаленном компьютере в сети, но можно указать локальный компьютер, передав ".".  
  
> [!NOTE]
>  В одном экземпляре процесса узла службы можно загрузить несколько служб Windows (svchost. exe). В процессе обработки не определены эти отдельные службы. для этого см. <xref:System.ServiceProcess.ServiceController.GetServices%2A>.  
  
   
  
## Examples  
 В следующем примере извлекаются сведения о текущем процессе, процессы, запущенные на локальном компьютере, все экземпляры Блокнота, запущенные на локальном компьютере, и конкретный процесс на локальном компьютере. Затем он получает сведения для тех же процессов на удаленном компьютере.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Недопустимый синтаксис параметра <paramref name="machineName" />. Он может иметь нулевую длину (0).</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="machineName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Платформа операционной системы не поддерживает эту операцию на удаленных компьютерах.</exception>
        <exception cref="T:System.InvalidOperationException">Существуют проблемы при доступе к API счетчиков производительности, которые используются для получения сведений о процессе. Это исключение характерно для Windows NT, Windows 2000 и Windows XP.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Возникла проблема при доступе к базовому системному API.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessesByName">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает массив из новых компонентов <see cref="T:System.Diagnostics.Process" /> и связывает их с существующими ресурсами процесса, для которых имя процесса является общедоступным.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName processName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">Понятное имя процесса.</param>
        <summary>Создает массив из новых компонентов <see cref="T:System.Diagnostics.Process" /> и связывает их со всеми ресурсами процесса на локальном компьютере, для которых заданное имя процесса является общедоступным.</summary>
        <returns>Массив типа <see cref="T:System.Diagnostics.Process" />, представляющий ресурсы процесса, выполняющего указанное приложение или файл.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод, чтобы создать массив новых компонентов <xref:System.Diagnostics.Process> и связать их со всеми ресурсами процесса, на которых выполняется один исполняемый файл на локальном компьютере. Ресурсы процесса должны уже существовать на компьютере, так как <xref:System.Diagnostics.Process.GetProcessesByName%2A> не создает системные ресурсы, а связывает их с <xref:System.Diagnostics.Process> компонентами, созданными приложением. Для исполняемого файла, который в данный момент не выполняется на локальном компьютере, можно указать `processName`, поэтому массив, возвращаемый методом, может быть пустым.  
  
 Имя процесса — это понятное имя процесса, например Outlook, которое не включает расширение EXE или путь. <xref:System.Diagnostics.Process.GetProcessesByName%2A> удобно использовать для получения и управления всеми процессами, связанными с одним и тем же исполняемым файлом. Например, можно передать имя исполняемого файла в качестве параметра `processName`, чтобы завершить работу всех работающих экземпляров этого исполняемого файла.  
  
 Хотя процесс <xref:System.Diagnostics.Process.Id%2A> уникален для одного ресурса процесса в системе, несколько процессов на локальном компьютере могут запускать приложение, указанное параметром `processName`. Таким образом, <xref:System.Diagnostics.Process.GetProcessById%2A> возвращает не более одного процесса, но <xref:System.Diagnostics.Process.GetProcessesByName%2A> возвращает массив, содержащий все связанные процессы. Если необходимо управлять процессом с помощью стандартных вызовов API, можно запросить каждый из этих процессов, включив его идентификатор. Нельзя получить доступ к ресурсам Process только по имени процесса, но после получения массива компонентов <xref:System.Diagnostics.Process>, связанных с ресурсами процесса, можно запустить, завершить и иным образом манипулировать системными ресурсами.  
  
   
  
## Examples  
 В следующем примере извлекаются сведения о текущем процессе, процессы, запущенные на локальном компьютере, все экземпляры Блокнота, запущенные на локальном компьютере, и конкретный процесс на локальном компьютере. Затем он получает сведения для тех же процессов на удаленном компьютере.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Существуют проблемы при доступе к API счетчиков производительности, которые используются для получения сведений о процессе. Это исключение характерно для Windows NT, Windows 2000 и Windows XP.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String, machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string * string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName (processName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">Понятное имя процесса.</param>
        <param name="machineName">Имя компьютера в сети.</param>
        <summary>Создает массив из новых компонентов <see cref="T:System.Diagnostics.Process" /> и связывает их со всеми ресурсами процесса на удаленном компьютере, для которых заданное имя процесса является общедоступным.</summary>
        <returns>Массив типа <see cref="T:System.Diagnostics.Process" />, представляющий ресурсы процесса, выполняющего указанное приложение или файл.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод, чтобы создать массив новых компонентов <xref:System.Diagnostics.Process> и связать их со всеми ресурсами процесса, на которых выполняется один и тот же исполняемый файл на указанном компьютере. Ресурсы процесса должны уже существовать на компьютере, так как <xref:System.Diagnostics.Process.GetProcessesByName%2A> не создает системные ресурсы, а связывает их с <xref:System.Diagnostics.Process> компонентами, созданными приложением. Для исполняемого файла, который в данный момент не выполняется на локальном компьютере, можно указать `processName`, поэтому массив, возвращаемый методом, может быть пустым.  
  
 Имя процесса — это понятное имя процесса, например Outlook, которое не включает расширение EXE или путь. <xref:System.Diagnostics.Process.GetProcessesByName%2A> удобно использовать для получения и управления всеми процессами, связанными с одним и тем же исполняемым файлом. Например, можно передать имя исполняемого файла в качестве параметра `processName`, чтобы завершить работу всех работающих экземпляров этого исполняемого файла.  
  
 Хотя процесс <xref:System.Diagnostics.Process.Id%2A> уникален для одного ресурса процесса в системе, несколько процессов на локальном компьютере могут запускать приложение, указанное параметром `processName`. Таким образом, <xref:System.Diagnostics.Process.GetProcessById%2A> возвращает не более одного процесса, но <xref:System.Diagnostics.Process.GetProcessesByName%2A> возвращает массив, содержащий все связанные процессы. Если необходимо управлять процессом с помощью стандартных вызовов API, можно запросить каждый из этих процессов, включив его идентификатор. Нельзя получить доступ к ресурсам Process только по имени процесса, но после получения массива компонентов <xref:System.Diagnostics.Process>, связанных с ресурсами процесса, можно запустить, завершить и иным образом манипулировать системными ресурсами.  
  
 Эту перегрузку можно использовать для получения процессов на локальном компьютере, а также на удаленном компьютере. Используйте ".", чтобы указать локальный компьютер. Существует другая перегрузка, которая по умолчанию использует локальный компьютер.  
  
 Доступ к процессам на удаленных компьютерах возможен только для просмотра сведений о процессах, например статистики. Нельзя закрыть, прервать (с помощью <xref:System.Diagnostics.Process.Kill%2A>) или запустить процессы на удаленных компьютерах.  
  
   
  
## Examples  
 В следующем примере извлекаются сведения о текущем процессе, процессы, запущенные на локальном компьютере, все экземпляры Блокнота, запущенные на локальном компьютере, и конкретный процесс на локальном компьютере. Затем он получает сведения для тех же процессов на удаленном компьютере.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Недопустимый синтаксис параметра <paramref name="machineName" />. Он может иметь нулевую длину (0).</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="machineName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Платформа операционной системы не поддерживает эту операцию на удаленных компьютерах.</exception>
        <exception cref="T:System.InvalidOperationException">Попытка подключиться к <paramref name="machineName" /> завершилась ошибкой.

- или - 
Существуют проблемы при доступе к API счетчиков производительности, которые используются для получения сведений о процессе. Это исключение характерно для Windows NT, Windows 2000 и Windows XP.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Возникла проблема при доступе к базовому системному API.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для вызова неуправляемого кода. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Diagnostics.Process.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Returns the native handle for this process.   The handle is only available if the process was started using this component.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает собственный дескриптор связанного процесса.</summary>
        <value>Дескриптор, присвоенный процессу операционной системой при запуске. Система использует этот дескриптор для хранения атрибутов процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Приложение может получить обработчик для процесса, который можно использовать в качестве параметра для многих функций обработки и управления данными. Этот обработчик можно использовать для инициализации <xref:System.Threading.WaitHandle> или вызова собственных методов с помощью вызова неуправляемого кода.  
  
 Этот дескриптор процесса является частным для приложения, иными словами, дескрипторы процессов не могут быть общими. Процесс также содержит процесс, <xref:System.Diagnostics.Process.Id%2A> который, в отличие от <xref:System.Diagnostics.Process.Handle%2A>, является уникальным и, следовательно, действителен во всей системе.  
  
 Только процессы, запущенные с помощью вызова метода <xref:System.Diagnostics.Process.Start%2A> установить свойство <xref:System.Diagnostics.Process.Handle%2A> соответствующих экземпляров <xref:System.Diagnostics.Process>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Процесс не был запущен или был завершен. Невозможно прочитать свойство <see cref="P:System.Diagnostics.Process.Handle" />, поскольку ни один процесс не связан с этим экземпляром <see cref="T:System.Diagnostics.Process" />.  
  
- или - 
Экземпляр <see cref="T:System.Diagnostics.Process" /> был присоединен к запущенному процессу, но у вас нет необходимых разрешений для получения маркера с полными правами доступа.</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.Handle" /> процесса, запущенного на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HandleCount" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="HandleCount">
      <MemberSignature Language="C#" Value="public int HandleCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HandleCount" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HandleCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HandleCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int HandleCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.HandleCount : int" Usage="System.Diagnostics.Process.HandleCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Handles for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessHandleCount")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает число дескрипторов, открытых процессом.</summary>
        <value>Число дескрипторов операционной системы, открытых процессом.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дескрипторы предоставляют процессу возможность ссылаться на объекты. Процесс может получать дескрипторы файлов, ресурсов, очередей сообщений и многих других объектов операционной системы. Операционная система освобождает память, связанную с процессом, только если число маркеров равно нулю.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="HasExited">
      <MemberSignature Language="C#" Value="public bool HasExited { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasExited" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HasExited" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasExited As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasExited { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasExited : bool" Usage="System.Diagnostics.Process.HasExited" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the associated process has been terminated.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessTerminated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, определяющее завершение связанного процесса.</summary>
        <value>Значение <see langword="true" />, если процесс операционной системы, на который ссылается компонент <see cref="T:System.Diagnostics.Process" />, был завершен; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение `true` для <xref:System.Diagnostics.Process.HasExited%2A> указывает, что связанный процесс был завершен, как обычно, так и аварийно. Можно запросить или принудительно завершить связанный процесс, вызвав <xref:System.Diagnostics.Process.CloseMainWindow%2A> или <xref:System.Diagnostics.Process.Kill%2A>. Если дескриптор открыт для процесса, операционная система освобождает память процесса при завершении процесса, но оставляет административную информацию о процессе, например дескриптор, код выхода и время выхода. Чтобы получить эти сведения, можно использовать свойства <xref:System.Diagnostics.Process.ExitCode%2A> и <xref:System.Diagnostics.Process.ExitTime%2A>. Эти свойства автоматически заполняются для процессов, запущенных этим компонентом. Административная информация освобождается, когда все компоненты <xref:System.Diagnostics.Process>, связанные с системным процессом, уничтожаются и не записывают больше дескрипторов для завершенного процесса.  
  
 Процесс может завершиться независимо от вашего кода. Если процесс был запущен с помощью этого компонента, система автоматически обновляет значение <xref:System.Diagnostics.Process.HasExited%2A>, даже если связанный процесс завершается независимо.  
  
> [!NOTE]
>  Когда стандартный вывод перенаправляется в асинхронные обработчики событий, обработка выходных данных может не завершиться, если это свойство возвращает `true`. Чтобы обеспечить завершение асинхронной обработки событий, вызовите перегрузку <xref:System.Diagnostics.Process.WaitForExit>, которая не принимает параметр, прежде чем проверять <xref:System.Diagnostics.Process.HasExited%2A>.  
  
   
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем он получает сведения об использовании физической памяти для связанного процесса с интервалом в 2 секунды в течение не более 10 секунд. Пример определяет, завершается ли процесс до 10 секунд. В этом примере процесс закрывается, если он по-прежнему выполняется через 10 секунд.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">С объектом не связаны никакие процессы.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Не удалось получить код выхода для процесса.</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.HasExited" /> процесса, запущенного на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="M:System.Diagnostics.Process.OnExited" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Diagnostics.Process.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The unique identifier for the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает уникальный идентификатор связанного процесса.</summary>
        <value>Созданный системой уникальный идентификатор, на который ссылается этот экземпляр <see cref="T:System.Diagnostics.Process" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Id%2A> процесса недопустим, если связанный процесс не выполняется. Поэтому перед попыткой получить свойство <xref:System.Diagnostics.Process.Id%2A> необходимо убедиться в том, что процесс выполняется. До завершения процесса идентификатор процесса однозначно определяет процесс во всей системе.  
  
 Процесс, работающий на локальном или удаленном компьютере, можно подключить к новому экземпляру <xref:System.Diagnostics.Process>, передав идентификатор процесса в метод <xref:System.Diagnostics.Process.GetProcessById%2A>. <xref:System.Diagnostics.Process.GetProcessById%2A> является методом `static`, который создает новый компонент и автоматически устанавливает свойство <xref:System.Diagnostics.Process.Id%2A> для нового экземпляра <xref:System.Diagnostics.Process>.  
  
 Идентификаторы процессов могут повторно использоваться системой. Значение свойства <xref:System.Diagnostics.Process.Id%2A> является уникальным только во время выполнения связанного процесса. После завершения процесса система может повторно использовать значение свойства <xref:System.Diagnostics.Process.Id%2A> для несвязанного процесса.  
  
 Поскольку идентификатор уникален в системе, его можно передать другим потокам в качестве альтернативы передаче экземпляра <xref:System.Diagnostics.Process>. Это действие может сэкономить системные ресурсы, тем самым гарантируя правильную идентификацию процесса.  
  
   
  
## Examples  
 В следующем примере показано, как получить <xref:System.Diagnostics.Process.Id%2A> для всех работающих экземпляров приложения. Код создает новый экземпляр блокнота, перечисляет все экземпляры Блокнота, а затем позволяет пользователю ввести номер <xref:System.Diagnostics.Process.Id%2A>, чтобы удалить конкретный экземпляр.  
  
 [!code-csharp[System.Diagnostics.Process.Id#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Id#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Свойство <see cref="P:System.Diagnostics.Process.Id" /> процесса не задано.  
  
- или - 
С этим объектом <see cref="T:System.Diagnostics.Process" /> никакие процессы не связаны.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Kill">
      <Docs>
        <summary>To be added.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Метод `Kill` вызывает принудительное завершение процесса, в то время как <xref:System.Diagnostics.Process.CloseMainWindow%2A> запрашивает только завершение. При выполнении процесса с графическим интерфейсом его цикл обработки сообщений находится в состоянии ожидания. Цикл обработки сообщений выполняется каждый раз, когда операционная система отправляет сообщение Windows в процесс. Вызов <xref:System.Diagnostics.Process.CloseMainWindow%2A> отправляет запрос на закрытие главного окна, которое в правильно сформированном приложении закрывает дочерние окна и отменяет все выполняющиеся циклы сообщений для приложения. Запрос на выход из процесса путем вызова <xref:System.Diagnostics.Process.CloseMainWindow%2A> не заставляет приложение завершить работу.
Приложение может запросить проверку пользователя перед выходом или отказаться от его завершения. Чтобы принудительно завершить работу приложения, используйте метод `Kill`.

Поведение <xref:System.Diagnostics.Process.CloseMainWindow%2A> аналогично тому, как пользователь закрывает главное окно приложения с помощью системного меню.
Таким образом, запрос на завершение процесса путем закрытия главного окна не заставляет приложение немедленно завершить работу.
  
> [!NOTE]
> Метод <xref:System.Diagnostics.Process.Kill%2A> выполняется асинхронно. После вызова метода `Kill` вызовите метод <xref:System.Diagnostics.Process.WaitForExit%2A>, чтобы дождаться завершения процесса, или проверьте свойство <xref:System.Diagnostics.Process.HasExited%2A>, чтобы определить, завершился ли процесс.

> [!NOTE]
> Метод <xref:System.Diagnostics.Process.WaitForExit%2A> и свойство <xref:System.Diagnostics.Process.HasExited%2A> не отражает состояние процессов-потомков.
> При использовании `Kill(entireProcessTree: true)` <xref:System.Diagnostics.Process.WaitForExit%2A> и <xref:System.Diagnostics.Process.HasExited%2A> указывают, что выход завершен после завершения данного процесса, даже если все потомки еще не завершили работу.
  
Данные, измененные процессом или ресурсами, выделенными для процесса, могут быть потеряны при вызове `Kill`. 
`Kill` вызывает аварийное завершение процесса и должно использоваться только при необходимости.
<xref:System.Diagnostics.Process.CloseMainWindow%2A> обеспечивает упорядоченное завершение процесса и закрывает все окна, поэтому оно является предпочтительным для приложений с интерфейсом. В случае сбоя <xref:System.Diagnostics.Process.CloseMainWindow%2A> можно использовать `Kill` для завершения процесса.
`Kill` является единственным способом завершения процессов, не имеющих графических интерфейсов.
  
Можно вызвать `Kill` и <xref:System.Diagnostics.Process.CloseMainWindow%2A> только для процессов, запущенных на локальном компьютере.
Нельзя вызвать завершение процессов на удаленных компьютерах. Можно просматривать только сведения о процессах, запущенных на удаленных компьютерах.
  
> [!NOTE]
> Если вызов метода `Kill` выполняется в то время, пока процесс завершается, для доступа будет выдано <xref:System.ComponentModel.Win32Exception>.
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public void Kill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Kill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Kill" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Kill();" />
      <MemberSignature Language="F#" Value="member this.Kill : unit -&gt; unit" Usage="process.Kill " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Немедленно останавливает связанный процесс.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Связанный процесс не может быть завершен.  
  
 - или -  
  
 Выполняется завершение процесса.</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь вызвать метод <see cref="M:System.Diagnostics.Process.Kill" /> для процесса, выполняющегося на удаленном компьютере. Этот метод доступен только для процессов, запущенных на локальном компьютере.</exception>
        <exception cref="T:System.InvalidOperationException">Этот процесс уже завершился.  
  
- или - 
С этим объектом <see cref="T:System.Diagnostics.Process" /> никакие процессы не связаны.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Environment.Exit(System.Int32)" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public void Kill (bool entireProcessTree);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Kill(bool entireProcessTree) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Kill(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill (entireProcessTree As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Kill(bool entireProcessTree);" />
      <MemberSignature Language="F#" Value="member this.Kill : bool -&gt; unit" Usage="process.Kill entireProcessTree" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entireProcessTree" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="entireProcessTree"><see langword="true" /> для уничтожения связанного процесса и его потомков; <see langword="false" /> для уничтожения только связанного процесса.</param>
        <summary>Немедленно останавливает связанный процесс и, при необходимости, его дочерние процессы.</summary>
        <remarks>Если <paramref name="entireProcessTree" /> имеет значение <see langword="true" />, процессы, в которых у вызова отсутствуют разрешения на просмотр сведений, автоматически пропускаются в процессе завершения потомков, поскольку процессу завершения не удается определить, являются ли эти процессы потомками.</remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Связанный процесс не может быть завершен.  
  
 - или -  
  
 Выполняется завершение процесса.</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь вызвать метод <see cref="M:System.Diagnostics.Process.Kill" /> для процесса, выполняющегося на удаленном компьютере. Этот метод доступен только для процессов, запущенных на локальном компьютере.</exception>
        <exception cref="T:System.InvalidOperationException">Этот процесс уже завершился.  
  
- или - 
С этим объектом <see cref="T:System.Diagnostics.Process" /> не связаны никакие процессы.

- или -

Вызывающий процесс является членом дерева потомков связанного процесса.</exception>
        <exception cref="T:System.AggregateException">Не все процессы в дереве потомков связанного процесса могут быть завершены.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Environment.Exit(System.Int32)" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
      </Docs>
    </Member>
    <Member MemberName="LeaveDebugMode">
      <MemberSignature Language="C#" Value="public static void LeaveDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LeaveDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.LeaveDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LeaveDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LeaveDebugMode();" />
      <MemberSignature Language="F#" Value="static member LeaveDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.LeaveDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Выбирает компонент <see cref="T:System.Diagnostics.Process" /> из состояния, позволяющего ему взаимодействовать с процессами операционной системы, запущенными в специальном режиме.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Некоторые процессы операционной системы выполняются в специальном режиме. Попытка чтения свойств или присоединения к этим процессам невозможна, если в компоненте не вызван <xref:System.Diagnostics.Process.EnterDebugMode%2A>. Вызовите <xref:System.Diagnostics.Process.LeaveDebugMode%2A>, когда вам больше не нужен доступ к этим процессам, выполняемым в специальном режиме.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.EnterDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Diagnostics.Process.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of the machine the running the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMachineName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает имя компьютера, на котором выполняется связанный процесс.</summary>
        <value>Имя компьютера, на котором выполняется связанный процесс.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно просматривать статистические данные и сведения о процессах для процессов, запущенных на удаленных компьютерах, но нельзя вызывать <xref:System.Diagnostics.Process.Start%2A>, <xref:System.Diagnostics.Process.CloseMainWindow%2A>или <xref:System.Diagnostics.Process.Kill%2A> на удаленных компьютерах.  
  
> [!NOTE]
>  При выполнении связанного процесса на локальном компьютере это свойство возвращает точку (".") для имени компьютера. Для получения правильного имени компьютера следует использовать свойство <xref:System.Environment.MachineName%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Чтобы использовать следующий пример, необходимо сначала запустить хотя бы один экземпляр блокнота на удаленном компьютере. В примере запрашивается имя удаленного компьютера, на котором работает Блокнот, а затем отображаются соответствующие свойства <xref:System.Diagnostics.Process.ProcessName%2A>, <xref:System.Diagnostics.Process.Id%2A>и <xref:System.Diagnostics.Process.MachineName%2A> для каждого экземпляра.  
  
 [!code-csharp[process_GetProcessesByName2_2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CS/process_getprocessesbyname2_2.cs#2)]
 [!code-vb[process_GetProcessesByName2_2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_GetProcessesByName2_2/VB/process_getprocessesbyname2_2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">С этим объектом <see cref="T:System.Diagnostics.Process" /> никакие процессы не связаны.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MainModule">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModule MainModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModule MainModule" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainModule" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainModule As ProcessModule" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModule ^ MainModule { System::Diagnostics::ProcessModule ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainModule : System.Diagnostics.ProcessModule" Usage="System.Diagnostics.Process.MainModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The main module of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainModule")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModule</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает главный модуль связанного процесса.</summary>
        <value>Модуль <see cref="T:System.Diagnostics.ProcessModule" />, который был использован для запуска процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Модуль процесса представляет собой DLL-или exe-файл, который загружается в определенный процесс. Свойство <xref:System.Diagnostics.Process.MainModule%2A> позволяет просматривать сведения о исполняемом файле, который используется для запуска процесса, включая имя модуля, имя файла и сведения о памяти модуля.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.MainModule" /> процесса, запущенного на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">32-разрядный процесс пытается получить доступ к модулям 64-разрядного процесса.</exception>
        <exception cref="T:System.InvalidOperationException">Процесс <see cref="P:System.Diagnostics.Process.Id" /> недоступен.  
  
- или - 
Процесс завершен.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.Modules" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowHandle">
      <MemberSignature Language="C#" Value="public IntPtr MainWindowHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MainWindowHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MainWindowHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowHandle : nativeint" Usage="System.Diagnostics.Process.MainWindowHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The handle of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainWindowHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает дескриптор главного окна связанного процесса.</summary>
        <value>Созданный системой дескриптор главного окна связанного процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Главное окно — это окно, открытое процессом, который в данный момент находится в фокусе (<xref:System.Windows.Forms.Form.TopLevel%2A> форме). Необходимо использовать метод <xref:System.Diagnostics.Process.Refresh%2A>, чтобы обновить объект <xref:System.Diagnostics.Process>, чтобы получить текущий основной обработчик окна, если он был изменен. Как правило, поскольку обработчик окна кэшируется, используйте <xref:System.Diagnostics.Process.Refresh%2A> заранее, чтобы гарантировать получение текущего маркера.  
  
 Свойство <xref:System.Diagnostics.Process.MainWindowHandle%2A> можно получить только для процессов, запущенных на локальном компьютере. Свойство <xref:System.Diagnostics.Process.MainWindowHandle%2A> — это значение, уникально идентифицирующее окно, связанное с процессом.  
  
 С процессом связано главное окно, только если процесс имеет графический интерфейс. Если связанный процесс не имеет главного окна, <xref:System.Diagnostics.Process.MainWindowHandle%2A> значение равно нулю. Значение также равно нулю для процессов, которые были скрыты, то есть процессов, которые не отображаются на панели задач. Это может быть так для процессов, которые отображаются в виде значков в области уведомлений в правом углу панели задач.  
  
 Если вы только что начали процесс и хотите использовать его основной обработчик окна, рассмотрите возможность использования метода <xref:System.Diagnostics.Process.WaitForInputIdle%2A>, чтобы завершить процесс, убедившись, что был создан обработчик главного окна. В противном случае будет создаваться исключение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Свойство <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> не определено, так как процесс завершился.</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> процесса, запущенного на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowTitle" />
        <altmember cref="P:System.Diagnostics.Process.MainModule" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowTitle">
      <MemberSignature Language="C#" Value="public string MainWindowTitle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MainWindowTitle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowTitle As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MainWindowTitle { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowTitle : string" Usage="System.Diagnostics.Process.MainWindowTitle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The title of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainWindowTitle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает заголовок главного окна процесса.</summary>
        <value>Заголовок главного окна процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 С процессом связано главное окно, только если процесс имеет графический интерфейс. Если связанный процесс не имеет главного окна (то есть <xref:System.Diagnostics.Process.MainWindowHandle%2A> равен нулю), <xref:System.Diagnostics.Process.MainWindowTitle%2A> является пустой строкой (""). Если вы только что начали процесс и хотите использовать его заголовок главного окна, попробуйте использовать метод <xref:System.Diagnostics.Process.WaitForInputIdle%2A>, чтобы завершить процесс, убедившись, что был создан обработчик главного окна. В противном случае система создает исключение.  
  
> [!NOTE]
>  Главное окно — это окно, в котором в данный момент находится фокус; Обратите внимание, что это может быть не основное окно процесса. Необходимо использовать метод <xref:System.Diagnostics.Process.Refresh%2A>, чтобы обновить объект <xref:System.Diagnostics.Process>, чтобы получить текущий основной обработчик окна, если он был изменен.  
  
   
  
## Examples  
 В следующем примере запускается экземпляр блокнота и извлекается заголовок главного окна процесса.  
  
 [!code-cpp[process_MainWindowTitle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_MainWindowTitle/CPP/process_mainwindowtitle.cpp#1)]
 [!code-csharp[process_MainWindowTitle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_MainWindowTitle/CS/process_mainwindowtitle.cs#1)]
 [!code-vb[process_MainWindowTitle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_MainWindowTitle/VB/process_mainwindowtitle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Свойство <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> не определено, так как процесс завершился.</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> процесса, запущенного на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="MaxWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MaxWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MaxWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MaxWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MaxWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MaxWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MaxWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMaxWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает максимальный допустимый размер рабочего множества (в байтах) для связанного процесса.</summary>
        <value>Максимальный размер рабочего множества в байтах, доступного в памяти для процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Рабочий набор процесса — это набор страниц памяти, которые в настоящее время видны процессу в физической ОПЕРАТИВной памяти. Эти страницы являются резидентными и доступны для использования приложением без активации ошибки страницы.  
  
 Рабочий набор включает как общие, так и частные данные. Общие данные включают страницы, содержащие все инструкции, выполняемые приложением, включая страницы в DLL-файлах и файлы System. dll. По мере увеличения размера рабочего набора увеличивается потребность в памяти.  
  
 Процесс имеет минимальный и максимальный размеры рабочего множества. При каждом создании ресурса процесса система резервирует объем памяти, равный минимальному размеру рабочего набора для процесса. Диспетчер виртуальной памяти пытается сохранить по крайней мере минимальный объем памяти, когда процесс активен, но не превышает максимальный размер.  
  
 Система устанавливает размеры рабочего набора по умолчанию. Эти размеры можно изменить с помощью членов <xref:System.Diagnostics.Process.MaxWorkingSet%2A> и <xref:System.Diagnostics.Process.MinWorkingSet%2A>. Однако установка этих значений не гарантирует, что память будет зарезервированной или резидентной.  
  
> [!NOTE]
>  При увеличении размера рабочего набора процесса вы принимаете физическую память вне остальной части системы. Убедитесь, что не запрашивается слишком большой минимальный или максимальный размер рабочего множества, так как это может привести к снижению производительности системы.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Максимальный размер рабочего множества является недопустимым. Это значение должно быть больше минимального размера рабочего множества или равно ему.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Не удается получить сведения о рабочем множестве из ресурса связанного процесса.  
  
 - или -  
  
 Идентификатор или дескриптор процесса равен нулю, так как процесс не запущен.</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.MaxWorkingSet" /> процесса, запущенного на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <exception cref="T:System.InvalidOperationException">Процесс <see cref="P:System.Diagnostics.Process.Id" /> недоступен.  
  
- или - 
Процесс завершен.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="MinWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MinWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MinWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MinWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MinWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MinWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MinWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The minimum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMinWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает минимальный допустимый размер рабочего множества (в байтах) для связанного процесса.</summary>
        <value>Минимальный размер рабочего множества в байтах, требуемый в памяти для процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Рабочий набор процесса — это набор страниц памяти, которые в настоящее время видны процессу в физической ОПЕРАТИВной памяти. Эти страницы являются резидентными и доступны для использования приложением без активации ошибки страницы.  
  
 Рабочий набор включает как общие, так и частные данные. Общие данные включают страницы, содержащие все инструкции, выполняемые приложением, включая страницы в DLL-файлах и файлы System. dll. По мере увеличения размера рабочего набора увеличивается потребность в памяти.  
  
 Процесс имеет минимальный и максимальный размеры рабочего множества. При каждом создании ресурса процесса система резервирует объем памяти, равный минимальному размеру рабочего набора для процесса. Диспетчер виртуальной памяти пытается сохранить по крайней мере минимальный объем памяти, когда процесс активен, но не превышает максимальный размер.  
  
 Система устанавливает размеры рабочего набора по умолчанию. Эти размеры можно изменить с помощью членов <xref:System.Diagnostics.Process.MaxWorkingSet%2A> и <xref:System.Diagnostics.Process.MinWorkingSet%2A>. Однако установка этих значений не гарантирует, что память будет зарезервированной или резидентной.  
  
> [!NOTE]
>  При увеличении размера рабочего набора процесса вы принимаете физическую память вне остальной части системы. Убедитесь, что не запрашивается слишком большой минимальный или максимальный размер рабочего множества, так как это может привести к снижению производительности системы.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Минимальный размер рабочего множества является недопустимым. Это значение должно быть не больше максимального размера рабочего множества.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Не удается получить сведения о рабочем множестве из ресурса связанного процесса.  
  
 - или -  
  
 Идентификатор или дескриптор процесса равен нулю, так как процесс не запущен.</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.MinWorkingSet" /> процесса, запущенного на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <exception cref="T:System.InvalidOperationException">Процесс <see cref="P:System.Diagnostics.Process.Id" /> недоступен.  
  
- или - 
Процесс завершен.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModuleCollection Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModuleCollection Modules" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Modules" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Modules As ProcessModuleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModuleCollection ^ Modules { System::Diagnostics::ProcessModuleCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Modules : System.Diagnostics.ProcessModuleCollection" Usage="System.Diagnostics.Process.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The modules that are loaded as part of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessModules")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModuleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает модули, которые были загружены связанным процессом.</summary>
        <value>Массив объектов типа <see cref="T:System.Diagnostics.ProcessModule" />, который предоставляет модули, загруженные связанным процессом.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Модуль процесса представляет собой DLL-или exe-файл, который загружается в определенный процесс. Экземпляр <xref:System.Diagnostics.ProcessModule> позволяет просматривать сведения о модуле, включая имя модуля, имя файла и сведения о памяти модуля.  
  
 Процесс может загружать в память несколько модулей. Например, exe-файлы, которые загружают дополнительные DLL-файлы, имеют несколько модулей.  
  
 После запуска процесса эта коллекция будет пустой до тех пор, пока система не загрузится процесс. Если процесс имеет главное окно, можно вызвать <xref:System.Diagnostics.Process.WaitForInputIdle%2A> перед получением этого свойства, чтобы гарантировать, что коллекция будет непустой при получении списка.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.Modules" /> процесса, выполняющегося на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <exception cref="T:System.InvalidOperationException">Процесс <see cref="P:System.Diagnostics.Process.Id" /> недоступен.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.Modules" /> системного или бездействующего процесса. Эти процессы не имеют модулей.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="T:System.Diagnostics.ProcessModule" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int NonpagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 NonpagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int NonpagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize : int" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use NonpagedSystemMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.NonpagedSystemMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessNonpagedSystemMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.NonpagedSystemMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.NonpagedSystemMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объем невыгружаемой системной памяти в байтах, выделенной для связанного процесса.</summary>
        <value>Объем памяти в байтах, выделенной системой для связанного процесса, который нельзя записать в файл подкачки виртуальной памяти.</value>
        <remarks>To be added.</remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long NonpagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 NonpagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long NonpagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessNonpagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объем невыгружаемой системной памяти в байтах, выделенной для связанного процесса.</summary>
        <value>Количество системной памяти в байтах, выделенной для связанного процесса, которую нельзя записать в файл подкачки виртуальной памяти.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, возвращаемое этим свойством, представляет текущий размер нестраничной системной памяти, используемой процессом, в байтах. Память системы — это физическая память, используемая операционной системой и разделенная на страничные и нестраничные пулы. Выделение памяти без страничных ресурсов остается в системной памяти и не выводятся из страничного файла виртуальной памяти.  
  
 Это свойство можно использовать для наблюдения за использованием памяти на компьютерах с 32-разрядными процессорами или 64-разрядными процессорами. Значение свойства эквивалентно значению счетчика производительности " **байт в невыгружаемом страничном пуле** " для процесса.  
  
   
  
## Examples  
 В следующем примере кода запускается экземпляр приложения Notepad. Затем в примере извлекаются и отображаются различные свойства связанного процесса. В примере обнаруживается, когда процесс завершается, и отображается его код выхода и Пиковая статистика памяти.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="OnExited">
      <MemberSignature Language="C#" Value="protected void OnExited ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnExited() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.OnExited" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnExited ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnExited();" />
      <MemberSignature Language="F#" Value="member this.OnExited : unit -&gt; unit" Usage="process.OnExited " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает событие <see cref="E:System.Diagnostics.Process.Exited" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.OnExited%2A> — это метод API, который вызывает событие <xref:System.Diagnostics.Process.Exited>. Вызов <xref:System.Diagnostics.Process.OnExited%2A> приводит к возникновению события <xref:System.Diagnostics.Process.Exited> и является единственным способом вызова события с помощью компонента <xref:System.Diagnostics.Process>. <xref:System.Diagnostics.Process.OnExited%2A> в основном используется при наследовании классов от компонента.  
  
 В качестве альтернативы <xref:System.Diagnostics.Process.OnExited%2A>можно написать собственный обработчик событий. Вы создаете собственный делегат обработчика событий и собственный метод обработки событий.  
  
> [!NOTE]
>  При использовании среды Visual Studio делегат обработчика событий (Аддонекситед) и метод обработки событий (Process1_Exited) создаются при перетаскивании <xref:System.Diagnostics.Process> компонента на форму и двойном щелчке значка. Код, создаваемый при возникновении события <xref:System.Diagnostics.Process.Exited>, вводится в процедуру Process1_Exited. Не нужно создавать элемент <xref:System.Diagnostics.Process.OnExited%2A>, так как он реализован для вас.  
  
 При возникновении события через делегат вызывается обработчик события. Общие сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере показано, как использовать метод <xref:System.Diagnostics.Process.OnExited%2A> в производном классе.  
  
 [!code-csharp[OnExitSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/onexitsample/cs/program.cs#1)]
 [!code-vb[OnExitSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/onexitsample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="OutputDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler OutputDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler OutputDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.OutputDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event OutputDataReceived As DataReceivedEventHandler " FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ OutputDataReceived;" />
      <MemberSignature Language="F#" Value="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event OutputDataReceived As DataReceivedEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessAssociated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда приложение записывает строку в свой перенаправленный поток <see cref="P:System.Diagnostics.Process.StandardOutput" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Событие <xref:System.Diagnostics.Process.OutputDataReceived> указывает, что связанная <xref:System.Diagnostics.Process> записала строку, заканчивающуюся символом новой строки, на перенаправленный <xref:System.Diagnostics.Process.StandardOutput%2A> поток.  
  
 Событие включается во время асинхронных операций чтения в <xref:System.Diagnostics.Process.StandardOutput%2A>. Чтобы начать асинхронные операции чтения, необходимо перенаправить поток <xref:System.Diagnostics.Process.StandardOutput%2A> <xref:System.Diagnostics.Process>, добавить обработчик событий в <xref:System.Diagnostics.Process.OutputDataReceived> событие и вызвать <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>. После этого <xref:System.Diagnostics.Process.OutputDataReceived> событие сигнализирует каждый раз, когда процесс записывает строку в перенаправленный поток <xref:System.Diagnostics.Process.StandardOutput%2A>, пока процесс не завершит работу или не вызовет <xref:System.Diagnostics.Process.CancelOutputRead%2A>.  
  
> [!NOTE]
>  Приложение, обрабатывающее асинхронный вывод, должно вызывать метод <xref:System.Diagnostics.Process.WaitForExit%2A>, чтобы убедиться, что выходной буфер был сброшен.  
  
   
  
## Examples  
 В следующем примере показано, как выполнять асинхронные операции чтения в перенаправленном <xref:System.Diagnostics.Process.StandardOutput%2A> потоке команды `ipconfig`.  
  
 В примере создается делегат события для обработчика событий `OutputHandler` и связывается с событием <xref:System.Diagnostics.Process.OutputDataReceived>. Обработчик событий получает текстовые строки из перенаправленного <xref:System.Diagnostics.Process.StandardOutput%2A> потока, форматирует текст и сохраняет его в выходной строке, которая позже показана в окне консоли в этом примере.  
  
 [!code-cpp[Process_AsyncStreams#4](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/datareceivedevent.cpp#4)]
 [!code-csharp[Process_AsyncStreams#4](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/datareceivedevent.cs#4)]
 [!code-vb[Process_AsyncStreams#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/datareceivedevent.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize">
      <MemberSignature Language="C#" Value="public int PagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize : int" Usage="System.Diagnostics.Process.PagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PagedMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объем выгружаемой системной памяти в байтах, выделенной для связанного процесса.</summary>
        <value>Объем памяти в байтах, выделенной связанным процессом, который можно записать в файл подкачки виртуальной памяти.</value>
        <remarks>To be added.</remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объем выгружаемой системной памяти в байтах, выделенной для связанного процесса.</summary>
        <value>Объем памяти в байтах, выделенной в файле подкачки виртуальной памяти для связанного процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, возвращаемое этим свойством, представляет текущий размер памяти в файле подкачки виртуальной памяти, используемой процессом, в байтах. Операционная система использует файл подкачки виртуальной памяти в сочетании с физической памятью для управления виртуальным адресным пространством для каждого процесса. Если страничная память не используется, ее можно передать в файл подкачки виртуальной памяти на диске. Чтобы получить размер памяти, используемой операционной системой для процесса, используйте свойство <xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A>.  
  
 Это свойство можно использовать для наблюдения за использованием памяти на компьютерах с 32-разрядными процессорами или 64-разрядными процессорами. Значение свойства эквивалентно значению счетчика производительности " **байт файла подкачки** " для процесса.  
  
   
  
## Examples  
 В следующем примере кода запускается экземпляр приложения «Блокнот», а затем извлекаются и отображаются различные свойства связанного процесса. В примере обнаруживается, когда процесс завершается, и отображается его код выхода и Пиковая статистика памяти.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int PagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize : int" Usage="System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PagedSystemMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedSystemMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedSystemMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedSystemMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedSystemMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объем выгружаемой системной памяти в байтах, выделенной для связанного процесса.</summary>
        <value>Объем памяти в байтах, выделенной системой для связанного процесса, который можно записать в файл подкачки виртуальной памяти.</value>
        <remarks>To be added.</remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объем выгружаемой системной памяти в байтах, выделенной для связанного процесса.</summary>
        <value>Количество системной памяти в байтах, выделенной для связанного процесса, которую можно записать в файл подкачки виртуальной памяти.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, возвращаемое этим значением свойства, представляет текущий размер страничной системной памяти, используемой процессом, в байтах. Память системы — это физическая память, используемая операционной системой и разделенная на страничные и нестраничные пулы. Если страничная память не используется, ее можно передать в файл подкачки виртуальной памяти на диске. Чтобы получить размер памяти приложения, используемой процессом, используйте свойство <xref:System.Diagnostics.Process.PagedMemorySize64%2A>.  
  
 Это свойство можно использовать для наблюдения за использованием памяти на компьютерах с 32-разрядными процессорами или 64-разрядными процессорами. Значение свойства эквивалентно счетчику производительности " **байт в выгружаемом страничном пуле** " для процесса.  
  
   
  
## Examples  
 В следующем примере кода запускается экземпляр приложения Notepad. Затем в примере извлекаются и отображаются различные свойства связанного процесса. В примере обнаруживается, когда процесс завершается, и отображается его код выхода и Пиковая статистика памяти.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize">
      <MemberSignature Language="C#" Value="public int PeakPagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakPagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakPagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize : int" Usage="System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakPagedMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakPagedMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakPagedMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakPagedMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakPagedMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает максимальный объем памяти в байтах в файле подкачки виртуальной памяти, используемой связанным процессом.</summary>
        <value>Максимальный объем памяти в байтах, выделенной связанным процессом, который можно записать в файл подкачки виртуальной памяти.</value>
        <remarks>To be added.</remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakPagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakPagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakPagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает максимальный объем памяти в байтах в файле подкачки виртуальной памяти, используемой связанным процессом.</summary>
        <value>Максимальное количество памяти в байтах, выделенной в файле подкачки виртуальной памяти для связанного процесса с момента его запуска.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, возвращаемое этим значением свойства, представляет максимальный размер памяти в файле подкачки виртуальной памяти, используемой процессом с момента его запуска, в байтах. Операционная система использует файл подкачки виртуальной памяти в сочетании с физической памятью для управления виртуальным адресным пространством для каждого процесса. Если страничная память не используется, ее можно передать в файл подкачки виртуальной памяти на диске.  
  
 Это свойство можно использовать для наблюдения за использованием памяти на компьютерах с 32-разрядными процессорами или 64-разрядными процессорами. Значение свойства равно значению счетчика производительности " **байт файла подкачки (пик)** " для процесса.  
  
   
  
## Examples  
 В следующем примере кода запускается экземпляр приложения Notepad. Затем в примере извлекаются и отображаются различные свойства связанного процесса. В примере обнаруживается, когда процесс завершается, и отображается его код выхода и Пиковая статистика памяти.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize">
      <MemberSignature Language="C#" Value="public int PeakVirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakVirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakVirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize : int" Usage="System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakVirtualMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakVirtualMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakVirtualMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakVirtualMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakVirtualMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает максимальный объем виртуальной памяти (в байтах), используемой связанным процессом.</summary>
        <value>Максимальный объем виртуальной памяти в байтах, запрошенной связанным процессом.</value>
        <remarks>To be added.</remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakVirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakVirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakVirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает максимальный объем виртуальной памяти (в байтах), используемой связанным процессом.</summary>
        <value>Максимальное количество виртуальной памяти в байтах, выделенной для связанного процесса с момента его запуска.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, возвращаемое этим свойством, представляет максимальный размер виртуальной памяти, используемой процессом с момента его запуска, в байтах. Операционная система сопоставляет виртуальное адресное пространство для каждого процесса с страницами, загруженными в физической памяти, или со страницами, хранящимися в файле подкачки виртуальной памяти на диске.  
  
 Это свойство можно использовать для наблюдения за использованием памяти на компьютерах с 32-разрядными процессорами или 64-разрядными процессорами. Значение свойства равно значению счетчика производительности " **пиковые байты виртуальной памяти** " для процесса.  
  
   
  
## Examples  
 В следующем примере кода запускается экземпляр приложения Notepad. Затем в примере извлекаются и отображаются различные свойства связанного процесса. В примере обнаруживается, когда процесс завершается, и отображается его код выхода и Пиковая статистика памяти.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet">
      <MemberSignature Language="C#" Value="public int PeakWorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakWorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet : int" Usage="System.Diagnostics.Process.PeakWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakWorkingSet64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakWorkingSet64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakWorkingSet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakWorkingSet64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakWorkingSet64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает максимальный размер рабочего множества для связанного процесса (в байтах).</summary>
        <value>Максимальный объем физической памяти, запрошенной связанным процессом одновременно (в байтах).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Рабочий набор процесса — это набор страниц памяти, которые в настоящее время видны процессу в физической ОПЕРАТИВной памяти. Эти страницы являются резидентными и доступны для использования приложением без активации ошибки страницы.  
  
 Рабочий набор включает как общие, так и частные данные. Общие данные включают страницы, содержащие все инструкции, выполняемые процессом, включая модули процессов и системные библиотеки.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet64">
      <MemberSignature Language="C#" Value="public long PeakWorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakWorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakWorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet64 : int64" Usage="System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает максимальный объем физической памяти (в байтах), используемой связанным процессом.</summary>
        <value>Максимальный объем физической памяти в байтах, выделенной для связанного процесса с момента его запуска.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, возвращаемое этим свойством, представляет максимальный размер памяти рабочего набора, используемый процессом с момента его запуска, в байтах. Рабочий набор процесса — это набор страниц памяти, которые в настоящее время видны процессу в физической ОПЕРАТИВной памяти. Эти страницы являются резидентными и доступны для использования приложением без активации ошибки страницы.  
  
 Рабочий набор включает как общие, так и частные данные. Общие данные включают страницы, содержащие все инструкции, выполняемые процессом, включая инструкции из модулей процесса и системных библиотек.  
  
 Это свойство можно использовать для наблюдения за использованием памяти на компьютерах с 32-разрядными процессорами или 64-разрядными процессорами. Значение свойства равно значению счетчика **пиковой производительности рабочего набора** для процесса.  
  
   
  
## Examples  
 В следующем примере кода запускается экземпляр приложения Notepad. Затем в примере извлекаются и отображаются различные свойства связанного процесса. В примере обнаруживается, когда процесс завершается, и отображается его код выхода и Пиковая статистика памяти.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityBoostEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PriorityBoostEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityBoostEnabled : bool with get, set" Usage="System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Process will be of higher priority while it is actively used.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPriorityBoostEnabled")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, должна ли операционная система временно увеличить приоритет связанного процесса, когда основное окно процесса получит фокус.</summary>
        <value>Значение <see langword="true" />, если требуется динамическое увеличение приоритета процесса, когда процесс выходит из состояния ожидания; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда поток выполняется в процессе, для которого класс приоритета имеет одно из значений перечисления динамического приоритета (<xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>или <xref:System.Diagnostics.ProcessPriorityClass.RealTime>), система временно повышает приоритет потока при выходе из состояния ожидания. Это действие предотвращает прерывание обработки текущего потока другими процессами. Параметр <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> влияет на все существующие потоки и потоки, которые в дальнейшем создаются процессом. Чтобы восстановить нормальное поведение, присвойте свойству <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> значение `false`.  
  
> [!NOTE]
>  Увеличение приоритета слишком велико может привести к утечке ресурсов из важных операционных систем и сетевых функций, что вызывает проблемы с другими задачами операционной системы.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Не удается получить информацию о повышении приоритета от связанного ресурса процесса.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Идентификатор процесса или дескриптор процесса равен нулю. (Процесс не был запущен.)</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.PriorityBoostEnabled" /> процесса, выполняющегося на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <exception cref="T:System.InvalidOperationException">Процесс <see cref="P:System.Diagnostics.Process.Id" /> недоступен.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="PriorityClass">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessPriorityClass PriorityClass { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ProcessPriorityClass PriorityClass" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityClass" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityClass As ProcessPriorityClass" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessPriorityClass PriorityClass { System::Diagnostics::ProcessPriorityClass get(); void set(System::Diagnostics::ProcessPriorityClass value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityClass : System.Diagnostics.ProcessPriorityClass with get, set" Usage="System.Diagnostics.Process.PriorityClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The priority that the threads in the process run relative to.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPriorityClass")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessPriorityClass</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает общую категорию приоритета для процесса.</summary>
        <value>Категория приоритета для связанного процесса, из которой вычисляется свойство <see cref="P:System.Diagnostics.Process.BasePriority" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Класс приоритета процесса охватывает диапазон уровней приоритета потока. Потоки с разными приоритетами, которые выполняются в процессе, выполняются относительно класса приоритета процесса. Win32 использует четыре класса приоритета с семью базовыми уровнями приоритета на класс. Эти классы приоритетов процессов фиксируются в перечислении <xref:System.Diagnostics.ProcessPriorityClass>, которое позволяет задать приоритет процесса <xref:System.Diagnostics.ProcessPriorityClass.Idle>, <xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>, <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>или <xref:System.Diagnostics.ProcessPriorityClass.RealTime>. В зависимости от затраченного времени или других увеличений базовый уровень приоритета может быть изменен операционной системой, когда процесс должен быть помещается впереди других для доступа к процессору. Кроме того, можно задать <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>, чтобы временно увеличить уровень приоритета потоков, выданных из состояния ожидания. Приоритет сбрасывается, когда процесс возвращается в состояние ожидания.  
  
 Свойство <xref:System.Diagnostics.Process.BasePriority%2A> позволяет просматривать начальный приоритет, назначенный процессу. Однако, так как он доступен только для чтения, нельзя использовать свойство <xref:System.Diagnostics.Process.BasePriority%2A> для задания приоритета процесса. Чтобы изменить приоритет, используйте свойство <xref:System.Diagnostics.Process.PriorityClass%2A>, которое получает или задает общую категорию приоритета для процесса.  
  
 Класс приоритета нельзя просмотреть с помощью системного монитора. В следующей таблице показана связь между значениями <xref:System.Diagnostics.Process.BasePriority%2A> и <xref:System.Diagnostics.Process.PriorityClass%2A>.  
  
|басеприорити|PriorityClass значение|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем в примере извлекаются и отображаются различные свойства связанного процесса. В примере обнаруживается, когда процесс завершается, и отображается код завершения процесса.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Не удается задать или получить сведения о приоритете процесса от связанного ресурса процесса.  
  
 - или -  
  
 Идентификатор процесса или дескриптор процесса равен нулю. (Процесс не был запущен.)</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.PriorityClass" /> процесса, выполняющегося на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <exception cref="T:System.InvalidOperationException">Процесс <see cref="P:System.Diagnostics.Process.Id" /> недоступен.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Невозможно задать класс приоритета, поскольку он не использует допустимое значение, как определено в перечислении <see cref="T:System.Diagnostics.ProcessPriorityClass" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
        <altmember cref="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize">
      <MemberSignature Language="C#" Value="public int PrivateMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PrivateMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PrivateMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize : int" Usage="System.Diagnostics.Process.PrivateMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PrivateMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PrivateMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivateMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PrivateMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PrivateMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объем закрытой системной памяти в байтах, выделенной для связанного процесса.</summary>
        <value>Число байтов, выделенных связанным процессом, которые не могут быть доступны другим процессам.</value>
        <remarks>To be added.</remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PrivateMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize64">
      <MemberSignature Language="C#" Value="public long PrivateMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PrivateMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PrivateMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize64 : int64" Usage="System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivateMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объем закрытой системной памяти в байтах, выделенной для связанного процесса.</summary>
        <value>Объем памяти в байтах, выделенное для связанного процесса, которое не может быть доступно другим процессам.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, возвращаемое этим свойством, представляет текущий размер памяти, используемой процессом (в байтах), который не может использоваться совместно с другими процессами.  
  
 Это свойство можно использовать для наблюдения за использованием памяти на компьютерах с 32-разрядными процессорами или 64-разрядными процессорами. Значение свойства эквивалентно значению счетчика производительности " **байт исключительного** выполнения" для процесса.  
  
   
  
## Examples  
 В следующем примере кода запускается экземпляр приложения Notepad. Затем в примере извлекаются и отображаются различные свойства связанного процесса. В примере обнаруживается, когда процесс завершается, и отображается его код выхода и Пиковая статистика памяти.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivilegedProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PrivilegedProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivilegedProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent inside the operating system core.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivilegedProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает права доступа на время процессора для этого процесса.</summary>
        <value>Класс <see cref="T:System.TimeSpan" />, показывающий количество времени, которое процесс потратил на выполнение кода внутри ядра операционной системы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем в примере извлекаются и отображаются различные свойства связанного процесса. В примере обнаруживается, когда процесс завершается, и отображается код завершения процесса.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> процесса, выполняющегося на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="ProcessName">
      <MemberSignature Language="C#" Value="public string ProcessName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProcessName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProcessName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProcessName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProcessName : string" Usage="System.Diagnostics.Process.ProcessName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessProcessName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает имя процесса.</summary>
        <value>Имя, которое использует система для идентификации процесса для пользователя.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Diagnostics.Process.ProcessName%2A> содержит имя исполняемого файла, например Outlook, которое не включает расширение EXE или путь. Это полезно для получения и управления всеми процессами, связанными с одним и тем же исполняемым файлом.  
  
> [!NOTE]
>  В операционных системах [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] свойство <xref:System.Diagnostics.Process.ProcessName%2A> может быть усечено до 15 символов, если не удается получить сведения о модуле процесса.  
  
 Можно вызвать <xref:System.Diagnostics.Process.GetProcessesByName%2A>, передав ему имя исполняемого файла, чтобы получить массив, содержащий все выполняющиеся экземпляры на указанном компьютере. Этот массив можно использовать, например, для завершения работы всех работающих экземпляров исполняемого файла.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Процесс не имеет идентификатора, или нет процесса, связанного с <see cref="T:System.Diagnostics.Process" />.  
  
- или - 
Связанный процесс завершился.</exception>
        <exception cref="T:System.NotSupportedException">Процесс отсутствует на этом компьютере.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessorAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Property ProcessorAffinity As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ProcessorAffinity { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorAffinity : nativeint with get, set" Usage="System.Diagnostics.Process.ProcessorAffinity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Allowed processor that can be used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessProcessorAffinity")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает процессоры, на которых может быть запланировано выполнение потоков данного процесса.</summary>
        <value>Битовая маска, представляющая процессоры, на которых могут выполняться потоки связанного процесса. По умолчанию маска зависит от числа процессоров в компьютере. Значение по умолчанию — 2 <sup>n</sup> – 1, где n — число процессоров.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В Windows 2000 и более поздних версиях поток процесса может переноситься с процессора на процессор, при этом каждый процесс миграции перезагружает кэш процессора. При высоких нагрузках на систему указание того, какой процессор должен запустить конкретный поток, может повысить производительность, уменьшая количество раз, когда кэш процессора перезагружается. Связь между процессором и потоком называется сходством процессоров.  
  
 Каждый процессор представляется в виде бита. Бит 0 — первый процессор, бит 1 — второй процессор и т. д. Если установить бит равным значению 1, соответствующий процессор будет выбран для назначения потоков. Если <xref:System.Diagnostics.Process.ProcessorAffinity%2A> значение равно нулю, алгоритмы планирования операционной системы устанавливают сходство потока. Если для <xref:System.Diagnostics.Process.ProcessorAffinity%2A> задано любое ненулевое значение, значение интерпретируется как битовая маска, указывающая, какие процессоры могут быть выбраны для выбора.  
  
 В следующей таблице показана выборка значений <xref:System.Diagnostics.Process.ProcessorAffinity%2A> для системы из восьми процессоров.  
  
|Битовые|Двоичное значение|Подходящие процессоры|  
|-------------|------------------|-------------------------|  
|0x0001|00000000 00000001|1|  
|0x0003|00000000 00000011|1 и 2|  
|0x0007|00000000 00000111|1, 2 и 3|  
|0x0009|00000000 00001001|1 и 4|  
|0x007F|00000000 01111111|1, 2, 3, 4, 5, 6 и 7|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Не удается задать или получить сведения о <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> от связанного ресурса процесса.  
  
- или - 
Идентификатор процесса или дескриптор процесса равен нулю. (Процесс не был запущен.)</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> процесса, выполняющегося на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <exception cref="T:System.InvalidOperationException">Процесс <see cref="P:System.Diagnostics.Process.Id" /> недоступен.  
  
- или - 
Процесс завершен.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="process.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет любые кэшированные внутри компонента процесса сведения о связанном процессе.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 После вызова <xref:System.Diagnostics.Process.Refresh%2A> первый запрос сведений о каждом свойстве приводит к тому, что компонент процесса получает новое значение из связанного процесса.  
  
 Если компонент <xref:System.Diagnostics.Process> связан с ресурсом процесса, значения свойств <xref:System.Diagnostics.Process> немедленно заполняются в соответствии с состоянием связанного процесса. Если сведения о связанном процессе в дальнейшем изменяются, эти изменения не отражаются в кэшированных значениях <xref:System.Diagnostics.Process> компонента. Компонент <xref:System.Diagnostics.Process> является моментальным снимком ресурса процесса во время его связывания. Чтобы просмотреть текущие значения связанного процесса, вызовите метод <xref:System.Diagnostics.Process.Refresh%2A>.  
  
   
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем он получает сведения об использовании физической памяти для связанного процесса с интервалом в 2 секунды в течение не более 10 секунд. Пример определяет, завершается ли процесс до 10 секунд. В этом примере процесс закрывается, если он по-прежнему выполняется через 10 секунд.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="Responding">
      <MemberSignature Language="C#" Value="public bool Responding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Responding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Responding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Responding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Responding { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Responding : bool" Usage="System.Diagnostics.Process.Responding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Is this process responsive.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessResponding")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, отвечает или нет пользовательский интерфейс.</summary>
        <value>Значение <see langword="true" />, если пользовательский интерфейс связанного процесса отвечает системе; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если процесс имеет пользовательский интерфейс, свойство <xref:System.Diagnostics.Process.Responding%2A> связывается с пользовательским интерфейсом, чтобы определить, отвечает ли процесс на ввод данных пользователем. Если интерфейс не отвечает немедленно, свойство <xref:System.Diagnostics.Process.Responding%2A> возвращает `false`. Используйте это свойство, чтобы определить, перестал ли отвечать интерфейс связанного процесса.  
  
 Если процесс не имеет <xref:System.Diagnostics.Process.MainWindowHandle%2A>, это свойство возвращает `true`.  
  
   
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем в примере извлекаются и отображаются различные свойства связанного процесса. В примере обнаруживается, когда процесс завершается, и отображается код завершения процесса.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">С этим объектом <see cref="T:System.Diagnostics.Process" /> никакие процессы не связаны.</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.Responding" /> процесса, выполняющегося на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowHandle" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeProcessHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeProcessHandle ^ SafeHandle { Microsoft::Win32::SafeHandles::SafeProcessHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeHandle : Microsoft.Win32.SafeHandles.SafeProcessHandle" Usage="System.Diagnostics.Process.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeProcessHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает собственный дескриптор процесса.</summary>
        <value>Собственный дескриптор процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот маркер доступен только в том случае, если вызывающий компонент запустил процесс.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionId">
      <MemberSignature Language="C#" Value="public int SessionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SessionId" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SessionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SessionId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SessionId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SessionId : int" Usage="System.Diagnostics.Process.SessionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The session ID for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessSessionId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает идентификатор сеанса служб терминалов для связанного процесса.</summary>
        <value>Идентификатор сеанса служба терминалов для связанного процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Diagnostics.Process.SessionId%2A> определяет сеанс, в котором приложение выполняется в данный момент.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">С этим процессом никакие сеансы не связаны.</exception>
        <exception cref="T:System.InvalidOperationException">С этим идентификатором сеанса не связаны никакие процессы.  
  
 - или -  
  
 На этом компьютере нет связанного процесса.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="StandardError">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardError" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardError" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardError As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardError { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardError : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard error stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardError")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает поток, используемый для чтения вывода ошибок приложения.</summary>
        <value>Объект <see cref="T:System.IO.StreamReader" />, используемый для чтения стандартного потока ошибок приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Diagnostics.Process> записывает текст в стандартный поток ошибок, этот текст обычно отображается в консоли. Перенаправление потока <xref:System.Diagnostics.Process.StandardError%2A> позволяет управлять выводом ошибок процесса или подавлять его. Например, можно отфильтровать текст, отформатировать его по-другому или записать выходные данные как в консоль, так и в назначенный файл журнала.  
  
> [!NOTE]
>  Чтобы использовать <xref:System.Diagnostics.Process.StandardError%2A>, необходимо задать для <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> значение `false`, а для параметра <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=nameWithType> необходимо задать значение `true`. В противном случае при чтении из потока <xref:System.Diagnostics.Process.StandardError%2A> возникает исключение.  
  
 Перенаправленный поток <xref:System.Diagnostics.Process.StandardError%2A> может считываться синхронно или асинхронно. Такие методы, как <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>и <xref:System.IO.StreamReader.ReadToEnd%2A> выполняют синхронные операции чтения для потока вывода ошибок процесса. Эти операции синхронного чтения не завершаются, пока связанный <xref:System.Diagnostics.Process> не запишет в свой поток <xref:System.Diagnostics.Process.StandardError%2A> или закроет поток.  
  
 В отличие от этого <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> запускает асинхронные операции чтения в потоке <xref:System.Diagnostics.Process.StandardError%2A>. Этот метод включает назначенный обработчик событий для выходного потока и сразу же возвращает вызывающему объекту, который может выполнять другие действия, пока выходные данные потока направляются в обработчик событий.  
  
 Синхронные операции чтения представляют зависимость между вызывающим объектом, читающим поток <xref:System.Diagnostics.Process.StandardError%2A>, и дочерним процессом, записывающим в этот поток. Эти зависимости могут привести к возникновению условий взаимоблокировки. Когда вызывающий объект считывает данные из перенаправленного потока дочернего процесса, он зависит от дочернего объекта. Вызывающий объект ожидает операции чтения до тех пор, пока дочерние записи не будут записаны в поток или закроет поток. Когда дочерний процесс записывает достаточно данных для заполнения перенаправляемого потока, он зависит от родителя. Дочерний процесс ожидает следующей операции записи, пока родитель не считывает из полного потока или не закрывает поток. Условие взаимоблокировки вызывается, когда вызывающий и дочерний процесс ожидает друг друга для выполнения операции, и ни одна из них не может продолжаться. Можно избежать взаимоблокировок, оценивая зависимости между вызывающим и дочерним процессами.  

В двух последних примерах в этом разделе используется метод <xref:System.Diagnostics.Process.Start%2A> для запуска исполняемого файла с именем *Write500Lines. exe*. В следующем примере содержится исходный код.

[!code-csharp[Executable launched by Process.Start](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/write500lines.cs)]
[!code-vb[Executable launched by Process.Start](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/write500lines.vb)]

В следующем примере показано, как выполнить чтение из перенаправленного потока ошибок и дождаться завершения дочернего процесса. Это позволяет избежать условия взаимоблокировки путем вызова `p.StandardError.ReadToEnd` перед `p.WaitForExit`. Условие взаимоблокировки может возникнуть, если родительский процесс вызывает `p.WaitForExit` до `p.StandardError.ReadToEnd` и дочерний процесс записывает достаточно текста для заполнения перенаправленного потока. Родительский процесс ожидает завершения дочернего процесса в течение неограниченного времени. Дочерний процесс в течение неограниченного времени будет ждать, пока родительский поток не будет считаться из полного <xref:System.Diagnostics.Process.StandardError%2A> потока.   

[!code-csharp[Reading from the error stream](~/samples/snippets/csharp/api/system.diagnostics/process/standarderror/stderror-sync.cs)]
[!code-vb[Reading from the error stream](~/samples/snippets/visualbasic/api/system.diagnostics/process/standarderror/stderror-sync.vb)]  

Подобная ситуация возникает при чтении всего текста из стандартных выходных и стандартных потоков ошибок. В следующем примере выполняется операция чтения для обоих потоков. Это позволяет избежать условия взаимоблокировки, выполняя асинхронные операции чтения в потоке <xref:System.Diagnostics.Process.StandardError%2A>. Условие взаимоблокировки дает результат, если родительский процесс вызывает `p.StandardOutput.ReadToEnd`, за которым следует `p.StandardError.ReadToEnd` и дочерний процесс записывает достаточно текста для заполнения потока ошибок. Родительский процесс будет ждать неограниченного времени, пока дочерний процесс не закроет свой поток <xref:System.Diagnostics.Process.StandardOutput%2A>. Дочерний процесс в течение неограниченного времени будет ждать, пока родительский поток не будет считаться из полного <xref:System.Diagnostics.Process.StandardError%2A> потока.  
[!code-csharp[Reading from both streams](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/stdoutput-async.cs)]
[!code-vb[Reading from both streams](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/stdoutput-async.vb)]  

Асинхронные операции чтения можно использовать во избежание этих зависимостей и их возможных взаимоблокировок. Кроме того, можно избежать условия взаимоблокировки, создав два потока и прочитав выходные данные каждого потока в отдельном потоке.  
  
> [!NOTE]
>  В перенаправленном потоке нельзя смешивать асинхронные и синхронные операции чтения. После открытия перенаправленного потока <xref:System.Diagnostics.Process> в асинхронном или синхронном режиме все последующие операции чтения в этом потоке должны быть в том же режиме. Например, не следует выполнять <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> с вызовом <xref:System.IO.StreamReader.ReadLine%2A> в <xref:System.Diagnostics.Process.StandardError%2A>ном потоке или наоборот. Однако можно считывать два разных потока в разных режимах. Например, можно вызвать <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>, а затем вызвать метод <xref:System.IO.StreamReader.ReadLine%2A> для <xref:System.Diagnostics.Process.StandardError%2A> потока.  
  
   
  
## Examples  
 В следующем примере используется команда `net use` вместе с аргументом, предоставляемым пользователем для подключения сетевого ресурса. Затем он считывает стандартный поток ошибок команды NET и записывает его в консоль.  
  
 [!code-cpp[Process_StandardError#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardError/CPP/source.cpp#1)]
 [!code-csharp[Process_StandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardError/CS/source.cs#1)]
 [!code-vb[Process_StandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardError/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Поток <see cref="P:System.Diagnostics.Process.StandardError" /> не был определен для переадресации. Убедитесь, что для <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> задано <see langword="true" />, а для <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> — <see langword="false" />.  
  
- или - 
Поток <see cref="P:System.Diagnostics.Process.StandardError" /> был открыт для асинхронных операций чтения с <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
      </Docs>
    </Member>
    <Member MemberName="StandardInput">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter StandardInput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamWriter StandardInput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardInput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardInput As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamWriter ^ StandardInput { System::IO::StreamWriter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardInput : System.IO.StreamWriter" Usage="System.Diagnostics.Process.StandardInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard input stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardInput")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает поток, используемый для записи ввода приложения.</summary>
        <value>Объект <see cref="T:System.IO.StreamWriter" />, используемый для записи стандартного входного потока приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process> может считывать входной текст из стандартного входного потока, обычно с клавиатуры. Перенаправляя поток <xref:System.Diagnostics.Process.StandardInput%2A>, можно программно указать входные данные. Например, вместо ввода с клавиатуры можно указать текст из содержимого указанного файла или выходных данных другого приложения.  
  
> [!NOTE]
>  Чтобы использовать <xref:System.Diagnostics.Process.StandardInput%2A>, необходимо задать для <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> значение `false`, а для параметра <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=nameWithType> необходимо задать значение `true`. В противном случае запись в поток <xref:System.Diagnostics.Process.StandardInput%2A> создает исключение.  
  
   
  
## Examples  
 В следующем примере показано, как перенаправить поток <xref:System.Diagnostics.Process.StandardInput%2A> процесса. В примере запускается команда `sort` с перенаправленным входом. Затем он запрашивает у пользователя текст и передает его в `sort` процесс с помощью перенаправленного <xref:System.Diagnostics.Process.StandardInput%2A> потока. Результаты `sort` отображаются для пользователя в консоли.  
  
 [!code-cpp[Process_StandardInput#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardInput/CPP/process_standardinput.cpp#1)]
 [!code-csharp[Process_StandardInput#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardInput/CS/process_standardinput.cs#1)]
 [!code-vb[Process_StandardInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardInput/VB/process_standardinput.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.Process.StandardInput" /> Поток не был определен, так как для <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" /> установлено значение <see langword="false" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />
      </Docs>
    </Member>
    <Member MemberName="StandardOutput">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardOutput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardOutput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardOutput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardOutput As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardOutput { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardOutput : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard output stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardOutput")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает поток, используемый для чтения текстовых выходных данных приложения.</summary>
        <value>Объект <see cref="T:System.IO.StreamReader" />, используемый для чтения стандартного потока вывода приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Diagnostics.Process> записывает текст в стандартный поток, этот текст обычно отображается в консоли. Перенаправление потока <xref:System.Diagnostics.Process.StandardOutput%2A> позволяет управлять выходом процесса или подавлять его вывод. Например, можно отфильтровать текст, отформатировать его по-другому или записать выходные данные как в консоль, так и в назначенный файл журнала.  
  
> [!NOTE]
>  Чтобы использовать <xref:System.Diagnostics.Process.StandardOutput%2A>, необходимо задать для <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> значение `false`, а для параметра <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=nameWithType> необходимо задать значение `true`. В противном случае при чтении из потока <xref:System.Diagnostics.Process.StandardOutput%2A> возникает исключение.  
  
 Перенаправленный поток <xref:System.Diagnostics.Process.StandardOutput%2A> может считываться синхронно или асинхронно. Такие методы, как <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>и <xref:System.IO.StreamReader.ReadToEnd%2A> выполняют синхронные операции чтения в потоке вывода процесса. Эти операции синхронного чтения не завершаются, пока связанный <xref:System.Diagnostics.Process> не запишет в свой поток <xref:System.Diagnostics.Process.StandardOutput%2A> или закроет поток.  
  
 В отличие от этого <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> запускает асинхронные операции чтения в потоке <xref:System.Diagnostics.Process.StandardOutput%2A>. Этот метод включает назначенный обработчик событий для выходного потока и сразу же возвращает вызывающему объекту, который может выполнять другие действия, пока выходные данные потока направляются в обработчик событий.  
  
 Синхронные операции чтения представляют зависимость между вызывающим объектом, читающим поток <xref:System.Diagnostics.Process.StandardOutput%2A>, и дочерним процессом, записывающим в этот поток. Эти зависимости могут привести к возникновению условий взаимоблокировки. Когда вызывающий объект считывает данные из перенаправленного потока дочернего процесса, он зависит от дочернего объекта. Вызывающий объект ожидает операции чтения до тех пор, пока дочерние записи не будут записаны в поток или закроет поток. Когда дочерний процесс записывает достаточно данных для заполнения перенаправляемого потока, он зависит от родителя. Дочерний процесс ожидает следующей операции записи, пока родитель не считывает из полного потока или не закрывает поток. Условие взаимоблокировки вызывается, когда вызывающий и дочерний процесс ожидает друг друга для выполнения операции, и ни одна из них не может продолжаться. Можно избежать взаимоблокировок, оценивая зависимости между вызывающим и дочерним процессами.  

В двух последних примерах в этом разделе используется метод <xref:System.Diagnostics.Process.Start%2A> для запуска исполняемого файла с именем *Write500Lines. exe*. В следующем примере содержится исходный код.

[!code-csharp[Executable launched by Process.Start](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/write500lines.cs)]
[!code-vb[Executable launched by Process.Start](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/write500lines.vb)]

В следующем примере показано, как выполнить чтение из перенаправленного потока и дождаться завершения дочернего процесса. В этом примере предотвращается условие взаимоблокировки путем вызова `p.StandardOutput.ReadToEnd` перед `p.WaitForExit`. Условие взаимоблокировки может возникнуть, если родительский процесс вызывает `p.WaitForExit` до `p.StandardOutput.ReadToEnd` и дочерний процесс записывает достаточно текста для заполнения перенаправленного потока. Родительский процесс ожидает завершения дочернего процесса в течение неограниченного времени. Дочерний процесс в течение неограниченного времени будет ждать, пока родительский поток не будет считаться из полного <xref:System.Diagnostics.Process.StandardOutput%2A> потока.  

[!code-csharp[Reading synchronously from a redirected output stream](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/stdoutput-sync.cs)]  
[!code-vb[Reading synchronously from a redirected output stream](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/stdoutput-sync.vb)]  

Подобная ситуация возникает при чтении всего текста из стандартных выходных и стандартных потоков ошибок. В следующем примере выполняется операция чтения для обоих потоков. Это позволяет избежать условия взаимоблокировки, выполняя асинхронные операции чтения в потоке <xref:System.Diagnostics.Process.StandardError%2A>. Условие взаимоблокировки дает результат, если родительский процесс вызывает `p.StandardOutput.ReadToEnd`, за которым следует `p.StandardError.ReadToEnd` и дочерний процесс записывает достаточно текста для заполнения потока ошибок. Родительский процесс будет ждать неограниченного времени, пока дочерний процесс не закроет свой поток <xref:System.Diagnostics.Process.StandardOutput%2A>. Дочерний процесс в течение неограниченного времени будет ждать, пока родительский поток не будет считаться из полного <xref:System.Diagnostics.Process.StandardError%2A> потока.   
[!code-csharp[Reading from a redirected output and error stream](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/stdoutput-async.cs)]  
[!code-vb[Reading from a redirected output and error stream](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/stdoutput-async.vb)]    
  
 Асинхронные операции чтения можно использовать во избежание этих зависимостей и их возможных взаимоблокировок. Кроме того, можно избежать условия взаимоблокировки, создав два потока и прочитав выходные данные каждого потока в отдельном потоке.  
  
> [!NOTE]
>  В перенаправленном потоке нельзя смешивать асинхронные и синхронные операции чтения. После открытия перенаправленного потока <xref:System.Diagnostics.Process> в асинхронном или синхронном режиме все последующие операции чтения в этом потоке должны быть в том же режиме. Например, не следует выполнять <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> с вызовом <xref:System.IO.StreamReader.ReadLine%2A> в <xref:System.Diagnostics.Process.StandardOutput%2A>ном потоке или наоборот. Однако можно считывать два разных потока в разных режимах. Например, можно вызвать <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>, а затем вызвать метод <xref:System.IO.StreamReader.ReadLine%2A> для <xref:System.Diagnostics.Process.StandardError%2A> потока.  
  
   
  
## Examples  
 Следующий пример выполняет команду ipconfig. exe и перенаправляет его стандартные выходные данные в окно консоли в этом примере.  
  
 [!code-cpp[Process_StandardOutput#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardOutput/CPP/process_standardoutput.cpp#2)]
 [!code-csharp[Process_StandardOutput#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardOutput/CS/process_standardoutput.cs#2)]
 [!code-vb[Process_StandardOutput#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardOutput/VB/process_standardoutput.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Поток <see cref="P:System.Diagnostics.Process.StandardOutput" /> не был определен для переадресации. Убедитесь, что для <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> задано <see langword="true" />, а для <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> — <see langword="false" />.  
  
- или - 
Поток <see cref="P:System.Diagnostics.Process.StandardOutput" /> был открыт для асинхронных операций чтения с <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Запускает ресурс процесса и связывает его с компонентом <see cref="T:System.Diagnostics.Process" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public bool Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start" />
      <MemberSignature Language="VB.NET" Value="Public Function Start () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; bool" Usage="process.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Запускает (или повторно использует) ресурс процесса, определенный свойством <see cref="P:System.Diagnostics.Process.StartInfo" /> этого компонента <see cref="T:System.Diagnostics.Process" />, и связывает его с компонентом.</summary>
        <returns>Значение <see langword="true" />, если ресурс процесса запущен; значение <see langword="false" />, если новый ресурс процесса не был запущен (например, при повторном использовании существующего процесса).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для запуска ресурса процесса и связывания его с текущим компонентом <xref:System.Diagnostics.Process>. Возвращаемое значение `true` указывающее, что был запущен новый ресурс процесса. Если ресурс процесса, указанный членом <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> свойства <xref:System.Diagnostics.Process.StartInfo%2A>, уже выполняется на компьютере, дополнительный ресурс процесса не запускается. Вместо этого выполняется повторное использование ресурса выполняющегося процесса и возвращается `false`.  
  
 Приложение ClickOnce можно запустить, указав расположение (например, веб-адрес), из которого изначально было установлено приложение. Не запускайте приложение ClickOnce, указав его расположение на жестком диске.  
  
> [!NOTE]
>  Если вы используете Visual Studio, эта перегрузка метода <xref:System.Diagnostics.Process.Start%2A> вставляется в код после перетаскивания компонента <xref:System.Diagnostics.Process> на конструктор. Используйте окно `Properties`, чтобы развернуть категорию `StartInfo` и записать соответствующее значение в свойство `FileName`. Изменения будут отображаться в `InitializeComponent`ной процедуре формы.  
  
 Эта перегрузка <xref:System.Diagnostics.Process.Start%2A> не является методом `static`. Его необходимо вызвать из экземпляра класса <xref:System.Diagnostics.Process>. Перед вызовом <xref:System.Diagnostics.Process.Start%2A>необходимо сначала указать <xref:System.Diagnostics.Process.StartInfo%2A> сведения о свойствах для этого экземпляра <xref:System.Diagnostics.Process>, так как эти сведения используются для определения запускаемого ресурса процесса.  
  
 Другие перегрузки метода <xref:System.Diagnostics.Process.Start%2A> являются `static` членами. Не нужно создавать экземпляр компонента <xref:System.Diagnostics.Process> перед вызовом этих перегрузок метода. Вместо этого можно вызвать <xref:System.Diagnostics.Process.Start%2A> для самого класса <xref:System.Diagnostics.Process> и создать новый компонент <xref:System.Diagnostics.Process>, если процесс был запущен. Или, если процесс был использован повторно, возвращается `null`. Ресурс процесса автоматически связывается с новым компонентом <xref:System.Diagnostics.Process>, который возвращается методом <xref:System.Diagnostics.Process.Start%2A>.  
  
 Члены <xref:System.Diagnostics.Process.StartInfo%2A> можно использовать для дублирования функциональных возможностей диалогового окна `Run` меню `Start` Windows. Все, что можно ввести в командную строку, можно запустить, задав соответствующие значения в свойстве <xref:System.Diagnostics.Process.StartInfo%2A>. Единственным свойством <xref:System.Diagnostics.Process.StartInfo%2A>, которое необходимо задать, является свойство <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>. Свойство <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> не обязательно должно быть исполняемым файлом. Это может быть любой тип файлов, для которого расширение было связано с приложением, установленным в системе. Например, свойство <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> может иметь расширение txt, если у вас есть связанные текстовые файлы с редактором, например Блокнот, или иметь расширение DOC, если у вас есть связанные DOC-файлы с инструментом обработки текста, например Microsoft Word.  
  
 В командной строке можно указать действия, выполняемые для определенных типов файлов. Например, можно печатать документы или редактировать текстовые файлы. Укажите эти действия с помощью элемента <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> свойства <xref:System.Diagnostics.Process.StartInfo%2A>. Для других типов файлов можно указать аргументы командной строки при запуске файла из диалогового окна `Run`. Например, можно передать URL-адрес в качестве аргумента, если в качестве <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>указан браузер. Эти аргументы можно указать в элементе <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> <xref:System.Diagnostics.Process.StartInfo%2A> свойства.  
  
 Если в системе объявлен заключенный в кавычки путь в переменной path, при запуске любого процесса из этого расположения необходимо указание полного пути. В противном случае система не найдет этот путь. Например, если в переменной path нет пути `c:\mypath` и он добавляется к ней с использованием кавычек (`path = %path%;"c:\mypath"`), при запуске любого процесса из `c:\mypath` необходимо полностью указывать путь к файлу.  
  
> [!NOTE]
>  Код веб-страницы и серверного элемента управления ASP.NET выполняется в контексте рабочего процесса ASP.NET на веб-сервере.  При использовании метода <xref:System.Diagnostics.Process.Start%2A> на веб-странице ASP.NET или серверном элементе управления новый процесс выполняется на веб-сервере с ограниченными разрешениями. Процесс не запускается в том же контексте, что и браузер клиента, и не имеет доступа к рабочему столу пользователя.  
  
 При использовании <xref:System.Diagnostics.Process.Start%2A> для запуска процесса может потребоваться закрыть его или вы рискуете потерять системные ресурсы. Закройте процессы с помощью <xref:System.Diagnostics.Process.CloseMainWindow%2A> или <xref:System.Diagnostics.Process.Kill%2A>. Вы можете проверить, был ли уже закрыт процесс, используя его свойство <xref:System.Diagnostics.Process.HasExited%2A>.  
  
 Примечание о состояниях апартамента в управляемых потоках необходимо здесь. Если <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> `true` в свойстве <xref:System.Diagnostics.Process.StartInfo%2A> компонента Process, убедитесь, что для приложения установлен потоковая модель, установив атрибут `[STAThread]` в методе `main()`. В противном случае управляемый поток может находиться в `unknown` состоянии или поставляться в `MTA`ном состоянии, второе из которых конфликтует с <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> `true`. Для некоторых методов требуется, чтобы состояние апартамента не было `unknown`. Если состояние не задано явно, то, когда приложение встречает такой метод, по умолчанию используется `MTA`, и после установки состояние апартамента не может быть изменено. Однако `MTA` вызывает исключение, если оболочка операционной системы управляет потоком.  
  
   
  
## Examples  
 В следующем примере для запуска процесса используется экземпляр класса <xref:System.Diagnostics.Process>.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Имя файла не было указано в свойстве <see cref="P:System.Diagnostics.Process.StartInfo" /> компонента <see cref="T:System.Diagnostics.Process" />.

- или -

Член <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> свойства <see cref="P:System.Diagnostics.Process.StartInfo" /> имеет значение <see langword="true" /> , тогда как <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />или <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> имеет значение <see langword="true" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Произошла ошибка при открытии связанного файла.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект процесса уже удален.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Метод не поддерживается в операционных системах без поддержки оболочки, таких как Nano Server (только в .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (System.Diagnostics.ProcessStartInfo startInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(class System.Diagnostics.ProcessStartInfo startInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (startInfo As ProcessStartInfo) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::Diagnostics::ProcessStartInfo ^ startInfo);" />
      <MemberSignature Language="F#" Value="static member Start : System.Diagnostics.ProcessStartInfo -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start startInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startInfo" Type="System.Diagnostics.ProcessStartInfo" />
      </Parameters>
      <Docs>
        <param name="startInfo">Объект <see cref="T:System.Diagnostics.ProcessStartInfo" />, который содержит информацию, использующуюся для запуска процесса, включая имя файла и все аргументы командной строки.</param>
        <summary>Запускает ресурс процесса, определенный параметром, содержащим стартовую информацию процесса (например, имя файла запускаемого процесса), и связывает ресурс с новым компонентом <see cref="T:System.Diagnostics.Process" />.</summary>
        <returns>Новый процесс <see cref="T:System.Diagnostics.Process" />, связанный с ресурсом процесса, или <see langword="null" />, если ресурс процесса не запущен. Обратите внимание, что новый процесс, запущенный наряду с уже выполняющимися экземплярами того же процесса, будет независимым от других. Кроме того, метод Start может вернуть ненулевой тип Process, свойство <see cref="P:System.Diagnostics.Process.HasExited" /> которого равно <see langword="true" />. В этом случае запущенный процесс может активировать существующий экземпляр самого себя, а затем завершить работу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для запуска ресурса процесса путем указания экземпляра <xref:System.Diagnostics.ProcessStartInfo>. Перегрузка связывает ресурс с новым объектом <xref:System.Diagnostics.Process>.  
  
> [!NOTE]
>  Если адрес исполняемого файла для запуска является URL-адресом, процесс не запускается и возвращается `null`.  
  
 Эта перегрузка позволяет запустить процесс без предварительного создания нового <xref:System.Diagnostics.Process> экземпляра. Использование этой перегрузки с параметром <xref:System.Diagnostics.ProcessStartInfo> является альтернативой явным шагам при создании нового экземпляра <xref:System.Diagnostics.Process>, установке его свойств <xref:System.Diagnostics.Process.StartInfo%2A> и вызове <xref:System.Diagnostics.Process.Start%2A> для экземпляра <xref:System.Diagnostics.Process>.  
  
 Использование экземпляра <xref:System.Diagnostics.ProcessStartInfo> в качестве параметра позволяет вызвать <xref:System.Diagnostics.Process.Start%2A> с наибольшим контролем над тем, что передается в вызов для запуска процесса. Если необходимо передать только имя файла или имя файла и аргументы, не нужно создавать новый экземпляр <xref:System.Diagnostics.ProcessStartInfo>, хотя это параметр. Единственным свойством <xref:System.Diagnostics.Process.StartInfo%2A?displayProperty=nameWithType>, которое необходимо задать, является свойство <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>. Свойству <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> не требуется представлять исполняемый файл. Это может быть любой тип файлов, для которого расширение было связано с приложением, установленным в системе. Например, свойство <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> может иметь расширение txt, если у вас есть связанные текстовые файлы с редактором, например Блокнот, или иметь расширение DOC, если у вас есть связанные DOC-файлы с инструментом обработки текста, например Microsoft Word.  
  
 Приложение ClickOnce можно запустить, указав расположение (например, веб-адрес), из которого изначально было установлено приложение. Не запускайте приложение ClickOnce, указав его расположение на жестком диске.  
  
 Если заданы свойства <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> и <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> экземпляра <xref:System.Diagnostics.Process.StartInfo%2A>, вызывается неуправляемая функция `CreateProcessWithLogonW`, которая запускает процесс в новом окне, даже если значение свойства <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A?displayProperty=nameWithType> равно `true` или значение свойства <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A?displayProperty=nameWithType> <xref:System.Diagnostics.ProcessWindowStyle.Hidden?displayProperty=nameWithType>. Если свойство <xref:System.Diagnostics.ProcessStartInfo.Domain%2A?displayProperty=nameWithType> имеет значение `null`, свойство <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> должно иметь формат UPN,@*пользователя* *DNS_domain_name*.   
  
 В отличие от других перегрузок, перегрузка <xref:System.Diagnostics.Process.Start%2A>, не имеющая параметров, не является `static` членом. Используйте эту перегрузку, если вы уже создали экземпляр <xref:System.Diagnostics.Process>, указали начальную информацию (включая имя файла) и хотите запустить ресурс процесса и связать его с существующим экземпляром <xref:System.Diagnostics.Process>. Используйте один из `static` перегрузок, если нужно создать новый <xref:System.Diagnostics.Process> компонент, а не запускать процесс для существующего компонента. Как эта перегрузка, так и перегрузка, не имеющая параметров, позволяют указать начальную информацию для ресурса процесса с помощью экземпляра <xref:System.Diagnostics.ProcessStartInfo>.  
  
 Если в системе объявлен заключенный в кавычки путь в переменной path, при запуске любого процесса из этого расположения необходимо указание полного пути. В противном случае система не найдет этот путь. Например, если в переменной path нет пути `c:\mypath` и он добавляется к ней с использованием кавычек (`path = %path%;"c:\mypath"`), при запуске любого процесса из `c:\mypath` необходимо полностью указывать путь к файлу.  
  
> [!NOTE]
>  Код веб-страницы и серверного элемента управления ASP.NET выполняется в контексте рабочего процесса ASP.NET на веб-сервере.  При использовании метода <xref:System.Diagnostics.Process.Start%2A> на веб-странице ASP.NET или серверном элементе управления новый процесс выполняется на веб-сервере с ограниченными разрешениями. Процесс не запускается в том же контексте, что и браузер клиента, и не имеет доступа к рабочему столу пользователя.  
  
 При использовании <xref:System.Diagnostics.Process.Start%2A> для запуска процесса может потребоваться закрыть его или вы рискуете потерять системные ресурсы. Закройте процессы с помощью <xref:System.Diagnostics.Process.CloseMainWindow%2A> или <xref:System.Diagnostics.Process.Kill%2A>. Вы можете проверить, был ли уже закрыт процесс, используя его свойство <xref:System.Diagnostics.Process.HasExited%2A>.  
  
 Примечание о состояниях апартамента в управляемых потоках необходимо здесь. Если <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> `true` в параметре `startInfo`, убедитесь, что для приложения задана потоковая модель, установив атрибут `[STAThread]` в методе `main()`. В противном случае управляемый поток может находиться в `unknown` состоянии или поставляться в `MTA`ном состоянии, второе из которых конфликтует с <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> `true`. Для некоторых методов требуется, чтобы состояние апартамента не было `unknown`. Если состояние не задано явно, то, когда приложение встречает такой метод, по умолчанию используется `MTA`, и после установки состояние апартамента не может быть изменено. Однако `MTA` вызывает исключение, если оболочка операционной системы управляет потоком.  
  
   
  
## Examples  
 Следующий пример сначала порождает экземпляр Internet Explorer и отображает содержимое папки «Избранное» в браузере. Затем он запускает некоторые другие экземпляры Internet Explorer и отображает некоторые определенные страницы или сайты. Наконец, запускается Internet Explorer с окном, которое свернется при переходе на конкретный сайт.  
  
 Дополнительные примеры других способов использования этого метода см. в отдельных свойствах класса <xref:System.Diagnostics.ProcessStartInfo>.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Имя файла не было указано в свойстве <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> параметра <paramref name="startInfo" />.  
  
- или - 
Свойство <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> параметра<paramref name="startInfo" /> имеет значение <see langword="true" /> и <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> или свойство <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> также имеет значение <see langword="true" />.  
  
- или - 
Свойство <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> параметра <paramref name="startInfo" /> имеет значение <see langword="true" />, и свойство <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> не равно <see langword="null" /> или не является пустым или свойство <see cref="P:System.Diagnostics.ProcessStartInfo.Password" /> не равно <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="startInfo" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект процесса уже удален.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Возникла ошибка при открытии связанного файла.  

- или - 
Файл, указанный в свойстве <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> параметра <paramref name="startInfo" />, не найден.
          
- или - 
Сумма длины аргументов и длины полного пути к процессу превышает 2080. Сообщение об ошибке, связанной с этим исключением, может иметь следующую формулировку: "Область данных, переданная системному вызову, слишком мала". или "Отказано в доступе".</exception>
        <exception cref="T:System.PlatformNotSupportedException">Метод не поддерживается в операционных системах без поддержки оболочки, таких как Nano Server (только в .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member Start : string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Имя документа или файла приложения для запуска в процессе.</param>
        <summary>Запускает ресурс процесса путем указания имени документа или файла приложения и связывает ресурс с новым компонентом <see cref="T:System.Diagnostics.Process" />.</summary>
        <returns>Новый процесс <see cref="T:System.Diagnostics.Process" />, связанный с ресурсом процесса, или <see langword="null" />, если ресурс процесса не запущен. Обратите внимание, что новый процесс, запущенный наряду с уже выполняющимися экземплярами того же процесса, будет независимым от других. Кроме того, метод Start может вернуть ненулевой тип Process, свойство <see cref="P:System.Diagnostics.Process.HasExited" /> которого равно <see langword="true" />. В этом случае запущенный процесс может активировать существующий экземпляр самого себя, а затем завершить работу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для запуска ресурса процесса путем указания его имени файла. Перегрузка связывает ресурс с новым объектом <xref:System.Diagnostics.Process>.  
  
> [!NOTE]
>  Если адрес исполняемого файла для запуска является URL-адресом, процесс не запускается и возвращается `null`.  
  
 Эта перегрузка позволяет запустить процесс без предварительного создания нового <xref:System.Diagnostics.Process> экземпляра. Перегрузка является альтернативой явным шагам создания нового экземпляра <xref:System.Diagnostics.Process>, установки <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> элемента свойства <xref:System.Diagnostics.Process.StartInfo%2A> и вызова <xref:System.Diagnostics.Process.Start%2A> для экземпляра <xref:System.Diagnostics.Process>.  
  
 Приложение ClickOnce можно запустить, присвоив параметру `fileName` расположение (например, веб-адрес), из которого изначально было установлено приложение. Не запускайте приложение ClickOnce, указав его расположение на жестком диске.  
  
 Запуск процесса путем указания имени файла аналогичен вводу сведений в диалоговом окне `Run` меню `Start` Windows. Таким образом, имя файла не должно представлять исполняемый файл. Это может быть любой тип файлов, для которого расширение было связано с приложением, установленным в системе. Например, имя файла может иметь расширение txt, если у вас есть связанные текстовые файлы с редактором, например Блокнот, или файл. doc, если у вас есть связанные DOC-файлы с инструментом обработки текста, например Microsoft Word. Аналогично, так же, как диалоговое окно `Run` может принимать имя исполняемого файла с расширением exe или без него, расширение EXE является необязательным в параметре `fileName`. Например, можно задать для параметра `fileName` значение «Notepad. exe» или «Notepad».  
  
 Эта перегрузка не позволяет использовать аргументы командной строки для процесса. Если необходимо указать один или несколько аргументов командной строки для процесса, используйте перегрузки <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType> или <xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=nameWithType>.  
  
 В отличие от других перегрузок, перегрузка <xref:System.Diagnostics.Process.Start%2A>, не имеющая параметров, не является `static` членом. Используйте эту перегрузку, если вы уже создали экземпляр <xref:System.Diagnostics.Process>, указали начальную информацию (включая имя файла) и хотите запустить ресурс процесса и связать его с существующим экземпляром <xref:System.Diagnostics.Process>. Используйте один из `static` перегрузок, если нужно создать новый <xref:System.Diagnostics.Process> компонент, а не запускать процесс для существующего компонента. Как эта перегрузка, так и перегрузка, не имеющая параметров, позволяют указать имя файла запускаемого ресурса процесса.  
  
 Если в системе объявлен заключенный в кавычки путь в переменной path, при запуске любого процесса из этого расположения необходимо указание полного пути. В противном случае система не найдет этот путь. Например, если в переменной path нет пути `c:\mypath` и он добавляется к ней с использованием кавычек (`path = %path%;"c:\mypath"`), при запуске любого процесса из `c:\mypath` необходимо полностью указывать путь к файлу.  
  
> [!NOTE]
>  Код веб-страницы и серверного элемента управления ASP.NET выполняется в контексте рабочего процесса ASP.NET на веб-сервере.  При использовании метода <xref:System.Diagnostics.Process.Start%2A> на веб-странице ASP.NET или серверном элементе управления новый процесс выполняется на веб-сервере с ограниченными разрешениями. Процесс не запускается в том же контексте, что и браузер клиента, и не имеет доступа к рабочему столу пользователя.  
  
 При использовании <xref:System.Diagnostics.Process.Start%2A> для запуска процесса может потребоваться закрыть его или вы рискуете потерять системные ресурсы. Закройте процессы с помощью <xref:System.Diagnostics.Process.CloseMainWindow%2A> или <xref:System.Diagnostics.Process.Kill%2A>. Вы можете проверить, был ли уже закрыт процесс, используя его свойство <xref:System.Diagnostics.Process.HasExited%2A>.  
  
 Примечание о состояниях апартамента в управляемых потоках необходимо здесь. Если <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> `true` в свойстве <xref:System.Diagnostics.Process.StartInfo%2A> компонента Process, убедитесь, что для приложения установлен потоковая модель, установив атрибут `[STAThread]` в методе `main()`. В противном случае управляемый поток может находиться в `unknown` состоянии или поставляться в `MTA`ном состоянии, второе из которых конфликтует с <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> `true`. Для некоторых методов требуется, чтобы состояние апартамента не было `unknown`. Если состояние не задано явно, то, когда приложение встречает такой метод, по умолчанию используется `MTA`, и после установки состояние апартамента не может быть изменено. Однако `MTA` вызывает исключение, если оболочка операционной системы управляет потоком.  
  
   
  
## Examples  
 Следующий пример сначала порождает экземпляр Internet Explorer и отображает содержимое папки «Избранное» в браузере. Затем он запускает некоторые другие экземпляры Internet Explorer и отображает некоторые определенные страницы или сайты. Наконец, запускается Internet Explorer с окном, которое свернется при переходе на конкретный сайт.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Возникла ошибка при открытии связанного файла.

- или -

Не удалось найти файл, указанный в <paramref name="fileName" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект процесса уже удален.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Переменная среды PATH содержит строку с кавычками.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Start : string * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Имя файла приложения для запуска в процессе.</param>
        <param name="arguments">Аргументы командной строки для передачи при запуске процесса.</param>
        <summary>Запускает ресурс процесса путем указания имени приложения и набора аргументов командной строки и связывает ресурс с новым компонентом <see cref="T:System.Diagnostics.Process" />.</summary>
        <returns>Новый процесс <see cref="T:System.Diagnostics.Process" />, связанный с ресурсом процесса, или <see langword="null" />, если ресурс процесса не запущен. Обратите внимание, что новый процесс, запущенный наряду с уже выполняющимися экземплярами того же процесса, будет независимым от других. Кроме того, метод Start может вернуть ненулевой тип Process, свойство <see cref="P:System.Diagnostics.Process.HasExited" /> которого равно <see langword="true" />. В этом случае запущенный процесс может активировать существующий экземпляр самого себя, а затем завершить работу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для запуска ресурса процесса путем указания его имени файла и аргументов командной строки. Перегрузка связывает ресурс с новым объектом <xref:System.Diagnostics.Process>.  
  
> [!NOTE]
>  Если адрес исполняемого файла для запуска является URL-адресом, процесс не запускается и возвращается `null`.  
  
 Эта перегрузка позволяет запустить процесс без предварительного создания нового <xref:System.Diagnostics.Process> экземпляра. Перегрузка является альтернативой явным шагам создания нового экземпляра <xref:System.Diagnostics.Process>, установки <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> и <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> элементов свойства <xref:System.Diagnostics.Process.StartInfo%2A>, а также вызова <xref:System.Diagnostics.Process.Start%2A> для экземпляра <xref:System.Diagnostics.Process>.  
  
 Запуск процесса путем указания имени файла и аргументов аналогичен вводу имени файла и аргументов командной строки в диалоговом окне `Run` меню `Start` Windows. Таким образом, имя файла не должно представлять исполняемый файл. Это может быть любой тип файлов, для которого расширение было связано с приложением, установленным в системе. Например, имя файла может иметь расширение txt, если у вас есть связанные текстовые файлы с редактором, например Блокнот, или файл. doc, если у вас есть связанные DOC-файлы с инструментом обработки текста, например Microsoft Word. Аналогично, так же, как диалоговое окно `Run` может принимать имя исполняемого файла с расширением exe или без него, расширение EXE является необязательным в параметре `fileName`. Например, можно задать для параметра `fileName` значение «Notepad. exe» или «Notepad». Если параметр `fileName` представляет исполняемый файл, параметр `arguments` может представлять файл для работы, например текстовый файл в `Notepad.exe myfile.txt`. Если параметр `fileName` представляет файл команды (cmd), параметр `arguments` должен включать аргумент "`/c`" или "`/k`", чтобы указать, что окно команд завершает работу или остается после завершения.  
  
 В отличие от других перегрузок, перегрузка <xref:System.Diagnostics.Process.Start%2A>, не имеющая параметров, не является `static` членом. Используйте эту перегрузку, если вы уже создали экземпляр <xref:System.Diagnostics.Process>, указали начальную информацию (включая имя файла) и хотите запустить ресурс процесса и связать его с существующим экземпляром <xref:System.Diagnostics.Process>. Используйте один из `static` перегрузок, если нужно создать новый <xref:System.Diagnostics.Process> компонент, а не запускать процесс для существующего компонента. Как эта перегрузка, так и перегрузка, не имеющая параметров, позволяют указать имя файла запускаемого ресурса процесса и аргументы командной строки для передачи.  
  
 Если в системе объявлен заключенный в кавычки путь в переменной path, при запуске любого процесса из этого расположения необходимо указание полного пути. В противном случае система не найдет этот путь. Например, если в переменной path нет пути `c:\mypath` и он добавляется к ней с использованием кавычек (`path = %path%;"c:\mypath"`), при запуске любого процесса из `c:\mypath` необходимо полностью указывать путь к файлу.  
  
> [!NOTE]
>  Код веб-страницы и серверного элемента управления ASP.NET выполняется в контексте рабочего процесса ASP.NET на веб-сервере.  При использовании метода <xref:System.Diagnostics.Process.Start%2A> на веб-странице ASP.NET или серверном элементе управления новый процесс выполняется на веб-сервере с ограниченными разрешениями. Процесс не запускается в том же контексте, что и браузер клиента, и не имеет доступа к рабочему столу пользователя.  
  
 При использовании <xref:System.Diagnostics.Process.Start%2A> для запуска процесса может потребоваться закрыть его или вы рискуете потерять системные ресурсы. Закройте процессы с помощью <xref:System.Diagnostics.Process.CloseMainWindow%2A> или <xref:System.Diagnostics.Process.Kill%2A>. Вы можете проверить, был ли уже закрыт процесс, используя его свойство <xref:System.Diagnostics.Process.HasExited%2A>. 
  
 Примечание о состояниях апартамента в управляемых потоках необходимо здесь. Если <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> `true` в свойстве <xref:System.Diagnostics.Process.StartInfo%2A> компонента Process, убедитесь, что для приложения установлен потоковая модель, установив атрибут `[STAThread]` в методе `main()`. В противном случае управляемый поток может находиться в `unknown` состоянии или поставляться в `MTA`ном состоянии, второе из которых конфликтует с <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> `true`. Для некоторых методов требуется, чтобы состояние апартамента не было `unknown`. Если состояние не задано явно, то, когда приложение встречает такой метод, по умолчанию используется `MTA`, и после установки состояние апартамента не может быть изменено. Однако `MTA` вызывает исключение, если оболочка операционной системы управляет потоком.  
  
   
  
## Examples  
 Следующий пример сначала порождает экземпляр Internet Explorer и отображает содержимое папки «Избранное» в браузере. Затем он запускает некоторые другие экземпляры Internet Explorer и отображает некоторые определенные страницы или сайты. Наконец, запускается Internet Explorer с окном, которое свернется при переходе на конкретный сайт.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Значение параметра <paramref name="fileName" /> или параметра <paramref name="arguments" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Возникла ошибка при открытии связанного файла.  

- или -

Не удалось найти файл, указанный в <paramref name="fileName" />.
  
- или - 
Сумма длины аргументов и длины полного пути к процессу превышает 2080. Сообщение об ошибке, связанной с этим исключением, может иметь следующую формулировку: "Область данных, переданная системному вызову, слишком мала". или "Отказано в доступе".</exception>
        <exception cref="T:System.ObjectDisposedException">Объект процесса уже удален.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Переменная среды PATH содержит строку с кавычками.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="userName" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="password" Type="System.Security.SecureString" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="domain" Type="System.String" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">Имя файла приложения для запуска в процессе.</param>
        <param name="userName">Имя пользователя, используемое при запуске процесса.</param>
        <param name="password">Объект <see cref="T:System.Security.SecureString" />, содержащий пароль для использования при запуске процесса.</param>
        <param name="domain">Домен, используемый при запуске процесса.</param>
        <summary>Запускает ресурс процесса путем указания имени приложения, имени пользователя, пароля и домена и связывает ресурс с новым компонентом <see cref="T:System.Diagnostics.Process" />.</summary>
        <returns>Новый процесс <see cref="T:System.Diagnostics.Process" />, связанный с ресурсом процесса, или <see langword="null" />, если ресурс процесса не запущен. Обратите внимание, что новый процесс, запущенный наряду с уже выполняющимися экземплярами того же процесса, будет независимым от других. Кроме того, метод Start может вернуть ненулевой тип Process, свойство <see cref="P:System.Diagnostics.Process.HasExited" /> которого равно <see langword="true" />. В этом случае запущенный процесс может активировать существующий экземпляр самого себя, а затем завершить работу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для создания нового процесса и его основного потока путем указания имени файла, имени пользователя, пароля и домена. Затем новый процесс запускает указанный исполняемый файл в контексте безопасности указанных учетных данных (пользователя, домена и пароля).  
  
> [!NOTE]
>  Если исполняемый файл находится на удаленном диске, необходимо задать общую сетевую папку, используя универсальный код ресурса (URI), а не букву связанного диска.  
  
> [!NOTE]
>  Если адрес исполняемого файла для запуска является URL-адресом, процесс не запускается и возвращается `null`.  
  
 Эта перегрузка позволяет запустить процесс без предварительного создания нового <xref:System.Diagnostics.Process> экземпляра. Перегрузка является альтернативой явным шагам создания нового экземпляра <xref:System.Diagnostics.Process>, установки свойств <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>и <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> свойства <xref:System.Diagnostics.Process.StartInfo%2A>, а также вызова <xref:System.Diagnostics.Process.Start%2A> для экземпляра <xref:System.Diagnostics.Process>.  
  
 Аналогично, так же, как диалоговое окно **Run (запуск** ) может принимать имя исполняемого файла с расширением exe или без него, расширение EXE является необязательным в параметре `fileName`. Например, можно задать для параметра `fileName` значение «Notepad. exe» или «Notepad». Если параметр `fileName` представляет исполняемый файл, параметр `arguments` может представлять файл для работы, например текстовый файл в `Notepad.exe myfile.txt`.  
  
> [!NOTE]
>  Имя файла должно представлять исполняемый файл в <xref:System.Diagnostics.Process.Start%2A> перегрузок, имеющих параметры `userName`, `password`и `domain`.  
  
 При использовании <xref:System.Diagnostics.Process.Start%2A> для запуска процесса может потребоваться закрыть его или вы рискуете потерять системные ресурсы. Закройте процессы с помощью <xref:System.Diagnostics.Process.CloseMainWindow%2A> или <xref:System.Diagnostics.Process.Kill%2A>. Вы можете проверить, был ли уже закрыт процесс, используя его свойство <xref:System.Diagnostics.Process.HasExited%2A>. 
  
   
  
## Examples  
 В следующем примере кода показано использование этой перегрузки для запуска исполняемого файла, а также демонстрируется создание <xref:System.ComponentModel.Win32Exception> при попытке запустить приложение, связанное с неисполняемым файлом.  
  
 [!code-csharp[System.Diagnostics.Process.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Не указано имя файла.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Произошла ошибка при открытии связанного файла.

- или -

Не удалось найти файл, указанный в <paramref name="fileName" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект процесса уже удален.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Этот элемент не поддерживается в Linux или macOS (только в .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="arguments" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="userName" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="password" Type="System.Security.SecureString" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="domain" Type="System.String" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">Имя файла приложения для запуска в процессе.</param>
        <param name="arguments">Аргументы командной строки для передачи при запуске процесса.</param>
        <param name="userName">Имя пользователя, используемое при запуске процесса.</param>
        <param name="password">Объект <see cref="T:System.Security.SecureString" />, содержащий пароль для использования при запуске процесса.</param>
        <param name="domain">Домен, используемый при запуске процесса.</param>
        <summary>Запускает ресурс процесса путем указания имени приложения, набора аргументов командной строки, имени пользователя, пароля и домена и связывает ресурс с новым компонентом <see cref="T:System.Diagnostics.Process" />.</summary>
        <returns>Новый процесс <see cref="T:System.Diagnostics.Process" />, связанный с ресурсом процесса, или <see langword="null" />, если ресурс процесса не запущен. Обратите внимание, что новый процесс, запущенный наряду с уже выполняющимися экземплярами того же процесса, будет независимым от других. Кроме того, метод Start может вернуть ненулевой тип Process, свойство <see cref="P:System.Diagnostics.Process.HasExited" /> которого равно <see langword="true" />. В этом случае запущенный процесс может активировать существующий экземпляр самого себя, а затем завершить работу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для создания нового процесса и его основного потока путем указания имени файла, аргументов командной строки, имени пользователя, пароля и домена. Затем новый процесс запускает указанный исполняемый файл в контексте безопасности указанных учетных данных (пользователя, домена и пароля).  
  
> [!NOTE]
>  Если исполняемый файл находится на удаленном диске, необходимо задать общую сетевую папку, используя универсальный код ресурса (URI), а не букву связанного диска.  
  
> [!NOTE]
>  Если адрес исполняемого файла для запуска является URL-адресом, процесс не запускается и возвращается `null`.  
  
 Эта перегрузка позволяет запустить процесс без предварительного создания нового <xref:System.Diagnostics.Process> экземпляра. Перегрузка является альтернативой явным шагам создания нового экземпляра <xref:System.Diagnostics.Process>, установки свойств <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>и <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> свойства <xref:System.Diagnostics.Process.StartInfo%2A>, а также вызова <xref:System.Diagnostics.Process.Start%2A> для экземпляра <xref:System.Diagnostics.Process>.  
  
 Аналогично, так же, как диалоговое окно **Run (запуск** ) может принимать имя исполняемого файла с расширением exe или без него, расширение EXE является необязательным в параметре `fileName`. Например, можно задать для параметра `fileName` значение «Notepad. exe» или «Notepad». Если параметр `fileName` представляет исполняемый файл, параметр `arguments` может представлять файл для работы, например текстовый файл в `Notepad.exe myfile.txt`.  
  
> [!NOTE]
>  Имя файла должно представлять исполняемый файл в <xref:System.Diagnostics.Process.Start%2A> перегрузок, имеющих параметры `userName`, `password`и `domain`.  
  
 При использовании <xref:System.Diagnostics.Process.Start%2A> для запуска процесса может потребоваться закрыть его или вы рискуете потерять системные ресурсы. Закройте процессы с помощью <xref:System.Diagnostics.Process.CloseMainWindow%2A> или <xref:System.Diagnostics.Process.Kill%2A>. Вы можете проверить, был ли уже закрыт процесс, используя его свойство <xref:System.Diagnostics.Process.HasExited%2A>. 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Не указано имя файла.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Возникла ошибка при открытии связанного файла.  

- или -

Не удалось найти файл, указанный в <paramref name="fileName" />.
  
- или - 
Сумма длины аргументов и длины полного пути к соответствующему файлу превышает 2080. Сообщение об ошибке, связанной с этим исключением, может иметь следующую формулировку: "Область данных, переданная системному вызову, слишком мала". или "Отказано в доступе".</exception>
        <exception cref="T:System.ObjectDisposedException">Объект процесса уже удален.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Этот элемент не поддерживается в Linux или macOS (только в .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="StartInfo">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessStartInfo StartInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessStartInfo StartInfo" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property StartInfo As ProcessStartInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessStartInfo ^ StartInfo { System::Diagnostics::ProcessStartInfo ^ get(); void set(System::Diagnostics::ProcessStartInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StartInfo : System.Diagnostics.ProcessStartInfo with get, set" Usage="System.Diagnostics.Process.StartInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Specifies information used to start a process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStartInfo")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessStartInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает свойства для передачи их методу <see cref="M:System.Diagnostics.Process.Start" /> объекта <see cref="T:System.Diagnostics.Process" />.</summary>
        <value>Класс <see cref="T:System.Diagnostics.ProcessStartInfo" />, который представляет данные для запуска процесса. Эти аргументы включают имя исполняемого файла или документа, использованного для запуска процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StartInfo%2A> представляет набор параметров, используемых для запуска процесса. При вызове <xref:System.Diagnostics.Process.Start%2A> используется <xref:System.Diagnostics.Process.StartInfo%2A>, чтобы указать запускаемый процесс. Единственным необходимым <xref:System.Diagnostics.Process.StartInfo%2A> элементом, который необходимо задать, является свойство <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>. Запуск процесса путем указания свойства <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> аналогичен вводу сведений в диалоговом окне **Запуск** меню " **Пуск** " Windows. Таким образом, свойству <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> не требуется представлять исполняемый файл. Это может быть любой тип файлов, для которого расширение было связано с приложением, установленным в системе. Например, <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> может иметь расширение txt, если у вас есть связанные текстовые файлы с редактором, например Блокнот, или файл. doc, если у вас есть связанные DOC-файлы с инструментом обработки текста, например Microsoft Word. Аналогично, так же, как диалоговое окно **Run (запуск** ) может принимать имя исполняемого файла с расширением exe или без него, расширение EXE является необязательным в элементе <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>. Например, можно задать для свойства <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> значение «Notepad. exe» или «Notepad».  
  
 Приложение ClickOnce можно запустить, задав для свойства <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> расположение (например, веб-адрес), из которого изначально было установлено приложение. Не запускайте приложение ClickOnce, указав его расположение на жестком диске.  
  
 Если имя файла включает в себя неисполняемый файл, например DOC-файл, можно включить команду, указывающую, какое действие следует выполнить с файлом. Например, можно задать для <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> значение «Print» для файла, который заканчивается расширением doc. Имя файла, указанное в свойстве <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, не обязательно должно иметь расширение, если вручную ввести значение для свойства <xref:System.Diagnostics.ProcessStartInfo.Verb%2A>. Однако если для определения доступных команд используется свойство <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>, необходимо включить расширение.  
  
 Можно изменить параметры, указанные в свойстве <xref:System.Diagnostics.Process.StartInfo%2A>, до момента вызова метода <xref:System.Diagnostics.Process.Start%2A> в процессе. После запуска процесса изменение значений <xref:System.Diagnostics.Process.StartInfo%2A> не влияет на связанный процесс и не перезапускает его. При вызове метода <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29> с установленными свойствами <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> и <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> вызывается неуправляемая функция `CreateProcessWithLogonW`, которая запускает процесс в новом окне, даже если значение свойства <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> равно `true` или значение свойства <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> <xref:System.Diagnostics.ProcessWindowStyle.Hidden>.  
  
 Доступ к свойству <xref:System.Diagnostics.Process.StartInfo%2A> должен осуществляться только для объекта <xref:System.Diagnostics.Process>, возвращаемого методом <xref:System.Diagnostics.Process.Start%2A>. Например, не следует обращаться к свойству <xref:System.Diagnostics.Process.StartInfo%2A> объекта <xref:System.Diagnostics.Process>, возвращаемого <xref:System.Diagnostics.Process.GetProcesses%2A>. В противном случае в .NET Core свойство <xref:System.Diagnostics.Process.StartInfo%2A> выдаст <xref:System.InvalidOperationException> и на .NET Framework он вернет фиктивный объект <xref:System.Diagnostics.ProcessStartInfo>.
  
 При запуске процесса имя файла — это файл, который заполняет свойство (только для чтения) <xref:System.Diagnostics.Process.MainModule%2A>. Если вы хотите получить исполняемый файл, связанный с процессом, после запуска процесса, используйте свойство <xref:System.Diagnostics.Process.MainModule%2A>. Если необходимо задать исполняемый файл экземпляра <xref:System.Diagnostics.Process>, для которого не запущен связанный процесс, используйте элемент <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> свойства <xref:System.Diagnostics.Process.StartInfo%2A>. Поскольку члены свойства <xref:System.Diagnostics.Process.StartInfo%2A> являются аргументами, которые передаются методу <xref:System.Diagnostics.Process.Start%2A> процесса, изменение свойства <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> после запуска связанного процесса не приведет к сбросу свойства <xref:System.Diagnostics.Process.MainModule%2A>. Эти свойства используются только для инициализации связанного процесса.  
  
   
  
## Examples  
 Следующий пример заполняет <xref:System.Diagnostics.Process.StartInfo%2A> файлом для выполнения, действием, выполненным над ним, и должно ли оно отображать пользовательский интерфейс. Дополнительные примеры см. на страницах справочника по свойствам класса <xref:System.Diagnostics.ProcessStartInfo>.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение, указывающее <see cref="P:System.Diagnostics.Process.StartInfo" />, равняется <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Diagnostics.Process.Start" /> не использовался для запуска процесса.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime StartTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.StartTime : DateTime" Usage="System.Diagnostics.Process.StartTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The time at which the process was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStartTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает время запуска связанного процесса.</summary>
        <value>Объект, показывающий время запуска процесса. Если процесс не выполняется, возникает исключение.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.StartTime" /> процесса, выполняющегося на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <exception cref="T:System.InvalidOperationException">Процесс завершен.  
  
 - или -  
  
 Процесс не был запущен.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">В вызове функции Windows произошла ошибка.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Diagnostics.Process.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The object used to marshal the event handler calls issued as a result of a Process exit.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessSynchronizingObject")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает объект, используемый для маршалинга вызовов обработчика событий, происходящих в результате события завершения процесса.</summary>
        <value>Объект <see cref="T:System.ComponentModel.ISynchronizeInvoke" />, используемый для маршалинга вызовов обработчика событий, возникающих в результате события <see cref="E:System.Diagnostics.Process.Exited" /> в процессе.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> `null`, методы, обрабатывающие событие <xref:System.Diagnostics.Process.Exited>, вызываются в потоке из пула системных потоков. Дополнительные сведения о пулах системных потоков см. в разделе <xref:System.Threading.ThreadPool>.  
  
 Если событие <xref:System.Diagnostics.Process.Exited> обрабатывается компонентом Visual Windows Forms, например <xref:System.Windows.Forms.Button>, доступ к компоненту через пул системных потоков может не работать или может привести к исключению. Это следует избегать, если присвоить <xref:System.Diagnostics.Process.SynchronizingObject%2A> компоненту Windows Forms, в результате чего методы, обрабатывающие событие <xref:System.Diagnostics.Process.Exited>, вызываются в том же потоке, в котором был создан компонент.  
  
 Если <xref:System.Diagnostics.Process> используется в [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] в конструкторе Windows Forms, <xref:System.Diagnostics.Process.SynchronizingObject%2A> автоматически устанавливается в элемент управления, содержащий <xref:System.Diagnostics.Process>. Например, при помещении <xref:System.Diagnostics.Process> в конструктор для `Form1` (который наследуется от <xref:System.Windows.Forms.Form>) свойству <xref:System.Diagnostics.Process.SynchronizingObject%2A> <xref:System.Diagnostics.Process> присваивается значение экземпляра `Form1`:  
  
 [!code-cpp[Process_SynchronizingObject#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/remarks.cpp#2)]
 [!code-csharp[Process_SynchronizingObject#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/remarks.cs#2)]
 [!code-vb[Process_SynchronizingObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/remarks.vb#2)]  
  
 Как правило, это свойство задается при помещении компонента в элемент управления или форму, поскольку эти компоненты привязаны к определенному потоку.  
  
   
  
## Examples  
 [!code-cpp[Process_SynchronizingObject#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/process_synchronizingobject.cpp#1)]
 [!code-csharp[Process_SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/process_synchronizingobject.cs#1)]
 [!code-vb[Process_SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/process_synchronizingobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName="Threads">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessThreadCollection Threads { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessThreadCollection Threads" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Threads" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Threads As ProcessThreadCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessThreadCollection ^ Threads { System::Diagnostics::ProcessThreadCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Threads : System.Diagnostics.ProcessThreadCollection" Usage="System.Diagnostics.Process.Threads" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of threads of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessThreads")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessThreadCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает множество потоков, выполняющихся в связанном процессе.</summary>
        <value>Массив объектов типа <see cref="T:System.Diagnostics.ProcessThread" />, представляющий потоки операционной системы, которые в настоящий момент выполняются в связанном процессе.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поток выполняет код в процессе. Каждый процесс запускается с одним потоком, основным потоком. Любой поток может создавать дополнительные потоки. Потоки внутри процесса совместно используют адресное пространство процесса.  
  
 Используйте <xref:System.Diagnostics.ProcessThread>, чтобы получить все потоки, связанные с текущим процессом. Первичный поток не обязательно должен иметь нулевой индекс в массиве.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">Процесс не имеет <see cref="P:System.Diagnostics.Process.Id" />, или нет процесса, связанного с экземпляром <see cref="T:System.Diagnostics.Process" />.  
  
- или - 
Связанный процесс завершился.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="T:System.Diagnostics.ProcessThread" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="process.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Преобразует имя процесса в строку, объединенную с родительским типом компонента, если это применимо.</summary>
        <returns>Свойство <see cref="P:System.Diagnostics.Process.ProcessName" />, объединенное с возвращаемым значением метода <see cref="M:System.Object.ToString" /> базового компонента.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем в примере извлекаются и отображаются различные свойства связанного процесса. В примере обнаруживается, когда процесс завершается, и отображается код завершения процесса.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.TotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.TotalProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.TotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process has used.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessTotalProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает полное время процессора для этого процесса.</summary>
        <value>Объект <see cref="T:System.TimeSpan" />, указывающий количество времени, потраченного процессом на загрузку ЦП. Это значение является суммой значений свойств <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> и <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем в примере извлекаются и отображаются различные свойства связанного процесса. В примере обнаруживается, когда процесс завершается, и отображается код завершения процесса.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.TotalProcessorTime" /> процесса, выполняющегося на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.UserProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan UserProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.UserProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.UserProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent outside the operating system core.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessUserProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает пользовательское время процессора для этого процесса.</summary>
        <value>Класс <see cref="T:System.TimeSpan" />, показывающий количество времени, которое связанный процесс потратил на выполнение кода внутри приложения (не внутри ядра операционной системы).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем в примере извлекаются и отображаются различные свойства связанного процесса. В примере обнаруживается, когда процесс завершается, и отображается код завершения процесса.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> процесса, выполняющегося на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize">
      <MemberSignature Language="C#" Value="public int VirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int VirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize : int" Usage="System.Diagnostics.Process.VirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use VirtualMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.VirtualMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessVirtualMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.VirtualMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.VirtualMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает размер виртуальной памяти процесса (в байтах).</summary>
        <value>Объем виртуальной памяти в байтах, запрошенной связанным процессом.</value>
        <remarks>To be added.</remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long VirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 VirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long VirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объем виртуальной памяти в байтах, выделенной для связанного процесса.</summary>
        <value>Возвращает количество виртуальной памяти в байтах, выделенной для связанного процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, возвращаемое этим свойством, представляет текущий размер виртуальной памяти, используемой процессом, в байтах. Операционная система сопоставляет виртуальное адресное пространство для каждого процесса с страницами, загруженными в физической памяти, или со страницами, хранящимися в файле подкачки виртуальной памяти на диске.  
  
 Это свойство можно использовать для наблюдения за использованием памяти на компьютерах с 32-разрядными процессорами или 64-разрядными процессорами. Значение свойства эквивалентно значению счетчика производительности " **Виртуальные байты** " для процесса.  
  
   
  
## Examples  
 В следующем примере кода запускается экземпляр приложения Notepad. Затем в примере извлекаются и отображаются различные свойства связанного процесса. В примере обнаруживается, когда процесс завершается, и отображается его код выхода и Пиковая статистика памяти.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForExit">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Задает период времени для ожидания завершения связанного процесса и блокирует текущий поток выполнения до того, как пройдет это время или процесс завершится. Чтобы избежать блокировки текущего потока, используйте событие <see cref="E:System.Diagnostics.Process.Exited" />.  
  
Примеры кода см. на следующих страницах справочника по свойствам <see cref="P:System.Diagnostics.Process.StandardError" /> и <see cref="P:System.Diagnostics.Process.ExitCode" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public void WaitForExit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForExit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit" />
      <MemberSignature Language="VB.NET" Value="Public Sub WaitForExit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WaitForExit();" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : unit -&gt; unit" Usage="process.WaitForExit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Дает компоненту <see cref="T:System.Diagnostics.Process" /> команду ожидать завершения связанного процесса в течение неограниченного времени.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit> делает текущий поток ожидающим, пока связанный процесс не завершится.  Он должен вызываться после вызова всех других методов в процессе. Чтобы избежать блокировки текущего потока, используйте событие <xref:System.Diagnostics.Process.Exited>.  
  
 Этот метод указывает компоненту <xref:System.Diagnostics.Process> ждать бесконечное количество времени, в течение которого обработчики процессов и событий завершают работу. Это может привести к тому, что приложение перестает отвечать на запросы. Например, при вызове <xref:System.Diagnostics.Process.CloseMainWindow%2A> для процесса, имеющего пользовательский интерфейс, запрос к операционной системе для завершения связанного процесса может не обрабатываться, если процесс записывается так, чтобы никогда не находился в цикле обработки сообщений.  
  
> [!NOTE]
>  В [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] и более ранних версиях перегрузка <xref:System.Diagnostics.Process.WaitForExit> ожидала <xref:System.Int32.MaxValue> миллисекунд (примерно 24 дня), а не бесконечно. Кроме того, предыдущие версии не ожидают завершения обработчиков событий, если достигнуто полное <xref:System.Int32.MaxValue> время.  
  
 Эта перегрузка гарантирует, что вся обработка завершена, включая обработку асинхронных событий для перенаправленного стандартного вывода. Эту перегрузку следует использовать после вызова перегрузки <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>, когда стандартный вывод перенаправляется в асинхронные обработчики событий.  
  
 При завершении связанного процесса (то есть при завершении работы операционной системой через нормальное или аварийное завершение) система хранит административную информацию о процессе и возвращает компоненту, который вызывал <xref:System.Diagnostics.Process.WaitForExit>. После этого компонент <xref:System.Diagnostics.Process> может получить доступ к информации, которая включает <xref:System.Diagnostics.Process.ExitTime%2A>, используя <xref:System.Diagnostics.Process.Handle%2A> для процесса завершения.  
  
 Поскольку связанный процесс завершился, свойство <xref:System.Diagnostics.Process.Handle%2A> компонента больше не указывает на существующий ресурс процесса. Вместо этого этот маркер можно использовать только для доступа к информации операционной системы о ресурсе процесса. Система осведомлена о дескрипторах завершенных процессов, которые не были освобождены <xref:System.Diagnostics.Process> компонентами, поэтому <xref:System.Diagnostics.Process.ExitTime%2A> и <xref:System.Diagnostics.Process.Handle%2A> сведения сохраняются в памяти до тех пор, пока компонент <xref:System.Diagnostics.Process> не освободит ресурсы. По этой причине при каждом вызове <xref:System.Diagnostics.Process.Start%2A> для экземпляра <xref:System.Diagnostics.Process> вызовите <xref:System.Diagnostics.Process.Close%2A>, когда связанный процесс завершится, и вам больше не понадобятся административные сведения о нем. <xref:System.Diagnostics.Process.Close%2A> освобождает память, выделенную для завершенного процесса.  
  
   
  
## Examples  
 См. раздел "Примечания" на странице справочника по свойствам <xref:System.Diagnostics.Process.StandardError%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Нет доступа к параметру ожидания.</exception>
        <exception cref="T:System.SystemException">Не задан <see cref="P:System.Diagnostics.Process.Id" /> процесса, и <see cref="P:System.Diagnostics.Process.Handle" />, из которого можно определить свойство <see cref="P:System.Diagnostics.Process.Id" />, не существует.  
  
- или - 
С этим объектом <see cref="T:System.Diagnostics.Process" /> не связаны никакие процессы.  
  
- или - 
Вы пытаетесь вызвать метод <see cref="M:System.Diagnostics.Process.WaitForExit" /> для процесса, выполняющегося на удаленном компьютере. Этот метод доступен только для процессов, запущенных на локальном компьютере.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public bool WaitForExit (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForExit(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForExit (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForExit(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : int -&gt; bool" Usage="process.WaitForExit milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">Количество времени в миллисекундах для ожидания завершения связанного процесса. Максимальным является наибольшее возможное 32-битное целое число, которое представляет для операционной системы бесконечность.</param>
        <summary>Дает компоненту <see cref="T:System.Diagnostics.Process" /> команду ожидать завершения связанного процесса в течение указанного времени в миллисекундах.</summary>
        <returns>Значение <see langword="true" />, если связанный процесс завершился; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> делает текущий поток ожидающим, пока связанный процесс не завершится. Он должен вызываться после вызова всех других методов в процессе. Чтобы избежать блокировки текущего потока, используйте событие <xref:System.Diagnostics.Process.Exited>.  
  
 Этот метод указывает компоненту <xref:System.Diagnostics.Process> ждать конечного времени завершения процесса. Если связанный процесс не выходит за конец интервала, поскольку запрос на завершение отклоняется, `false` возвращается вызывающей процедуре. Можно указать <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> для `milliseconds`, и <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29?displayProperty=nameWithType> будет вести себя так же, как перегрузка <xref:System.Diagnostics.Process.WaitForExit>. Если в метод передается значение 0 (ноль), он возвращает `true` только в том случае, если процесс уже завершился. в противном случае он немедленно возвращает `false`.  
  
> [!NOTE]
>  В [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] и более ранних версиях, если `milliseconds` имел значение-1, <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> перегрузка ожидала <xref:System.Int32.MaxValue> миллисекунд (примерно 24 дня), а не бесконечно.  
  
 Если стандартные выходные данные перенаправляются в асинхронные обработчики событий, то, возможно, обработка выходных данных не будет завершена при возврате из этого метода. Чтобы обеспечить завершение асинхронной обработки событий, вызовите перегрузку <xref:System.Diagnostics.Process.WaitForExit>, которая не принимает параметр после получения `true` из этой перегрузки. Чтобы обеспечить правильную обработку события <xref:System.Diagnostics.Process.Exited> в Windows Forms приложениях, задайте свойство <xref:System.Diagnostics.Process.SynchronizingObject%2A>.  
  
 При завершении связанного процесса (завершение работы операционной системой через нормальное или аварийное завершение) система хранит административную информацию о процессе и возвращает компоненту, который вызывал <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>. После этого компонент <xref:System.Diagnostics.Process> может получить доступ к информации, которая включает <xref:System.Diagnostics.Process.ExitTime%2A>, используя <xref:System.Diagnostics.Process.Handle%2A> для процесса завершения.  
  
 Поскольку связанный процесс завершился, свойство <xref:System.Diagnostics.Process.Handle%2A> компонента больше не указывает на существующий ресурс процесса. Вместо этого этот маркер можно использовать только для доступа к информации операционной системы о ресурсе процесса. Система осведомлена о дескрипторах завершенных процессов, которые не были освобождены <xref:System.Diagnostics.Process> компонентами, поэтому <xref:System.Diagnostics.Process.ExitTime%2A> и <xref:System.Diagnostics.Process.Handle%2A> сведения сохраняются в памяти до тех пор, пока компонент <xref:System.Diagnostics.Process> не освободит ресурсы. По этой причине при каждом вызове <xref:System.Diagnostics.Process.Start%2A> для экземпляра <xref:System.Diagnostics.Process> вызовите <xref:System.Diagnostics.Process.Close%2A>, когда связанный процесс завершится, и вам больше не понадобятся административные сведения о нем. <xref:System.Diagnostics.Process.Close%2A> освобождает память, выделенную для завершенного процесса.  
  
   
  
## Examples  
 См. пример кода для свойства <xref:System.Diagnostics.Process.ExitCode%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Нет доступа к параметру ожидания.</exception>
        <exception cref="T:System.SystemException">Не задан <see cref="P:System.Diagnostics.Process.Id" /> процесса, и <see cref="P:System.Diagnostics.Process.Handle" />, из которого можно определить свойство <see cref="P:System.Diagnostics.Process.Id" />, не существует.  
  
- или - 
С этим объектом <see cref="T:System.Diagnostics.Process" /> не связаны никакие процессы.  
  
- или - 
Вы пытаетесь вызвать метод <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" /> для процесса, выполняющегося на удаленном компьютере. Этот метод доступен только для процессов, запущенных на локальном компьютере.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="milliseconds" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForInputIdle">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Дает компоненту <see cref="T:System.Diagnostics.Process" /> команду ожидать входа связанного процесса в состояние простоя.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle();" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : unit -&gt; bool" Usage="process.WaitForInputIdle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Дает компоненту <see cref="T:System.Diagnostics.Process" /> команду ожидать перехода связанного процесса в состояние простоя в течение неограниченного времени. Эта перегрузка применяется только к процессам с пользовательским интерфейсом и, следовательно, с циклом сообщений.</summary>
        <returns>Значение <see langword="true" />, если связанный процесс достиг состояния простоя.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Diagnostics.Process.WaitForInputIdle>, чтобы заставить приложение ожидать, пока цикл обработки сообщений не вернется в состояние простоя. При выполнении процесса с пользовательским интерфейсом его цикл обработки сообщений выполняется каждый раз, когда операционная система отправляет в процесс сообщение Windows. Затем процесс возвращается в цикл обработки сообщений. Считается, что процесс находится в состоянии простоя, когда он ожидает сообщения в цикле обработки сообщений. Это состояние полезно, например, когда приложению необходимо подождать начала процесса, чтобы завершить создание главного окна, прежде чем приложение взаимодействует с этим окном.  
  
 Если процесс не имеет цикла обработки сообщений, <xref:System.Diagnostics.Process.WaitForInputIdle> создает исключение <xref:System.InvalidOperationException>.  
  
 Перегрузка <xref:System.Diagnostics.Process.WaitForInputIdle> указывает компоненту <xref:System.Diagnostics.Process> на бесконечное ожидание, пока процесс не станет активным в цикле обработки сообщений. Эта инструкция может привести к тому, что приложение перестает отвечать на запросы. Например, если процесс написан так, чтобы всегда немедленно выйти из цикла обработки сообщений, как в фрагменте кода `while(true)`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Процесс не имеет графического интерфейса.  
  
- или - 
Произошла неизвестная ошибка. Процессу не удалось перейти в состояние бездействия.  
  
- или - 
Этот процесс уже завершился.  
  
- или - 
Нет процессов, связанных с этим объектом <see cref="T:System.Diagnostics.Process" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : int -&gt; bool" Usage="process.WaitForInputIdle milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="milliseconds">Значение от 1 до <see cref="F:System.Int32.MaxValue" />, определяющее количество времени в миллисекундах, в течение которого ожидается переход связанного процесса в состояние простоя. Значение "0" указывает немедленный возврат, а значение "-1" указывает неопределенно долгое ожидание.</param>
        <summary>Дает компоненту <see cref="T:System.Diagnostics.Process" /> команду ожидать входа связанного процесса в состояние простоя в течение указанного времени в миллисекундах. Эта перегрузка применяется только к процессам с пользовательским интерфейсом и, следовательно, с циклом сообщений.</summary>
        <returns>Значение <see langword="true" />, если связанный процесс достиг состояния простоя; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29>, чтобы заставить приложение ожидать, пока цикл обработки сообщений не вернется в состояние простоя. При выполнении процесса с пользовательским интерфейсом его цикл обработки сообщений выполняется каждый раз, когда операционная система отправляет в процесс сообщение Windows. Затем процесс возвращается в цикл обработки сообщений. Считается, что процесс находится в состоянии простоя, когда он ожидает сообщения в цикле обработки сообщений. Это состояние полезно, например, когда приложению необходимо подождать начала процесса, чтобы завершить создание главного окна, прежде чем приложение взаимодействует с этим окном.  
  
 Если процесс не имеет цикла обработки сообщений, <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> создает исключение <xref:System.InvalidOperationException>.  
  
 Перегрузка <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> указывает компоненту <xref:System.Diagnostics.Process> на ожидание в течение ограниченного периода времени, в течение которого процесс становится неактивным в цикле обработки сообщений. Если связанный процесс не стал бездействовать на конец интервала, так как цикл все еще обрабатывает сообщения, `false` возвращается вызывающей процедуре.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Процесс не имеет графического интерфейса.  
  
- или - 
Произошла неизвестная ошибка. Процессу не удалось перейти в состояние бездействия.  
  
- или - 
Этот процесс уже завершился.  
  
- или - 
Нет процессов, связанных с этим объектом <see cref="T:System.Diagnostics.Process" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public int WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet : int" Usage="System.Diagnostics.Process.WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use WorkingSet64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.WorkingSet64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessWorkingSet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.WorkingSet64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.WorkingSet64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает использование физической памяти связанного процесса (в байтах).</summary>
        <value>Полное количество физической памяти в байтах, которое использует связанный процесс.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, возвращаемое этим свойством, представляет текущий размер памяти рабочего набора, используемый процессом, в байтах. Рабочий набор процесса — это набор страниц памяти, которые в настоящее время видны процессу в физической ОПЕРАТИВной памяти. Эти страницы являются резидентными и доступны для использования приложением без активации ошибки страницы.  
  
 Рабочий набор включает как общие, так и частные данные. Общие данные включают страницы, содержащие все инструкции, выполняемые процессом, включая модули процессов и системные библиотеки.  
  
   
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем в примере извлекаются и отображаются различные свойства связанного процесса. В примере обнаруживается, когда процесс завершается, и отображается код выхода процесса.  
  
 [!code-cpp[process_sample#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_sample/CPP/process_sample.cpp#1)]
 [!code-csharp[process_sample#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_sample/CS/process_sample.cs#1)]
 [!code-vb[process_sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_sample/VB/process_sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet64">
      <MemberSignature Language="C#" Value="public long WorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 WorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long WorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet64 : int64" Usage="System.Diagnostics.Process.WorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объем физической памяти в байтах, выделенной для связанного процесса.</summary>
        <value>Объем физической памяти в байтах, выделенной для связанного процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, возвращаемое этим свойством, представляет текущий размер памяти рабочего набора, используемый процессом, в байтах. Рабочий набор процесса — это набор страниц памяти, которые в настоящее время видны процессу в физической ОПЕРАТИВной памяти. Эти страницы являются резидентными и доступны для использования приложением без активации ошибки страницы.  
  
 Рабочий набор включает как общие, так и частные данные. Общие данные включают страницы, содержащие все инструкции, выполняемые процессом, включая инструкции в модулях процессов и системных библиотеках.  
  
 Это свойство можно использовать для наблюдения за использованием памяти на компьютерах с 32-разрядными процессорами или 64-разрядными процессорами. Значение свойства эквивалентно значению счетчика производительности " **Рабочий набор** " для процесса.  
  
   
  
## Examples  
 В следующем примере кода запускается экземпляр приложения Notepad. Затем в примере извлекаются и отображаются различные свойства связанного процесса. В примере обнаруживается, когда процесс завершается, и отображается его код выхода и Пиковая статистика памяти.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
  </Members>
</Type>
