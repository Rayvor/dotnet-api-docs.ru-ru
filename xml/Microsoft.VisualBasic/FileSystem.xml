<Type Name="FileSystem" FullName="Microsoft.VisualBasic.FileSystem">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b8affba69c9ea52a1bf3e93c3b9d5d4a2d6fd1f8" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69317700" /></Metadata><TypeSignature Language="C#" Value="public sealed class FileSystem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FileSystem extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileSystem" />
  <TypeSignature Language="VB.NET" Value="Public Module FileSystem" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystem sealed" />
  <TypeSignature Language="F#" Value="type FileSystem = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>7.0.5000.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
    <AssemblyVersion>10.0.4.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>В модуле <see langword="FileSystem" /> содержатся процедуры, используемые для выполнения операций с файлами, папками или каталогами и системой. Возможность <see langword="My" /> обеспечивает улучшенные производительность и быстродействие в операциях файлового ввода-вывода по сравнению с модулем <see langword="FileSystem" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот модуль поддерживает ключевые слова языка Visual Basic и элементы библиотеки времени выполнения, которые обращаются к файлам и папкам.  
  
   
  
## Examples  
 В этом примере `GetAttr` функция используется для определения атрибутов файла, каталога или папки.  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/directories-and-files-summary.md">Сводка по каталогам и файлам</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/input-and-output-summary.md">Сводка по вводу и выводу</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/index.md">Ключевые слова (Visual Basic)</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Visual Basic элементов библиотеки времени выполнения</related>
  </Docs>
  <Members>
    <Member MemberName="ChDir">
      <MemberSignature Language="C#" Value="public static void ChDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member ChDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Обязательный. Строковое выражение, определяющее, какая папка или каталог становятся новым каталогом или папкой по умолчанию. Параметр <paramref name="Path" /> может содержать метку диска. Если диск не указан, функция <see langword="ChDir" /> меняет каталог или папку по умолчанию на текущем диске.</param>
        <summary>Изменяет текущую папку или каталог. Возможность <see langword="My" /> обеспечивает улучшенные производительность и быстродействие операций файлового ввода-вывода по сравнению с функциями <see langword="ChDir" />. Дополнительные сведения см. в разделе <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDir` Функция изменяет каталог по умолчанию, но не диск по умолчанию. Например, если диском по умолчанию является C, следующая инструкция изменяет каталог по умолчанию на диске D, но C остается диском по умолчанию:  
  
 [!code-vb[VbVbalrCatRef#39](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#39)]  
  
 Относительные изменения каталога можно сделать, введя две точки следующим образом:  
  
 [!code-vb[VbVbalrCatRef#40](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#40)]  
  
> [!IMPORTANT]
>  `ChDir` Функции требуется разрешение на неуправляемый код, что может повлиять на его выполнение в ситуациях частичного доверия. Дополнительные сведения см <xref:System.Security.Permissions.SecurityPermission> . в статьях и.  
  
   
  
## Examples  
 В этом примере `ChDir` функция используется для изменения текущего каталога или папки.  
  
 [!code-vb[VbVbalrCatRef#41](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="Path" /> пуст.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Указан несуществующий диск или диск недоступен.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md">Практическое руководство. Анализ путей к файлам в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/creating-deleting-and-moving-files-and-directories.md">Создание, удаление и перемещение файлов и папок в Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ChDrive">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Изменяет текущий диск.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(char Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : char -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">Обязательный. Строковое выражение, задающее существующий диск. Если указать пустую строку (""), текущий диск не изменится. Если аргумент <paramref name="Drive" /> содержит строку из нескольких знаков, функция <see langword="ChDrive" /> использует только первую букву.</param>
        <summary>Изменяет текущий диск.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDrive` Функции требуется разрешение неуправляемого кода, которое может повлиять на его выполнение в ситуациях частичного доверия. Дополнительные сведения см. в <xref:System.Security.Permissions.SecurityPermission> разделе и [разрешения на доступ к коду](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 В этом примере `ChDrive` функция используется для изменения текущего диска. Функция создает исключение, если диск не существует.  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Указан несуществующий диск или диск недоступен.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (string Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(string Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(System::String ^ Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Drive">Обязательный. Строковое выражение, задающее существующий диск. Если указать пустую строку (""), текущий диск не изменится. Если аргумент <paramref name="Drive" /> содержит строку из нескольких знаков, функция <see langword="ChDrive" /> использует только первую букву.</param>
        <summary>Изменяет текущий диск.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDrive` Функции требуется разрешение неуправляемого кода, которое может повлиять на его выполнение в ситуациях частичного доверия. Дополнительные сведения см. в <xref:System.Security.Permissions.SecurityPermission> разделе и [разрешения на доступ к коду](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 В этом примере `ChDrive` функция используется для изменения текущего диска. Функция создает исключение, если диск не существует.  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Указан несуществующий диск или диск недоступен.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CurDir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает строку, представляющую текущий путь. Объект <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> предоставляет большую производительность и быстродействие в операциях файлового ввода-вывода по сравнению с функцией <see langword="CurDir" />. Для получения дополнительной информации см. <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir();" />
      <MemberSignature Language="F#" Value="static member CurDir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает строку, представляющую текущий путь. Объект <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> предоставляет большую производительность и быстродействие в операциях файлового ввода-вывода по сравнению с функцией <see langword="CurDir" />. Для получения дополнительной информации см. <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
        <returns>Строка, представляющая текущий путь.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В этом примере используется `CurDir` функция для возврата текущего пути.  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir (Drive As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir(char Drive);" />
      <MemberSignature Language="F#" Value="static member CurDir : char -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">Необязательный параметр. Выражение типа <see langword="Char" />, задающее существующий диск. Если диск не указан или параметр <paramref name="Drive" /> является пустой строкой (""), функция <see langword="CurDir" /> возвращает путь для текущего диска.</param>
        <summary>Возвращает строку, представляющую текущий путь. Объект <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> предоставляет большую производительность и быстродействие в операциях файлового ввода-вывода по сравнению с функцией <see langword="CurDir" />. Для получения дополнительной информации см. <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
        <returns>Строка, представляющая текущий путь.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В этом примере используется `CurDir` функция для возврата текущего пути.  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает строку, представляющую имя файла, каталога или папки, соответствующую указанному шаблону, атрибуту файла или метке тома диска. Объект <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> обеспечивает большие показатели производительности и быстродействия операций файлового ввода-вывода, чем функция <see langword="Dir" />. Дополнительные сведения см. в разделе <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Dir();" />
      <MemberSignature Language="F#" Value="static member Dir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает строку, представляющую имя файла, каталога или папки, соответствующую указанному шаблону, атрибуту файла или метке тома диска. Объект <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> обеспечивает большие показатели производительности и быстродействия операций файлового ввода-вывода, чем функция <see langword="Dir" />. Дополнительные сведения см. в разделе <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />.</summary>
        <returns>Строка, представляющая имя файла, каталога или папки, соответствующее указанному шаблону, атрибуту файла или метке тома на диске.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Функция поддерживает использование подстановочных знаков с несколькими символами`*`() и одиночными символами (`?`) для указания нескольких файлов. `Dir`  
  
 `VbVolume`Возвращает метку тома для диска вместо определенного имени файла.  
  
 Необходимо указать `PathName` при первом `Dir` вызове функции. Чтобы получить следующий элемент, можно выполнить последующие вызовы `Dir` функции без параметров.  
  
> [!IMPORTANT]
>  Для правильной `Dir` работы функция <xref:System.Security.Permissions.FileIOPermissionAccess.Read> требует предоставления флагов <xref:System.Security.Permissions.FileIOPermission> и <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> для выполнения кода. Дополнительные сведения см. в <xref:System.Security.Permissions.FileIOPermission>разделе <xref:System.Security.SecurityException>, и [разрешения на доступ к коду](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
 Ниже приведены значения перечисления аргументов.`Attributes`  
  
|Значение|Константа|Описание|  
|-|-|-|  
|`Normal`|`vbnormal`|По умолчанию. Указывает файлы без атрибутов.|  
|`ReadOnly`|`vbReadOnly`|Указывает файлы только для чтения, а также файлы без атрибутов.|  
|`Hidden`|`vbHidden`|Указывает скрытые файлы, а также файлы без атрибутов.|  
|`System`|`vbSystem`|Указывает системные файлы, а также файлы без атрибутов.|  
|`Volume`|`vbVolume`|Указывает метку тома; Если указан какой-либо другой атрибут `vbVolume` , он игнорируется.|  
|`Directory`|`vbDirectory`|Указывает каталоги или папки, а также файлы без атрибутов.|  
|`Archive`|`vbArchive`|Файл был изменен с момента создания последней резервной копии.|  
|`Alias`|`vbAlias`|У файла другое имя.|  
  
> [!NOTE]
>  Эти перечисления указываются на языке Visual Basic и могут использоваться в любом месте кода вместо фактических значений.  
  
   
  
## Examples  
 В этом примере `Dir` функция используется для проверки существования определенных файлов и каталогов.  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (PathName As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (PathName, Attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="PathName">Необязательный параметр. Строковое выражение, задающее имя файла, имя каталога или папки, либо метку тома диска. Если параметр <paramref name="PathName" /> не обнаруживается, возвращается строка нулевой длины (<see langword="&quot;&quot;" />).</param>
        <param name="Pathname">Необязательный параметр. Строковое выражение, задающее имя файла, имя каталога или папки, либо метку тома диска. Если параметр <paramref name="Pathname" /> не обнаруживается, возвращается строка нулевой длины (<see langword="&quot;&quot;" />).</param>
        <param name="Attributes">Необязательный параметр. Перечисление или числовое выражение, значение которого задает атрибуты файла. Если этот параметр опущен, функция <see langword="Dir" /> возвращает файлы, соответствующие параметру <paramref name="Pathname" />, но не имеющие атрибутов.</param>
        <summary>Возвращает строку, представляющую имя файла, каталога или папки, соответствующую указанному шаблону, атрибуту файла или метке тома диска. Объект <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> обеспечивает большие показатели производительности и быстродействия операций файлового ввода-вывода, чем функция <see langword="Dir" />. Дополнительные сведения см. в разделе <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />.</summary>
        <returns>Строка, представляющая имя файла, каталога или папки, соответствующее указанному шаблону, атрибуту файла или метке тома на диске.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Функция поддерживает использование подстановочных знаков с несколькими символами`*`() и одиночными символами (`?`) для указания нескольких файлов. `Dir`  
 `VbVolume`Возвращает метку тома для диска вместо определенного имени файла.  
 Необходимо указать `PathName` при первом `Dir` вызове функции. Чтобы получить следующий элемент, можно выполнить последующие вызовы `Dir` функции без параметров.  
> [!IMPORTANT]
>  Для правильной `Dir` работы функция <xref:System.Security.Permissions.FileIOPermissionAccess.Read> требует предоставления флагов <xref:System.Security.Permissions.FileIOPermission> и <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> для выполнения кода. Дополнительные сведения см. в <xref:System.Security.Permissions.FileIOPermission>разделе <xref:System.Security.SecurityException>, и [разрешения на доступ к коду](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
 Ниже приведены значения перечисления аргументов.`Attributes`  
|Значение|Константа|Описание|  
|-|-|-|  
|`Normal`|`vbnormal`|По умолчанию. Указывает файлы без атрибутов.|  
|`ReadOnly`|`vbReadOnly`|Указывает файлы только для чтения в дополнение к файлам, которые не имеют атрибутов.|  
|`Hidden`|`vbHidden`|Указывает скрытые файлы в дополнение к файлам, которые не имеют атрибутов.|  
|`System`|`vbSystem`|Указывает системные файлы в дополнение к файлам, которые не имеют атрибутов.|  
|`Volume`|`vbVolume`|Указывает метку тома; Если указан какой-либо другой атрибут `vbVolume` , он игнорируется.|  
|`Directory`|`vbDirectory`|Указывает каталоги или папки в дополнение к файлам, которые не имеют атрибутов.|  
|`Archive`|`vbArchive`|Файл был изменен с момента создания последней резервной копии.|  
|`Alias`|`vbAlias`|У файла другое имя.|  
> [!NOTE]
>  Эти перечисления указываются на языке Visual Basic и могут использоваться в любом месте кода вместо фактических значений.  
## Examples  
 В этом примере `Dir` функция используется для проверки существования определенных файлов и каталогов.  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public static bool EOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool EOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EOF (FileNumber As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member EOF : int -&gt; bool" Usage="Microsoft.VisualBasic.FileSystem.EOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Значение <see langword="Integer" />, содержащее любой допустимый номер файла.</param>
        <summary>Возвращает логическое значение <see langword="True" /> при достижении конца файла, открытого в режиме <see langword="Random" /> или в режиме последовательного ввода (<see langword="Input" />).</summary>
        <returns>Логическое значение <see langword="True" /> при достижении конца файла, открытого в режиме <see langword="Random" /> или в режиме последовательного ввода (<see langword="Input" />).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте `EOF` , чтобы избежать ошибки, возникшей при попытке получения входных данных после конца файла.  
  
 `EOF` Функция возвращает`False` , пока не будет достигнут конец файла. Для файлов, открытых `Random` для `Binary` или доступа `EOF` , `False` возвращает значение, пока `FileGet` последняя выполненная функция не сможет считать всю запись.  
  
 При открытии файлов, `Binary` открытых для доступа, попытка чтения файла `Input` с помощью функции до `EOF` возврата `True` приведет к ошибке. `Loc` Используйтефункции`EOF` `Input` ивместо`Get` при чтении двоичных`EOF` файлов с помощью или при использовании функции. `LOF` Если файлы открыты для `Output`, `EOF` всегда возвращает `True`.  
  
   
  
## Examples  
 В этом примере `EOF` функция используется для обнаружения конца файла. В этом примере предполагается, что `Testfile` является текстовым файлом, содержащим несколько строк текста.  
  
 [!code-vb[VbVbalrCatRef#62](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#62)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.OpenMode FileAttr(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileAttr (FileNumber As Integer) As OpenMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::OpenMode FileAttr(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member FileAttr : int -&gt; Microsoft.VisualBasic.OpenMode" Usage="Microsoft.VisualBasic.FileSystem.FileAttr FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.OpenMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. <see langword="Integer" />. Любой допустимый номер файла.</param>
        <summary>Возвращает перечисление, представляющее режим файла для файлов, открытых функцией <see langword="FileOpen" />. Объект <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> обеспечивает большие показатели производительности и быстродействия операций файлового ввода-вывода, чем функция <see langword="FileAttr" />. Дополнительные сведения см. в разделе <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</summary>
        <returns>Следующие значения перечисления определяют режим доступа к файлу: 
 <list type="table"><item><term> Значение 
 </term><description> Режим 
 </description></item><item><term> 1 
 </term><description><see langword="OpenMode.Input" /></description></item><item><term> 2 
 </term><description><see langword="OpenMode.Output" /></description></item><item><term> 4 
 </term><description><see langword="OpenMode.Random" /></description></item><item><term> 8 
 </term><description><see langword="OpenMode.Append" /></description></item><item><term> 32 
 </term><description><see langword="OpenMode.Binary" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта функция возвращает перечисление, представляющее режим файла для файлов, `FileOpen` открытых с помощью функции.  
  
   
  
## Examples  
 В этом примере `FileAttr` функция используется для возврата режима файла открытого файла.  
  
 [!code-vb[VbVbalrCatRef#46](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#46)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileClose">
      <MemberSignature Language="C#" Value="public static void FileClose (params int[] FileNumbers);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileClose(int32[] FileNumbers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileClose (ParamArray FileNumbers As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileClose(... cli::array &lt;int&gt; ^ FileNumbers);" />
      <MemberSignature Language="F#" Value="static member FileClose : int[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileClose FileNumbers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumbers" Type="System.Int32[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumbers">Необязательный параметр. Массив параметров из 0 или нескольких каналов, которые должны быть закрыты.</param>
        <summary>Завершает операции ввода-вывода с файлом, открытым с помощью функции <see langword="FileOpen" />. Возможность <see langword="My" /> предоставляет лучшие показатели производительности и быстродействии в операциях файлового ввода-вывода. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileClose` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, не использующих `My.Computer.FileSystem` устаревшие версии, объект обеспечивает лучшую производительность. Дополнительные сведения см. в разделе [Практическое руководство. Чтение текста из файлов с помощью StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md), [как: Запись текста в файлы с помощью StreamWriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)и [пошаговое руководство. Управление файлами и каталогами в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md).  
  
 Если пропустить `FileNumbers`, все активные файлы, открытые `FileOpen` функцией, будут закрыты.  
  
 При закрытии файлов, которые были открыты `Output` для `Append`или, последний буфер выходных данных записывается в буфер операционной системы для этого файла. Освобождается все буферное пространство, связанное с закрытым файлом.  
  
 При выполнении `FileClose` функции происходит связывание файла с его номером файла.  
  
   
  
## Examples  
 В этом примере `FileClose` функция используется для закрытия файла, открытого для `Input`.  
  
 [!code-vb[VbVbalrCatRef#69](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="FileNumber" /> — не существует.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Reset" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/end-statement.md">Оператор End</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/stop-statement.md">Оператор Stop (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileCopy">
      <MemberSignature Language="C#" Value="public static void FileCopy (string Source, string Destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileCopy(string Source, string Destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileCopy (Source As String, Destination As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileCopy(System::String ^ Source, System::String ^ Destination);" />
      <MemberSignature Language="F#" Value="static member FileCopy : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileCopy (Source, Destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Source" Type="System.String" />
        <Parameter Name="Destination" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Source">Обязательный. Строковое выражение, задающее имя копируемого файла. Параметр <paramref name="Source" /> может содержать имя каталога или папки, а также имя диска, где находится исходный файл.</param>
        <param name="Destination">Обязательный. Строковое выражение, определяющее имя файла назначения. Параметр <paramref name="Destination" /> может содержать имя каталога или папки, а также имя диска, где находится файл назначения.</param>
        <summary>Копирует файл. Объект <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> предоставляет большую производительность и быстродействие в операциях файлового ввода-вывода по сравнению с функцией <see langword="FileCopy" />. Дополнительные сведения см. в разделе <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При попытке использовать `FileCopy` функцию в открытом файле возникает ошибка.  
  
 `FileCopy`для работы на локальном диске требуется полное доверие.  
  
   
  
## Examples  
 В этом примере `FileCopy` функция используется для копирования одного файла в другой. В этом примере предполагается, что `SrcFile` — это файл, содержащий данные.  
  
 [!code-vb[VbVbalrCatRef#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="Source" /> или <paramref name="Destination" /> недопустим или не указан.</exception>
        <exception cref="T:System.IO.IOException">Этот файл уже открыт.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не существует.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md">Практическое руководство. Создание копии файла в другом каталоге в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md">Практическое руководство. Создание копии файла в том же каталоге в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md">Практическое руководство. Копирование каталога в другой каталог в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileDateTime">
      <MemberSignature Language="C#" Value="public static DateTime FileDateTime (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype System.DateTime FileDateTime(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileDateTime (PathName As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FileDateTime(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileDateTime : string -&gt; DateTime" Usage="Microsoft.VisualBasic.FileSystem.FileDateTime PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Обязательный. Строковое выражение, определяющее имя файла. <paramref name="PathName" /> — может включать каталог или папку, а также имя диска.</param>
        <summary>Возвращает значение типа <see langword="Date" />, которое указывает дату и время последней операции записи в файл. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FileDateTime" />. Дополнительные сведения см. в разделе <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</summary>
        <returns>Значение типа <see langword="Date" />, которое указывает дату и время создания или последнего изменения файла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В этом примере `FileDateTime` функция используется для определения даты и времени создания или последнего изменения файла. Формат отображаемых даты и времени зависит от параметров языкового стандарта системы.  
  
 [!code-vb[VbVbalrCatRef#34](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="PathName" /> недопустим или содержит подстановочный знак.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Указанный файл не существует.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FileGet">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Считывает данные из файла открытия диска в переменную. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FileGet" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, bool&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, в которую считываются данные.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы режима <see langword="Random" />) или номер байта (файлы режима <see langword="Binary" />), с которого начинается считывание.</param>
        <summary>Считывает данные из файла открытия диска в переменную. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FileGet" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`Допустим только в `Random` режиме и `Binary` .  
  
 Данные, считанные с помощью `FileGet` , обычно записываются в файл с помощью. `FilePut`  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт — на позиции 2 и т. д. Если опустить `RecordNumber`, считывается следующая запись или байт, следующая за последней `FileGet` функцией `FilePut` или (или на нее указывает последняя `Seek` функция).  
  
> [!IMPORTANT]
>  При чтении из файлов не следует принимать решения о содержимом файла на основе расширения имени файла. Например, файл с именем Form1. vb не может быть Visual Basic исходным файлом.  
  
## <a name="random-mode"></a>Произвольный режим  
 Для файлов, открытых `Random` в режиме, применяются следующие правила.  
  
-   Если длина считываемых данных меньше длины, указанной в `RecordLength` предложении `FileOpen` функции, `FileGet` считывает последующие записи на границах записи. Пространство между концом одной записи и началом следующей записи дополняется существующим содержимым файлового буфера. Поскольку объем данных заполнения не может быть определен точно, обычно рекомендуется, чтобы длина записи соответствовала длине считываемых данных.  
  
-   По умолчанию, если переменная, которую считывается в, является строкой, `FileGet` считывает двухбайтовый дескриптор, содержащий длину строки, а затем считывает данные, которые передаются в переменную. Таким образом, длина записи, заданная `RecordLength` в предложении `FileOpen` функции, должна быть как минимум на два байта больше, чем фактическая длина строки. Visual Basic 6,0 и более ранних версий поддерживают строки фиксированной длины. При помещении в файл дескриптор длины не записывается. Если требуется прочитать строку без дескриптора, следует передать `True` `StringIsFixedLength` параметр, а строка, в которую считываются строки, должна иметь правильную длину.  
  
-   Если переменная, которую считывается в, является массивом, можно выбрать, следует ли считать дескриптор размера и размерности массива. Чтобы записать дескриптор, присвойте `ArrayIsDynamic` `True`параметру значение. При чтении массива необходимо точно соответствовать способу, которым был написан массив. Если он был записан с дескриптором, необходимо прочитать дескриптор. Если дескриптор не используется, размер и границы массива, переданного в `FileGet` , определяют, что считывать.  
  
     Дескриптор задает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс в 8 раз больше, чем число измерений: (2 + 8 * Нумберофдименсионс). Длина записи, `RecordLength` заданная параметром `FileOpen` в функции, должна быть больше или равна сумме всех байтов, необходимых для записи данных массива и дескриптора массива. Например, следующее объявление массива требует 218 байт при записье массива на диск.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 байт распределяются следующим образом:  
  
    -   18 байт для дескриптора: (2 + 8 * 2)  
  
    -   200 байт для данных: (5 * 10 * 4).  
  
-   Если переменная, для которой выполняется чтение, является любым другим типом переменной (а не строкой переменной длины или объектом), `FileGet` считывает только данные переменной. Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна длине считываемых данных.  
  
-   `FileGet`считывает элементы структур так, как если бы они были считаны по отдельности, за исключением отсутствия заполнения между элементами. На диске динамический массив в определяемом пользователем типе (записанном с помощью `FilePut`) предваряется дескриптором, длина которого равна 2 плюс в 8 раз больше числа измерений: (2 + 8 * Нумберофдименсионс). Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна сумме всех байтов, необходимых для чтения отдельных элементов. Сюда входят все массивы и их дескрипторы. `VBFixedString` Атрибут может применяться к строковым полям в структурах для указания размера строки при их запись на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых `Binary` в режиме, применяются большинство `Random` правил режима с некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме, отличаются от правил для `Random` режима:  
  
-   `RecordLength` Предложение`FileOpen` в функции не оказывает никакого влияния. `FileGet`считывает все переменные с диска непрерывно; то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре, `FileGet` считывает только данные. Дескриптор не читается.  
  
-   `FileGet`считывает строки переменной длины, которые не являются элементами структур, без ожидания дескриптора длины в 2 байта. Число считанных байтов равно числу символов, уже надаваемыхся в строке.  
  
    > [!IMPORTANT]
    >  Для чтения из файла с помощью`FileGet` функции требуется `Read` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Чтение из файлов в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, unsigned int8&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, в которую считываются данные.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы режима <see langword="Random" />) или номер байта (файлы режима <see langword="Binary" />), с которого начинается считывание.</param>
        <summary>Считывает данные из файла открытия диска в переменную. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FileGet" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`Допустим только в `Random` режиме и `Binary` .  
  
 Данные, считанные с помощью `FileGet` , обычно записываются в файл с помощью. `FilePut`  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт — на позиции 2 и т. д. Если опустить `RecordNumber`, считывается следующая запись или байт, следующая за последней `FileGet` функцией `FilePut` или (или на нее указывает последняя `Seek` функция).  
  
> [!IMPORTANT]
>  При чтении из файлов не следует принимать решения о содержимом файла на основе расширения имени файла. Например, файл с именем Form1. vb не может быть Visual Basic исходным файлом.  
  
## <a name="random-mode"></a>Произвольный режим  
 Для файлов, открытых `Random` в режиме, применяются следующие правила.  
  
-   Если длина считываемых данных меньше длины, указанной в `RecordLength` предложении `FileOpen` функции, `FileGet` считывает последующие записи на границах записи. Пространство между концом одной записи и началом следующей записи дополняется существующим содержимым файлового буфера. Поскольку объем данных заполнения не может быть определен точно, обычно рекомендуется, чтобы длина записи соответствовала длине считываемых данных.  
  
-   По умолчанию, если переменная, которую считывается в, является строкой, `FileGet` считывает двухбайтовый дескриптор, содержащий длину строки, а затем считывает данные, которые передаются в переменную. Таким образом, длина записи, заданная `RecordLength` в предложении `FileOpen` функции, должна быть как минимум на два байта больше, чем фактическая длина строки. Visual Basic 6,0 и более ранних версий поддерживают строки фиксированной длины. При помещении в файл дескриптор длины не записывается. Если требуется прочитать строку без дескриптора, следует передать `True` `StringIsFixedLength` параметр, а строка, в которую считываются строки, должна иметь правильную длину.  
  
-   Если переменная, которую считывается в, является массивом, можно выбрать, следует ли считать дескриптор размера и размерности массива. Чтобы записать дескриптор, присвойте `ArrayIsDynamic` `True`параметру значение. При чтении массива необходимо точно соответствовать способу, которым был написан массив. Если он был записан с дескриптором, необходимо прочитать дескриптор. Значение, если дескриптор не используется. Затем размер и границы массива, переданного в `FileGet` , определяют, что считывать.  
  
     Дескриптор задает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс в 8 раз больше, чем число измерений: (2 + 8 * Нумберофдименсионс). Длина записи, `RecordLength` заданная параметром `FileOpen` в функции, должна быть больше или равна сумме всех байтов, необходимых для записи данных массива и дескриптора массива. Например, следующее объявление массива требует 218 байт при записье массива на диск.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 байт распределяются следующим образом:  
  
    -   18 байт для дескриптора: (2 + 8 * 2)  
  
    -   200 байт для данных: (5 * 10 * 4).  
  
-   Если переменная, для которой выполняется чтение, является любым другим типом переменной (а не строкой переменной длины или объектом), `FileGet` считывает только данные переменной. Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна длине считываемых данных.  
  
-   `FileGet`считывает элементы структур так, как если бы они были считаны по отдельности, за исключением отсутствия заполнения между элементами. На диске динамический массив в определяемом пользователем типе (записанном с помощью `FilePut`) предваряется дескриптором, длина которого равна 2 плюс в 8 раз больше числа измерений: (2 + 8 * Нумберофдименсионс). Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна сумме всех байтов, необходимых для чтения отдельных элементов. Сюда входят все массивы и их дескрипторы. `VBFixedString` Атрибут может применяться к строковым полям в структурах для указания размера строки при их запись на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых `Binary` в режиме, применяются большинство `Random` правил режима с некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме, отличаются от правил для `Random` режима:  
  
-   `RecordLength` Предложение`FileOpen` в функции не оказывает никакого влияния. `FileGet`считывает все переменные с диска непрерывно; то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре, `FileGet` считывает только данные. Дескриптор не читается.  
  
-   `FileGet`считывает строки переменной длины, которые не являются элементами структур, без ожидания дескриптора длины в 2 байта. Число считанных байтов равно числу символов, уже надаваемыхся в строке.  
  
    > [!IMPORTANT]
    >  Для чтения из файла с помощью `FileGet` функции требуется `Read` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Чтение из файлов в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, char&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, в которую считываются данные.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы режима <see langword="Random" />) или номер байта (файлы режима <see langword="Binary" />), с которого начинается считывание.</param>
        <summary>Считывает данные из файла открытия диска в переменную. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FileGet" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`Допустим только в `Random` режиме и `Binary` .  
  
 Данные, считанные с помощью `FileGet` , обычно записываются в файл с помощью. `FilePut`  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт — на позиции 2 и т. д. Если опустить `RecordNumber`, считывается следующая запись или байт, следующая за последней `FileGet` функцией `FilePut` или (или на нее указывает последняя `Seek` функция).  
  
> [!IMPORTANT]
>  При чтении из файлов не следует принимать решения о содержимом файла на основе расширения имени файла. Например, файл с именем Form1. vb не может быть Visual Basic исходным файлом.  
  
## <a name="random-mode"></a>Произвольный режим  
 Для файлов, открытых `Random` в режиме, применяются следующие правила.  
  
-   Если длина считываемых данных меньше длины, указанной в `RecordLength` предложении `FileOpen` функции, `FileGet` считывает последующие записи на границах записи. Пространство между концом одной записи и началом следующей записи дополняется существующим содержимым файлового буфера. Поскольку объем данных заполнения не может быть определен точно, обычно рекомендуется, чтобы длина записи соответствовала длине считываемых данных.  
  
-   По умолчанию, если переменная, которую считывается в, является строкой, `FileGet` считывает двухбайтовый дескриптор, содержащий длину строки, а затем считывает данные, которые передаются в переменную. Таким образом, длина записи, заданная `RecordLength` в предложении `FileOpen` функции, должна быть как минимум на два байта больше, чем фактическая длина строки. Visual Basic 6,0 и более ранних версий поддерживают строки фиксированной длины. При помещении в файл дескриптор длины не записывается. Если требуется прочитать строку без дескриптора, следует передать `True` `StringIsFixedLength` параметр, а строка, в которую считываются строки, должна иметь правильную длину.  
  
-   Если переменная, которую считывается в, является массивом, можно выбрать, следует ли считать дескриптор размера и размерности массива. Чтобы записать дескриптор, присвойте `ArrayIsDynamic` `True`параметру значение. При чтении массива необходимо точно соответствовать способу, которым был написан массив. Если он был записан с дескриптором, необходимо прочитать дескриптор. Если дескриптор не используется, размер и границы массива, переданного в `FileGet` , определяют, что считывать.  
  
     Дескриптор задает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс в 8 раз больше, чем число измерений: (2 + 8 * Нумберофдименсионс). Длина записи, `RecordLength` заданная параметром `FileOpen` в функции, должна быть больше или равна сумме всех байтов, необходимых для записи данных массива и дескриптора массива. Например, следующее объявление массива требует 218 байт при записье массива на диск.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 байт распределяются следующим образом:  
  
    -   18 байт для дескриптора: (2 + 8 * 2)  
  
    -   200 байт для данных: (5 * 10 * 4).  
  
-   Если переменная, для которой выполняется чтение, является любым другим типом переменной (а не строкой переменной длины или объектом), `FileGet` считывает только данные переменной. Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна длине считываемых данных.  
  
-   `FileGet`считывает элементы структур так, как если бы они были считаны по отдельности, за исключением отсутствия заполнения между элементами. На диске динамический массив в определяемом пользователем типе (записанном с помощью `FilePut`) предваряется дескриптором, длина которого равна 2 плюс в 8 раз больше числа измерений: (2 + 8 * Нумберофдименсионс). Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна сумме всех байтов, необходимых для чтения отдельных элементов. Сюда входят все массивы и их дескрипторы. `VBFixedString` Атрибут может применяться к строковым полям в структурах для указания размера строки при их запись на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых `Binary` в режиме, применяются большинство `Random` правил режима с некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме, отличаются от правил для `Random` режима:  
  
-   `RecordLength` Предложение`FileOpen` в функции не оказывает никакого влияния. `FileGet`считывает все переменные с диска непрерывно; то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре, `FileGet` считывает только данные. Дескриптор не читается.  
  
-   `FileGet`считывает строки переменной длины, которые не являются элементами структур, без ожидания дескриптора длины в 2 байта. Число считанных байтов равно числу символов, уже надаваемыхся в строке.  
  
    > [!IMPORTANT]
    >  Для чтения из файла с помощью `FileGet` функции требуется `Read` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Чтение из файлов в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.DateTime&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, в которую считываются данные.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы режима <see langword="Random" />) или номер байта (файлы режима <see langword="Binary" />), с которого начинается считывание.</param>
        <summary>Считывает данные из файла открытия диска в переменную. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FileGet" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`Допустим только в `Random` режиме и `Binary` .  
  
 Данные, считанные с помощью `FileGet` , обычно записываются в файл с помощью. `FilePut`  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт — на позиции 2 и т. д. Если опустить `RecordNumber`, считывается следующая запись или байт, следующая за последней `FileGet` функцией `FilePut` или (или на нее указывает последняя `Seek` функция).  
  
> [!IMPORTANT]
>  При чтении из файлов не следует принимать решения о содержимом файла на основе расширения имени файла. Например, файл с именем Form1. vb не может быть Visual Basic исходным файлом.  
  
## <a name="random-mode"></a>Произвольный режим  
 Для файлов, открытых `Random` в режиме, применяются следующие правила.  
  
-   Если длина считываемых данных меньше длины, указанной в `RecordLength` предложении `FileOpen` функции,`FileGet` считывает последующие записи на границах записи. Пространство между концом одной записи и началом следующей записи дополняется существующим содержимым файлового буфера. Поскольку объем данных заполнения не может быть определен точно, обычно рекомендуется, чтобы длина записи соответствовала длине считываемых данных.  
  
-   По умолчанию, если переменная, которую считывается в, является строкой, `FileGet` считывает двухбайтовый дескриптор, содержащий длину строки, а затем считывает данные, которые передаются в переменную. Таким образом, длина записи, заданная `RecordLength` в предложении `FileOpen` функции, должна быть как минимум на два байта больше, чем фактическая длина строки. Visual Basic 6,0 и более ранних версий поддерживают строки фиксированной длины. При помещении в файл дескриптор длины не записывается. Если требуется прочитать строку без дескриптора, следует передать `True` `StringIsFixedLength` параметр, а строка, в которую считываются строки, должна иметь правильную длину.  
  
-   Если переменная, которую считывается в, является массивом, можно выбрать, следует ли считать дескриптор размера и размерности массива. Чтобы записать дескриптор, присвойте `ArrayIsDynamic` `True`параметру значение. При чтении массива необходимо точно соответствовать способу, которым был написан массив. Если он был записан с дескриптором, необходимо прочитать дескриптор. Если дескриптор не используется, размер и границы массива, переданного в `FileGet` , определяют, что считывать.  
  
     Дескриптор задает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс в 8 раз больше, чем число измерений: (2 + 8 * Нумберофдименсионс). Длина записи, `RecordLength` заданная параметром `FileOpen` в функции, должна быть больше или равна сумме всех байтов, необходимых для записи данных массива и дескриптора массива. Например, следующее объявление массива требует 218 байт при записье массива на диск.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 байт распределяются следующим образом:  
  
    -   18 байт для дескриптора: (2 + 8 * 2)  
  
    -   200 байт для данных: (5 * 10 * 4).  
  
-   Если переменная, для которой выполняется чтение, является любым другим типом переменной (а не строкой переменной длины или объектом), `FileGet` считывает только данные переменной. Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна длине считываемых данных.  
  
-   `FileGet`считывает элементы структур так, как если бы они были считаны по отдельности, за исключением отсутствия заполнения между элементами. На диске динамический массив в определяемом пользователем типе (записанном с помощью `FilePut`) предваряется дескриптором, длина которого равна 2 плюс в 8 раз больше числа измерений: (2 + 8 * Нумберофдименсионс). Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна сумме всех байтов, необходимых для чтения отдельных элементов. Сюда входят все массивы и их дескрипторы. `VBFixedString` Атрибут может применяться к строковым полям в структурах для указания размера строки при их запись на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых `Binary` в режиме, применяются большинство `Random` правил режима с некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме, отличаются от правил для `Random` режима:  
  
-   `RecordLength` Предложение`FileOpen` в функции не оказывает никакого влияния. `FileGet`считывает все переменные с диска непрерывно; то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре, `FileGet` считывает только данные. Дескриптор не читается.  
  
-   `FileGet`считывает строки переменной длины, которые не являются элементами структур, без ожидания дескриптора длины в 2 байта. Число считанных байтов равно числу символов, уже надаваемыхся в строке.  
  
    > [!IMPORTANT]
    >  Для чтения из файла с помощью `FileGet` функции требуется `Read` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Чтение из файлов в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.Decimal&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, в которую считываются данные.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы режима <see langword="Random" />) или номер байта (файлы режима <see langword="Binary" />), с которого начинается считывание.</param>
        <summary>Считывает данные из файла открытия диска в переменную. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FileGet" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`Допустим только в `Random` режиме и `Binary` .  
  
 Данные, считанные с помощью `FileGet` , обычно записываются в файл с помощью. `FilePut`  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт — на позиции 2 и т. д. Если опустить `RecordNumber`, считывается следующая запись или байт, следующая за последней `FileGet` функцией `FilePut` или (или на нее указывает последняя `Seek` функция).  
  
> [!IMPORTANT]
>  При чтении из файлов не следует принимать решения о содержимом файла на основе расширения имени файла. Например, файл с именем Form1. vb не может быть Visual Basic исходным файлом.  
  
## <a name="random-mode"></a>Произвольный режим  
 Для файлов, открытых `Random` в режиме, применяются следующие правила.  
  
-   Если длина считываемых данных меньше длины, указанной в `RecordLength` предложении `FileOpen` функции, `FileGet` считывает последующие записи на границах записи. Пространство между концом одной записи и началом следующей записи дополняется существующим содержимым файлового буфера. Поскольку объем данных заполнения не может быть определен точно, обычно рекомендуется, чтобы длина записи соответствовала длине считываемых данных.  
  
-   По умолчанию, если переменная, которую считывается в, является строкой, `FileGet` считывает двухбайтовый дескриптор, содержащий длину строки, а затем считывает данные, которые передаются в переменную. Таким образом, длина записи, заданная `RecordLength` в предложении `FileOpen` функции, должна быть как минимум на два байта больше, чем фактическая длина строки. Visual Basic 6,0 и более ранних версий поддерживают строки фиксированной длины. При помещении в файл дескриптор длины не записывается. Если требуется прочитать строку без дескриптора, следует передать `True` `StringIsFixedLength` параметр, а строка, в которую считываются строки, должна иметь правильную длину.  
  
-   Если переменная, которую считывается в, является массивом, можно выбрать, следует ли считать дескриптор размера и размерности массива. Чтобы записать дескриптор, присвойте `ArrayIsDynamic` `True`параметру значение. При чтении массива необходимо точно соответствовать способу, которым был написан массив. Если он был записан с дескриптором, необходимо прочитать дескриптор. Если дескриптор не используется, размер и границы массива, переданного в `FileGet` , определяют, что считывать.  
  
     Дескриптор задает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс в 8 раз больше, чем число измерений: (2 + 8 * Нумберофдименсионс). Длина записи, `RecordLength` заданная параметром `FileOpen` в функции, должна быть больше или равна сумме всех байтов, необходимых для записи данных массива и дескриптора массива. Например, следующее объявление массива требует 218 байт при записье массива на диск.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 байт распределяются следующим образом:  
  
    -   18 байт для дескриптора: (2 + 8 * 2)  
  
    -   200 байт для данных: (5 * 10 * 4).  
  
-   Если переменная, для которой выполняется чтение, является любым другим типом переменной (а не строкой переменной длины или объектом), `FileGet` считывает только данные переменной. Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна длине считываемых данных.  
  
-   `FileGet`считывает элементы структур так, как если бы они были считаны по отдельности, за исключением отсутствия заполнения между элементами. На диске динамический массив в определяемом пользователем типе (записанном с помощью `FilePut`) предваряется дескриптором, длина которого равна 2 плюс в 8 раз больше числа измерений: (2 + 8 * Нумберофдименсионс). Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна сумме всех байтов, необходимых для чтения отдельных элементов. Сюда входят все массивы и их дескрипторы. `VBFixedString` Атрибут может применяться к строковым полям в структурах для указания размера строки при их запись на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых `Binary` в режиме, применяются большинство `Random` правил режима с некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме, отличаются от правил для `Random` режима:  
  
-   `RecordLength` Предложение`FileOpen` в функции не оказывает никакого влияния. `FileGet`считывает все переменные с диска непрерывно; то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре, `FileGet` считывает только данные. Дескриптор не читается.  
  
-   `FileGet`считывает строки переменной длины, которые не являются элементами структур, без ожидания дескриптора длины в 2 байта. Число считанных байтов равно числу символов, уже надаваемыхся в строке.  
  
    > [!IMPORTANT]
    >  Для чтения из файла с помощью `FileGet` функции требуется `Read` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Чтение из файлов в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, в которую считываются данные.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы режима <see langword="Random" />) или номер байта (файлы режима <see langword="Binary" />), с которого начинается считывание.</param>
        <summary>Считывает данные из файла открытия диска в переменную. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FileGet" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`Допустим только в `Random` режиме и `Binary` .  
  
 Данные, считанные с помощью `FileGet` , обычно записываются в файл с помощью. `FilePut`  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт — на позиции 2 и т. д. Если опустить `RecordNumber`, считывается следующая запись или байт, следующая за последней `FileGet` функцией `FilePut` или (или на нее указывает последняя `Seek` функция).  
  
> [!IMPORTANT]
>  При чтении из файлов не следует принимать решения о содержимом файла на основе расширения имени файла. Например, файл с именем Form1. vb не может быть Visual Basic исходным файлом.  
  
## <a name="random-mode"></a>Произвольный режим  
 Для файлов, открытых `Random` в режиме, применяются следующие правила.  
  
-   Если длина считываемых данных меньше длины, указанной в `RecordLength` предложении `FileOpen` функции, `FileGet` считывает последующие записи на границах записи. Пространство между концом одной записи и началом следующей записи дополняется существующим содержимым файлового буфера. Поскольку объем данных заполнения не может быть определен точно, обычно рекомендуется, чтобы длина записи соответствовала длине считываемых данных.  
  
-   По умолчанию, если переменная, которую считывается в, является строкой, `FileGet` считывает двухбайтовый дескриптор, содержащий длину строки, а затем считывает данные, которые передаются в переменную. Таким образом, длина записи, заданная `RecordLength` в предложении `FileOpen` функции, должна быть как минимум на два байта больше, чем фактическая длина строки. Visual Basic 6,0 и более ранних версий поддерживают строки фиксированной длины. При помещении в файл дескриптор длины не записывается. Если требуется прочитать строку без дескриптора, следует передать `True` `StringIsFixedLength` параметр, а строка, в которую считываются строки, должна иметь правильную длину.  
  
-   Если переменная, которую считывается в, является массивом, можно выбрать, следует ли считать дескриптор размера и размерности массива. Чтобы записать дескриптор, присвойте `ArrayIsDynamic` `True`параметру значение. При чтении массива необходимо точно соответствовать способу, которым был написан массив. Если он был записан с дескриптором, необходимо прочитать дескриптор. Если дескриптор не используется, размер и границы массива, переданного в `FileGet` , определяют, что считывать.  
  
     Дескриптор задает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс в 8 раз больше, чем число измерений: (2 + 8 * Нумберофдименсионс). Длина записи, `RecordLength` заданная параметром `FileOpen` в функции, должна быть больше или равна сумме всех байтов, необходимых для записи данных массива и дескриптора массива. Например, следующее объявление массива требует 218 байт при записье массива на диск.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 байт распределяются следующим образом:  
  
    -   18 байт для дескриптора: (2 + 8 * 2)  
  
    -   200 байт для данных: (5 * 10 * 4).  
  
-   Если переменная, для которой выполняется чтение, является любым другим типом переменной (а не строкой переменной длины или объектом), `FileGet` считывает только данные переменной. Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна длине считываемых данных.  
  
-   `FileGet`считывает элементы структур так, как если бы они были считаны по отдельности, за исключением отсутствия заполнения между элементами. На диске динамический массив в определяемом пользователем типе (записанном с помощью `FilePut`) предваряется дескриптором, длина которого равна 2 плюс в 8 раз больше числа измерений: (2 + 8 * Нумберофдименсионс). Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна сумме всех байтов, необходимых для чтения отдельных элементов. Сюда входят все массивы и их дескрипторы. `VBFixedString` Атрибут может применяться к строковым полям в структурах для указания размера строки при их запись на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых `Binary` в режиме, применяются большинство `Random` правил режима с некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме, отличаются от правил для `Random` режима:  
  
-   `RecordLength` Предложение`FileOpen` в функции не оказывает никакого влияния. `FileGet`считывает все переменные с диска непрерывно; то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре, `FileGet` считывает только данные. Дескриптор не читается.  
  
-   `FileGet`считывает строки переменной длины, которые не являются элементами структур, без ожидания дескриптора длины в 2 байта. Число считанных байтов равно числу символов, уже надаваемыхся в строке.  
  
    > [!IMPORTANT]
    >  Для чтения из файла с помощью`FileGet` функции требуется `Read` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Чтение из файлов в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int16&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, в которую считываются данные.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы режима <see langword="Random" />) или номер байта (файлы режима <see langword="Binary" />), с которого начинается считывание.</param>
        <summary>Считывает данные из файла открытия диска в переменную. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FileGet" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`Допустим только в `Random` режиме и `Binary` .  
  
 Данные, считанные с помощью `FileGet` , обычно записываются в файл с помощью. `FilePut`  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт — на позиции 2 и т. д. Если опустить `RecordNumber`, считывается следующая запись или байт, следующая за последней `FileGet` функцией `FilePut` или (или на нее указывает последняя `Seek` функция).  
  
> [!IMPORTANT]
>  При чтении из файлов не следует принимать решения о содержимом файла на основе расширения имени файла. Например, файл с именем Form1. vb не может быть Visual Basic исходным файлом.  
  
## <a name="random-mode"></a>Произвольный режим  
 Для файлов, открытых `Random` в режиме, применяются следующие правила.  
  
-   Если длина считываемых данных меньше длины, указанной в `RecordLength` предложении `FileOpen` функции, `FileGet` считывает последующие записи на границах записи. Пространство между концом одной записи и началом следующей записи дополняется существующим содержимым файлового буфера. Поскольку объем данных заполнения не может быть определен точно, обычно рекомендуется, чтобы длина записи соответствовала длине считываемых данных.  
  
-   По умолчанию, если переменная, которую считывается в, является строкой, `FileGet` считывает двухбайтовый дескриптор, содержащий длину строки, а затем считывает данные, которые передаются в переменную. Таким образом, длина записи, заданная `RecordLength` в предложении `FileOpen` функции, должна быть как минимум на два байта больше, чем фактическая длина строки. Visual Basic 6,0 и более ранних версий поддерживают строки фиксированной длины. При помещении в файл дескриптор длины не записывается. Если требуется прочитать строку без дескриптора, следует передать `True` `StringIsFixedLength` параметр, а строка, в которую считываются строки, должна иметь правильную длину.  
  
-   Если переменная, которую считывается в, является массивом, можно выбрать, следует ли считать дескриптор размера и размерности массива. Чтобы записать дескриптор, присвойте `ArrayIsDynamic` `True`параметру значение. При чтении массива необходимо точно соответствовать способу, которым был написан массив. Если он был записан с дескриптором, необходимо прочитать дескриптор. Если дескриптор не используется, размер и границы массива, переданного в `FileGet` , определяют, что считывать.  
  
     Дескриптор задает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс в 8 раз больше, чем число измерений: (2 + 8 * Нумберофдименсионс). Длина записи, `RecordLength` заданная параметром `FileOpen` в функции, должна быть больше или равна сумме всех байтов, необходимых для записи данных массива и дескриптора массива. Например, следующее объявление массива требует 218 байт при записье массива на диск.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 байт распределяются следующим образом:  
  
    -   18 байт для дескриптора: (2 + 8 * 2)  
  
    -   200 байт для данных: (5 * 10 * 4).  
  
-   Если переменная, для которой выполняется чтение, является любым другим типом переменной (а не строкой переменной длины или объектом), `FileGet` считывает только данные переменной. Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна длине считываемых данных.  
  
-   `FileGet`считывает элементы структур так, как если бы они были считаны по отдельности, за исключением отсутствия заполнения между элементами. На диске динамический массив в определяемом пользователем типе (записанном с помощью `FilePut`) предваряется дескриптором, длина которого равна 2 плюс в 8 раз больше числа измерений: (2 + 8 * Нумберофдименсионс). Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна сумме всех байтов, необходимых для чтения отдельных элементов. Сюда входят все массивы и их дескрипторы. `VBFixedString` Атрибут может применяться к строковым полям в структурах для указания размера строки при их запись на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых `Binary` в режиме, применяются большинство `Random` правил режима с некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме, отличаются от правил для `Random` режима:  
  
-   `RecordLength` Предложение`FileOpen` в функции не оказывает никакого влияния. `FileGet`считывает все переменные с диска непрерывно; то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре, `FileGet` считывает только данные. Дескриптор не читается.  
  
-   `FileGet`считывает строки переменной длины, которые не являются элементами структур, без ожидания дескриптора длины в 2 байта. Число считанных байтов равно числу символов, уже надаваемыхся в строке.  
  
    > [!IMPORTANT]
    >  Для чтения из файла с помощью `FileGet` функции требуется `Read` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Чтение из файлов в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, в которую считываются данные.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы режима <see langword="Random" />) или номер байта (файлы режима <see langword="Binary" />), с которого начинается считывание.</param>
        <summary>Считывает данные из файла открытия диска в переменную. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FileGet" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`Допустим только в `Random` режиме и `Binary` .  
  
 Данные, считанные с помощью `FileGet` , обычно записываются в файл с помощью. `FilePut`  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт — на позиции 2 и т. д. Если опустить `RecordNumber`, считывается следующая запись или байт, следующая за последней `FileGet` функцией `FilePut` или (или на нее указывает последняя `Seek` функция).  
  
> [!IMPORTANT]
>  При чтении из файлов не следует принимать решения о содержимом файла на основе расширения имени файла. Например, файл с именем Form1. vb не может быть Visual Basic исходным файлом.  
  
## <a name="random-mode"></a>Произвольный режим  
 Для файлов, открытых `Random` в режиме, применяются следующие правила.  
  
-   Если длина считываемых данных меньше длины, указанной в `RecordLength` предложении `FileOpen` функции, `FileGet` считывает последующие записи на границах записи. Пространство между концом одной записи и началом следующей записи дополняется существующим содержимым файлового буфера. Поскольку объем данных заполнения не может быть определен точно, обычно рекомендуется, чтобы длина записи соответствовала длине считываемых данных.  
  
-   По умолчанию, если переменная, которую считывается в, является строкой, `FileGet` считывает двухбайтовый дескриптор, содержащий длину строки, а затем считывает данные, которые передаются в переменную. Таким образом, длина записи, заданная `RecordLength` в предложении `FileOpen` функции, должна быть как минимум на два байта больше, чем фактическая длина строки. Visual Basic 6,0 и более ранних версий поддерживают строки фиксированной длины. При помещении в файл дескриптор длины не записывается. Если требуется прочитать строку без дескриптора, следует передать `True` `StringIsFixedLength` параметр, а строка, в которую считываются строки, должна иметь правильную длину.  
  
-   Если переменная, которую считывается в, является массивом, можно выбрать, следует ли считать дескриптор размера и размерности массива. Чтобы записать дескриптор, присвойте `ArrayIsDynamic` `True`параметру значение. При чтении массива необходимо точно соответствовать способу, которым был написан массив. Если он был записан с дескриптором, необходимо прочитать дескриптор. Если дескриптор не используется, размер и границы массива, переданного в `FileGet` , определяют, что считывать.  
  
     Дескриптор задает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс в 8 раз больше, чем число измерений: (2 + 8 * Нумберофдименсионс). Длина записи, `RecordLength` заданная параметром `FileOpen` в функции, должна быть больше или равна сумме всех байтов, необходимых для записи данных массива и дескриптора массива. Например, следующее объявление массива требует 218 байт при записье массива на диск.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 байт распределяются следующим образом:  
  
    -   18 байт для дескриптора: (2 + 8 * 2)  
  
    -   200 байт для данных: (5 * 10 * 4).  
  
-   Если переменная, для которой выполняется чтение, является любым другим типом переменной (а не строкой переменной длины или объектом), `FileGet` считывает только данные переменной. Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна длине считываемых данных.  
  
-   `FileGet`считывает элементы структур так, как если бы они были считаны по отдельности, за исключением отсутствия заполнения между элементами. На диске динамический массив в определяемом пользователем типе (записанном с помощью `FilePut`) предваряется дескриптором, длина которого равна 2 плюс в 8 раз больше числа измерений: (2 + 8 * Нумберофдименсионс). Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна сумме всех байтов, необходимых для чтения отдельных элементов. Сюда входят все массивы и их дескрипторы. `VBFixedString` Атрибут может применяться к строковым полям в структурах для указания размера строки при их запись на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых `Binary` в режиме, применяются большинство `Random` правил режима с некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме, отличаются от правил для `Random` режима:  
  
-   `RecordLength` Предложение`FileOpen` в функции не оказывает никакого влияния. `FileGet`считывает все переменные с диска непрерывно; то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре, `FileGet` считывает только данные. Дескриптор не читается.  
  
-   `FileGet`считывает строки переменной длины, которые не являются элементами структур, без ожидания дескриптора длины в 2 байта. Число считанных байтов равно числу символов, уже надаваемыхся в строке.  
  
    > [!IMPORTANT]
    >  Для чтения из файла с помощью `FileGet` функции требуется `Read` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Чтение из файлов в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, в которую считываются данные.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы режима <see langword="Random" />) или номер байта (файлы режима <see langword="Binary" />), с которого начинается считывание.</param>
        <summary>Считывает данные из файла открытия диска в переменную. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FileGet" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`Допустим только в `Random` режиме и `Binary` .  
  
 Данные, считанные с помощью `FileGet` , обычно записываются в файл с помощью. `FilePut`  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт — на позиции 2 и т. д. Если опустить `RecordNumber`, считывается следующая запись или байт, следующая за последней `FileGet` функцией `FilePut` или (или на нее указывает последняя `Seek` функция).  
  
> [!IMPORTANT]
>  При чтении из файлов не следует принимать решения о содержимом файла на основе расширения имени файла. Например, файл с именем Form1. vb не может быть Visual Basic исходным файлом.  
  
## <a name="random-mode"></a>Произвольный режим  
 Для файлов, открытых `Random` в режиме, применяются следующие правила.  
  
-   Если длина считываемых данных меньше длины, указанной в `RecordLength` предложении `FileOpen` функции, `FileGet` считывает последующие записи на границах записи. Пространство между концом одной записи и началом следующей записи дополняется существующим содержимым файлового буфера. Поскольку объем данных заполнения не может быть определен точно, обычно рекомендуется, чтобы длина записи соответствовала длине считываемых данных.  
  
-   По умолчанию, если переменная, которую считывается в, является строкой, `FileGet` считывает двухбайтовый дескриптор, содержащий длину строки, а затем считывает данные, которые передаются в переменную. Таким образом, длина записи, заданная `RecordLength` в предложении `FileOpen` функции, должна быть как минимум на два байта больше, чем фактическая длина строки. Visual Basic 6,0 и более ранних версий поддерживают строки фиксированной длины. При помещении в файл дескриптор длины не записывается. Если требуется прочитать строку без дескриптора, следует передать `True` `StringIsFixedLength` параметр, а строка, в которую считываются строки, должна иметь правильную длину.  
  
-   Если переменная, которую считывается в, является массивом, можно выбрать, следует ли считать дескриптор размера и размерности массива. Чтобы записать дескриптор, присвойте `ArrayIsDynamic` `True`параметру значение. При чтении массива необходимо точно соответствовать способу, которым был написан массив. Если он был записан с дескриптором, необходимо прочитать дескриптор. Если дескриптор не используется, размер и границы массива, переданного в `FileGet` , определяют, что считывать.  
  
     Дескриптор задает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс в 8 раз больше, чем число измерений: (2 + 8 * Нумберофдименсионс). Длина записи, `RecordLength` заданная параметром `FileOpen` в функции, должна быть больше или равна сумме всех байтов, необходимых для записи данных массива и дескриптора массива. Например, следующее объявление массива требует 218 байт при записье массива на диск.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 байт распределяются следующим образом:  
  
    -   18 байт для дескриптора: (2 + 8 * 2)  
  
    -   200 байт для данных: (5 * 10 * 4).  
  
-   Если переменная, для которой выполняется чтение, является любым другим типом переменной (а не строкой переменной длины или объектом), `FileGet` считывает только данные переменной. Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна длине считываемых данных.  
  
-   `FileGet`считывает элементы структур так, как если бы они были считаны по отдельности, за исключением отсутствия заполнения между элементами. На диске динамический массив в определяемом пользователем типе (записанном с помощью `FilePut`) предваряется дескриптором, длина которого равна 2 плюс в 8 раз больше числа измерений: (2 + 8 * Нумберофдименсионс). Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна сумме всех байтов, необходимых для чтения отдельных элементов. Сюда входят все массивы и их дескрипторы. `VBFixedString` Атрибут может применяться к строковым полям в структурах для указания размера строки при их запись на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых `Binary` в режиме, применяются большинство `Random` правил режима с некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме, отличаются от правил для `Random` режима:  
  
-   `RecordLength` Предложение`FileOpen` в функции не оказывает никакого влияния. `FileGet`считывает все переменные с диска непрерывно; то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре, `FileGet` считывает только данные. Дескриптор не читается.  
  
-   `FileGet`считывает строки переменной длины, которые не являются элементами структур, без ожидания дескриптора длины в 2 байта. Число считанных байтов равно числу символов, уже надаваемыхся в строке.  
  
    > [!IMPORTANT]
    >  Для чтения из файла с помощью `FileGet` функции требуется `Read` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Чтение из файлов в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, в которую считываются данные.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы режима <see langword="Random" />) или номер байта (файлы режима <see langword="Binary" />), с которого начинается считывание.</param>
        <summary>Считывает данные из файла открытия диска в переменную. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FileGet" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`Допустим только в `Random` режиме и `Binary` .  
  
 Данные, считанные с помощью `FileGet` , обычно записываются в файл с помощью. `FilePut`  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт — на позиции 2 и т. д. Если опустить `RecordNumber`, считывается следующая запись или байт, следующая за последней `FileGet` функцией `FilePut` или (или на нее указывает последняя `Seek` функция).  
  
> [!IMPORTANT]
>  При чтении из файлов не следует принимать решения о содержимом файла на основе расширения имени файла. Например, файл с именем Form1. vb не может быть Visual Basic исходным файлом.  
  
## <a name="random-mode"></a>Произвольный режим  
 Для файлов, открытых `Random` в режиме, применяются следующие правила.  
  
-   Если длина считываемых данных меньше длины, указанной в `RecordLength` предложении `FileOpen` функции, `FileGet` считывает последующие записи на границах записи. Пространство между концом одной записи и началом следующей записи дополняется существующим содержимым файлового буфера. Поскольку объем данных заполнения не может быть определен точно, обычно рекомендуется, чтобы длина записи соответствовала длине считываемых данных.  
  
-   По умолчанию, если переменная, которую считывается в, является строкой, `FileGet` считывает двухбайтовый дескриптор, содержащий длину строки, а затем считывает данные, которые передаются в переменную. Таким образом, длина записи, заданная `RecordLength` в предложении `FileOpen` функции, должна быть как минимум на два байта больше, чем фактическая длина строки. Visual Basic 6,0 и более ранних версий поддерживают строки фиксированной длины. При помещении в файл дескриптор длины не записывается. Если требуется прочитать строку без дескриптора, следует передать `True` `StringIsFixedLength` параметр, а строка, в которую считываются строки, должна иметь правильную длину.  
  
-   Если переменная, которую считывается в, является массивом, можно выбрать, следует ли считать дескриптор размера и размерности массива. Чтобы записать дескриптор, присвойте `ArrayIsDynamic` `True`параметру значение. При чтении массива необходимо точно соответствовать способу, которым был написан массив. Если он был записан с дескриптором, необходимо прочитать дескриптор. Если дескриптор не используется, размер и границы массива, переданного в `FileGet` , определяют, что считывать.  
  
     Дескриптор задает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс в 8 раз больше, чем число измерений: (2 + 8 * Нумберофдименсионс). Длина записи, `RecordLength` заданная параметром `FileOpen` в функции, должна быть больше или равна сумме всех байтов, необходимых для записи данных массива и дескриптора массива. Например, следующее объявление массива требует 218 байт при записье массива на диск.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 байт распределяются следующим образом:  
  
    -   18 байт для дескриптора: (2 + 8 * 2)  
  
    -   200 байт для данных: (5 * 10 * 4).  
  
-   Если переменная, для которой выполняется чтение, является любым другим типом переменной (а не строкой переменной длины или объектом), `FileGet` считывает только данные переменной. Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна длине считываемых данных.  
  
-   `FileGet`считывает элементы структур так, как если бы они были считаны по отдельности, за исключением отсутствия заполнения между элементами. На диске динамический массив в определяемом пользователем типе (записанном с помощью `FilePut`) предваряется дескриптором, длина которого равна 2 плюс в 8 раз больше числа измерений: (2 + 8 * Нумберофдименсионс). Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна сумме всех байтов, необходимых для чтения отдельных элементов. Сюда входят все массивы и их дескрипторы. `VBFixedString` Атрибут может применяться к строковым полям в структурах для указания размера строки при их запись на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых `Binary` в режиме, применяются большинство `Random` правил режима с некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме, отличаются от правил для `Random` режима:  
  
-   `RecordLength` Предложение`FileOpen` в функции не оказывает никакого влияния. `FileGet`считывает все переменные с диска непрерывно; то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре, `FileGet` считывает только данные. Дескриптор не читается.  
  
-   `FileGet`считывает строки переменной длины, которые не являются элементами структур, без ожидания дескриптора длины в 2 байта. Число считанных байтов равно числу символов, уже надаваемыхся в строке.  
  
    > [!IMPORTANT]
    >  Для чтения из файла с помощью `FileGet` функции требуется `Read` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Чтение из файлов в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.ValueType&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, в которую считываются данные.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы режима <see langword="Random" />) или номер байта (файлы режима <see langword="Binary" />), с которого начинается считывание.</param>
        <summary>Считывает данные из файла открытия диска в переменную. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FileGet" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`Допустим только в `Random` режиме и `Binary` .  
  
 Данные, считанные с помощью `FileGet` , обычно записываются в файл с помощью. `FilePut`  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт — на позиции 2 и т. д. Если опустить `RecordNumber`, считывается следующая запись или байт, следующая за последней `FileGet` функцией `FilePut` или (или на нее указывает последняя `Seek` функция).  
  
> [!IMPORTANT]
>  При чтении из файлов не следует принимать решения о содержимом файла на основе расширения имени файла. Например, файл с именем Form1. vb не может быть Visual Basic исходным файлом.  
  
## <a name="random-mode"></a>Произвольный режим  
 Для файлов, открытых `Random` в режиме, применяются следующие правила.  
  
-   Если длина считываемых данных меньше длины, указанной в `RecordLength` предложении `FileOpen` функции, `FileGet` считывает последующие записи на границах записи. Пространство между концом одной записи и началом следующей записи дополняется существующим содержимым файлового буфера. Поскольку объем данных заполнения не может быть определен точно, обычно рекомендуется, чтобы длина записи соответствовала длине считываемых данных.  
  
-   По умолчанию, если переменная, которую считывается в, является строкой, `FileGet` считывает двухбайтовый дескриптор, содержащий длину строки, а затем считывает данные, которые передаются в переменную. Таким образом, длина записи, заданная `RecordLength` в предложении `FileOpen` функции, должна быть как минимум на два байта больше, чем фактическая длина строки. Visual Basic 6,0 и более ранних версий поддерживают строки фиксированной длины. При помещении в файл дескриптор длины не записывается. Если требуется прочитать строку без дескриптора, следует передать `True` `StringIsFixedLength` параметр, а строка, в которую считываются строки, должна иметь правильную длину.  
  
-   Если переменная, которую считывается в, является массивом, можно выбрать, следует ли считать дескриптор размера и размерности массива. Чтобы записать дескриптор, присвойте `ArrayIsDynamic` `True`параметру значение. При чтении массива необходимо точно соответствовать способу, которым был написан массив. Если он был записан с дескриптором, необходимо прочитать дескриптор. Если дескриптор не используется, размер и границы массива, переданного в `FileGet` , определяют, что считывать.  
  
     Дескриптор задает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс в 8 раз больше, чем число измерений: (2 + 8 * Нумберофдименсионс). Длина записи, `RecordLength` заданная параметром `FileOpen` в функции, должна быть больше или равна сумме всех байтов, необходимых для записи данных массива и дескриптора массива. Например, следующее объявление массива требует 218 байт при записье массива на диск.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 байт распределяются следующим образом:  
  
    -   18 байт для дескриптора: (2 + 8 * 2)  
  
    -   200 байт для данных: (5 * 10 * 4).  
  
-   Если переменная, для которой выполняется чтение, является любым другим типом переменной (а не строкой переменной длины или объектом), `FileGet` считывает только данные переменной. Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна длине считываемых данных.  
  
-   `FileGet`считывает элементы структур так, как если бы они были считаны по отдельности, за исключением отсутствия заполнения между элементами. На диске динамический массив в определяемом пользователем типе (записанном с помощью `FilePut`) предваряется дескриптором, длина которого равна 2 плюс в 8 раз больше числа измерений: (2 + 8 * Нумберофдименсионс). Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна сумме всех байтов, необходимых для чтения отдельных элементов. Сюда входят все массивы и их дескрипторы. `VBFixedString` Атрибут может применяться к строковым полям в структурах для указания размера строки при их запись на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых `Binary` в режиме, применяются большинство `Random` правил режима с некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме, отличаются от правил для `Random` режима:  
  
-   `RecordLength` Предложение`FileOpen` в функции не оказывает никакого влияния. `FileGet`считывает все переменные с диска непрерывно; то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре, `FileGet` считывает только данные. Дескриптор не читается.  
  
-   `FileGet`считывает строки переменной длины, которые не являются элементами структур, без ожидания дескриптора длины в 2 байта. Число считанных байтов равно числу символов, уже надаваемыхся в строке.  
  
    > [!IMPORTANT]
    >  Для чтения из файла с помощью `FileGet` функции требуется `Read` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Чтение из файлов в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, string&amp; Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, в которую считываются данные.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы режима <see langword="Random" />) или номер байта (файлы режима <see langword="Binary" />), с которого начинается считывание.</param>
        <param name="StringIsFixedLength">Необязательный параметр. Используется только при записи строки. Указывает, записывать ли двухбайтовый дескриптор длины строки. Значение по умолчанию — <see langword="False" />.</param>
        <summary>Считывает данные из файла открытия диска в переменную. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FileGet" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`Допустим только в `Random` режиме и `Binary` .  
  
 Данные, считанные с помощью `FileGet` , обычно записываются в файл с помощью. `FilePut`  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт — на позиции 2 и т. д. Если опустить `RecordNumber`, считывается следующая запись или байт, следующая за последней `FileGet` функцией `FilePut` или (или на нее указывает последняя `Seek` функция).  
  
> [!IMPORTANT]
>  При чтении из файлов не следует принимать решения о содержимом файла на основе расширения имени файла. Например, файл с именем Form1. vb не может быть Visual Basic исходным файлом.  
  
## <a name="random-mode"></a>Произвольный режим  
 Для файлов, открытых `Random` в режиме, применяются следующие правила.  
  
-   Если длина считываемых данных меньше длины, указанной в `RecordLength` предложении `FileOpen` функции, `FileGet` считывает последующие записи на границах записи. Пространство между концом одной записи и началом следующей записи дополняется существующим содержимым файлового буфера. Поскольку объем данных заполнения не может быть определен точно, обычно рекомендуется, чтобы длина записи соответствовала длине считываемых данных.  
  
-   По умолчанию, если переменная, которую считывается в, является строкой, `FileGet` считывает двухбайтовый дескриптор, содержащий длину строки, а затем считывает данные, которые передаются в переменную. Таким образом, длина записи, заданная `RecordLength` в предложении `FileOpen` функции, должна быть как минимум на два байта больше, чем фактическая длина строки. Visual Basic 6,0 и более ранних версий поддерживают строки фиксированной длины. При помещении в файл дескриптор длины не записывается. Если требуется прочитать строку без дескриптора, следует передать `True` `StringIsFixedLength` параметр, а строка, в которую считываются строки, должна иметь правильную длину.  
  
-   Если переменная, которую считывается в, является массивом, можно выбрать, следует ли считать дескриптор размера и размерности массива. Чтобы записать дескриптор, присвойте `ArrayIsDynamic` `True`параметру значение. При чтении массива необходимо точно соответствовать способу, которым был написан массив. Если он был записан с дескриптором, необходимо прочитать дескриптор. Если дескриптор не используется, размер и границы массива, переданного в `FileGet` , определяют, что считывать.  
  
     Дескриптор задает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс в 8 раз больше, чем число измерений: (2 + 8 * Нумберофдименсионс). Длина записи, `RecordLength` заданная параметром `FileOpen` в функции, должна быть больше или равна сумме всех байтов, необходимых для записи данных массива и дескриптора массива. Например, следующее объявление массива требует 218 байт при записье массива на диск.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 байт распределяются следующим образом:  
  
    -   18 байт для дескриптора: (2 + 8 * 2)  
  
    -   200 байт для данных: (5 * 10 * 4).  
  
-   Если переменная, для которой выполняется чтение, является любым другим типом переменной (а не строкой переменной длины или объектом), `FileGet` считывает только данные переменной. Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна длине считываемых данных.  
  
-   `FileGet`считывает элементы структур так, как если бы они были считаны по отдельности, за исключением отсутствия заполнения между элементами. На диске динамический массив в определяемом пользователем типе (записанном с помощью `FilePut`) предваряется дескриптором, длина которого равна 2 плюс в 8 раз больше числа измерений: (2 + 8 * Нумберофдименсионс). Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна сумме всех байтов, необходимых для чтения отдельных элементов. Сюда входят все массивы и их дескрипторы. `VBFixedString` Атрибут может применяться к строковым полям в структурах для указания размера строки при их запись на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых `Binary` в режиме, применяются большинство `Random` правил режима с некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме, отличаются от правил для `Random` режима:  
  
-   `RecordLength` Предложение`FileOpen` в функции не оказывает никакого влияния. `FileGet`считывает все переменные с диска непрерывно; то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре, `FileGet` считывает только данные. Дескриптор не читается.  
  
-   `FileGet`считывает строки переменной длины, которые не являются элементами структур, без ожидания дескриптора длины в 2 байта. Число считанных байтов равно числу символов, уже надаваемыхся в строке.  
  
    > [!IMPORTANT]
    >  Для чтения из файла с помощью `FileGet` функции требуется `Read` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Чтение из файлов в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.Array&amp; Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, в которую считываются данные.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы режима <see langword="Random" />) или номер байта (файлы режима <see langword="Binary" />), с которого начинается считывание.</param>
        <param name="ArrayIsDynamic">Необязательный параметр. Применяется только при записи массива. Указывает, нужно ли обрабатывать массив как динамический, и обязательно ли записывать дескриптор массива, описывающий его длину и границы.</param>
        <param name="StringIsFixedLength">Необязательный параметр. Используется только при записи строки. Указывает, записывать ли двухбайтовый дескриптор длины строки. Значение по умолчанию — <see langword="False" />.</param>
        <summary>Считывает данные из файла открытия диска в переменную. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FileGet" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`Допустим только в `Random` режиме и `Binary` .  
  
 Данные, считанные с помощью `FileGet` , обычно записываются в файл с помощью. `FilePut`  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт — на позиции 2 и т. д. Если опустить `RecordNumber`, считывается следующая запись или байт, следующая за последней `FileGet` функцией `FilePut` или (или на нее указывает последняя `Seek` функция).  
  
> [!IMPORTANT]
>  При чтении из файлов не следует принимать решения о содержимом файла на основе расширения имени файла. Например, файл с именем Form1. vb не может быть Visual Basic исходным файлом.  
  
## <a name="random-mode"></a>Произвольный режим  
 Для файлов, открытых `Random` в режиме, применяются следующие правила.  
  
-   Если длина считываемых данных меньше длины, указанной в `RecordLength` предложении `FileOpen` функции, `FileGet` считывает последующие записи на границах записи. Пространство между концом одной записи и началом следующей записи дополняется существующим содержимым файлового буфера. Поскольку объем данных заполнения не может быть определен точно, обычно рекомендуется, чтобы длина записи соответствовала длине считываемых данных.  
  
-   По умолчанию, если переменная, которую считывается в, является строкой, `FileGet` считывает двухбайтовый дескриптор, содержащий длину строки, а затем считывает данные, которые передаются в переменную. Таким образом, длина записи, заданная `RecordLength` в предложении `FileOpen` функции, должна быть как минимум на два байта больше, чем фактическая длина строки. Visual Basic 6,0 и более ранних версий поддерживают строки фиксированной длины. При помещении в файл дескриптор длины не записывается. Если требуется прочитать строку без дескриптора, следует передать `True` `StringIsFixedLength` параметр, а строка, в которую считываются строки, должна иметь правильную длину.  
  
-   Если переменная, которую считывается в, является массивом, можно выбрать, следует ли считать дескриптор размера и размерности массива. Чтобы записать дескриптор, присвойте `ArrayIsDynamic` `True`параметру значение. При чтении массива необходимо точно соответствовать способу, которым был написан массив. Если он был записан с дескриптором, необходимо прочитать дескриптор. Если дескриптор не используется, размер и границы массива, переданного в `FileGet` , определяют, что считывать.  
  
     Дескриптор задает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс в 8 раз больше, чем число измерений: (2 + 8 * Нумберофдименсионс). Длина записи, `RecordLength` заданная параметром `FileOpen` в функции, должна быть больше или равна сумме всех байтов, необходимых для записи данных массива и дескриптора массива. Например, следующее объявление массива требует 218 байт при записье массива на диск.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 байт распределяются следующим образом:  
  
    -   18 байт для дескриптора: (2 + 8 * 2)  
  
    -   200 байт для данных: (5 * 10 * 4).  
  
-   Если переменная, для которой выполняется чтение, является любым другим типом переменной (а не строкой переменной длины или объектом), `FileGet` считывает только данные переменной. Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна длине считываемых данных.  
  
-   `FileGet`считывает элементы структур так, как если бы они были считаны по отдельности, за исключением отсутствия заполнения между элементами. На диске динамический массив в определяемом пользователем типе (записанном с помощью `FilePut`) предваряется дескриптором, длина которого равна 2 плюс в 8 раз больше числа измерений: (2 + 8 * Нумберофдименсионс). Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна сумме всех байтов, необходимых для чтения отдельных элементов. Сюда входят все массивы и их дескрипторы. `VBFixedString` Атрибут может применяться к строковым полям в структурах для указания размера строки при их запись на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых `Binary` в режиме, применяются большинство `Random` правил режима с некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме, отличаются от правил для `Random` режима:  
  
-   `RecordLength` Предложение`FileOpen` в функции не оказывает никакого влияния. `FileGet`считывает все переменные с диска непрерывно; то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре, `FileGet` считывает только данные. Дескриптор не читается.  
  
-   `FileGet`считывает строки переменной длины, которые не являются элементами структур, без ожидания дескриптора длины в 2 байта. Число считанных байтов равно числу символов, уже надаваемыхся в строке.  
  
    > [!IMPORTANT]
    >  Для чтения из файла с помощью `FileGet` функции требуется `Read` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Чтение из файлов в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGetObject">
      <MemberSignature Language="C#" Value="public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGetObject(int32 FileNumber, object&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGetObject (FileNumber As Integer, ByRef Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGetObject : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGetObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, в которую считываются данные.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы режима <see langword="Random" />) или номер байта (файлы режима <see langword="Binary" />), с которого начинается считывание.</param>
        <summary>Считывает данные из файла открытия диска в переменную.  Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FileGetObject" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Object` `Integer` `Long` `Short`Функция используется `FileGet` вместо, чтобы избежать неоднозначности во время компиляции, если возвращается тип, а не другой тип, например,, и т. д. `FileGetObject`  
  
 Если предполагается записывать `Variant` тип, `FileGetObject` требуется. В случае сомнений, если вы используете объект для второго параметра, всегда рекомендуется использовать `FilePutObject` и. `FileGetObject`  
  
 `FileGetObject`Допустим только в `Random` режиме и `Binary` .  
  
 Данные, считанные с помощью `FileGetObject` , обычно записываются с помощью. `FilePutObject`  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт — на позиции 2 и т. д. `RecordNumber`Если опустить `Seek` , `FileGetObject` считывает запись или байт после последней `FileGetObject` функции или `FilePutObject` (или на нее указывает последняя функция).  
  
## <a name="random-mode"></a>Произвольный режим  
 Для файлов, открытых `Random` в режиме, применяются следующие правила.  
  
-   Если длина считываемых данных меньше длины, указанной в `RecordLength` предложении `FileOpen` функции, `FileGetObject` считывает последующие записи на границах записи. Пространство между концом одной записи и началом следующей записи дополняется существующим содержимым файлового буфера. Поскольку объем данных заполнения не может быть определен точно, рекомендуется, чтобы длина записи соответствовала длине считываемых данных.  
  
-   Если переменная, которую считывается в, является строкой, по `FileGetObject` умолчанию считывает двухбайтовый дескриптор, содержащий длину строки, а затем считывает данные, которые передаются в переменную. Таким образом, длина записи, заданная `RecordLength` в предложении `FileOpen` функции, должна быть как минимум на два байта больше, чем фактическая длина строки. Visual Basic 6,0 и более ранние версии поддерживают строки фиксированной длины и при чтении в файл дескриптор длины не записывается. Если требуется прочитать строку без дескриптора, следует передать `True` `StringIsFixedLength` параметр, а строка, в которую считываются строки, должна иметь правильную длину.  
  
-   Если переменная, которую считывается в, является массивом, то длина записи, заданная `RecordLength` параметром `FileOpen` в функции, должна быть больше или равна сумме всех байтов, необходимых для записи данных массива и дескриптора массива. Дескриптор задает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс в 8 раз больше, чем число измерений: 2 + 8 * Нумберофдименсионс.  
  
     Например, следующее объявление массива требует 218 байт при запись массива на диск:  
  
     [!code-vb[VbVbalrCatRef#27](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#27)]  
  
     218 байт распределяются следующим образом: 18 байт для дескриптора (2 + 8 * 2) и 100 байт для данных (5 * 10 * 4).  
  
-   `FileGetObject`считывает элементы структур так, как если бы они были считаны по отдельности, за исключением отсутствия заполнения между элементами. На диске динамический массив в определяемом пользователем типе (записанном с помощью `FilePutObject`) предваряется дескриптором, длина которого равна 2 плюс в 8 раз больше числа измерений: 2 + 8 * Нумберофдименсионс. Длина записи, заданная `RecordLength` предложением `FileOpen` в функции, должна быть больше или равна сумме всех байтов, необходимых для чтения отдельных элементов, включая массивы и их дескрипторы. <xref:Microsoft.VisualBasic.VBFixedStringAttribute> Класс может применяться к строковым полям в структурах для указания размера строки при их запись на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых `Binary` в режиме, применяются все `Random` правила, за исключением следующих:  
  
-   `RecordLength` Предложение`FileOpen` в функции не оказывает никакого влияния. `FileGetObject`считывает все переменные с диска непрерывно, то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре, `FileGetObject` считывает только данные. Дескриптор не читается.  
  
 `FileGetObject`считывает строки переменной длины, которые не являются элементами структур, без ожидания дескриптора длины в 2 байта. Число считанных байтов равно числу символов, уже надаваемыхся в строке.  
  
> [!IMPORTANT]
>  При чтении из файлов не следует принимать решения о содержимом файла на основе расширения имени файла. Например, файл с именем Form1. vb не может быть Visual Basic исходным файлом.  
  
   
  
## Examples  
 В следующем примере запись считывается в файл теста, а затем извлекается.  
  
 [!code-vb[VbVbalrCatRef#26](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#26)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Чтение из файлов в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileLen">
      <MemberSignature Language="C#" Value="public static long FileLen (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 FileLen(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileLen (PathName As String) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long FileLen(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileLen : string -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.FileLen PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Обязательный. Строковое выражение, которое определяет файл. <paramref name="PathName" /> — может включать каталог или папку, а также имя диска.</param>
        <summary>Возвращает значение, которое указывает длину файла в байтах. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FileLen" />. Для получения дополнительной информации см. <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</summary>
        <returns>Длина файла в байтах.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если указанный файл открыт при `FileLen` вызове функции, возвращаемое значение представляет размер файла во время его открытия.  
  
> [!NOTE]
>  Чтобы получить текущую длину открытого файла, используйте `LOF` функцию.  
  
   
  
## Examples  
 В этом примере `FileLen` функция используется для возврата длины файла в байтах. В этом примере предполагается, что `TestFile` — это файл, содержащий некоторые данные.  
  
 [!code-vb[VbVbalrCatRef#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Файл не существует.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileOpen">
      <MemberSignature Language="C#" Value="public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileOpen(int32 FileNumber, string FileName, valuetype Microsoft.VisualBasic.OpenMode Mode, valuetype Microsoft.VisualBasic.OpenAccess Access, valuetype Microsoft.VisualBasic.OpenShare Share, int32 RecordLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileOpen (FileNumber As Integer, FileName As String, Mode As OpenMode, Optional Access As OpenAccess = Microsoft.VisualBasic.OpenAccess.Default, Optional Share As OpenShare = Microsoft.VisualBasic.OpenShare.Default, Optional RecordLength As Integer = -1)" />
      <MemberSignature Language="F#" Value="static member FileOpen : int * string * Microsoft.VisualBasic.OpenMode * Microsoft.VisualBasic.OpenAccess * Microsoft.VisualBasic.OpenShare * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileOpen (FileNumber, FileName, Mode, Access, Share, RecordLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FileName" Type="System.String" />
        <Parameter Name="Mode" Type="Microsoft.VisualBasic.OpenMode" />
        <Parameter Name="Access" Type="Microsoft.VisualBasic.OpenAccess" />
        <Parameter Name="Share" Type="Microsoft.VisualBasic.OpenShare" />
        <Parameter Name="RecordLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла. Для получения следующего свободного номера файла следует использовать функцию <see langword="FreeFile" />.</param>
        <param name="FileName">Обязательный. Строковое выражение, которое указывает имя файла. Может включать имя каталога или папки, а также имя диска.</param>
        <param name="Mode">Обязательный. Перечисление, определяющее режим файла: <see langword="Append" />, <see langword="Binary" />, <see langword="Input" />, <see langword="Output" /> или <see langword="Random" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.OpenMode" />.</param>
        <param name="Access">Необязательный параметр. Перечисление, определяющие операции, разрешенные для работы с открытым файлом: <see langword="Read" />, <see langword="Write" /> или <see langword="ReadWrite" />. По умолчанию — <see langword="ReadWrite" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.OpenAccess" />.</param>
        <param name="Share">Необязательный параметр. Перечисление операций, не разрешенных при работе с файлом, открытым другим процессом: <see langword="Shared" />, <see langword="Lock Read" />, <see langword="Lock Write" /> и <see langword="Lock Read Write" />. По умолчанию — <see langword="Lock Read Write" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.OpenShare" />.</param>
        <param name="RecordLength">Необязательный параметр. Число, не превышающее 32 767 (байт). Для файлов, открытых с произвольным доступом, это значение является длиной записи. Для файлов с последовательным доступом — это число знаков в буфере.</param>
        <summary>Открывает файл для ввода или вывода. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FileOpen" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileOpen` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, не использующих `My.Computer.FileSystem` устаревшие версии, объект обеспечивает лучшую производительность. Дополнительные сведения см. [в разделе доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Файл необходимо открыть перед выполнением любой операции ввода-вывода. `FileOpen`выделяет буфер для ввода-вывода в файл и определяет режим доступа для использования с буфером.  
  
> [!IMPORTANT]
>  При записи в файл приложению может потребоваться создать файл, если файл, в который он пытается выполнить запись, не существует. Для этого ему требуется разрешение для каталога, в котором будет создан файл. Однако если файл, указанный параметром `FileName` , существует, приложению требуется `Write` разрешение только для самого файла. Там, где это возможно, для повышения безопасности создайте файл во время развертывания и `Write` предоставьте разрешение только для этого файла, а не для всего каталога. Чтобы улучшить безопасность, запишите данные в каталоги пользователей, а не в корневой каталог или каталог Program Files.  
  
 Открываемый канал можно найти с помощью `FreeFile()` функции.  
  
> [!IMPORTANT]
>  Функции требуется `Read` доступ из`FileIOPermissionAccess` перечисления, что может повлиять на его выполнение в ситуациях с частичным доверием. `FileOpen` Дополнительные сведения см. в <xref:System.Security.Permissions.FileIOPermissionAccess> разделе Enumeration.  
  
   
  
## Examples  
 В этом примере показаны различные способы использования `FileOpen` функции для включения ввода и вывода в файл.  
  
 Следующий код открывает файл `TestFile` в `Input` режиме.  
  
 [!code-vb[VbVbalrCatRef#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#5)]  
  
 В этом примере файл открывается в `Binary` режиме только для записи операций.  
  
 [!code-vb[VbVbalrCatRef#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#6)]  
  
 В следующем примере файл открывается в `Random` режиме. Файл содержит записи структуры `Person`.  
  
 [!code-vb[VbVbalrCatRef#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#7)]  
  
 Этот пример кода открывает файл в `Output` режиме. любой процесс может выполнять чтение или запись в файл.  
  
 [!code-vb[VbVbalrCatRef#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#8)]  
  
 Этот пример кода открывает файл в `Binary` режиме чтения; другие процессы не могут считать файл.  
  
 [!code-vb[VbVbalrCatRef#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Отрицательная длина записи (не равная –1).</exception>
        <exception cref="T:System.IO.IOException">Файл <paramref name="FileName" /> уже открыт, или <paramref name="FileName" /> является недопустимым.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Чтение из файлов в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FilePut">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Записывает значения переменных в файл на диске. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FilePut" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, bool Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * bool * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, содержащей данные для записи на диск.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы, открытые в режиме <see langword="Random" />) или номер байта (файлы, открытые в режиме <see langword="Binary" />), с которого начинается запись.</param>
        <summary>Записывает значения переменных в файл на диске. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FilePut" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`Допустим только в `Random` режиме и `Binary` .  
  
 Данные, записанные с использованием `FilePut`, обычно считываются с помощью `FileGet`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт — на позиции 2 и т. д. Если опустить `RecordNumber`, записывается следующая запись или байт после последней `FileGet` функции `FilePut` или, на которую указывает последняя `Seek` функция.  
  
 `StringIsFixedLength` Аргумент определяет, интерпретирует ли функция строки как переменную или фиксированную длину. `FilePut`не записывает дескриптор длины, если аргумент имеет `True`значение. `StringIsFixedLength` При использовании  =  с в необходимо выполнить те же действия с `FileGet`, а также убедиться, что строка инициализируется с ожидаемой длиной. `FilePut` `True`  
  
## <a name="random-mode"></a>Произвольный режим  
 Для файлов, открытых `Random` в режиме, применяются следующие правила.  
  
-   Если длина записываемых данных меньше длины, указанной в `RecordLength` предложении `FileOpen` функции, `FilePut` записывает последующие записи на границах записи. Пространство между концом одной записи и началом следующей записи дополняется существующим содержимым файлового буфера. Поскольку объем данных заполнения не может быть определен точно, обычно рекомендуется, чтобы длина записи соответствовала длине записываемых данных. Если длина записываемых данных превышает длину, указанную в `RecordLength` предложении `FileOpen` функции, будет создано исключение.  
  
-   Если записываемая переменная является строкой, `FilePut` записывает двухбайтовый дескриптор, содержащий длину строки, а затем записывает данные, которые попадают в переменную. Таким образом, длина записи, заданная `RecordLength` предложением `FileOpen` в функции, должна быть как минимум на два байта больше, чем фактическая длина строки.  
  
-   Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, `VarType` идентифицирующие объект, а затем записывает переменную. Например, при записи объекта, содержащего целое число, `FilePut` записывается шесть байт: два байта, которые обозначают объект как `VarType(3)` (`Integer`), и четыре байта, содержащие данные. Длина записи, `RecordLength` заданная параметром `FileOpen` в функции, должна быть как минимум на два байта больше фактического числа байтов, необходимого для хранения переменной.  
  
-   Если записываемая переменная является объектом, содержащим строку, `FilePut` записывается двухбайтовый дескриптор `VarType(8)` объекта, двухбайтовый дескриптор, указывающий длину строки, и затем записывает строковые данные. Длина записи, `RecordLength` заданная параметром `FileOpen` в функции, должна быть не менее четырех байтов, превышающих фактическую длину строки. Если нужно поместить строку без дескриптора, следует передать `True` `StringIsFixedLength` параметр, а строка, в которую считываются строки, должна иметь правильную длину.  
  
-   Если записываемая переменная является массивом, можно выбрать, следует ли записывать дескриптор размера и размеров массива. Visual Basic 6,0 и более ранние версии записывают дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию не записывает дескриптор. Чтобы записать дескриптор, присвойте `ArrayIsDynamic` `True`параметру значение. При записи массива необходимо точно соответствовать способу чтения массива. Если он будет считан с дескриптора, необходимо написать дескриптор. Дескриптор задает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс в 8 раз больше, чем число измерений: (2 + 8 * Нумберофдименсионс). Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна сумме всех байтов, необходимых для записи данных массива и дескриптора массива. Например, следующее объявление массива требует 218 байт при записье массива на диск.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Если записываемая переменная является любым другим типом переменной (а не строкой переменной длины или объектом), `FilePut` записывает только данные переменной. Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна длине записываемых данных.  
  
-   `FilePut`записывает элементы структур, как если бы они были записаны по отдельности, за исключением того, что между элементами нет заполнения. `VBFixedString` Атрибут может применяться к строковым полям в структурах для указания размера строки при ее запись на диск.  
  
    > [!NOTE]
    >  Строковые поля с большим числом байтов, чем `VBFixedString` указано в атрибуте, усекаются при запись на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых `Binary` в режиме, применяются большинство `Random` правил режима с некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме, отличаются от правил для `Random` режима:  
  
-   `RecordLength` Предложение`FileOpen` в функции не оказывает никакого влияния. `FilePut`Записывает все переменные на диск последовательно, то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре, `FilePut` записывает только данные. Дескриптор не записывается.  
  
-   `FilePut`записывает строки переменной длины, которые не являются элементами структур, без дескриптора длины в 2 байта. Число записанных байтов равно числу символов в строке. Например, следующие инструкции записывают 11 байт в номер файла 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Для записи в файл с помощью `FilePut` функции требуется `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере `FilePut` функция используется для записи данных в файл. В файл записываются `Person` пять записей структуры.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, unsigned int8 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * byte * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, содержащей данные для записи на диск.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы, открытые в режиме <see langword="Random" />) или номер байта (файлы, открытые в режиме <see langword="Binary" />), с которого начинается запись.</param>
        <summary>Записывает значения переменных в файл на диске. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FilePut" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`Допустим только в `Random` режиме и `Binary` .  
  
 Данные, записанные с использованием `FilePut`, обычно считываются с помощью `FileGet`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт — на позиции 2 и т. д. Если опустить `RecordNumber`, записывается следующая запись или байт после последней `FileGet` функции `FilePut` или, на которую указывает последняя `Seek` функция.  
  
 `StringIsFixedLength` Аргумент определяет, интерпретирует ли функция строки как переменную или фиксированную длину. `FilePut`не записывает дескриптор длины, если аргумент имеет `True`значение. `StringIsFixedLength` При использовании  =  с в необходимо выполнить те же действия с `FileGet`, а также убедиться, что строка инициализируется с ожидаемой длиной. `FilePut` `True`  
  
## <a name="random-mode"></a>Произвольный режим  
 Для файлов, открытых `Random` в режиме, применяются следующие правила.  
  
-   Если длина записываемых данных меньше длины, указанной в `RecordLength` предложении `FileOpen` функции, `FilePut` записывает последующие записи на границах записи. Пространство между концом одной записи и началом следующей записи дополняется существующим содержимым файлового буфера. Поскольку объем данных заполнения не может быть определен точно, обычно рекомендуется, чтобы длина записи соответствовала длине записываемых данных. Если длина записываемых данных превышает длину, указанную в `RecordLength` предложении `FileOpen` функции, будет создано исключение.  
  
-   Если записываемая переменная является строкой, `FilePut` записывает двухбайтовый дескриптор, содержащий длину строки, а затем записывает данные, которые попадают в переменную. Таким образом, длина записи, заданная `RecordLength` предложением `FileOpen` в функции, должна быть как минимум на два байта больше, чем фактическая длина строки.  
  
-   Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, `VarType` идентифицирующие объект, а затем записывает переменную. Например, при записи объекта, содержащего целое число, `FilePut` записывается шесть байт: два байта, которые обозначают объект как `VarType(3)` (`Integer`), и четыре байта, содержащие данные. Длина записи, `RecordLength` заданная параметром `FileOpen` в функции, должна быть как минимум на два байта больше фактического числа байтов, необходимого для хранения переменной.  
  
-   Если записываемая переменная является объектом, содержащим строку, `FilePut` записывается двухбайтовый дескриптор `VarType(8)` объекта, двухбайтовый дескриптор, указывающий длину строки, и затем записывает строковые данные. Длина записи, `RecordLength` заданная параметром `FileOpen` в функции, должна быть не менее четырех байтов, превышающих фактическую длину строки. Если нужно поместить строку без дескриптора, следует передать `True` `StringIsFixedLength` параметр, а строка, в которую считываются строки, должна иметь правильную длину.  
  
-   Если записываемая переменная является массивом, можно выбрать, следует ли записывать дескриптор размера и размеров массива. Visual Basic 6,0 и более ранние версии записывают дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию не записывает дескриптор. Чтобы записать дескриптор, присвойте `ArrayIsDynamic` `True`параметру значение. При записи массива необходимо точно соответствовать способу чтения массива. Если он будет считан с дескриптора, необходимо написать дескриптор. Дескриптор задает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс в 8 раз больше, чем число измерений: (2 + 8 * Нумберофдименсионс). Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна сумме всех байтов, необходимых для записи данных массива и дескриптора массива. Например, следующее объявление массива требует 218 байт при записье массива на диск.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Если записываемая переменная является любым другим типом переменной (а не строкой переменной длины или объектом), `FilePut` записывает только данные переменной. Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна длине записываемых данных.  
  
-   `FilePut`записывает элементы структур, как если бы они были записаны по отдельности, за исключением того, что между элементами нет заполнения. `VBFixedString` Атрибут может применяться к строковым полям в структурах для указания размера строки при ее запись на диск.  
  
    > [!NOTE]
    >  Строковые поля с большим числом байтов, чем `VBFixedString` указано в атрибуте, усекаются при запись на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых `Binary` в режиме, применяются большинство `Random` правил режима с некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме, отличаются от правил для `Random` режима:  
  
-   `RecordLength` Предложение`FileOpen` в функции не оказывает никакого влияния. `FilePut`Записывает все переменные на диск последовательно, то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре, `FilePut` записывает только данные. Дескриптор не записывается.  
  
-   `FilePut`записывает строки переменной длины, которые не являются элементами структур, без дескриптора длины в 2 байта. Число записанных байтов равно числу символов в строке. Например, следующие инструкции записывают 11 байт в номер файла 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Для записи в файл с помощью `FilePut` функции требуется `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере `FilePut` функция используется для записи данных в файл. В файл записываются `Person` пять записей структуры.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, char Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * char * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, содержащей данные для записи на диск.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы, открытые в режиме <see langword="Random" />) или номер байта (файлы, открытые в режиме <see langword="Binary" />), с которого начинается запись.</param>
        <summary>Записывает значения переменных в файл на диске. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FilePut" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`Допустим только в `Random` режиме и `Binary` .  
  
 Данные, записанные с использованием `FilePut`, обычно считываются с помощью `FileGet`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт — на позиции 2 и т. д. Если опустить `RecordNumber`, записывается следующая запись или байт после последней `FileGet` функции `FilePut` или, на которую указывает последняя `Seek` функция.  
  
 `StringIsFixedLength` Аргумент определяет, интерпретирует ли функция строки как переменную или фиксированную длину. `FilePut`не записывает дескриптор длины, если аргумент имеет `True`значение. `StringIsFixedLength` При использовании  =  с в необходимо выполнить те же действия с `FileGet`, а также убедиться, что строка инициализируется с ожидаемой длиной. `FilePut` `True`  
  
## <a name="random-mode"></a>Произвольный режим  
 Для файлов, открытых `Random` в режиме, применяются следующие правила.  
  
-   Если длина записываемых данных меньше длины, указанной в `RecordLength` предложении `FileOpen` функции, `FilePut` записывает последующие записи на границах записи. Пространство между концом одной записи и началом следующей записи дополняется существующим содержимым файлового буфера. Поскольку объем данных заполнения не может быть определен точно, обычно рекомендуется, чтобы длина записи соответствовала длине записываемых данных. Если длина записываемых данных превышает длину, указанную в `RecordLength` предложении `FileOpen` функции, будет создано исключение.  
  
-   Если записываемая переменная является строкой, `FilePut` записывает двухбайтовый дескриптор, содержащий длину строки, а затем записывает данные, которые попадают в переменную. Таким образом, длина записи, заданная `RecordLength` предложением `FileOpen` в функции, должна быть как минимум на два байта больше, чем фактическая длина строки.  
  
-   Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, `VarType` идентифицирующие объект, а затем записывает переменную. Например, при записи объекта, содержащего целое число, `FilePut` записывается шесть байт: два байта, которые обозначают объект как `VarType(3)` (`Integer`), и четыре байта, содержащие данные. Длина записи, `RecordLength` заданная параметром `FileOpen` в функции, должна быть как минимум на два байта больше фактического числа байтов, необходимого для хранения переменной.  
  
-   Если записываемая переменная является объектом, содержащим строку, `FilePut` записывается двухбайтовый дескриптор `VarType(8)` объекта, двухбайтовый дескриптор, указывающий длину строки, и затем записывает строковые данные. Длина записи, `RecordLength` заданная параметром `FileOpen` в функции, должна быть не менее четырех байтов, превышающих фактическую длину строки. Если нужно поместить строку без дескриптора, следует передать `True` `StringIsFixedLength` параметр, а строка, в которую считываются строки, должна иметь правильную длину.  
  
-   Если записываемая переменная является массивом, можно выбрать, следует ли записывать дескриптор размера и размеров массива. Visual Basic 6,0 и более ранние версии записывают дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию не записывает дескриптор. Чтобы записать дескриптор, присвойте `ArrayIsDynamic` `True`параметру значение. При записи массива необходимо точно соответствовать способу чтения массива. Если он будет считан с дескриптора, необходимо написать дескриптор. Дескриптор задает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс в 8 раз больше, чем число измерений: (2 + 8 * Нумберофдименсионс). Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна сумме всех байтов, необходимых для записи данных массива и дескриптора массива. Например, следующее объявление массива требует 218 байт при записье массива на диск.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Если записываемая переменная является любым другим типом переменной (а не строкой переменной длины или объектом), `FilePut` записывает только данные переменной. Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна длине записываемых данных.  
  
-   `FilePut`записывает элементы структур, как если бы они были записаны по отдельности, за исключением того, что между элементами нет заполнения. `VBFixedString` Атрибут может применяться к строковым полям в структурах для указания размера строки при ее запись на диск.  
  
    > [!NOTE]
    >  Строковые поля с большим числом байтов, чем `VBFixedString` указано в атрибуте, усекаются при запись на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых `Binary` в режиме, применяются большинство `Random` правил режима с некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме, отличаются от правил для `Random` режима:  
  
-   `RecordLength` Предложение`FileOpen` в функции не оказывает никакого влияния. `FilePut`Записывает все переменные на диск последовательно, то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре, `FilePut` записывает только данные. Дескриптор не записывается.  
  
-   `FilePut`записывает строки переменной длины, которые не являются элементами структур, без дескриптора длины в 2 байта. Число записанных байтов равно числу символов в строке. Например, следующие инструкции записывают 11 байт в номер файла 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Для записи в файл с помощью `FilePut` функции требуется `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере `FilePut` функция используется для записи данных в файл. В файл записываются `Person` пять записей структуры.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.DateTime Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * DateTime * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, содержащей данные для записи на диск.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы, открытые в режиме <see langword="Random" />) или номер байта (файлы, открытые в режиме <see langword="Binary" />), с которого начинается запись.</param>
        <summary>Записывает значения переменных в файл на диске. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FilePut" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`Допустим только в `Random` режиме и `Binary` .  
  
 Данные, записанные с использованием `FilePut`, обычно считываются с помощью `FileGet`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт — на позиции 2 и т. д. Если опустить `RecordNumber`, записывается следующая запись или байт после последней `FileGet` функции `FilePut` или, на которую указывает последняя `Seek` функция.  
  
 `StringIsFixedLength` Аргумент определяет, интерпретирует ли функция строки как переменную или фиксированную длину. `FilePut`не записывает дескриптор длины, если аргумент имеет `True`значение. `StringIsFixedLength` При использовании  =  с в необходимо выполнить те же действия с `FileGet`, а также убедиться, что строка инициализируется с ожидаемой длиной. `FilePut` `True`  
  
## <a name="random-mode"></a>Произвольный режим  
 Для файлов, открытых `Random` в режиме, применяются следующие правила.  
  
-   Если длина записываемых данных меньше длины, указанной в `RecordLength` предложении `FileOpen` функции, `FilePut` записывает последующие записи на границах записи. Пространство между концом одной записи и началом следующей записи дополняется существующим содержимым файлового буфера. Поскольку объем данных заполнения не может быть определен точно, обычно рекомендуется, чтобы длина записи соответствовала длине записываемых данных. Если длина записываемых данных превышает длину, указанную в `RecordLength` предложении `FileOpen` функции, будет создано исключение.  
  
-   Если записываемая переменная является строкой, `FilePut` записывает двухбайтовый дескриптор, содержащий длину строки, а затем записывает данные, которые попадают в переменную. Таким образом, длина записи, заданная `RecordLength` предложением `FileOpen` в функции, должна быть как минимум на два байта больше, чем фактическая длина строки.  
  
-   Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, `VarType` идентифицирующие объект, а затем записывает переменную. Например, при записи объекта, содержащего целое число, `FilePut` записывается шесть байт: два байта, которые обозначают объект как `VarType(3)` (`Integer`), и четыре байта, содержащие данные. Длина записи, `RecordLength` заданная параметром `FileOpen` в функции, должна быть как минимум на два байта больше фактического числа байтов, необходимого для хранения переменной.  
  
-   Если записываемая переменная является объектом, содержащим строку, `FilePut` записывается двухбайтовый дескриптор `VarType(8)` объекта, двухбайтовый дескриптор, указывающий длину строки, и затем записывает строковые данные. Длина записи, `RecordLength` заданная параметром `FileOpen` в функции, должна быть не менее четырех байтов, превышающих фактическую длину строки. Если нужно поместить строку без дескриптора, следует передать `True` `StringIsFixedLength` параметр, а строка, в которую считываются строки, должна иметь правильную длину.  
  
-   Если записываемая переменная является массивом, можно выбрать, следует ли записывать дескриптор размера и размеров массива. Visual Basic 6,0 и более ранние версии записывают дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию не записывает дескриптор. Чтобы записать дескриптор, присвойте `ArrayIsDynamic` `True`параметру значение. При записи массива необходимо точно соответствовать способу чтения массива. Если он будет считан с дескриптора, необходимо написать дескриптор. Дескриптор задает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс в 8 раз больше, чем число измерений: (2 + 8 * Нумберофдименсионс). Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна сумме всех байтов, необходимых для записи данных массива и дескриптора массива. Например, следующее объявление массива требует 218 байт при записье массива на диск.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Если записываемая переменная является любым другим типом переменной (а не строкой переменной длины или объектом), `FilePut` записывает только данные переменной. Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна длине записываемых данных.  
  
-   `FilePut`записывает элементы структур, как если бы они были записаны по отдельности, за исключением того, что между элементами нет заполнения. `VBFixedString` Атрибут может применяться к строковым полям в структурах для указания размера строки при ее запись на диск.  
  
    > [!NOTE]
    >  Строковые поля с большим числом байтов, чем `VBFixedString` указано в атрибуте, усекаются при запись на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых `Binary` в режиме, применяются большинство `Random` правил режима с некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме, отличаются от правил для `Random` режима:  
  
-   `RecordLength` Предложение`FileOpen` в функции не оказывает никакого влияния. `FilePut`Записывает все переменные на диск последовательно, то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре, `FilePut` записывает только данные. Дескриптор не записывается.  
  
-   `FilePut`записывает строки переменной длины, которые не являются элементами структур, без дескриптора длины в 2 байта. Число записанных байтов равно числу символов в строке. Например, следующие инструкции записывают 11 байт в номер файла 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Для записи в файл с помощью `FilePut` функции требуется `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере `FilePut` функция используется для записи данных в файл. В файл записываются `Person` пять записей структуры.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.Decimal Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * decimal * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, содержащей данные для записи на диск.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы, открытые в режиме <see langword="Random" />) или номер байта (файлы, открытые в режиме <see langword="Binary" />), с которого начинается запись.</param>
        <summary>Записывает значения переменных в файл на диске. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FilePut" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`Допустим только в `Random` режиме и `Binary` .  
  
 Данные, записанные с использованием `FilePut`, обычно считываются с помощью `FileGet`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт — на позиции 2 и т. д. Если опустить `RecordNumber`, записывается следующая запись или байт после последней `FileGet` функции `FilePut` или, на которую указывает последняя `Seek` функция.  
  
 `StringIsFixedLength` Аргумент определяет, интерпретирует ли функция строки как переменную или фиксированную длину. `FilePut`не записывает дескриптор длины, если аргумент имеет `True`значение. `StringIsFixedLength` При использовании  =  с в необходимо выполнить те же действия с `FileGet`, а также убедиться, что строка инициализируется с ожидаемой длиной. `FilePut` `True`  
  
## <a name="random-mode"></a>Произвольный режим  
 Для файлов, открытых `Random` в режиме, применяются следующие правила.  
  
-   Если длина записываемых данных меньше длины, указанной в `RecordLength` предложении `FileOpen` функции, `FilePut` записывает последующие записи на границах записи. Пространство между концом одной записи и началом следующей записи дополняется существующим содержимым файлового буфера. Поскольку объем данных заполнения не может быть определен точно, обычно рекомендуется, чтобы длина записи соответствовала длине записываемых данных. Если длина записываемых данных превышает длину, указанную в `RecordLength` предложении `FileOpen` функции, будет создано исключение.  
  
-   Если записываемая переменная является строкой, `FilePut` записывает двухбайтовый дескриптор, содержащий длину строки, а затем записывает данные, которые попадают в переменную. Таким образом, длина записи, заданная `RecordLength` предложением `FileOpen` в функции, должна быть как минимум на два байта больше, чем фактическая длина строки.  
  
-   Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, `VarType` идентифицирующие объект, а затем записывает переменную. Например, при записи объекта, содержащего целое число, `FilePut` записывается шесть байт: два байта, которые обозначают объект как `VarType(3)` (`Integer`), и четыре байта, содержащие данные. Длина записи, `RecordLength` заданная параметром `FileOpen` в функции, должна быть как минимум на два байта больше фактического числа байтов, необходимого для хранения переменной.  
  
-   Если записываемая переменная является объектом, содержащим строку, `FilePut` записывается двухбайтовый дескриптор `VarType(8)` объекта, двухбайтовый дескриптор, указывающий длину строки, и затем записывает строковые данные. Длина записи, `RecordLength` заданная параметром `FileOpen` в функции, должна быть не менее четырех байтов, превышающих фактическую длину строки. Если нужно поместить строку без дескриптора, следует передать `True` `StringIsFixedLength` параметр, а строка, в которую считываются строки, должна иметь правильную длину.  
  
-   Если записываемая переменная является массивом, можно выбрать, следует ли записывать дескриптор размера и размеров массива. Visual Basic 6,0 и более ранние версии записывают дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию не записывает дескриптор. Чтобы записать дескриптор, присвойте `ArrayIsDynamic` `True`параметру значение. При записи массива необходимо точно соответствовать способу чтения массива. Если он будет считан с дескриптора, необходимо написать дескриптор. Дескриптор задает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс в 8 раз больше, чем число измерений: (2 + 8 * Нумберофдименсионс). Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна сумме всех байтов, необходимых для записи данных массива и дескриптора массива. Например, следующее объявление массива требует 218 байт при записье массива на диск.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Если записываемая переменная является любым другим типом переменной (а не строкой переменной длины или объектом), `FilePut` записывает только данные переменной. Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна длине записываемых данных.  
  
-   `FilePut`записывает элементы структур, как если бы они были записаны по отдельности, за исключением того, что между элементами нет заполнения. `VBFixedString` Атрибут может применяться к строковым полям в структурах для указания размера строки при ее запись на диск.  
  
    > [!NOTE]
    >  Строковые поля с большим числом байтов, чем `VBFixedString` указано в атрибуте, усекаются при запись на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых `Binary` в режиме, применяются большинство `Random` правил режима с некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме, отличаются от правил для `Random` режима:  
  
-   `RecordLength` Предложение`FileOpen` в функции не оказывает никакого влияния. `FilePut`Записывает все переменные на диск последовательно, то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре, `FilePut` записывает только данные. Дескриптор не записывается.  
  
-   `FilePut`записывает строки переменной длины, которые не являются элементами структур, без дескриптора длины в 2 байта. Число записанных байтов равно числу символов в строке. Например, следующие инструкции записывают 11 байт в номер файла 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Для записи в файл с помощью `FilePut` функции требуется `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере `FilePut` функция используется для записи данных в файл. В файл записываются `Person` пять записей структуры.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * double * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, содержащей данные для записи на диск.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы, открытые в режиме <see langword="Random" />) или номер байта (файлы, открытые в режиме <see langword="Binary" />), с которого начинается запись.</param>
        <summary>Записывает значения переменных в файл на диске. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FilePut" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`Допустим только в `Random` режиме и `Binary` .  
  
 Данные, записанные с использованием `FilePut`, обычно считываются с помощью `FileGet`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт — на позиции 2 и т. д. Если опустить `RecordNumber`, записывается следующая запись или байт после последней `FileGet` функции `FilePut` или, на которую указывает последняя `Seek` функция.  
  
 `StringIsFixedLength` Аргумент определяет, интерпретирует ли функция строки как переменную или фиксированную длину. `FilePut`не записывает дескриптор длины, если аргумент имеет `True`значение. `StringIsFixedLength` При использовании  =  с в необходимо выполнить те же действия с `FileGet`, а также убедиться, что строка инициализируется с ожидаемой длиной. `FilePut` `True`  
  
## <a name="random-mode"></a>Произвольный режим  
 Для файлов, открытых `Random` в режиме, применяются следующие правила.  
  
-   Если длина записываемых данных меньше длины, указанной в `RecordLength` предложении `FileOpen` функции, `FilePut` записывает последующие записи на границах записи. Пространство между концом одной записи и началом следующей записи дополняется существующим содержимым файлового буфера. Поскольку объем данных заполнения не может быть определен точно, обычно рекомендуется, чтобы длина записи соответствовала длине записываемых данных. Если длина записываемых данных превышает длину, указанную в `RecordLength` предложении `FileOpen` функции, будет создано исключение.  
  
-   Если записываемая переменная является строкой, `FilePut` записывает двухбайтовый дескриптор, содержащий длину строки, а затем записывает данные, которые попадают в переменную. Таким образом, длина записи, заданная `RecordLength` предложением `FileOpen` в функции, должна быть как минимум на два байта больше, чем фактическая длина строки.  
  
-   Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, `VarType` идентифицирующие объект, а затем записывает переменную. Например, при записи объекта, содержащего целое число, `FilePut` записывается шесть байт: два байта, которые обозначают объект как `VarType(3)` (`Integer`), и четыре байта, содержащие данные. Длина записи, `RecordLength` заданная параметром `FileOpen` в функции, должна быть как минимум на два байта больше фактического числа байтов, необходимого для хранения переменной.  
  
-   Если записываемая переменная является объектом, содержащим строку, `FilePut` записывается двухбайтовый дескриптор `VarType(8)` объекта, двухбайтовый дескриптор, указывающий длину строки, и затем записывает строковые данные. Длина записи, `RecordLength` заданная параметром `FileOpen` в функции, должна быть не менее четырех байтов, превышающих фактическую длину строки. Если нужно поместить строку без дескриптора, следует передать `True` `StringIsFixedLength` параметр, а строка, в которую считываются строки, должна иметь правильную длину.  
  
-   Если записываемая переменная является массивом, можно выбрать, следует ли записывать дескриптор размера и размеров массива. Visual Basic 6,0 и более ранние версии записывают дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию не записывает дескриптор. Чтобы записать дескриптор, присвойте `ArrayIsDynamic` `True`параметру значение. При записи массива необходимо точно соответствовать способу чтения массива. Если он будет считан с дескриптора, необходимо написать дескриптор. Дескриптор задает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс в 8 раз больше, чем число измерений: (2 + 8 * Нумберофдименсионс). Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна сумме всех байтов, необходимых для записи данных массива и дескриптора массива. Например, следующее объявление массива требует 218 байт при записье массива на диск.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Если записываемая переменная является любым другим типом переменной (а не строкой переменной длины или объектом), `FilePut` записывает только данные переменной. Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна длине записываемых данных.  
  
-   `FilePut`записывает элементы структур, как если бы они были записаны по отдельности, за исключением того, что между элементами нет заполнения. `VBFixedString` Атрибут может применяться к строковым полям в структурах для указания размера строки при ее запись на диск.  
  
    > [!NOTE]
    >  Строковые поля с большим числом байтов, чем `VBFixedString` указано в атрибуте, усекаются при запись на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых `Binary` в режиме, применяются большинство `Random` правил режима с некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме, отличаются от правил для `Random` режима:  
  
-   `RecordLength` Предложение`FileOpen` в функции не оказывает никакого влияния. `FilePut`Записывает все переменные на диск последовательно, то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре, `FilePut` записывает только данные. Дескриптор не записывается.  
  
-   `FilePut`записывает строки переменной длины, которые не являются элементами структур, без дескриптора длины в 2 байта. Число записанных байтов равно числу символов в строке. Например, следующие инструкции записывают 11 байт в номер файла 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Для записи в файл с помощью `FilePut` функции требуется `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере `FilePut` функция используется для записи данных в файл. В файл записываются `Person` пять записей структуры.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int16 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int16 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, содержащей данные для записи на диск.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы, открытые в режиме <see langword="Random" />) или номер байта (файлы, открытые в режиме <see langword="Binary" />), с которого начинается запись.</param>
        <summary>Записывает значения переменных в файл на диске. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FilePut" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`Допустим только в `Random` режиме и `Binary` .  
  
 Данные, записанные с использованием `FilePut`, обычно считываются с помощью `FileGet`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт — на позиции 2 и т. д. Если опустить `RecordNumber`, записывается следующая запись или байт после последней `FileGet` функции `FilePut` или, на которую указывает последняя `Seek` функция.  
  
 `StringIsFixedLength` Аргумент определяет, интерпретирует ли функция строки как переменную или фиксированную длину. `FilePut`не записывает дескриптор длины, если аргумент имеет `True`значение. `StringIsFixedLength` При использовании  =  с в необходимо выполнить те же действия с `FileGet`, а также убедиться, что строка инициализируется с ожидаемой длиной. `FilePut` `True`  
  
## <a name="random-mode"></a>Произвольный режим  
 Для файлов, открытых `Random` в режиме, применяются следующие правила.  
  
-   Если длина записываемых данных меньше длины, указанной в `RecordLength` предложении `FileOpen` функции, `FilePut` записывает последующие записи на границах записи. Пространство между концом одной записи и началом следующей записи дополняется существующим содержимым файлового буфера. Поскольку объем данных заполнения не может быть определен точно, обычно рекомендуется, чтобы длина записи соответствовала длине записываемых данных. Если длина записываемых данных превышает длину, указанную в `RecordLength` предложении `FileOpen` функции, будет создано исключение.  
  
-   Если записываемая переменная является строкой, `FilePut` записывает двухбайтовый дескриптор, содержащий длину строки, а затем записывает данные, которые попадают в переменную. Таким образом, длина записи, заданная `RecordLength` предложением `FileOpen` в функции, должна быть как минимум на два байта больше, чем фактическая длина строки.  
  
-   Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, `VarType` идентифицирующие объект, а затем записывает переменную. Например, при записи объекта, содержащего целое число, `FilePut` записывается шесть байт: два байта, которые обозначают объект как `VarType(3)` (`Integer`), и четыре байта, содержащие данные. Длина записи, `RecordLength` заданная параметром `FileOpen` в функции, должна быть как минимум на два байта больше фактического числа байтов, необходимого для хранения переменной.  
  
-   Если записываемая переменная является объектом, содержащим строку, `FilePut` записывается двухбайтовый дескриптор`VarType(8)` объекта, двухбайтовый дескриптор, указывающий длину строки, и затем записывает строковые данные. Длина записи, `RecordLength` заданная параметром `FileOpen` в функции, должна быть не менее четырех байтов, превышающих фактическую длину строки. Если нужно поместить строку без дескриптора, следует передать `True` `StringIsFixedLength` параметр, а строка, в которую считываются строки, должна иметь правильную длину.  
  
-   Если записываемая переменная является массивом, можно выбрать, следует ли записывать дескриптор размера и размеров массива. Visual Basic 6,0 и более ранние версии записывают дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию не записывает дескриптор. Чтобы записать дескриптор, присвойте `ArrayIsDynamic` `True`параметру значение. При записи массива необходимо точно соответствовать способу чтения массива. Если он будет считан с дескриптора, необходимо написать дескриптор. Дескриптор задает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс в 8 раз больше, чем число измерений: (2 + 8 * Нумберофдименсионс). Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна сумме всех байтов, необходимых для записи данных массива и дескриптора массива. Например, следующее объявление массива требует 218 байт при записье массива на диск.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Если записываемая переменная является любым другим типом переменной (а не строкой переменной длины или объектом), `FilePut` записывает только данные переменной. Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна длине записываемых данных.  
  
-   `FilePut`записывает элементы структур, как если бы они были записаны по отдельности, за исключением того, что между элементами нет заполнения. `VBFixedString` Атрибут может применяться к строковым полям в структурах для указания размера строки при ее запись на диск.  
  
    > [!NOTE]
    >  Строковые поля с большим числом байтов, чем `VBFixedString` указано в атрибуте, усекаются при запись на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых `Binary` в режиме, применяются большинство `Random` правил режима с некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме, отличаются от правил для `Random` режима:  
  
-   `RecordLength` Предложение`FileOpen` в функции не оказывает никакого влияния. `FilePut`Записывает все переменные на диск последовательно, то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре, `FilePut` записывает только данные. Дескриптор не записывается.  
  
-   `FilePut`записывает строки переменной длины, которые не являются элементами структур, без дескриптора длины в 2 байта. Число записанных байтов равно числу символов в строке. Например, следующие инструкции записывают 11 байт в номер файла 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Для записи в файл с помощью `FilePut` функции требуется `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере `FilePut` функция используется для записи данных в файл. В файл записываются `Person` пять записей структуры.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, содержащей данные для записи на диск.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы, открытые в режиме <see langword="Random" />) или номер байта (файлы, открытые в режиме <see langword="Binary" />), с которого начинается запись.</param>
        <summary>Записывает значения переменных в файл на диске. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FilePut" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`Допустим только в `Random` режиме и `Binary` .  
  
 Данные, записанные с использованием `FilePut`, обычно считываются с помощью `FileGet`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт — на позиции 2 и т. д. Если опустить `RecordNumber`, записывается следующая запись или байт после последней `FileGet` функции `FilePut` или, на которую указывает последняя `Seek` функция.  
  
 `StringIsFixedLength` Аргумент определяет, интерпретирует ли функция строки как переменную или фиксированную длину. `FilePut`не записывает дескриптор длины, если аргумент имеет `True`значение. `StringIsFixedLength` При использовании  =  с в необходимо выполнить те же действия с `FileGet`, а также убедиться, что строка инициализируется с ожидаемой длиной. `FilePut` `True`  
  
## <a name="random-mode"></a>Произвольный режим  
 Для файлов, открытых `Random` в режиме, применяются следующие правила.  
  
-   Если длина записываемых данных меньше длины, указанной в `RecordLength` предложении `FileOpen` функции, `FilePut` записывает последующие записи на границах записи. Пространство между концом одной записи и началом следующей записи дополняется существующим содержимым файлового буфера. Поскольку объем данных заполнения не может быть определен точно, обычно рекомендуется, чтобы длина записи соответствовала длине записываемых данных. Если длина записываемых данных превышает длину, указанную в `RecordLength` предложении `FileOpen` функции, будет создано исключение.  
  
-   Если записываемая переменная является строкой, `FilePut` записывает двухбайтовый дескриптор, содержащий длину строки, а затем записывает данные, которые попадают в переменную. Таким образом, длина записи, заданная `RecordLength` предложением `FileOpen` в функции, должна быть как минимум на два байта больше, чем фактическая длина строки.  
  
-   Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, `VarType` идентифицирующие объект, а затем записывает переменную. Например, при записи объекта, содержащего целое число, `FilePut` записывается шесть байт: два байта, которые обозначают объект как `VarType(3)` (`Integer`), и четыре байта, содержащие данные. Длина записи, `RecordLength` заданная параметром `FileOpen` в функции, должна быть как минимум на два байта больше фактического числа байтов, необходимого для хранения переменной.  
  
-   Если записываемая переменная является объектом, содержащим строку, `FilePut` записывается двухбайтовый дескриптор `VarType(8)` объекта, двухбайтовый дескриптор, указывающий длину строки, и затем записывает строковые данные. Длина записи, `RecordLength` заданная параметром `FileOpen` в функции, должна быть не менее четырех байтов, превышающих фактическую длину строки. Если нужно поместить строку без дескриптора, следует передать `True` `StringIsFixedLength` параметр, а строка, в которую считываются строки, должна иметь правильную длину.  
  
-   Если записываемая переменная является массивом, можно выбрать, следует ли записывать дескриптор размера и размеров массива. Visual Basic 6,0 и более ранние версии записывают дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию не записывает дескриптор. Чтобы записать дескриптор, присвойте `ArrayIsDynamic` `True`параметру значение. При записи массива необходимо точно соответствовать способу чтения массива. Если он будет считан с дескриптора, необходимо написать дескриптор. Дескриптор задает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс в 8 раз больше, чем число измерений: (2 + 8 * Нумберофдименсионс). Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна сумме всех байтов, необходимых для записи данных массива и дескриптора массива. Например, следующее объявление массива требует 218 байт при записье массива на диск.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Если записываемая переменная является любым другим типом переменной (а не строкой переменной длины или объектом), `FilePut` записывает только данные переменной. Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна длине записываемых данных.  
  
-   `FilePut`записывает элементы структур, как если бы они были записаны по отдельности, за исключением того, что между элементами нет заполнения. `VBFixedString` Атрибут может применяться к строковым полям в структурах для указания размера строки при ее запись на диск.  
  
    > [!NOTE]
    >  Строковые поля с большим числом байтов, чем `VBFixedString` указано в атрибуте, усекаются при запись на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых `Binary` в режиме, применяются большинство `Random` правил режима с некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме, отличаются от правил для `Random` режима:  
  
-   `RecordLength` Предложение`FileOpen` в функции не оказывает никакого влияния. `FilePut`Записывает все переменные на диск последовательно, то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре, `FilePut` записывает только данные. Дескриптор не записывается.  
  
-   `FilePut`записывает строки переменной длины, которые не являются элементами структур, без дескриптора длины в 2 байта. Число записанных байтов равно числу символов в строке. Например, следующие инструкции записывают 11 байт в номер файла 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Для записи в файл с помощью `FilePut` функции требуется `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере `FilePut` функция используется для записи данных в файл. В файл записываются `Person` пять записей структуры.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, содержащей данные для записи на диск.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы, открытые в режиме <see langword="Random" />) или номер байта (файлы, открытые в режиме <see langword="Binary" />), с которого начинается запись.</param>
        <summary>Записывает значения переменных в файл на диске. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FilePut" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`Допустим только в `Random` режиме и `Binary` .  
  
 Данные, записанные с использованием `FilePut`, обычно считываются с помощью `FileGet`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт — на позиции 2 и т. д. Если опустить `RecordNumber`, записывается следующая запись или байт после последней `FileGet` функции `FilePut` или, на которую указывает последняя `Seek` функция.  
  
 `StringIsFixedLength` Аргумент определяет, интерпретирует ли функция строки как переменную или фиксированную длину. `FilePut`не записывает дескриптор длины, если аргумент имеет `True`значение. `StringIsFixedLength` При использовании  =  с в необходимо выполнить те же действия с `FileGet`, а также убедиться, что строка инициализируется с ожидаемой длиной. `FilePut` `True`  
  
## <a name="random-mode"></a>Произвольный режим  
 Для файлов, открытых `Random` в режиме, применяются следующие правила.  
  
-   Если длина записываемых данных меньше длины, указанной в `RecordLength` предложении `FileOpen` функции, `FilePut` записывает последующие записи на границах записи. Пространство между концом одной записи и началом следующей записи дополняется существующим содержимым файлового буфера. Поскольку объем данных заполнения не может быть определен точно, обычно рекомендуется, чтобы длина записи соответствовала длине записываемых данных. Если длина записываемых данных превышает длину, указанную в `RecordLength` предложении `FileOpen` функции, будет создано исключение.  
  
-   Если записываемая переменная является строкой, `FilePut` записывает двухбайтовый дескриптор, содержащий длину строки, а затем записывает данные, которые попадают в переменную. Таким образом, длина записи, заданная `RecordLength` предложением `FileOpen` в функции, должна быть как минимум на два байта больше, чем фактическая длина строки.  
  
-   Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, `VarType` идентифицирующие объект, а затем записывает переменную. Например, при записи объекта, содержащего целое число, `FilePut` записывается шесть байт: два байта, которые обозначают объект как `VarType(3)` (`Integer`), и четыре байта, содержащие данные. Длина записи, `RecordLength` заданная параметром `FileOpen` в функции, должна быть как минимум на два байта больше фактического числа байтов, необходимого для хранения переменной.  
  
-   Если записываемая переменная является объектом, содержащим строку, `FilePut` записывается двухбайтовый дескриптор `VarType(8)` объекта, двухбайтовый дескриптор, указывающий длину строки, и затем записывает строковые данные. Длина записи, `RecordLength` заданная параметром `FileOpen` в функции, должна быть не менее четырех байтов, превышающих фактическую длину строки. Если нужно поместить строку без дескриптора, следует передать `True` `StringIsFixedLength` параметр, а строка, в которую считываются строки, должна иметь правильную длину.  
  
-   Если записываемая переменная является массивом, можно выбрать, следует ли записывать дескриптор размера и размеров массива. Visual Basic 6,0 и более ранние версии записывают дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию не записывает дескриптор. Чтобы записать дескриптор, присвойте `ArrayIsDynamic` `True`параметру значение. При записи массива необходимо точно соответствовать способу чтения массива. Если он будет считан с дескриптора, необходимо написать дескриптор. Дескриптор задает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс в 8 раз больше, чем число измерений: (2 + 8 * Нумберофдименсионс). Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна сумме всех байтов, необходимых для записи данных массива и дескриптора массива. Например, следующее объявление массива требует 218 байт при записье массива на диск.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Если записываемая переменная является любым другим типом переменной (а не строкой переменной длины или объектом), `FilePut` записывает только данные переменной. Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна длине записываемых данных.  
  
-   `FilePut`записывает элементы структур, как если бы они были записаны по отдельности, за исключением того, что между элементами нет заполнения. `VBFixedString` Атрибут может применяться к строковым полям в структурах для указания размера строки при ее запись на диск.  
  
    > [!NOTE]
    >  Строковые поля с большим числом байтов, чем `VBFixedString` указано в атрибуте, усекаются при запись на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых `Binary` в режиме, применяются большинство `Random` правил режима с некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме, отличаются от правил для `Random` режима:  
  
-   `RecordLength` Предложение`FileOpen` в функции не оказывает никакого влияния. `FilePut`Записывает все переменные на диск последовательно, то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре, `FilePut` записывает только данные. Дескриптор не записывается.  
  
-   `FilePut`записывает строки переменной длины, которые не являются элементами структур, без дескриптора длины в 2 байта. Число записанных байтов равно числу символов в строке. Например, следующие инструкции записывают 11 байт в номер файла 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Для записи в файл с помощью `FilePut` функции требуется `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере `FilePut` функция используется для записи данных в файл. В файл записываются `Person` пять записей структуры.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * single * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, содержащей данные для записи на диск.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы, открытые в режиме <see langword="Random" />) или номер байта (файлы, открытые в режиме <see langword="Binary" />), с которого начинается запись.</param>
        <summary>Записывает значения переменных в файл на диске. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FilePut" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`Допустим только в `Random` режиме и `Binary` .  
  
 Данные, записанные с использованием `FilePut`, обычно считываются с помощью `FileGet`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт — на позиции 2 и т. д. Если опустить `RecordNumber`, записывается следующая запись или байт после последней `FileGet` функции `FilePut` или, на которую указывает последняя `Seek` функция.  
  
 `StringIsFixedLength` Аргумент определяет, интерпретирует ли функция строки как переменную или фиксированную длину. `FilePut`не записывает дескриптор длины, если аргумент имеет `True`значение. `StringIsFixedLength` При использовании  =  с в необходимо выполнить те же действия с `FileGet`, а также убедиться, что строка инициализируется с ожидаемой длиной. `FilePut` `True`  
  
## <a name="random-mode"></a>Произвольный режим  
 Для файлов, открытых `Random` в режиме, применяются следующие правила.  
  
-   Если длина записываемых данных меньше длины, указанной в `RecordLength` предложении `FileOpen` функции, `FilePut` записывает последующие записи на границах записи. Пространство между концом одной записи и началом следующей записи дополняется существующим содержимым файлового буфера. Поскольку объем данных заполнения не может быть определен точно, обычно рекомендуется, чтобы длина записи соответствовала длине записываемых данных. Если длина записываемых данных превышает длину, указанную в `RecordLength` предложении `FileOpen` функции, будет создано исключение.  
  
-   Если записываемая переменная является строкой, `FilePut` записывает двухбайтовый дескриптор, содержащий длину строки, а затем записывает данные, которые попадают в переменную. Таким образом, длина записи, заданная `RecordLength` предложением `FileOpen` в функции, должна быть как минимум на два байта больше, чем фактическая длина строки.  
  
-   Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, `VarType` идентифицирующие объект, а затем записывает переменную. Например, при записи объекта, содержащего целое число, `FilePut` записывается шесть байт: два байта, которые обозначают объект как `VarType(3)` (`Integer`), и четыре байта, содержащие данные. Длина записи, `RecordLength` заданная параметром `FileOpen` в функции, должна быть как минимум на два байта больше фактического числа байтов, необходимого для хранения переменной.  
  
-   Если записываемая переменная является объектом, содержащим строку, `FilePut` записывается двухбайтовый дескриптор `VarType(8)` объекта, двухбайтовый дескриптор, указывающий длину строки, и затем записывает строковые данные. Длина записи, `RecordLength` заданная параметром `FileOpen` в функции, должна быть не менее четырех байтов, превышающих фактическую длину строки. Если нужно поместить строку без дескриптора, следует передать `True` `StringIsFixedLength` параметр, а строка, в которую считываются строки, должна иметь правильную длину.  
  
-   Если записываемая переменная является массивом, можно выбрать, следует ли записывать дескриптор размера и размеров массива. Visual Basic 6,0 и более ранние версии записывают дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию не записывает дескриптор. Чтобы записать дескриптор, присвойте `ArrayIsDynamic` `True`параметру значение. При записи массива необходимо точно соответствовать способу чтения массива. Если он будет считан с дескриптора, необходимо написать дескриптор. Дескриптор задает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс в 8 раз больше, чем число измерений: (2 + 8 * Нумберофдименсионс). Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна сумме всех байтов, необходимых для записи данных массива и дескриптора массива. Например, следующее объявление массива требует 218 байт при записье массива на диск.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Если записываемая переменная является любым другим типом переменной (а не строкой переменной длины или объектом), `FilePut` записывает только данные переменной. Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна длине записываемых данных.  
  
-   `FilePut`записывает элементы структур, как если бы они были записаны по отдельности, за исключением того, что между элементами нет заполнения. `VBFixedString` Атрибут может применяться к строковым полям в структурах для указания размера строки при ее запись на диск.  
  
    > [!NOTE]
    >  Строковые поля с большим числом байтов, чем `VBFixedString` указано в атрибуте, усекаются при запись на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых `Binary` в режиме, применяются большинство `Random` правил режима с некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме, отличаются от правил для `Random` режима:  
  
-   `RecordLength` Предложение`FileOpen` в функции не оказывает никакого влияния. `FilePut`Записывает все переменные на диск последовательно, то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре, `FilePut` записывает только данные. Дескриптор не записывается.  
  
-   `FilePut`записывает строки переменной длины, которые не являются элементами структур, без дескриптора длины в 2 байта. Число записанных байтов равно числу символов в строке. Например, следующие инструкции записывают 11 байт в номер файла 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Для записи в файл с помощью `FilePut` функции требуется `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере `FilePut` функция используется для записи данных в файл. В файл записываются `Person` пять записей структуры.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.ValueType Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * ValueType * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, содержащей данные для записи на диск.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы, открытые в режиме <see langword="Random" />) или номер байта (файлы, открытые в режиме <see langword="Binary" />), с которого начинается запись.</param>
        <summary>Записывает значения переменных в файл на диске. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FilePut" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`Допустим только в `Random` режиме и `Binary` .  
  
 Данные, записанные с использованием `FilePut`, обычно считываются с помощью `FileGet`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт — на позиции 2 и т. д. Если опустить `RecordNumber`, записывается следующая запись или байт после последней `FileGet` функции `FilePut` или, на которую указывает последняя `Seek` функция.  
  
 `StringIsFixedLength` Аргумент определяет, интерпретирует ли функция строки как переменную или фиксированную длину. `FilePut`не записывает дескриптор длины, если аргумент имеет `True`значение. `StringIsFixedLength` При использовании  =  с в необходимо выполнить те же действия с `FileGet`, а также убедиться, что строка инициализируется с ожидаемой длиной. `FilePut` `True`  
  
## <a name="random-mode"></a>Произвольный режим  
 Для файлов, открытых `Random` в режиме, применяются следующие правила.  
  
-   Если длина записываемых данных меньше длины, указанной в`RecordLength` предложении `FileOpen` функции, `FilePut` записывает последующие записи на границах записи. Пространство между концом одной записи и началом следующей записи дополняется существующим содержимым файлового буфера. Поскольку объем данных заполнения не может быть определен точно, обычно рекомендуется, чтобы длина записи соответствовала длине записываемых данных. Если длина записываемых данных превышает длину, указанную в `RecordLength` предложении `FileOpen` функции, будет создано исключение.  
  
-   Если записываемая переменная является строкой, `FilePut` записывает двухбайтовый дескриптор, содержащий длину строки, а затем записывает данные, которые попадают в переменную. Таким образом, длина записи, заданная `RecordLength` предложением `FileOpen` в функции, должна быть как минимум на два байта больше, чем фактическая длина строки.  
  
-   Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, `VarType` идентифицирующие объект, а затем записывает переменную. Например, при записи объекта, содержащего целое число, `FilePut` записывается шесть байт: два байта, которые обозначают объект как `VarType(3)` (`Integer`), и четыре байта, содержащие данные. Длина записи, `RecordLength` заданная параметром `FileOpen` в функции, должна быть как минимум на два байта больше фактического числа байтов, необходимого для хранения переменной.  
  
-   Если записываемая переменная является объектом, содержащим строку, `FilePut` записывается двухбайтовый дескриптор `VarType(8)` объекта, двухбайтовый дескриптор, указывающий длину строки, и затем записывает строковые данные. Длина записи, `RecordLength` заданная параметром `FileOpen` в функции, должна быть не менее четырех байтов, превышающих фактическую длину строки. Если нужно поместить строку без дескриптора, следует передать `True` `StringIsFixedLength` параметр, а строка, в которую считываются строки, должна иметь правильную длину.  
  
-   Если записываемая переменная является массивом, можно выбрать, следует ли записывать дескриптор размера и размеров массива. Visual Basic 6,0 и более ранние версии записывают дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию не записывает дескриптор. Чтобы записать дескриптор, присвойте `ArrayIsDynamic` `True`параметру значение. При записи массива необходимо точно соответствовать способу чтения массива. Если он будет считан с дескриптора, необходимо написать дескриптор. Дескриптор задает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс в 8 раз больше, чем число измерений: (2 + 8 * Нумберофдименсионс). Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна сумме всех байтов, необходимых для записи данных массива и дескриптора массива. Например, следующее объявление массива требует 218 байт при записье массива на диск.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Если записываемая переменная является любым другим типом переменной (а не строкой переменной длины или объектом), `FilePut` записывает только данные переменной. Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна длине записываемых данных.  
  
-   `FilePut`записывает элементы структур, как если бы они были записаны по отдельности, за исключением того, что между элементами нет заполнения. `VBFixedString` Атрибут может применяться к строковым полям в структурах для указания размера строки при ее запись на диск.  
  
    > [!NOTE]
    >  Строковые поля с большим числом байтов, чем `VBFixedString` указано в атрибуте, усекаются при запись на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых `Binary` в режиме, применяются большинство `Random` правил режима с некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме, отличаются от правил для `Random` режима:  
  
-   `RecordLength` Предложение`FileOpen` в функции не оказывает никакого влияния. `FilePut`Записывает все переменные на диск последовательно, то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре, `FilePut` записывает только данные. Дескриптор не записывается.  
  
-   `FilePut`записывает строки переменной длины, которые не являются элементами структур, без дескриптора длины в 2 байта. Число записанных байтов равно числу символов в строке. Например, следующие инструкции записывают 11 байт в номер файла 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Для записи в файл с помощью `FilePut` функции требуется `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере `FilePut` функция используется для записи данных в файл. В файл записываются `Person` пять записей структуры.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(object FileNumber, object Value, object RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Object, Value As Object, Optional RecordNumber As Object = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : obj * obj * obj -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FilePut(System::Object ^ FileNumber, System::Object ^ Value, System::Object ^ RecordNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Obsolete("This member has been deprecated. Please use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Obsolete("Use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Object" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, содержащей данные для записи на диск.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы, открытые в режиме <see langword="Random" />) или номер байта (файлы, открытые в режиме <see langword="Binary" />), с которого начинается запись.</param>
        <summary>Записывает значения переменных в файл на диске. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FilePut" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`Допустим только в `Random` режиме и `Binary` .  
  
 Данные, записанные с использованием `FilePut`, обычно считываются с помощью `FileGet`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт — на позиции 2 и т. д. Если опустить `RecordNumber`, записывается следующая запись или байт после последней `FileGet` функции `FilePut` или, на которую указывает последняя `Seek` функция.  
  
 `StringIsFixedLength` Аргумент определяет, интерпретирует ли функция строки как переменную или фиксированную длину. `FilePut`не записывает дескриптор длины, если аргумент имеет `True`значение. `StringIsFixedLength` При использовании  =  с в необходимо выполнить те же действия с `FileGet`, а также убедиться, что строка инициализируется с ожидаемой длиной. `FilePut` `True`  
  
## <a name="random-mode"></a>Произвольный режим  
 Для файлов, открытых `Random` в режиме, применяются следующие правила.  
  
-   Если длина записываемых данных меньше длины, указанной в `RecordLength` предложении `FileOpen` функции, `FilePut` записывает последующие записи на границах записи. Пространство между концом одной записи и началом следующей записи дополняется существующим содержимым файлового буфера. Поскольку объем данных заполнения не может быть определен точно, обычно рекомендуется, чтобы длина записи соответствовала длине записываемых данных. Если длина записываемых данных превышает длину, указанную в `RecordLength` предложении `FileOpen` функции, будет создано исключение.  
  
-   Если записываемая переменная является строкой, `FilePut` записывает двухбайтовый дескриптор, содержащий длину строки, а затем записывает данные, которые попадают в переменную. Таким образом, длина записи, заданная `RecordLength` предложением `FileOpen` в функции, должна быть как минимум на два байта больше, чем фактическая длина строки.  
  
-   Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, `VarType` идентифицирующие объект, а затем записывает переменную. Например, при записи объекта, содержащего целое число, `FilePut` записывается шесть байт: два байта, которые обозначают объект как `VarType(3)` (`Integer`), и четыре байта, содержащие данные. Длина записи, `RecordLength` заданная параметром `FileOpen` в функции, должна быть как минимум на два байта больше фактического числа байтов, необходимого для хранения переменной.  
  
-   Если записываемая переменная является объектом, содержащим строку, `FilePut` записывается двухбайтовый дескриптор `VarType(8)` объекта, двухбайтовый дескриптор, указывающий длину строки, и затем записывает строковые данные. Длина записи, `RecordLength` заданная параметром `FileOpen` в функции, должна быть не менее четырех байтов, превышающих фактическую длину строки. Если нужно поместить строку без дескриптора, следует передать `True` `StringIsFixedLength` параметр, а строка, в которую считываются строки, должна иметь правильную длину.  
  
-   Если записываемая переменная является массивом, можно выбрать, следует ли записывать дескриптор размера и размеров массива. Visual Basic 6,0 и более ранние версии записывают дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию не записывает дескриптор. Чтобы записать дескриптор, присвойте `ArrayIsDynamic` `True`параметру значение. При записи массива необходимо точно соответствовать способу чтения массива. Если он будет считан с дескриптора, необходимо написать дескриптор. Дескриптор задает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс в 8 раз больше, чем число измерений: (2 + 8 * Нумберофдименсионс). Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна сумме всех байтов, необходимых для записи данных массива и дескриптора массива. Например, следующее объявление массива требует 218 байт при записье массива на диск.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Если записываемая переменная является любым другим типом переменной (а не строкой переменной длины или объектом), `FilePut` записывает только данные переменной. Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна длине записываемых данных.  
  
-   `FilePut`записывает элементы структур, как если бы они были записаны по отдельности, за исключением того, что между элементами нет заполнения. `VBFixedString` Атрибут может применяться к строковым полям в структурах для указания размера строки при ее запись на диск.  
  
    > [!NOTE]
    >  Строковые поля с большим числом байтов, чем `VBFixedString` указано в атрибуте, усекаются при запись на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых `Binary` в режиме, применяются большинство `Random` правил режима с некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме, отличаются от правил для `Random` режима:  
  
-   `RecordLength` Предложение`FileOpen` в функции не оказывает никакого влияния. `FilePut`Записывает все переменные на диск последовательно, то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре, `FilePut` записывает только данные. Дескриптор не записывается.  
  
-   `FilePut`записывает строки переменной длины, которые не являются элементами структур, без дескриптора длины в 2 байта. Число записанных байтов равно числу символов в строке. Например, следующие инструкции записывают 11 байт в номер файла 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Для записи в файл с помощью `FilePut` функции требуется `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере `FilePut` функция используется для записи данных в файл. В файл записываются `Person` пять записей структуры.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, string Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * string * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, содержащей данные для записи на диск.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы, открытые в режиме <see langword="Random" />) или номер байта (файлы, открытые в режиме <see langword="Binary" />), с которого начинается запись.</param>
        <param name="StringIsFixedLength">Необязательный параметр. Используется только при записи строки. Указывает, записывать ли в файл двухбайтовый дескриптор длины строки. Значение по умолчанию — <see langword="False" />.</param>
        <summary>Записывает значения переменных в файл на диске. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FilePut" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`Допустим только в `Random` режиме и `Binary` .  
  
 Данные, записанные с использованием `FilePut`, обычно считываются с помощью `FileGet`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт — на позиции 2 и т. д. Если опустить `RecordNumber`, записывается следующая запись или байт после последней `FileGet` функции `FilePut` или, на которую указывает последняя `Seek` функция.  
  
 `StringIsFixedLength` Аргумент определяет, интерпретирует ли функция строки как переменную или фиксированную длину. `FilePut`не записывает дескриптор длины, если аргумент имеет `True`значение. `StringIsFixedLength` При использовании  =  с в необходимо выполнить те же действия с `FileGet`, а также убедиться, что строка инициализируется с ожидаемой длиной. `FilePut` `True`  
  
## <a name="random-mode"></a>Произвольный режим  
 Для файлов, открытых `Random` в режиме, применяются следующие правила.  
  
-   Если длина записываемых данных меньше длины, указанной в `RecordLength` предложении `FileOpen` функции, `FilePut` записывает последующие записи на границах записи. Пространство между концом одной записи и началом следующей записи дополняется существующим содержимым файлового буфера. Поскольку объем данных заполнения не может быть определен точно, обычно рекомендуется, чтобы длина записи соответствовала длине записываемых данных. Если длина записываемых данных превышает длину, указанную в `RecordLength` предложении `FileOpen` функции, будет создано исключение.  
  
-   Если записываемая переменная является строкой, `FilePut` записывает двухбайтовый дескриптор, содержащий длину строки, а затем записывает данные, которые попадают в переменную. Таким образом, длина записи, заданная `RecordLength` предложением `FileOpen` в функции, должна быть как минимум на два байта больше, чем фактическая длина строки.  
  
-   Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, `VarType` идентифицирующие объект, а затем записывает переменную. Например, при записи объекта, содержащего целое число, `FilePut` записывается шесть байт: два байта, которые обозначают объект как `VarType(3)` (`Integer`), и четыре байта, содержащие данные. Длина записи, `RecordLength` заданная параметром `FileOpen` в функции, должна быть как минимум на два байта больше фактического числа байтов, необходимого для хранения переменной.  
  
-   Если записываемая переменная является объектом, содержащим строку, `FilePut` записывается двухбайтовый дескриптор `VarType(8)` объекта, двухбайтовый дескриптор, указывающий длину строки, и затем записывает строковые данные. Длина записи, `RecordLength` заданная параметром `FileOpen` в функции, должна быть не менее четырех байтов, превышающих фактическую длину строки. Если нужно поместить строку без дескриптора, следует передать `True` `StringIsFixedLength` параметр, а строка, в которую считываются строки, должна иметь правильную длину.  
  
-   Если записываемая переменная является массивом, можно выбрать, следует ли записывать дескриптор размера и размеров массива. Visual Basic 6,0 и более ранние версии записывают дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию не записывает дескриптор. Чтобы записать дескриптор, присвойте `ArrayIsDynamic` `True`параметру значение. При записи массива необходимо точно соответствовать способу чтения массива. Если он будет считан с дескриптора, необходимо написать дескриптор. Дескриптор задает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс в 8 раз больше, чем число измерений: (2 + 8 * Нумберофдименсионс). Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна сумме всех байтов, необходимых для записи данных массива и дескриптора массива. Например, следующее объявление массива требует 218 байт при записье массива на диск.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Если записываемая переменная является любым другим типом переменной (а не строкой переменной длины или объектом), `FilePut` записывает только данные переменной. Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна длине записываемых данных.  
  
-   `FilePut`записывает элементы структур, как если бы они были записаны по отдельности, за исключением того, что между элементами нет заполнения. `VBFixedString` Атрибут может применяться к строковым полям в структурах для указания размера строки при ее запись на диск.  
  
    > [!NOTE]
    >  Строковые поля с большим числом байтов, чем `VBFixedString` указано в атрибуте, усекаются при запись на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых `Binary` в режиме, применяются большинство `Random` правил режима с некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме, отличаются от правил для `Random` режима:  
  
-   `RecordLength` Предложение`FileOpen` в функции не оказывает никакого влияния. `FilePut`Записывает все переменные на диск последовательно, то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре, `FilePut` записывает только данные. Дескриптор не записывается.  
  
-   `FilePut`записывает строки переменной длины, которые не являются элементами структур, без дескриптора длины в 2 байта. Число записанных байтов равно числу символов в строке. Например, следующие инструкции записывают 11 байт в номер файла 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Для записи в файл с помощью `FilePut` функции требуется `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере `FilePut` функция используется для записи данных в файл. В файл записываются `Person` пять записей структуры.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.Array Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * Array * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, содержащей данные для записи на диск.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы, открытые в режиме <see langword="Random" />) или номер байта (файлы, открытые в режиме <see langword="Binary" />), с которого начинается запись.</param>
        <param name="ArrayIsDynamic">Необязательный параметр. Применяется только при записи массива. Указывает, нужно ли обрабатывать массив как динамический, и записывать ли дескриптор массива для строки, определяющий ее длину.</param>
        <param name="StringIsFixedLength">Необязательный параметр. Используется только при записи строки. Указывает, записывать ли в файл двухбайтовый дескриптор длины строки. Значение по умолчанию — <see langword="False" />.</param>
        <summary>Записывает значения переменных в файл на диске. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FilePut" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`Допустим только в `Random` режиме и `Binary` .  
  
 Данные, записанные с использованием `FilePut`, обычно считываются с помощью `FileGet`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт — на позиции 2 и т. д. Если опустить `RecordNumber`, записывается следующая запись или байт после последней `FileGet` функции `FilePut` или, на которую указывает последняя `Seek` функция.  
  
 `StringIsFixedLength` Аргумент определяет, интерпретирует ли функция строки как переменную или фиксированную длину. `FilePut`не записывает дескриптор длины, если аргумент имеет `True`значение. `StringIsFixedLength` При использовании  =  с в необходимо выполнить те же действия с `FileGet`, а также убедиться, что строка инициализируется с ожидаемой длиной. `FilePut` `True`  
  
## <a name="random-mode"></a>Произвольный режим  
 Для файлов, открытых `Random` в режиме, применяются следующие правила.  
  
-   Если длина записываемых данных меньше длины, указанной в `RecordLength` предложении `FileOpen` функции, `FilePut` записывает последующие записи на границах записи. Пространство между концом одной записи и началом следующей записи дополняется существующим содержимым файлового буфера. Поскольку объем данных заполнения не может быть определен точно, обычно рекомендуется, чтобы длина записи соответствовала длине записываемых данных. Если длина записываемых данных превышает длину, указанную в `RecordLength` предложении `FileOpen` функции, будет создано исключение.  
  
-   Если записываемая переменная является строкой, `FilePut` записывает двухбайтовый дескриптор, содержащий длину строки, а затем записывает данные, которые попадают в переменную. Таким образом, длина записи, заданная `RecordLength` предложением `FileOpen` в функции, должна быть как минимум на два байта больше, чем фактическая длина строки.  
  
-   Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, `VarType` идентифицирующие объект, а затем записывает переменную. Например, при записи объекта, содержащего целое число, `FilePut` записывается шесть байт: два байта, которые обозначают объект как `VarType(3)` (`Integer`), и четыре байта, содержащие данные. Длина записи, `RecordLength` заданная параметром `FileOpen` в функции, должна быть как минимум на два байта больше фактического числа байтов, необходимого для хранения переменной.  
  
-   Если записываемая переменная является объектом, содержащим строку, `FilePut` записывается двухбайтовый дескриптор `VarType(8)` объекта, двухбайтовый дескриптор, указывающий длину строки, и затем записывает строковые данные. Длина записи, `RecordLength` заданная параметром `FileOpen` в функции, должна быть не менее четырех байтов, превышающих фактическую длину строки. Если нужно поместить строку без дескриптора, следует передать `True` `StringIsFixedLength` параметр, а строка, в которую считываются строки, должна иметь правильную длину.  
  
-   Если записываемая переменная является массивом, можно выбрать, следует ли записывать дескриптор размера и размеров массива. Visual Basic 6,0 и более ранние версии записывают дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию не записывает дескриптор. Чтобы записать дескриптор, присвойте `ArrayIsDynamic` `True`параметру значение. При записи массива необходимо точно соответствовать способу чтения массива. Если он будет считан с дескриптора, необходимо написать дескриптор. Дескриптор задает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс в 8 раз больше, чем число измерений: (2 + 8 * Нумберофдименсионс). Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна сумме всех байтов, необходимых для записи данных массива и дескриптора массива. Например, следующее объявление массива требует 218 байт при записье массива на диск.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Если записываемая переменная является любым другим типом переменной (а не строкой переменной длины или объектом), `FilePut` записывает только данные переменной. Длина записи, `RecordLength` заданная предложением `FileOpen` в функции, должна быть больше или равна длине записываемых данных.  
  
-   `FilePut`записывает элементы структур, как если бы они были записаны по отдельности, за исключением того, что между элементами нет заполнения. `VBFixedString` Атрибут может применяться к строковым полям в структурах для указания размера строки при ее запись на диск.  
  
    > [!NOTE]
    >  Строковые поля с большим числом байтов, чем `VBFixedString` указано в атрибуте, усекаются при запись на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых `Binary` в режиме, применяются большинство `Random` правил режима с некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме, отличаются от правил для `Random` режима:  
  
-   `RecordLength` Предложение`FileOpen` в функции не оказывает никакого влияния. `FilePut`Записывает все переменные на диск последовательно, то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре, `FilePut` записывает только данные. Дескриптор не записывается.  
  
-   `FilePut`записывает строки переменной длины, которые не являются элементами структур, без дескриптора длины в 2 байта. Число записанных байтов равно числу символов в строке. Например, следующие инструкции записывают 11 байт в номер файла 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Для записи в файл с помощью `FilePut` функции требуется `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере `FilePut` функция используется для записи данных в файл. В файл записываются `Person` пять записей структуры.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePutObject">
      <MemberSignature Language="C#" Value="public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePutObject(int32 FileNumber, object Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePutObject (FileNumber As Integer, Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePutObject : int * obj * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePutObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, содержащей данные для записи на диск.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы, открытые в режиме <see langword="Random" />) или номер байта (файлы, открытые в режиме <see langword="Binary" />), с которого начинается запись.</param>
        <summary>Записывает значения переменных в файл на диске.  Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FilePutObject" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Object` `Integer` `Long` `Short`Функция используется `FilePut` вместо, чтобы избежать неоднозначности во время компиляции, если передается тип вместо другого типа, например,, и т. д. `FilePutObject`  
  
 `FilePutObject`записывает и считывает дескрипторы, описывающие объект. Если предполагается записывать `Variant` тип, `FilePutObject` требуется. В случае сомнений, если вы используете объект для второго параметра, рекомендуется всегда использовать `FilePutObject` и. `FileGetObject`  
  
 `FilePutObject`Допустим только в `Random` режиме и `Binary` .  
  
 Данные, записанные с использованием `FilePutObject`, обычно считываются с помощью `FileGetObject`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт — на позиции 2 и т. д. `RecordNumber`Если опустить `Seek` , `FilePutObject` записывает следующую запись или байт после последней `FileGetObject` функции или `FilePutObject` (или запись или байт, на который указывает последняя функция).  
  
 `StringIsFixedLength` Аргумент определяет, интерпретирует ли функция строки как переменную или фиксированную длину. `FilePutObject`не записывает дескриптор длины, если аргумент имеет `True`значение. `StringIsFixedLength` При использовании  =  с в необходимо выполнить те же действия с `FileGetObject`, а также убедиться, что строка инициализируется с ожидаемой длиной. `FilePutObject` `True`  
  
## <a name="random-mode"></a>Произвольный режим  
 Для файлов, открытых `Random` в режиме, применяются следующие правила.  
  
-   Если длина записываемых данных меньше длины, указанной в `RecordLength` предложении `FileOpen` функции, `FilePutObject` записывает последующие записи на границах записи. Пространство между концом одной записи и началом следующей записи дополняется существующим содержимым файлового буфера. Поскольку объем данных заполнения не может быть определен точно, обычно рекомендуется, чтобы длина записи соответствовала длине записываемых данных. Если длина записываемых данных превышает длину, указанную в `RecordLength` предложении `FileOpen` функции, создается исключение.  
  
-   Если записываемая переменная является объектом, содержащим числовой тип, `FilePutObject` записывает два байта, `VarType` идентифицирующие объект, а затем записывает переменную. Например, при записи объекта, содержащего целое число, `FilePutObject` записывается шесть байт: два байта, которые обозначают объект как `VarType(3)` (`Integer`), и четыре байта, содержащие данные. Длина записи, `RecordLength` заданная параметром `FileOpen` в функции, должна быть как минимум на два байта больше фактического числа байтов, необходимого для хранения переменной.  
  
-   Если записываемая переменная является объектом, содержащим строку, `FilePutObject` записывает двухбайтовый дескриптор, `VarType(8)` идентифицирующий объект, двухбайтовый дескриптор, указывающий длину строки, а затем записывает строковые данные. Длина записи, `RecordLength` заданная параметром `FileOpen` в функции, должна быть не менее четырех байтов, превышающих фактическую длину строки. Если нужно поместить строку без дескриптора, следует передать `True` `StringIsFixedLength` параметр, а строка, в которую считываются строки, должна иметь правильную длину.  
  
-   Если записываемая переменная является массивом, длина записи, заданная `RecordLength` предложением `FileOpen` в функции, должна быть больше или равна сумме всех байтов, необходимых для записи данных массива и дескриптора массива. Дескриптор задает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс в 8 раз больше, чем число измерений: (2 + 8 * Нумберофдименсионс).  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых `Binary` в режиме, применяются `Random` все правила режима, за исключением:  
  
-   `RecordLength` Предложение`FileOpen` в функции не оказывает никакого влияния. `FilePutObject`Записывает все переменные на диск последовательно, то есть без заполнения между записями.  
  
   
  
## Examples  
 В этом примере `FilePutObject` функция используется для записи строки в файл.  
  
 [!code-vb[VbVbalrCatRef#54](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#54)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileWidth">
      <MemberSignature Language="C#" Value="public static void FileWidth (int FileNumber, int RecordWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileWidth(int32 FileNumber, int32 RecordWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileWidth (FileNumber As Integer, RecordWidth As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileWidth(int FileNumber, int RecordWidth);" />
      <MemberSignature Language="F#" Value="static member FileWidth : int * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileWidth (FileNumber, RecordWidth)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="RecordWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="RecordWidth">Обязательный. Числовое выражение в диапазоне от 0 до 255 включительно, которое показывает, сколько знаков появится в строке перед началом новой строки. Если параметр <paramref name="RecordWidth" /> равен 0, ограничения на длину строки не устанавливаются. Значение по умолчанию для <paramref name="RecordWidth" /> равно 0.</param>
        <summary>Присваивает ширину строки вывода в файле, открытом функцией <see langword="FileOpen" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В этом примере `FileWidth` функция используется для задания ширины строки вывода для файла.  
  
 [!code-vb[VbVbalrCatRef#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FreeFile">
      <MemberSignature Language="C#" Value="public static int FreeFile ();" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 FreeFile() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      <MemberSignature Language="VB.NET" Value="Public Function FreeFile () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FreeFile();" />
      <MemberSignature Language="F#" Value="static member FreeFile : unit -&gt; int" Usage="Microsoft.VisualBasic.FileSystem.FreeFile " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение типа <see langword="Integer" />, представляющее следующий номер файла, доступный для использования функцией <see langword="FileOpen" />.</summary>
        <returns>Целочисленное значение, представляющее следующий номер файла, доступный для использования функцией <see langword="FileOpen" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте `FreeFile` , чтобы указать номер файла, который еще не используется.  
  
   
  
## Examples  
 В этом примере используется `FreeFile` функция для возврата следующего доступного номера файла. Для выходных данных в цикле открывается пять файлов, а в каждую из них записывается несколько примеров.  
  
 [!code-vb[VbVbalrCatRef#55](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#55)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Используется больше 255 файлов.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="GetAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.FileAttribute GetAttr(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttr (PathName As String) As FileAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileAttribute GetAttr(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member GetAttr : string -&gt; Microsoft.VisualBasic.FileAttribute" Usage="Microsoft.VisualBasic.FileSystem.GetAttr PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Обязательный. Строковое выражение, определяющее имя файла, каталога или папки. Выражение <paramref name="PathName" /> может содержать имя каталога или папки и имя диска.</param>
        <summary>Возвращает значение <see langword="FileAttribute" />, представляющее атрибуты файла, каталога или папки. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FileAttribute" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Побитовое сочетание значений перечисления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы определить, какие атрибуты заданы, используйте `And` оператор для выполнения побитового сравнения значения, возвращаемого `GetAttr` функцией, и значения нужного атрибута файла. Если результат не равен нулю, то этот атрибут задается для именованного файла. Например, возвращаемое значение следующего `And` выражения равно нулю, `Archive` если атрибут не задан:  
  
```vb  
Result = GetAttr(FName) And vbArchive  
```  
  
 Если `Archive` задан атрибут, возвращается ненулевое значение.  
  
   
  
## Examples  
 В этом примере `GetAttr` функция используется для определения атрибутов файла, каталога или папки.  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Параметр <paramref name="Pathname" /> недопустим или содержит подстановочный знак.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Указанный файл не существует.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/and-operator.md">Оператор And (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Input">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Читает данные из открытого последовательного файла и присваивает данные переменным.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref bool Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, bool&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, bool % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Переменная, которой присваиваются значения, считанные из файла. Не может быть массивом или объектной переменной.</param>
        <summary>Читает данные из открытого последовательного файла и присваивает данные переменным.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, не использующих `My.Computer.FileSystem` устаревшие версии, объект обеспечивает лучшую производительность. Дополнительные сведения см. [в разделе доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Данные, считанные с помощью `Input` , обычно записываются в файл с помощью. `Write` Используйте эту функцию только с файлами, открытыми `Input` в `Binary` режиме или.  
  
> [!IMPORTANT]
>  При чтении из файлов не следует принимать решения о содержимом файла на основе расширения имени файла. Например, файл с именем Form1. vb не может быть исходным файлом Visual Basic 2005.  
  
 При чтении стандартные строковые или числовые данные присваиваются переменным без изменения. В следующей таблице показано, как обрабатываются другие входные данные.  
  
|Данные|Значение, присвоенное переменной|  
|-|-|  
|Разделительная запятая или пустая строка|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # или #FALSE #|`True` или `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Дата и/или время, представленные выражением|  
|#ERROR`errornumber`#|`errornumber`(переменная является объектом, помеченным как ошибка)|  
  
 Если достигнут конец файла при вводе элемента данных, входные данные останавливаются и возникает ошибка.  
  
> [!NOTE]
>  `Input` Функция не локализована. Например, в немецкой версии при вводе 3, 14159 возвращает только 3, поскольку запятая обрабатывается как разделитель переменных, а не как десятичная точка.  
  
> [!IMPORTANT]
>  Для чтения из файла с помощью `Input` функции требуется `Read` доступ из `FileIOPermissionAccess` перечисления. Для получения дополнительной информации см. <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере `Input` функция используется для считывания данных из файла в две переменные. В этом примере предполагается, что `TestFile` — это файл с несколькими строками данных, записанными в него `Write` с помощью функции, каждая строка которой содержит строку в кавычках и номер, разделенный запятыми, например: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Практическое руководство. Запись текста в файлы в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Практическое руководство. Запись текста в файл с помощью StreamWriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref byte Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, unsigned int8&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Byte % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Переменная, которой присваиваются значения, считанные из файла. Не может быть массивом или объектной переменной.</param>
        <summary>Читает данные из открытого последовательного файла и присваивает данные переменным.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, не использующих `My.Computer.FileSystem` устаревшие версии, объект обеспечивает лучшую производительность. Дополнительные сведения см. [в разделе доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Данные, считанные с помощью `Input` , обычно записываются в файл с помощью. `Write` Используйте эту функцию только с файлами, открытыми `Input` в `Binary` режиме или.  
  
> [!IMPORTANT]
>  При чтении из файлов не следует принимать решения о содержимом файла на основе расширения имени файла. Например, файл с именем Form1. vb не может быть исходным файлом Visual Basic 2005.  
  
 При чтении стандартные строковые или числовые данные присваиваются переменным без изменения. В следующей таблице показано, как обрабатываются другие входные данные.  
  
|Данные|Значение, присвоенное переменной|  
|-|-|  
|Разделительная запятая или пустая строка|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # или #FALSE #|`True` или `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Дата и/или время, представленные выражением|  
|#ERROR`errornumber`#|`errornumber`(переменная является объектом, помеченным как ошибка)|  
  
 Если достигнут конец файла при вводе элемента данных, входные данные останавливаются и возникает ошибка.  
  
> [!NOTE]
>  `Input` Функция не локализована. Например, в немецкой версии при вводе 3, 14159 возвращает только 3, поскольку запятая обрабатывается как разделитель переменных, а не как десятичная точка.  
  
> [!IMPORTANT]
>  Для чтения из файла с помощью `Input` функции требуется `Read` доступ из `FileIOPermissionAccess` перечисления. Для получения дополнительной информации см. <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере `Input` функция используется для считывания данных из файла в две переменные. В этом примере предполагается, что `TestFile` — это файл с несколькими строками данных, записанными в него `Write` с помощью функции, каждая строка которой содержит строку в кавычках и номер, разделенный запятыми, например: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Практическое руководство. Запись текста в файлы в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Практическое руководство. Запись текста в файл с помощью StreamWriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref char Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, char&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, char % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Переменная, которой присваиваются значения, считанные из файла. Не может быть массивом или объектной переменной.</param>
        <summary>Читает данные из открытого последовательного файла и присваивает данные переменным.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, не использующих `My.Computer.FileSystem` устаревшие версии, объект обеспечивает лучшую производительность. Дополнительные сведения см. [в разделе доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Данные, считанные с помощью `Input` , обычно записываются в файл с помощью. `Write` Используйте эту функцию только с файлами, открытыми `Input` в `Binary` режиме или.  
  
> [!IMPORTANT]
>  При чтении из файлов не следует принимать решения о содержимом файла на основе расширения имени файла. Например, файл с именем Form1. vb не может быть исходным файлом Visual Basic 2005.  
  
 При чтении стандартные строковые или числовые данные присваиваются переменным без изменения. В следующей таблице показано, как обрабатываются другие входные данные.  
  
|Данные|Значение, присвоенное переменной|  
|-|-|  
|Разделительная запятая или пустая строка|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # или #FALSE #|`True` или `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Дата и/или время, представленные выражением|  
|#ERROR`errornumber`#|`errornumber`(переменная является объектом, помеченным как ошибка)|  
  
 Если достигнут конец файла при вводе элемента данных, входные данные останавливаются и возникает ошибка.  
  
> [!NOTE]
>  `Input` Функция не локализована. Например, в немецкой версии при вводе 3, 14159 возвращает только 3, поскольку запятая обрабатывается как разделитель переменных, а не как десятичная точка.  
  
> [!IMPORTANT]
>  Для чтения из файла с помощью `Input` функции требуется `Read` доступ из `FileIOPermissionAccess` перечисления. Для получения дополнительной информации см. <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере `Input` функция используется для считывания данных из файла в две переменные. В этом примере предполагается, что `TestFile` это файл с несколькими строками данных, записанными в него `Write` с помощью функции, каждая строка которой содержит строку в кавычках и номер, разделенный запятыми, например: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Практическое руководство. Запись текста в файлы в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Практическое руководство. Запись текста в файл с помощью StreamWriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref DateTime Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.DateTime&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, DateTime % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Переменная, которой присваиваются значения, считанные из файла. Не может быть массивом или объектной переменной.</param>
        <summary>Читает данные из открытого последовательного файла и присваивает данные переменным.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, не использующих `My.Computer.FileSystem` устаревшие версии, объект обеспечивает лучшую производительность. Дополнительные сведения см. [в разделе доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Данные, считанные с помощью `Input` , обычно записываются в файл с помощью. `Write` Используйте эту функцию только с файлами, открытыми `Input` в `Binary` режиме или.  
  
> [!IMPORTANT]
>  При чтении из файлов не следует принимать решения о содержимом файла на основе расширения имени файла. Например, файл с именем Form1. vb не может быть исходным файлом Visual Basic 2005.  
  
 При чтении стандартные строковые или числовые данные присваиваются переменным без изменения. В следующей таблице показано, как обрабатываются другие входные данные.  
  
|Данные|Значение, присвоенное переменной|  
|-|-|  
|Разделительная запятая или пустая строка|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # или #FALSE #|`True` или `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Дата и/или время, представленные выражением|  
|#ERROR`errornumber`#|`errornumber`(переменная является объектом, помеченным как ошибка)|  
  
 Если достигнут конец файла при вводе элемента данных, входные данные останавливаются и возникает ошибка.  
  
> [!NOTE]
>  `Input` Функция не локализована. Например, в немецкой версии при вводе 3, 14159 возвращает только 3, поскольку запятая обрабатывается как разделитель переменных, а не как десятичная точка.  
  
> [!IMPORTANT]
>  Для чтения из файла с помощью `Input` функции требуется `Read` доступ из `FileIOPermissionAccess` перечисления. Для получения дополнительной информации см. <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере `Input` функция используется для считывания данных из файла в две переменные. В этом примере предполагается, что `TestFile` это файл с несколькими строками данных, записанными в него `Write` с помощью функции, каждая строка которой содержит строку в кавычках и номер, разделенный запятыми, например: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Практическое руководство. Запись текста в файлы в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Практическое руководство. Запись текста в файл с помощью StreamWriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref decimal Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.Decimal&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Decimal % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Переменная, которой присваиваются значения, считанные из файла. Не может быть массивом или объектной переменной.</param>
        <summary>Читает данные из открытого последовательного файла и присваивает данные переменным.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, не использующих `My.Computer.FileSystem` устаревшие версии, объект обеспечивает лучшую производительность. Дополнительные сведения см. [в разделе доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Данные, считанные с помощью `Input` , обычно записываются в файл с помощью. `Write` Используйте эту функцию только с файлами, открытыми `Input` в `Binary` режиме или.  
  
> [!IMPORTANT]
>  При чтении из файлов не следует принимать решения о содержимом файла на основе расширения имени файла. Например, файл с именем Form1. vb не может быть исходным файлом Visual Basic 2005.  
  
 При чтении стандартные строковые или числовые данные присваиваются переменным без изменения. В следующей таблице показано, как обрабатываются другие входные данные.  
  
|Данные|Значение, присвоенное переменной|  
|-|-|  
|Разделительная запятая или пустая строка|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # или #FALSE #|`True` или `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Дата и/или время, представленные выражением|  
|#ERROR`errornumber`#|`errornumber`(переменная является объектом, помеченным как ошибка)|  
  
 Если достигнут конец файла при вводе элемента данных, входные данные останавливаются и возникает ошибка.  
  
> [!NOTE]
>  `Input` Функция не локализована. Например, в немецкой версии при вводе 3, 14159 возвращает только 3, поскольку запятая обрабатывается как разделитель переменных, а не как десятичная точка.  
  
> [!IMPORTANT]
>  Для чтения из файла с помощью `Input` функции требуется `Read` доступ из `FileIOPermissionAccess` перечисления. Для получения дополнительной информации см. <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере `Input` функция используется для считывания данных из файла в две переменные. В этом примере предполагается, что `TestFile` это файл с несколькими строками данных, записанными в него `Write` с помощью функции, каждая строка которой содержит строку в кавычках и номер, разделенный запятыми, например: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Практическое руководство. Запись текста в файлы в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Практическое руководство. Запись текста в файл с помощью StreamWriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref double Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, double % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Переменная, которой присваиваются значения, считанные из файла. Не может быть массивом или объектной переменной.</param>
        <summary>Читает данные из открытого последовательного файла и присваивает данные переменным.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, не использующих `My.Computer.FileSystem` устаревшие версии, объект обеспечивает лучшую производительность. Дополнительные сведения см. [в разделе доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Данные, считанные с помощью `Input` , обычно записываются в файл с помощью. `Write` Используйте эту функцию только с файлами, открытыми `Input` в `Binary` режиме или.  
  
> [!IMPORTANT]
>  При чтении из файлов не следует принимать решения о содержимом файла на основе расширения имени файла. Например, файл с именем Form1. vb не может быть исходным файлом Visual Basic 2005.  
  
 При чтении стандартные строковые или числовые данные присваиваются переменным без изменения. В следующей таблице показано, как обрабатываются другие входные данные.  
  
|Данные|Значение, присвоенное переменной|  
|-|-|  
|Разделительная запятая или пустая строка|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # или #FALSE #|`True` или `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Дата и/или время, представленные выражением|  
|#ERROR`errornumber`#|`errornumber`(переменная является объектом, помеченным как ошибка)|  
  
 Если достигнут конец файла при вводе элемента данных, входные данные останавливаются и возникает ошибка.  
  
> [!NOTE]
>  `Input` Функция не локализована. Например, в немецкой версии при вводе 3, 14159 возвращает только 3, поскольку запятая обрабатывается как разделитель переменных, а не как десятичная точка.  
  
> [!IMPORTANT]
>  Для чтения из файла с помощью `Input` функции требуется `Read` доступ из `FileIOPermissionAccess` перечисления. Для получения дополнительной информации см. <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере `Input` функция используется для считывания данных из файла в две переменные. В этом примере предполагается, что `TestFile` это файл с несколькими строками данных, записанными в него `Write` с помощью функции, каждая строка которой содержит строку в кавычках и номер, разделенный запятыми, например: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Практическое руководство. Запись текста в файлы в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Практическое руководство. Запись текста в файл с помощью StreamWriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref short Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int16&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, short % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Переменная, которой присваиваются значения, считанные из файла. Не может быть массивом или объектной переменной.</param>
        <summary>Читает данные из открытого последовательного файла и присваивает данные переменным.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, не использующих `My.Computer.FileSystem` устаревшие версии, объект обеспечивает лучшую производительность. Дополнительные сведения см. [в разделе доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Данные, считанные с помощью `Input` , обычно записываются в файл с помощью. `Write` Используйте эту функцию только с файлами, открытыми `Input` в `Binary` режиме или.  
  
> [!IMPORTANT]
>  При чтении из файлов не следует принимать решения о содержимом файла на основе расширения имени файла. Например, файл с именем Form1. vb не может быть исходным файлом Visual Basic 2005.  
  
 При чтении стандартные строковые или числовые данные присваиваются переменным без изменения. В следующей таблице показано, как обрабатываются другие входные данные.  
  
|Данные|Значение, присвоенное переменной|  
|-|-|  
|Разделительная запятая или пустая строка|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # или #FALSE #|`True` или `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Дата и/или время, представленные выражением|  
|#ERROR`errornumber`#|`errornumber`(переменная является объектом, помеченным как ошибка)|  
  
 Если достигнут конец файла при вводе элемента данных, входные данные останавливаются и возникает ошибка.  
  
> [!NOTE]
>  `Input` Функция не локализована. Например, в немецкой версии при вводе 3, 14159 возвращает только 3, поскольку запятая обрабатывается как разделитель переменных, а не как десятичная точка.  
  
> [!IMPORTANT]
>  Для чтения из файла с помощью `Input` функции требуется `Read` доступ из `FileIOPermissionAccess` перечисления. Для получения дополнительной информации см. <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере `Input` функция используется для считывания данных из файла в две переменные. В этом примере предполагается, что `TestFile` это файл с несколькими строками данных, записанными в него `Write` с помощью функции, каждая строка которой содержит строку в кавычках и номер, разделенный запятыми, например: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Практическое руководство. Запись текста в файлы в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Практическое руководство. Запись текста в файл с помощью StreamWriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref int Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, int % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Переменная, которой присваиваются значения, считанные из файла. Не может быть массивом или объектной переменной.</param>
        <summary>Читает данные из открытого последовательного файла и присваивает данные переменным.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, не использующих `My.Computer.FileSystem` устаревшие версии, объект обеспечивает лучшую производительность. Дополнительные сведения см. [в разделе доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Данные, считанные с помощью `Input` , обычно записываются в файл с помощью. `Write` Используйте эту функцию только с файлами, открытыми `Input` в `Binary` режиме или.  
  
> [!IMPORTANT]
>  При чтении из файлов не следует принимать решения о содержимом файла на основе расширения имени файла. Например, файл с именем Form1. vb не может быть исходным файлом Visual Basic 2005.  
  
 При чтении стандартные строковые или числовые данные присваиваются переменным без изменения. В следующей таблице показано, как обрабатываются другие входные данные.  
  
|Данные|Значение, присвоенное переменной|  
|-|-|  
|Разделительная запятая или пустая строка|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # или #FALSE #|`True` или `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Дата и/или время, представленные выражением|  
|#ERROR`errornumber`#|`errornumber`(переменная является объектом, помеченным как ошибка)|  
  
 Если достигнут конец файла при вводе элемента данных, входные данные останавливаются и возникает ошибка.  
  
> [!NOTE]
>  `Input` Функция не локализована. Например, в немецкой версии при вводе 3, 14159 возвращает только 3, поскольку запятая обрабатывается как разделитель переменных, а не как десятичная точка.  
  
> [!IMPORTANT]
>  Для чтения из файла с помощью `Input` функции требуется `Read` доступ из `FileIOPermissionAccess` перечисления. Для получения дополнительной информации см. <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере `Input` функция используется для считывания данных из файла в две переменные. В этом примере предполагается, что `TestFile` это файл с несколькими строками данных, записанными в него `Write` с помощью функции, каждая строка которой содержит строку в кавычках и номер, разделенный запятыми, например: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Практическое руководство. Запись текста в файлы в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Практическое руководство. Запись текста в файл с помощью StreamWriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref long Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, long % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Переменная, которой присваиваются значения, считанные из файла. Не может быть массивом или объектной переменной.</param>
        <summary>Читает данные из открытого последовательного файла и присваивает данные переменным.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, не использующих `My.Computer.FileSystem` устаревшие версии, объект обеспечивает лучшую производительность. Дополнительные сведения см. [в разделе доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Данные, считанные с помощью `Input` , обычно записываются в файл с помощью. `Write` Используйте эту функцию только с файлами, открытыми `Input` в `Binary` режиме или.  
  
> [!IMPORTANT]
>  При чтении из файлов не следует принимать решения о содержимом файла на основе расширения имени файла. Например, файл с именем Form1. vb не может быть исходным файлом Visual Basic 2005.  
  
 При чтении стандартные строковые или числовые данные присваиваются переменным без изменения. В следующей таблице показано, как обрабатываются другие входные данные.  
  
|Данные|Значение, присвоенное переменной|  
|-|-|  
|Разделительная запятая или пустая строка|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # или #FALSE #|`True` или `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Дата и/или время, представленные выражением|  
|#ERROR`errornumber`#|`errornumber`(переменная является объектом, помеченным как ошибка)|  
  
 Если достигнут конец файла при вводе элемента данных, входные данные останавливаются и возникает ошибка.  
  
> [!NOTE]
>  `Input` Функция не локализована. Например, в немецкой версии при вводе 3, 14159 возвращает только 3, поскольку запятая обрабатывается как разделитель переменных, а не как десятичная точка.  
  
> [!IMPORTANT]
>  Для чтения из файла с помощью `Input` функции требуется `Read` доступ из `FileIOPermissionAccess` перечисления. Для получения дополнительной информации см. <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере `Input` функция используется для считывания данных из файла в две переменные. В этом примере предполагается, что `TestFile` это файл с несколькими строками данных, записанными в него `Write` с помощью функции, каждая строка которой содержит строку в кавычках и номер, разделенный запятыми, например: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Практическое руководство. Запись текста в файлы в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Практическое руководство. Запись текста в файл с помощью StreamWriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref object Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, object&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Object ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Переменная, которой присваиваются значения, считанные из файла. Не может быть массивом или объектной переменной.</param>
        <summary>Читает данные из открытого последовательного файла и присваивает данные переменным.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, не использующих `My.Computer.FileSystem` устаревшие версии, объект обеспечивает лучшую производительность. Дополнительные сведения см. [в разделе доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Данные, считанные с помощью `Input` , обычно записываются в файл с помощью. `Write` Используйте эту функцию только с файлами, открытыми `Input` в `Binary` режиме или.  
  
> [!IMPORTANT]
>  При чтении из файлов не следует принимать решения о содержимом файла на основе расширения имени файла. Например, файл с именем Form1. vb не может быть исходным файлом Visual Basic 2005.  
  
 При чтении стандартные строковые или числовые данные присваиваются переменным без изменения. В следующей таблице показано, как обрабатываются другие входные данные.  
  
|Данные|Значение, присвоенное переменной|  
|-|-|  
|Разделительная запятая или пустая строка|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # или #FALSE #|`True` или `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Дата и/или время, представленные выражением|  
|#ERROR`errornumber`#|`errornumber`(переменная является объектом, помеченным как ошибка)|  
  
 Если достигнут конец файла при вводе элемента данных, входные данные останавливаются и возникает ошибка.  
  
> [!NOTE]
>  `Input` Функция не локализована. Например, в немецкой версии при вводе 3, 14159 возвращает только 3, поскольку запятая обрабатывается как разделитель переменных, а не как десятичная точка.  
  
> [!IMPORTANT]
>  Для чтения из файла с помощью `Input` функции требуется `Read` доступ из `FileIOPermissionAccess` перечисления. Для получения дополнительной информации см. <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере `Input` функция используется для считывания данных из файла в две переменные. В этом примере предполагается, что `TestFile` это файл с несколькими строками данных, записанными в него `Write` с помощью функции, каждая строка которой содержит строку в кавычках и номер, разделенный запятыми, например: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Практическое руководство. Запись текста в файлы в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Практическое руководство. Запись текста в файл с помощью StreamWriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref float Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, float % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Переменная, которой присваиваются значения, считанные из файла. Не может быть массивом или объектной переменной.</param>
        <summary>Читает данные из открытого последовательного файла и присваивает данные переменным.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, не использующих `My.Computer.FileSystem` устаревшие версии, объект обеспечивает лучшую производительность. Дополнительные сведения см. [в разделе доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Данные, считанные с помощью `Input` , обычно записываются в файл с помощью. `Write` Используйте эту функцию только с файлами, открытыми `Input` в `Binary` режиме или.  
  
> [!IMPORTANT]
>  При чтении из файлов не следует принимать решения о содержимом файла на основе расширения имени файла. Например, файл с именем Form1. vb не может быть исходным файлом Visual Basic 2005.  
  
 При чтении стандартные строковые или числовые данные присваиваются переменным без изменения. В следующей таблице показано, как обрабатываются другие входные данные.  
  
|Данные|Значение, присвоенное переменной|  
|-|-|  
|Разделительная запятая или пустая строка|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # или #FALSE #|`True` или `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Дата и/или время, представленные выражением|  
|#ERROR`errornumber`#|`errornumber`(переменная является объектом, помеченным как ошибка)|  
  
 Если достигнут конец файла при вводе элемента данных, входные данные останавливаются и возникает ошибка.  
  
> [!NOTE]
>  `Input` Функция не локализована. Например, в немецкой версии при вводе 3, 14159 возвращает только 3, поскольку запятая обрабатывается как разделитель переменных, а не как десятичная точка.  
  
> [!IMPORTANT]
>  Для чтения из файла с помощью `Input` функции требуется `Read` доступ из `FileIOPermissionAccess` перечисления. Для получения дополнительной информации см. <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере `Input` функция используется для считывания данных из файла в две переменные. В этом примере предполагается, что `TestFile` это файл с несколькими строками данных, записанными в него `Write` с помощью функции, каждая строка которой содержит строку в кавычках и номер, разделенный запятыми, например: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Практическое руководство. Запись текста в файлы в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Практическое руководство. Запись текста в файл с помощью StreamWriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref string Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, string&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::String ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Переменная, которой присваиваются значения, считанные из файла. Не может быть массивом или объектной переменной.</param>
        <summary>Читает данные из открытого последовательного файла и присваивает данные переменным.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, не использующих `My.Computer.FileSystem` устаревшие версии, объект обеспечивает лучшую производительность. Дополнительные сведения см. [в разделе доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Данные, считанные с помощью `Input` , обычно записываются в файл с помощью. `Write` Используйте эту функцию только с файлами, открытыми `Input` в `Binary` режиме или.  
  
> [!IMPORTANT]
>  При чтении из файлов не следует принимать решения о содержимом файла на основе расширения имени файла. Например, файл с именем Form1. vb не может быть исходным файлом Visual Basic 2005.  
  
 При чтении стандартные строковые или числовые данные присваиваются переменным без изменения. В следующей таблице показано, как обрабатываются другие входные данные.  
  
|Данные|Значение, присвоенное переменной|  
|-|-|  
|Разделительная запятая или пустая строка|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # или #FALSE #|`True` или `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Дата и/или время, представленные выражением|  
|#ERROR`errornumber`#|`errornumber`(переменная является объектом, помеченным как ошибка)|  
  
 Если достигнут конец файла при вводе элемента данных, входные данные останавливаются и возникает ошибка.  
  
> [!NOTE]
>  `Input` Функция не локализована. Например, в немецкой версии при вводе 3, 14159 возвращает только 3, поскольку запятая обрабатывается как разделитель переменных, а не как десятичная точка.  
  
> [!IMPORTANT]
>  Для чтения из файла с помощью `Input` функции требуется `Read` доступ из `FileIOPermissionAccess` перечисления. Для получения дополнительной информации см. <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере `Input` функция используется для считывания данных из файла в две переменные. В этом примере предполагается, что `TestFile` это файл с несколькими строками данных, записанными в него `Write` с помощью функции, каждая строка которой содержит строку в кавычках и номер, разделенный запятыми, например: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Практическое руководство. Запись текста в файлы в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Практическое руководство. Запись текста в файл с помощью StreamWriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="InputString">
      <MemberSignature Language="C#" Value="public static string InputString (int FileNumber, int CharCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputString(int32 FileNumber, int32 CharCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputString (FileNumber As Integer, CharCount As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ InputString(int FileNumber, int CharCount);" />
      <MemberSignature Language="F#" Value="static member InputString : int * int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.InputString (FileNumber, CharCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="CharCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="CharCount">Обязательный. Любое допустимое числовое выражение, указывающее число знаков, которые надо прочитать.</param>
        <summary>Возвращает значение <see langword="String" />, содержащее знаки из файла, открытого в режиме <see langword="Input" /> или <see langword="Binary" />. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="InputString" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Строка, содержащая знаки из файла, открытого в режиме <see langword="Input" /> или <see langword="Binary" />. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="InputString" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `InputString` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, не использующих `My.Computer.FileSystem` устаревшие версии, объект обеспечивает лучшую производительность. Дополнительные сведения см. [в разделе доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Данные, считанные `InputString` с помощью функции, обычно записываются в `Print` файл `FilePut`с помощью или. Используйте эту функцию только с файлами, открытыми `Input` в `Binary` режиме или.  
  
 `Input` В`InputString` отличие от функции функция возвращает все считанные символы. Сюда входят запятые, возвраты каретки, символы перевода строки, кавычки и начальные пробелы.  
  
 При открытии файлов, `Binary` открытых для доступа, попытка чтения файла с `InputString` помощью функции до `EOF` возврата `True` приведет к ошибке. `Loc` `InputString` `EOF` Используйтефункции`FileGet` и вместо `EOF` при чтении двоичных файлов с помощью или при использовании функции. `LOF`  
  
> [!NOTE]
>  При чтении из файлов не следует принимать решения о безопасности содержимого файла на основе расширения имени файла. Например, файл с именем Form1. vb не может быть Visual Basic исходным файлом.  
  
   
  
## Examples  
 В этом примере `InputString` функция используется для считывания одного символа за раз из файла и вывода его `Output` в окно. В этом примере предполагается, что `MyFile` — это текстовый файл, содержащий несколько строк образца данных.  
  
 [!code-vb[VbVbalrCatRef#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="FileNumber" /> — не существует.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="CharCount" />&lt; 0 или &gt; 214.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Практическое руководство. Запись текста в файл с помощью StreamWriter (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Практическое руководство. Запись текста в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public static void Kill (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Kill(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill (PathName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Kill(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member Kill : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Kill PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Обязательный. Строковое выражение, определяющее файлы, которые должны быть удалены. Выражение <paramref name="PathName" /> может содержать имя каталога или папки и имя диска.</param>
        <summary>Удаляет файлы с диска. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="Kill" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Kill`поддерживает использование подстановочных знаков с несколькими символами (`*`) и одиночными символами (`?`) для указания нескольких файлов.  
  
 **Примечание по безопасности** Для выполнения `Kill` функции требуется `Read` , <xref:System.Security.Permissions.FileIOPermission> чтобы в выполняемый `PathDiscovery` код были предоставлены флаги и. Дополнительные сведения см. в <xref:System.Security.SecurityException>разделе [разрешения на доступ к коду](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675) .  
  
   
  
## Examples  
 В этом примере `Kill` функция используется для удаления файла с диска.  
  
 [!code-vb[VbVbalrCatRef#60](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Удаляемые файлы открыты.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Удаляемые файлы не найдены.</exception>
        <exception cref="T:System.Security.SecurityException">В разрешении отказано.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="LineInput">
      <MemberSignature Language="C#" Value="public static string LineInput (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static string LineInput(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LineInput (FileNumber As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LineInput(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LineInput : int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.LineInput FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <summary>Читает одну строку из открытого последовательного файла и присваивает ее переменной типа <see langword="String" />.</summary>
        <returns>Читает одну строку из открытого последовательного файла и присваивает ее переменной типа <see langword="String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `LineInput` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, не использующих `My.Computer.FileSystem` устаревшие версии, объект обеспечивает лучшую производительность. Дополнительные сведения см. [в разделе доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Данные, считанные с помощью `LineInput` , обычно записываются в файл с помощью. `Print`  
  
> [!IMPORTANT]
>  При чтении из файлов не следует принимать решения о содержимом файла на основе расширения имени файла. Например, файл с именем Form1. vb не может быть Visual Basic исходным файлом.  
  
 Функция считывает данные из файла по одному символу за раз, пока не встретится последовательность возврата каретки (`Chr(13)`) или возврата каретки/`Chr(13) + Chr(10)`перевода строки (). `LineInput` Последовательности возврата каретки и перевода строки пропускаются вместо добавления к строке символов.  
  
> [!IMPORTANT]
>  Для чтения из файла с помощью `LineInput` функции требуется `Read` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере `LineInput` функция используется для считывания строки из последовательного файла и ее присвоения переменной. В этом примере предполагается, что `TestFile` — это текстовый файл, содержащий несколько строк образца данных.  
  
 [!code-vb[VbVbalrCatRef#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">Достигнут конец файла.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="FileNumber" /> — не существует.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Практическое руководство. Запись текста в файл с помощью StreamWriter (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Практическое руководство. Запись текста в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Loc">
      <MemberSignature Language="C#" Value="public static long Loc (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Loc(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Loc (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Loc(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Loc : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Loc FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла типа <see langword="Integer" />.</param>
        <summary>Возвращает значение, указывающее текущую позицию для ввода-вывода в открытом файле.</summary>
        <returns>Текущая позиция чтения или записи в открытом файле.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Loc` Функция отсчитывается от нуля; использование ее для получения первого байта в файле возвратит 0.  
  
 `Loc` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, не использующих `My.Computer.FileSystem` устаревшие версии, объект обеспечивает лучшую производительность. Дополнительные сведения см. [в разделе доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Ниже описаны возвращаемые значения для каждого режима доступа к файлу.  
  
|Режим|Возвращаемое значение|  
|-|-|  
|`Random`|Номер последней записи, считанной из файла или записанной в файл.|  
|`Sequential`|Текущее значение байта в файле, деленное на 128. Однако сведения, возвращаемые `Loc` для последовательных файлов, не используются и не требуются.|  
|`Binary`|Расположение последнего считанного или записанного байта.|  
  
   
  
## Examples  
 В этом примере `Loc` функция используется для возврата текущей позицией чтения/записи в открытом файле. В этом примере предполагается, что `MyFile` — это текстовый файл, содержащий несколько строк образца данных.  
  
 [!code-vb[VbVbalrCatRef#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Lock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Управляет доступом других процессов ко всему файлу, открытому с помощью функции <see langword="Open" />, или к его части. Средства из пространства имен <see langword="My" /> обеспечивают большую производительность и быстродействие операций файлового ввода-вывода, чем методы <see langword="Lock" /> и <see langword="Unlock" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Lock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <summary>Управляет доступом других процессов ко всему файлу, открытому с помощью функции <see langword="Open" />, или к его части. Средства из пространства имен <see langword="My" /> обеспечивают большую производительность и быстродействие операций файлового ввода-вывода, чем методы <see langword="Lock" /> и <see langword="Unlock" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Функции `Lock` и`Unlock` используются в средах, где некоторым процессам может потребоваться доступ к одному и тому же файлу.  
  
 `Lock`функции `Unlock` и всегда используются парами. Аргументы для `Lock` и `Unlock` должны быть идентичны.  
  
 Если `Record`, или `FromRecord` и `ToRecord` не указаны, блокировка будет выполняться для всего файла. Если `Record` указан отдельный параметр, одна запись будет заблокирована или разблокирована.  
  
 Значение, `Lock` если файл был открыт для последовательного ввода или вывода `Unlock` и влияет на весь файл, независимо от диапазона, указанного в `FromRecord` и`ToRecord`.  
  
   
  
## Examples  
 В этом примере показано использование `Lock` функций и. `Unlock` В этом примере предполагается, что `People.txt` — это файл, содержащий записи структуры. `Person`  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Record">Необязательный параметр. Номер единственной записи или единственного байта для блокировки или разблокировки.</param>
        <summary>Управляет доступом других процессов ко всему файлу, открытому с помощью функции <see langword="Open" />, или к его части. Средства из пространства имен <see langword="My" /> обеспечивают большую производительность и быстродействие операций файлового ввода-вывода, чем методы <see langword="Lock" /> и <see langword="Unlock" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Функции `Lock` и`Unlock` используются в средах, где некоторым процессам может потребоваться доступ к одному и тому же файлу.  
  
 `Lock`функции `Unlock` и всегда используются парами. Аргументы для `Lock` и `Unlock` должны быть идентичны.  
  
 Если `Record`, или `FromRecord` и `ToRecord` не указаны, блокировка будет выполняться для всего файла. Если `Record` указан отдельный параметр, одна запись будет заблокирована или разблокирована.  
  
 Значение, `Lock` если файл был открыт для последовательного ввода или вывода `Unlock` и влияет на весь файл, независимо от диапазона, указанного в `FromRecord` и`ToRecord`.  
  
   
  
## Examples  
 В этом примере показано использование `Lock` функций и. `Unlock` В этом примере предполагается, что `People.txt` — это файл, содержащий записи структуры. `Person`  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="FromRecord">Необязательный параметр. Номер первой записи или первого байта, начиная с которого файл открывается или закрывается для доступа.</param>
        <param name="ToRecord">Необязательный параметр. Номер последней записи или последнего байта, которыми заканчивается часть файла, открытая или закрытая для доступа.</param>
        <summary>Управляет доступом других процессов ко всему файлу, открытому с помощью функции <see langword="Open" />, или к его части. Средства из пространства имен <see langword="My" /> обеспечивают большую производительность и быстродействие операций файлового ввода-вывода, чем методы <see langword="Lock" /> и <see langword="Unlock" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Функции `Lock` и`Unlock` используются в средах, где некоторым процессам может потребоваться доступ к одному и тому же файлу.  
  
 `Lock`функции `Unlock` и всегда используются парами. Аргументы для `Lock` и `Unlock` должны быть идентичны.  
  
 Если `Record`, или `FromRecord` и `ToRecord` не указаны, блокировка будет выполняться для всего файла. Если `Record` указан отдельный параметр, одна запись будет заблокирована или разблокирована.  
  
 Значение, `Lock` если файл был открыт для последовательного ввода или вывода `Unlock` и влияет на весь файл, независимо от диапазона, указанного в `FromRecord` и`ToRecord`.  
  
   
  
## Examples  
 В этом примере показано использование `Lock` функций и. `Unlock` В этом примере предполагается, что `People.txt` — это файл, содержащий записи структуры. `Person`  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="LOF">
      <MemberSignature Language="C#" Value="public static long LOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 LOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LOF (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long LOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LOF : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.LOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Целое число, содержащее допустимый номер файла.</param>
        <summary>Возвращает размер (в байтах) файла, открытого функцией <see langword="FileOpen" />. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="LOF" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Размер (в байтах) файла, открытого функцией <see langword="FileOpen" />. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="LOF" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileLen` Используйте функцию, чтобы получить длину неоткрытого файла.  
  
   
  
## Examples  
 В этом примере `LOF` функция используется для определения размера открытого файла. В этом примере предполагается, что `TestFile` является текстовым файлом, содержащим образец данных.  
  
 [!code-vb[VbVbalrCatRef#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Чтение из файлов в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="MkDir">
      <MemberSignature Language="C#" Value="public static void MkDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MkDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MkDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MkDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member MkDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.MkDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Обязательный. Строковое выражение, задающее создаваемый каталог. Параметр <paramref name="Path" /> может содержать метку диска. Если диск не указан, <see langword="MkDir" /> создает каталог на текущем диске.</param>
        <summary>Создает каталог. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="MkDir" />. Для получения дополнительной информации см. <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта функция создает новый каталог.  
  
   
  
## Examples  
 В этом примере используется `MkDir` функция для создания каталога. Если диск не указан, новый каталог создается на текущем диске.  
  
 [!code-vb[VbVbalrCatRef#38](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Path" /> не указан или пуст.</exception>
        <exception cref="T:System.Security.SecurityException">В разрешении отказано.</exception>
        <exception cref="T:System.IO.IOException">Каталог уже существует.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-directory.md">Практическое руководство. Создание каталога в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Print">
      <MemberSignature Language="C#" Value="public static void Print (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Print(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Print (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Print(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Print : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Print (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Output">Необязательный. Ноль или больше выражений с разделителями-запятыми для записи в файл.  
  
Параметры аргумента <paramref name="Output" />: 
 <see langword="T:System.IO.IOException" />: Недопустимый режим файла.  
  
 <see langword="T:System.IO.IOException" />: <paramref name="FileNumber" /> не существует.</param>
        <summary>Записывает отформатированные данные в последовательный файл.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Функции `Print` и`PrintLine` предоставляются для обеспечения обратной совместимости и могут повлиять на производительность. Для приложений, не использующих `My.Computer.FileSystem` устаревшие версии, объект обеспечивает лучшую производительность. Дополнительные сведения см. [в разделе доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 `Print`не включает символ перевода строки в конце строки; `PrintLine` однако включает в себя перевод строки.  
  
 Данные, записанные с помощью `Print` , обычно считываются из файла с помощью `LineInput` или `Input`.  
  
 Если не указано значение `Print`, в файл выводится пустая строка; в параметре ничего не выводится. `PrintLine` `Output` Несколько выражений, разделенных запятыми, будут выделены по границам табуляции, `TAB` но можно смешивать запятые и привести к несогласованным результатам.  
  
 Для `Boolean` данных `True` либо печатается.`False` Ключевые слова `False` и не переводятся независимо от языкового стандарта. `True`  
  
 Данные даты записываются в файл с использованием стандартного краткого формата даты, распознаваемого системой. Если либо дата, либо компонент времени отсутствует или равен нулю, в файл записывается только часть, указанная в файле.  
  
 Если `Output` данные пусты, в файл ничего не записывается. Однако, если `Output` данные списка имеют `DBNull`значение `Null` , записывается в файл.  
  
 Для `Error` данных выходные данные отображаются как `Error errorcode`. `Error` Ключевое слово не переводится, независимо от языкового стандарта.  
  
 Все данные, записанные в файл с `Print` помощью, имеют международный формат, т. е. данные правильно отформатированы с помощью соответствующего десятичного разделителя. Если пользователь хочет выводить данные для использования несколькими языками, `Write` следует использовать.  
  
 Для записи `Print` в файл с помощью `PrintLine` `Write` функций или требуется доступ из перечисления.`FileIOPermissionAccess` Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере для `Print` записи `PrintLine` данных в файл используются функции и.  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Практическое руководство. Запись текста в файлы в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Практическое руководство. Запись текста в файл с помощью StreamWriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="PrintLine">
      <MemberSignature Language="C#" Value="public static void PrintLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void PrintLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub PrintLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrintLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member PrintLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.PrintLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Output">Необязательный. Ноль или больше выражений с разделителями-запятыми для записи в файл.  
  
Параметры аргумента <paramref name="Output" />: 
 <see langword="T:System.IO.IOException" />: Недопустимый режим файла.  
  
 <see langword="T:System.IO.IOException" />: <paramref name="FileNumber" /> не существует.</param>
        <summary>Записывает отформатированные данные в последовательный файл.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Функции `Print` и`PrintLine` предоставляются для обеспечения обратной совместимости и могут повлиять на производительность. Для приложений, не использующих `My.Computer.FileSystem` устаревшие версии, объект обеспечивает лучшую производительность. Дополнительные сведения см. [в разделе доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 `Print`не включает символ перевода строки в конце строки; `PrintLine` однако включает в себя перевод строки.  
  
 Данные, записанные с помощью `Print` , обычно считываются из файла с помощью `LineInput` или `Input`.  
  
 Если не указано значение `Print`, в файл выводится пустая строка; в параметре ничего не выводится. `PrintLine` `Output` Несколько выражений, разделенных запятыми, будут выделены по границам табуляции, `TAB` но можно смешивать запятые и привести к несогласованным результатам.  
  
 Для `Boolean` данных `True` либо печатается.`False` Ключевые слова `False` и не переводятся независимо от языкового стандарта. `True`  
  
 Данные даты записываются в файл с использованием стандартного краткого формата даты, распознаваемого системой. Если либо дата, либо компонент времени отсутствует или равен нулю, в файл записывается только часть, указанная в файле.  
  
 Если `Output` данные пусты, в файл ничего не записывается. Однако, если `Output` данные списка имеют `DBNull`значение `Null` , записывается в файл.  
  
 Для `Error` данных выходные данные отображаются как `Error errorcode`. `Error` Ключевое слово не переводится, независимо от языкового стандарта.  
  
 Все данные, записанные в файл с `Print` помощью, имеют международный формат, т. е. данные правильно отформатированы с помощью соответствующего десятичного разделителя. Если пользователь хочет выводить данные для использования несколькими языками, `Write` следует использовать.  
  
 Для записи `Print` в файл с помощью `PrintLine` `Write` функций или требуется доступ из перечисления.`FileIOPermissionAccess` Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере для `Print` записи `PrintLine` данных в файл используются функции и.  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Практическое руководство. Запись текста в файлы в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Практическое руководство. Запись текста в файл с помощью StreamWriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Rename">
      <MemberSignature Language="C#" Value="public static void Rename (string OldPath, string NewPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Rename(string OldPath, string NewPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Rename (OldPath As String, NewPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Rename(System::String ^ OldPath, System::String ^ NewPath);" />
      <MemberSignature Language="F#" Value="static member Rename : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Rename (OldPath, NewPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="OldPath" Type="System.String" />
        <Parameter Name="NewPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="OldPath">Обязательный. Строковое выражение, указывающее имя и расположение существующего файла. Выражение <paramref name="OldPath" /> может содержать имя каталога и метку диска для файла.</param>
        <param name="NewPath">Обязательный. Строковое выражение, указывающее имя и расположение нового файла. Параметр <paramref name="NewPath" /> может содержать имя каталога и метку диска для нового местонахождения файла. Имя файла, заданного параметром <paramref name="NewPath" /> не может быть именем существующего файла.</param>
        <summary>Переименовывает файл или каталог на диске. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="Rename" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Rename` Функция переименовывает файл и перемещает его в другой каталог, если это необходимо. Функция может перемещать файл между дисками, но он может переименовать существующий каталог, если оба `NewPath` и `OldPath` находятся на одном диске. `Rename` `Rename`не удается создать новый файл или каталог.  
  
 `Rename` Использование функции в открытом файле приводит к ошибке. Необходимо закрыть открытый файл перед его переименованием. `Rename`аргументы не могут содержать подстановочные знаки (*) и один символ (?).  
  
> [!IMPORTANT]
>  При использовании `Rename` для копирования файла из незащищенного расположения в защищенное расположение файл остается менее ограниченными правами. Убедитесь, что вы не представляете угрозы безопасности.  
  
   
  
## Examples  
 В этом примере `Rename` функция используется для переименования файла. Для целей этого примера предположим, что указанные каталоги уже существуют.  
  
 [!code-vb[VbVbalrCatRef#30](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Недопустимый путь.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл <paramref name="OldPath" /> не существует.</exception>
        <exception cref="T:System.IO.IOException">Нельзя переименовать с указанием другого диска.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md">Практическое руководство. Переименование файла в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public static void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reset();" />
      <MemberSignature Language="F#" Value="static member Reset : unit -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Закрывает все файлы на диске, открытые функцией <see langword="FileOpen" />. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="Reset" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Функция закрывает все активные файлы `FileOpen` , открытые функцией, и имеет ту же функцию, `FileClose()` что и без параметров. `Reset`  
  
   
  
## Examples  
 В этом примере `Reset` функция используется для закрытия всех открытых файлов и записи содержимого всех буферов файлов на диск. Обратите внимание на использование `Object` переменной `FileNumber` в качестве строки и числа.  
  
 [!code-vb[VbVbalrCatRef#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/end-statement.md">Оператор End</related>
      </Docs>
    </Member>
    <Member MemberName="RmDir">
      <MemberSignature Language="C#" Value="public static void RmDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RmDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RmDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RmDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member RmDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.RmDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Обязательный. Строковое выражение, определяющее удаляемый каталог или папку. Параметр <paramref name="Path" /> может содержать метку диска. Если диск не указан, <see langword="RmDir" /> удаляет каталог на текущем диске.</param>
        <summary>Удаляет существующий каталог. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="RmDir" />. Для получения дополнительной информации см. <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При попытке использования `RmDir` в каталоге, содержащем файлы, возникает ошибка. `Kill` Используйте функцию, чтобы удалить все файлы перед попыткой удаления каталога.  
  
   
  
## Examples  
 В этом примере `RmDir` функция используется для удаления существующего каталога.  
  
 [!code-vb[VbVbalrCatRef#31](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#31)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Path" /> не указан или пуст.</exception>
        <exception cref="T:System.IO.IOException">Удаляемый каталог содержит файлы.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Каталог не существует.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Seek">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает значение типа <see langword="Long" />, указывающее текущую позицию ввода-вывода в файле, открытом функцией <see langword="FileOpen" />, или устанавливает позицию для следующей операции ввода-вывода в файле, открытом с помощью функции <see langword="FileOpen" />. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="Seek" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static long Seek (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Seek(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Seek (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Seek(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Seek : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Seek FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Значение <see langword="Integer" />, содержащее допустимый номер файла.</param>
        <summary>Возвращает значение типа <see langword="Long" />, указывающее текущую позицию ввода-вывода в файле, открытом функцией <see langword="FileOpen" />, или устанавливает позицию для следующей операции ввода-вывода в файле, открытом с помощью функции <see langword="FileOpen" />. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="Seek" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Значение типа <see langword="Long" />, указывающее текущую позицию ввода-вывода в файле, открытом функцией <see langword="FileOpen" />, или устанавливает позицию для следующей операции ввода-вывода в файле, открытом с помощью функции <see langword="FileOpen" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek`Возвращает значение от 1 до 2 147 483 647 (эквивалентно 2 ^ 31-1) включительно.  
  
 Ниже описаны возвращаемые значения для каждого режима доступа к файлу.  
  
|Режим|Возвращаемое значение|  
|-|-|  
|`Random`|Номер следующей записи, чтение или запись|  
|`Binary`, `Input`, `Output`, `Append`|Номер позиции в байте, с которой происходит следующая операция. Первый байт в файле находится в позиции 1, второй байт — на позиции 2 и т. д.|  
  
   
  
## Examples  
 В этом примере используется `Seek` функция для возврата текущей позицией в файле. В примере предполагается `TestFile` , что это файл, содержащий записи структуры `Record`.  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 Для файлов, открытых `Random` в режиме `Seek` , возвращает номер следующей записи.  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 Для файлов, открытых в режимах `Random` , отличных от Mode, `Seek` возвращает точку байта, с которой происходит следующая операция. Предположим `TestFile` , что это файл, содержащий несколько строк текста.  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 В этом примере `Seek` функция используется для задания места следующего чтения или записи в файле.  
  
 Для файлов, открытых в режимах `Random` , отличных от Mode, `Seek` задает точку байта, с которой происходит следующая операция. Предположим `TestFile` , что это файл, содержащий несколько строк текста.  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Чтение из файлов в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static void Seek (int FileNumber, long Position);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Seek(int32 FileNumber, int64 Position) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (FileNumber As Integer, Position As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Seek(int FileNumber, long Position);" />
      <MemberSignature Language="F#" Value="static member Seek : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Seek (FileNumber, Position)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Значение <see langword="Integer" />, содержащее допустимый номер файла.</param>
        <param name="Position">Обязательный. Число в диапазоне от 1 до 2 147 483 647 включительно, определяющее место следующей операции чтения/записи.</param>
        <summary>Возвращает значение типа <see langword="Long" />, указывающее текущую позицию ввода-вывода в файле, открытом функцией <see langword="FileOpen" />, или устанавливает позицию для следующей операции ввода-вывода в файле, открытом с помощью функции <see langword="FileOpen" />. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="Seek" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek`Возвращает значение от 1 до 2 147 483 647 (эквивалентно 2 ^ 31-1) включительно.  
  
 Ниже описаны возвращаемые значения для каждого режима доступа к файлу.  
  
|Режим|Возвращаемое значение|  
|-|-|  
|`Random`|Номер следующей записи, чтение или запись|  
|`Binary`, `Input`, `Output`, `Append`|Номер позиции в байте, с которой происходит следующая операция. Первый байт в файле находится в позиции 1, второй байт — на позиции 2 и т. д.|  
  
   
  
## Examples  
 В этом примере используется `Seek` функция для возврата текущей позицией в файле. В примере предполагается `TestFile` , что это файл, содержащий записи структуры `Record`.  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 Для файлов, открытых `Random` в режиме `Seek` , возвращает номер следующей записи.  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 Для файлов, открытых в режимах `Random` , отличных от Mode, `Seek` возвращает точку байта, с которой происходит следующая операция. Предположим `TestFile` , что это файл, содержащий несколько строк текста.  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 В этом примере `Seek` функция используется для задания места следующего чтения или записи в файле.  
  
 Для файлов, открытых в режимах `Random` , отличных от Mode, `Seek` задает точку байта, с которой происходит следующая операция. Предположим `TestFile` , что это файл, содержащий несколько строк текста.  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Чтение из файлов в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="SetAttr">
      <MemberSignature Language="C#" Value="public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SetAttr(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAttr (PathName As String, Attributes As FileAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAttr(System::String ^ PathName, Microsoft::VisualBasic::FileAttribute Attributes);" />
      <MemberSignature Language="F#" Value="static member SetAttr : string * Microsoft.VisualBasic.FileAttribute -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.SetAttr (PathName, Attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName">Обязательный. Строковое выражение, определяющее имя файла. <paramref name="PathName" /> может включать каталог или папку, а также диск.</param>
        <param name="Attributes">Обязательный. Константа или числовое выражение, сумма которого определяет атрибуты файла.</param>
        <summary>Устанавливает атрибуты файла. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="SetAttr" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При попытке задать атрибуты открытого файла возникает ошибка времени выполнения.  
  
 Ниже приведены значения перечисления аргументов.`Attributes`  
  
|Значение|Константа|Описание|  
|-|-|-|  
|`Normal`|`vbNormal`|Обычная (по умолчанию).|  
|`ReadOnly`|`vbReadOnly`|Только для чтения.|  
|`Hidden`|`vbHidden`|Скрытый.|  
|`System`|`vbSystem`|Системный файл.|  
|`Volume`|`vbVolume`|Метка тома|  
|`Directory`|`vbDirectory`|Каталог или папка.|  
|`Archive`|`vbArchive`|Файл был изменен с момента создания последней резервной копии.|  
|`Alias`|`vbAlias`|У файла другое имя.|  
  
> [!NOTE]
>  Эти перечисления определены в языке Visual Basic. Имена можно использовать в любом месте кода вместо фактических значений.  
  
   
  
## Examples  
 В этом примере `SetAttr` функция используется для задания атрибутов для файла.  
  
 [!code-vb[VbVbalrCatRef#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Недопустимый тип <paramref name="Attribute" />.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="SPC">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.SpcInfo SPC (short Count);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.SpcInfo SPC(int16 Count) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function SPC (Count As Short) As SpcInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::SpcInfo SPC(short Count);" />
      <MemberSignature Language="F#" Value="static member SPC : int16 -&gt; Microsoft.VisualBasic.SpcInfo" Usage="Microsoft.VisualBasic.FileSystem.SPC Count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.SpcInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Count" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Count">Обязательный. Число пробелов, вставляемых перед отображением или печатью очередного выражения в списке.</param>
        <summary>Используется с функцией <see langword="Print" /> или <see langword="PrintLine" /> для установки позиции вывода.</summary>
        <returns>Используется с функцией <see langword="Print" /> или <see langword="PrintLine" /> для установки позиции вывода.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `Count` параметр меньше, чем ширина строки вывода, Следующая позиция печати сразу следует за числом напечатанных пробелов. Если`Count` значение больше, чем ширина строки вывода, `SPC` вычисляет следующую точку печати с помощью формулы:  
  
 `currentprintposition`(+(`Count``Mod``width`))  
  
 Например, если текущей позицией печати является 24, ширина строки вывода равна 80, и вы указываете `SPC(90)`, что следующая печать начнется в позиции 34 (Текущая строка печати + остаток от 90/80). Если разница между текущей позицией печати `Count` и толщиной строки вывода меньше (или ** `SPC` `Count` `Mod` ширины), функция переходит к началу следующей строки и создает пробелы, равные `Count`-(*Width* - *куррентпринтпоситион*).  
  
> [!NOTE]
>  Убедитесь, что табличные столбцы достаточно широки, чтобы иметь широкие буквы.  
  
   
  
## Examples  
 В этом примере `SPC` функция используется для размещения выходных данных в файле и в окне **вывода** .  
  
 [!code-vb[VbVbalrCatRef#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md">Оператор Mod (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TAB">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Используется с функциями <see langword="Print" /> или <see langword="PrintLine" /> для установки позиции вывода.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB ();" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB () As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB();" />
      <MemberSignature Language="F#" Value="static member TAB : unit -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Используется с функциями <see langword="Print" /> или <see langword="PrintLine" /> для установки позиции вывода.</summary>
        <returns>Используется с функциями <see langword="Print" /> или <see langword="PrintLine" /> для установки позиции вывода.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если текущая строка печати в текущей строке больше `Column`, то пропускается до значения столбца, `TAB` равного `Column` значению в следующей строке вывода. Если `Column` значение меньше 1, `TAB` перемещает отпечаток в столбец 1. Если `Column` значение больше, чем ширина строки вывода, `TAB` вычисляет следующую точку печати с помощью формулы:  
  
 Ширина столбца (MOD)  
  
 Например, если значение *Width* равно 80 и указано `TAB(90)`, то следующая печать начнется в столбце 10 (остаток от 90/80). Если `Column` значение меньше текущей позиции печати, печать начинается со следующей строки в вычисляемой позиции печати. Если вычисленная позиции печати больше текущей позиции печати, то печать начинается с вычисленной позиции печати в той же строке.  
  
 Крайняя левая положение печати в строке вывода всегда равно 1. Если для печати в `Print` файлы `PrintLine` используются функции или, крайняя правая позиция печати — это текущая ширина выходного файла, которую можно задать с помощью `FileWidth` функции.  
  
 Функцию также можно использовать `WriteLine` с функцией. `TAB` Его нельзя использовать с <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> или. <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>  
  
> [!NOTE]
>  Убедитесь, что табличные столбцы достаточно широки, чтобы содержать широкие буквы.  
  
   
  
## Examples  
 В этом примере `TAB` функция используется для размещения выходных данных в файле и в окне **вывода** .  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md">Оператор Mod (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB (short Column);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB(int16 Column) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB (Column As Short) As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB(short Column);" />
      <MemberSignature Language="F#" Value="static member TAB : int16 -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB Column" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Column" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Column">Необязательный параметр. Номер столбца, в который помещается курсор перед отображением или печатью следующего выражения из списка. Если этот параметр опущен, <see langword="TAB" /> перемещает положение курсора в начало следующей зоны печати.</param>
        <summary>Используется с функциями <see langword="Print" /> или <see langword="PrintLine" /> для установки позиции вывода.</summary>
        <returns>Используется с функциями <see langword="Print" /> или <see langword="PrintLine" /> для установки позиции вывода.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если текущая строка печати в текущей строке больше `Column`, то пропускает значение столбца, `TAB` равное `Column` значению в следующей строке вывода. Если `Column` значение меньше 1, `TAB` перемещает отпечаток в столбец 1. Если `Column` значение больше, чем ширина строки вывода, `TAB` вычисляет следующую точку печати с помощью формулы:  
  
 Ширина столбца (MOD)  
  
 Например, если значение *Width* равно 80 и указано `TAB(90)`, то следующая печать начнется в столбце 10 (остаток от 90/80). Если `Column` значение меньше текущей позиции печати, печать начинается со следующей строки в вычисляемой позиции печати. Если вычисленная позиции печати больше текущей позиции печати, то печать начинается с вычисленной позиции печати в той же строке.  
  
 Крайняя левая положение печати в строке вывода всегда равно 1. Если для печати в `Print` файлы `PrintLine` используются функции или, крайняя правая позиция печати — это текущая ширина выходного файла, которую можно задать с помощью `FileWidth` функции.  
  
 Функцию также можно использовать `WriteLine` с функцией. `TAB` Его нельзя использовать с <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> или. <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>  
  
> [!NOTE]
>  Убедитесь, что табличные столбцы достаточно широки, чтобы содержать широкие буквы.  
  
   
  
## Examples  
 В этом примере `TAB` функция используется для размещения выходных данных в файле и в окне **вывода** .  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md">Оператор Mod (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Unlock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Управляет доступом других процессов ко всему файлу, открытому с помощью функции <see langword="Open" />, или к его части. Средства из пространства имен <see langword="My" /> обеспечивают большую производительность и быстродействие операций файлового ввода-вывода, чем методы <see langword="Lock" /> и <see langword="Unlock" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Unlock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <summary>Управляет доступом других процессов ко всему файлу, открытому с помощью функции <see langword="Open" />, или к его части. Средства из пространства имен <see langword="My" /> обеспечивают большую производительность и быстродействие операций файлового ввода-вывода, чем методы <see langword="Lock" /> и <see langword="Unlock" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Функции `Lock` и`Unlock` используются в средах, где некоторым процессам может потребоваться доступ к одному и тому же файлу.  
  
 `Lock`функции `Unlock` и всегда используются парами. Аргументы для `Lock` и `Unlock` должны быть идентичны.  
  
 Если `Record`, или `FromRecord` и `ToRecord` не указаны, блокировка будет выполняться для всего файла. Если `Record` указан отдельный параметр, одна запись будет заблокирована или разблокирована.  
  
 Значение, `Lock` если файл был открыт для последовательного ввода или вывода `Unlock` и влияет на весь файл, независимо от диапазона, указанного в `FromRecord` и`ToRecord`.  
  
   
  
## Examples  
 В этом примере показано использование `Lock` функций и. `Unlock` В этом примере предполагается, что `People.txt` — это файл, содержащий записи структуры. `Person`  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Record">Необязательный параметр. Номер единственной записи или единственного байта для блокировки или разблокировки.</param>
        <summary>Управляет доступом других процессов ко всему файлу, открытому с помощью функции <see langword="Open" />, или к его части. Средства из пространства имен <see langword="My" /> обеспечивают большую производительность и быстродействие операций файлового ввода-вывода, чем методы <see langword="Lock" /> и <see langword="Unlock" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Функции `Lock` и`Unlock` используются в средах, где некоторым процессам может потребоваться доступ к одному и тому же файлу.  
  
 `Lock`функции `Unlock` и всегда используются парами. Аргументы для `Lock` и `Unlock` должны быть идентичны.  
  
 Если `Record`, или `FromRecord` и `ToRecord` не указаны, блокировка будет выполняться для всего файла. Если `Record` указан отдельный параметр, одна запись будет заблокирована или разблокирована.  
  
 Значение, `Lock` если файл был открыт для последовательного ввода или вывода `Unlock` и влияет на весь файл, независимо от диапазона, указанного в `FromRecord` и`ToRecord`.  
  
   
  
## Examples  
 В этом примере показано использование `Lock` функций и. `Unlock` В этом примере предполагается, что `People.txt` — это файл, содержащий записи структуры. `Person`  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="FromRecord">Необязательный параметр. Номер первой записи или первого байта, начиная с которого файл открывается или закрывается для доступа.</param>
        <param name="ToRecord">Необязательный параметр. Номер последней записи или последнего байта, которыми заканчивается часть файла, открытая или закрытая для доступа.</param>
        <summary>Управляет доступом других процессов ко всему файлу, открытому с помощью функции <see langword="Open" />, или к его части. Средства из пространства имен <see langword="My" /> обеспечивают большую производительность и быстродействие операций файлового ввода-вывода, чем методы <see langword="Lock" /> и <see langword="Unlock" />. Для получения дополнительной информации см. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Функции `Lock` и`Unlock` используются в средах, где некоторым процессам может потребоваться доступ к одному и тому же файлу.  
  
 `Lock`функции `Unlock` и всегда используются парами. Аргументы для `Lock` и `Unlock` должны быть идентичны.  
  
 Если `Record`, или `FromRecord` и `ToRecord` не указаны, блокировка будет выполняться для всего файла. Если `Record` указан отдельный параметр, одна запись будет заблокирована или разблокирована.  
  
 Значение, `Lock` если файл был открыт для последовательного ввода или вывода `Unlock` и влияет на весь файл, независимо от диапазона, указанного в `FromRecord` и`ToRecord`.  
  
   
  
## Examples  
 В этом примере показано использование `Lock` функций и. `Unlock` В этом примере предполагается, что `People.txt` — это файл, содержащий записи структуры. `Person`  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Write(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Write : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Write (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Выражение <see langword="Integer" />, содержащее любой допустимый номер файла.</param>
        <param name="Output">Необязательный параметр. Одно или несколько выражений с разделителями-запятыми, которые нужно записать в файл.</param>
        <summary>Записывает данные в последовательный файл. Данные, записанные с использованием <see langword="Write" />, обычно считываются с помощью <see langword="Input" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Функции `Write` и`WriteLine` предоставляются для обеспечения обратной совместимости и могут повлиять на производительность. Для приложений, не использующих `My.Computer.FileSystem` устаревшие версии, объект обеспечивает лучшую производительность. Дополнительные сведения см. [в разделе доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Если опустить `Output`, в файл будет напечатано пустая строка. Несколько выражений можно разделить запятыми.  
  
 `Print` В`Write` отличие от функции, функция вставляет запятые между элементами и кавычками вокруг строк по мере их записи в файл. В списке не нужно добавлять явные разделители. Если `Write` используется для записи данных в файл, поддерживаются только форматы numeric `Boolean`, Date, NULL и `Error` Data. Следующие универсальные предположения следуют, поэтому данные всегда можно считать и правильно интерпретировать с помощью `Input`, независимо от языкового стандарта.  
  
-   Числовые данные всегда записываются с использованием точки в качестве десятичного разделителя.  
  
-   Для `Boolean` данных `#TRUE#` либо печатается.`#FALSE#` Ключевые слова `False` и не переводятся, независимо от языкового стандарта. `True`  
  
-   Данные даты записываются в файл с использованием универсального формата даты. Если либо дата, либо компонент времени отсутствует или равен нулю, в файл записывается только часть, указанная в файле.  
  
-   Если `Output` данные пусты, в файл ничего не записывается. Однако для данных `#NULL#` NULL записывается.  
  
-   Для `Error` данных выходные данные отображаются как `#ERROR errorcode#`. `Error` Ключевое слово не переводится, независимо от языкового стандарта.  
  
 `WriteLine`Вставляет символ новой строки (то есть символ возврата каретки или перевода строки или `Chr(13) + Chr(10)`) после того, как записал в файл окончательный символ в. `Output`  
  
 Кавычки можно внедрять в строку с помощью двойных кавычек или "". Например, примененная к объекту директива  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 Возвращает строку со значением `Double quotation marks aren't "difficult" to handle`.  
  
 Для записи `Write` в файл с помощью `WriteLine` `Append` функций или требуется доступ из перечисления.`FileIOPermissionAccess` Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере `Write` функция используется для записи необработанных данных в последовательный файл.  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Практическое руководство. Запись текста в файлы в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Практическое руководство. Запись текста в файл с помощью StreamWriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member WriteLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.WriteLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Выражение <see langword="Integer" />, содержащее любой допустимый номер файла.</param>
        <param name="Output">Необязательный параметр. Одно или несколько выражений с разделителями-запятыми, которые нужно записать в файл.</param>
        <summary>Записывает данные в последовательный файл. Данные, записанные с использованием <see langword="Write" />, обычно считываются с помощью <see langword="Input" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Функции `Write` и`WriteLine` предоставляются для обеспечения обратной совместимости и могут повлиять на производительность. Для приложений, не использующих `My.Computer.FileSystem` устаревшие версии, объект обеспечивает лучшую производительность. Дополнительные сведения см. [в разделе доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Если опустить `Output`, в файл будет напечатано пустая строка. Несколько выражений можно разделить запятыми.  
  
 `Print` В`Write` отличие от функции, функция вставляет запятые между элементами и кавычками вокруг строк по мере их записи в файл. В списке не нужно добавлять явные разделители. Если `Write` используется для записи данных в файл, поддерживаются только форматы numeric `Boolean`, Date, NULL и `Error` Data. Следующие универсальные предположения следуют, поэтому данные всегда можно считать и правильно интерпретировать с помощью `Input`, независимо от языкового стандарта.  
  
-   Числовые данные всегда записываются с использованием точки в качестве десятичного разделителя.  
  
-   Для `Boolean` данных `#TRUE#` либо печатается.`#FALSE#` Ключевые слова `False` и не переводятся, независимо от языкового стандарта. `True`  
  
-   Данные даты записываются в файл с использованием универсального формата даты. Если либо дата, либо компонент времени отсутствует или равен нулю, в файл записывается только часть, указанная в файле.  
  
-   Если `Output` данные пусты, в файл ничего не записывается. Однако для данных `#NULL#` NULL записывается.  
  
-   Для `Error` данных выходные данные отображаются как `#ERROR errorcode#`. `Error` Ключевое слово не переводится, независимо от языкового стандарта.  
  
 `WriteLine`Вставляет символ новой строки (то есть символ возврата каретки или перевода строки или `Chr(13) + Chr(10)`) после того, как записал в файл окончательный символ в. `Output`  
  
 Кавычки можно внедрять в строку с помощью двойных кавычек или "". Например, примененная к объекту директива  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 Возвращает строку со значением `Double quotation marks aren't "difficult" to handle`.  
  
 Для записи `Write` в файл с помощью `WriteLine` `Append` функций или требуется доступ из перечисления.`FileIOPermissionAccess` Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере `Write` функция используется для записи необработанных данных в последовательный файл.  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Практическое руководство. Запись текста в файлы в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Практическое руководство. Запись текста в файл с помощью StreamWriter (Visual Basic)</related>
      </Docs>
    </Member>
  </Members>
</Type>
