<Type Name="RenderOptions" FullName="System.Windows.Media.RenderOptions">
  <Metadata><Meta Name="ms.openlocfilehash" Value="70d44f193ad41d142457afe1c71d6ad46c31e0c3" /><Meta Name="ms.sourcegitcommit" Value="2767b5903996fbd7e2b81eda1114dfc9d0d9db63" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="05/02/2019" /><Meta Name="ms.locfileid" Value="65009217" /></Metadata><TypeSignature Language="C#" Value="public static class RenderOptions" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit RenderOptions extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.RenderOptions" />
  <TypeSignature Language="VB.NET" Value="Public Class RenderOptions" />
  <TypeSignature Language="C++ CLI" Value="public ref class RenderOptions abstract sealed" />
  <TypeSignature Language="F#" Value="type RenderOptions = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Предоставляет параметры для управления поведением отрисовки объектов.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Присоединенные свойства <xref:System.Windows.Media.RenderOptions> класса можно использовать для указания параметров отрисовки текста и визуальных элементов в приложении WPF. Эти параметры позволяют оптимизировать рендеринг для скорости или качества.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Media.RenderCapability" />
    <related type="Article" href="https://msdn.microsoft.com/library/67cafaad-57ad-4ecb-9c08-57fac144393e">Средства профилирования производительности для WPF</related>
  </Docs>
  <Members>
    <Member MemberName="BitmapScalingMode">
      <MemberSignature Language="C#" Value="see GetBitmapScalingMode, and SetBitmapScalingMode" />
      <MemberSignature Language="ILAsm" Value="see GetBitmapScalingMode, and SetBitmapScalingMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.RenderOptions.BitmapScalingMode" />
      <MemberSignature Language="VB.NET" Value="see GetBitmapScalingMode, and SetBitmapScalingMode" />
      <MemberSignature Language="F#" Value="see GetBitmapScalingMode, and SetBitmapScalingMode" Usage="see GetBitmapScalingMode, and SetBitmapScalingMode" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает или задает <see cref="T:System.Windows.Media.BitmapScalingMode" /> для заданного <see cref="T:System.Windows.DependencyObject" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте свойство для потомка <xref:System.Windows.Media.DrawingGroup>или, которое служит анимацией растрового изображения. <xref:System.Windows.UIElement> <xref:System.Windows.Media.RenderOptions.BitmapScalingMode%2A>  
  
 При анимации масштабирования любого растрового изображения алгоритм повторной дискретизации изображения высокого качества по умолчанию иногда может использовать столько системных ресурсов, чтобы привести к снижению частоты кадров анимации и задержкам. Установив <xref:System.Windows.Media.RenderOptions.BitmapScalingMode%2A> для<xref:System.Windows.Media.BitmapScalingMode.LowQuality?displayProperty=nameWithType>свойства значение, можно создать плавную анимацию при масштабировании растрового изображения.  
  
 Чтобы получить доступ к этому свойству в коде <xref:System.Windows.Media.RenderOptions.GetBitmapScalingMode%2A> , <xref:System.Windows.Media.RenderOptions.SetBitmapScalingMode%2A> используйте методы и.  
  
<a name="dependencyPropertyInfo_BitmapScalingMode"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Media.RenderOptions.BitmapScalingModeProperty>|  
|Свойства метаданных, для которых задано значение`true`|Нет|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.RenderOptions.GetBitmapScalingMode(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Media.RenderOptions.SetBitmapScalingMode(System.Windows.DependencyObject,System.Windows.Media.BitmapScalingMode)" />
      </Docs>
    </Member>
    <Member MemberName="BitmapScalingModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BitmapScalingModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BitmapScalingModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.RenderOptions.BitmapScalingModeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BitmapScalingModeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BitmapScalingModeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BitmapScalingModeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.RenderOptions.BitmapScalingModeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует присоединенное свойство <see cref="P:System.Windows.Media.RenderOptions.BitmapScalingMode" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CacheInvalidationThresholdMaximum">
      <MemberSignature Language="C#" Value="see GetCacheInvalidationThresholdMaximum, and SetCacheInvalidationThresholdMaximum" />
      <MemberSignature Language="ILAsm" Value="see GetCacheInvalidationThresholdMaximum, and SetCacheInvalidationThresholdMaximum" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum" />
      <MemberSignature Language="VB.NET" Value="see GetCacheInvalidationThresholdMaximum, and SetCacheInvalidationThresholdMaximum" />
      <MemberSignature Language="F#" Value="see GetCacheInvalidationThresholdMaximum, and SetCacheInvalidationThresholdMaximum" Usage="see GetCacheInvalidationThresholdMaximum, and SetCacheInvalidationThresholdMaximum" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает или задает максимальное пороговое значение недействительности данных в кэше для заданного <see cref="T:System.Windows.DependencyObject" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это вложенное свойство поддерживается и <xref:System.Windows.Media.TileBrush> производными от него типами. Он предназначен для использования с кистями, имеющими промежуточные поверхности, например <xref:System.Windows.Media.DrawingBrush> и <xref:System.Windows.Media.VisualBrush>. Он действует только в том случае, <xref:System.Windows.Media.RenderOptions.CachingHint%2A> если свойство имеет <xref:System.Windows.Media.CachingHint.Cache>значение.  
  
 По умолчанию [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] не кэширует отображаемое <xref:System.Windows.Media.DrawingBrush> содержимое объектов и <xref:System.Windows.Media.VisualBrush> . В статических сценариях, где ни содержимое, ни использование кисти в сцене не меняются, не кэширование содержимого дает преимущество, так как экономит видеопамять. Если кисть со статическим содержимым используется нестатическим образом, поведением [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] по умолчанию является повторное отображение всего содержимого кисти, даже если содержимое не изменяется. Например, это происходит, когда статический <xref:System.Windows.Media.DrawingBrush> объект или <xref:System.Windows.Media.VisualBrush> сопоставляется с поверхностью вращающегося трехмерного объекта. Повторная визуализация статического содержимого может негативно сказаться на производительности.  
  
 Если присвоить <xref:System.Windows.Media.RenderOptions.CachingHint%2A> свойству присоединенное свойство <xref:System.Windows.Media.CachingHint.Cache>кисти значение, производительность можно повысить, используя кэшированные версии объектов мозаичной кисти.  
  
 Значения свойств <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum%2A> <xref:System.Windows.Media.TileBrush> и — это значения относительного размера, которые определяют, когда объект должен быть повторно создан из-за изменений в масштабе. <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum%2A> Например, если <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum%2A> свойство имеет значение 2,0, кэш <xref:System.Windows.Media.TileBrush> для необходимо повторно создать, только если его размер превышает размер текущего кэша в два раза.  
  
 Чтобы получить доступ к этому свойству в коде <xref:System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMaximum%2A> , <xref:System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMaximum%2A> используйте методы и.  
  
<a name="dependencyPropertyInfo_CacheInvalidationThresholdMaximum"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximumProperty>|  
|Свойства метаданных, для которых задано значение`true`|Нет|  
  
   
  
## Examples  
 В следующем примере показано, как использовать параметр указания <xref:System.Windows.Media.DrawingBrush>кэширования для.  
  
 [!code-xml[RenderOptions#CachingXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/RenderOptions/CSharp/Window1.xaml#cachingxaml)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMaximum(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMaximum(System.Windows.DependencyObject,System.Double)" />
        <altmember cref="P:System.Windows.Media.RenderOptions.CachingHint" />
      </Docs>
    </Member>
    <Member MemberName="CacheInvalidationThresholdMaximumProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CacheInvalidationThresholdMaximumProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CacheInvalidationThresholdMaximumProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximumProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CacheInvalidationThresholdMaximumProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CacheInvalidationThresholdMaximumProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CacheInvalidationThresholdMaximumProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximumProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует присоединенное свойство <see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CacheInvalidationThresholdMinimum">
      <MemberSignature Language="C#" Value="see GetCacheInvalidationThresholdMinimum, and SetCacheInvalidationThresholdMinimum" />
      <MemberSignature Language="ILAsm" Value="see GetCacheInvalidationThresholdMinimum, and SetCacheInvalidationThresholdMinimum" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum" />
      <MemberSignature Language="VB.NET" Value="see GetCacheInvalidationThresholdMinimum, and SetCacheInvalidationThresholdMinimum" />
      <MemberSignature Language="F#" Value="see GetCacheInvalidationThresholdMinimum, and SetCacheInvalidationThresholdMinimum" Usage="see GetCacheInvalidationThresholdMinimum, and SetCacheInvalidationThresholdMinimum" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает или задает минимальное пороговое значение недействительности данных в кэше для заданного <see cref="T:System.Windows.DependencyObject" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это вложенное свойство поддерживается и <xref:System.Windows.Media.TileBrush> производными от него типами. Он предназначен для использования с кистями, имеющими промежуточные поверхности, например <xref:System.Windows.Media.DrawingBrush> и <xref:System.Windows.Media.VisualBrush>. Он действует только в том случае, <xref:System.Windows.Media.RenderOptions.CachingHint%2A> если свойство имеет <xref:System.Windows.Media.CachingHint.Cache>значение.  
  
 По умолчанию [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] не кэширует отображаемое <xref:System.Windows.Media.DrawingBrush> содержимое объектов и <xref:System.Windows.Media.VisualBrush> . В статических сценариях, где ни содержимое, ни использование кисти в сцене не меняются, не кэширование содержимого дает преимущество, так как экономит видеопамять. Если кисть со статическим содержимым используется нестатическим способом, поведением [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] по умолчанию является повторное отображение всего содержимого кисти, даже если содержимое не изменяется. Например, это происходит, когда статический <xref:System.Windows.Media.DrawingBrush> объект или <xref:System.Windows.Media.VisualBrush> сопоставляется с поверхностью вращающегося трехмерного объекта. Повторная визуализация статического содержимого может негативно сказаться на производительности.  
  
 Если присвоить <xref:System.Windows.Media.RenderOptions.CachingHint%2A> свойству присоединенное свойство <xref:System.Windows.Media.CachingHint.Cache>кисти значение, производительность можно повысить, используя кэшированные версии объектов мозаичной кисти.  
  
 Значения свойств <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum%2A> <xref:System.Windows.Media.TileBrush> и — это значения относительного размера, которые определяют, когда объект должен быть повторно создан из-за изменений в масштабе. <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum%2A> Например, если <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum%2A> свойство имеет значение 0,5, кэш <xref:System.Windows.Media.TileBrush> для должен быть повторно создан только в том случае, если его размер уменьшился меньше чем на одну половину размера текущего кэша.  
  
 Чтобы получить доступ к этому свойству в коде <xref:System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMinimum%2A> , <xref:System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMinimum%2A> используйте методы и.  
  
<a name="dependencyPropertyInfo_CacheInvalidationThresholdMinimum"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimumProperty>|  
|Свойства метаданных, для которых задано значение`true`|Нет|  
  
   
  
## Examples  
 В следующем примере показано, как использовать параметр указания <xref:System.Windows.Media.DrawingBrush>кэширования для.  
  
 [!code-xml[RenderOptions#CachingXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/RenderOptions/CSharp/Window1.xaml#cachingxaml)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMinimum(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMinimum(System.Windows.DependencyObject,System.Double)" />
        <altmember cref="P:System.Windows.Media.RenderOptions.CachingHint" />
      </Docs>
    </Member>
    <Member MemberName="CacheInvalidationThresholdMinimumProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CacheInvalidationThresholdMinimumProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CacheInvalidationThresholdMinimumProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimumProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CacheInvalidationThresholdMinimumProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CacheInvalidationThresholdMinimumProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CacheInvalidationThresholdMinimumProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimumProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует присоединенное свойство <see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CachingHint">
      <MemberSignature Language="C#" Value="see GetCachingHint, and SetCachingHint" />
      <MemberSignature Language="ILAsm" Value="see GetCachingHint, and SetCachingHint" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.RenderOptions.CachingHint" />
      <MemberSignature Language="VB.NET" Value="see GetCachingHint, and SetCachingHint" />
      <MemberSignature Language="F#" Value="see GetCachingHint, and SetCachingHint" Usage="see GetCachingHint, and SetCachingHint" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает или задает значение, указывающее, что визуализируемое содержимое по возможности должно кэшироваться.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это вложенное свойство поддерживается и <xref:System.Windows.Media.TileBrush> производными от него типами. Он предназначен для использования с кистями, имеющими промежуточные поверхности, например <xref:System.Windows.Media.DrawingBrush> и <xref:System.Windows.Media.VisualBrush>.  
  
 По умолчанию [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] не кэширует отображаемое <xref:System.Windows.Media.DrawingBrush> содержимое объектов и <xref:System.Windows.Media.VisualBrush> . В статических сценариях, где ни содержимое, ни использование кисти в сцене не меняются, а не кэширование предоставляет преимущество, так как экономит видеопамять. Если кисть со статическим содержимым используется нестатическим образом, поведением [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] по умолчанию является повторное отображение всего содержимого кисти, даже если содержимое не изменяется. Например, это происходит, когда статический <xref:System.Windows.Media.DrawingBrush> объект или <xref:System.Windows.Media.VisualBrush> сопоставляется с поверхностью вращающегося трехмерного объекта. Повторная визуализация статического содержимого может негативно сказаться на производительности.  
  
 Установив <xref:System.Windows.Media.RenderOptions.CachingHint%2A> присоединенное свойство кисти в <xref:System.Windows.Media.CachingHint.Cache>значение, можно повысить производительность, используя кэшированные версии объектов мозаичной кисти.  
  
 Значения свойств <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum%2A> <xref:System.Windows.Media.TileBrush> и — это значения относительного размера, которые определяют, когда объект должен быть повторно создан из-за изменений в масштабе. <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum%2A> Например, если <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum%2A> свойство имеет значение 2,0, кэш <xref:System.Windows.Media.TileBrush> для необходимо повторно создать, только если его размер превышает размер текущего кэша в два раза.  
  
 Чтобы получить доступ к этому свойству в коде <xref:System.Windows.Media.RenderOptions.GetCachingHint%2A> , <xref:System.Windows.Media.RenderOptions.SetCachingHint%2A> используйте методы и.  
  
<a name="dependencyPropertyInfo_CachingHint"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Media.RenderOptions.CachingHintProperty>|  
|Свойства метаданных, для которых задано значение`true`|Нет|  
  
   
  
## Examples  
 В следующем примере показано, как использовать параметр указания <xref:System.Windows.Media.DrawingBrush>кэширования для.  
  
 [!code-xml[RenderOptions#CachingXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/RenderOptions/CSharp/Window1.xaml#cachingxaml)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.RenderOptions.GetCachingHint(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Media.RenderOptions.SetCachingHint(System.Windows.DependencyObject,System.Windows.Media.CachingHint)" />
        <altmember cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum" />
        <altmember cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum" />
      </Docs>
    </Member>
    <Member MemberName="CachingHintProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CachingHintProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CachingHintProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.RenderOptions.CachingHintProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CachingHintProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CachingHintProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CachingHintProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.RenderOptions.CachingHintProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует присоединенное свойство <see cref="P:System.Windows.Media.RenderOptions.CachingHint" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearTypeHint">
      <MemberSignature Language="C#" Value="see GetClearTypeHint, and SetClearTypeHint" />
      <MemberSignature Language="ILAsm" Value="see GetClearTypeHint, and SetClearTypeHint" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.RenderOptions.ClearTypeHint" />
      <MemberSignature Language="VB.NET" Value="see GetClearTypeHint, and SetClearTypeHint" />
      <MemberSignature Language="F#" Value="see GetClearTypeHint, and SetClearTypeHint" Usage="see GetClearTypeHint, and SetClearTypeHint" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает или задает значение, указывающее механизму отрисовки, возможно ли отображать текст с помощью ClearType.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.RenderOptions.ClearTypeHint%2A> Используйте присоединенное свойство, чтобы указать, что текст может быть визуализирован с помощью технологии ClearType в определенной части визуального дерева.  
  
 Текст ClearType неправильно отображается в фоновом режиме, который не является полностью непрозрачным. Промежуточные целевые объекты отрисовки <xref:System.Windows.UIElement.OpacityMask%2A>, такие <xref:System.Windows.Media.DrawingBrush>как <xref:System.Windows.UIElement.Clip%2A> <xref:System.Windows.UIElement.Effect%2A> <xref:System.Windows.Media.VisualBrush>,, <xref:System.Windows.UIElement.Opacity%2A>,, и, могут отображать фоновые рисунки, которые не являются полностью непрозрачными. WPF отключает ClearType при обнаружении того, что буфер, в котором отображается текст, может иметь прозрачный фон.  
  
 Задайте для <xref:System.Windows.Media.RenderOptions.ClearTypeHint%2A> <xref:System.Windows.Media.ClearTypeHint.Enabled> свойства значение, чтобы указать, что поддерево является надежным для визуализации текста ClearType. Сделайте это только в том случае, если вы можете убедиться, что текст отображается в полностью непрозрачном фоне. Если элемент в поддереве содержит сведения о прозрачности, можно включить ClearType; Однако могут возникнуть проблемы с отрисовкой. Если часть поддерева содержит более промежуточные целевые объекты отрисовки, необходимо задать <xref:System.Windows.Media.RenderOptions.ClearTypeHint%2A> еще раз для дочерних элементов этого поддерева.  
  
 В следующем списке показано, как убедиться, что текст, отображаемый с помощью ClearType, отображается правильно.  
  
-   Не выводятся промежуточные целевые объекты отрисовки между <xref:System.Windows.Media.RenderOptions.ClearTypeHint%2A> и текст, который должен быть визуализирован с помощью технологии ClearType.  
  
-   Присвоить тексту непрозрачный фон, как можно ближе к визуальному дереву.  
  
-   Имейте в виду <xref:System.Windows.Media.RenderOptions.ClearTypeHint%2A> , что повторное включение ClearType для поддерева, однако, не приводит к принудительной визуализации ClearType.  
  
-   Имейте в виду <xref:System.Windows.Media.RenderOptions.ClearTypeHint%2A> , что не переопределяет системные параметры <xref:System.Windows.Media.TextOptions.TextRenderingMode%2A> или параметры.  
  
> [!NOTE]
>  Присоединенное свойство не <xref:System.Windows.Controls.TextBox> влияет на элемент управления, однако <xref:System.Windows.Controls.TextBlock> оно работает с элементом управления. <xref:System.Windows.Media.RenderOptions.ClearTypeHint%2A>  
  
> [!NOTE]
>  Во многих элементах управления <xref:System.Windows.Media.RenderOptions.ClearTypeHint%2A> присоединенное свойство не действует, если не задан непрозрачный фон за текстом.  
  
 Чтобы получить доступ к этому свойству в коде <xref:System.Windows.Media.RenderOptions.GetClearTypeHint%2A> , <xref:System.Windows.Media.RenderOptions.SetClearTypeHint%2A> используйте методы и.  
  
   
  
## Examples  
 В следующем примере показано, <xref:System.Windows.Media.RenderOptions.ClearTypeHint%2A> как свойство влияет на различные ветви визуального дерева. В первом элементе управления Text Block текст отображается с помощью технологии ClearType, поскольку текстовый блок наследует параметр из главного окна. Во втором текстовом блоке технология ClearType не используется, так как <xref:System.Windows.UIElement.OpacityMask%2A> свойство родительского элемента задано. В третьем блоке <xref:System.Windows.Media.RenderOptions.ClearTypeHint%2A> текста используется, но могут возникнуть проблемы с отрисовкой.  
  
```xaml
<Window x:Class="ClearTypeHintDemo.Window1"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Window1" Height="300" Width="300"
        AllowsTransparency="True" 
        WindowStyle="None" 
        RenderOptions.ClearTypeHint="Enabled" 
        Background="White">
    <Window.Resources>
        <LinearGradientBrush x:Key="opacityBrush" >
            <GradientStop Color="#FF000000" Offset="0.0" />
            <GradientStop Color="#00000000" Offset="1.0" />
        </LinearGradientBrush>
    </Window.Resources>

    <StackPanel>
        <TextBlock Text="This text is rendered with ClearType." />
        <StackPanel OpacityMask="{StaticResource opacityBrush}" >
            <TextBlock Text="This text is not rendered with ClearType." />
            <TextBlock RenderOptions.ClearTypeHint="Enabled" 
                       Text="This text is rendered with ClearType but may alpha-blend incorrectly." />
        </StackPanel>
    </StackPanel>
</Window>  
```

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearTypeHintProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ClearTypeHintProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ClearTypeHintProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.RenderOptions.ClearTypeHintProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ClearTypeHintProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ClearTypeHintProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ClearTypeHintProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.RenderOptions.ClearTypeHintProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует присоединенное свойство <see cref="P:System.Windows.Media.RenderOptions.ClearTypeHint" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EdgeMode">
      <MemberSignature Language="C#" Value="see GetEdgeMode, and SetEdgeMode" />
      <MemberSignature Language="ILAsm" Value="see GetEdgeMode, and SetEdgeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.RenderOptions.EdgeMode" />
      <MemberSignature Language="VB.NET" Value="see GetEdgeMode, and SetEdgeMode" />
      <MemberSignature Language="F#" Value="see GetEdgeMode, and SetEdgeMode" Usage="see GetEdgeMode, and SetEdgeMode" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает или задает для нетекстового примитива значение из перечисления <see cref="T:System.Windows.Media.EdgeMode" />, определяющее, как визуализируются границы этого примитива.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.RenderOptions.EdgeMode%2A> Используйте присоединенное свойство, чтобы повысить производительность отрисовки, указав, что визуальный объект должен быть визуализирован с границами с псевдонимами. Текстовые объекты всегда отображаются с сглаживанием и не затрагиваются установкой значения режима ребра. При задании значения режима ребра для визуального объекта все примитивы рисования элемента визуального объекта устанавливаются в одинаковое значение режима ребра.  
  
 Чтобы получить доступ к этому свойству в коде <xref:System.Windows.Media.RenderOptions.GetEdgeMode%2A> , <xref:System.Windows.Media.RenderOptions.SetEdgeMode%2A> используйте методы и.  
  
<a name="dependencyPropertyInfo_EdgeMode"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Media.RenderOptions.EdgeModeProperty>|  
|Свойства метаданных, для которых задано значение`true`|Нет|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.RenderOptions.GetEdgeMode(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Media.RenderOptions.SetEdgeMode(System.Windows.DependencyObject,System.Windows.Media.EdgeMode)" />
      </Docs>
    </Member>
    <Member MemberName="EdgeModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty EdgeModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty EdgeModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.RenderOptions.EdgeModeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EdgeModeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ EdgeModeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable EdgeModeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.RenderOptions.EdgeModeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует присоединенное свойство <see cref="P:System.Windows.Media.RenderOptions.EdgeMode" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBitmapScalingMode">
      <MemberSignature Language="C#" Value="public static System.Windows.Media.BitmapScalingMode GetBitmapScalingMode (System.Windows.DependencyObject target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Media.BitmapScalingMode GetBitmapScalingMode(class System.Windows.DependencyObject target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.GetBitmapScalingMode(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetBitmapScalingMode (target As DependencyObject) As BitmapScalingMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Media::BitmapScalingMode GetBitmapScalingMode(System::Windows::DependencyObject ^ target);" />
      <MemberSignature Language="F#" Value="static member GetBitmapScalingMode : System.Windows.DependencyObject -&gt; System.Windows.Media.BitmapScalingMode" Usage="System.Windows.Media.RenderOptions.GetBitmapScalingMode target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.AttachedPropertyBrowsableForType(typeof(System.Windows.DependencyObject))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.BitmapScalingMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="target">Объект зависимости, из которого нужно извлечь значение вложенного свойства зависимостей <see cref="P:System.Windows.Media.RenderOptions.BitmapScalingMode" />.</param>
        <summary>Возвращает значение присоединенного свойства <see cref="P:System.Windows.Media.RenderOptions.BitmapScalingMode" /> для указанного объекта зависимости.</summary>
        <returns>Текущее значение присоединенного свойства <see cref="P:System.Windows.Media.RenderOptions.BitmapScalingMode" /> для заданного объекта зависимости.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере показано, <xref:System.Windows.Media.BitmapScalingMode> как получить для объекта Image.  
  
 [!code-csharp[RenderOptions#RenderOptionsSnippet1](~/samples/snippets/csharp/VS_Snippets_Wpf/RenderOptions/CSharp/Window1.xaml.cs#renderoptionssnippet1)]
 [!code-vb[RenderOptions#RenderOptionsSnippet1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RenderOptions/visualbasic/window1.xaml.vb#renderoptionssnippet1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Заданный объект <paramref name="target" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Media.RenderOptions.SetBitmapScalingMode(System.Windows.DependencyObject,System.Windows.Media.BitmapScalingMode)" />
      </Docs>
    </Member>
    <Member MemberName="GetCacheInvalidationThresholdMaximum">
      <MemberSignature Language="C#" Value="public static double GetCacheInvalidationThresholdMaximum (System.Windows.DependencyObject target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetCacheInvalidationThresholdMaximum(class System.Windows.DependencyObject target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMaximum(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCacheInvalidationThresholdMaximum (target As DependencyObject) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetCacheInvalidationThresholdMaximum(System::Windows::DependencyObject ^ target);" />
      <MemberSignature Language="F#" Value="static member GetCacheInvalidationThresholdMaximum : System.Windows.DependencyObject -&gt; double" Usage="System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMaximum target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.AttachedPropertyBrowsableForType(typeof(System.Windows.Media.TileBrush))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="target">Объект зависимости, из которого нужно извлечь значение вложенного свойства зависимостей <see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum" />.</param>
        <summary>Возвращает значение присоединенного свойства <see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum" /> для указанного объекта зависимости.</summary>
        <returns>Текущее значение присоединенного свойства <see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum" /> для заданного объекта зависимости.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере показано, как получить значения подсказки кэширования для <xref:System.Windows.Media.DrawingBrush>.  
  
 [!code-csharp[RenderOptions#RenderOptionsSnippet4](~/samples/snippets/csharp/VS_Snippets_Wpf/RenderOptions/CSharp/Window1.xaml.cs#renderoptionssnippet4)]
 [!code-vb[RenderOptions#RenderOptionsSnippet4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RenderOptions/visualbasic/window1.xaml.vb#renderoptionssnippet4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Заданный объект <paramref name="target" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Media.RenderOptions.GetCachingHint(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMinimum(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="GetCacheInvalidationThresholdMinimum">
      <MemberSignature Language="C#" Value="public static double GetCacheInvalidationThresholdMinimum (System.Windows.DependencyObject target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetCacheInvalidationThresholdMinimum(class System.Windows.DependencyObject target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMinimum(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCacheInvalidationThresholdMinimum (target As DependencyObject) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetCacheInvalidationThresholdMinimum(System::Windows::DependencyObject ^ target);" />
      <MemberSignature Language="F#" Value="static member GetCacheInvalidationThresholdMinimum : System.Windows.DependencyObject -&gt; double" Usage="System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMinimum target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.AttachedPropertyBrowsableForType(typeof(System.Windows.Media.TileBrush))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="target">Объект зависимости, из которого нужно извлечь значение вложенного свойства зависимостей <see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum" />.</param>
        <summary>Возвращает значение присоединенного свойства <see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum" /> для указанного объекта зависимости.</summary>
        <returns>Текущее значение присоединенного свойства <see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum" /> для заданного объекта зависимости.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере показано, как получить значения подсказки кэширования для <xref:System.Windows.Media.DrawingBrush>.  
  
 [!code-csharp[RenderOptions#RenderOptionsSnippet4](~/samples/snippets/csharp/VS_Snippets_Wpf/RenderOptions/CSharp/Window1.xaml.cs#renderoptionssnippet4)]
 [!code-vb[RenderOptions#RenderOptionsSnippet4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RenderOptions/visualbasic/window1.xaml.vb#renderoptionssnippet4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Заданный объект <paramref name="target" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Media.RenderOptions.GetCachingHint(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMaximum(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="GetCachingHint">
      <MemberSignature Language="C#" Value="public static System.Windows.Media.CachingHint GetCachingHint (System.Windows.DependencyObject target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Media.CachingHint GetCachingHint(class System.Windows.DependencyObject target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.GetCachingHint(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCachingHint (target As DependencyObject) As CachingHint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Media::CachingHint GetCachingHint(System::Windows::DependencyObject ^ target);" />
      <MemberSignature Language="F#" Value="static member GetCachingHint : System.Windows.DependencyObject -&gt; System.Windows.Media.CachingHint" Usage="System.Windows.Media.RenderOptions.GetCachingHint target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.AttachedPropertyBrowsableForType(typeof(System.Windows.Media.TileBrush))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.CachingHint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="target">Объект зависимости, из которого нужно извлечь значение вложенного свойства зависимостей <see cref="P:System.Windows.Media.RenderOptions.CachingHint" />.</param>
        <summary>Возвращает значение присоединенного свойства <see cref="P:System.Windows.Media.RenderOptions.CachingHint" /> для указанного объекта зависимости.</summary>
        <returns>Текущее значение присоединенного свойства <see cref="P:System.Windows.Media.RenderOptions.CachingHint" /> для заданного объекта зависимости.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере показано, как получить значения подсказки кэширования для <xref:System.Windows.Media.DrawingBrush>.  
  
 [!code-csharp[RenderOptions#RenderOptionsSnippet4](~/samples/snippets/csharp/VS_Snippets_Wpf/RenderOptions/CSharp/Window1.xaml.cs#renderoptionssnippet4)]
 [!code-vb[RenderOptions#RenderOptionsSnippet4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RenderOptions/visualbasic/window1.xaml.vb#renderoptionssnippet4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Заданный объект <paramref name="target" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMinimum(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMaximum(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="GetClearTypeHint">
      <MemberSignature Language="C#" Value="public static System.Windows.Media.ClearTypeHint GetClearTypeHint (System.Windows.DependencyObject target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Media.ClearTypeHint GetClearTypeHint(class System.Windows.DependencyObject target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.GetClearTypeHint(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetClearTypeHint (target As DependencyObject) As ClearTypeHint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Media::ClearTypeHint GetClearTypeHint(System::Windows::DependencyObject ^ target);" />
      <MemberSignature Language="F#" Value="static member GetClearTypeHint : System.Windows.DependencyObject -&gt; System.Windows.Media.ClearTypeHint" Usage="System.Windows.Media.RenderOptions.GetClearTypeHint target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Windows.AttachedPropertyBrowsableForType(typeof(System.Windows.DependencyObject))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.ClearTypeHint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="target">Объект <see cref="T:System.Windows.DependencyObject" />, для которого необходимо получить значение вложенного свойства зависимостей <see cref="P:System.Windows.Media.RenderOptions.ClearTypeHint" />.</param>
        <summary>Получает значение вложенного свойства зависимостей <see cref="P:System.Windows.Media.RenderOptions.ClearTypeHint" /> для указанного элемента.</summary>
        <returns>Значение <see cref="P:System.Windows.Media.RenderOptions.ClearTypeHint" /> вложенного свойства зависимостей для <paramref name="target" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEdgeMode">
      <MemberSignature Language="C#" Value="public static System.Windows.Media.EdgeMode GetEdgeMode (System.Windows.DependencyObject target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Media.EdgeMode GetEdgeMode(class System.Windows.DependencyObject target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.GetEdgeMode(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEdgeMode (target As DependencyObject) As EdgeMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Media::EdgeMode GetEdgeMode(System::Windows::DependencyObject ^ target);" />
      <MemberSignature Language="F#" Value="static member GetEdgeMode : System.Windows.DependencyObject -&gt; System.Windows.Media.EdgeMode" Usage="System.Windows.Media.RenderOptions.GetEdgeMode target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.AttachedPropertyBrowsableForType(typeof(System.Windows.DependencyObject))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.EdgeMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="target">Объект зависимости, из которого нужно извлечь значение вложенного свойства зависимостей <see cref="P:System.Windows.Media.RenderOptions.EdgeMode" />.</param>
        <summary>Возвращает значение присоединенного свойства <see cref="P:System.Windows.Media.RenderOptions.EdgeMode" /> для указанного объекта зависимости.</summary>
        <returns>Текущее значение присоединенного свойства <see cref="P:System.Windows.Media.RenderOptions.EdgeMode" /> для заданного объекта зависимости.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значением по умолчанию для примитивов, отличных от текста, <xref:System.Windows.Shapes.Ellipse> таких <xref:System.Windows.Shapes.Polygon>как и <xref:System.Windows.Media.EdgeMode.Unspecified>, является.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Заданный объект <paramref name="target" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessRenderMode">
      <MemberSignature Language="C#" Value="public static System.Windows.Interop.RenderMode ProcessRenderMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Interop.RenderMode ProcessRenderMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.RenderOptions.ProcessRenderMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ProcessRenderMode As RenderMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Interop::RenderMode ProcessRenderMode { System::Windows::Interop::RenderMode get(); void set(System::Windows::Interop::RenderMode value); };" />
      <MemberSignature Language="F#" Value="member this.ProcessRenderMode : System.Windows.Interop.RenderMode with get, set" Usage="System.Windows.Media.RenderOptions.ProcessRenderMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Interop.RenderMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Задает параметры режима визуализации текущего процесса.</summary>
        <value>Параметр <see cref="T:System.Windows.Interop.RenderMode" /> для текущего процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.RenderOptions.ProcessRenderMode%2A> Используйте свойство, чтобы принудительно выполнить отрисовку программного обеспечения для текущего процесса. Вы можете избежать многих проблем отрисовки, возникающих в приложениях WPF, которые вызываются внешними проблемами, если изменить предпочтения на отрисовку программного обеспечения.  
  
 При запуске приложения, если приложение обнаруживает проблемы отрисовки, такие как медленное снижение скорости кадров, можно установить режим отрисовки только по. Кроме того, может потребоваться включить пользовательский параметр во время работы приложения.  
  
 Предпочтение<xref:System.Windows.Interop.HwndTarget.RenderMode%2A>переопределяетпараметр. <xref:System.Windows.Interop.RenderMode.SoftwareOnly> Порядок очередности визуализации программного обеспечения:  
  
1.  Раздел реестра Дисаблехвакцелератион  
  
2.  <xref:System.Windows.Media.RenderOptions.ProcessRenderMode%2A>  
  
3.  <xref:System.Windows.Interop.HwndTarget.RenderMode%2A>(для каждого целевого объекта)  
  
 **Примечание** . <xref:System.Windows.Media.RenderOptions.ProcessRenderMode%2A> задает предпочтение и не обязательно изменяет реальный режим отрисовки. Другие компоненты системы могут переопределять этот параметр и принудительно выполнять программную отрисовку.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">для задания этого свойства. Связанное перечисление:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Interop.RenderMode" />
      </Docs>
    </Member>
    <Member MemberName="SetBitmapScalingMode">
      <MemberSignature Language="C#" Value="public static void SetBitmapScalingMode (System.Windows.DependencyObject target, System.Windows.Media.BitmapScalingMode bitmapScalingMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetBitmapScalingMode(class System.Windows.DependencyObject target, valuetype System.Windows.Media.BitmapScalingMode bitmapScalingMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.SetBitmapScalingMode(System.Windows.DependencyObject,System.Windows.Media.BitmapScalingMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetBitmapScalingMode(System::Windows::DependencyObject ^ target, System::Windows::Media::BitmapScalingMode bitmapScalingMode);" />
      <MemberSignature Language="F#" Value="static member SetBitmapScalingMode : System.Windows.DependencyObject * System.Windows.Media.BitmapScalingMode -&gt; unit" Usage="System.Windows.Media.RenderOptions.SetBitmapScalingMode (target, bitmapScalingMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="bitmapScalingMode" Type="System.Windows.Media.BitmapScalingMode" />
      </Parameters>
      <Docs>
        <param name="target">Потомок <see cref="T:System.Windows.UIElement" /> или <see cref="T:System.Windows.Media.DrawingGroup" />, которому задается значение свойства <see cref="P:System.Windows.Media.RenderOptions.BitmapScalingMode" />.</param>
        <param name="bitmapScalingMode">Новое значение для установки свойства.</param>
        <summary>Задает значение присоединенного свойства <see cref="P:System.Windows.Media.RenderOptions.BitmapScalingMode" /> для указанного объекта зависимости.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте метод для потомка <xref:System.Windows.Media.DrawingGroup>или, которая служит для анимации растрового изображения. <xref:System.Windows.UIElement> <xref:System.Windows.Media.RenderOptions.SetBitmapScalingMode%2A>  
  
 При анимации масштабирования любого растрового изображения алгоритм повторной дискретизации изображения высокого качества по умолчанию иногда может использовать столько системных ресурсов, чтобы привести к снижению частоты кадров анимации и задержкам. Установив <xref:System.Windows.Media.RenderOptions.BitmapScalingMode%2A> свойство <xref:System.Windows.Media.RenderOptions> объекта в<xref:System.Windows.Media.BitmapScalingMode.LowQuality>значение, можно создать плавную анимацию при масштабировании растрового изображения.  
  
   
  
## Examples  
 В следующем примере показано, <xref:System.Windows.Media.BitmapScalingMode> как задать <xref:System.Windows.Controls.Image> для объекта.  
  
 [!code-csharp[RenderOptions#RenderOptionsSnippet2](~/samples/snippets/csharp/VS_Snippets_Wpf/RenderOptions/CSharp/Window1.xaml.cs#renderoptionssnippet2)]
 [!code-vb[RenderOptions#RenderOptionsSnippet2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RenderOptions/visualbasic/window1.xaml.vb#renderoptionssnippet2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Заданный объект <paramref name="target" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Media.RenderOptions.GetBitmapScalingMode(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="SetCacheInvalidationThresholdMaximum">
      <MemberSignature Language="C#" Value="public static void SetCacheInvalidationThresholdMaximum (System.Windows.DependencyObject target, double cacheInvalidationThresholdMaximum);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCacheInvalidationThresholdMaximum(class System.Windows.DependencyObject target, float64 cacheInvalidationThresholdMaximum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMaximum(System.Windows.DependencyObject,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCacheInvalidationThresholdMaximum (target As DependencyObject, cacheInvalidationThresholdMaximum As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCacheInvalidationThresholdMaximum(System::Windows::DependencyObject ^ target, double cacheInvalidationThresholdMaximum);" />
      <MemberSignature Language="F#" Value="static member SetCacheInvalidationThresholdMaximum : System.Windows.DependencyObject * double -&gt; unit" Usage="System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMaximum (target, cacheInvalidationThresholdMaximum)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="cacheInvalidationThresholdMaximum" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="target">Объект зависимости, для которого нужно установить значение свойства <see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum" /></param>
        <param name="cacheInvalidationThresholdMaximum">Новое значение для установки свойства.</param>
        <summary>Задает значение присоединенного свойства <see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum" /> для указанного объекта зависимости.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод, чтобы задать <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum%2A> присоединенное свойство в коде.  
  
   
  
## Examples  
 В следующем примере показано, как использовать параметр указания <xref:System.Windows.Media.DrawingBrush>кэширования для.  
  
 [!code-csharp[RenderOptions#RenderOptionsSnippet3](~/samples/snippets/csharp/VS_Snippets_Wpf/RenderOptions/CSharp/Window1.xaml.cs#renderoptionssnippet3)]
 [!code-vb[RenderOptions#RenderOptionsSnippet3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RenderOptions/visualbasic/window1.xaml.vb#renderoptionssnippet3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Заданный объект <paramref name="target" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Media.RenderOptions.SetCachingHint(System.Windows.DependencyObject,System.Windows.Media.CachingHint)" />
        <altmember cref="M:System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMinimum(System.Windows.DependencyObject,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="SetCacheInvalidationThresholdMinimum">
      <MemberSignature Language="C#" Value="public static void SetCacheInvalidationThresholdMinimum (System.Windows.DependencyObject target, double cacheInvalidationThresholdMinimum);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCacheInvalidationThresholdMinimum(class System.Windows.DependencyObject target, float64 cacheInvalidationThresholdMinimum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMinimum(System.Windows.DependencyObject,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCacheInvalidationThresholdMinimum (target As DependencyObject, cacheInvalidationThresholdMinimum As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCacheInvalidationThresholdMinimum(System::Windows::DependencyObject ^ target, double cacheInvalidationThresholdMinimum);" />
      <MemberSignature Language="F#" Value="static member SetCacheInvalidationThresholdMinimum : System.Windows.DependencyObject * double -&gt; unit" Usage="System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMinimum (target, cacheInvalidationThresholdMinimum)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="cacheInvalidationThresholdMinimum" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="target">Объект зависимости, для которого нужно установить значение свойства <see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum" /></param>
        <param name="cacheInvalidationThresholdMinimum">Новое значение для установки свойства.</param>
        <summary>Задает значение присоединенного свойства <see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum" /> для указанного объекта зависимости.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод, чтобы задать <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum%2A> присоединенное свойство в коде.  
  
   
  
## Examples  
 В следующем примере показано, как использовать параметр указания <xref:System.Windows.Media.DrawingBrush>кэширования для.  
  
 [!code-csharp[RenderOptions#RenderOptionsSnippet3](~/samples/snippets/csharp/VS_Snippets_Wpf/RenderOptions/CSharp/Window1.xaml.cs#renderoptionssnippet3)]
 [!code-vb[RenderOptions#RenderOptionsSnippet3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RenderOptions/visualbasic/window1.xaml.vb#renderoptionssnippet3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Заданный объект <paramref name="target" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Media.RenderOptions.SetCachingHint(System.Windows.DependencyObject,System.Windows.Media.CachingHint)" />
        <altmember cref="M:System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMaximum(System.Windows.DependencyObject,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="SetCachingHint">
      <MemberSignature Language="C#" Value="public static void SetCachingHint (System.Windows.DependencyObject target, System.Windows.Media.CachingHint cachingHint);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCachingHint(class System.Windows.DependencyObject target, valuetype System.Windows.Media.CachingHint cachingHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.SetCachingHint(System.Windows.DependencyObject,System.Windows.Media.CachingHint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCachingHint(System::Windows::DependencyObject ^ target, System::Windows::Media::CachingHint cachingHint);" />
      <MemberSignature Language="F#" Value="static member SetCachingHint : System.Windows.DependencyObject * System.Windows.Media.CachingHint -&gt; unit" Usage="System.Windows.Media.RenderOptions.SetCachingHint (target, cachingHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="cachingHint" Type="System.Windows.Media.CachingHint" />
      </Parameters>
      <Docs>
        <param name="target">Объект зависимости, для которого нужно установить значение свойства <see cref="P:System.Windows.Media.RenderOptions.CachingHint" />.</param>
        <param name="cachingHint">Новое значение для установки свойства.</param>
        <summary>Задает значение присоединенного свойства <see cref="P:System.Windows.Media.RenderOptions.CachingHint" /> для указанного объекта зависимости.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] не кэширует отображаемое <xref:System.Windows.Media.DrawingBrush> содержимое объектов и <xref:System.Windows.Media.VisualBrush> . В статических сценариях, где ни содержимое, ни использование кисти в сцене не меняются, а не кэширование предоставляет преимущество, так как экономит видеопамять. Если кисть со статическим содержимым используется нестатическим образом, поведением [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] по умолчанию является повторное отображение всего содержимого кисти, даже если содержимое не изменяется. Например, это происходит, когда статический <xref:System.Windows.Media.DrawingBrush> объект или <xref:System.Windows.Media.VisualBrush> сопоставляется с поверхностью вращающегося трехмерного объекта. Повторная визуализация статического содержимого может негативно сказаться на производительности.  
  
 Установив <xref:System.Windows.Media.RenderOptions.CachingHint%2A> присоединенное свойство кисти в <xref:System.Windows.Media.CachingHint.Cache>значение, можно повысить производительность, используя кэшированные версии объектов мозаичной кисти.  
  
 Значения свойств <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum%2A> <xref:System.Windows.Media.TileBrush> и — это значения относительного размера, которые определяют, когда объект должен быть повторно создан из-за изменений в масштабе. <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum%2A> Например, если <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum%2A> свойство имеет значение 2,0, кэш <xref:System.Windows.Media.TileBrush> для необходимо повторно создать, только если его размер превышает размер текущего кэша в два раза.  
  
 Используйте этот метод, чтобы задать <xref:System.Windows.Media.RenderOptions.CachingHint%2A> присоединенное свойство в коде.  
  
   
  
## Examples  
 В следующем примере показано, как использовать параметр указания <xref:System.Windows.Media.DrawingBrush>кэширования для.  
  
 [!code-csharp[RenderOptions#RenderOptionsSnippet3](~/samples/snippets/csharp/VS_Snippets_Wpf/RenderOptions/CSharp/Window1.xaml.cs#renderoptionssnippet3)]
 [!code-vb[RenderOptions#RenderOptionsSnippet3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RenderOptions/visualbasic/window1.xaml.vb#renderoptionssnippet3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Заданный объект <paramref name="target" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMaximum(System.Windows.DependencyObject,System.Double)" />
        <altmember cref="M:System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMinimum(System.Windows.DependencyObject,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="SetClearTypeHint">
      <MemberSignature Language="C#" Value="public static void SetClearTypeHint (System.Windows.DependencyObject target, System.Windows.Media.ClearTypeHint clearTypeHint);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetClearTypeHint(class System.Windows.DependencyObject target, valuetype System.Windows.Media.ClearTypeHint clearTypeHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.SetClearTypeHint(System.Windows.DependencyObject,System.Windows.Media.ClearTypeHint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetClearTypeHint(System::Windows::DependencyObject ^ target, System::Windows::Media::ClearTypeHint clearTypeHint);" />
      <MemberSignature Language="F#" Value="static member SetClearTypeHint : System.Windows.DependencyObject * System.Windows.Media.ClearTypeHint -&gt; unit" Usage="System.Windows.Media.RenderOptions.SetClearTypeHint (target, clearTypeHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="clearTypeHint" Type="System.Windows.Media.ClearTypeHint" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="target">Объект <see cref="T:System.Windows.DependencyObject" />, которому задается значение вложенного свойства зависимостей <see cref="P:System.Windows.Media.RenderOptions.ClearTypeHint" />.</param>
        <param name="clearTypeHint">Новое значение <see cref="P:System.Windows.Media.RenderOptions.ClearTypeHint" />.</param>
        <summary>Задает значение вложенного свойства зависимостей <see cref="P:System.Windows.Media.RenderOptions.ClearTypeHint" /> указанного элемента.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Заданный объект <paramref name="target" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetEdgeMode">
      <MemberSignature Language="C#" Value="public static void SetEdgeMode (System.Windows.DependencyObject target, System.Windows.Media.EdgeMode edgeMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetEdgeMode(class System.Windows.DependencyObject target, valuetype System.Windows.Media.EdgeMode edgeMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.SetEdgeMode(System.Windows.DependencyObject,System.Windows.Media.EdgeMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetEdgeMode(System::Windows::DependencyObject ^ target, System::Windows::Media::EdgeMode edgeMode);" />
      <MemberSignature Language="F#" Value="static member SetEdgeMode : System.Windows.DependencyObject * System.Windows.Media.EdgeMode -&gt; unit" Usage="System.Windows.Media.RenderOptions.SetEdgeMode (target, edgeMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="edgeMode" Type="System.Windows.Media.EdgeMode" />
      </Parameters>
      <Docs>
        <param name="target">Объект зависимости, для которого нужно установить значение свойства <see cref="P:System.Windows.Media.RenderOptions.EdgeMode" /></param>
        <param name="edgeMode">Новое значение для установки свойства.</param>
        <summary>Задает значение присоединенного свойства <see cref="P:System.Windows.Media.RenderOptions.EdgeMode" /> для указанного объекта зависимости.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовые объекты всегда отображаются с сглаживанием и не затрагиваются установкой значения режима ребра. При задании значения режима ребра для визуального объекта все примитивы рисования элемента визуального объекта устанавливаются в одинаковое значение режима ребра.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Windows.Media.RenderOptions.SetEdgeMode%2A> метод, чтобы задать в качестве режима ребра для визуального <xref:System.Windows.Media.EdgeMode.Aliased>объекта значение.  
  
 [!code-csharp[VisualSnippets#SetEdgeMode](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Snippets.cs#setedgemode)]
 [!code-vb[VisualSnippets#SetEdgeMode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/VisualSnippets/visualbasic/snippets.vb#setedgemode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Заданный объект <paramref name="target" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>