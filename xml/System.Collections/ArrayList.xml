<Type Name="ArrayList" FullName="System.Collections.ArrayList">
  <Metadata><Meta Name="ms.openlocfilehash" Value="783dfe191b215e44bf05183f2e48c16e8165667a" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69351918" /></Metadata><TypeSignature Language="C#" Value="public class ArrayList : ICloneable, System.Collections.IList" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit ArrayList extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.ArrayList" />
  <TypeSignature Language="VB.NET" Value="Public Class ArrayList&#xA;Implements ICloneable, IList" />
  <TypeSignature Language="C++ CLI" Value="public ref class ArrayList : ICloneable, System::Collections::IList" />
  <TypeSignature Language="F#" Value="type ArrayList = class&#xA;    interface IList&#xA;    interface ICloneable&#xA;    interface ICollection&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.NonGeneric</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.ArrayList/ArrayListDebugView))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Реализует интерфейс <see cref="T:System.Collections.IList" /> с помощью массива с динамическим изменением размера по требованию.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  

> [!IMPORTANT]
>  Мы не рекомендуем использовать `ArrayList` класс для новой разработки. Вместо этого рекомендуется использовать универсальный <xref:System.Collections.Generic.List%601> класс.
> <xref:System.Collections.ArrayList> Класс предназначен для хранения разнородных коллекций объектов. Однако это не всегда обеспечивает наилучшую производительность. Вместо этого рекомендуется следующее:  
> - Для разнородной коллекции объектов используйте `List<Object>` тип (in C#) или `List(Of Object)` (in Visual Basic).  
> - Для однородной коллекции объектов используйте <xref:System.Collections.Generic.List%601> класс.  
> Описание [](xref:System.Collections.Generic.List%601#performance-considerations) относительной производительности этих <xref:System.Collections.Generic.List%601> классов см. в разделе рекомендации по производительности.  Общие сведения об использовании универсальных типов, а не неуниверсальных коллекций, см. в разделе неуниверсальные [коллекции](https://github.com/dotnet/platform-compat/blob/master/docs/DE0006.md) в GitHub. 
  
 Сортировка <xref:System.Collections.ArrayList> не гарантируется.  Необходимо отсортировать <xref:System.Collections.ArrayList> объект, вызвав его <xref:System.Collections.ArrayList.Sort%2A> метод перед <xref:System.Collections.ArrayList.BinarySearch%2A>выполнением операций (например,), <xref:System.Collections.ArrayList> для которых требуется сортировка. Чтобы поддерживать коллекцию, которая автоматически сортируется по мере добавления новых элементов, можно использовать <xref:System.Collections.Generic.SortedSet%601> класс.  
  
 Емкость <xref:System.Collections.ArrayList> — это количество элементов, <xref:System.Collections.ArrayList> которые может содержать. Когда элементы добавляются в <xref:System.Collections.ArrayList>, емкость автоматически увеличивается по мере необходимости путем перераспределения. Емкость можно уменьшить, вызвав <xref:System.Collections.ArrayList.TrimToSize%2A> или явно <xref:System.Collections.ArrayList.Capacity%2A> задав свойство.  
  
 **Только .NET Framework:** Для очень больших <xref:System.Collections.ArrayList> объектов можно увеличить максимальную емкость до 2 000 000 000 элементов в 64-разрядной системе, `enabled` задав атрибут [`<gcAllowVeryLargeObjects>`](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) элемента `true` конфигурации в среде выполнения.  
  
 Доступ к элементам в этой коллекции можно получить с помощью целочисленного индекса.  Индексы в этой коллекции отсчитываются от нуля.  
  
 <xref:System.Collections.ArrayList> Коллекция принимает`null` как допустимое значение. Он также позволяет дублировать элементы.  
  
 Использование многомерных массивов в качестве элементов в <xref:System.Collections.ArrayList> коллекции не поддерживается.  
  
   
  
## Examples  
 В следующем примере показано, как создать и инициализировать объект <xref:System.Collections.ArrayList> и как отобразить его значения.  
  
 [!code-cpp[Classic ArrayList Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Открытые статические (<see langword="Shared" /> в Visual Basic) члены этого типа являются потокобезопасными. Потокобезопасность членов экземпляров не гарантируется.  
  
<see cref="T:System.Collections.ArrayList" /> Может поддерживать одновременно несколько модулей чтения, если коллекция не изменяется. Чтобы обеспечить потокобезопасность <see cref="T:System.Collections.ArrayList" />, все операции должны выполняться через оболочку, возвращенную <see cref="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)" /> методом.  
  
Перечисление коллекции не является потокобезопасной процедурой. Даже если коллекция синхронизирована, другие потоки могут ее изменить, что приведет к тому, что перечислитель создаст исключение. Для обеспечения потокобезопасности при перечислении можно либо заблокировать коллекцию на все время перечисления, либо перехватывать исключения, возникающие в результате изменений, внесенных другими потоками.</threadsafe>
    <altmember cref="T:System.Collections.IList" />
    <altmember cref="T:System.Collections.Generic.List`1" />
    <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Выполнение в коллекциях строковых операций, не зависящих от языка и региональных параметров</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Collections.ArrayList" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ArrayList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ArrayList();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Collections.ArrayList" />, который является пустым и имеет начальную емкость по умолчанию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Емкость <xref:System.Collections.ArrayList> — это количество элементов, которые может содержать объект <xref:System.Collections.ArrayList> . При добавлении элементов в объект <xref:System.Collections.ArrayList>емкость автоматически увеличивается по мере необходимости путем перераспределения внутреннего массива.  
  
 Если размер коллекции можно оценить, указание начальной емкости избавляет от необходимости выполнять несколько операций изменения размера при добавлении элементов <xref:System.Collections.ArrayList>в.  
  
 Этот конструктор является операцией O (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ArrayList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ArrayList (System.Collections.ICollection c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.ICollection c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.#ctor(System.Collections.ICollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (c As ICollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ArrayList(System::Collections::ICollection ^ c);" />
      <MemberSignature Language="F#" Value="new System.Collections.ArrayList : System.Collections.ICollection -&gt; System.Collections.ArrayList" Usage="new System.Collections.ArrayList c" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="c" Type="System.Collections.ICollection" />
      </Parameters>
      <Docs>
        <param name="c">Интерфейс <see cref="T:System.Collections.ICollection" />, элементы которого копируются в новый список.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Collections.ArrayList" />, который содержит элементы, скопированные из указанной коллекции, и обладает начальной емкостью, равной количеству скопированных элементов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Емкость <xref:System.Collections.ArrayList> — это количество элементов, которые может содержать объект <xref:System.Collections.ArrayList> . При добавлении элементов в объект <xref:System.Collections.ArrayList>емкость автоматически увеличивается по мере необходимости путем перераспределения внутреннего массива.  
  
 Если размер коллекции можно оценить, указание начальной емкости избавляет от необходимости выполнять несколько операций изменения размера при добавлении элементов <xref:System.Collections.ArrayList>в.  
  
 Элементы копируются <xref:System.Collections.ArrayList> в в в том же порядке, в котором они считываются <xref:System.Collections.IEnumerator> объектом <xref:System.Collections.ICollection>.  
  
 Этот конструктор является операцией O`n`(), где `n` — число элементов в `c`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="c" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.ArrayList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ArrayList (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ArrayList(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.ArrayList : int -&gt; System.Collections.ArrayList" Usage="new System.Collections.ArrayList capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Число элементов, которые может изначально вместить новый список.</param>
        <summary>Инициализирует новый пустой экземпляр класса <see cref="T:System.Collections.ArrayList" /> с указанной начальной емкостью.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Емкость <xref:System.Collections.ArrayList> — это количество элементов, которые может содержать объект <xref:System.Collections.ArrayList> . При добавлении элементов в объект <xref:System.Collections.ArrayList>емкость автоматически увеличивается по мере необходимости путем перераспределения внутреннего массива.  
  
 Если размер коллекции можно оценить, указание начальной емкости избавляет от необходимости выполнять несколько операций изменения размера при добавлении элементов <xref:System.Collections.ArrayList>в.  
  
 Этот конструктор является операцией O`n`(), где `n` имеет `capacity`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="capacity" /> меньше нуля.</exception>
        <altmember cref="P:System.Collections.ArrayList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Adapter">
      <MemberSignature Language="C#" Value="public static System.Collections.ArrayList Adapter (System.Collections.IList list);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ArrayList Adapter(class System.Collections.IList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Adapter(System.Collections.IList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Adapter (list As IList) As ArrayList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ArrayList ^ Adapter(System::Collections::IList ^ list);" />
      <MemberSignature Language="F#" Value="static member Adapter : System.Collections.IList -&gt; System.Collections.ArrayList" Usage="System.Collections.ArrayList.Adapter list" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ArrayList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="list" Type="System.Collections.IList" />
      </Parameters>
      <Docs>
        <param name="list">Класс <see cref="T:System.Collections.IList" />, для которого создается оболочка.</param>
        <summary>Создает оболочку класса <see cref="T:System.Collections.ArrayList" /> для указанного интерфейса <see cref="T:System.Collections.IList" />.</summary>
        <returns>Оболочка <see cref="T:System.Collections.ArrayList" /> интерфейса <see cref="T:System.Collections.IList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList.Adapter%2A>не копирует содержимое <xref:System.Collections.IList>. Вместо этого он <xref:System.Collections.ArrayList> создает только <xref:System.Collections.IList>оболочку, <xref:System.Collections.IList> поэтому изменения также влияют <xref:System.Collections.ArrayList>на.  
  
 Класс предоставляет <xref:System.Collections.ArrayList.Reverse%2A>универсальныеметоды <xref:System.Collections.ArrayList.Sort%2A> и. <xref:System.Collections.ArrayList.BinarySearch%2A> <xref:System.Collections.ArrayList> Эта оболочка может быть средством использования этих методов <xref:System.Collections.IList>; однако выполнение этих универсальных операций через оболочку может оказаться менее эффективным, чем операции, <xref:System.Collections.IList>применяемые непосредственно к.  
  
 Этот метод является операцией O (1).  
  
## <a name="version-compatibility"></a>Совместимость версий  
 В .NET Framework версии 1,0 и 1,1 вызов <xref:System.Collections.ArrayList.GetEnumerator%28System.Int32%2CSystem.Int32%29> перегрузки метода <xref:System.Collections.ArrayList> в оболочке вернул перечислитель, который обрабатывал второй аргумент как верхнюю границу, а не как число. [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] Во втором аргументе правильно рассматривается как число.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="list" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)" />
        <altmember cref="M:System.Collections.ArrayList.Reverse" />
        <altmember cref="M:System.Collections.ArrayList.Sort" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual int Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Add(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Add(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Add : obj -&gt; int&#xA;override this.Add : obj -&gt; int" Usage="arrayList.Add value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Объект <see cref="T:System.Object" />, добавляемый в конец коллекции <see cref="T:System.Collections.ArrayList" />. Допускается значение <see langword="null" />.</param>
        <summary>Добавляет объект в конец очереди <see cref="T:System.Collections.ArrayList" />.</summary>
        <returns>Индекс <see cref="T:System.Collections.ArrayList" />, по которому добавлен параметр <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList>принимает `null` как допустимое значение и позволяет дублировать элементы.  
  
 Если <xref:System.Collections.ArrayList.Count%2A> значение уже <xref:System.Collections.ArrayList.Capacity%2A> равно<xref:System.Collections.ArrayList> , емкость увеличивается путем автоматического перераспределения внутреннего массива, а существующие элементы копируются в новый массив перед добавлением нового элемента.  
  
 <xref:System.Collections.ArrayList.Count%2A> Если<xref:System.Collections.ArrayList.Capacity%2A>меньше, этот метод является операцией O (1). Если емкость необходимо увеличить для размещения нового элемента, этот метод становится операцией O (`n`), где `n` имеет значение <xref:System.Collections.ArrayList.Count%2A>.  
  
   
  
## Examples  
 В следующем примере кода показано, как добавить элементы в <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.Add Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Add Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Add Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Add Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Add Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Add Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Объект <see cref="T:System.Collections.ArrayList" /> доступен только для чтения.  
  
- или - 
<see cref="T:System.Collections.ArrayList" /> имеет фиксированный размер.</exception>
        <altmember cref="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Remove(System.Object)" />
        <altmember cref="P:System.Collections.ArrayList.Count" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public virtual void AddRange (System.Collections.ICollection c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddRange(class System.Collections.ICollection c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AddRange (c As ICollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AddRange(System::Collections::ICollection ^ c);" />
      <MemberSignature Language="F#" Value="abstract member AddRange : System.Collections.ICollection -&gt; unit&#xA;override this.AddRange : System.Collections.ICollection -&gt; unit" Usage="arrayList.AddRange c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Collections.ICollection" />
      </Parameters>
      <Docs>
        <param name="c">Интерфейс <see cref="T:System.Collections.ICollection" />, элементы которого добавляются в конец списка <see cref="T:System.Collections.ArrayList" />. Сама коллекция не может иметь значение <see langword="null" />, но может содержать элементы со значением <see langword="null" />.</param>
        <summary>Добавляет элементы интерфейса <see cref="T:System.Collections.ICollection" /> в конец списка <see cref="T:System.Collections.ArrayList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList>принимает `null` как допустимое значение и позволяет дублировать элементы.  
  
 Порядок элементов в <xref:System.Collections.ICollection> сохраняется <xref:System.Collections.ArrayList>в.  
  
 Если новый <xref:System.Collections.ArrayList.Count%2A> (текущий <xref:System.Collections.ArrayList.Count%2A> плюс размер коллекции <xref:System.Collections.ArrayList.Capacity%2A>) будет больше, емкость <xref:System.Collections.ArrayList> увеличивается путем автоматического перераспределения внутреннего массива для размещения новых элементов, а элемент существующие элементы копируются в новый массив перед добавлением новых элементов.  
  
 Если объект <xref:System.Collections.ArrayList> может разместить новые элементы без <xref:System.Collections.ArrayList.Capacity%2A>увеличения, этот метод является операцией O (`n`), где `n` — число добавляемых элементов. Если емкость необходимо увеличить для размещения новых элементов, этот метод становится операцией O (`n` +  `m` `m`), где `n` — число добавляемых элементов, а — <xref:System.Collections.ArrayList.Count%2A>.  
  
   
  
## Examples  
 В следующем примере кода показано, как добавить элементы в <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.Add Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Add Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Add Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Add Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Add Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Add Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="c" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Объект <see cref="T:System.Collections.ArrayList" /> доступен только для чтения.  
  
- или - 
<see cref="T:System.Collections.ArrayList" /> имеет фиксированный размер.</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.ArrayList.Capacity" />
        <altmember cref="P:System.Collections.ArrayList.Count" />
        <altmember cref="M:System.Collections.ArrayList.Add(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Использует алгоритм двоичного поиска для нахождения определенного элемента в отсортированном списке <see cref="T:System.Collections.ArrayList" /> или в его части.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public virtual int BinarySearch (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 BinarySearch(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.BinarySearch(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BinarySearch (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int BinarySearch(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member BinarySearch : obj -&gt; int&#xA;override this.BinarySearch : obj -&gt; int" Usage="arrayList.BinarySearch value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Искомый объект <see cref="T:System.Object" />. Допускается значение <see langword="null" />.</param>
        <summary>Выполняет поиск элемента по всему отсортированному списку <see cref="T:System.Collections.ArrayList" />, используя компаратор по умолчанию, и возвращает индекс элемента, отсчитываемый от нуля.</summary>
        <returns>Начинающийся с нуля индекс элемента <paramref name="value" /> в отсортированном списке <see cref="T:System.Collections.ArrayList" />, если элемент <paramref name="value" /> найден; в противном случае — отрицательное число, которое является двоичным дополнением индекса следующего элемента, большего, чем <paramref name="value" />, или, если большего элемента не существует, двоичным дополнением значения <see cref="P:System.Collections.ArrayList.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр и каждый элемент в <xref:System.Collections.ArrayList> должны реализовывать <xref:System.IComparable> интерфейс, который используется для сравнений. `value` Элементы объекта <xref:System.Collections.ArrayList> должны уже быть отсортированы в возрастающем значении в соответствии с порядком сортировки, <xref:System.IComparable> определенным реализацией; в противном случае результат может быть неверным.  
  
 Допускается `null` сравнение с любым типом и не создает исключение при использовании <xref:System.IComparable>. При сортировке `null` считается меньше, чем любой другой объект.  
  
 Если объект <xref:System.Collections.ArrayList> содержит более одного элемента с одинаковым значением, метод возвращает только одно из вхождений и может возвращать одно из вхождений, необязательное в первую очередь.  
  
 Если параметр <xref:System.Collections.ArrayList> не содержит указанное значение, метод возвращает отрицательное целое число. Операцию побитового дополнения (~) можно применить к этому отрицательному целому числу, чтобы получить индекс первого элемента, превышающего искомое значение. При вставке значения в объект <xref:System.Collections.ArrayList>этот индекс следует использовать в качестве точки вставки для сохранения порядка сортировки.  
  
 Этот метод является операцией O ( `n`log), где `n` — <xref:System.Collections.ArrayList.Count%2A>.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать <xref:System.Collections.ArrayList.BinarySearch%2A> для нахождение определенного объекта <xref:System.Collections.ArrayList>в.  
  
 [!code-cpp[Classic ArrayList.BinarySearch1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.BinarySearch1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.BinarySearch1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.BinarySearch1 Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.BinarySearch1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.BinarySearch1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ни один из элементов <paramref name="value" /> и <see cref="T:System.Collections.ArrayList" /> не реализуют интерфейс <see cref="T:System.IComparable" />.</exception>
        <exception cref="T:System.InvalidOperationException">Тип <paramref name="value" /> не совпадает с типом элементов <see cref="T:System.Collections.ArrayList" />.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Выполнение в коллекциях строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public virtual int BinarySearch (object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 BinarySearch(object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BinarySearch (value As Object, comparer As IComparer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int BinarySearch(System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="abstract member BinarySearch : obj * System.Collections.IComparer -&gt; int&#xA;override this.BinarySearch : obj * System.Collections.IComparer -&gt; int" Usage="arrayList.BinarySearch (value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="value">Искомый объект <see cref="T:System.Object" />. Допускается значение <see langword="null" />.</param>
        <param name="comparer">Реализация интерфейса <see cref="T:System.Collections.IComparer" />, которая используется при сравнении элементов.  
  
- или - 
 Значение <see langword="null" />, чтобы использовать функцию сравнения по умолчанию, которая является реализацией <see cref="T:System.IComparable" /> для каждого элемента.</param>
        <summary>Выполняет поиск элемента по всему отсортированному списку <see cref="T:System.Collections.ArrayList" />, используя указанный компаратор, и возвращает индекс элемента, отсчитываемый от нуля.</summary>
        <returns>Начинающийся с нуля индекс элемента <paramref name="value" /> в отсортированном списке <see cref="T:System.Collections.ArrayList" />, если элемент <paramref name="value" /> найден; в противном случае — отрицательное число, которое является двоичным дополнением индекса следующего элемента, большего, чем <paramref name="value" />, или, если большего элемента не существует, двоичным дополнением значения <see cref="P:System.Collections.ArrayList.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Функция сравнения позволяет настроить сравнение элементов. Например, можно использовать <xref:System.Collections.CaseInsensitiveComparer> экземпляр в качестве компаратора для выполнения поиска строки без учета регистра.  
  
 Если `comparer` указано, элементы <xref:System.Collections.ArrayList> объекта сравниваются с указанным значением с использованием указанной <xref:System.Collections.IComparer> реализации. Элементы объекта <xref:System.Collections.ArrayList> должны быть уже отсортированы в порядке возрастания значений в соответствии с порядком сортировки `comparer`, определенным в. в противном случае результат может быть неверным.  
  
 Если `comparer` имеет `null`значение ,<xref:System.IComparable> сравнение выполняется с помощью реализации, предоставляемой элементом или указанным значением. Элементы объекта <xref:System.Collections.ArrayList> должны уже быть отсортированы в возрастающем значении в соответствии с порядком сортировки, <xref:System.IComparable> определенным реализацией; в противном случае результат может быть неверным.  
  
 Допускается `null` сравнение с любым типом и не создает исключение при использовании <xref:System.IComparable>. При сортировке `null` считается меньше, чем любой другой объект.  
  
 Если объект <xref:System.Collections.ArrayList> содержит более одного элемента с одинаковым значением, метод возвращает только одно из вхождений и может возвращать одно из вхождений, необязательное в первую очередь.  
  
 Если параметр <xref:System.Collections.ArrayList> не содержит указанное значение, метод возвращает отрицательное целое число. Операцию побитового дополнения (~) можно применить к этому отрицательному целому числу, чтобы получить индекс первого элемента, превышающего искомое значение. При вставке значения в объект <xref:System.Collections.ArrayList>этот индекс следует использовать в качестве точки вставки для сохранения порядка сортировки.  
  
 Этот метод является операцией O ( `n`log), где `n` — <xref:System.Collections.ArrayList.Count%2A>.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Collections.ArrayList> цвет животных. Заданный <xref:System.Collections.IComparer> объект выполняет сравнение строк для двоичного поиска. Отобразятся результаты одновременного поиска и двоичного поиска.  
  
 [!code-cpp[Classic ArrayList.BinarySearch1 Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.BinarySearch1 Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic ArrayList.BinarySearch1 Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.BinarySearch1 Example/CS/source2.cs#2)]
 [!code-vb[Classic ArrayList.BinarySearch1 Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.BinarySearch1 Example/VB/source2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparer" /> имеет значение <see langword="null" />, и ни <paramref name="value" />, ни элементы <see cref="T:System.Collections.ArrayList" /> не реализуют интерфейс <see cref="T:System.IComparable" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> имеет значение <see langword="null" />, и тип <paramref name="value" /> не совпадает с типом элементов <see cref="T:System.Collections.ArrayList" />.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Выполнение в коллекциях строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public virtual int BinarySearch (int index, int count, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 BinarySearch(int32 index, int32 count, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BinarySearch (index As Integer, count As Integer, value As Object, comparer As IComparer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int BinarySearch(int index, int count, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="abstract member BinarySearch : int * int * obj * System.Collections.IComparer -&gt; int&#xA;override this.BinarySearch : int * int * obj * System.Collections.IComparer -&gt; int" Usage="arrayList.BinarySearch (index, count, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="index">Отсчитываемый от нуля индекс начала диапазона поиска.</param>
        <param name="count">Длина диапазона поиска.</param>
        <param name="value">Искомый объект <see cref="T:System.Object" />. Допускается значение <see langword="null" />.</param>
        <param name="comparer">Реализация интерфейса <see cref="T:System.Collections.IComparer" />, которая используется при сравнении элементов.  
  
- или - 
 Значение <see langword="null" />, чтобы использовать функцию сравнения по умолчанию, которая является реализацией <see cref="T:System.IComparable" /> для каждого элемента.</param>
        <summary>Выполняет поиск элемента в диапазоне элементов отсортированного списка <see cref="T:System.Collections.ArrayList" />, используя указанную функцию сравнения, и возвращает индекс элемента, отсчитываемый от нуля.</summary>
        <returns>Начинающийся с нуля индекс элемента <paramref name="value" /> в отсортированном списке <see cref="T:System.Collections.ArrayList" />, если элемент <paramref name="value" /> найден; в противном случае — отрицательное число, которое является двоичным дополнением индекса следующего элемента, большего, чем <paramref name="value" />, или, если большего элемента не существует, двоичным дополнением значения <see cref="P:System.Collections.ArrayList.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Функция сравнения позволяет настроить сравнение элементов. Например, можно использовать <xref:System.Collections.CaseInsensitiveComparer> экземпляр в качестве компаратора для выполнения поиска строки без учета регистра.  
  
 Если `comparer` указано, элементы <xref:System.Collections.ArrayList> объекта сравниваются с указанным значением с использованием указанной <xref:System.Collections.IComparer> реализации. Элементы объекта <xref:System.Collections.ArrayList> должны быть уже отсортированы в порядке возрастания значений в соответствии с порядком сортировки `comparer`, определенным в. в противном случае результат может быть неверным.  
  
 Если `comparer` имеет `null`значение ,<xref:System.IComparable> сравнение выполняется с помощью реализации, предоставляемой элементом или указанным значением. Элементы объекта <xref:System.Collections.ArrayList> должны уже быть отсортированы в возрастающем значении в соответствии с порядком сортировки, <xref:System.IComparable> определенным реализацией; в противном случае результат может быть неверным.  
  
 Допускается `null` сравнение с любым типом и не создает исключение при использовании <xref:System.IComparable>. При сортировке `null` считается меньше, чем любой другой объект.  
  
 Если объект <xref:System.Collections.ArrayList> содержит более одного элемента с одинаковым значением, метод возвращает только одно из вхождений и может возвращать одно из вхождений, необязательное в первую очередь.  
  
 Если параметр <xref:System.Collections.ArrayList> не содержит указанное значение, метод возвращает отрицательное целое число. Операцию побитового дополнения (~) можно применить к этому отрицательному целому числу, чтобы получить индекс первого элемента, превышающего искомое значение. При вставке значения в объект <xref:System.Collections.ArrayList>этот индекс следует использовать в качестве точки вставки для сохранения порядка сортировки.  
  
 Этот метод является операцией O ( `n`log), где `n` — `count`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметры <paramref name="index" /> и <paramref name="count" /> не указывают допустимый диапазон в <see cref="T:System.Collections.ArrayList" />.  
  
- или - 
 <paramref name="comparer" /> имеет значение <see langword="null" />, и ни <paramref name="value" />, ни элементы <see cref="T:System.Collections.ArrayList" /> не реализуют интерфейс <see cref="T:System.IComparable" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> имеет значение <see langword="null" />, и тип <paramref name="value" /> не совпадает с типом элементов <see cref="T:System.Collections.ArrayList" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> меньше нуля.  
  
- или - 
 Значение параметра <paramref name="count" /> меньше нуля.</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Выполнение в коллекциях строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public virtual int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ArrayList.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Collections.ArrayList.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает число элементов, которое может содержать список <see cref="T:System.Collections.ArrayList" />.</summary>
        <value>Количество элементов, которое может содержать коллекция <see cref="T:System.Collections.ArrayList" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList.Capacity%2A>число элементов, которое может храниться <xref:System.Collections.ArrayList> в. <xref:System.Collections.ArrayList.Count%2A>число элементов, которые фактически находятся в <xref:System.Collections.ArrayList>.  
  
 <xref:System.Collections.ArrayList.Capacity%2A>всегда больше или равно <xref:System.Collections.ArrayList.Count%2A>. Если <xref:System.Collections.ArrayList.Count%2A> превышено <xref:System.Collections.ArrayList.Capacity%2A> время добавления элементов, емкость автоматически увеличивается путем перераспределения внутреннего массива перед копированием старых элементов и добавлением новых элементов.  
  
 Емкость можно уменьшить, вызвав <xref:System.Collections.ArrayList.TrimToSize%2A> или явно <xref:System.Collections.ArrayList.Capacity%2A> задав свойство. Если значение <xref:System.Collections.ArrayList.Capacity%2A> задано явно, внутренний массив также перераспределяется в соответствии с заданной емкостью.  
  
 Получение значения этого свойства является операцией O (1); Задание свойства является операцией O (`n`), где `n` — это новая емкость.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Для <see cref="P:System.Collections.ArrayList.Capacity" /> установлено значение, которое меньше <see cref="P:System.Collections.ArrayList.Count" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно свободной памяти в системе.</exception>
        <altmember cref="P:System.Collections.ArrayList.Count" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public virtual void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="arrayList.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет из коллекции <see cref="T:System.Collections.ArrayList" /> все элементы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList.Count%2A>имеет значение 0, а ссылки на другие объекты из элементов коллекции также освобождаются.  
  
 <xref:System.Collections.ArrayList.Capacity%2A>не изменяется.  Чтобы сбросить емкость <xref:System.Collections.ArrayList>, вызовите <xref:System.Collections.ArrayList.TrimToSize%2A> или задайте <xref:System.Collections.ArrayList.Capacity%2A> свойство напрямую. Удаление пустой <xref:System.Collections.ArrayList> задает емкость объекта <xref:System.Collections.ArrayList> емкость по умолчанию.  
  
 Этот метод является операцией O`n`(), где `n` имеет <xref:System.Collections.ArrayList.Count%2A>.  
  
   
  
## Examples  
 В следующем примере кода показано, как обрезать неиспользуемые части <xref:System.Collections.ArrayList> объекта и как очистить значения. <xref:System.Collections.ArrayList>  
  
 [!code-cpp[Classic ArrayList.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Объект <see cref="T:System.Collections.ArrayList" /> доступен только для чтения.  
  
- или - 
<see cref="T:System.Collections.ArrayList" /> имеет фиксированный размер.</exception>
        <altmember cref="M:System.Collections.ArrayList.TrimToSize" />
        <altmember cref="P:System.Collections.ArrayList.Capacity" />
        <altmember cref="P:System.Collections.ArrayList.Count" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="arrayList.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает неполную копию <see cref="T:System.Collections.ArrayList" />.</summary>
        <returns>Неполная копия <see cref="T:System.Collections.ArrayList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Неполная копия коллекции копирует только элементы коллекции, будь то ссылочные типы или типы значений, но не копирует объекты, на которые ссылаются ссылки. Ссылки в новой коллекции указывают на те же объекты, на которые указывает ссылка в исходной коллекции.  
  
 В отличие от этого, глубокая копия коллекции копирует элементы и все, на которые прямо или косвенно ссылаются элементы.  
  
 Этот метод является операцией O`n`(), где `n` имеет <xref:System.Collections.ArrayList.Count%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public virtual bool Contains (object item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Contains (item As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Object ^ item);" />
      <MemberSignature Language="F#" Value="abstract member Contains : obj -&gt; bool&#xA;override this.Contains : obj -&gt; bool" Usage="arrayList.Contains item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Объект <see cref="T:System.Object" />, который требуется найти в коллекции <see cref="T:System.Collections.ArrayList" />. Допускается значение <see langword="null" />.</param>
        <summary>Определяет, входит ли элемент в коллекцию <see cref="T:System.Collections.ArrayList" />.</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="item" /> найден в коллекции <see cref="T:System.Collections.ArrayList" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет линейный поиск. Таким образом, этот метод является операцией`n`O (), `n` где <xref:System.Collections.ArrayList.Count%2A>имеет.  
  
 Этот метод определяет равенство путем <xref:System.Object.Equals%2A?displayProperty=nameWithType>вызова.  
  
 Начиная с .NET Framework 2,0, этот метод использует объекты <xref:System.Object.Equals%2A> и <xref:System.IComparable.CompareTo%2A> методы `item` коллекции для определения того, существует ли элемент. В более ранних версиях .NET Framework это определение было выполнено с помощью <xref:System.Object.Equals%2A> методов `item` и <xref:System.IComparable.CompareTo%2A> параметра для объектов в коллекции.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ArrayList.IndexOf(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.LastIndexOf(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Выполнение в коллекциях строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Копирует список <see cref="T:System.Collections.ArrayList" /> или его часть в одномерный массив.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.CopyTo(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array -&gt; unit&#xA;override this.CopyTo : Array -&gt; unit" Usage="arrayList.CopyTo array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">Одномерный массив <see cref="T:System.Array" />, в который копируются элементы из интерфейса <see cref="T:System.Collections.ArrayList" />. Массив <see cref="T:System.Array" /> должен иметь индексацию, начинающуюся с нуля.</param>
        <summary>Копирует весь список <see cref="T:System.Collections.ArrayList" /> в совместимый одномерный массив <see cref="T:System.Array" />, начиная с начального элемента целевого массива.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Указанный массив должен иметь совместимый тип.  
  
 Этот метод использует <xref:System.Array.Copy%2A?displayProperty=nameWithType> для копирования элементов.  
  
 Элементы копируются <xref:System.Array> в в том же порядке, в котором перечислитель выполняет итерацию <xref:System.Collections.ArrayList>по.  
  
 Этот метод является операцией O`n`(), где `n` имеет <xref:System.Collections.ArrayList.Count%2A>.  
  
   
  
## Examples  
 В следующем примере кода показано, как скопировать объект <xref:System.Collections.ArrayList> в одномерный <xref:System.Array?displayProperty=nameWithType>массив.  
  
 [!code-cpp[Classic ArrayList.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.CopyTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Массив <paramref name="array" /> является многомерным.  
  
- или - 
Число элементов в исходном массиве <see cref="T:System.Collections.ArrayList" /> больше числа элементов, которые может содержать массив назначения <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidCastException">Тип исходного массива <see cref="T:System.Collections.ArrayList" /> не может быть автоматически приведен к типу массива назначения <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="arrayList.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Одномерный массив <see cref="T:System.Array" />, в который копируются элементы из интерфейса <see cref="T:System.Collections.ArrayList" />. Массив <see cref="T:System.Array" /> должен иметь индексацию, начинающуюся с нуля.</param>
        <param name="arrayIndex">Отсчитываемый от нуля индекс в массиве <paramref name="array" />, указывающий начало копирования.</param>
        <summary>Копирует целый массив <see cref="T:System.Collections.ArrayList" /> в совместимый одномерный массив <see cref="T:System.Array" />, начиная с заданного индекса целевого массива.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Указанный массив должен иметь совместимый тип.  
  
 Этот метод использует <xref:System.Array.Copy%2A?displayProperty=nameWithType> для копирования элементов.  
  
 Элементы копируются <xref:System.Array> в в том же порядке, в котором перечислитель выполняет итерацию <xref:System.Collections.ArrayList>по.  
  
 Этот метод является операцией O`n`(), где `n` имеет <xref:System.Collections.ArrayList.Count%2A>.  
  
   
  
## Examples  
 В следующем примере кода показано, как скопировать объект <xref:System.Collections.ArrayList> в одномерный <xref:System.Array?displayProperty=nameWithType>массив.  
  
 [!code-cpp[Classic ArrayList.CopyTo1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.CopyTo1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.CopyTo1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.CopyTo1 Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.CopyTo1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.CopyTo1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="arrayIndex" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException">Массив <paramref name="array" /> является многомерным.  
  
- или - 
Число элементов в исходной коллекции <see cref="T:System.Collections.ArrayList" /> больше доступного места от положения, заданного значением параметра <paramref name="arrayIndex" />, до конца массива назначения <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidCastException">Тип исходного массива <see cref="T:System.Collections.ArrayList" /> не может быть автоматически приведен к типу массива назначения <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public virtual void CopyTo (int index, Array array, int arrayIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(int32 index, class System.Array array, int32 arrayIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(int index, Array ^ array, int arrayIndex, int count);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : int * Array * int * int -&gt; unit&#xA;override this.CopyTo : int * Array * int * int -&gt; unit" Usage="arrayList.CopyTo (index, array, arrayIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Отсчитываемый от нуля индекс исходного списка <see cref="T:System.Collections.ArrayList" />, с которого начинается копирование.</param>
        <param name="array">Одномерный массив <see cref="T:System.Array" /> , в который копируются элементы из интерфейса <see cref="T:System.Collections.ArrayList" />. Массив <see cref="T:System.Array" /> должен иметь индексацию, начинающуюся с нуля.</param>
        <param name="arrayIndex">Отсчитываемый от нуля индекс в массиве <paramref name="array" />, указывающий начало копирования.</param>
        <param name="count">Число элементов для копирования.</param>
        <summary>Копирует диапазон элементов из списка <see cref="T:System.Collections.ArrayList" /> в совместимый одномерный массив <see cref="T:System.Array" />, начиная с указанного индекса целевого массива.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Указанный массив должен иметь совместимый тип.  
  
 Этот метод использует <xref:System.Array.Copy%2A?displayProperty=nameWithType> для копирования элементов.  
  
 Элементы копируются <xref:System.Array> в в том же порядке, в котором перечислитель выполняет итерацию <xref:System.Collections.ArrayList>по.  
  
 Этот метод является операцией O`n`(), где `n` имеет `count`.  
  
   
  
## Examples  
 В следующем примере кода показано, как скопировать объект <xref:System.Collections.ArrayList> в одномерный <xref:System.Array?displayProperty=nameWithType>массив.  
  
 [!code-cpp[Classic ArrayList.CopyTo1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.CopyTo1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.CopyTo1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.CopyTo1 Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.CopyTo1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.CopyTo1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> меньше нуля.  
  
- или - 
 Значение параметра <paramref name="arrayIndex" /> меньше нуля.  
  
- или - 
 Значение параметра <paramref name="count" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException">Массив <paramref name="array" /> является многомерным.  
  
- или - 
 Значение параметра <paramref name="index" /> больше или равно значению <see cref="P:System.Collections.ArrayList.Count" /> исходного списка <see cref="T:System.Collections.ArrayList" />.  
  
-или- 
Число элементов от <paramref name="index" /> до конца исходного списка <see cref="T:System.Collections.ArrayList" /> больше доступного места от положения, заданного значением параметра <paramref name="arrayIndex" />, до конца массива назначения <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidCastException">Тип исходного массива <see cref="T:System.Collections.ArrayList" /> не может быть автоматически приведен к типу массива назначения <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public virtual int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ArrayList.Count" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.ArrayList.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает число элементов, фактически содержащихся в списке <see cref="T:System.Collections.ArrayList" />.</summary>
        <value>Число элементов, фактически содержащихся в списке <see cref="T:System.Collections.ArrayList" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList.Capacity%2A>число элементов, которое может храниться <xref:System.Collections.ArrayList> в. <xref:System.Collections.ArrayList.Count%2A>число элементов, которые фактически находятся в <xref:System.Collections.ArrayList>.  
  
 <xref:System.Collections.ArrayList.Capacity%2A>всегда больше или равно <xref:System.Collections.ArrayList.Count%2A>. Если <xref:System.Collections.ArrayList.Count%2A> превышено <xref:System.Collections.ArrayList.Capacity%2A> время добавления элементов, емкость автоматически увеличивается путем перераспределения внутреннего массива перед копированием старых элементов и добавлением новых элементов.  
  
 Получение значения данного свойства является операцией порядка сложности O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ArrayList.Capacity" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FixedSize">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает оболочку списка фиксированного размера, в которой элементы можно изменять, но нельзя добавлять или удалять.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FixedSize">
      <MemberSignature Language="C#" Value="public static System.Collections.ArrayList FixedSize (System.Collections.ArrayList list);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ArrayList FixedSize(class System.Collections.ArrayList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.FixedSize(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FixedSize (list As ArrayList) As ArrayList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ArrayList ^ FixedSize(System::Collections::ArrayList ^ list);" />
      <MemberSignature Language="F#" Value="static member FixedSize : System.Collections.ArrayList -&gt; System.Collections.ArrayList" Usage="System.Collections.ArrayList.FixedSize list" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ArrayList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="list" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="list">Класс <see cref="T:System.Collections.ArrayList" />, для которого создается оболочка.</param>
        <summary>Возвращает оболочку <see cref="T:System.Collections.ArrayList" /> фиксированного размера.</summary>
        <returns>Оболочка <see cref="T:System.Collections.ArrayList" /> фиксированного размера.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта оболочка может использоваться для предотвращения добавления и удаления из исходной <xref:System.Collections.ArrayList>. Элементы можно по-прежнему изменять или заменять.  
  
 Коллекция с фиксированным размером — это просто коллекция с оболочкой, которая предотвращает добавление и удаление элементов. Таким образом, если в базовую коллекцию вносятся изменения, включая добавление или удаление элементов, Коллекция фиксированного размера отражает эти изменения.  
  
 Этот метод является операцией O (1).  
  
   
  
## Examples  
 В следующем примере кода показано, как создать оболочку фиксированного размера вокруг <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.IsFixedSize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IsFixedSize Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.IsFixedSize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IsFixedSize Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.IsFixedSize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IsFixedSize Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="list" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FixedSize">
      <MemberSignature Language="C#" Value="public static System.Collections.IList FixedSize (System.Collections.IList list);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IList FixedSize(class System.Collections.IList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.FixedSize(System.Collections.IList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FixedSize (list As IList) As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IList ^ FixedSize(System::Collections::IList ^ list);" />
      <MemberSignature Language="F#" Value="static member FixedSize : System.Collections.IList -&gt; System.Collections.IList" Usage="System.Collections.ArrayList.FixedSize list" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="list" Type="System.Collections.IList" />
      </Parameters>
      <Docs>
        <param name="list">Класс <see cref="T:System.Collections.IList" />, для которого создается оболочка.</param>
        <summary>Возвращает оболочку <see cref="T:System.Collections.IList" /> фиксированного размера.</summary>
        <returns>Оболочка <see cref="T:System.Collections.IList" /> фиксированного размера.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта оболочка может использоваться для предотвращения добавления и удаления из исходной <xref:System.Collections.IList>. Элементы можно по-прежнему изменять или заменять.  
  
 Коллекция с фиксированным размером — это просто коллекция с оболочкой, которая предотвращает добавление и удаление элементов. Таким образом, если в базовую коллекцию вносятся изменения, включая добавление или удаление элементов, Коллекция фиксированного размера отражает эти изменения.  
  
 Этот метод является операцией O (1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="list" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEnumerator">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает перечислитель, осуществляющий перебор элементов списка <see cref="T:System.Collections.ArrayList" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="arrayList.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает перечислитель для класса <see cref="T:System.Collections.ArrayList" />.</summary>
        <returns><see cref="T:System.Collections.IEnumerator" /> для всего <see cref="T:System.Collections.ArrayList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Инструкция `foreach` языка C# (`for each` в Visual Basic) позволяет скрыть сложный механизм перечислителей.  Поэтому рекомендуется вместо непосредственного использования перечислителя применять ключевое слово `foreach`.  
  
 Перечислители могут использоваться для чтения данных в коллекции, но не для ее изменения.  
  
 Изначально перечислитель располагается перед первым элементом коллекции. Метод <xref:System.Collections.IEnumerator.Reset%2A> также переводит перечислитель в эту позицию.  В этой позиции значение свойства <xref:System.Collections.IEnumerator.Current%2A> не определено. Поэтому необходимо вызвать метод <xref:System.Collections.IEnumerator.MoveNext%2A>, чтобы переместить перечислитель к первому элементу коллекции до считывания значения свойства <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> возвращает тот же объект, пока не будет вызван метод <xref:System.Collections.IEnumerator.MoveNext%2A> или <xref:System.Collections.IEnumerator.Reset%2A>. <xref:System.Collections.IEnumerator.MoveNext%2A> задает <xref:System.Collections.IEnumerator.Current%2A> в качестве значения для следующего элемента.  
  
 Если <xref:System.Collections.IEnumerator.MoveNext%2A> передает конец коллекции, перечислитель располагается после последнего элемента в коллекции и <xref:System.Collections.IEnumerator.MoveNext%2A> возвращает `false`. Если перечислитель находится в этой позиции, последующие вызовы <xref:System.Collections.IEnumerator.MoveNext%2A> также возвращают. `false` Если последний вызов <xref:System.Collections.IEnumerator.MoveNext%2A> возвращен `false`, <xref:System.Collections.IEnumerator.Current%2A> значение не определено. Чтобы снова задать в качестве значения свойства <xref:System.Collections.IEnumerator.Current%2A> первый элемент коллекции, можно последовательно вызвать методы <xref:System.Collections.IEnumerator.Reset%2A> и<xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Перечислитель остается действительным, пока коллекция не изменяется. Если в коллекцию вносятся изменения, например добавляются, изменяются или удаляются элементы, перечислитель становится недействительным без возможности восстановление, а его поведение не определено.  
  
 У перечислителя нет эксклюзивного доступа к коллекции, поэтому перечисление коллекции не является потокобезопасной процедурой.  Чтобы гарантировать потокобезопасность, можно заблокировать коллекцию на время всего перечисления.  Чтобы разрешить доступ к коллекции из нескольких потоков для чтения и записи, необходимо реализовать собственную синхронизацию.  
  
 Этот метод является операцией O (1).  
  
   
  
## Examples  
 В следующем примере возвращается перечислитель для <xref:System.Collections.ArrayList>, а также перечислитель для диапазона элементов <xref:System.Collections.ArrayList>в.  
  
 [!code-csharp[Collections.ArrayList.GetEnumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR/collections.arraylist.getenumerator/cs/program.cs#1)]
 [!code-vb[Collections.ArrayList.GetEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/collections.arraylist.getenumerator/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IEnumerator GetEnumerator (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumerator (index As Integer, count As Integer) As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator(int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : int * int -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : int * int -&gt; System.Collections.IEnumerator" Usage="arrayList.GetEnumerator (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Отсчитываемый от нуля начальный индекс участка списка <see cref="T:System.Collections.ArrayList" />, на который должен ссылаться перечислитель.</param>
        <param name="count">Количество элементов в участке списка <see cref="T:System.Collections.ArrayList" />, на который должен ссылаться перечислитель.</param>
        <summary>Возвращает перечислитель для диапазона элементов в списке <see cref="T:System.Collections.ArrayList" />.</summary>
        <returns>Интерфейс <see cref="T:System.Collections.IEnumerator" /> для указанного диапазона элементов списка <see cref="T:System.Collections.ArrayList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `foreach` Оператор C# языка (`for each` в Visual C++ ,`For Each` Visual Basic) скрывает сложность перечислителей.  Поэтому рекомендуется вместо непосредственного использования перечислителя применять ключевое слово `foreach`.  
  
 Перечислители могут использоваться для чтения данных в коллекции, но не для ее изменения.  
  
 Изначально перечислитель располагается перед первым элементом коллекции. Метод <xref:System.Collections.IEnumerator.Reset%2A> также переводит перечислитель в эту позицию.  В этой позиции значение свойства <xref:System.Collections.IEnumerator.Current%2A> не определено. Поэтому необходимо вызвать метод <xref:System.Collections.IEnumerator.MoveNext%2A>, чтобы переместить перечислитель к первому элементу коллекции до считывания значения свойства <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> возвращает тот же объект, пока не будет вызван метод <xref:System.Collections.IEnumerator.MoveNext%2A> или <xref:System.Collections.IEnumerator.Reset%2A>. <xref:System.Collections.IEnumerator.MoveNext%2A> задает <xref:System.Collections.IEnumerator.Current%2A> в качестве значения для следующего элемента.  
  
 Если <xref:System.Collections.IEnumerator.MoveNext%2A> передает конец коллекции, перечислитель располагается после последнего элемента в коллекции и <xref:System.Collections.IEnumerator.MoveNext%2A> возвращает `false`. Если перечислитель находится в этой позиции, последующие вызовы <xref:System.Collections.IEnumerator.MoveNext%2A> также возвращают. `false` Если последний вызов <xref:System.Collections.IEnumerator.MoveNext%2A> возвращен `false`, <xref:System.Collections.IEnumerator.Current%2A> значение не определено. Чтобы снова задать в качестве значения свойства <xref:System.Collections.IEnumerator.Current%2A> первый элемент коллекции, можно последовательно вызвать методы <xref:System.Collections.IEnumerator.Reset%2A> и<xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Перечислитель остается действительным, пока коллекция не изменяется. Если в коллекцию вносятся изменения, например добавляются, изменяются или удаляются элементы, перечислитель становится недействительным без возможности восстановление, а его поведение не определено.  
  
 У перечислителя нет эксклюзивного доступа к коллекции, поэтому перечисление коллекции не является потокобезопасной процедурой.  Чтобы гарантировать потокобезопасность, можно заблокировать коллекцию на время всего перечисления.  Чтобы разрешить доступ к коллекции из нескольких потоков для чтения и записи, необходимо реализовать собственную синхронизацию.  
  
 Этот метод является операцией O (1).  
  
## <a name="version-compatibility"></a>Совместимость версий  
 В .NET Framework версиях 1,0 и 1,1 перечислитель для <xref:System.Collections.ArrayList> оболочки, возвращаемой <xref:System.Collections.ArrayList.Adapter%2A> методом, обрабатывает второй аргумент как верхнюю границу, а не как число. [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] Во втором аргументе правильно рассматривается как число.  
  
   
  
## Examples  
 В следующем примере возвращается перечислитель для <xref:System.Collections.ArrayList>, а также перечислитель для диапазона элементов <xref:System.Collections.ArrayList>в.  
  
 [!code-csharp[Collections.ArrayList.GetEnumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR/collections.arraylist.getenumerator/cs/program.cs#1)]
 [!code-vb[Collections.ArrayList.GetEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/collections.arraylist.getenumerator/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> меньше нуля.  
  
- или - 
 Значение параметра <paramref name="count" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> и <paramref name="count" /> не указывают допустимый диапазон в <see cref="T:System.Collections.ArrayList" />.</exception>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetRange">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ArrayList GetRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.ArrayList GetRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetRange (index As Integer, count As Integer) As ArrayList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::ArrayList ^ GetRange(int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetRange : int * int -&gt; System.Collections.ArrayList&#xA;override this.GetRange : int * int -&gt; System.Collections.ArrayList" Usage="arrayList.GetRange (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ArrayList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Отсчитываемый от нуля индекс списка <see cref="T:System.Collections.ArrayList" />, с которого начинается диапазон.</param>
        <param name="count">Число элементов в диапазоне.</param>
        <summary>Возвращает список <see cref="T:System.Collections.ArrayList" />, представляющий подмножество элементов исходного списка <see cref="T:System.Collections.ArrayList" />.</summary>
        <returns>Список <see cref="T:System.Collections.ArrayList" />, представляющий подмножество элементов исходного списка <see cref="T:System.Collections.ArrayList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не создает копии элементов. Новый <xref:System.Collections.ArrayList> — это только окно представления в источнике <xref:System.Collections.ArrayList>. Однако все последующие изменения в источнике <xref:System.Collections.ArrayList> должны выполняться через это окно <xref:System.Collections.ArrayList>представления. Если изменения вносятся непосредственно в источник <xref:System.Collections.ArrayList>, окно <xref:System.Collections.ArrayList> представления становится недействительным и любые операции <xref:System.InvalidOperationException>на нем будут возвращать.  
  
 Этот метод является операцией O (1).  
  
   
  
## Examples  
 В следующем примере кода показано, как задать и получить диапазон элементов в <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.SetRange Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.SetRange Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.SetRange Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.SetRange Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.SetRange Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.SetRange Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> меньше нуля.  
  
- или - 
 Значение параметра <paramref name="count" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException">Параметры <paramref name="index" /> и <paramref name="count" /> не указывают допустимый диапазон элементов в списке <see cref="T:System.Collections.ArrayList" />.</exception>
        <altmember cref="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает отсчитываемый от нуля индекс первого вхождения значения в списке <see cref="T:System.Collections.ArrayList" /> или в его части.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : obj -&gt; int&#xA;override this.IndexOf : obj -&gt; int" Usage="arrayList.IndexOf value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Объект <see cref="T:System.Object" />, который требуется найти в коллекции <see cref="T:System.Collections.ArrayList" />. Допускается значение <see langword="null" />.</param>
        <summary>Осуществляет поиск указанного объекта <see cref="T:System.Object" /> и возвращает отсчитываемый от нуля индекс первого вхождения в коллекцию <see cref="T:System.Collections.ArrayList" />.</summary>
        <returns>Индекс (с нуля) первого вхождения параметра <paramref name="value" />, если оно найдено в коллекции <see cref="T:System.Collections.ArrayList" />; в противном случае -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск <xref:System.Collections.ArrayList> выполняется в прямом направлении, начиная с первого элемента и заканчивая последним элементом.  
  
 Этот метод выполняет линейный поиск. Таким образом, этот метод является операцией`n`O (), `n` где <xref:System.Collections.ArrayList.Count%2A>имеет.  
  
 Этот метод определяет равенство путем <xref:System.Object.Equals%2A?displayProperty=nameWithType>вызова.  
  
 Начиная с .NET Framework 2,0, этот метод использует объекты <xref:System.Object.Equals%2A> и <xref:System.IComparable.CompareTo%2A> методы `item` коллекции для определения того, существует ли элемент. В более ранних версиях .NET Framework это определение было выполнено с помощью <xref:System.Object.Equals%2A> методов `item` и <xref:System.IComparable.CompareTo%2A> параметра для объектов в коллекции.  
  
   
  
## Examples  
 В следующем примере кода показано, как определить индекс первого вхождения указанного элемента.  
  
 [!code-cpp[Classic ArrayList.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ArrayList.LastIndexOf(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Contains(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Выполнение в коллекциях строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (value As Object, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::Object ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : obj * int -&gt; int&#xA;override this.IndexOf : obj * int -&gt; int" Usage="arrayList.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Объект <see cref="T:System.Object" />, который требуется найти в коллекции <see cref="T:System.Collections.ArrayList" />. Допускается значение <see langword="null" />.</param>
        <param name="startIndex">Индекс (с нуля) начальной позиции поиска. Значение 0 (ноль) действительно в пустом списке.</param>
        <summary>Осуществляет поиск указанного объекта <see cref="T:System.Object" /> и возвращает отсчитываемый от нуля индекс первого вхождения в диапазоне элементов списка <see cref="T:System.Collections.ArrayList" />, начиная с заданного индекса и до последнего элемента.</summary>
        <returns>Отсчитываемый от нуля индекс первого вхождения элемента <paramref name="value" /> в диапазоне элементов списка <see cref="T:System.Collections.ArrayList" />, начиная с позиции <paramref name="startIndex" /> и до конца списка, если элемент найден; в противном случае значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск выполняется в прямом направлении `startIndex` и заканчивается на последнем элементе. <xref:System.Collections.ArrayList>  
  
 Этот метод выполняет линейный поиск. Таким образом, этот метод является операцией`n`O (), `n` где — число элементов от `startIndex` до конца <xref:System.Collections.ArrayList>.  
  
 Этот метод определяет равенство путем <xref:System.Object.Equals%2A?displayProperty=nameWithType>вызова.  
  
 Начиная с .NET Framework 2,0, этот метод использует объекты <xref:System.Object.Equals%2A> и <xref:System.IComparable.CompareTo%2A> методы `item` коллекции для определения того, существует ли элемент. В более ранних версиях .NET Framework это определение было выполнено с помощью <xref:System.Object.Equals%2A> методов `item` и <xref:System.IComparable.CompareTo%2A> параметра для объектов в коллекции.  
  
   
  
## Examples  
 В следующем примере кода показано, как определить индекс первого вхождения указанного элемента.  
  
 [!code-cpp[Classic ArrayList.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> находится вне диапазона допустимых индексов для <see cref="T:System.Collections.ArrayList" />.</exception>
        <altmember cref="M:System.Collections.ArrayList.LastIndexOf(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Contains(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Выполнение в коллекциях строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (value As Object, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::Object ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : obj * int * int -&gt; int&#xA;override this.IndexOf : obj * int * int -&gt; int" Usage="arrayList.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Объект <see cref="T:System.Object" />, который требуется найти в коллекции <see cref="T:System.Collections.ArrayList" />. Допускается значение <see langword="null" />.</param>
        <param name="startIndex">Индекс (с нуля) начальной позиции поиска. Значение 0 (ноль) действительно в пустом списке.</param>
        <param name="count">Число элементов в диапазоне, в котором выполняется поиск.</param>
        <summary>Выполняет поиск указанного объекта <see cref="T:System.Object" /> и возвращает отсчитываемый от нуля индекс первого вхождения в диапазоне элементов списка <see cref="T:System.Collections.ArrayList" />, который начинается с заданного индекса и содержит указанное число элементов.</summary>
        <returns>Отсчитываемый от нуля индекс первого вхождения <paramref name="value" /> в диапазоне элементов списка <see cref="T:System.Collections.ArrayList" />, который начинается с позиции <paramref name="startIndex" /> и содержит <paramref name="count" /> элементов, если искомый объект найден; в противном случае значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `startIndex` `count` `count` Поиск выполняется в прямом направлении `startIndex` и заканчивается в плюс минус 1, если больше 0. <xref:System.Collections.ArrayList>  
  
 Этот метод выполняет линейный поиск. Таким образом, этот метод является операцией`n`O (), `n` где `count`имеет.  
  
 Этот метод определяет равенство путем <xref:System.Object.Equals%2A?displayProperty=nameWithType>вызова.  
  
 Начиная с .NET Framework 2,0, этот метод использует объекты <xref:System.Object.Equals%2A> и <xref:System.IComparable.CompareTo%2A> методы `item` коллекции для определения того, существует ли элемент. В более ранних версиях .NET Framework это определение было выполнено с помощью <xref:System.Object.Equals%2A> методов `item` и <xref:System.IComparable.CompareTo%2A> параметра для объектов в коллекции.  
  
   
  
## Examples  
 В следующем примере кода показано, как определить индекс первого вхождения указанного элемента.  
  
 [!code-cpp[Classic ArrayList.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> находится вне диапазона допустимых индексов для <see cref="T:System.Collections.ArrayList" />.  
  
- или - 
 Значение параметра <paramref name="count" /> меньше нуля.  
  
-или- 
 <paramref name="startIndex" /> и <paramref name="count" /> не указывают допустимый раздел в <see cref="T:System.Collections.ArrayList" />.</exception>
        <altmember cref="M:System.Collections.ArrayList.LastIndexOf(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Contains(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Выполнение в коллекциях строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public virtual void Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Insert (index As Integer, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Insert(int index, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Insert : int * obj -&gt; unit&#xA;override this.Insert : int * obj -&gt; unit" Usage="arrayList.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Отсчитываемый от нуля индекс, по которому следует вставить элемент <paramref name="value" />.</param>
        <param name="value">Вставляемый объект <see cref="T:System.Object" />. Допускается значение <see langword="null" />.</param>
        <summary>Вставляет элемент в коллекцию <see cref="T:System.Collections.ArrayList" /> по указанному индексу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList>принимает `null` как допустимое значение и позволяет дублировать элементы.  
  
 Если <xref:System.Collections.ArrayList.Count%2A> значение уже <xref:System.Collections.ArrayList.Capacity%2A> равно<xref:System.Collections.ArrayList> , емкость увеличивается путем автоматического перераспределения внутреннего массива, а существующие элементы копируются в новый массив перед добавлением нового элемента.  
  
 Если `index` параметр <xref:System.Collections.ArrayList>равен, то`value` добавляется в конец. <xref:System.Collections.ArrayList.Count%2A>  
  
 В коллекциях с непрерывным набором элементов, таких как списки, чтобы выделить место новому элементу, следующие за точкой вставки элементы перемещаются вниз. Если коллекция индексируется, индексы перемещенных элементов также обновляются. Такое поведение не реализуется в коллекциях, в которых элементы логически сгруппированы, например в хэш-таблицах.  
  
 Этот метод является операцией O`n`(), где `n` имеет <xref:System.Collections.ArrayList.Count%2A>.  
  
   
  
## Examples  
 В следующем примере кода показано, как вставлять элементы в <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.Insert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Insert Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Insert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Insert Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Insert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Insert Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> меньше нуля.  
  
- или - 
 Значение <paramref name="index" /> больше значения <see cref="P:System.Collections.ArrayList.Count" />.</exception>
        <exception cref="T:System.NotSupportedException">Объект <see cref="T:System.Collections.ArrayList" /> доступен только для чтения.  
  
- или - 
<see cref="T:System.Collections.ArrayList" /> имеет фиксированный размер.</exception>
        <altmember cref="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.Add(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Remove(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="InsertRange">
      <MemberSignature Language="C#" Value="public virtual void InsertRange (int index, System.Collections.ICollection c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void InsertRange(int32 index, class System.Collections.ICollection c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub InsertRange (index As Integer, c As ICollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void InsertRange(int index, System::Collections::ICollection ^ c);" />
      <MemberSignature Language="F#" Value="abstract member InsertRange : int * System.Collections.ICollection -&gt; unit&#xA;override this.InsertRange : int * System.Collections.ICollection -&gt; unit" Usage="arrayList.InsertRange (index, c)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="c" Type="System.Collections.ICollection" />
      </Parameters>
      <Docs>
        <param name="index">Отсчитываемый от нуля индекс места вставки новых элементов.</param>
        <param name="c">Коллекция <see cref="T:System.Collections.ICollection" />, элементы которой требуется вставить в список <see cref="T:System.Collections.ArrayList" />. Сама коллекция не может иметь значение <see langword="null" />, но может содержать элементы со значением <see langword="null" />.</param>
        <summary>Вставляет элементы коллекции в список <see cref="T:System.Collections.ArrayList" /> в позиции с указанным индексом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList>принимает `null` как допустимое значение и позволяет дублировать элементы.  
  
 Если новый <xref:System.Collections.ArrayList.Count%2A> (текущий <xref:System.Collections.ArrayList.Count%2A> плюс размер коллекции <xref:System.Collections.ArrayList.Capacity%2A>) будет больше, емкость <xref:System.Collections.ArrayList> увеличивается путем автоматического перераспределения внутреннего массива для размещения новых элементов, а элемент существующие элементы копируются в новый массив перед добавлением новых элементов.  
  
 Если `index` равен<xref:System.Collections.ArrayList.Count%2A>, элементы<xref:System.Collections.ArrayList>добавляются в конец.  
  
 Порядок элементов в <xref:System.Collections.ICollection> сохраняется <xref:System.Collections.ArrayList>в.  
  
 В коллекциях с непрерывным набором элементов, таких как списки, чтобы выделить место новому элементу, следующие за точкой вставки элементы перемещаются вниз. Если коллекция индексируется, индексы перемещенных элементов также обновляются. Такое поведение не реализуется в коллекциях, в которых элементы логически сгруппированы, например в хэш-таблицах.  
  
 Этот метод является операцией O`n`( `m` `n`  + ), где — число добавляемых элементов, а — <xref:System.Collections.ArrayList.Count%2A>.`m`  
  
   
  
## Examples  
 В следующем примере кода показано, как вставлять элементы в <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.Insert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Insert Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Insert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Insert Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Insert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Insert Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="c" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> меньше нуля.  
  
-или- 
 Значение <paramref name="index" /> больше значения <see cref="P:System.Collections.ArrayList.Count" />.</exception>
        <exception cref="T:System.NotSupportedException">Объект <see cref="T:System.Collections.ArrayList" /> доступен только для чтения.  
  
-или- 
<see cref="T:System.Collections.ArrayList" /> имеет фиксированный размер.</exception>
        <altmember cref="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public virtual bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ArrayList.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFixedSize : bool" Usage="System.Collections.ArrayList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, имеет ли список <see cref="T:System.Collections.ArrayList" /> фиксированный размер.</summary>
        <value>Значение<see langword="true" /> , если словарь <see cref="T:System.Collections.ArrayList" /> имеет фиксированный размер; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В созданной коллекции фиксированного размера запрещается добавлять или удалять элементы, но разрешается изменять существующие элементы.  
  
 Коллекция с фиксированным размером — это просто коллекция с оболочкой, которая предотвращает добавление и удаление элементов. Таким образом, если в базовую коллекцию вносятся изменения, включая добавление или удаление элементов, Коллекция фиксированного размера отражает эти изменения.  
  
 Получение значения данного свойства является операцией порядка сложности O(1).  
  
   
  
## Examples  
 В следующем примере кода показано, как создать оболочку фиксированного размера вокруг <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.IsFixedSize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IsFixedSize Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.IsFixedSize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IsFixedSize Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.IsFixedSize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IsFixedSize Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public virtual bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ArrayList.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Collections.ArrayList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, является ли объект <see cref="T:System.Collections.ArrayList" /> доступным только для чтения.</summary>
        <value>Значение<see langword="true" /> , если коллекция <see cref="T:System.Collections.ArrayList" /> доступна только для чтения; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 После создания коллекции, доступной только для чтения, не разрешается добавление элементов в коллекцию, их изменение или удаление.  
  
 Коллекция, доступная только для чтения, — это просто коллекция с оболочкой, которая предотвращает изменение коллекции. Таким образом, если в базовую коллекцию вносятся изменения, то эти изменения отражаются в коллекции только для чтения.  
  
 Получение значения данного свойства является операцией порядка сложности O(1).  
  
   
  
## Examples  
 В следующем примере кода показано, как создать оболочку <xref:System.Collections.ArrayList> , <xref:System.Collections.ArrayList> доступную только для чтения, и определить, доступна ли она только для чтения.  
  
 [!code-cpp[Classic ArrayList.ReadOnly1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.ReadOnly1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.ReadOnly1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.ReadOnly1 Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.ReadOnly1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.ReadOnly1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ArrayList.ReadOnly(System.Collections.IList)" />
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public virtual bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ArrayList.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Collections.ArrayList.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, показывающее, является ли доступ к коллекции <see cref="T:System.Collections.ArrayList" /> синхронизированным (потокобезопасным).</summary>
        <value><see langword="true" /> , если доступ к классу <see cref="T:System.Collections.ArrayList" /> является синхронизированным (потокобезопасным); в противном случае — <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы обеспечить потокобезопасность <xref:System.Collections.ArrayList>, все операции должны выполняться через оболочку, возвращенную <xref:System.Collections.ArrayList.Synchronized%2A> методом.  
  
 Перечисление коллекции не является потокобезопасной процедурой. Даже если коллекция синхронизирована, другие потоки могут ее изменить, что приведет к тому, что перечислитель создаст исключение. Для обеспечения потокобезопасности при перечислении можно либо заблокировать коллекцию на все время перечисления, либо перехватывать исключения, возникающие в результате изменений, внесенных другими потоками.  
  
   
  
## Examples  
 В следующем примере кода показано, <xref:System.Collections.ArrayList.SyncRoot%2A> как заблокировать коллекцию с помощью во время всего перечисления.  
  
 [!code-cpp[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/VB/source2.vb#2)]  
  
 Получение значения данного свойства является операцией порядка сложности O(1).  
  
 В следующем примере кода показано <xref:System.Collections.ArrayList>, как синхронизировать, определить, синхронизировано <xref:System.Collections.ArrayList> ли и использовать синхронизированное. <xref:System.Collections.ArrayList>  
  
 [!code-cpp[Classic ArrayList.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ArrayList.SyncRoot" />
        <altmember cref="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual object this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ArrayList.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable Property Item(index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : obj with get, set" Usage="System.Collections.ArrayList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Отсчитываемый от нуля индекс элемента, который требуется возвратить или задать.</param>
        <summary>Возвращает или задает элемент по указанному индексу.</summary>
        <value>Элемент, расположенный по указанному индексу.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList.Item%2A> Метод<xref:System.Object>возвращает, поэтому может потребоваться привести возвращаемое значение к исходному типу, чтобы управлять им. Важно отметить, что <xref:System.Collections.ArrayList> не является строго типизированной коллекцией. Для строго типизированной альтернативы см. <xref:System.Collections.Generic.List%601>раздел.  
  
 <xref:System.Collections.ArrayList>принимает `null` как допустимое значение и позволяет дублировать элементы.  
  
 Это свойство предоставляет доступ к указанному элементу коллекции при использовании следующего синтаксиса: `myCollection[index]`.  
  
 C# Язык использует [`this`](~/docs/csharp/language-reference/keywords/this.md) ключевое слово для определения индексаторов <xref:System.Collections.ArrayList.Item%2A> вместо реализации свойства. В языке Visual Basic в качестве свойства по умолчанию реализовано свойство <xref:System.Collections.ArrayList.Item%2A>, предоставляющее те же возможности индексирования.  
  
 Получение значения этого свойства является операцией O (1); Задание свойства также является операцией O (1).  
  
   
  
## Examples  
 В следующем примере кода создается <xref:System.Collections.ArrayList> и добавляется несколько элементов. В примере демонстрируется доступ к элементам <xref:System.Collections.ArrayList.Item%2A> со свойством (индексатор в C#) и изменение элемента путем присвоения <xref:System.Collections.ArrayList.Item%2A> свойству нового значения для указанного индекса. В примере также показано, что <xref:System.Collections.ArrayList.Item%2A> свойство не может использоваться для доступа к элементам или их добавления за пределами текущего размера списка.  
  
 [!code-cpp[System.Collections.ArrayList.Item#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.ArrayList.Item/cpp/source.cpp#1)]
 [!code-csharp[System.Collections.ArrayList.Item#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.ArrayList.Item/CS/source.cs#1)]
 [!code-vb[System.Collections.ArrayList.Item#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.ArrayList.Item/VB/source.vb#1)]  
  
 В следующем примере <xref:System.Collections.ArrayList.Item%2A> свойство явно используется для присвоения значений элементам в списке. В примере определяется класс, который наследует <xref:System.Collections.ArrayList> и добавляет метод для шифрования элементов списка.  
  
 [!code-cpp[System.Collections.ArrayList.Item#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.ArrayList.Item/cpp/source2.cpp#2)]
 [!code-csharp[System.Collections.ArrayList.Item#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.ArrayList.Item/CS/source2.cs#2)]
 [!code-vb[System.Collections.ArrayList.Item#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.ArrayList.Item/VB/source2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> меньше нуля.  
  
- или - 
 Значение параметра <paramref name="index" /> больше или равно значению свойства <see cref="P:System.Collections.ArrayList.Count" />.</exception>
        <altmember cref="P:System.Collections.ArrayList.Count" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает отсчитываемый от нуля индекс последнего вхождения значения в списке <see cref="T:System.Collections.ArrayList" /> или в его части.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public virtual int LastIndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 LastIndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.LastIndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LastIndexOf (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int LastIndexOf(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member LastIndexOf : obj -&gt; int&#xA;override this.LastIndexOf : obj -&gt; int" Usage="arrayList.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Объект <see cref="T:System.Object" />, который требуется найти в коллекции <see cref="T:System.Collections.ArrayList" />. Допускается значение <see langword="null" />.</param>
        <summary>Осуществляет поиск указанного объекта <see cref="T:System.Object" /> и возвращает отсчитываемый от нуля индекс последнего вхождения в коллекцию <see cref="T:System.Collections.ArrayList" />.</summary>
        <returns>Отсчитываемый от нуля индекс последнего вхождения <paramref name="value" /> в пределах всего списка <see cref="T:System.Collections.ArrayList" />, если элемент найден; в противном случае значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск <xref:System.Collections.ArrayList> выполняется в обратном направлении, начиная с последнего элемента и заканчивая первым элементом.  
  
 Этот метод выполняет линейный поиск. Таким образом, этот метод является операцией`n`O (), `n` где <xref:System.Collections.ArrayList.Count%2A>имеет.  
  
 Начиная с .NET Framework 2,0, этот метод использует объекты <xref:System.Object.Equals%2A> и <xref:System.IComparable.CompareTo%2A> методы `item` коллекции для определения того, существует ли элемент. В более ранних версиях .NET Framework это определение было выполнено с помощью <xref:System.Object.Equals%2A> методов `item` и <xref:System.IComparable.CompareTo%2A> параметра для объектов в коллекции.  
  
   
  
## Examples  
 В следующем примере кода показано, как определить индекс последнего вхождения указанного элемента.  
  
 [!code-cpp[Classic ArrayList.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ArrayList.IndexOf(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Contains(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Выполнение в коллекциях строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public virtual int LastIndexOf (object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 LastIndexOf(object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LastIndexOf (value As Object, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int LastIndexOf(System::Object ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="abstract member LastIndexOf : obj * int -&gt; int&#xA;override this.LastIndexOf : obj * int -&gt; int" Usage="arrayList.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Объект <see cref="T:System.Object" />, который требуется найти в коллекции <see cref="T:System.Collections.ArrayList" />. Допускается значение <see langword="null" />.</param>
        <param name="startIndex">Индекс (с нуля) начала диапазона поиска в обратном направлении.</param>
        <summary>Осуществляет поиск указанного объекта <see cref="T:System.Object" /> и возвращает отсчитываемый от нуля индекс последнего вхождения в диапазоне элементов списка <see cref="T:System.Collections.ArrayList" />, начиная с первого элемента и заканчивая элементом с заданным индексом.</summary>
        <returns>Отсчитываемый от нуля индекс последнего вхождения элемента <paramref name="value" /> в диапазоне элементов списка <see cref="T:System.Collections.ArrayList" />, начиная с первого элемента и до позиции <paramref name="startIndex" />, если элемент найден; в противном случае значение -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск <xref:System.Collections.ArrayList> в обратном направлении начинается `startIndex` с и заканчивается на первом элементе.  
  
 Этот метод выполняет линейный поиск. Таким образом, этот метод является операцией`n`O (), `n` где — число элементов <xref:System.Collections.ArrayList> от начала до `startIndex`.  
  
 Этот метод определяет равенство путем <xref:System.Object.Equals%2A?displayProperty=nameWithType>вызова.  
  
 Начиная с .NET Framework 2,0, этот метод использует объекты <xref:System.Object.Equals%2A> и <xref:System.IComparable.CompareTo%2A> методы `item` коллекции для определения того, существует ли элемент. В более ранних версиях .NET Framework это определение было выполнено с помощью <xref:System.Object.Equals%2A> методов `item` и <xref:System.IComparable.CompareTo%2A> параметра для объектов в коллекции.  
  
   
  
## Examples  
 В следующем примере кода показано, как определить индекс последнего вхождения указанного элемента.  
  
 [!code-cpp[Classic ArrayList.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> находится вне диапазона допустимых индексов для <see cref="T:System.Collections.ArrayList" />.</exception>
        <altmember cref="M:System.Collections.ArrayList.IndexOf(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Contains(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Выполнение в коллекциях строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public virtual int LastIndexOf (object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 LastIndexOf(object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LastIndexOf (value As Object, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int LastIndexOf(System::Object ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="abstract member LastIndexOf : obj * int * int -&gt; int&#xA;override this.LastIndexOf : obj * int * int -&gt; int" Usage="arrayList.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Объект <see cref="T:System.Object" />, который требуется найти в коллекции <see cref="T:System.Collections.ArrayList" />. Допускается значение <see langword="null" />.</param>
        <param name="startIndex">Индекс (с нуля) начала диапазона поиска в обратном направлении.</param>
        <param name="count">Число элементов в диапазоне, в котором выполняется поиск.</param>
        <summary>Выполняет поиск указанного объекта <see cref="T:System.Object" /> и возвращает отсчитываемый от нуля индекс последнего вхождения в диапазоне элементов списка <see cref="T:System.Collections.ArrayList" />, содержащем указанное число элементов и заканчивающемся в позиции с указанным индексом.</summary>
        <returns>Отсчитываемый от нуля индекс последнего вхождения <paramref name="value" /> в диапазоне элементов списка <see cref="T:System.Collections.ArrayList" />, состоящем из <paramref name="count" /> элементов и заканчивающемся в позиции <paramref name="startIndex" />, если элемент найден. В противном случае значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск <xref:System.Collections.ArrayList> в обратном направлении начинается `startIndex` с и заканчивается `startIndex` минус `count` плюс 1, если `count` больше 0.  
  
 Этот метод выполняет линейный поиск. Таким образом, этот метод является операцией`n`O (), `n` где `count`имеет.  
  
 Этот метод определяет равенство путем <xref:System.Object.Equals%2A?displayProperty=nameWithType>вызова.  
  
 Начиная с .NET Framework 2,0, этот метод использует объекты <xref:System.Object.Equals%2A> и <xref:System.IComparable.CompareTo%2A> методы `item` коллекции для определения того, существует ли элемент. В более ранних версиях .NET Framework это определение было выполнено с помощью <xref:System.Object.Equals%2A> методов `item` и <xref:System.IComparable.CompareTo%2A> параметра для объектов в коллекции.  
  
   
  
## Examples  
 В следующем примере кода показано, как определить индекс последнего вхождения указанного элемента. Обратите `LastIndexOf` внимание, что является обратным поиском, `count` поэтому он должен быть `startIndex` меньше или равен + 1.  
  
 [!code-cpp[Classic ArrayList.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> находится вне диапазона допустимых индексов для <see cref="T:System.Collections.ArrayList" />.  
  
-или- 
 Значение параметра <paramref name="count" /> меньше нуля.  
  
- или - 
 <paramref name="startIndex" /> и <paramref name="count" /> не указывают допустимый раздел в <see cref="T:System.Collections.ArrayList" />.</exception>
        <altmember cref="M:System.Collections.ArrayList.IndexOf(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Contains(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Выполнение в коллекциях строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadOnly">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает оболочку списка, доступную только для чтения.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public static System.Collections.ArrayList ReadOnly (System.Collections.ArrayList list);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ArrayList ReadOnly(class System.Collections.ArrayList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.ReadOnly(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadOnly (list As ArrayList) As ArrayList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ArrayList ^ ReadOnly(System::Collections::ArrayList ^ list);" />
      <MemberSignature Language="F#" Value="static member ReadOnly : System.Collections.ArrayList -&gt; System.Collections.ArrayList" Usage="System.Collections.ArrayList.ReadOnly list" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ArrayList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="list" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="list">Класс <see cref="T:System.Collections.ArrayList" />, для которого создается оболочка.</param>
        <summary>Возвращает программу-оболочку <see cref="T:System.Collections.ArrayList" />, доступную только для чтения.</summary>
        <returns>Доступная только для чтения программа-оболочка <see cref="T:System.Collections.ArrayList" /> для параметра <paramref name="list" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы предотвратить любые изменения `list`, предоставляйте `list` только через эту оболочку.  
  
 Коллекция, доступная только для чтения, — это просто коллекция с оболочкой, которая предотвращает изменение коллекции. Если в базовую коллекцию вносятся изменения, то эти изменения отражаются в коллекции только для чтения.  
  
 Этот метод является операцией O (1).  
  
   
  
## Examples  
 В следующем примере кода показано, как создать оболочку <xref:System.Collections.ArrayList> , <xref:System.Collections.ArrayList> доступную только для чтения, и определить, доступна ли она только для чтения.  
  
 [!code-cpp[Classic ArrayList.ReadOnly1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.ReadOnly1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.ReadOnly1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.ReadOnly1 Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.ReadOnly1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.ReadOnly1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="list" /> — <see langword="null" />.</exception>
        <altmember cref="P:System.Collections.ArrayList.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public static System.Collections.IList ReadOnly (System.Collections.IList list);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IList ReadOnly(class System.Collections.IList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.ReadOnly(System.Collections.IList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadOnly (list As IList) As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IList ^ ReadOnly(System::Collections::IList ^ list);" />
      <MemberSignature Language="F#" Value="static member ReadOnly : System.Collections.IList -&gt; System.Collections.IList" Usage="System.Collections.ArrayList.ReadOnly list" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="list" Type="System.Collections.IList" />
      </Parameters>
      <Docs>
        <param name="list">Класс <see cref="T:System.Collections.IList" />, для которого создается оболочка.</param>
        <summary>Возвращает программу-оболочку <see cref="T:System.Collections.IList" />, доступную только для чтения.</summary>
        <returns>Доступная только для чтения программа-оболочка <see cref="T:System.Collections.IList" /> для параметра <paramref name="list" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы предотвратить любые изменения `list`, предоставляйте `list` только через эту оболочку.  
  
 Коллекция, доступная только для чтения, — это просто коллекция с оболочкой, которая предотвращает изменение коллекции. Если в базовую коллекцию вносятся изменения, то эти изменения отражаются в коллекции только для чтения.  
  
 Этот метод является операцией O (1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="list" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="P:System.Collections.ArrayList.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public virtual void Remove (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Remove (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Remove(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Remove : obj -&gt; unit&#xA;override this.Remove : obj -&gt; unit" Usage="arrayList.Remove obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Элемент <see cref="T:System.Object" />, который требуется удалить из <see cref="T:System.Collections.ArrayList" />. Допускается значение <see langword="null" />.</param>
        <summary>Удаляет первое вхождение указанного объекта из коллекции <see cref="T:System.Collections.ArrayList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList> Если объект несодержитуказанногообъекта,объектостается<xref:System.Collections.ArrayList> неизменным. Исключение не возникает.  
  
 Этот метод выполняет линейный поиск. Таким образом, этот метод является операцией`n`O (), `n` где <xref:System.Collections.ArrayList.Count%2A>имеет.  
  
 Этот метод определяет равенство путем <xref:System.Object.Equals%2A?displayProperty=nameWithType>вызова.  
  
 В коллекциях с непрерывным набором элементов, таких как списки, элементы, следующие за удаленным элементом, перемещаются вверх, занимая освободившуюся позицию. Если коллекция индексируется, индексы перемещенных элементов также обновляются. Такое поведение не реализуется в коллекциях, в которых элементы логически сгруппированы, например в хэш-таблицах.  
  
   
  
## Examples  
 В следующем примере кода показано, как удалить элементы из <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.Remove Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Remove Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Remove Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Remove Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Remove Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Remove Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Объект <see cref="T:System.Collections.ArrayList" /> доступен только для чтения.  
  
- или - 
<see cref="T:System.Collections.ArrayList" /> имеет фиксированный размер.</exception>
        <altmember cref="M:System.Collections.ArrayList.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.Add(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Выполнение в коллекциях строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public virtual void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveAt(int index);" />
      <MemberSignature Language="F#" Value="abstract member RemoveAt : int -&gt; unit&#xA;override this.RemoveAt : int -&gt; unit" Usage="arrayList.RemoveAt index" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Индекс (с нуля) элемента, который требуется удалить.</param>
        <summary>Удаляет элемент по указанному индексу из коллекции <see cref="T:System.Collections.ArrayList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 После удаления элемента размер коллекции корректируется, а значение <xref:System.Collections.ArrayList.Count%2A> свойства уменьшается на единицу.  
  
 В коллекциях с непрерывным набором элементов, таких как списки, элементы, следующие за удаленным элементом, перемещаются вверх, занимая освободившуюся позицию. Если коллекция индексируется, индексы перемещенных элементов также обновляются. Такое поведение не реализуется в коллекциях, в которых элементы логически сгруппированы, например в хэш-таблицах.  
  
 Этот метод является операцией O`n`(), где `n` имеет <xref:System.Collections.ArrayList.Count%2A>.  
  
   
  
## Examples  
 В следующем примере кода показано, как удалить элементы из <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.Remove Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Remove Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Remove Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Remove Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Remove Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Remove Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> меньше нуля.  
  
-или- 
 Значение параметра <paramref name="index" /> больше или равно значению свойства <see cref="P:System.Collections.ArrayList.Count" />.</exception>
        <exception cref="T:System.NotSupportedException">Объект <see cref="T:System.Collections.ArrayList" /> доступен только для чтения.  
  
- или - 
<see cref="T:System.Collections.ArrayList" /> имеет фиксированный размер.</exception>
        <altmember cref="M:System.Collections.ArrayList.Remove(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.Add(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveRange">
      <MemberSignature Language="C#" Value="public virtual void RemoveRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveRange (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveRange(int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member RemoveRange : int * int -&gt; unit&#xA;override this.RemoveRange : int * int -&gt; unit" Usage="arrayList.RemoveRange (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Отсчитываемый от нуля индекс начала диапазона элементов, которые требуется удалить.</param>
        <param name="count">Число удаляемых элементов.</param>
        <summary>Удаляет диапазон элементов из списка <see cref="T:System.Collections.ArrayList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В коллекциях с непрерывным набором элементов, таких как списки, элементы, следующие за удаленным элементом, перемещаются вверх, занимая освободившуюся позицию. Если коллекция индексируется, индексы перемещенных элементов также обновляются. Такое поведение не реализуется в коллекциях, в которых элементы логически сгруппированы, например в хэш-таблицах.  
  
 Этот метод является операцией O`n`(), где `n` имеет <xref:System.Collections.ArrayList.Count%2A>.  
  
   
  
## Examples  
 В следующем примере кода показано, как удалить элементы из <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.Remove Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Remove Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Remove Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Remove Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Remove Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Remove Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> меньше нуля.  
  
- или - 
 Значение параметра <paramref name="count" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException">Параметры<paramref name="index" /> и <paramref name="count" /> не указывают допустимый диапазон элементов в списке <see cref="T:System.Collections.ArrayList" />.</exception>
        <exception cref="T:System.NotSupportedException">Объект <see cref="T:System.Collections.ArrayList" /> доступен только для чтения.  
  
- или - 
<see cref="T:System.Collections.ArrayList" /> имеет фиксированный размер.</exception>
        <altmember cref="M:System.Collections.ArrayList.Remove(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)" />
      </Docs>
    </Member>
    <Member MemberName="Repeat">
      <MemberSignature Language="C#" Value="public static System.Collections.ArrayList Repeat (object value, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ArrayList Repeat(object value, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Repeat(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Repeat (value As Object, count As Integer) As ArrayList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ArrayList ^ Repeat(System::Object ^ value, int count);" />
      <MemberSignature Language="F#" Value="static member Repeat : obj * int -&gt; System.Collections.ArrayList" Usage="System.Collections.ArrayList.Repeat (value, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ArrayList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Объект <see cref="T:System.Object" />, который требуется скопировать несколько раз в новый список <see cref="T:System.Collections.ArrayList" />. Допускается значение <see langword="null" />.</param>
        <param name="count">Количество копий значения <paramref name="value" />.</param>
        <summary>Возвращает список <see cref="T:System.Collections.ArrayList" />, элементы которого являются копиями указанного значения.</summary>
        <returns>Список <see cref="T:System.Collections.ArrayList" /> с количеством элементов, равным <paramref name="count" />, которые являются копиями объекта <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList>принимает `null` как допустимое значение и позволяет дублировать элементы.  
  
 Этот метод является операцией O`n`(), где `n` имеет `count`.  
  
   
  
## Examples  
 В следующем примере кода показано, как создать и инициализировать новый <xref:System.Collections.ArrayList> объект с тем же значением.  
  
 [!code-cpp[Classic ArrayList.Repeat Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Repeat Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Repeat Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Repeat Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Repeat Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Repeat Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="count" /> меньше нуля.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Изменяет порядок элементов в списке <see cref="T:System.Collections.ArrayList" /> или в его части на обратный.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public virtual void Reverse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reverse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Reverse" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reverse ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reverse();" />
      <MemberSignature Language="F#" Value="abstract member Reverse : unit -&gt; unit&#xA;override this.Reverse : unit -&gt; unit" Usage="arrayList.Reverse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Изменяет порядок элементов во всем списке <see cref="T:System.Collections.ArrayList" /> на обратный.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует <xref:System.Array.Reverse%2A?displayProperty=nameWithType> для изменения порядка элементов, так что элемент в <xref:System.Collections.ArrayList> [i], где i является любым индексом в диапазоне, перемещается в <xref:System.Collections.ArrayList> [j], где j равно `index`  +  `index`  + -i-1. `count`  
  
 Этот метод является операцией O`n`(), где `n` имеет <xref:System.Collections.ArrayList.Count%2A>.  
  
   
  
## Examples  
 В следующем примере кода показано, как изменить порядок сортировки значений в <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.Reverse Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Reverse Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Reverse Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Reverse Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Reverse Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Reverse Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Объект <see cref="T:System.Collections.ArrayList" /> доступен только для чтения.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public virtual void Reverse (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reverse(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Reverse(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reverse (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reverse(int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member Reverse : int * int -&gt; unit&#xA;override this.Reverse : int * int -&gt; unit" Usage="arrayList.Reverse (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Отсчитываемый от нуля индекс начала диапазона, порядок элементов которого требуется изменить.</param>
        <param name="count">Число элементов в диапазоне, порядок сортировки в котором требуется изменить.</param>
        <summary>Изменяет порядок элементов в указанном диапазоне.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует <xref:System.Array.Reverse%2A?displayProperty=nameWithType> для изменения порядка элементов, так что элемент в <xref:System.Collections.ArrayList> [i], где i является любым индексом в диапазоне, перемещается в <xref:System.Collections.ArrayList> [j], где j равно `index`  +  `index`  + -i-1. `count`  
  
 Этот метод является операцией O`n`(), где `n` имеет `count`.  
  
   
  
## Examples  
 В следующем примере кода показано, как изменить порядок сортировки значений в диапазоне элементов в <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.Reverse1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Reverse1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Reverse1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Reverse1 Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Reverse1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Reverse1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> меньше нуля.  
  
- или - 
 Значение параметра <paramref name="count" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException">Параметры<paramref name="index" /> и <paramref name="count" /> не указывают допустимый диапазон элементов в списке <see cref="T:System.Collections.ArrayList" />.</exception>
        <exception cref="T:System.NotSupportedException">Объект <see cref="T:System.Collections.ArrayList" /> доступен только для чтения.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetRange">
      <MemberSignature Language="C#" Value="public virtual void SetRange (int index, System.Collections.ICollection c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetRange(int32 index, class System.Collections.ICollection c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetRange (index As Integer, c As ICollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetRange(int index, System::Collections::ICollection ^ c);" />
      <MemberSignature Language="F#" Value="abstract member SetRange : int * System.Collections.ICollection -&gt; unit&#xA;override this.SetRange : int * System.Collections.ICollection -&gt; unit" Usage="arrayList.SetRange (index, c)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="c" Type="System.Collections.ICollection" />
      </Parameters>
      <Docs>
        <param name="index">Отсчитываемый от нуля индекс списка <see cref="T:System.Collections.ArrayList" />, с которого начинается копирование элементов коллекции <paramref name="c" />.</param>
        <param name="c">Интерфейс <see cref="T:System.Collections.ICollection" />, элементы которого копируются в список <see cref="T:System.Collections.ArrayList" />. Сама коллекция не может иметь значение <see langword="null" />, но может содержать элементы со значением <see langword="null" />.</param>
        <summary>Копирует элементы коллекции в диапазон элементов списка <see cref="T:System.Collections.ArrayList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList>принимает `null` как допустимое значение и позволяет дублировать элементы.  
  
 Порядок элементов в <xref:System.Collections.ICollection> сохраняется <xref:System.Collections.ArrayList>в.  
  
 Этот метод является операцией O`n` (+ 1), где `n` — <xref:System.Collections.ArrayList.Count%2A>.  
  
   
  
## Examples  
 В следующем примере кода показано, как задать и получить диапазон элементов в <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.SetRange Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.SetRange Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.SetRange Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.SetRange Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.SetRange Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.SetRange Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> меньше нуля.  
  
- или - 
 <paramref name="index" /> плюс количество элементов в <paramref name="c" /> больше, чем <see cref="P:System.Collections.ArrayList.Count" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="c" /> — <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Объект <see cref="T:System.Collections.ArrayList" /> доступен только для чтения.</exception>
        <altmember cref="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Сортирует элементы в списке <see cref="T:System.Collections.ArrayList" /> или в его части.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public virtual void Sort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Sort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Sort" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Sort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Sort();" />
      <MemberSignature Language="F#" Value="abstract member Sort : unit -&gt; unit&#xA;override this.Sort : unit -&gt; unit" Usage="arrayList.Sort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Сортирует элементы во всем списке <see cref="T:System.Collections.ArrayList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует <xref:System.Array.Sort%2A?displayProperty=nameWithType>, который использует алгоритм QuickSort. Алгоритм QuickSort — это сравнительная Сортировка (также называемая нестабильной сортировкой), которая означает, что из двух элементов, которые должны выполняться первыми в итоговом отсортированном списке, определяется операция сравнения "меньше или равно". Однако если два элемента равны, их исходный порядок может не сохраняться. В отличие от этого, стабильная сортировка сохраняет порядок элементов, равных. Чтобы выполнить стабильную сортировку, необходимо реализовать пользовательский <xref:System.Collections.IComparer> интерфейс для использования с другими перегрузками этого метода.  
  
 В среднем этот метод является операцией o (`n` log `n`), где `n` имеет <xref:System.Collections.ArrayList.Count%2A>значение; в худшем случае это операция o (`n`^ 2).  
  
   
  
## Examples  
 В следующем примере кода показано, как сортировать значения в <xref:System.Collections.ArrayList>.  
  
 [!code-cpp[Classic ArrayList.Sort Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Sort Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Sort Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Sort Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Sort Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Sort Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Объект <see cref="T:System.Collections.ArrayList" /> доступен только для чтения.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Выполнение в коллекциях строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public virtual void Sort (System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Sort(class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Sort (comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Sort(System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="abstract member Sort : System.Collections.IComparer -&gt; unit&#xA;override this.Sort : System.Collections.IComparer -&gt; unit" Usage="arrayList.Sort comparer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="comparer">Реализация интерфейса <see cref="T:System.Collections.IComparer" />, которая используется при сравнении элементов.  
  
- или - 
Пустая ссылка (<see langword="Nothing" /> в Visual Basic) для использования реализации <see cref="T:System.IComparable" /> каждого элемента.</param>
        <summary>Сортирует элементы во всем списке <see cref="T:System.Collections.ArrayList" /> с помощью указанной функции сравнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте метод для сортировки списка объектов с помощью пользовательского компаратора, <xref:System.Collections.IComparer> реализующего интерфейс. <xref:System.Collections.ArrayList.Sort%2A> При передаче `null` `comparer`в этот метод использует <xref:System.IComparable> реализацию каждого элемента. В этом случае необходимо убедиться, что объекты, содержащиеся в списке, реализуют интерфейс <xref:System.Collections.IComparer> , или возникнет исключение.  
  
 Кроме того <xref:System.IComparable> , использование реализации означает, что список выполняет сортировку по сравнению (также называемую нестабильной сортировкой); то есть если два элемента равны, их порядок может не сохраняться. В отличие от этого, стабильная сортировка сохраняет порядок элементов, равных. Чтобы выполнить стабильную сортировку, необходимо реализовать пользовательский <xref:System.Collections.IComparer> интерфейс.  
  
 В среднем этот метод является операцией o (`n` log `n`), где `n` имеет <xref:System.Collections.ArrayList.Count%2A>значение; в худшем случае это операция o (`n`^ 2).  
  
   
  
## Examples  
 В следующем примере кода показано, как сортировать значения в <xref:System.Collections.ArrayList> с помощью компаратора по умолчанию и пользовательского компаратора, который изменяет порядок сортировки на обратный.  
  
 [!code-cpp[System.Collections.ArrayList.Sort_2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.ArrayList.Sort_2/CPP/arraylist_sort2.cpp#1)]
 [!code-csharp[System.Collections.ArrayList.Sort_2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.ArrayList.Sort_2/CS/arraylist_sort2.cs#1)]
 [!code-vb[System.Collections.ArrayList.Sort_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.ArrayList.Sort_2/VB/arraylist_sort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Объект <see cref="T:System.Collections.ArrayList" /> доступен только для чтения.</exception>
        <exception cref="T:System.InvalidOperationException">При сравнении двух элементов возникла ошибка.</exception>
        <exception cref="T:System.ArgumentException"><see langword="null" /> передается для <paramref name="comparer" />, а элементы в списке не реализуют <see cref="T:System.IComparable" />.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Выполнение в коллекциях строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public virtual void Sort (int index, int count, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Sort(int32 index, int32 count, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Sort (index As Integer, count As Integer, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Sort(int index, int count, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="abstract member Sort : int * int * System.Collections.IComparer -&gt; unit&#xA;override this.Sort : int * int * System.Collections.IComparer -&gt; unit" Usage="arrayList.Sort (index, count, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="index">Индекс (с нуля) начала диапазона, который требуется отсортировать.</param>
        <param name="count">Длина диапазона сортировки.</param>
        <param name="comparer">Реализация интерфейса <see cref="T:System.Collections.IComparer" />, которая используется при сравнении элементов.  
  
- или - 
Пустая ссылка (<see langword="Nothing" /> в Visual Basic) для использования реализации <see cref="T:System.IComparable" /> каждого элемента.</param>
        <summary>Сортирует элементы в диапазоне элементов списка <see cref="T:System.Collections.ArrayList" /> с помощью указанной функции сравнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `comparer` для задано `null`значение, этот метод выполняет сортировку по сравнению (также называемую нестабильной сортировкой); то есть если два элемента равны, их порядок может не сохраняться. В отличие от этого, стабильная сортировка сохраняет порядок элементов, равных. Чтобы выполнить стабильную сортировку, необходимо реализовать пользовательский <xref:System.Collections.IComparer> интерфейс.  
  
 В среднем этот метод является операцией o (`n` log `n`), где `n` имеет `count`значение; в худшем случае это операция o (n ^ 2).  
  
   
  
## Examples  
 В следующем примере кода показано, как сортировать значения в диапазоне элементов <xref:System.Collections.ArrayList> с помощью компаратора по умолчанию и пользовательского компаратора, который изменяет порядок сортировки на обратный.  
  
 [!code-cpp[System.Collections.ArrayList.Sort_3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.ArrayList.Sort_3/CPP/arraylist_sort3.cpp#1)]
 [!code-csharp[System.Collections.ArrayList.Sort_3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.ArrayList.Sort_3/CS/arraylist_sort3.cs#1)]
 [!code-vb[System.Collections.ArrayList.Sort_3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.ArrayList.Sort_3/VB/arraylist_sort3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> меньше нуля.  
  
-или- 
 Значение параметра <paramref name="count" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> и <paramref name="count" /> не указывают допустимый диапазон в <see cref="T:System.Collections.ArrayList" />.</exception>
        <exception cref="T:System.NotSupportedException">Объект <see cref="T:System.Collections.ArrayList" /> доступен только для чтения.</exception>
        <exception cref="T:System.InvalidOperationException">При сравнении двух элементов возникла ошибка.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Выполнение в коллекциях строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Synchronized">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает синхронизированную (потокобезопасную) оболочку списка.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Synchronized">
      <MemberSignature Language="C#" Value="public static System.Collections.ArrayList Synchronized (System.Collections.ArrayList list);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ArrayList Synchronized(class System.Collections.ArrayList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Synchronized(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Synchronized (list As ArrayList) As ArrayList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ArrayList ^ Synchronized(System::Collections::ArrayList ^ list);" />
      <MemberSignature Language="F#" Value="static member Synchronized : System.Collections.ArrayList -&gt; System.Collections.ArrayList" Usage="System.Collections.ArrayList.Synchronized list" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ArrayList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="list" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="list">Коллекция <see cref="T:System.Collections.ArrayList" />, которую требуется синхронизировать.</param>
        <summary>Возвращает синхронизированную (потокобезопасную) оболочку <see cref="T:System.Collections.ArrayList" />.</summary>
        <returns>Синхронизированная (потокобезопасная) оболочка <see cref="T:System.Collections.ArrayList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы обеспечить потокобезопасность <xref:System.Collections.ArrayList>, все операции должны выполняться через эту оболочку.  
  
 Перечисление коллекции не является потокобезопасной процедурой. Даже если коллекция синхронизирована, другие потоки могут ее изменить, что приведет к тому, что перечислитель создаст исключение. Для обеспечения потокобезопасности при перечислении можно либо заблокировать коллекцию на все время перечисления, либо перехватывать исключения, возникающие в результате изменений, внесенных другими потоками.  
  
   
  
## Examples  
 В следующем примере кода показано, <xref:System.Collections.ArrayList.SyncRoot%2A> как заблокировать коллекцию с помощью во время всего перечисления.  
  
 [!code-cpp[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/VB/source2.vb#2)]  
  
 Этот метод является операцией O (1).  
  
 В следующем примере кода показано <xref:System.Collections.ArrayList>, как синхронизировать, определить, синхронизировано <xref:System.Collections.ArrayList> ли и использовать синхронизированное. <xref:System.Collections.ArrayList>  
  
 [!code-cpp[Classic ArrayList.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="list" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="P:System.Collections.ArrayList.SyncRoot" />
        <altmember cref="P:System.Collections.ArrayList.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="Synchronized">
      <MemberSignature Language="C#" Value="public static System.Collections.IList Synchronized (System.Collections.IList list);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IList Synchronized(class System.Collections.IList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Synchronized (list As IList) As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IList ^ Synchronized(System::Collections::IList ^ list);" />
      <MemberSignature Language="F#" Value="static member Synchronized : System.Collections.IList -&gt; System.Collections.IList" Usage="System.Collections.ArrayList.Synchronized list" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="list" Type="System.Collections.IList" />
      </Parameters>
      <Docs>
        <param name="list">Коллекция <see cref="T:System.Collections.IList" />, которую требуется синхронизировать.</param>
        <summary>Возвращает синхронизированную (потокобезопасную) оболочку <see cref="T:System.Collections.IList" />.</summary>
        <returns>Синхронизированная (потокобезопасная) оболочка <see cref="T:System.Collections.IList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы обеспечить потокобезопасность <xref:System.Collections.ArrayList>, все операции должны выполняться через эту оболочку.  
  
 Перечисление коллекции не является потокобезопасной процедурой. Даже если коллекция синхронизирована, другие потоки могут ее изменить, что приведет к тому, что перечислитель создаст исключение. Для обеспечения потокобезопасности при перечислении можно либо заблокировать коллекцию на все время перечисления, либо перехватывать исключения, возникающие в результате изменений, внесенных другими потоками.  
  
   
  
## Examples  
 В следующем примере кода показано, <xref:System.Collections.ArrayList.SyncRoot%2A> как заблокировать коллекцию с помощью во время всего перечисления.  
  
 [!code-cpp[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/VB/source2.vb#2)]  
  
 Этот метод является операцией O (1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="list" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="P:System.Collections.ArrayList.SyncRoot" />
        <altmember cref="P:System.Collections.ArrayList.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public virtual object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ArrayList.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Collections.ArrayList.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект, с помощью которого можно синхронизировать доступ к коллекции <see cref="T:System.Collections.ArrayList" />.</summary>
        <value>Объект, который может использоваться для синхронизации доступа к <see cref="T:System.Collections.ArrayList" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы создать синхронизированную версию <xref:System.Collections.ArrayList>, <xref:System.Collections.ArrayList.Synchronized%2A> используйте метод. Однако производные классы могут предоставлять собственную синхронизированную версию <xref:System.Collections.ArrayList> <xref:System.Collections.ArrayList.SyncRoot%2A> с помощью свойства. Синхронизирующий код должен выполнять операции <xref:System.Collections.ArrayList.SyncRoot%2A> <xref:System.Collections.ArrayList>в <xref:System.Collections.ArrayList>, а не непосредственно на. Это обеспечивает правильную работу коллекций, являющихся производными других объектов. В частности, он поддерживает правильную синхронизацию с другими потоками, которые <xref:System.Collections.ArrayList> могут одновременно изменять объект.  
  
 Перечисление коллекции не является потокобезопасной процедурой. Даже если коллекция синхронизирована, другие потоки могут ее изменить, что приведет к тому, что перечислитель создаст исключение. Для обеспечения потокобезопасности при перечислении можно либо заблокировать коллекцию на все время перечисления, либо перехватывать исключения, возникающие в результате изменений, внесенных другими потоками.  
  
   
  
## Examples  
 В следующем примере кода показано, <xref:System.Collections.ArrayList.SyncRoot%2A> как заблокировать коллекцию с помощью во время всего перечисления.  
  
 [!code-cpp[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/VB/source2.vb#2)]  
  
 Получение значения данного свойства является операцией порядка сложности O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ArrayList.IsSynchronized" />
        <altmember cref="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToArray">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Копирует элементы списка <see cref="T:System.Collections.ArrayList" /> в новый массив.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public virtual object[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToArray () As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="abstract member ToArray : unit -&gt; obj[]&#xA;override this.ToArray : unit -&gt; obj[]" Usage="arrayList.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Копирует элементы списка <see cref="T:System.Collections.ArrayList" /> в новый массив <see cref="T:System.Object" />.</summary>
        <returns>Массив <see cref="T:System.Object" />, содержащий копии элементов списка <see cref="T:System.Collections.ArrayList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элементы копируются с помощью <xref:System.Array.Copy%2A?displayProperty=nameWithType>, что является операцией O`n`(), где `n` имеет <xref:System.Collections.ArrayList.Count%2A>значение.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public virtual Array ToArray (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Array ToArray(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.ToArray(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Array ^ ToArray(Type ^ type);" />
      <MemberSignature Language="F#" Value="abstract member ToArray : Type -&gt; Array&#xA;override this.ToArray : Type -&gt; Array" Usage="arrayList.ToArray type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Элемент <see cref="T:System.Type" /> массива назначения, используемый для создания и копирования элементов в этот массив.</param>
        <summary>Копирует элементы списка <see cref="T:System.Collections.ArrayList" /> в новый массив с элементами указанного типа.</summary>
        <returns>Массив элементов указанного типа, содержащий копии элементов массива <see cref="T:System.Collections.ArrayList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Все объекты в <xref:System.Collections.ArrayList> объекте будут приведены к типу, <xref:System.Type> указанному в `type` параметре.  
  
 Элементы копируются с помощью <xref:System.Array.Copy%2A?displayProperty=nameWithType>, что является операцией O`n`(), где `n` имеет <xref:System.Collections.ArrayList.Count%2A>значение.  
  
   
  
## Examples  
 В следующем примере копирования показано, как скопировать элементы <xref:System.Collections.ArrayList> массива в массив строк.  
  
 [!code-cpp[System.Collections.ArrayList.ToArray#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.ArrayList.ToArray/CPP/arraylist_toarray.cpp#1)]
 [!code-csharp[System.Collections.ArrayList.ToArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.ArrayList.ToArray/CS/arraylist_toarray.cs#1)]
 [!code-vb[System.Collections.ArrayList.ToArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.ArrayList.ToArray/VB/arraylist_toarray.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> — <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">Тип исходного списка <see cref="T:System.Collections.ArrayList" /> не может быть автоматически приведен к указанному типу.</exception>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="TrimToSize">
      <MemberSignature Language="C#" Value="public virtual void TrimToSize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void TrimToSize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.TrimToSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub TrimToSize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void TrimToSize();" />
      <MemberSignature Language="F#" Value="abstract member TrimToSize : unit -&gt; unit&#xA;override this.TrimToSize : unit -&gt; unit" Usage="arrayList.TrimToSize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Задает значение емкости, равное действительному количеству элементов в <see cref="T:System.Collections.ArrayList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно использовать для снижения нагрузки на память коллекции, если в коллекцию не добавляются новые элементы.  
  
 Чтобы восстановить <xref:System.Collections.ArrayList> исходное состояние, <xref:System.Collections.ArrayList.Clear%2A> вызовите метод перед вызовом <xref:System.Collections.ArrayList.TrimToSize%2A>метода. Удаление пустой <xref:System.Collections.ArrayList> задает емкость объекта <xref:System.Collections.ArrayList> емкость по умолчанию.  
  
 Этот метод является операцией O`n`(), где `n` имеет <xref:System.Collections.ArrayList.Count%2A>.  
  
   
  
## Examples  
 В следующем примере кода показано, как обрезать неиспользуемые части <xref:System.Collections.ArrayList> объекта и как очистить значения. <xref:System.Collections.ArrayList>  
  
 [!code-cpp[Classic ArrayList.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Объект <see cref="T:System.Collections.ArrayList" /> доступен только для чтения.  
  
- или - 
<see cref="T:System.Collections.ArrayList" /> имеет фиксированный размер.</exception>
        <altmember cref="M:System.Collections.ArrayList.Clear" />
        <altmember cref="P:System.Collections.ArrayList.Capacity" />
        <altmember cref="P:System.Collections.ArrayList.Count" />
      </Docs>
    </Member>
  </Members>
</Type>
