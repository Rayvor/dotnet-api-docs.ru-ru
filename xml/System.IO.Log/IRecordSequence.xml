<Type Name="IRecordSequence" FullName="System.IO.Log.IRecordSequence">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6a2bacddb80f2006249ed7194edf1d3865804236" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69356866" /></Metadata><TypeSignature Language="C#" Value="public interface IRecordSequence : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IRecordSequence implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.IRecordSequence" />
  <TypeSignature Language="VB.NET" Value="Public Interface IRecordSequence&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public interface class IRecordSequence : IDisposable" />
  <TypeSignature Language="F#" Value="type IRecordSequence = interface&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Предоставляет универсальный интерфейс последовательности записей.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Интерфейс <xref:System.IO.Log.IRecordSequence> предоставляет абстрактный интерфейс потоку, ориентированному на записи. Экземпляр <xref:System.IO.Log.IRecordSequence> можно использовать для чтения и записи записей журнала.  
  
 Интерфейс <xref:System.IO.Log.IRecordSequence> предоставляет следующие возможности.  
  
-   Добавление записей журнала с помощью методов <xref:System.IO.Log.IRecordSequence.Append%2A>.  
  
-   Считывание добавленных записей с помощью метода <xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A>.  
  
-   Регистрация специальной записи перезапуска с помощью метода <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A>.  
  
-   Считывание записей из последней перезаписанной записи перезапуска с помощью <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.  
  
-   Очистка записей для устойчивого хранения с помощью метода <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
-   Резервирование пространства для добавления записей.  
  
-   Освобождение пространства журнала с помощью перемещения базы журнала.  
  
-   Получение уведомлений о событиях <xref:System.IO.Log.IRecordSequence.TailPinned> для перемещения базы журнала на свободное пространство.  
  
 Записи журнала добавляются в экземпляр <xref:System.IO.Log.IRecordSequence>, и каждой записи присваивается уникальный порядковый номер. Порядковые номера увеличиваются строго монотонно в рамках определенной последовательности записей. Запись журнала состоит из непрозрачных данных, предоставляемых экземпляру <xref:System.IO.Log.IRecordSequence> в списке <xref:System.Collections.IList> фрагментов массива байтов.  
  
 Интерфейс <xref:System.IO.Log.IRecordSequence> также предоставляет несколько базовых свойств, содержащих сведения о границах журнала.  
  
-   Свойство <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> содержит порядковый номер первой допустимой записи в последовательности записей.  
  
-   Свойство <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A> содержит порядковый номер, который гарантированно больше, чем порядковый номер последней добавленной записи.  
  
-   Свойство <xref:System.IO.Log.IRecordSequence.RestartSequenceNumber%2A> содержит порядковый номер последней записанной области перезапуска.  
  
-   Свойство <xref:System.IO.Log.IRecordSequence.MaximumRecordLength%2A> содержит размер в байтах наибольшей записи, которую можно добавить или прочитать из последовательности.  
  
-   Свойство <xref:System.IO.Log.IRecordSequence.ReservedBytes%2A> содержит общий размер резервирований, созданных в последовательности записей.  
  
-   Если свойство <xref:System.IO.Log.IRecordSequence.RetryAppend%2A> имеет значение `true` и операция <xref:System.IO.Log.IRecordSequence.Append%2A> завершается неудачно из-за отсутствия места в последовательности, последовательность записей пытается освободить место и повторно выполнить операцию добавления.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AdvanceBaseSequenceNumber">
      <MemberSignature Language="C#" Value="public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AdvanceBaseSequenceNumber(valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AdvanceBaseSequenceNumber (newBaseSequenceNumber As SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AdvanceBaseSequenceNumber(System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member AdvanceBaseSequenceNumber : System.IO.Log.SequenceNumber -&gt; unit" Usage="iRecordSequence.AdvanceBaseSequenceNumber newBaseSequenceNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="newBaseSequenceNumber">Новый базовый порядковый номер последовательности журналов.</param>
        <summary>Выполняет переход базового порядкового номера журнала.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании экземпляра <xref:System.IO.Log.LogRecordSequence> и попытке переместить порядковый номер для освобождения пространства в журнале новый базовый порядковый номер должен находиться в другой области журнала, чтобы предыдущая область была помечена как пустая. Частичное освобождение областей не поддерживается.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="newBaseSequenceNumber" /> недопустим.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="newBaseSequenceNumber" /> не активен в журнале.</exception>
        <exception cref="T:System.IO.IOException">При изменении последовательности произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательность записей заполнена.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>При переопределении в производном классе записывает запись журнала в последовательность <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="F#" Value="abstract member Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="nextUndoRecord">Порядковый номер следующей записи в порядке, заданном пользователем.</param>
        <param name="previousRecord">Порядковый номер следующей записи в обратном порядке.</param>
        <param name="recordAppendOptions">Допустимое значение объекта <see cref="T:System.IO.Log.RecordAppendOptions" />, задающего, как должны записываться данные.</param>
        <summary>При переопределении в производном классе записывает запись журнала в последовательность <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <returns>Порядковый номер добавленной в журнал записи.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данные, содержащиеся в параметре `data`, будут сцеплены в единый массив байтов для добавления в качестве записи. Однако не делается допущение об обратном разделении данных на фрагменты массива при чтении записи.  
  
 Обычно этот метод завершает работу до того, как запись будет записана. Чтобы запись точно была записана, либо укажите флаг <xref:System.IO.Log.RecordAppendOptions.ForceFlush> с помощью параметра `recordAppendOptions`, либо вызовите метод <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Один или несколько аргументов являются недопустимыми.</exception>
        <exception cref="T:System.IO.IOException">При добавлении записи произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательности записей не удалось выделить достаточно свободного пространства для новой записи.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="F#" Value="abstract member Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="nextUndoRecord">Порядковый номер следующей записи в порядке, заданном пользователем.</param>
        <param name="previousRecord">Порядковый номер следующей записи в обратном порядке.</param>
        <param name="recordAppendOptions">Допустимое значение объекта <see cref="T:System.IO.Log.RecordAppendOptions" />, задающего, как должны записываться данные.</param>
        <summary>При переопределении в производном классе добавляет запись журнала в последовательность <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <returns>Порядковый номер добавленной в журнал записи.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данные, содержащиеся в параметре `data`, будут сцеплены в единый массив байтов для добавления в качестве записи. Однако не делается допущение об обратном разделении данных на фрагменты массива при чтении записи.  
  
 Обычно этот метод завершает работу до того, как запись будет записана. Чтобы запись точно была записана, либо укажите флаг <xref:System.IO.Log.RecordAppendOptions.ForceFlush> с помощью параметра `recordAppendOptions`, либо вызовите метод <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Один или несколько аргументов являются недопустимыми.</exception>
        <exception cref="T:System.IO.IOException">При добавлении записи произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательности записей не удалось выделить достаточно свободного пространства для новой записи.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="nextUndoRecord">Порядковый номер следующей записи в порядке, заданном пользователем.</param>
        <param name="previousRecord">Порядковый номер следующей записи в обратном порядке.</param>
        <param name="recordAppendOptions">Допустимое значение объекта <see cref="T:System.IO.Log.RecordAppendOptions" />, задающего, как должны записываться данные.</param>
        <param name="reservations">Коллекция <see cref="T:System.IO.Log.ReservationCollection" />, содержащая резервирование, которое следует использовать для данной записи.</param>
        <summary>При переопределении в производном классе добавляет запись журнала в <see cref="T:System.IO.Log.IRecordSequence" />, используя пространство, которое было ранее зарезервировано в последовательности.</summary>
        <returns>Порядковый номер добавленной в журнал записи.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данные, содержащиеся в параметре `data`, будут сцеплены в единый массив байтов для добавления в качестве записи. Однако не делается допущение об обратном разделении данных на фрагменты массива при чтении записи.  
  
 Добавленная запись будет занимать пространство, ранее зарезервированное с помощью резервирования, заданного параметром `reservations`. Если выполнить добавление удается, оно займет минимальную область резервирования, в которой поместятся данные, а эта область резервирования будет удалена из коллекции.  
  
 Обычно этот метод завершает работу до того, как запись будет записана. Чтобы запись точно была записана, либо укажите флаг <xref:System.IO.Log.RecordAppendOptions.ForceFlush> с помощью параметра `recordAppendOptions`, либо вызовите метод <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Один или несколько аргументов являются недопустимыми.</exception>
        <exception cref="T:System.IO.IOException">При добавлении записи произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательности записей не удалось выделить достаточно свободного пространства для новой записи.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="nextUndoRecord">Порядковый номер следующей записи в порядке, заданном пользователем.</param>
        <param name="previousRecord">Порядковый номер следующей записи в обратном порядке.</param>
        <param name="recordAppendOptions">Допустимое значение объекта <see cref="T:System.IO.Log.RecordAppendOptions" />, задающего, как должны записываться данные.</param>
        <param name="reservations">Коллекция <see cref="T:System.IO.Log.ReservationCollection" />, содержащая резервирование, которое следует использовать для данной записи.</param>
        <summary>При переопределении в производном классе добавляет запись журнала в <see cref="T:System.IO.Log.IRecordSequence" />, используя пространство, которое было ранее зарезервировано в последовательности.</summary>
        <returns>Порядковый номер добавленной в журнал записи.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данные, содержащиеся в параметре `data`, будут сцеплены в единый массив байтов для добавления в качестве записи. Однако не делается допущение об обратном разделении данных на фрагменты массива при чтении записи.  
  
 Добавленная запись будет занимать пространство, ранее зарезервированное с помощью резервирования, заданного параметром `reservations`. Если выполнить добавление удается, оно займет минимальную область резервирования, в которой поместятся данные, а эта область резервирования будет удалена из коллекции.  
  
 Обычно этот метод завершает работу до того, как запись будет записана. Чтобы запись точно была записана, либо укажите флаг <xref:System.IO.Log.RecordAppendOptions.ForceFlush> с помощью параметра `recordAppendOptions`, либо вызовите метод <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Один или несколько аргументов являются недопустимыми.</exception>
        <exception cref="T:System.IO.IOException">При добавлении записи произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательности записей не удалось выделить достаточно свободного пространства для новой записи.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.BaseSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber BaseSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.IRecordSequence.BaseSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе возвращает порядковый номер первой допустимой записи в текущей последовательности <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <value>Самый низкий порядковый номер, соответствующий допустимой записи в последовательности <see cref="T:System.IO.Log.IRecordSequence" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Допустимые порядковые номера больше или равны <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> и меньше <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>.  
  
 Значение этого свойства можно изменить вызовом метода<xref:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber%2A> или <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Обращение к свойству произошло после удаления последовательности.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>При переопределении в производном классе начинает асинхронную операцию добавления.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="nextUndoRecord">Порядковый номер следующей записи в порядке, заданном пользователем.</param>
        <param name="previousRecord">Порядковый номер следующей записи в обратном порядке.</param>
        <param name="recordAppendOptions">Допустимое значение объекта <see cref="T:System.IO.Log.RecordAppendOptions" />, задающего, как должны записываться данные.</param>
        <param name="callback">Необязательный асинхронный обратный вызов по завершении добавления.</param>
        <param name="state">Предоставляемый пользователем объект, отличающий конкретный запрос на асинхронное добавление от других запросов.</param>
        <summary>При переопределении в производном классе начинает асинхронную операцию добавления.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, представляющий асинхронное добавление, которое может все еще ожидать выполнения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы обеспечить завершение операции добавления и освободить соответствующие ресурсы, необходимо передать значение <xref:System.IAsyncResult>, возвращенное этим методом, в метод <xref:System.IO.Log.IRecordSequence.EndAppend%2A>. Если ошибка возникла при выполнении асинхронного добавления, исключение не будет создано до тех пор, пока метод <xref:System.IO.Log.IRecordSequence.EndAppend%2A> не будет вызван со значением <xref:System.IAsyncResult>, возвращенным данным методом.  
  
 Данные, содержащиеся в параметре `data`, будут сцеплены в единый массив байтов для добавления в качестве записи. Однако не делается допущение об обратном разделении данных на фрагменты массива при чтении записи.  
  
 Обычно этот метод завершает работу до того, как запись будет записана. Чтобы запись точно была записана, либо укажите флаг <xref:System.IO.Log.RecordAppendOptions.ForceFlush> с помощью параметра `recordAppendOptions`, либо вызовите метод <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Один или несколько аргументов являются недопустимыми.</exception>
        <exception cref="T:System.IO.IOException">При добавлении записи произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательности записей не удалось выделить достаточно свободного пространства для новой записи.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="nextUndoRecord">Порядковый номер следующей записи в порядке, заданном пользователем.</param>
        <param name="previousRecord">Порядковый номер следующей записи в обратном порядке.</param>
        <param name="recordAppendOptions">Допустимое значение объекта <see cref="T:System.IO.Log.RecordAppendOptions" />, задающего, как должны записываться данные.</param>
        <param name="callback">Необязательный асинхронный обратный вызов по завершении добавления.</param>
        <param name="state">Предоставляемый пользователем объект, отличающий конкретный запрос на асинхронное добавление от других запросов.</param>
        <summary>При переопределении в производном классе начинает асинхронную операцию добавления, используя пространство, которое было ранее зарезервировано в последовательности.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, представляющий асинхронное добавление, которое может все еще ожидать выполнения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы обеспечить завершение операции добавления и освободить соответствующие ресурсы, необходимо передать значение <xref:System.IAsyncResult>, возвращенное этим методом, в метод <xref:System.IO.Log.IRecordSequence.EndAppend%2A>. Если ошибка возникла при выполнении асинхронного добавления, исключение не будет создано до тех пор, пока метод <xref:System.IO.Log.IRecordSequence.EndAppend%2A> не будет вызван со значением <xref:System.IAsyncResult>, возвращенным данным методом.  
  
 Данные, содержащиеся в параметре `data`, будут сцеплены в единый массив байтов для добавления в качестве записи. Однако не делается допущение об обратном разделении данных на фрагменты массива при чтении записи.  
  
 Обычно этот метод завершает работу до того, как запись будет записана. Чтобы запись точно была записана, либо укажите флаг <xref:System.IO.Log.RecordAppendOptions.ForceFlush> с помощью параметра `recordAppendOptions`, либо вызовите метод <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Один или несколько аргументов являются недопустимыми.</exception>
        <exception cref="T:System.IO.IOException">При добавлении записи произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательности записей не удалось выделить достаточно свободного пространства для новой записи.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="nextUndoRecord">Порядковый номер следующей записи в порядке, заданном пользователем.</param>
        <param name="previousRecord">Порядковый номер следующей записи в обратном порядке.</param>
        <param name="recordAppendOptions">Допустимое значение объекта <see cref="T:System.IO.Log.RecordAppendOptions" />, задающего, как должны записываться данные.</param>
        <param name="reservations">Коллекция <see cref="T:System.IO.Log.ReservationCollection" />, содержащая резервирование, которое следует использовать для данной записи.</param>
        <param name="callback">Необязательный асинхронный обратный вызов по завершении добавления.</param>
        <param name="state">Предоставляемый пользователем объект, отличающий конкретный запрос на асинхронное добавление от других запросов.</param>
        <summary>При переопределении в производном классе начинает асинхронную операцию добавления, используя пространство, которое было ранее зарезервировано в последовательности.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, представляющий асинхронное добавление, которое может все еще ожидать выполнения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы обеспечить завершение операции добавления и освободить соответствующие ресурсы, необходимо передать значение <xref:System.IAsyncResult>, возвращенное этим методом, в метод <xref:System.IO.Log.IRecordSequence.EndAppend%2A>. Если ошибка возникла при выполнении асинхронного добавления, исключение не будет создано до тех пор, пока метод <xref:System.IO.Log.IRecordSequence.EndAppend%2A> не будет вызван со значением <xref:System.IAsyncResult>, возвращенным данным методом.  
  
 Данные, содержащиеся в параметре `data`, будут сцеплены в единый массив байтов для добавления в качестве записи. Однако не делается допущение об обратном разделении данных на фрагменты массива при чтении записи.  
  
 Добавленная запись будет занимать пространство, ранее зарезервированное с помощью резервирования, заданного параметром `reservations`. Если выполнить добавление удается, оно займет минимальную область резервирования, в которой поместятся данные, а эта область резервирования будет удалена из коллекции.  
  
 Обычно этот метод завершает работу до того, как запись будет записана. Чтобы запись точно была записана, либо укажите флаг <xref:System.IO.Log.RecordAppendOptions.ForceFlush> с помощью параметра `recordAppendOptions`, либо вызовите метод <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Один или несколько аргументов являются недопустимыми.</exception>
        <exception cref="T:System.IO.IOException">При добавлении записи произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательности записей не удалось выделить достаточно свободного пространства для новой записи.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousUndoRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousUndoRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousUndoRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginAppend (data, nextUndoRecord, previousUndoRecord, recordAppendOptions, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="nextUndoRecord">Порядковый номер следующей записи в порядке, заданном пользователем.</param>
        <param name="previousUndoRecord">Порядковый номер следующей записи в обратном порядке.</param>
        <param name="recordAppendOptions">Допустимое значение объекта <see cref="T:System.IO.Log.RecordAppendOptions" />, задающего, как должны записываться данные.</param>
        <param name="reservations">Коллекция <see cref="T:System.IO.Log.ReservationCollection" />, содержащая резервирование, которое следует использовать для данной записи.</param>
        <param name="callback">Необязательный асинхронный обратный вызов по завершении добавления.</param>
        <param name="state">Предоставляемый пользователем объект, отличающий конкретный запрос на асинхронное добавление от других запросов.</param>
        <summary>При переопределении в производном классе начинает асинхронную операцию добавления, используя пространство, которое было ранее зарезервировано в последовательности.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, представляющий асинхронное добавление, которое может все еще ожидать выполнения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы обеспечить завершение операции добавления и освободить соответствующие ресурсы, необходимо передать значение <xref:System.IAsyncResult>, возвращенное этим методом, в метод <xref:System.IO.Log.IRecordSequence.EndAppend%2A>. Если ошибка возникла при выполнении асинхронного добавления, исключение не будет создано до тех пор, пока метод <xref:System.IO.Log.IRecordSequence.EndAppend%2A> не будет вызван со значением <xref:System.IAsyncResult>, возвращенным данным методом.  
  
 Данные, содержащиеся в параметре `data`, будут сцеплены в единый массив байтов для добавления в качестве записи. Однако не делается допущение об обратном разделении данных на фрагменты массива при чтении записи.  
  
 Добавленная запись будет занимать пространство, ранее зарезервированное с помощью резервирования, заданного параметром `reservations`. Если выполнить добавление удается, оно займет минимальную область резервирования, в которой поместятся данные, а эта область резервирования будет удалена из коллекции.  
  
 Обычно этот метод завершает работу до того, как запись будет записана. Чтобы запись точно была записана, либо укажите флаг <xref:System.IO.Log.RecordAppendOptions.ForceFlush> с помощью параметра `recordAppendOptions`, либо вызовите метод <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Один или несколько аргументов являются недопустимыми.</exception>
        <exception cref="T:System.IO.IOException">При добавлении записи произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательности записей не удалось выделить достаточно свободного пространства для новой записи.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginFlush(valuetype System.IO.Log.SequenceNumber sequenceNumber, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginFlush(System::IO::Log::SequenceNumber sequenceNumber, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginFlush : System.IO.Log.SequenceNumber * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginFlush (sequenceNumber, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">Порядковый номер последней записи, которую требуется записать. Если этот номер <see cref="T:System.IO.Log.SequenceNumber" /> недопустим, необходимо записать все записи.</param>
        <param name="callback">Необязательный асинхронный обратный вызов по завершении операции записи на диск.</param>
        <param name="state">Предоставляемый пользователем объект, являющийся отличительным признаком данного конкретного запроса на запись на диск от других запросов.</param>
        <summary>При переопределении в производном классе начинает асинхронную операцию записи на диск, используя пространство, которое было ранее зарезервировано в последовательности.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, представляющий асинхронную операцию записи на диск, которая может все еще ожидать выполнения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Необходимо передать объект <xref:System.IAsyncResult>, возвращаемый текущим методом, методу <xref:System.IO.Log.IRecordSequence.EndFlush%2A>, чтобы обеспечить завершение очистки и правильное освобождение ресурсов. Если ошибка возникает при выполнении асинхронной очистки, исключение не будет создано до тех пор, пока не будет вызван метод <xref:System.IO.Log.IRecordSequence.EndFlush%2A> с объектом <xref:System.IAsyncResult>, возвращаемым данным методом.  
  
 Вызов этого метода гарантирует, что внесены все записи, добавленные в последовательность <xref:System.IO.Log.IRecordSequence>.  
  
 Если последовательность записей была удалена, или если передается неверный аргумент, исключения создаются немедленно, в пределах данной операции. Ошибки, возникшие при выполнении запроса асинхронной очистки, например ошибка диска в процессе запроса ввода-вывода, приводят к созданию исключений при вызове метода <xref:System.IO.Log.IRecordSequence.EndFlush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Один или несколько аргументов являются недопустимыми.</exception>
        <exception cref="T:System.IO.IOException">При очистке данных произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>При переопределении в производном классе начинает асинхронную операцию резервирования и добавления.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="nextUndoRecord">Порядковый номер следующей записи в порядке, заданном пользователем.</param>
        <param name="previousRecord">Порядковый номер следующей записи в обратном порядке.</param>
        <param name="recordAppendOptions">Допустимое значение объекта <see cref="T:System.IO.Log.RecordAppendOptions" />, задающего, как должны записываться данные.</param>
        <param name="reservationCollection">Коллекция резервирования, в которой требуется сделать резервирования.</param>
        <param name="reservations">Размер необходимого резервирования (в байтах).</param>
        <param name="callback">Необязательный асинхронный обратный вызов по завершении добавления.</param>
        <param name="state">Предоставляемый пользователем объект, отличающий конкретный запрос на асинхронное добавление от других запросов.</param>
        <summary>При переопределении в производном классе начинает асинхронную операцию резервирования и добавления.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, представляющий данную асинхронную операцию, которая может все еще ожидать выполнения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы обеспечить завершение операции добавления и освободить соответствующие ресурсы, необходимо передать значение <xref:System.IAsyncResult>, возвращенное этим методом, в метод <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>. Если ошибка возникла при выполнении асинхронного добавления, исключение не будет создано до тех пор, пока метод <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> не будет вызван со значением <xref:System.IAsyncResult>, возвращенным данным методом.  
  
 Данные, содержащиеся в параметре `data`, будут сцеплены в единый массив байтов для добавления в качестве записи. Однако не делается допущение об обратном разделении данных на фрагменты массива при чтении записи.  
  
 Заданные резервирования добавляются в предоставленную коллекцию резервирования при помощи атомарной операции добавления записи. Если выполнить добавление не удается, место не резервируется.  
  
 Обычно этот метод может завершить работу до того, как запись будет записана. Чтобы запись точно была записана, либо укажите флаг <xref:System.IO.Log.RecordAppendOptions.ForceFlush> с помощью параметра `recordAppendOptions`, либо вызовите метод <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 Если последовательность записей была удалена, или если передается неверный аргумент, исключения создаются немедленно, в пределах данной операции. Ошибки, возникшие при выполнении запроса асинхронного добавления, например ошибка диска в процессе запроса ввода-вывода, приводят к созданию исключений при вызове метода <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Один или несколько аргументов являются недопустимыми.</exception>
        <exception cref="T:System.IO.IOException">При добавлении записи произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательности записей не удалось выделить достаточно свободного пространства для новой записи или выполнить резервирование.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="nextUndoRecord">Порядковый номер следующей записи в порядке, заданном пользователем.</param>
        <param name="previousRecord">Порядковый номер следующей записи в обратном порядке.</param>
        <param name="recordAppendOptions">Допустимое значение объекта <see cref="T:System.IO.Log.RecordAppendOptions" />, задающего, как должны записываться данные.</param>
        <param name="reservationCollection">Коллекция резервирования, в которой требуется сделать резервирования.</param>
        <param name="reservations">Размер необходимого резервирования (в байтах).</param>
        <param name="callback">Необязательный асинхронный обратный вызов по завершении добавления.</param>
        <param name="state">Предоставляемый пользователем объект, отличающий конкретный запрос на асинхронное добавление от других запросов.</param>
        <summary>При переопределении в производном классе начинает асинхронную операцию резервирования и добавления.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, представляющий данную асинхронную операцию, которая может все еще ожидать выполнения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы обеспечить завершение операции добавления и освободить соответствующие ресурсы, необходимо передать значение <xref:System.IAsyncResult>, возвращенное этим методом, в метод <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>. Если ошибка возникла при выполнении асинхронного добавления, исключение не будет создано до тех пор, пока метод <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> не будет вызван со значением <xref:System.IAsyncResult>, возвращенным данным методом.  
  
 Данные, содержащиеся в параметре `data`, будут сцеплены в единый массив байтов для добавления в качестве записи. Однако не делается допущение об обратном разделении данных на фрагменты массива при чтении записи.  
  
 Заданные резервирования добавляются в предоставленную коллекцию резервирования при помощи атомарной операции добавления записи. Если выполнить добавление не удается, место не резервируется.  
  
 Обычно этот метод может завершить работу до того, как запись будет записана. Чтобы запись точно была записана, либо укажите флаг <xref:System.IO.Log.RecordAppendOptions.ForceFlush> с помощью параметра `recordAppendOptions`, либо вызовите метод <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 Если последовательность записей была удалена, или если передается неверный аргумент, исключения создаются немедленно, в пределах данной операции. Ошибки, возникшие при выполнении запроса асинхронного добавления, например ошибка диска в процессе запроса ввода-вывода, приводят к созданию исключений при вызове метода <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Один или несколько аргументов являются недопустимыми.</exception>
        <exception cref="T:System.IO.IOException">При добавлении записи произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательности записей не удалось выделить достаточно свободного пространства для новой записи или выполнить резервирование.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginWriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>При переопределении в производном классе начинает асинхронную операцию записи области перезапуска.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As ArraySegment(Of Byte), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginWriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginWriteRestartArea (data, newBaseSequenceNumber, reservation, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="newBaseSequenceNumber">Новый базовый порядковый номер. Заданный порядковый номер должен быть больше или равен текущему базовому порядковому номеру.</param>
        <param name="reservation">Коллекция <see cref="T:System.IO.Log.ReservationCollection" />, содержащая резервирование, которое следует использовать для данной области перезапуска.</param>
        <param name="callback">Необязательный асинхронный обратный вызов по завершении записи в области перезапуска.</param>
        <param name="state">Предоставляемый пользователем объект, отличающий конкретный запрос на асинхронную запись в область перезапуска от других запросов.</param>
        <summary>При переопределении в производном классе начинает асинхронную операцию записи области перезапуска, используя пространство, которое было ранее зарезервировано в последовательности.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" /> представляет асинхронную операцию записи в область перезапуска, которая может все еще быть отложена.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы обеспечить завершение операции записи в область перезапуска и освободить соответствующие ресурсы, необходимо передать значение <xref:System.IAsyncResult>, возвращенное этим методом, в метод <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>. Если ошибка возникла при выполнении операции асинхронной записи в область перезапуска, исключение не будет создано до тех пор, пока метод <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> не будет вызван со значением <xref:System.IAsyncResult>, возвращенным данным методом.  
  
 Данные, содержащиеся в параметре `data`, будут сцеплены в единый массив байтов для добавления в качестве записи. Однако не делается допущение об обратном разделении данных на фрагменты массива при чтении записи.  
  
 При успешном выполнении операции базовый порядковый номер обновляется. Все записи журнала с порядковыми номерами меньшими, чем новый базовый порядковый номер, недоступны.  
  
 Если задано <xref:System.IO.Log.ReservationCollection>, записанная область перезапуска будет занимать место, ранее зарезервированное с помощью содержащегося в коллекции резервирования. Если метод завершается успешно, будет занята минимальная область резервирования, в которой поместятся данные, а эта область резервирования будет удалена из коллекции.  
  
 Если последовательность записей была удалена, или если передается неверный аргумент, исключения создаются немедленно, в пределах данной операции. Ошибки, возникшие при выполнении запроса асинхронного добавления, например ошибка диска в процессе запроса ввода-вывода, приводят к созданию исключений при вызове метода <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginWriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginWriteRestartArea (data, newBaseSequenceNumber, reservation, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="newBaseSequenceNumber">Новый базовый порядковый номер. Заданный порядковый номер должен быть больше или равен текущему базовому порядковому номеру.</param>
        <param name="reservation">Коллекция <see cref="T:System.IO.Log.ReservationCollection" />, содержащая резервирование, которое следует использовать для данной области перезапуска.</param>
        <param name="callback">Необязательный асинхронный обратный вызов по завершении записи в области перезапуска.</param>
        <param name="state">Предоставляемый пользователем объект, отличающий конкретный запрос на асинхронную запись в область перезапуска от других запросов.</param>
        <summary>При переопределении в производном классе начинает асинхронную операцию записи области перезапуска, используя пространство, которое было ранее зарезервировано в последовательности.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" /> представляет асинхронную операцию записи в область перезапуска, которая может все еще быть отложена.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы обеспечить завершение операции записи в область перезапуска и освободить соответствующие ресурсы, необходимо передать значение <xref:System.IAsyncResult>, возвращенное этим методом, в метод <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>. Если ошибка возникла при выполнении операции асинхронной записи в область перезапуска, исключение не будет создано до тех пор, пока метод <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> не будет вызван со значением <xref:System.IAsyncResult>, возвращенным данным методом.  
  
 Данные, содержащиеся в параметре `data`, будут сцеплены в единый массив байтов для добавления в качестве записи. Однако не делается допущение об обратном разделении данных на фрагменты массива при чтении записи.  
  
 При успешном выполнении операции базовый порядковый номер обновляется. Все записи журнала с порядковыми номерами меньшими, чем новый базовый порядковый номер, недоступны.  
  
 Если задано <xref:System.IO.Log.ReservationCollection>, записанная область перезапуска будет занимать место, ранее зарезервированное с помощью содержащегося в коллекции резервирования. Если метод завершается успешно, будет занята минимальная область резервирования, в которой поместятся данные, а эта область резервирования будет удалена из коллекции.  
  
 Если последовательность записей была удалена, или если передается неверный аргумент, исключения создаются немедленно, в пределах данной операции. Ошибки, возникшие при выполнении запроса асинхронного добавления, например ошибка диска в процессе запроса ввода-вывода, приводят к созданию исключений при вызове метода <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Один или несколько аргументов являются недопустимыми.</exception>
        <exception cref="T:System.IO.IOException">При записи в область перезапуска произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательности записей не удалось выделить достаточно свободного пространства для новой записи.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateReservationCollection">
      <MemberSignature Language="C#" Value="public System.IO.Log.ReservationCollection CreateReservationCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Log.ReservationCollection CreateReservationCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.CreateReservationCollection" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateReservationCollection () As ReservationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::ReservationCollection ^ CreateReservationCollection();" />
      <MemberSignature Language="F#" Value="abstract member CreateReservationCollection : unit -&gt; System.IO.Log.ReservationCollection" Usage="iRecordSequence.CreateReservationCollection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.ReservationCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе создает новый объект <see cref="T:System.IO.Log.ReservationCollection" />.</summary>
        <returns>Вновь созданный <see cref="T:System.IO.Log.ReservationCollection" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndAppend(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.EndAppend result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Ссылка на невыполненный асинхронный запрос ввода-вывода.</param>
        <summary>При переопределении в производном классе завершает асинхронную операцию добавления.</summary>
        <returns>Порядковый номер добавленной в журнал записи.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод блокируется до завершения операции ввода-вывода. Ошибки, возникающие при выполнении запроса асинхронной записи, например ошибка диска в процессе запроса ввода-вывода, отображаются при вызове <xref:System.IO.Log.IRecordSequence.EndAppend%2A>.  
  
 Этот метод должен вызываться ровно по одному разу для каждого объекта <xref:System.IAsyncResult>, возвращенного методом <xref:System.IO.Log.IRecordSequence.BeginAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Один или несколько аргументов являются недопустимыми.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndFlush(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndFlush (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndFlush(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndFlush : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.EndFlush result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Ссылка на невыполненный асинхронный запрос ввода-вывода.</param>
        <summary>При переопределении в производном классе завершает асинхронную операцию очистки.</summary>
        <returns>Порядковый номер последней записи, которая была записана.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод блокируется до завершения операции ввода-вывода. Ошибки, возникающие при выполнении запроса асинхронной очистки, например ошибка диска в процессе запроса ввода-вывода, отображаются при вызове <xref:System.IO.Log.IRecordSequence.EndFlush%2A>.  
  
 Этот метод должен вызываться ровно по одному разу для каждого объекта <xref:System.IAsyncResult>, возвращенного методом <xref:System.IO.Log.IRecordSequence.BeginFlush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Один или несколько аргументов являются недопустимыми.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndReserveAndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReserveAndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndReserveAndAppend(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndReserveAndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.EndReserveAndAppend result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Ссылка на невыполненный асинхронный запрос ввода-вывода.</param>
        <summary>При переопределении в производном классе завершает асинхронную операцию резервирования и добавления.</summary>
        <returns>Порядковый номер добавленной в журнал записи.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод блокируется до завершения операции ввода-вывода. Ошибки, возникающие при выполнении запроса асинхронной записи, например ошибка диска в процессе запроса ввода-вывода, отображаются при вызове <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>.  
  
 Этот метод должен вызываться ровно по одному разу для каждого объекта <xref:System.IAsyncResult>, возвращенного методом <xref:System.IO.Log.IRecordSequence.BeginReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Один или несколько аргументов являются недопустимыми.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndWriteRestartArea(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndWriteRestartArea (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndWriteRestartArea(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndWriteRestartArea : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.EndWriteRestartArea result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Ссылка на невыполненный асинхронный запрос ввода-вывода.</param>
        <summary>При переопределении в производном классе завершает асинхронную операцию записи области перезапуска.</summary>
        <returns>Порядковый номер записанной в журнал записи.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод блокируется до завершения операции ввода-вывода. Ошибки, возникающие при выполнении запроса асинхронной записи, например ошибка диска в процессе запроса ввода-вывода, отображаются при вызове <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>.  
  
 Этот метод должен вызываться ровно по одному разу для каждого объекта <xref:System.IAsyncResult>, возвращенного методом <xref:System.IO.Log.IRecordSequence.BeginWriteRestartArea%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Один или несколько аргументов являются недопустимыми.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>При переопределении в производном классе приводит к регистрации всех добавленных записей.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Function Flush () As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Flush();" />
      <MemberSignature Language="F#" Value="abstract member Flush : unit -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе обеспечивает регистрацию всех добавленных записей.</summary>
        <returns>Порядковый номер последней записи, которая была записана.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов этого метода гарантирует выполнение устойчивых записей, добавленных в последовательность <xref:System.IO.Log.IRecordSequence>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">При очистке данных произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush(valuetype System.IO.Log.SequenceNumber sequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Flush(System::IO::Log::SequenceNumber sequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member Flush : System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Flush sequenceNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">Порядковый номер последней записи, которую требуется записать. Если этот номер <see cref="T:System.IO.Log.SequenceNumber" /> недопустим, необходимо записать все записи.</param>
        <summary>При переопределении в производном классе обеспечивает устойчивую запись всех добавленных записей до указанного порядкового номера включительно.</summary>
        <returns>Порядковый номер последней записи, которая была записана.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов этого метода обеспечивает устойчивую запись всех записей до указанного порядкового номера включительно.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Один или несколько аргументов являются недопустимыми.</exception>
        <exception cref="T:System.IO.IOException">При очистке данных произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.LastSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber LastSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.LastSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.IRecordSequence.LastSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе возвращает порядковый номер, превышающий последнюю добавленную запись.</summary>
        <value>Порядковый номер, превышающий последнюю добавленную запись.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данное свойство содержит порядковый номер, который гарантированно больше, чем порядковый номер последней добавленной записи. Допустимые порядковые номера больше или равны <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> и меньше <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>.  
  
> [!NOTE]
>  При использовании экземпляра <xref:System.IO.Log.LogRecordSequence> значение <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A> может стать устаревшим, пока записи не помещены в журнал. Дополнительные <xref:System.IO.Log.IRecordSequence.Flush%2A> сведения <xref:System.IO.Log.RecordAppendOptions> о сбросе записей см. в разделе и. 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Обращение к свойству произошло после удаления последовательности.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumRecordLength">
      <MemberSignature Language="C#" Value="public long MaximumRecordLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumRecordLength" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.MaximumRecordLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaximumRecordLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumRecordLength { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumRecordLength : int64" Usage="System.IO.Log.IRecordSequence.MaximumRecordLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе возвращает размер в байтах наибольшей записи, которую можно добавить или прочитать из последовательности.</summary>
        <value>Размер в байтах наибольшей записи, которую можно добавить или прочитать из последовательности.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Обращение к свойству произошло после удаления последовательности.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLogRecords">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadLogRecords(valuetype System.IO.Log.SequenceNumber start, valuetype System.IO.Log.LogRecordEnumeratorType logRecordEnum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLogRecords (start As SequenceNumber, logRecordEnum As LogRecordEnumeratorType) As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadLogRecords(System::IO::Log::SequenceNumber start, System::IO::Log::LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="F#" Value="abstract member ReadLogRecords : System.IO.Log.SequenceNumber * System.IO.Log.LogRecordEnumeratorType -&gt; seq&lt;System.IO.Log.LogRecord&gt;" Usage="iRecordSequence.ReadLogRecords (start, logRecordEnum)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="logRecordEnum" Type="System.IO.Log.LogRecordEnumeratorType" />
      </Parameters>
      <Docs>
        <param name="start">Порядковый номер первой записи, с которой начинается чтение.</param>
        <param name="logRecordEnum">Допустимое значение <see cref="T:System.IO.Log.LogRecordEnumeratorType" />, указывающее способ (вперед или назад), которым записи должны считываться из <see cref="T:System.IO.Log.LogRecordSequence" />.</param>
        <summary>При переопределении в производном классе возвращает перечислимую коллекцию записей в последовательности.</summary>
        <returns>Перечисляемая коллекция записей в последовательности.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При переопределении в производном классе возвращает перечислимую коллекцию записей в последовательности. Порядок перечисленных записей зависит от значения параметра `logRecordEnum`.  
  
   
  
## Examples  
 В этом образце демонстрируется использование метода <xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A>.  
  
```csharp  
using System;  
 using System.IO;  
 using System.IO.Log;  
  
 class ReadRecordsSample  
 {  
     static SequenceNumber AppendRecord(IRecordSequence sequence,  
                                        string message,  
                                        SequenceNumber user,  
                                        SequenceNumber previous)  
     {  
         MemoryStream data = new MemoryStream();  
         BinaryWriter writer = new BinaryWriter(data);  
         writer.Write(message);  
  
         ArraySegment<byte>[] segments;  
         segments = new ArraySegment<byte>[1];  
         segments[0] = new ArraySegment(data.GetBuffer(),  
                                        0,  
                                        Data.Length);  
  
         return sequence.Append(segments,  
                                user,  
                                previous,  
                                WriteFlags.None);  
     }  
  
     public static void Main(string[] args)  
     {  
         IRecordSequence sequence;  
         sequence = new FileIRecordSequence(args[0]);  
  
         SequenceNumber a, b, c, d;  
  
         a = AppendRecord(sequence,  
                          "This is record A",  
                          SequenceNumber.Invalid,  
                          SequenceNumber.Invalid);  
         Console.WriteLine("Record A has sequence number System.IO.Log", a);  
  
         b = AppendRecord(sequence,  
                          "This is record B",  
                          a,  
                          a);  
         Console.WriteLine("Record B has sequence number System.IO.Log", b);  
  
         c = AppendRecord(sequence,  
                          "This is record C",  
                          a,  
                          a);  
         Console.WriteLine("Record C has sequence number System.IO.Log", c);  
  
         d = AppendRecord(sequence,  
                          "This is record D",  
                          b,  
                          c);  
         Console.WriteLine("Record D has sequence number System.IO.Log", d);  
  
         foreach(LogRecord record in  
                 sequence.ReadLogRecords(a, ReadDirection.Forward))  
         {  
             BinaryReader reader = new BinaryReader(record.Data);  
             Console.WriteLine("System.IO.Log: T:System.IO.Log.IRecordSequence",  
                               record.SequenceNumber,  
                               reader.ReadString());  
         }  
  
         foreach(LogRecord record in  
                 sequence.ReadLogRecords(d, ReadDirection.User))  
         {  
             BinaryReader reader = new BinaryReader(record.Data);  
             Console.WriteLine("System.IO.Log: T:System.IO.Log.IRecordSequence",  
                               record.SequenceNumber,  
                               reader.ReadString());  
         }  
  
         foreach(LogRecord record in  
                 sequence.ReadLogRecords(d, ReadDirection.Previous))  
         {  
             BinaryReader reader = new BinaryReader(record.Data);  
             Console.WriteLine("System.IO.Log: T:System.IO.Log.IRecordSequence",  
                               record.SequenceNumber,  
                               reader.ReadString());  
         }  
     }  
       }  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Один или несколько аргументов являются недопустимыми.</exception>
        <exception cref="T:System.IO.IOException">При чтении записи произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadRestartAreas">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadRestartAreas ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadRestartAreas() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReadRestartAreas" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadRestartAreas () As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadRestartAreas();" />
      <MemberSignature Language="F#" Value="abstract member ReadRestartAreas : unit -&gt; seq&lt;System.IO.Log.LogRecord&gt;" Usage="iRecordSequence.ReadRestartAreas " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе возвращает перечисляемую коллекцию областей перезапуска в последовательности.</summary>
        <returns>Перечисляемая коллекция областей перезапуска в последовательности.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Области перезапуска перечислены в обратном порядке их номеров, т.е. от самого высокого порядкового номера до самого низкого. Выполняется перечисление только областей перезапуска между последним и базовым порядковым номером.  
  
> [!NOTE]
>  В случае повреждения области журнала, содержащей свойство <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>, этот метод может создать исключение <xref:System.IO.IOException> с сообщением об ошибке "Не удалось выполнить запрос, так как возникла неожиданная ошибка ввода-вывода. Возвращен следующий код ошибки: ' 80070026 ' ".  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Один или несколько аргументов являются недопустимыми.</exception>
        <exception cref="T:System.IO.IOException">При чтении записи произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>При переопределении в производном классе автоматически делает одно резервирование и добавляет запись в последовательность.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber ReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member ReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.ReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="nextUndoRecord">Порядковый номер следующей записи в порядке, заданном пользователем.</param>
        <param name="previousRecord">Порядковый номер следующей записи в обратном порядке.</param>
        <param name="recordAppendOptions">Допустимое значение объекта <see cref="T:System.IO.Log.RecordAppendOptions" />, задающего, как должны записываться данные.</param>
        <param name="reservationCollection">Объект <see cref="T:System.IO.Log.ReservationCollection" />, содержащий коллекцию, в которой создается резервирование.</param>
        <param name="reservations">Размер необходимого резервирования (в байтах).</param>
        <summary>При переопределении в производном классе автоматически делает одно резервирование и добавляет запись в последовательность.</summary>
        <returns>Порядковый номер добавленной в журнал записи.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данные, содержащиеся в параметре `data`, будут сцеплены в единый массив байтов для добавления в качестве записи. Однако не делается допущение об обратном разделении данных на фрагменты массива при чтении записи.  
  
 Заданные резервирования добавляются в предоставленную коллекцию резервирования при помощи атомарной операции добавления записи. Если выполнить добавление не удается, место не резервируется.  
  
 Обычно этот метод может завершить работу до того, как запись будет записана. Чтобы запись точно была записана, либо укажите флаг <xref:System.IO.Log.RecordAppendOptions.ForceFlush> с помощью параметра `recordAppendOptions`, либо вызовите метод <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Один или несколько аргументов являются недопустимыми.</exception>
        <exception cref="T:System.IO.IOException">При добавлении записи произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательности записей не удалось выделить достаточно свободного пространства для новой записи или выполнить резервирование.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber ReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member ReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.ReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="nextUndoRecord">Порядковый номер следующей записи в порядке, заданном пользователем.</param>
        <param name="previousRecord">Порядковый номер следующей записи в обратном порядке.</param>
        <param name="recordAppendOptions">Допустимое значение объекта <see cref="T:System.IO.Log.RecordAppendOptions" />, задающего, как должны записываться данные.</param>
        <param name="reservationCollection">Коллекция резервирования, в которой требуется сделать резервирования.</param>
        <param name="reservations">Размер необходимого резервирования (в байтах).</param>
        <summary>При переопределении в производном классе автоматически делает одно резервирование и добавляет запись в последовательность.</summary>
        <returns>Порядковый номер добавленной в журнал записи.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данные, содержащиеся в параметре `data`, будут сцеплены в единый массив байтов для добавления в качестве записи. Однако не делается допущение об обратном разделении данных на фрагменты массива при чтении записи.  
  
 Заданные резервирования добавляются в предоставленную коллекцию резервирования при помощи атомарной операции добавления записи. Если выполнить добавление не удается, место не резервируется.  
  
 Обычно этот метод может завершить работу до того, как запись будет записана. Чтобы запись точно была записана, либо укажите флаг <xref:System.IO.Log.RecordAppendOptions.ForceFlush> с помощью параметра `recordAppendOptions`, либо вызовите метод <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Один или несколько аргументов являются недопустимыми.</exception>
        <exception cref="T:System.IO.IOException">При добавлении записи произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательности записей не удалось выделить достаточно свободного пространства для новой записи или выполнить резервирование.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReservedBytes">
      <MemberSignature Language="C#" Value="public long ReservedBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ReservedBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.ReservedBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReservedBytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ReservedBytes { long get(); };" />
      <MemberSignature Language="F#" Value="member this.ReservedBytes : int64" Usage="System.IO.Log.IRecordSequence.ReservedBytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе возвращает общее количество зарезервированных байтов.</summary>
        <value>Общий размер резервирований, созданных в последовательности записей.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Обращение к свойству произошло после удаления последовательности.</exception>
      </Docs>
    </Member>
    <Member MemberName="RestartSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber RestartSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.RestartSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestartSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber RestartSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.RestartSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.IRecordSequence.RestartSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе возвращает порядковый номер последней записанной области перезапуска.</summary>
        <value>Порядковый номер последней записанной области перезапуска.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Область перезапуска служит для временного хранения сведений, содержащих последнюю операцию контрольной точки клиента. Если требуется выполнить восстановление, можно проанализировать область перезапуска, чтобы извлечь все данные с последней операции контрольной точки. Эти данные инициализирует таблицу транзакций, таблицу "грязных страниц" и таблицу открытых файлов, чтобы их можно было использовать в процессе восстановления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Обращение к свойству произошло после удаления последовательности.</exception>
      </Docs>
    </Member>
    <Member MemberName="RetryAppend">
      <MemberSignature Language="C#" Value="public bool RetryAppend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RetryAppend" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.RetryAppend" />
      <MemberSignature Language="VB.NET" Value="Public Property RetryAppend As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RetryAppend { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RetryAppend : bool with get, set" Usage="System.IO.Log.IRecordSequence.RetryAppend" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, выполняется ли повторная автоматическая попытка добавления в случае заполнения журнала.</summary>
        <value>Значение <see langword="true" />, если выполняется автоматическая повторная попытка добавления при заполнении журнала; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если значением данного свойства является `true` и происходит сбой вызова <xref:System.IO.Log.IRecordSequence.Append%2A> из-за недостатка места в последовательности, последовательность записей пытается освободить место и совершает повторную попытку добавления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Обращение к свойству произошло после удаления последовательности.</exception>
      </Docs>
    </Member>
    <Member MemberName="TailPinned">
      <MemberSignature Language="C#" Value="event EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; TailPinned;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IO.Log.TailPinnedEventArgs&gt; TailPinned" />
      <MemberSignature Language="DocId" Value="E:System.IO.Log.IRecordSequence.TailPinned" />
      <MemberSignature Language="VB.NET" Value="Event TailPinned As EventHandler(Of TailPinnedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::IO::Log::TailPinnedEventArgs ^&gt; ^ TailPinned;" />
      <MemberSignature Language="F#" Value="member this.TailPinned : EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; " Usage="member this.TailPinned : System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда последовательность записей определяет завершающую часть, которую необходимо переместить вперед.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие можно создать, когда в последовательности записей закончилось свободное пространство. При создании этого события завершающая часть последовательности (то есть базовый порядковый номер) перемещается вперед для освобождения места.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>При переопределении в производном классе записывает область перезапуска в последовательность <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Область перезапуска служит для временного хранения сведений, содержащих последнюю операцию контрольной точки клиента. Если требуется выполнить восстановление, можно проанализировать область перезапуска, чтобы извлечь все данные с последней операции контрольной точки. Эти данные инициализирует таблицу транзакций, таблицу "грязных страниц" и таблицу открытых файлов, чтобы их можно было использовать в процессе восстановления. Чтение области перезапуска возможно с помощью метода <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte)) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <summary>При переопределении в производном классе записывает область перезапуска в последовательность <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <returns>Порядковый номер записанной области перезапуска.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Область перезапуска служит для временного хранения сведений, содержащих последнюю операцию контрольной точки клиента. Файловая система CLFS поддерживает две области перезапуска, чтобы всегда была доступна хотя бы одна действительная область. Если требуется выполнить восстановление, файловая система CLFS читает область перезапуска и все данные с последней операции контрольной точки. Эти данные инициализирует таблицу транзакций, таблицу "грязных страниц" и таблицу открытых файлов, чтобы их можно было использовать в процессе восстановления.  
  
 Чтение области перезапуска возможно с помощью метода <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.  
  
 Данные в этих фрагментах массива байтов будут сцеплены в единый массив байтов для добавления в качестве записи. Не делается никаких допущений об обратном разделении данных на фрагменты массива при чтении области перезапуска.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Один или несколько аргументов являются недопустимыми.</exception>
        <exception cref="T:System.IO.IOException">При записи в область перезапуска произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательности записей не удалось выделить достаточно свободного пространства для новой области перезапуска.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte))) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <summary>При переопределении в производном классе записывает область перезапуска в последовательность <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <returns>Порядковый номер записанной области перезапуска.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Область перезапуска служит для временного хранения сведений, содержащих последнюю операцию контрольной точки клиента. Если требуется выполнить восстановление, можно проанализировать область перезапуска, чтобы извлечь все данные с последней операции контрольной точки. Эти данные инициализирует таблицу транзакций, таблицу "грязных страниц" и таблицу открытых файлов, чтобы их можно было использовать в процессе восстановления. Чтение области перезапуска возможно с помощью метода <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.  
  
 Данные в этих фрагментах массива байтов будут сцеплены в единый массив байтов для добавления в качестве записи. Не делается никаких допущений об обратном разделении данных на фрагменты массива при чтении области перезапуска.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Один или несколько аргументов являются недопустимыми.</exception>
        <exception cref="T:System.IO.IOException">При записи в область перезапуска произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательности записей не удалось выделить достаточно свободного пространства для новой области перезапуска.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSequenceNumber As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea (data, newBaseSequenceNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="newBaseSequenceNumber">Новый базовый порядковый номер. Заданный порядковый номер должен быть больше или равен текущему базовому порядковому номеру.</param>
        <summary>При переопределении в производном классе записывает область перезапуска в последовательность <see cref="T:System.IO.Log.IRecordSequence" /> и обновляет базовый порядковый номер.</summary>
        <returns>Порядковый номер записанной области перезапуска.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Область перезапуска служит для временного хранения сведений, содержащих последнюю операцию контрольной точки клиента. Если требуется выполнить восстановление, можно проанализировать область перезапуска, чтобы извлечь все данные с последней операции контрольной точки. Эти данные инициализирует таблицу транзакций, таблицу "грязных страниц" и таблицу открытых файлов, чтобы их можно было использовать в процессе восстановления. Чтение области перезапуска возможно с помощью метода <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.  
  
 При записи области перезапуска данные в этих фрагментах массива байтов сцепляются в единый массив байтов для добавления в качестве записи. Не делается никаких допущений об обратном разделении данных на фрагменты массива при чтении области перезапуска.  
  
 При успешном выполнении этого метода базовый порядковый номер обновляется. Все записи журнала с порядковыми номерами меньшими, чем новый базовый порядковый номер, недоступны.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Один или несколько аргументов являются недопустимыми.</exception>
        <exception cref="T:System.IO.IOException">При записи в область перезапуска произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательности записей не удалось выделить достаточно свободного пространства для новой области перезапуска.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSequenceNumber As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea (data, newBaseSequenceNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="newBaseSequenceNumber">Новый базовый порядковый номер. Заданный порядковый номер должен быть больше или равен текущему базовому порядковому номеру.</param>
        <summary>При переопределении в производном классе записывает область перезапуска в последовательность <see cref="T:System.IO.Log.IRecordSequence" /> и обновляет базовый порядковый номер.</summary>
        <returns>Порядковый номер записанной области перезапуска.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Область перезапуска служит для временного хранения сведений, содержащих последнюю операцию контрольной точки клиента. Если требуется выполнить восстановление, можно проанализировать область перезапуска, чтобы извлечь все данные с последней операции контрольной точки. Эти данные инициализирует таблицу транзакций, таблицу "грязных страниц" и таблицу открытых файлов, чтобы их можно было использовать в процессе восстановления. Чтение области перезапуска возможно с помощью метода <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.  
  
 При записи области перезапуска данные в этих фрагментах массива байтов сцепляются в единый массив байтов для добавления в качестве записи. Не делается никаких допущений об обратном разделении данных на фрагменты массива при чтении области перезапуска.  
  
 При успешном выполнении этого метода базовый порядковый номер обновляется. Все записи журнала с порядковыми номерами меньшими, чем новый базовый порядковый номер, недоступны.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Один или несколько аргументов являются недопустимыми.</exception>
        <exception cref="T:System.IO.IOException">При записи в область перезапуска произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательности записей не удалось выделить достаточно свободного пространства для новой области перезапуска.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea (data, newBaseSequenceNumber, reservation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="newBaseSequenceNumber">Новый базовый порядковый номер. Заданный порядковый номер должен быть больше или равен текущему базовому порядковому номеру.</param>
        <param name="reservation">Коллекция <see cref="T:System.IO.Log.ReservationCollection" />, содержащая резервирование, которое следует использовать для данной области перезапуска.</param>
        <summary>При переопределении в производном классе записывает область перезапуска в последовательность <see cref="T:System.IO.Log.IRecordSequence" />, используя резервирование, и обновляет базовый порядковый номер.</summary>
        <returns>Порядковый номер записанной области перезапуска.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Область перезапуска служит для временного хранения сведений, содержащих последнюю операцию контрольной точки клиента. Если требуется выполнить восстановление, можно проанализировать область перезапуска, чтобы извлечь все данные с последней операции контрольной точки. Эти данные инициализирует таблицу транзакций, таблицу "грязных страниц" и таблицу открытых файлов, чтобы их можно было использовать в процессе восстановления. Чтение области перезапуска возможно с помощью метода <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.  
  
 При записи области перезапуска данные в этих фрагментах массива байтов сцепляются в единый массив байтов для добавления в качестве записи. Не делается никаких допущений об обратном разделении данных на фрагменты массива при чтении области перезапуска.  
  
 Если задано резервирование, записанная область перезапуска будет занимать место, ранее зарезервированное с помощью содержащегося в коллекции резервирования. Если метод завершается успешно, будет занята минимальная область резервирования, в которой поместятся данные, а эта область резервирования будет удалена из коллекции.  
  
 При успешном выполнении этого метода базовый порядковый номер обновляется. Все записи журнала с порядковыми номерами меньшими, чем новый базовый порядковый номер, недоступны.  
  
 Если последовательность записей была удалена, или если передается неверный аргумент, исключения создаются немедленно, в пределах данной операции. Ошибки, возникшие при выполнении запроса асинхронного добавления, например ошибка диска в процессе запроса ввода-вывода, приводят к созданию исключений при вызове метода <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Один или несколько аргументов являются недопустимыми.</exception>
        <exception cref="T:System.IO.IOException">При записи в область перезапуска произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательности записей не удалось выделить достаточно свободного пространства для новой области перезапуска.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea (data, newBaseSequenceNumber, reservation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="newBaseSequenceNumber">Новый базовый порядковый номер. Заданный порядковый номер должен быть больше или равен текущему базовому порядковому номеру.</param>
        <param name="reservation">Коллекция <see cref="T:System.IO.Log.ReservationCollection" />, содержащая резервирование, которое следует использовать для данной области перезапуска.</param>
        <summary>При переопределении в производном классе записывает область перезапуска в последовательность <see cref="T:System.IO.Log.IRecordSequence" />, используя резервирование, и обновляет базовый порядковый номер.</summary>
        <returns>Порядковый номер записанной области перезапуска.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Область перезапуска служит для временного хранения сведений, содержащих последнюю операцию контрольной точки клиента. Если требуется выполнить восстановление, можно проанализировать область перезапуска, чтобы извлечь все данные с последней операции контрольной точки. Эти данные инициализирует таблицу транзакций, таблицу "грязных страниц" и таблицу открытых файлов, чтобы их можно было использовать в процессе восстановления. Чтение области перезапуска возможно с помощью метода <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.  
  
 При записи области перезапуска данные в этих фрагментах массива байтов сцепляются в единый массив байтов для добавления в качестве записи. Не делается никаких допущений об обратном разделении данных на фрагменты массива при чтении области перезапуска.  
  
 Если задано резервирование, записанная область перезапуска будет занимать место, ранее зарезервированное с помощью содержащегося в коллекции резервирования. Если метод завершается успешно, будет занята минимальная область резервирования, в которой поместятся данные, а эта область резервирования будет удалена из коллекции.  
  
 При успешном выполнении этого метода базовый порядковый номер обновляется. Все записи журнала с порядковыми номерами меньшими, чем новый базовый порядковый номер, недоступны.  
  
 Если последовательность записей была удалена, или если передается неверный аргумент, исключения создаются немедленно, в пределах данной операции. Ошибки, возникшие при выполнении запроса асинхронного добавления, например ошибка диска в процессе запроса ввода-вывода, приводят к созданию исключений при вызове метода <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Один или несколько аргументов являются недопустимыми.</exception>
        <exception cref="T:System.IO.IOException">При записи в область перезапуска произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательности записей не удалось выделить достаточно свободного пространства для новой области перезапуска.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
