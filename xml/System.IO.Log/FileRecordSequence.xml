<Type Name="FileRecordSequence" FullName="System.IO.Log.FileRecordSequence">
  <Metadata><Meta Name="ms.openlocfilehash" Value="357bcf9d63d200a6b2f6eff82d460c052bdce2ba" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69356895" /></Metadata><TypeSignature Language="C#" Value="public sealed class FileRecordSequence : IDisposable, System.IO.Log.IRecordSequence" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FileRecordSequence extends System.Object implements class System.IDisposable, class System.IO.Log.IRecordSequence" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.FileRecordSequence" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class FileRecordSequence&#xA;Implements IDisposable, IRecordSequence" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileRecordSequence sealed : IDisposable, System::IO::Log::IRecordSequence" />
  <TypeSignature Language="F#" Value="type FileRecordSequence = class&#xA;    interface IRecordSequence&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IO.Log.IRecordSequence</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Реализует класс <see cref="T:System.IO.Log.IRecordSequence" /> в верхней строке файла. Этот класс не наследуется.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Класс <xref:System.IO.Log.FileRecordSequence> является последовательностью записей, основанной на одном файле журнала в файловой системе. Это простая реализация интерфейса <xref:System.IO.Log.IRecordSequence> на базе журнала, основанного на простых файлах.  
  
 Для управления журналом на основе файлов учетная запись, в которой запущено приложение, должна иметь достаточные права доступа, как того требует безопасность файловой системы в момент создания объекта <xref:System.IO.Log.FileRecordSequence>. Кроме того, во время создания требуется разрешение FullTrust (полное доверие). Результаты проверки разрешений кэшируются в соответствии с моделью безопасности Windows. Необходимо убедиться, что содержание последовательности записей не станет по случайности доступно неавторизованному пользователю.  
  
   
  
## Examples  
 В следующем примере создается последовательность записей, добавляется к ней запись, и наконец, выполняется чтение записей.  
  
 [!code-csharp[IRecordSequence#1](~/samples/snippets/csharp/VS_Snippets_CFX/irecordsequence/cs/readrecord.cs#1)]
 [!code-vb[IRecordSequence#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/irecordsequence/vb/readrecord.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.Log.FileRecordSequence" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileRecordSequence (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileRecordSequence(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.FileRecordSequence : string -&gt; System.IO.Log.FileRecordSequence" Usage="new System.IO.Log.FileRecordSequence path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Абсолютный или относительный путь к файлу, который инкапсулируется экземпляром <see cref="T:System.IO.Log.FileRecordSequence" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.Log.FileRecordSequence" /> с указанным файлом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор создает доступ для чтения и записи к файлу и открывает файл с общим доступом для чтения. Это означает, что не удастся выполнить запросы на открытие файла для записи этим или другим процессом, пока не будет удален экземпляр <xref:System.IO.Log.FileRecordSequence>, но чтение будет происходить. Если параметр `path` не найден, новый файл создается с нулевым размером.  
  
   
  
## Examples  
 В следующем примере создается последовательность записей, добавляется запись к ней, считываются записи и, наконец, удаляется последовательность.  
  
 [!code-csharp[IRecordSequence#1](~/samples/snippets/csharp/VS_Snippets_CFX/irecordsequence/cs/readrecord.cs#1)]
 [!code-vb[IRecordSequence#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/irecordsequence/vb/readrecord.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Файл, заданный параметром <paramref name="path" />, является недопустимым.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удается найти файл, заданный свойством <paramref name="path" />.</exception>
        <exception cref="T:System.IO.IOException">Выполнить запрос невозможно из-за непредвиденного исключения ввода-вывода.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Доступ к заданному хранилищу журнала запрещен операционной системой.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileRecordSequence (string path, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.#ctor(System.String,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileRecordSequence(System::String ^ path, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.FileRecordSequence : string * System.IO.FileAccess -&gt; System.IO.Log.FileRecordSequence" Usage="new System.IO.Log.FileRecordSequence (path, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Абсолютный или относительный путь к файлу, который инкапсулируется экземпляром <see cref="T:System.IO.Log.FileRecordSequence" />.</param>
        <param name="access">Допустимое значение <see cref="T:System.IO.FileAccess" />, определяющее тип доступа пользователей к файлу журнала.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.Log.FileRecordSequence" /> с указанным файлом и режимом доступа.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Файл, заданный параметром <paramref name="path" />, является недопустимым.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удается найти файл, заданный свойством <paramref name="path" />.</exception>
        <exception cref="T:System.IO.IOException">Выполнить запрос невозможно из-за непредвиденного исключения ввода-вывода.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Доступ к заданному хранилищу журнала запрещен операционной системой.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileRecordSequence (string path, System.IO.FileAccess access, int size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileAccess access, int32 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.#ctor(System.String,System.IO.FileAccess,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, access As FileAccess, size As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileRecordSequence(System::String ^ path, System::IO::FileAccess access, int size);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.FileRecordSequence : string * System.IO.FileAccess * int -&gt; System.IO.Log.FileRecordSequence" Usage="new System.IO.Log.FileRecordSequence (path, access, size)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">Абсолютный или относительный путь к файлу, который инкапсулируется экземпляром <see cref="T:System.IO.Log.FileRecordSequence" />.</param>
        <param name="access">Допустимое значение <see cref="T:System.IO.FileAccess" />, определяющее тип доступа пользователей к файлу журнала.</param>
        <param name="size">Размер файла журнала, который необходимо открыть.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.Log.FileRecordSequence" /> с указанным файлом, режимом доступа и размером файла.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Один или несколько параметров выходят за пределы допустимого диапазона.</exception>
        <exception cref="T:System.ArgumentException">Файл, заданный параметром <paramref name="path" />, является недопустимым.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удается найти файл, заданный свойством <paramref name="path" />.</exception>
        <exception cref="T:System.IO.IOException">Выполнить запрос невозможно из-за непредвиденного исключения ввода-вывода.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Доступ к заданному хранилищу журнала запрещен операционной системой.</exception>
      </Docs>
    </Member>
    <Member MemberName="AdvanceBaseSequenceNumber">
      <MemberSignature Language="C#" Value="public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AdvanceBaseSequenceNumber(valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AdvanceBaseSequenceNumber (newBaseSequenceNumber As SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AdvanceBaseSequenceNumber(System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member AdvanceBaseSequenceNumber : System.IO.Log.SequenceNumber -&gt; unit&#xA;override this.AdvanceBaseSequenceNumber : System.IO.Log.SequenceNumber -&gt; unit" Usage="fileRecordSequence.AdvanceBaseSequenceNumber newBaseSequenceNumber" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="newBaseSequenceNumber">Новый базовый порядковый номер последовательности журналов.</param>
        <summary>Выполняет переход базового порядкового номера журнала. Наследовать этот метод нельзя.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="newBaseSequenceNumber" /> недопустим.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="newBaseSequenceNumber" /> не находится в пределах этой последовательности.</exception>
        <exception cref="T:System.IO.IOException">При изменении последовательности произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Регистрирует запись журнала в <see cref="T:System.IO.Log.FileRecordSequence" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере создается последовательность записей, добавляется к ней запись, и наконец, выполняется чтение записей.  
  
 [!code-csharp[IRecordSequence#0](~/samples/snippets/csharp/VS_Snippets_CFX/irecordsequence/cs/readrecord.cs#0)]
 [!code-vb[IRecordSequence#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/irecordsequence/vb/readrecord.vb#0)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="F#" Value="abstract member Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="nextUndoRecord">Порядковый номер следующей записи в порядке, заданном пользователем.</param>
        <param name="previousRecord">Порядковый номер следующей записи в обратном порядке.</param>
        <param name="recordAppendOptions">Допустимое значение объекта <see cref="T:System.IO.Log.RecordAppendOptions" />, задающего, как должны записываться данные.</param>
        <summary>Регистрирует запись журнала в <see cref="T:System.IO.Log.FileRecordSequence" />. Наследовать этот метод нельзя.</summary>
        <returns>Порядковый номер добавленной в журнал записи.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данные, содержащиеся в параметре `data`, будут сцеплены в единый массив байтов для добавления в качестве записи. Однако не делается допущение об обратном разделении данных на фрагменты массива при чтении записи.  
  
 Обычно этот метод завершает работу до того, как запись будет записана. Чтобы запись точно была записана, либо укажите флаг <xref:System.IO.Log.RecordAppendOptions.ForceFlush> с помощью параметра `recordAppendOptions`, либо вызовите метод <xref:System.IO.Log.FileRecordSequence.Flush%2A>.  
  
   
  
## Examples  
 В следующем примере создается последовательность записей, добавляется к ней запись, и наконец, выполняется чтение записей.  
  
 [!code-csharp[FileRecordSequence#0](~/samples/snippets/csharp/VS_Snippets_CFX/filerecordsequence/cs/filerecordsequence.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Один или несколько аргументов имеют значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Один или несколько аргументов выходят за пределы диапазона.</exception>
        <exception cref="T:System.NotSupportedException">Невозможно выполнить операцию, поскольку последовательность записей была открыта с доступом только для чтения.</exception>
        <exception cref="T:System.IO.IOException">Не удалось выполнить запрос, так как возникла неожиданная ошибка ввода-вывода.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательность записей заполнена.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="F#" Value="abstract member Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="nextUndoRecord">Порядковый номер следующей записи в порядке, заданном пользователем.</param>
        <param name="previousRecord">Порядковый номер следующей записи в обратном порядке.</param>
        <param name="recordAppendOptions">Допустимое значение объекта <see cref="T:System.IO.Log.RecordAppendOptions" />, задающего, как должны записываться данные.</param>
        <summary>Регистрирует запись журнала в <see cref="T:System.IO.Log.FileRecordSequence" />. Наследовать этот метод нельзя.</summary>
        <returns>Порядковый номер добавленной в журнал записи.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данные, содержащиеся в параметре `data`, будут сцеплены в единый массив байтов для добавления в качестве записи. Однако не делается допущение об обратном разделении данных на фрагменты массива при чтении записи.  
  
 Обычно этот метод завершает работу до того, как запись будет записана. Чтобы запись точно была записана, либо укажите флаг <xref:System.IO.Log.RecordAppendOptions.ForceFlush> с помощью параметра `recordAppendOptions`, либо вызовите метод <xref:System.IO.Log.FileRecordSequence.Flush%2A>.  
  
   
  
## Examples  
 В следующем примере показан способ создания последовательности записей с помощью этого метода.  
  
 [!code-csharp[IRecordSequence#3](~/samples/snippets/csharp/VS_Snippets_CFX/irecordsequence/cs/readrecord.cs#3)] 
 [!code-vb[IRecordSequence#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/irecordsequence/vb/readrecord.vb#3)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Один или несколько аргументов имеют значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Один или несколько аргументов выходят за пределы диапазона.</exception>
        <exception cref="T:System.NotSupportedException">Невозможно выполнить операцию, поскольку последовательность записей была открыта с доступом только для чтения.</exception>
        <exception cref="T:System.IO.IOException">Не удалось выполнить запрос, так как возникла неожиданная ошибка ввода-вывода.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательность записей заполнена.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="nextUndoRecord">Порядковый номер следующей записи в порядке, заданном пользователем.</param>
        <param name="previousRecord">Порядковый номер следующей записи в обратном порядке.</param>
        <param name="recordAppendOptions">Допустимое значение объекта <see cref="T:System.IO.Log.RecordAppendOptions" />, задающего, как должны записываться данные.</param>
        <param name="reservations">Коллекция <see cref="T:System.IO.Log.ReservationCollection" />, содержащая резервирование, которое следует использовать для данной записи.</param>
        <summary>Регистрирует запись журнала в <see cref="T:System.IO.Log.FileRecordSequence" />, используя пространство, которое было ранее зарезервировано в последовательности. Наследовать этот метод нельзя.</summary>
        <returns>Порядковый номер добавленной в журнал записи.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данные, содержащиеся в параметре `data`, будут сцеплены в единый массив байтов для добавления в качестве записи. Однако не делается допущение об обратном разделении данных на фрагменты массива при чтении записи.  
  
 Добавленная запись будет занимать пространство, ранее зарезервированное с помощью резервирования, заданного параметром `reservations`. Если выполнить добавление удается, оно займет минимальную область резервирования, в которой поместятся данные, а эта область резервирования будет удалена из коллекции.  
  
 Обычно этот метод завершает работу до того, как запись будет записана. Чтобы запись точно была записана, либо укажите флаг <xref:System.IO.Log.RecordAppendOptions.ForceFlush> с помощью параметра `recordAppendOptions`, либо вызовите метод <xref:System.IO.Log.FileRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Один или несколько аргументов имеют значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Один или несколько аргументов выходят за пределы диапазона.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="reservations" /> не был создан этой последовательностью записи.</exception>
        <exception cref="T:System.NotSupportedException">Невозможно выполнить операцию, поскольку последовательность записей была открыта с доступом только для чтения.</exception>
        <exception cref="T:System.IO.IOException">Не удалось выполнить запрос, так как возникла неожиданная ошибка ввода-вывода.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательность записей заполнена.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">В <paramref name="data" /> не удается найти резервирование, достаточное для размещения параметра <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="nextUndoRecord">Порядковый номер следующей записи в порядке, заданном пользователем.</param>
        <param name="previousRecord">Порядковый номер следующей записи в обратном порядке.</param>
        <param name="recordAppendOptions">Допустимое значение объекта <see cref="T:System.IO.Log.RecordAppendOptions" />, задающего, как должны записываться данные.</param>
        <param name="reservations">Коллекция <see cref="T:System.IO.Log.ReservationCollection" />, содержащая резервирование, которое следует использовать для данной записи.</param>
        <summary>Регистрирует запись журнала в <see cref="T:System.IO.Log.FileRecordSequence" />, используя пространство, которое было ранее зарезервировано в последовательности. Наследовать этот метод нельзя.</summary>
        <returns>Порядковый номер добавленной в журнал записи.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данные, содержащиеся в параметре `data`, будут сцеплены в единый массив байтов для добавления в качестве записи. Однако не делается допущение об обратном разделении данных на фрагменты массива при чтении записи.  
  
 Добавленная запись будет занимать пространство, ранее зарезервированное с помощью резервирования, заданного параметром `reservations`. Если выполнить добавление удается, оно займет минимальную область резервирования, в которой поместятся данные, а эта область резервирования будет удалена из коллекции.  
  
 Обычно этот метод завершает работу до того, как запись будет записана. Чтобы запись точно была записана, либо укажите флаг <xref:System.IO.Log.RecordAppendOptions.ForceFlush> с помощью параметра `recordAppendOptions`, либо вызовите метод <xref:System.IO.Log.FileRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Один или несколько аргументов имеют значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Один или несколько аргументов выходят за пределы диапазона.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="reservations" /> не был создан этой последовательностью записи.</exception>
        <exception cref="T:System.NotSupportedException">Невозможно выполнить операцию, поскольку последовательность записей была открыта с доступом только для чтения.</exception>
        <exception cref="T:System.IO.IOException">Не удалось выполнить запрос, так как возникла неожиданная ошибка ввода-вывода.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательность записей заполнена.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">В <paramref name="data" /> не удается найти резервирование, достаточное для размещения параметра <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.FileRecordSequence.BaseSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber BaseSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.FileRecordSequence.BaseSequenceNumber" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.BaseSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает порядковый номер первой допустимой записи в текущем объекте <see cref="T:System.IO.Log.FileRecordSequence" />.</summary>
        <value>Самый низкий порядковый номер, соответствующий допустимой записи в последовательности <see cref="T:System.IO.Log.FileRecordSequence" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Допустимые порядковые номера больше или равны <xref:System.IO.Log.FileRecordSequence.BaseSequenceNumber%2A> и меньше <xref:System.IO.Log.FileRecordSequence.LastSequenceNumber%2A>. Все другие порядковые номера недопустимы.  
  
 Значение этого свойства можно изменить вызовом метода<xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A> или <xref:System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber%2A>.  
  
   
  
## Examples  
 В следующем примере показано использование свойства <xref:System.IO.Log.FileRecordSequence.BaseSequenceNumber%2A> в цикле:  
  
 [!code-csharp[IRecordSequence#2](~/samples/snippets/csharp/VS_Snippets_CFX/irecordsequence/cs/readrecord.cs#2)]
 [!code-vb[IRecordSequence#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/irecordsequence/vb/readrecord.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Обращение к свойству произошло после удаления последовательности.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Начинает асинхронную операцию добавления.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="nextUndoRecord">Порядковый номер следующей записи в порядке, заданном пользователем.</param>
        <param name="previousRecord">Порядковый номер следующей записи в обратном порядке.</param>
        <param name="recordAppendOptions">Допустимое значение объекта <see cref="T:System.IO.Log.RecordAppendOptions" />, задающего, как должны записываться данные.</param>
        <param name="callback">Необязательный асинхронный обратный вызов по завершении добавления.</param>
        <param name="state">Предоставляемый пользователем объект, отличающий конкретный запрос на асинхронное добавление от других запросов.</param>
        <summary>Начинает асинхронную операцию добавления. Наследовать этот метод нельзя.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, представляющий асинхронное добавление, которое может все еще ожидать выполнения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы обеспечить завершение операции добавления и освободить соответствующие ресурсы, необходимо передать значение <xref:System.IAsyncResult>, возвращенное этим методом, в метод <xref:System.IO.Log.FileRecordSequence.EndAppend%2A>. Если ошибка возникла при выполнении асинхронного добавления, исключение не будет создано до тех пор, пока метод <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> не будет вызван со значением <xref:System.IAsyncResult>, возвращенным данным методом.  
  
 Данные, содержащиеся в параметре `data`, будут сцеплены в единый массив байтов для добавления в качестве записи. Однако не делается допущение об обратном разделении данных на фрагменты массива при чтении записи.  
  
 Обычно этот метод завершает работу до того, как запись будет записана. Чтобы запись точно была записана, либо укажите флаг <xref:System.IO.Log.RecordAppendOptions.ForceFlush> с помощью параметра `recordAppendOptions`, либо вызовите метод <xref:System.IO.Log.FileRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Один или несколько аргументов имеют значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Один или несколько аргументов выходят за пределы диапазона.</exception>
        <exception cref="T:System.NotSupportedException">Невозможно выполнить операцию, поскольку последовательность записей была открыта с доступом только для чтения.</exception>
        <exception cref="T:System.IO.IOException">Выполнить запрос невозможно из-за непредвиденного исключения ввода-вывода.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательность записей заполнена.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="nextUndoRecord">Порядковый номер следующей записи в порядке, заданном пользователем.</param>
        <param name="previousRecord">Порядковый номер следующей записи в обратном порядке.</param>
        <param name="recordAppendOptions">Допустимое значение объекта <see cref="T:System.IO.Log.RecordAppendOptions" />, задающего, как должны записываться данные.</param>
        <param name="callback">Необязательный асинхронный обратный вызов по завершении добавления.</param>
        <param name="state">Предоставляемый пользователем объект, отличающий конкретный запрос на асинхронное добавление от других запросов.</param>
        <summary>Начинает асинхронную операцию добавления. Наследовать этот метод нельзя.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, представляющий асинхронное добавление, которое может все еще ожидать выполнения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы обеспечить завершение операции добавления и освободить соответствующие ресурсы, необходимо передать значение <xref:System.IAsyncResult>, возвращенное этим методом, в метод <xref:System.IO.Log.FileRecordSequence.EndAppend%2A>. Если ошибка возникла при выполнении асинхронного добавления, исключение не будет создано до тех пор, пока метод <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> не будет вызван со значением <xref:System.IAsyncResult>, возвращенным данным методом.  
  
 Данные, содержащиеся в параметре `data`, будут сцеплены в единый массив байтов для добавления в качестве записи. Однако не делается допущение об обратном разделении данных на фрагменты массива при чтении записи.  
  
 Обычно этот метод завершает работу до того, как запись будет записана. Чтобы запись точно была записана, либо укажите флаг <xref:System.IO.Log.RecordAppendOptions.ForceFlush> с помощью параметра `recordAppendOptions`, либо вызовите метод <xref:System.IO.Log.FileRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Один или несколько аргументов имеют значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Один или несколько аргументов выходят за пределы диапазона.</exception>
        <exception cref="T:System.NotSupportedException">Невозможно выполнить операцию, поскольку последовательность записей была открыта с доступом только для чтения.</exception>
        <exception cref="T:System.IO.IOException">Выполнить запрос невозможно из-за непредвиденного исключения ввода-вывода.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательность записей заполнена.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="nextUndoRecord">Порядковый номер следующей записи в порядке, заданном пользователем.</param>
        <param name="previousRecord">Порядковый номер следующей записи в обратном порядке.</param>
        <param name="recordAppendOptions">Допустимое значение объекта <see cref="T:System.IO.Log.RecordAppendOptions" />, задающего, как должны записываться данные.</param>
        <param name="reservations">Коллекция <see cref="T:System.IO.Log.ReservationCollection" />, содержащая резервирование, которое следует использовать для данной записи.</param>
        <param name="callback">Необязательный асинхронный обратный вызов по завершении добавления.</param>
        <param name="state">Предоставляемый пользователем объект, отличающий конкретный запрос на асинхронное добавление от других запросов.</param>
        <summary>Начинает асинхронную операцию добавления, используя пространство, которое было ранее зарезервировано в последовательности. Наследовать этот метод нельзя.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, представляющий асинхронное добавление, которое может все еще ожидать выполнения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы обеспечить завершение операции добавления и освободить соответствующие ресурсы, необходимо передать значение <xref:System.IAsyncResult>, возвращенное этим методом, в метод <xref:System.IO.Log.FileRecordSequence.EndAppend%2A>. Если ошибка возникла при выполнении асинхронного добавления, исключение не будет создано до тех пор, пока метод <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> не будет вызван со значением <xref:System.IAsyncResult>, возвращенным данным методом.  
  
 Данные, содержащиеся в параметре `data`, будут сцеплены в единый массив байтов для добавления в качестве записи. Однако не делается допущение об обратном разделении данных на фрагменты массива при чтении записи.  
  
 Добавленная запись будет занимать пространство, ранее зарезервированное с помощью резервирования, заданного параметром `reservations`. Если выполнить добавление удается, оно займет минимальную область резервирования, в которой поместятся данные, а эта область резервирования будет удалена из коллекции.  
  
 Обычно этот метод завершает работу до того, как запись будет записана. Чтобы запись точно была записана, либо укажите флаг <xref:System.IO.Log.RecordAppendOptions.ForceFlush> с помощью параметра `recordAppendOptions`, либо вызовите метод <xref:System.IO.Log.FileRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Один или несколько аргументов имеют значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Один или несколько аргументов выходят за пределы диапазона.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="reservations" /> не был создан этой последовательностью записи.</exception>
        <exception cref="T:System.NotSupportedException">Невозможно выполнить операцию, поскольку последовательность записей была открыта с доступом только для чтения.</exception>
        <exception cref="T:System.IO.IOException">Выполнить запрос невозможно из-за непредвиденного исключения ввода-вывода.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательность записей заполнена.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">В <paramref name="data" /> не удается найти резервирование, достаточное для размещения параметра <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="nextUndoRecord">Порядковый номер следующей записи в порядке, заданном пользователем.</param>
        <param name="previousRecord">Порядковый номер следующей записи в обратном порядке.</param>
        <param name="recordAppendOptions">Допустимое значение объекта <see cref="T:System.IO.Log.RecordAppendOptions" />, задающего, как должны записываться данные.</param>
        <param name="reservations">Коллекция <see cref="T:System.IO.Log.ReservationCollection" />, содержащая резервирование, которое следует использовать для данной записи.</param>
        <param name="callback">Необязательный асинхронный обратный вызов по завершении добавления.</param>
        <param name="state">Предоставляемый пользователем объект, отличающий конкретный запрос на асинхронное добавление от других запросов.</param>
        <summary>Начинает асинхронную операцию добавления, используя пространство, которое было ранее зарезервировано в последовательности. Наследовать этот метод нельзя.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, представляющий асинхронное добавление, которое может все еще ожидать выполнения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы обеспечить завершение операции добавления и освободить соответствующие ресурсы, необходимо передать значение <xref:System.IAsyncResult>, возвращенное этим методом, в метод <xref:System.IO.Log.FileRecordSequence.EndAppend%2A>. Если ошибка возникла при выполнении асинхронного добавления, исключение не будет создано до тех пор, пока метод <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> не будет вызван со значением <xref:System.IAsyncResult>, возвращенным данным методом.  
  
 Данные, содержащиеся в параметре `data`, будут сцеплены в единый массив байтов для добавления в качестве записи. Однако не делается допущение об обратном разделении данных на фрагменты массива при чтении записи.  
  
 Добавленная запись будет занимать пространство, ранее зарезервированное с помощью резервирования, заданного параметром `reservations`. Если выполнить добавление удается, оно займет минимальную область резервирования, в которой поместятся данные, а эта область резервирования будет удалена из коллекции.  
  
 Обычно этот метод завершает работу до того, как запись будет записана. Чтобы запись точно была записана, либо укажите флаг <xref:System.IO.Log.RecordAppendOptions.ForceFlush> с помощью параметра `recordAppendOptions`, либо вызовите метод <xref:System.IO.Log.FileRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Один или несколько аргументов имеют значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Один или несколько аргументов выходят за пределы диапазона.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="reservations" /> не был создан этой последовательностью записи.</exception>
        <exception cref="T:System.NotSupportedException">Невозможно выполнить операцию, поскольку последовательность записей была открыта с доступом только для чтения.</exception>
        <exception cref="T:System.IO.IOException">Выполнить запрос невозможно из-за непредвиденного исключения ввода-вывода.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательность записей заполнена.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">В <paramref name="data" /> не удается найти резервирование, достаточное для размещения параметра <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginFlush(valuetype System.IO.Log.SequenceNumber sequenceNumber, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginFlush(System::IO::Log::SequenceNumber sequenceNumber, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginFlush : System.IO.Log.SequenceNumber * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginFlush : System.IO.Log.SequenceNumber * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileRecordSequence.BeginFlush (sequenceNumber, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">Порядковый номер последней записи, которую требуется записать. Если номер <see cref="T:System.IO.Log.SequenceNumber" /> недопустим, необходимо зарегистрировать все записи.</param>
        <param name="callback">Необязательный асинхронный обратный вызов по завершении операции записи на диск.</param>
        <param name="state">Предоставляемый пользователем объект, являющийся отличительным признаком данного конкретного запроса на запись на диск от других запросов.</param>
        <summary>Начинает асинхронную операцию записи на диск, используя пространство, которое было ранее зарезервировано в последовательности. Наследовать этот метод нельзя.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, представляющий асинхронную операцию записи на диск, которая может все еще ожидать выполнения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Необходимо передать объект <xref:System.IAsyncResult>, возвращаемый текущим методом, методу <xref:System.IO.Log.FileRecordSequence.EndFlush%2A>, чтобы обеспечить завершение очистки и правильное освобождение ресурсов. Если ошибка возникает при выполнении асинхронной очистки, исключение не будет создано до тех пор, пока не будет вызван метод <xref:System.IO.Log.FileRecordSequence.EndFlush%2A> с объектом <xref:System.IAsyncResult>, возвращаемым данным методом.  
  
 Вызов этого метода гарантирует, что внесены все записи, добавленные в последовательность <xref:System.IO.Log.FileRecordSequence>.  
  
 Если последовательность записей была удалена, или если передается неверный аргумент, исключения создаются немедленно, в пределах данной операции. Ошибки, возникшие при выполнении запроса асинхронной очистки, например ошибка диска в процессе запроса ввода-вывода, приводят к созданию исключений при вызове метода <xref:System.IO.Log.FileRecordSequence.EndFlush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Один или несколько аргументов являются недопустимыми.  
  
 Значение параметра <paramref name="sequenceNumber" /> недопустимо для этой последовательности.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="sequenceNumber" /> не находится в пределах этой последовательности.</exception>
        <exception cref="T:System.IO.IOException">При очистке данных произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Начинает асинхронную операцию резервирования и добавления.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileRecordSequence.BeginReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="nextUndoRecord">Порядковый номер следующей записи в порядке, заданном пользователем.</param>
        <param name="previousRecord">Порядковый номер следующей записи в обратном порядке.</param>
        <param name="recordAppendOptions">Допустимое значение объекта <see cref="T:System.IO.Log.RecordAppendOptions" />, задающего, как должны записываться данные.</param>
        <param name="reservationCollection">Коллекция резервирования, в которой требуется сделать резервирования.</param>
        <param name="reservations">Размер необходимого резервирования (в байтах).</param>
        <param name="callback">Необязательный асинхронный обратный вызов по завершении добавления.</param>
        <param name="state">Предоставляемый пользователем объект, отличающий конкретный запрос на асинхронное добавление от других запросов.</param>
        <summary>Начинает асинхронную операцию резервирования и добавления. Наследовать этот метод нельзя.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, представляющий данную асинхронную операцию, которая может все еще ожидать выполнения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы обеспечить завершение операции добавления и освободить соответствующие ресурсы, необходимо передать значение <xref:System.IAsyncResult>, возвращенное этим методом, в метод <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>. Если ошибка возникла при выполнении асинхронного добавления, исключение не будет создано до тех пор, пока метод <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> не будет вызван со значением <xref:System.IAsyncResult>, возвращенным данным методом.  
  
 Данные, содержащиеся в параметре `data`, будут сцеплены в единый массив байтов для добавления в качестве записи. Однако не делается допущение об обратном разделении данных на фрагменты массива при чтении записи.  
  
 Заданные резервирования добавляются в предоставленную коллекцию резервирования при помощи атомарной операции добавления записи. Если выполнить добавление не удается, место не резервируется.  
  
 Обычно этот метод может завершить работу до того, как запись будет записана. Чтобы запись точно была записана, либо укажите флаг <xref:System.IO.Log.RecordAppendOptions.ForceFlush> с помощью параметра `recordAppendOptions`, либо вызовите метод <xref:System.IO.Log.FileRecordSequence.Flush%2A>.  
  
 Если последовательность записей была удалена, или если передается неверный аргумент, исключения создаются немедленно, в пределах данной операции. Ошибки, возникшие при выполнении запроса асинхронного добавления, например ошибка диска в процессе запроса ввода-вывода, приводят к созданию исключений при вызове метода <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Один или несколько аргументов имеют значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Один или несколько аргументов выходят за пределы диапазона.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="reservations" /> не был создан этой последовательностью записи.</exception>
        <exception cref="T:System.NotSupportedException">Невозможно выполнить операцию, поскольку последовательность записей была открыта с доступом только для чтения.</exception>
        <exception cref="T:System.IO.IOException">Не удалось выполнить запрос, так как возникла неожиданная ошибка ввода-вывода.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательность записей заполнена.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">В <paramref name="data" /> не удается найти резервирование, достаточное для размещения параметра <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileRecordSequence.BeginReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="nextUndoRecord">Порядковый номер следующей записи в порядке, заданном пользователем.</param>
        <param name="previousRecord">Порядковый номер следующей записи в обратном порядке.</param>
        <param name="recordAppendOptions">Допустимое значение объекта <see cref="T:System.IO.Log.RecordAppendOptions" />, задающего, как должны записываться данные.</param>
        <param name="reservationCollection">Коллекция резервирования, в которой требуется сделать резервирования.</param>
        <param name="reservations">Размер необходимого резервирования (в байтах).</param>
        <param name="callback">Необязательный асинхронный обратный вызов по завершении добавления.</param>
        <param name="state">Предоставляемый пользователем объект, отличающий конкретный запрос на асинхронное добавление от других запросов.</param>
        <summary>Начинает асинхронную операцию резервирования и добавления. Наследовать этот метод нельзя.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, представляющий данную асинхронную операцию, которая может все еще ожидать выполнения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы обеспечить завершение операции добавления и освободить соответствующие ресурсы, необходимо передать значение <xref:System.IAsyncResult>, возвращенное этим методом, в метод <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>. Если ошибка возникла при выполнении асинхронного добавления, исключение не будет создано до тех пор, пока метод <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> не будет вызван со значением <xref:System.IAsyncResult>, возвращенным данным методом.  
  
 Данные, содержащиеся в параметре `data`, будут сцеплены в единый массив байтов для добавления в качестве записи. Однако не делается допущение об обратном разделении данных на фрагменты массива при чтении записи.  
  
 Заданные резервирования добавляются в предоставленную коллекцию резервирования при помощи атомарной операции добавления записи. Если выполнить добавление не удается, место не резервируется.  
  
 Обычно этот метод может завершить работу до того, как запись будет записана. Чтобы запись точно была записана, либо укажите флаг <xref:System.IO.Log.RecordAppendOptions.ForceFlush> с помощью параметра `recordAppendOptions`, либо вызовите метод <xref:System.IO.Log.FileRecordSequence.Flush%2A>.  
  
 Если последовательность записей была удалена, или если передается неверный аргумент, исключения создаются немедленно, в пределах данной операции. Ошибки, возникшие при выполнении запроса асинхронного добавления, например ошибка диска в процессе запроса ввода-вывода, приводят к созданию исключений при вызове метода <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Один или несколько аргументов имеют значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Один или несколько аргументов выходят за пределы диапазона.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="reservations" /> не был создан этой последовательностью записи.</exception>
        <exception cref="T:System.NotSupportedException">Невозможно выполнить операцию, поскольку последовательность записей была открыта с доступом только для чтения.</exception>
        <exception cref="T:System.IO.IOException">Не удалось выполнить запрос, так как возникла неожиданная ошибка ввода-вывода.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательность записей заполнена.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">В <paramref name="data" /> не удается найти резервирование, достаточное для размещения параметра <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginWriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Начинает операцию записи в область перезапуска.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginWriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginWriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileRecordSequence.BeginWriteRestartArea (data, newBaseSeqNum, reservation, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="newBaseSeqNum">Новый базовый порядковый номер. Заданный порядковый номер должен быть больше или равен текущему базовому порядковому номеру.</param>
        <param name="reservation">Коллекция <see cref="T:System.IO.Log.ReservationCollection" />, содержащая резервирование, которое следует использовать для данной области перезапуска.</param>
        <param name="callback">Необязательный асинхронный обратный вызов по завершении записи в области перезапуска.</param>
        <param name="state">Предоставляемый пользователем объект, отличающий конкретный запрос на асинхронную запись в область перезапуска от других запросов.</param>
        <summary>Начинает асинхронную операцию записи в область перезапуска, используя пространство, которое было ранее зарезервировано в последовательности. Наследовать этот метод нельзя.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" /> представляет асинхронную операцию записи в область перезапуска, которая может все еще быть отложена.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы обеспечить завершение операции записи в область перезапуска и освободить соответствующие ресурсы, необходимо передать значение <xref:System.IAsyncResult>, возвращенное этим методом, в метод <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>. Если ошибка возникла при выполнении операции асинхронной записи в область перезапуска, исключение не будет создано до тех пор, пока метод <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> не будет вызван со значением <xref:System.IAsyncResult>, возвращенным данным методом.  
  
 Данные, содержащиеся в параметре `data`, будут сцеплены в единый массив байтов для добавления в качестве записи. Однако не делается допущение об обратном разделении данных на фрагменты массива при чтении записи.  
  
 При успешном выполнении операции базовый порядковый номер обновляется. Все записи журнала с порядковыми номерами меньшими, чем новый базовый порядковый номер, недоступны.  
  
 Если задано <xref:System.IO.Log.ReservationCollection>, записанная область перезапуска будет занимать место, ранее зарезервированное с помощью содержащегося в коллекции резервирования. Если метод завершается успешно, будет занята минимальная область резервирования, в которой поместятся данные, а эта область резервирования будет удалена из коллекции.  
  
 Если последовательность записей была удалена, или если передается неверный аргумент, исключения создаются немедленно, в пределах данной операции. Ошибки, возникшие при выполнении запроса асинхронного добавления, например ошибка диска в процессе запроса ввода-вывода, приводят к созданию исключений при вызове метода <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Один или несколько аргументов имеют значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="newBaseSeqNum" /> не находится в пределах этой последовательности.  
  
- или - 
Новая или существующая архивная цепочка или база активного журнала недействительна.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="reservations" /> не был создан этой последовательностью записи.  
  
- или - 
 Значение параметра <paramref name="newBaseSeqNum" /> недопустимо для этой последовательности.</exception>
        <exception cref="T:System.NotSupportedException">Невозможно выполнить операцию, поскольку последовательность записей была открыта с доступом только для чтения.</exception>
        <exception cref="T:System.IO.IOException">Выполнить запрос невозможно из-за непредвиденного исключения ввода-вывода.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательность записей заполнена.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">В <paramref name="data" /> не удается найти резервирование, достаточное для размещения параметра <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSeqNum As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginWriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginWriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileRecordSequence.BeginWriteRestartArea (data, newBaseSeqNum, reservation, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="newBaseSeqNum">Новый базовый порядковый номер. Заданный порядковый номер должен быть больше или равен текущему базовому порядковому номеру.</param>
        <param name="reservation">Коллекция <see cref="T:System.IO.Log.ReservationCollection" />, содержащая резервирование, которое следует использовать для данной области перезапуска.</param>
        <param name="callback">Необязательный асинхронный обратный вызов по завершении записи в области перезапуска.</param>
        <param name="state">Предоставляемый пользователем объект, отличающий конкретный запрос на асинхронную запись в область перезапуска от других запросов.</param>
        <summary>Начинает асинхронную операцию записи в область перезапуска, используя пространство, которое было ранее зарезервировано в последовательности. Наследовать этот метод нельзя.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" /> представляет асинхронную операцию записи в область перезапуска, которая может все еще быть отложена.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы обеспечить завершение операции записи в область перезапуска и освободить соответствующие ресурсы, необходимо передать значение <xref:System.IAsyncResult>, возвращенное этим методом, в метод <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>. Если ошибка возникла при выполнении операции асинхронной записи в область перезапуска, исключение не будет создано до тех пор, пока метод <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> не будет вызван со значением <xref:System.IAsyncResult>, возвращенным данным методом.  
  
 Данные, содержащиеся в параметре `data`, будут сцеплены в единый массив байтов для добавления в качестве записи. Однако не делается допущение об обратном разделении данных на фрагменты массива при чтении записи.  
  
 При успешном выполнении операции базовый порядковый номер обновляется. Все записи журнала с порядковыми номерами меньшими, чем новый базовый порядковый номер, недоступны.  
  
 Если задано <xref:System.IO.Log.ReservationCollection>, записанная область перезапуска будет занимать место, ранее зарезервированное с помощью содержащегося в коллекции резервирования. Если метод завершается успешно, будет занята минимальная область резервирования, в которой поместятся данные, а эта область резервирования будет удалена из коллекции.  
  
 Если последовательность записей была удалена, или если передается неверный аргумент, исключения создаются немедленно, в пределах данной операции. Ошибки, возникшие при выполнении запроса асинхронного добавления, например ошибка диска в процессе запроса ввода-вывода, приводят к созданию исключений при вызове метода <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Один или несколько аргументов имеют значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="newBaseSeqNum" /> не находится в пределах этой последовательности.  
  
- или - 
Новая или существующая архивная цепочка или база активного журнала недействительна.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="reservations" /> не был создан этой последовательностью записи.  
  
-или- 
 Значение параметра <paramref name="newBaseSeqNum" /> недопустимо для этой последовательности.</exception>
        <exception cref="T:System.NotSupportedException">Невозможно выполнить операцию, поскольку последовательность записей была открыта с доступом только для чтения.</exception>
        <exception cref="T:System.IO.IOException">Выполнить запрос невозможно из-за непредвиденного исключения ввода-вывода.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательность записей заполнена.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">В <paramref name="data" /> не удается найти резервирование, достаточное для размещения параметра <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateReservationCollection">
      <MemberSignature Language="C#" Value="public System.IO.Log.ReservationCollection CreateReservationCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Log.ReservationCollection CreateReservationCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.CreateReservationCollection" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateReservationCollection () As ReservationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::ReservationCollection ^ CreateReservationCollection();" />
      <MemberSignature Language="F#" Value="abstract member CreateReservationCollection : unit -&gt; System.IO.Log.ReservationCollection&#xA;override this.CreateReservationCollection : unit -&gt; System.IO.Log.ReservationCollection" Usage="fileRecordSequence.CreateReservationCollection " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.CreateReservationCollection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.ReservationCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает новый экземпляр <see cref="T:System.IO.Log.ReservationCollection" />. Наследовать этот метод нельзя.</summary>
        <returns>Вновь созданный <see cref="T:System.IO.Log.ReservationCollection" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="fileRecordSequence.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Немедленно освобождает неуправляемые ресурсы, используемые объектом.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IO.IOException">При очистке данных произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.EndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndAppend(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.EndAppend result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Ссылка на невыполненный асинхронный запрос ввода-вывода.</param>
        <summary>Завершает асинхронную операцию добавления. Наследовать этот метод нельзя.</summary>
        <returns>Порядковый номер добавленной в журнал записи.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод блокируется до завершения операции ввода-вывода. Ошибки, возникающие при выполнении запроса асинхронной записи, например ошибка диска в процессе запроса ввода-вывода, отображаются при вызове <xref:System.IO.Log.FileRecordSequence.EndAppend%2A>.  
  
 Этот метод должен вызываться ровно по одному разу для каждого объекта <xref:System.IAsyncResult>, возвращенного методом <xref:System.IO.Log.FileRecordSequence.BeginAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="result" /> недопустим.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see langword="End" /> уже был вызван для данной асинхронной операции.</exception>
        <exception cref="T:System.IO.IOException">Выполнить запрос невозможно из-за непредвиденного исключения ввода-вывода.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndFlush(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndFlush (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndFlush(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndFlush : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndFlush : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.EndFlush result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Ссылка на невыполненный асинхронный запрос ввода-вывода.</param>
        <summary>Завершает асинхронную операцию записи на диск. Наследовать этот метод нельзя.</summary>
        <returns>Порядковый номер последней записи, которая была записана.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод блокируется до завершения операции ввода-вывода. Ошибки, возникающие при выполнении запроса асинхронной очистки, например ошибка диска в процессе запроса ввода-вывода, отображаются при вызове <xref:System.IO.Log.FileRecordSequence.EndFlush%2A>.  
  
 Этот метод должен вызываться ровно по одному разу для каждого объекта <xref:System.IAsyncResult>, возвращенного методом <xref:System.IO.Log.FileRecordSequence.BeginFlush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="result" /> недопустим.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see langword="End" /> уже был вызван для данной асинхронной операции.</exception>
        <exception cref="T:System.IO.IOException">Выполнить запрос невозможно из-за непредвиденного исключения ввода-вывода.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndReserveAndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.EndReserveAndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReserveAndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndReserveAndAppend(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndReserveAndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndReserveAndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.EndReserveAndAppend result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Ссылка на невыполненный асинхронный запрос ввода-вывода.</param>
        <summary>Завершает асинхронную операцию резервирования и добавления. Наследовать этот метод нельзя.</summary>
        <returns>Порядковый номер добавленной в журнал записи.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод блокируется до завершения операции ввода-вывода. Ошибки, возникающие при выполнении запроса асинхронной записи, например ошибка диска в процессе запроса ввода-вывода, отображаются при вызове <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>.  
  
 Этот метод должен вызываться ровно по одному разу для каждого объекта <xref:System.IAsyncResult>, возвращенного методом <xref:System.IO.Log.FileRecordSequence.BeginReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="result" /> недопустим.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see langword="End" /> уже был вызван для данной асинхронной операции.</exception>
        <exception cref="T:System.IO.IOException">Выполнить запрос невозможно из-за непредвиденного исключения ввода-вывода.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndWriteRestartArea(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.EndWriteRestartArea(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndWriteRestartArea (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndWriteRestartArea(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndWriteRestartArea : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndWriteRestartArea : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.EndWriteRestartArea result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Ссылка на невыполненный асинхронный запрос ввода-вывода.</param>
        <summary>Завершает операцию записи в область перезапуска. Наследовать этот метод нельзя.</summary>
        <returns>Порядковый номер записанной в журнал записи.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод блокируется до завершения операции ввода-вывода. Ошибки, возникающие при выполнении запроса асинхронной записи, например ошибка диска в процессе запроса ввода-вывода, отображаются при вызове <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>.  
  
 Этот метод должен вызываться ровно по одному разу для каждого объекта <xref:System.IAsyncResult>, возвращенного методом <xref:System.IO.Log.FileRecordSequence.BeginWriteRestartArea%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="result" /> недопустим.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see langword="End" /> уже был вызван для данной асинхронной операции.</exception>
        <exception cref="T:System.IO.IOException">Выполнить запрос невозможно из-за непредвиденного исключения ввода-вывода.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет устойчивую запись всех добавленных записей.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Function Flush () As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Flush();" />
      <MemberSignature Language="F#" Value="abstract member Flush : unit -&gt; System.IO.Log.SequenceNumber&#xA;override this.Flush : unit -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.Flush " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Flush</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Обеспечивает запись всех добавленных записей. Наследовать этот метод нельзя.</summary>
        <returns>Порядковый номер последней записи, которая была записана.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов этого метода гарантирует выполнение устойчивых записей, добавленных в последовательность <xref:System.IO.Log.FileRecordSequence>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">При очистке данных произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush(valuetype System.IO.Log.SequenceNumber sequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.Flush(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Flush(System::IO::Log::SequenceNumber sequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member Flush : System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber&#xA;override this.Flush : System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.Flush sequenceNumber" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">Порядковый номер последней записи, которую требуется записать. Если этот номер <see cref="T:System.IO.Log.SequenceNumber" /> недопустим, необходимо записать все записи.</param>
        <summary>Обеспечивает запись всех добавленных записей. Наследовать этот метод нельзя.</summary>
        <returns>Порядковый номер последней записи, которая была записана.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов этого метода обеспечивает устойчивую запись всех записей до указанного порядкового номера включительно.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="sequenceNumber" /> не находится в пределах этой последовательности.</exception>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="sequenceNumber" /> недопустимо для этой последовательности.</exception>
        <exception cref="T:System.IO.IOException">При очистке данных произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.FileRecordSequence.LastSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber LastSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.LastSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.FileRecordSequence.LastSequenceNumber" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.LastSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает порядковый номер, превышающий последнюю добавленную запись.</summary>
        <value>Порядковый номер, превышающий последнюю добавленную запись.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данное свойство содержит порядковый номер, который гарантированно больше, чем порядковый номер последней добавленной записи. Допустимые порядковые номера больше или равны <xref:System.IO.Log.FileRecordSequence.BaseSequenceNumber%2A> и меньше <xref:System.IO.Log.FileRecordSequence.LastSequenceNumber%2A>. Все другие порядковые номера недопустимы.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Обращение к свойству произошло после удаления последовательности.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumRecordLength">
      <MemberSignature Language="C#" Value="public long MaximumRecordLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumRecordLength" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.FileRecordSequence.MaximumRecordLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaximumRecordLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumRecordLength { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumRecordLength : int64" Usage="System.IO.Log.FileRecordSequence.MaximumRecordLength" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.MaximumRecordLength</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает размер в байтах наибольшей записи, которую можно добавить или прочитать из последовательности.</summary>
        <value>Размер в байтах наибольшей записи, которую можно добавить или прочитать из последовательности.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Обращение к свойству произошло после удаления последовательности.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLogRecords">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadLogRecords(valuetype System.IO.Log.SequenceNumber start, valuetype System.IO.Log.LogRecordEnumeratorType logRecordEnum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLogRecords (start As SequenceNumber, logRecordEnum As LogRecordEnumeratorType) As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadLogRecords(System::IO::Log::SequenceNumber start, System::IO::Log::LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="F#" Value="abstract member ReadLogRecords : System.IO.Log.SequenceNumber * System.IO.Log.LogRecordEnumeratorType -&gt; seq&lt;System.IO.Log.LogRecord&gt;&#xA;override this.ReadLogRecords : System.IO.Log.SequenceNumber * System.IO.Log.LogRecordEnumeratorType -&gt; seq&lt;System.IO.Log.LogRecord&gt;" Usage="fileRecordSequence.ReadLogRecords (start, logRecordEnum)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="logRecordEnum" Type="System.IO.Log.LogRecordEnumeratorType" />
      </Parameters>
      <Docs>
        <param name="start">Порядковый номер первой записи, с которой начинается чтение.</param>
        <param name="logRecordEnum">Допустимое значение <see cref="T:System.IO.Log.LogRecordEnumeratorType" />, указывающее способ (вперед или назад), которым записи должны считываться из <see cref="T:System.IO.Log.LogRecordSequence" />.</param>
        <summary>Возвращает перечислимую коллекцию записей в последовательности. Наследовать этот метод нельзя.</summary>
        <returns>Перечисляемая коллекция записей в последовательности.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает перечисляемую коллекцию записей в последовательности. Порядок перечисленных записей зависит от значения параметра `logRecordEnum`.  
  
   
  
## Examples  
 В следующем примере показано, как использовать этот метод для чтения записей в последовательности журналов.  
  
 [!code-csharp[IRecordSequence#2](~/samples/snippets/csharp/VS_Snippets_CFX/irecordsequence/cs/readrecord.cs#2)]
 [!code-vb[IRecordSequence#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/irecordsequence/vb/readrecord.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Один или несколько аргументов выходят за пределы диапазона.</exception>
        <exception cref="T:System.NotSupportedException">Невозможно выполнить операцию, поскольку последовательность записей была открыта с доступом только для записи.</exception>
        <exception cref="T:System.IO.IOException">Последовательность записей повреждена.  
  
 - или -  
  
 Запись была сделана с помощью несовместимой версии последовательности записей.</exception>
        <exception cref="T:System.InvalidOperationException">Перечисление завершено.  
  
-или- 
Перечисление не запущено. Должен быть вызван метод <see cref="M:System.Collections.IEnumerator.MoveNext" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadRestartAreas">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadRestartAreas ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadRestartAreas() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.ReadRestartAreas" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadRestartAreas () As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadRestartAreas();" />
      <MemberSignature Language="F#" Value="abstract member ReadRestartAreas : unit -&gt; seq&lt;System.IO.Log.LogRecord&gt;&#xA;override this.ReadRestartAreas : unit -&gt; seq&lt;System.IO.Log.LogRecord&gt;" Usage="fileRecordSequence.ReadRestartAreas " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReadRestartAreas</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает перечисляемую коллекцию областей перезапуска в последовательности. Наследовать этот метод нельзя.</summary>
        <returns>Перечисляемая коллекция областей перезапуска в последовательности.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Области перезапуска перечислены в обратном порядке их номеров, т.е. от самого высокого порядкового номера до самого низкого. Выполняется перечисление только областей перезапуска между последним и базовым порядковым номером.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Невозможно выполнить операцию, поскольку последовательность записей была открыта с доступом только для записи.</exception>
        <exception cref="T:System.IO.IOException">Последовательность записей повреждена.  
  
 - или -  
  
 Запись была сделана с помощью несовместимой версии последовательности записей.</exception>
        <exception cref="T:System.InvalidOperationException">Перечисление завершено.  
  
- или - 
Перечисление не запущено. Должен быть вызван метод <see cref="M:System.Collections.IEnumerator.MoveNext" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Автоматически делает одно резервирование и добавляет запись в последовательность.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber ReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member ReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber&#xA;override this.ReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.ReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="nextUndoRecord">Порядковый номер следующей записи в порядке, заданном пользователем.</param>
        <param name="previousRecord">Порядковый номер следующей записи в обратном порядке.</param>
        <param name="recordAppendOptions">Допустимое значение объекта <see cref="T:System.IO.Log.RecordAppendOptions" />, задающего, как должны записываться данные.</param>
        <param name="reservationCollection">Объект <see cref="T:System.IO.Log.ReservationCollection" />, содержащий коллекцию, в которой создается резервирование.</param>
        <param name="reservations">Размер необходимого резервирования (в байтах).</param>
        <summary>Автоматически делает одно резервирование и добавляет запись в последовательность. Наследовать этот метод нельзя.</summary>
        <returns>Порядковый номер добавленной в журнал записи.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данные, содержащиеся в параметре `data`, будут сцеплены в единый массив байтов для добавления в качестве записи. Однако не делается допущение об обратном разделении данных на фрагменты массива при чтении записи.  
  
 Заданные резервирования добавляются в предоставленную коллекцию резервирования при помощи атомарной операции добавления записи. Если выполнить добавление не удается, место не резервируется.  
  
 Обычно этот метод может завершить работу до того, как запись будет записана. Чтобы запись точно была записана, либо укажите флаг <xref:System.IO.Log.RecordAppendOptions.ForceFlush> с помощью параметра `recordAppendOptions`, либо вызовите метод <xref:System.IO.Log.FileRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Один или несколько аргументов имеют значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Один или несколько аргументов выходят за пределы диапазона.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="reservations" /> не был создан этой последовательностью записи.</exception>
        <exception cref="T:System.NotSupportedException">Невозможно выполнить операцию, поскольку последовательность записей была открыта с доступом только для чтения.</exception>
        <exception cref="T:System.IO.IOException">Не удалось выполнить запрос, так как возникла неожиданная ошибка ввода-вывода.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательность записей заполнена.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber ReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member ReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber&#xA;override this.ReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.ReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="nextUndoRecord">Порядковый номер следующей записи в порядке, заданном пользователем.</param>
        <param name="previousRecord">Порядковый номер следующей записи в обратном порядке.</param>
        <param name="recordAppendOptions">Допустимое значение объекта <see cref="T:System.IO.Log.RecordAppendOptions" />, задающего, как должны записываться данные.</param>
        <param name="reservationCollection">Коллекция резервирования, в которой требуется сделать резервирования.</param>
        <param name="reservations">Размер необходимого резервирования (в байтах).</param>
        <summary>Автоматически делает одно резервирование и добавляет запись в последовательность. Наследовать этот метод нельзя.</summary>
        <returns>Порядковый номер добавленной в журнал записи.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данные, содержащиеся в параметре `data`, будут сцеплены в единый массив байтов для добавления в качестве записи. Однако не делается допущение об обратном разделении данных на фрагменты массива при чтении записи.  
  
 Заданные резервирования добавляются в предоставленную коллекцию резервирования при помощи атомарной операции добавления записи. Если выполнить добавление не удается, место не резервируется.  
  
 Обычно этот метод может завершить работу до того, как запись будет записана. Чтобы запись точно была записана, либо укажите флаг <xref:System.IO.Log.RecordAppendOptions.ForceFlush> с помощью параметра `recordAppendOptions`, либо вызовите метод <xref:System.IO.Log.FileRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Один или несколько аргументов имеют значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Один или несколько аргументов выходят за пределы диапазона.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="reservations" /> не был создан этой последовательностью записи.</exception>
        <exception cref="T:System.NotSupportedException">Невозможно выполнить операцию, поскольку последовательность записей была открыта с доступом только для чтения.</exception>
        <exception cref="T:System.IO.IOException">Не удалось выполнить запрос, так как возникла неожиданная ошибка ввода-вывода.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательность записей заполнена.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReservedBytes">
      <MemberSignature Language="C#" Value="public long ReservedBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ReservedBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.FileRecordSequence.ReservedBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReservedBytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ReservedBytes { long get(); };" />
      <MemberSignature Language="F#" Value="member this.ReservedBytes : int64" Usage="System.IO.Log.FileRecordSequence.ReservedBytes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.ReservedBytes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает общее число зарезервированных байтов.</summary>
        <value>Общий размер резервирований, созданных в последовательности записей.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Обращение к свойству произошло после удаления последовательности.</exception>
      </Docs>
    </Member>
    <Member MemberName="RestartSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber RestartSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.FileRecordSequence.RestartSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestartSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber RestartSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.RestartSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.FileRecordSequence.RestartSequenceNumber" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.RestartSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает порядковый номер последней записанной области перезапуска.</summary>
        <value>Порядковый номер последней записанной области перезапуска.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Область перезапуска служит для временного хранения сведений, содержащих последнюю операцию контрольной точки клиента. Файловая система CLFS поддерживает две области перезапуска, чтобы всегда была доступна хотя бы одна действительная область. Если требуется выполнить восстановление, файловая система CLFS читает область перезапуска и все данные с последней операции контрольной точки. Эти данные инициализирует таблицу транзакций, таблицу "грязных страниц" и таблицу открытых файлов, чтобы их можно было использовать в процессе восстановления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Обращение к свойству произошло после удаления последовательности.</exception>
      </Docs>
    </Member>
    <Member MemberName="RetryAppend">
      <MemberSignature Language="C#" Value="public bool RetryAppend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RetryAppend" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.FileRecordSequence.RetryAppend" />
      <MemberSignature Language="VB.NET" Value="Public Property RetryAppend As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RetryAppend { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RetryAppend : bool with get, set" Usage="System.IO.Log.FileRecordSequence.RetryAppend" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.RetryAppend</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, выполняется ли повторная автоматическая попытка добавления в случае заполнения журнала.</summary>
        <value>Значение <see langword="true" />, если выполняется автоматическая повторная попытка добавления при заполнении журнала; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если значением данного свойства является `true` и происходит сбой вызова <xref:System.IO.Log.FileRecordSequence.Append%2A> из-за недостатка места в последовательности, последовательность записей пытается освободить место и совершает повторную попытку добавления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Обращение к свойству произошло после удаления последовательности.</exception>
      </Docs>
    </Member>
    <Member MemberName="TailPinned">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; TailPinned;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IO.Log.TailPinnedEventArgs&gt; TailPinned" />
      <MemberSignature Language="DocId" Value="E:System.IO.Log.FileRecordSequence.TailPinned" />
      <MemberSignature Language="VB.NET" Value="Public Event TailPinned As EventHandler(Of TailPinnedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler&lt;System::IO::Log::TailPinnedEventArgs ^&gt; ^ TailPinned;" />
      <MemberSignature Language="F#" Value="member this.TailPinned : EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; " Usage="member this.TailPinned : System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.IO.Log.IRecordSequence.TailPinned</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда последовательность записей определяет завершающую часть, которую необходимо переместить вперед. Наследовать этот метод нельзя.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие можно создать, когда в последовательности записей закончилось свободное пространство. При создании этого события завершающая часть последовательности (то есть базовый порядковый номер) перемещается вперед для освобождения места.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Записывает область перезапуска в объект <see cref="T:System.IO.Log.FileRecordSequence" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Область перезапуска можно использовать для временного хранения сведений, содержащих последнюю операцию контрольной точки клиента. Если требуется выполнить восстановление, можно прочитать область перезапуска и извлечь все данные с последней операции контрольной точки. Эти данные инициализирует таблицу транзакций, таблицу "грязных страниц" и таблицу открытых файлов, чтобы их можно было использовать в процессе восстановления.  
  
 Чтение области перезапуска возможно с помощью метода <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte)) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : ArraySegment&lt;byte&gt; -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.WriteRestartArea data" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <summary>Записывает область перезапуска в объект <see cref="T:System.IO.Log.FileRecordSequence" />. Наследовать этот метод нельзя.</summary>
        <returns>Порядковый номер записанной области перезапуска.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Область перезапуска можно использовать для временного хранения сведений, содержащих последнюю операцию контрольной точки клиента. Если требуется выполнить восстановление, можно прочитать область перезапуска и извлечь все данные с последней операции контрольной точки. Эти данные инициализирует таблицу транзакций, таблицу "грязных страниц" и таблицу открытых файлов, чтобы их можно было использовать в процессе восстановления.  
  
 Чтение области перезапуска возможно с помощью метода <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>.  
  
 Данные в этих фрагментах массива байтов будут сцеплены в единый массив байтов для добавления в качестве записи. Не делается никаких допущений об обратном разделении данных на фрагменты массива при чтении области перезапуска.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Один или несколько аргументов имеют значение <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Невозможно выполнить операцию, поскольку последовательность записей была открыта с доступом только для чтения.</exception>
        <exception cref="T:System.IO.IOException">Выполнить запрос невозможно из-за непредвиденного исключения ввода-вывода.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательность записей заполнена.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte))) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.WriteRestartArea data" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <summary>Записывает область перезапуска в объект <see cref="T:System.IO.Log.FileRecordSequence" />. Наследовать этот метод нельзя.</summary>
        <returns>Порядковый номер записанной области перезапуска.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Область перезапуска можно использовать для временного хранения сведений, содержащих последнюю операцию контрольной точки клиента. Если требуется выполнить восстановление, можно прочитать область перезапуска и извлечь все данные с последней операции контрольной точки. Эти данные инициализирует таблицу транзакций, таблицу "грязных страниц" и таблицу открытых файлов, чтобы их можно было использовать в процессе восстановления.  
  
 Чтение области перезапуска возможно с помощью метода <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>.  
  
 Данные в этих фрагментах массива байтов будут сцеплены в единый массив байтов для добавления в качестве записи. Не делается никаких допущений об обратном разделении данных на фрагменты массива при чтении области перезапуска.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Один или несколько аргументов имеют значение <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Невозможно выполнить операцию, поскольку последовательность записей была открыта с доступом только для чтения.</exception>
        <exception cref="T:System.IO.IOException">Выполнить запрос невозможно из-за непредвиденного исключения ввода-вывода.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательность записей заполнена.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.WriteRestartArea (data, newBaseSeqNum)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="newBaseSeqNum">Новый базовый порядковый номер. Заданный порядковый номер должен быть больше или равен текущему базовому порядковому номеру.</param>
        <summary>Записывает область перезапуска в объект <see cref="T:System.IO.Log.FileRecordSequence" />. Наследовать этот метод нельзя.</summary>
        <returns>Порядковый номер записанной области перезапуска.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Область перезапуска можно использовать для временного хранения сведений, содержащих последнюю операцию контрольной точки клиента. Если требуется выполнить восстановление, можно прочитать область перезапуска и извлечь все данные с последней операции контрольной точки. Эти данные инициализирует таблицу транзакций, таблицу "грязных страниц" и таблицу открытых файлов, чтобы их можно было использовать в процессе восстановления.  
  
 Чтение области перезапуска возможно с помощью метода <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>.  
  
 При записи области перезапуска данные в этих фрагментах массива байтов сцепляются в единый массив байтов для добавления в качестве записи. Не делается никаких допущений об обратном разделении данных на фрагменты массива при чтении области перезапуска.  
  
 При успешном выполнении этого метода базовый порядковый номер обновляется. Все записи журнала с порядковыми номерами меньшими, чем новый базовый порядковый номер, недоступны.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Один или несколько аргументов имеют значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="newBaseSeqNum" /> не находится в пределах этой последовательности.  
  
-или- 
Новая или существующая архивная цепочка или база активного журнала недействительна.</exception>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="newBaseSeqNum" /> недопустимо для этой последовательности.</exception>
        <exception cref="T:System.NotSupportedException">Невозможно выполнить операцию, поскольку последовательность записей была открыта с доступом только для чтения.</exception>
        <exception cref="T:System.IO.IOException">Выполнить запрос невозможно из-за непредвиденного исключения ввода-вывода.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательность записей заполнена.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSeqNum As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.WriteRestartArea (data, newBaseSeqNum)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="newBaseSeqNum">Новый базовый порядковый номер. Заданный порядковый номер должен быть больше или равен текущему базовому порядковому номеру.</param>
        <summary>Записывает область перезапуска в объект <see cref="T:System.IO.Log.FileRecordSequence" />. Наследовать этот метод нельзя.</summary>
        <returns>Порядковый номер записанной области перезапуска.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Область перезапуска можно использовать для временного хранения сведений, содержащих последнюю операцию контрольной точки клиента. Если требуется выполнить восстановление, можно прочитать область перезапуска и извлечь все данные с последней операции контрольной точки. Эти данные инициализирует таблицу транзакций, таблицу "грязных страниц" и таблицу открытых файлов, чтобы их можно было использовать в процессе восстановления.  
  
 Чтение области перезапуска возможно с помощью метода <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>.  
  
 При записи области перезапуска данные в этих фрагментах массива байтов сцепляются в единый массив байтов для добавления в качестве записи. Не делается никаких допущений об обратном разделении данных на фрагменты массива при чтении области перезапуска.  
  
 При успешном выполнении этого метода базовый порядковый номер обновляется. Все записи журнала с порядковыми номерами меньшими, чем новый базовый порядковый номер, недоступны.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Один или несколько аргументов имеют значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="newBaseSeqNum" /> не находится в пределах этой последовательности.  
  
- или - 
Новая или существующая архивная цепочка или база активного журнала недействительна.</exception>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="newBaseSeqNum" /> недопустимо для этой последовательности.</exception>
        <exception cref="T:System.NotSupportedException">Невозможно выполнить операцию, поскольку последовательность записей была открыта с доступом только для чтения.</exception>
        <exception cref="T:System.IO.IOException">Выполнить запрос невозможно из-за непредвиденного исключения ввода-вывода.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательность записей заполнена.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber, reservations As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.WriteRestartArea (data, newBaseSeqNum, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="newBaseSeqNum">Новый базовый порядковый номер. Заданный порядковый номер должен быть больше или равен текущему базовому порядковому номеру.</param>
        <param name="reservations">Коллекция <see cref="T:System.IO.Log.ReservationCollection" />, содержащая резервирование, которое следует использовать для данной области перезапуска.</param>
        <summary>Записывает область перезапуска в объект <see cref="T:System.IO.Log.FileRecordSequence" />. Наследовать этот метод нельзя.</summary>
        <returns>Порядковый номер записанной области перезапуска.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Область перезапуска можно использовать для временного хранения сведений, содержащих последнюю операцию контрольной точки клиента. Если требуется выполнить восстановление, можно прочитать область перезапуска и извлечь все данные с последней операции контрольной точки. Эти данные инициализирует таблицу транзакций, таблицу "грязных страниц" и таблицу открытых файлов, чтобы их можно было использовать в процессе восстановления.  
  
 Чтение области перезапуска возможно с помощью метода <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>.  
  
 При записи области перезапуска данные в этих фрагментах массива байтов сцепляются в единый массив байтов для добавления в качестве записи. Не делается никаких допущений об обратном разделении данных на фрагменты массива при чтении области перезапуска.  
  
 Если задано резервирование, записанная область перезапуска будет занимать место, ранее зарезервированное с помощью содержащегося в коллекции резервирования. Если метод завершается успешно, будет занята минимальная область резервирования, в которой поместятся данные, а эта область резервирования будет удалена из коллекции.  
  
 При успешном выполнении этого метода базовый порядковый номер обновляется. Все записи журнала с порядковыми номерами меньшими, чем новый базовый порядковый номер, недоступны.  
  
 Если последовательность записей была удалена, или если передается неверный аргумент, исключения создаются немедленно, в пределах данной операции. Ошибки, возникшие при выполнении запроса асинхронного добавления, например ошибка диска в процессе запроса ввода-вывода, приводят к созданию исключений при вызове метода <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Один или несколько аргументов имеют значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="newBaseSeqNum" /> не находится в пределах этой последовательности.  
  
-или- 
Новая или существующая архивная цепочка или база активного журнала недействительна.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="reservations" /> не был создан этой последовательностью записи.  
  
-или- 
 Значение параметра <paramref name="newBaseSeqNum" /> недопустимо для этой последовательности.</exception>
        <exception cref="T:System.NotSupportedException">Невозможно выполнить операцию, поскольку последовательность записей была открыта с доступом только для чтения.</exception>
        <exception cref="T:System.IO.IOException">Выполнить запрос невозможно из-за непредвиденного исключения ввода-вывода.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательность записей заполнена.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">В <paramref name="data" /> не удается найти резервирование, достаточное для размещения параметра <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSeqNum As SequenceNumber, reservations As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.WriteRestartArea (data, newBaseSeqNum, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи.</param>
        <param name="newBaseSeqNum">Новый базовый порядковый номер. Заданный порядковый номер должен быть больше или равен текущему базовому порядковому номеру.</param>
        <param name="reservations">Коллекция <see cref="T:System.IO.Log.ReservationCollection" />, содержащая резервирование, которое следует использовать для данной области перезапуска.</param>
        <summary>Записывает область перезапуска в объект <see cref="T:System.IO.Log.FileRecordSequence" />. Наследовать этот метод нельзя.</summary>
        <returns>Порядковый номер записанной области перезапуска.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Область перезапуска можно использовать для временного хранения сведений, содержащих последнюю операцию контрольной точки клиента. Если требуется выполнить восстановление, можно прочитать область перезапуска и извлечь все данные с последней операции контрольной точки. Эти данные инициализирует таблицу транзакций, таблицу "грязных страниц" и таблицу открытых файлов, чтобы их можно было использовать в процессе восстановления.  
  
 Чтение области перезапуска возможно с помощью метода <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>.  
  
 При записи области перезапуска данные в этих фрагментах массива байтов сцепляются в единый массив байтов для добавления в качестве записи. Не делается никаких допущений об обратном разделении данных на фрагменты массива при чтении области перезапуска.  
  
 Если задано резервирование, записанная область перезапуска будет занимать место, ранее зарезервированное с помощью содержащегося в коллекции резервирования. Если метод завершается успешно, будет занята минимальная область резервирования, в которой поместятся данные, а эта область резервирования будет удалена из коллекции.  
  
 При успешном выполнении этого метода базовый порядковый номер обновляется. Все записи журнала с порядковыми номерами меньшими, чем новый базовый порядковый номер, недоступны.  
  
 Если последовательность записей была удалена, или если передается неверный аргумент, исключения создаются немедленно, в пределах данной операции. Ошибки, возникшие при выполнении запроса асинхронного добавления, например ошибка диска в процессе запроса ввода-вывода, приводят к созданию исключений при вызове метода <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Один или несколько аргументов имеют значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="newBaseSeqNum" /> не находится в пределах этой последовательности.  
  
-или- 
Новая или существующая архивная цепочка или база активного журнала недействительна.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="reservations" /> не был создан этой последовательностью записи.  
  
- или - 
 Значение параметра <paramref name="newBaseSeqNum" /> недопустимо для этой последовательности.</exception>
        <exception cref="T:System.NotSupportedException">Невозможно выполнить операцию, поскольку последовательность записей была открыта с доступом только для чтения.</exception>
        <exception cref="T:System.IO.IOException">Выполнить запрос невозможно из-за непредвиденного исключения ввода-вывода.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжить выполнение программы.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательность записей заполнена.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">В <paramref name="data" /> не удается найти резервирование, достаточное для размещения параметра <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
