<Type Name="LogStore" FullName="System.IO.Log.LogStore">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3d2973801edb7f38489df79e4b3d97f234628173" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69245164" /></Metadata><TypeSignature Language="C#" Value="public sealed class LogStore : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit LogStore extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.LogStore" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class LogStore&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class LogStore sealed : IDisposable" />
  <TypeSignature Language="F#" Value="type LogStore = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Представляет хранилище, структурированное журналом.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Класс <xref:System.IO.Log.LogRecordSequence> предоставляет реализацию интерфейса последовательности записей на базе журнала CLFS. Он работает с классом <xref:System.IO.Log.LogStore>, который предоставляет интерфейс для прямого управления файлом журнала CLFS. Хранилище журнала предоставляет хранилище, доступное только для добавления, в наборе областей диска. Класс <xref:System.IO.Log.LogStore> представляет это хранилище, а также предоставляет методы для добавления и удаления контейнеров, задания политики и создания архивов. Класс не предоставляет методы для чтения из хранилища и записи в хранилище; это методы предоставляются классом <xref:System.IO.Log.LogRecordSequence>.  
  
 Отношение между классом <xref:System.IO.Log.LogStore> и классом <xref:System.IO.Log.LogRecordSequence> аналогично отношению между файлом на диске и объектом <xref:System.IO.FileStream>. Файл на диске предоставляет фактическое хранилище, он имеет атрибуты длины и времени последнего обращения, тогда как объект <xref:System.IO.FileStream> предоставляет структуру файла, которая нужна для чтения и записи в файл. Аналогично, класс <xref:System.IO.Log.LogStore> имеет атрибуты политики и коллекции областей диска, а класс <xref:System.IO.Log.LogRecordSequence> предоставляет механизм для чтения и записи данных.  
  
 В отличие от последовательности записей файла, представленной классом <xref:System.IO.Log.FileRecordSequence>, экземпляр <xref:System.IO.Log.LogStore> хранит данные в коллекции областей памяти, представленных экземплярами <xref:System.IO.Log.LogExtent>. Области памяти конкретного экземпляра <xref:System.IO.Log.LogStore> все одинакового размера, пространство экземпляра <xref:System.IO.Log.LogStore> увеличивается или уменьшается с шагом в размер области памяти. Чтобы добавить и удалить области журнала, используйте методы <xref:System.IO.Log.LogExtentCollection.Add%2A> и <xref:System.IO.Log.LogExtentCollection.Remove%2A> объекта <xref:System.IO.Log.LogExtentCollection>, возвращаемого свойством <xref:System.IO.Log.LogStore.Extents%2A>.  
  
 С экземпляром <xref:System.IO.Log.LogStore> могут быть связаны политики. Они представлены экземплярами <xref:System.IO.Log.LogPolicy>, возвращаемыми свойством <xref:System.IO.Log.LogStore.Policy%2A>. Политика диктует правила, которым должен следовать журнал, например, максимальное число областей памяти и минимальный размер. Также политика задает правила увеличения и сжатия хранилища <xref:System.IO.Log.LogStore> в определенных условиях. Кроме того, можно указать, допускается ли архивирование экземпляра <xref:System.IO.Log.LogStore>. Политики задаются для каждого журнала и являются неустойчивыми, это означает, что когда все дескрипторы журнала закрываются, политика перестает существовать.  
  
   
  
## Examples  
 В следующем примере показано, как архивировать хранилище <xref:System.IO.Log.LogStore> в документ XML.  
  
 [!code-csharp[logarchievesnapshot#0](~/samples/snippets/csharp/VS_Snippets_CFX/logarchievesnapshot/cs/logarchievesnapshot.cs#0)]
 [!code-vb[logarchievesnapshot#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/logarchievesnapshot/vb/logarchievesnapshot.vb#0)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.Log.LogStore" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (Microsoft.Win32.SafeHandles.SafeFileHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : Microsoft.Win32.SafeHandles.SafeFileHandle -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore handle" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
      </Parameters>
      <Docs>
        <param name="handle">Дескриптор для файла журнала, инкапсулируемого текущим объектом <see cref="T:System.IO.Log.LogStore" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.Log.LogStore" /> для указанного дескриптора.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="handle" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Не удается привязать дескриптор журнала к пулу потоков.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Доступ к заданному хранилищу журнала запрещен операционной системой.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжать выполнение программы.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к базовому файлу хранилища журналов для открытия.</param>
        <param name="mode">Одно из значений <see cref="T:System.IO.FileMode" />, с помощью которого можно определить способ открытия или создания хранилища.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.Log.LogStore" /> с указанным путем и режимом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот конструктор, чтобы открыть хранилище журнала с указанным путем и режимом. Хранилище открывается с доступом для чтения и записи и имеет общий доступ для чтения.  
  
 В параметре `path` используется следующий синтаксис.  
  
 `log:<physical log name>[::<log client name>]`  
  
 где `<physical log name>` — это допустимый путь к файлу журнала, а `<log client name>` — это уникальный идентификатор клиента. Хранилище журнала должно быть физическим или виртуальным хранилищем журнала, но оно не может быть одновременно обоих типов. После создания хранилища журналов физически или виртуально хранилище сохраняет данный тип на все время своего существования. Физическое хранилище журнала создается с помощью указания только физического имени журнала. Виртуальное хранилище журнала создается с помощью указания как физического имени журнала, так и имени клиента журнала.  
  
 Клиенты, использующие одно имя физического журнала, используют одну коллекцию областей и политику.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="path" /> является пустой строкой ("").  
  
- или - 
 Параметр <paramref name="path" /> содержит только пробелы.  
  
-или- 
 Параметр <paramref name="path" /> содержит один или несколько недопустимых символов.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="mode" /> содержит недопустимое значение.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удается найти файл.</exception>
        <exception cref="T:System.IO.IOException">При открытии хранилища журналов произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Доступ к заданному хранилищу журнала запрещен операционной системой.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Невозможно использовать <see cref="T:System.IO.Log.LogStore" />, так как не установлен требуемый компонент CLFS. Установите компонент CLFS, если он доступен на платформе, или используйте класс <see cref="T:System.IO.Log.FileRecordSequence" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжать выполнение программы.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к базовому файлу хранилища журналов для открытия.</param>
        <param name="mode">Одно из значений <see cref="T:System.IO.FileMode" />, с помощью которого можно определить способ открытия или создания хранилища.</param>
        <param name="access">Одно из значений <see cref="T:System.IO.FileAccess" />, определяющее, каким образом объект <see cref="T:System.IO.Log.LogStore" /> может получить доступ к файлу.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.Log.LogStore" /> с указанным путем, режимом и доступом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот конструктор, чтобы открыть новое хранилище журнала с указанным путем, режимом и доступом. Хранилище открывается с общим доступом для чтения.  
  
 В параметре `path` используется следующий синтаксис.  
  
 `log:<physical log name>[::<log client name>]`  
  
 где `<physical log name>` — это допустимый путь к файлу журнала, а `<log client name>` — это уникальный идентификатор клиента. Хранилище журнала должно быть физическим или виртуальным хранилищем журнала, но оно не может быть одновременно обоих типов. После создания хранилища журналов физически или виртуально хранилище сохраняет данный тип на все время своего существования. Физическое хранилище журнала создается с помощью указания только физического имени журнала. Виртуальное хранилище журнала создается с помощью указания как физического имени журнала, так и имени клиента журнала.  
  
 Клиенты, использующие одно имя физического журнала, используют одну коллекцию областей и политику.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="path" /> является пустой строкой ("").  
  
- или - 
 Параметр <paramref name="path" /> содержит только пробелы.  
  
-или- 
 Параметр <paramref name="path" /> содержит один или несколько недопустимых символов.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="mode" /> содержит недопустимое значение.  
  
-или 
 Параметр <paramref name="access" /> содержит недопустимое значение.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удается найти файл.</exception>
        <exception cref="T:System.IO.IOException">При открытии хранилища журналов произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Доступ к заданному хранилищу журнала запрещен операционной системой.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Невозможно использовать <see cref="T:System.IO.Log.LogStore" />, так как не установлен требуемый компонент CLFS. Установите компонент CLFS, если он доступен на платформе, или используйте класс <see cref="T:System.IO.Log.FileRecordSequence" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжать выполнение программы.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode, access, share)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к базовому файлу хранилища журналов для открытия.</param>
        <param name="mode">Одно из значений <see cref="T:System.IO.FileMode" />, с помощью которого можно определить способ открытия или создания хранилища.</param>
        <param name="access">Одно из значений <see cref="T:System.IO.FileAccess" />, определяющее, каким образом объект <see cref="T:System.IO.Log.LogStore" /> может получить доступ к файлу.</param>
        <param name="share">Одно из значений <see cref="T:System.IO.FileShare" />, с помощью которых можно определить, как процессы будут совместно использовать хранилище журнала.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.Log.LogStore" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор инициализирует новый объект <xref:System.IO.Log.LogStore>, который открывается с помощью указанного пути, режима и доступа. Хранилище открывается с общим указанным доступом.  
  
 В параметре `path` используется следующий синтаксис.  
  
 `log:<physical log name>[::<log client name>]`  
  
 где `<physical log name>` — это допустимый путь к файлу журнала, а `<log client name>` — это уникальный идентификатор клиента. Хранилище журнала должно быть физическим или виртуальным хранилищем журнала, но оно не может быть одновременно обоих типов. После создания хранилища журналов физически или виртуально хранилище сохраняет данный тип на все время своего существования. Физическое хранилище журнала создается с помощью указания только физического имени журнала. Виртуальное хранилище журнала создается с помощью указания как физического имени журнала, так и имени клиента журнала.  
  
 Клиенты, использующие одно имя физического журнала, используют одну коллекцию областей и политику.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="path" /> является пустой строкой ("").  
  
- или - 
 Параметр <paramref name="path" /> содержит только пробелы.  
  
- или - 
 Параметр <paramref name="path" /> содержит один или несколько недопустимых символов.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="mode" /> содержит недопустимое значение.  
  
-или 
 Параметр <paramref name="access" /> содержит недопустимое значение.  
  
- или - 
 Параметр <paramref name="share" /> содержит недопустимое значение.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удается найти файл.</exception>
        <exception cref="T:System.IO.IOException">При открытии хранилища журналов произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Доступ к заданному хранилищу журнала запрещен операционной системой.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Невозможно использовать <see cref="T:System.IO.Log.LogStore" />, так как не установлен требуемый компонент CLFS. Установите компонент CLFS, если он доступен на платформе, или используйте класс <see cref="T:System.IO.Log.FileRecordSequence" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжать выполнение программы.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * System.Security.AccessControl.FileSecurity -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode, access, share, fileSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к базовому файлу хранилища журналов для открытия.</param>
        <param name="mode">Одно из значений <see cref="T:System.IO.FileMode" />, с помощью которого можно определить способ открытия или создания хранилища.</param>
        <param name="access">Одно из значений <see cref="T:System.IO.FileAccess" />, определяющее, каким образом объект <see cref="T:System.IO.Log.LogStore" /> может получить доступ к файлу.</param>
        <param name="share">Одно из значений <see cref="T:System.IO.FileShare" />, с помощью которых можно определить, как процессы будут совместно использовать хранилище журнала.</param>
        <param name="fileSecurity">Одно из значений <see cref="T:System.Security.AccessControl.FileSecurity" />, указывающее тип безопасности, который задается для нового хранилища в случае его создания.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.Log.LogStore" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор инициализирует новый объект <xref:System.IO.Log.LogStore>, который открывается с помощью указанного пути, режима и доступа. Хранилище открывается с общим указанным доступом. В параметре `path` должен использоваться следующий синтаксис.  
  
 `log:<physical log name>[::<log client name>]`  
  
 где `<physical log name>` — это допустимый путь к файлу журнала, а `<log client name>` — это уникальный идентификатор клиента. Хранилище журнала должно быть физическим или виртуальным хранилищем журнала, но оно не может быть одновременно обоих типов. После создания хранилища журналов физически или виртуально хранилище сохраняет данный тип на все время своего существования. Физическое хранилище журнала создается с помощью указания только физического имени журнала. Виртуальное хранилище журнала создается с помощью указания как физического имени журнала, так и имени клиента журнала.  
  
 Клиенты, использующие одно имя физического журнала, используют одну коллекцию областей и политику.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Имя файла хранилища журнала, указанное параметром <paramref name="path" />, является недопустимым.  
  
- или - 
 Параметр <paramref name="Mode" /> имеет значение <see langword="CreateNew" />, которое невозможно использовать без доступа на запись.  
  
-или- 
 Параметр <paramref name="Mode" /> имеет значение <see langword="OpenOrCreate" />, которое невозможно использовать без доступа на запись.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="mode" /> содержит недопустимое значение.  
  
-или 
 Параметр <paramref name="access" /> содержит недопустимое значение.  
  
- или - 
 Параметр <paramref name="share" /> содержит недопустимое значение.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удается найти файл.</exception>
        <exception cref="T:System.IO.IOException">При открытии хранилища журналов произошла ошибка ввода-вывода.  
  
Не удается получить доступ к файлу, указанному в параметре <paramref name="path" />, так как он уже используется другим процессом.  
  
- или - 
Невозможно создать файл, указанный параметром <paramref name="path" />, так как файл или каталог уже существует.  
  
-или- 
Не удается привязать дескриптор журнала к пулу потоков.  
  
- или - 
Указан недопустимый формат или версия файла журнала.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Невозможно использовать <see cref="T:System.IO.Log.LogStore" />, так как не установлен требуемый компонент CLFS. Установите компонент CLFS, если он доступен на платформе, или используйте класс <see cref="T:System.IO.Log.FileRecordSequence" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжать выполнение программы.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательность записей заполнена.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Доступ к заданному хранилищу журнала запрещен операционной системой.</exception>
      </Docs>
    </Member>
    <Member MemberName="Archivable">
      <MemberSignature Language="C#" Value="public bool Archivable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Archivable" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Archivable" />
      <MemberSignature Language="VB.NET" Value="Public Property Archivable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Archivable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Archivable : bool with get, set" Usage="System.IO.Log.LogStore.Archivable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, которое определяет, можно ли архивировать этот экземпляр <see cref="T:System.IO.Log.LogStore" />.</summary>
        <value>Значение <see langword="true" />, если экземпляр <see cref="T:System.IO.Log.LogStore" /> можно архивировать; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если экземпляр <xref:System.IO.Log.LogStore> не архивируется, при вызове методов <xref:System.IO.Log.LogStore.CreateLogArchiveSnapshot%2A> и <xref:System.IO.Log.LogStore.SetArchiveTail%2A> создается исключение <xref:System.NotSupportedException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Обращение к свойству произошло после удаления последовательности.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.BaseSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber BaseSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogStore.BaseSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает самый низкий порядковый номер, соответствующий допустимой записи в экземпляре <see cref="T:System.IO.Log.LogStore" />.</summary>
        <value>Самый низкий порядковый номер, соответствующий допустимой записи в экземпляре <see cref="T:System.IO.Log.LogStore" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Допустимые порядковые номера больше или равны <xref:System.IO.Log.LogStore.BaseSequenceNumber%2A> и меньше <xref:System.IO.Log.LogStore.LastSequenceNumber%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Обращение к свойству произошло после удаления последовательности.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateLogArchiveSnapshot">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Делает моментальный снимок состояния хранилища журналов, необходимого для создания резервной копии.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateLogArchiveSnapshot">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.CreateLogArchiveSnapshot" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateLogArchiveSnapshot () As LogArchiveSnapshot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::LogArchiveSnapshot ^ CreateLogArchiveSnapshot();" />
      <MemberSignature Language="F#" Value="member this.CreateLogArchiveSnapshot : unit -&gt; System.IO.Log.LogArchiveSnapshot" Usage="logStore.CreateLogArchiveSnapshot " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogArchiveSnapshot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Делает моментальный снимок состояния хранилища журналов для создания резервной копии.</summary>
        <returns>Объект <see cref="T:System.IO.Log.LogArchiveSnapshot" />, содержащий состояние, необходимое для создания архива.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере показано, как архивировать хранилище <xref:System.IO.Log.LogStore> в документ XML.  
  
 [!code-csharp[logarchievesnapshot#0](~/samples/snippets/csharp/VS_Snippets_CFX/logarchievesnapshot/cs/logarchievesnapshot.cs#0)]
 [!code-vb[logarchievesnapshot#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/logarchievesnapshot/vb/logarchievesnapshot.vb#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Данное хранилище журналов не может быть архивировано.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.IO.IOException">При создании моментального снимка архива произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.ArgumentException">Аргумент является недопустимым.</exception>
        <exception cref="T:System.InvalidOperationException">Выполнена недопустимая операция.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжать выполнение программы.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательность записей заполнена.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Доступ к заданному хранилищу журнала запрещен операционной системой.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateLogArchiveSnapshot">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot (System.IO.Log.SequenceNumber first, System.IO.Log.SequenceNumber last);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot(valuetype System.IO.Log.SequenceNumber first, valuetype System.IO.Log.SequenceNumber last) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.CreateLogArchiveSnapshot(System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateLogArchiveSnapshot (first As SequenceNumber, last As SequenceNumber) As LogArchiveSnapshot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::LogArchiveSnapshot ^ CreateLogArchiveSnapshot(System::IO::Log::SequenceNumber first, System::IO::Log::SequenceNumber last);" />
      <MemberSignature Language="F#" Value="member this.CreateLogArchiveSnapshot : System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber -&gt; System.IO.Log.LogArchiveSnapshot" Usage="logStore.CreateLogArchiveSnapshot (first, last)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogArchiveSnapshot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="first" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="last" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="first">Начальный порядковый номер находится в диапазоне для архивирования.</param>
        <param name="last">Конечный порядковый номер находится в диапазоне для архивирования.</param>
        <summary>Делает моментальный снимок состояния хранилища журналов для указанных порядковых номеров для создания резервной копии.</summary>
        <returns>Объект <see cref="T:System.IO.Log.LogArchiveSnapshot" />, содержащий состояние, необходимое для создания архива.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Моментальный снимок экрана, возвращаемый этим методом, включает сведения, начинающиеся от базового порядкового номера или порядкового номера архива (что меньше) до последнего порядкового номера. Сведения для последнего порядкового номера не включаются, что означает, что архив включает все записи, за исключением последней. Кроме того, при использовании этого метода начальный порядковый номер SequenceNumber должен быть равен порядковому номер BaseSequenceNumber, чтобы архив был согласованным.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="first" /> или <paramref name="last" /> не лежит между основным и последним порядковыми номерами этой последовательности.</exception>
        <exception cref="T:System.ArgumentException">Значение <paramref name="first" /> больше, чем значение <paramref name="last" /></exception>
        <exception cref="T:System.InvalidOperationException">Выполнена недопустимая операция.</exception>
        <exception cref="T:System.IO.IOException">При создании моментального снимка архива произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.NotSupportedException">Данное хранилище журналов не может быть архивировано.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжать выполнение программы.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Последовательность записей заполнена.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Доступ к заданному хранилищу журнала запрещен операционной системой.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.IO.Log.LogStore.Delete path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к базовому файлу хранилища журналов для удаления.</param>
        <summary>Удаляет хранилище журналов.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="path" /> является пустой строкой ("").  
  
-или- 
 Параметр <paramref name="path" /> содержит только пробелы.  
  
- или - 
 Параметр <paramref name="path" /> содержит один или несколько недопустимых символов.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удается найти файл.</exception>
        <exception cref="T:System.IO.IOException">При открытии хранилища журналов произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Доступ к заданному хранилищу журнала запрещен операционной системой.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="logStore.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает все ресурсы, занятые модулем <see cref="T:System.IO.Log.LogStore" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите метод <xref:System.IO.Log.LogStore.Dispose%2A> по окончании использования объекта <xref:System.IO.Log.LogStore>. Метод <xref:System.IO.Log.LogStore.Dispose%2A> оставляет класс <xref:System.IO.Log.LogStore> в непригодном для использования состоянии. После вызова метода <xref:System.IO.Log.LogStore.Dispose%2A> необходимо удалить все ссылки на объект <xref:System.IO.Log.LogStore>, чтобы сборщик мусора мог освободить память, занимаемую <xref:System.IO.Log.LogStore>.  
  
> [!NOTE]
>  Всегда вызывайте метод <xref:System.IO.Log.LogStore.Dispose%2A> перед освобождением последней ссылки на класс <xref:System.IO.Log.LogStore>. В противном случае используемые им ресурсы не будут освобождены до тех пор, пока сборщик мусора не вызовет для объекта <xref:System.IO.Log.LogStore> метод `Finalize`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
      </Docs>
    </Member>
    <Member MemberName="Extents">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogExtentCollection Extents { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Log.LogExtentCollection Extents" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Extents" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Extents As LogExtentCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::LogExtentCollection ^ Extents { System::IO::Log::LogExtentCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Extents : System.IO.Log.LogExtentCollection" Usage="System.IO.Log.LogStore.Extents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogExtentCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает коллекцию областей журнала, которая содержит данные для этого хранилища журналов.</summary>
        <value>Экземпляр <see cref="T:System.IO.Log.LogExtentCollection" />, содержащий коллекцию областей журнала, которая инкапсулирует данные для этого хранилища журналов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Экземпляр <xref:System.IO.Log.LogStore> хранит данные в коллекции областей диска, представленных экземплярами <xref:System.IO.Log.LogExtent>. Области памяти конкретного экземпляра <xref:System.IO.Log.LogStore> все одинакового размера, пространство экземпляра <xref:System.IO.Log.LogStore> увеличивается или уменьшается с шагом в размер области памяти. Чтобы добавить и удалить области журнала, используйте методы <xref:System.IO.Log.LogExtentCollection.Add%2A> и <xref:System.IO.Log.LogExtentCollection.Remove%2A> объекта <xref:System.IO.Log.LogExtentCollection>, возвращаемого данным свойством.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeBytes">
      <MemberSignature Language="C#" Value="public long FreeBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 FreeBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.FreeBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FreeBytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long FreeBytes { long get(); };" />
      <MemberSignature Language="F#" Value="member this.FreeBytes : int64" Usage="System.IO.Log.LogStore.FreeBytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает число байтов, доступных в хранилище журналов.</summary>
        <value>Число байтов, доступных в хранилище журналов.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Обращение к свойству произошло после удаления последовательности.</exception>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeFileHandle Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeFileHandle Handle" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As SafeFileHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeFileHandle ^ Handle { Microsoft::Win32::SafeHandles::SafeFileHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : Microsoft.Win32.SafeHandles.SafeFileHandle" Usage="System.IO.Log.LogStore.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает дескриптор файла операционной системы для файла журнала, который инкапсулирует текущий экземпляр <see cref="T:System.IO.Log.LogStore" />.</summary>
        <value>Дескриптор файла операционной системы для файла журнала, который инкапсулирует текущий экземпляр <see cref="T:System.IO.Log.LogStore" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.LastSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber LastSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.LastSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogStore.LastSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе возвращает порядковый номер следующей записи, добавляемой в хранилище журналов.</summary>
        <value>Порядковый номер следующей записи, добавляемой в хранилище журналов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Допустимые порядковые номера больше или равны <xref:System.IO.Log.LogStore.BaseSequenceNumber%2A> и меньше <xref:System.IO.Log.LogStore.LastSequenceNumber%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Обращение к свойству произошло после удаления последовательности.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.Log.LogStore.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает размер хранилища журналов в байтах.</summary>
        <value>Размер хранилища журналов в байтах.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Размер хранилища журналов — это сумма размеров областей журнала.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Обращение к свойству произошло после удаления последовательности.</exception>
      </Docs>
    </Member>
    <Member MemberName="Policy">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogPolicy Policy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Log.LogPolicy Policy" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Policy" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Policy As LogPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::LogPolicy ^ Policy { System::IO::Log::LogPolicy ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Policy : System.IO.Log.LogPolicy" Usage="System.IO.Log.LogStore.Policy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает политику, связанную с данным хранилищем журналов.</summary>
        <value>Экземпляр <see cref="T:System.IO.Log.LogPolicy" />, представляющий политику, связанную с данным хранилищем журналов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Экземпляр <xref:System.IO.Log.LogPolicy>, возвращаемый этим свойством, можно использовать, чтобы проверять и управлять политикой журнала, связанной с хранилищем <xref:System.IO.Log.LogStore>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetArchiveTail">
      <MemberSignature Language="C#" Value="public void SetArchiveTail (System.IO.Log.SequenceNumber archiveTail);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetArchiveTail(valuetype System.IO.Log.SequenceNumber archiveTail) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.SetArchiveTail(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetArchiveTail (archiveTail As SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetArchiveTail(System::IO::Log::SequenceNumber archiveTail);" />
      <MemberSignature Language="F#" Value="member this.SetArchiveTail : System.IO.Log.SequenceNumber -&gt; unit" Usage="logStore.SetArchiveTail archiveTail" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="archiveTail" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="archiveTail">Порядковый номер архивной цепочки.</param>
        <summary>Задает порядковый номер архивной цепочки.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Архивная цепочка и меньший из базовых порядковых номеров определяют цепочку журнала.  
  
   
  
## Examples  
 В следующем примере показано, как архивировать хранилище <xref:System.IO.Log.LogStore> в документ XML.  
  
 [!code-csharp[logarchievesnapshot#0](~/samples/snippets/csharp/VS_Snippets_CFX/logarchievesnapshot/cs/logarchievesnapshot.cs#0)]
 [!code-vb[logarchievesnapshot#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/logarchievesnapshot/vb/logarchievesnapshot.vb#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="archiveTail" /> не находится в пределах этой последовательности.</exception>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="archiveTail" /> недопустимо для этой последовательности.</exception>
        <exception cref="T:System.InvalidOperationException">Выполнена недопустимая операция.</exception>
        <exception cref="T:System.IO.IOException">При создании моментального снимка архива произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.NotSupportedException">Данное хранилище журналов не может быть архивировано.</exception>
        <exception cref="T:System.ObjectDisposedException">Метод был вызван после удаления последовательности.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти, чтобы продолжать выполнение программы.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Доступ к заданному хранилищу журнала запрещен операционной системой.</exception>
      </Docs>
    </Member>
    <Member MemberName="StreamCount">
      <MemberSignature Language="C#" Value="public int StreamCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 StreamCount" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.StreamCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StreamCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int StreamCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.StreamCount : int" Usage="System.IO.Log.LogStore.StreamCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает количество потоков журнала в данном хранилище журналов.</summary>
        <value>Количество потоков журнала в данном хранилище журналов.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
