<Type Name="ResourceReader" FullName="System.Resources.ResourceReader">
  <Metadata><Meta Name="ms.openlocfilehash" Value="cc2329cf6988186b9da27d48b6c8d95189893181" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70521565" /></Metadata><TypeSignature Language="C#" Value="public sealed class ResourceReader : System.Resources.IResourceReader" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ResourceReader extends System.Object implements class System.Collections.IEnumerable, class System.IDisposable, class System.Resources.IResourceReader" />
  <TypeSignature Language="DocId" Value="T:System.Resources.ResourceReader" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ResourceReader&#xA;Implements IResourceReader" />
  <TypeSignature Language="C++ CLI" Value="public ref class ResourceReader sealed : System::Resources::IResourceReader" />
  <TypeSignature Language="F#" Value="type ResourceReader = class&#xA;    interface IResourceReader&#xA;    interface IEnumerable&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Resources.Reader</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Resources.ResourceManager</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Resources.IResourceReader</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Перечисляет ресурсы в двоичном файле ресурсов (RESOURCES) путем последовательного считывания пар "ключ-значение" ресурсов.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE [untrusted-data-class-note](~/includes/untrusted-data-class-note.md)]

 Класс предоставляет стандартную реализацию <xref:System.Resources.IResourceReader> интерфейса. <xref:System.Resources.ResourceReader> <xref:System.Resources.ResourceReader> Экземпляр представляет либо изолированный RESOURCES-файл, либо Resources, внедренный в сборку. Он используется для перечисления ресурсов в Resources-файле и получения пар "имя-значение". Он отличается от <xref:System.Resources.ResourceManager> класса, который используется для извлечения указанных именованных ресурсов из Resources-файла, внедренного в сборку. Класс используется для извлечения ресурсов, имена которых известны заранее, в то время как <xref:System.Resources.ResourceReader> класс полезен для извлечения ресурсов, число или точное имя которых неизвестно во время компиляции. <xref:System.Resources.ResourceManager> Например, приложение может использовать файл ресурсов для хранения сведений о конфигурации, упорядоченных в разделы и элементы в разделе, где количество разделов или элементов в разделе не известно заранее. Затем ресурсы можно назвать универсальным образом `Section1`(например `Section1Item2`, `Section1Item1`, и <xref:System.Resources.ResourceReader> т. д.) и извлечь с помощью объекта.  
  
> [!IMPORTANT]
>  Этот тип реализует интерфейс <xref:System.IDisposable>. По окончании использования выдаленную ему память следует прямо или косвенно освободить. Чтобы сделать это прямо, вызовите его метод <xref:System.IDisposable.Dispose%2A> в блоке `try`/`catch`. Чтобы сделать это косвенно, используйте языковые конструкции, такие как `using` (в C#) или `Using` (в Visual Basic). Дополнительные сведения см. в разделе "Использование объекта, реализующего IDisposable" в статье об интерфейсе <xref:System.IDisposable>.  
  
 Дополнительные сведения об использовании <xref:System.Resources.ResourceReader> класса см. в следующих разделах:  
  
-   [Создание экземпляра объекта ResourceReader](#instantiate)  
  
-   [Перечисление ресурсов объекта ResourceReader](#enumerate)  
  
    -   [Извлечение ресурсов с помощью свойств Идиктионаренумератор](#idictionaryenumerator)  
  
    -   [Извлечение ресурсов по имени с помощью Жетресаурцедата](#getresourcedata)  
  
<a name="instantiate"></a>   
## <a name="instantiating-a-resourcereader-object"></a>Создание экземпляра объекта ResourceReader  
 Resources-файл — это двоичный файл, скомпилированный из текстового файла или файла XML. resx программой [Resgen. exe (генератор файлов ресурсов)](~/docs/framework/tools/resgen-exe-resource-file-generator.md). <xref:System.Resources.ResourceReader> Объект может представлять либо автономный RESOURCES-файл, либо RESOURCES-файл, внедренный в сборку.  
  
 Чтобы создать экземпляр <xref:System.Resources.ResourceReader> объекта, считывающего данные из автономного Resources-файла <xref:System.Resources.ResourceReader> , используйте конструктор класса с входным потоком или строкой, содержащей имя Resources-файла. В следующем примере показаны оба подхода. Сначала создается <xref:System.Resources.ResourceReader> объект, представляющий RESOURCES-файл с именем `Resources1.resources` файла. Во втором экземпляре создается <xref:System.Resources.ResourceReader> объект, представляющий Resources- `Resources2.resources` файл, с помощью потока, созданного из файла.  
  
 [!code-csharp[System.Resources.ResourceReader.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/ctor1.cs#2)]
 [!code-vb[System.Resources.ResourceReader.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/ctor1.vb#2)]  
  
 Чтобы создать <xref:System.Resources.ResourceReader> объект, представляющий внедренный RESOURCES-файл, создайте экземпляр <xref:System.Reflection.Assembly> объекта из сборки, в которую внедрен RESOURCES-файл. Его <xref:System.Reflection.Assembly.GetManifestResourceStream%2A?displayProperty=nameWithType> метод <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> возвращает объект, который можно передать конструктору. <xref:System.IO.Stream> В следующем примере создается экземпляр объекта <xref:System.Resources.ResourceReader> , который представляет внедренный RESOURCES-файл.  
  
 [!code-csharp[System.Resources.ResourceReader.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/ctor1.cs#3)]
 [!code-vb[System.Resources.ResourceReader.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/ctor1.vb#3)]  
  
<a name="enumerate"></a>   
## <a name="enumerating-a-resourcereader-objects-resources"></a>Перечисление ресурсов объекта ResourceReader  
 Для перечисления ресурсов в Resources-файле вызывается <xref:System.Resources.ResourceReader.GetEnumerator%2A> метод, который <xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType> возвращает объект. Для перехода от `IDictionaryEnumerator.MoveNext` одного ресурса к другому вызывается метод. Метод возвращает `false` значение, если были перечислены все ресурсы в Resources.  
  
> [!NOTE]
>  Несмотря на <xref:System.Resources.ResourceReader> то, что <xref:System.Collections.IEnumerable> класс реализует интерфейс <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType> <xref:System.Resources.ResourceReader.GetEnumerator%2A?displayProperty=nameWithType> и <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType> метод, метод не предоставляет реализацию. Вместо этого <xref:System.Collections.IDictionaryEnumerator> метод возвращает объект интерфейса, который предоставляет доступ к паре "имя-значение" каждого ресурса. <xref:System.Resources.ResourceReader.GetEnumerator%2A?displayProperty=nameWithType>  
  
 Получить отдельные ресурсы в коллекции можно двумя способами.  
  
-   Можно выполнить итерацию каждого ресурса в <xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType> коллекции и использовать <xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType> свойства для получения имени и значения ресурса. Рекомендуется использовать этот метод, если все ресурсы имеют одинаковый тип или вы знакомы с типом данных каждого ресурса.  
  
-   Вы можете получить имя каждого ресурса при итерации <xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType> коллекции и <xref:System.Resources.ResourceReader.GetResourceData%2A> вызвать метод для получения данных ресурса. Рекомендуется использовать этот подход, если вы не узнаете тип данных каждого ресурса или если предыдущий подход порождает исключения.  
  
<a name="idictionaryenumerator"></a>   
### <a name="retrieving-resources-by-using-idictionaryenumerator-properties"></a>Извлечение ресурсов с помощью свойств Идиктионаренумератор  
 Первый метод перечисления ресурсов в Resources-файле включает непосредственное извлечение пары "имя-значение" для каждого ресурса. После вызова `IDictionaryEnumerator.MoveNext` метода для перехода к каждому ресурсу в коллекции можно получить имя ресурса <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> из свойства и данных ресурса из <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> свойства.  
  
 В следующем примере показано, как получить имя и значение каждого ресурса в Resources-файле с помощью <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> свойств и. <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> Чтобы выполнить пример, создайте следующий текстовый файл с именем Аппликатионресаурцес. txt для определения строковых ресурсов.  
  
```  
Title="Contact Information"  
Label1="First Name:"  
Label2="Middle Name:"  
Label3="Last Name:"  
Label4="SSN:"  
Label5="Street Address:"  
Label6="City:"  
Label7="State:"  
Label8="Zip Code:"  
Label9="Home Phone:"  
Label10="Business Phone:"  
Label11="Mobile Phone:"  
Label12="Other Phone:"  
Label13="Fax:"  
Label14="Email Address:"  
Label15="Alternate Email Address:"  
```  
  
 Затем можно преобразовать текстовый файл ресурсов в двоичный файл с именем Аппликатионресаурцес. Resources с помощью следующей команды:  
  
 **Resgen Аппликатионресаурцес. txt**  
  
 В следующем примере <xref:System.Resources.ResourceReader> класс используется для перечисления каждого ресурса в отдельном двоичном файле. Resources и для вывода имени ключа и соответствующего значения.  
  
 [!code-csharp[System.Resources.ResourceReader.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/class1.cs#1)]
 [!code-vb[System.Resources.ResourceReader.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/class1.vb#1)]  
  
 Попытка получить данные ресурса из <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> свойства может вызвать следующие исключения:  
  
-   Значение <xref:System.FormatException> , если формат данных отличается от ожидаемого.  
  
-   Значение <xref:System.IO.FileNotFoundException> , если не удается найти сборку, содержащую тип, которому принадлежат данные.  
  
-   Значение <xref:System.TypeLoadException> , если тип, которому принадлежат данные, не может быть найден.  
  
 Как правило, эти исключения вызываются, если RESOURCES-файл был изменен вручную, если сборка, в которой определен тип, не включена в приложение или была случайно удалена, или если сборка имеет более раннюю версию, которая предшествует тип. При возникновении одного из этих исключений можно получить ресурсы, перечисляя каждый ресурс и вызвав <xref:System.Resources.ResourceReader.GetResourceData%2A> метод, как показано в следующем разделе. Такой подход позволяет получить некоторую информацию о типе данных, <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> возвращаемом свойством.  
  
<a name="getresourcedata"></a>   
### <a name="retrieving-resources-by-name-with-getresourcedata"></a>Извлечение ресурсов по имени с помощью Жетресаурцедата  
 Второй подход к перечислению ресурсов в Resources-файле также включает перемещение по ресурсам в файле путем вызова `IDictionaryEnumerator.MoveNext` метода. Для каждого ресурса имя ресурса извлекается из <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> свойства, которое затем передается <xref:System.Resources.ResourceReader.GetResourceData%28System.String%2CSystem.String%40%2CSystem.Byte%5B%5D%40%29> в метод для получения данных ресурса. Он возвращается в качестве массива байтов в `resourceData` аргументе.  
  
 Этот подход более неудобен, чем получение имени и значения ресурса из <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> свойств и <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> , поскольку он возвращает фактические байты, которые формируют значение ресурса. Однако если попытка получить ресурс вызывает исключение, <xref:System.Resources.ResourceReader.GetResourceData%2A> метод может помочь определить источник исключения, предоставив сведения о типе данных ресурса. Дополнительные сведения о строке, которая указывает тип данных ресурса, см. в разделе <xref:System.Resources.ResourceReader.GetResourceData%2A>.  
  
 В следующем примере показано, как использовать этот подход для извлечения ресурсов и для выполнения всех возникающих исключений. Он программным образом создает файл binary. Resources, который содержит четыре строки: одно логическое значение, одно целое число `DateTimeTZI` , одно растровое изображение и один пользовательский объект. Чтобы запустить пример, выполните следующие действия.  
  
1.  Создайте сборку с именем Library. dll, которая содержит `DateTimeTZI` структуру. Ниже приведен исходный код для сборки.  
  
     [!code-csharp[System.Resources.ResourceReader.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/library.cs#4)]
     [!code-vb[System.Resources.ResourceReader.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/library.vb#4)]  
  
     Скомпилируйте исходный код в C# с помощью следующей команды:  
  
    ```  
    csc /t:library library.cs  
    ```  
  
     Можно также скомпилировать его в Visual Basic с помощью следующей команды:  
  
    ```  
    vbc library.vb /t:library  
    ```  
  
2.  Скомпилируйте и выполните следующий исходный код, который создает RESOURCES-файл с именем Контактресаурцес. Resources.  
  
     [!code-csharp[System.Resources.ResourceReader.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/createresourceex1.cs#5)]
     [!code-vb[System.Resources.ResourceReader.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/createresourceex1.vb#5)]  
  
     Файл с исходным кодом называется CreateResources.cs. Его можно скомпилировать в C# с помощью следующей команды:  
  
    ```  
    csc CreateResources.cs /r:library.dll  
    ```  
  
     Можно также скомпилировать его в Visual Basic с помощью следующей команды:  
  
    ```  
    vbc CreateResources.vb /r:library.dll  
    ```  
  
3.  Скомпилируйте и выполните следующий код, чтобы перечислить ресурсы в файле Контактресаурцес. Resources.  
  
     [!code-csharp[System.Resources.ResourceReader.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/readresourceex1.cs#6)]
     [!code-vb[System.Resources.ResourceReader.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/readresourceex1.vb#6)]  
  
     После изменения исходного кода (например, путем намеренного создания <xref:System.FormatException> в конце `try` блока) или переименования сборки библиотеки. dll так, чтобы она была недоступна во время выполнения, можно запустить пример, <xref:System.Resources.ResourceReader.GetResourceData%2A> чтобы узнать, как вызовы позволяют извлекать или повторно создавать некоторые сведения о ресурсах.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Resources.ResourceReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE [untrusted-data-instance-note](~/includes/untrusted-data-instance-note.md)].
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceReader (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceReader(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="new System.Resources.ResourceReader : System.IO.Stream -&gt; System.Resources.ResourceReader" Usage="new System.Resources.ResourceReader stream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Входной поток для чтения ресурсов.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Resources.ResourceReader" /> для заданного потока.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Конструктор создает экземпляр <xref:System.Resources.ResourceReader> объекта, который получает ресурсы из автономного Resources-файла или из файла. Resources, внедренного в сборку. <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> Для чтения из автономного Resources-файла создайте экземпляр <xref:System.IO.Stream> объекта и передайте его <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> в конструктор. Чтобы выполнить чтение из внедренного Resources-файла <xref:System.Reflection.Assembly.GetManifestResourceStream%2A?displayProperty=nameWithType> , вызовите метод, используя имя Resources-файла с учетом регистра и <xref:System.IO.Stream> передав возвращенный <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> объект в конструктор.  
  
[!INCLUDE [untrusted-data-instance-note](~/includes/untrusted-data-instance-note.md)]
  
## Examples  
 В примере в этом разделе для определения ресурсов, используемых приложением, `PatientForm.txt` используется следующий txt файл с именем.  
  
```  
  
Title="Top Pet Animal Clinic"  
Label1="Patient Number:"  
Label2="Pet Name:"  
Label3="Species:"  
Label4="Breed:"  
Label5="Date of Birth:"  
Label6="Age:"  
Label7="Owner:"  
Label8="Address:"  
Label9="Home Phone:"  
Label10="Work Phone:"  
Label11="Mobile Phone:"  
  
```  
  
 Файл. txt можно скомпилировать в RESOURCES-файл, выполнив следующую команду:  
  
 **Resgen Патиентформ. txt**  
  
 В следующем примере предполагается, что файл ресурсов внедрен в сборку, содержащую исполняемый код приложения. Он извлекает файл ресурсов с именем `PatientForm.resources` из выполняемых в настоящее время сборок и отображает имя и значение каждого из его ресурсов.  
  
 [!code-csharp[System.Resources.ResourceReader.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/cs/stream1.cs#1)]
 [!code-vb[System.Resources.ResourceReader.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/vb/stream1.vb#1)]  
  
 Если C# пример имеет имя `Example.cs`, его можно скомпилировать с помощью следующей команды:  
  
 **CSC Example.cs/RES: Патиентформ. Resources**  
  
 Если Visual Basic пример имеет имя `Example.vb`, его можно скомпилировать с помощью следующей команды:  
  
 **Vbc example. vb/RES: Патиентформ. Resources**  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="stream" /> недоступен для чтения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="stream" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">При доступе к <paramref name="stream" /> произошла ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для предоставления служб сериализации. Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Связанное перечисление:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceReader (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceReader(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="new System.Resources.ResourceReader : string -&gt; System.Resources.ResourceReader" Usage="new System.Resources.ResourceReader fileName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">Путь к файлу и имя файла ресурсов для чтения. В параметре <c>filename</c> регистр не учитывается.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Resources.ResourceReader" /> для указанного именованного файла ресурсов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Конструктор создает экземпляр <xref:System.Resources.ResourceReader> объекта, который получает ресурсы из автономного Resources-файла. <xref:System.Resources.ResourceReader.%23ctor%28System.String%29> Чтобы извлечь ресурсы из внедренного файла Resources, используйте <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> конструктор.  

[!INCLUDE [untrusted-data-instance-note](~/includes/untrusted-data-instance-note.md)]

## Examples  
 В примере в этом разделе для определения ресурсов, используемых приложением, `PatientForm.txt` используется следующий txt файл с именем.  
  
```  
  
Title="Top Pet Animal Clinic"  
Label1="Patient Number:"  
Label2="Pet Name:"  
Label3="Species:"  
Label4="Breed:"  
Label5="Date of Birth:"  
Label6="Age:"  
Label7="Owner:"  
Label8="Address:"  
Label9="Home Phone:"  
Label10="Work Phone:"  
Label11="Mobile Phone:"  
  
```  
  
 Файл. txt можно скомпилировать в RESOURCES-файл, выполнив следующую команду:  
  
 **Resgen Патиентформ. txt**  
  
 В следующем примере перечисляются ресурсы в `PatientForm.resources` и отображаются имя и значение каждого из них.  
  
 [!code-csharp[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/cs/stream2.cs#2)]
 [!code-vb[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/vb/stream2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="fileName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удается найти файл.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.BadImageFormatException">Файле ресурса имеет недопустимый формат. Например, длина файла может быть равна нулю.</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="resourceReader.Close " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Resources.IResourceReader.Close</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает все ресурсы операционной системы, связанные с этим объектом <see cref="T:System.Resources.ResourceReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader.Close%2A>можно безопасно вызывать несколько раз.  
  
   
  
## Examples  
 В следующем примере выполняется перемещение ресурсов файла и отображение всех найденных пар "ключ-значение". Затем код использует <xref:System.Resources.ResourceReader.Close%2A> метод, чтобы завершить работу <xref:System.Resources.ResourceReader> и освободить все используемые им ресурсы.  
  
 [!code-cpp[System.Resources.ResourceReader.GetEnumerator Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Resources.ResourceReader.GetEnumerator Example/CPP/getenumerator.cpp#1)]
 [!code-csharp[System.Resources.ResourceReader.GetEnumerator Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Resources.ResourceReader.GetEnumerator Example/CS/getenumerator.cs#1)]
 [!code-vb[System.Resources.ResourceReader.GetEnumerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Resources.ResourceReader.GetEnumerator Example/VB/getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="resourceReader.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Resources.ResourceReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда вы завершите работу с этим экземпляром <xref:System.Resources.ResourceReader>, вызовите метод <xref:System.Resources.ResourceReader.Dispose%2A> , чтобы освободить все ресурсы, используемые этим экземпляром. Следует исключить дальнейшие ссылки на этот <xref:System.Resources.ResourceReader> экземпляр, чтобы сборщик мусора мог освободить память экземпляра, а не сохранить его для завершения.  
  
 <xref:System.Resources.ResourceReader.Dispose%2A>вызывает закрытый метод Dispose (Boolean), который содержит код для освобождения управляемых и неуправляемых ресурсов. Дополнительные сведения см. [в разделе Реализация метода Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionaryEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IDictionaryEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionaryEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator" Usage="resourceReader.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Resources.IResourceReader.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает перечислитель для данного объекта <see cref="T:System.Resources.ResourceReader" />.</summary>
        <returns>Перечислитель для данного объекта <see cref="T:System.Resources.ResourceReader" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Как правило, <xref:System.Resources.ResourceReader.GetEnumerator%2A> перечисляются ресурсы путем вызова метода и повторного <xref:System.Collections.IEnumerator.MoveNext%2A> вызова метода для возвращаемого <xref:System.Collections.IDictionaryEnumerator> объекта до тех пор, пока метод `false`не вернет значение. Имя ресурса доступно из <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> свойства; его значение <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> можно получить из свойства. В примере показано, как перечислить ресурсы таким образом.  
  
 Реализация <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> свойства <xref:System.Resources.ResourceReader>  классом может вызывать следующие исключения:  
  
-   <xref:System.IO.FileNotFoundException>  
  
     Не удается найти сборку, содержащую тип, которому принадлежат данные.  
  
-   <xref:System.FormatException>  
  
     Данные имеют формат, отличный от ожидаемого.  
  
-   <xref:System.TypeLoadException>  
  
     Не удается найти тип, которому принадлежат данные.  
  
 Исключение можно реализовать, вызвав <xref:System.Resources.ResourceReader.GetResourceData%2A> метод для получения сведений о типе данных и массиве байтов, назначенном именованному ресурсу. Дополнительные сведения см. в подразделе «получение ресурсов по имени с помощью жетресаурцедата» в <xref:System.Resources.ResourceReader> разделе «класс».  
  
> [!IMPORTANT]
>  <xref:System.Resources.ResourceReader> Класс содержит два метода, возвращающих перечислители. <xref:System.Resources.ResourceReader.GetEnumerator%2A> Метод возвращает объект интерфейса и является рекомендуемым методом для вызова при <xref:System.Collections.IDictionaryEnumerator>  перечислении ресурсов.  
  
   
  
## Examples  
 В примере в этом разделе для определения ресурсов, используемых приложением, `PatientForm.txt` используется следующий txt файл с именем.  
  
```  
  
Title="Top Pet Animal Clinic"  
Label1="Patient Number:"  
Label2="Pet Name:"  
Label3="Species:"  
Label4="Breed:"  
Label5="Date of Birth:"  
Label6="Age:"  
Label7="Owner:"  
Label8="Address:"  
Label9="Home Phone:"  
Label10="Work Phone:"  
Label11="Mobile Phone:"  
  
```  
  
 Файл. txt можно скомпилировать в RESOURCES-файл, выполнив следующую команду:  
  
 **Resgen Патиентформ. txt**  
  
 В следующем примере перечисляются ресурсы в `PatientForm.resources` и отображаются имя и значение каждого из них.  
  
 [!code-csharp[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/cs/stream2.cs#2)]
 [!code-vb[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/vb/stream2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Устройство чтения уже закрыто или удалено, поэтому доступ невозможен.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetResourceData">
      <MemberSignature Language="C#" Value="public void GetResourceData (string resourceName, out string resourceType, out byte[] resourceData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetResourceData(string resourceName, [out] string&amp; resourceType, [out] unsigned int8[]&amp; resourceData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.GetResourceData(System.String,System.String@,System.Byte[]@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetResourceData (resourceName As String, ByRef resourceType As String, ByRef resourceData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetResourceData(System::String ^ resourceName, [Runtime::InteropServices::Out] System::String ^ % resourceType, [Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % resourceData);" />
      <MemberSignature Language="F#" Value="member this.GetResourceData : string *  *  -&gt; unit" Usage="resourceReader.GetResourceData (resourceName, resourceType, resourceData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="resourceType" Type="System.String" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="resourceData" Type="System.Byte[]" RefType="out" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="resourceName">Имя ресурса.</param>
        <param name="resourceType">При возвращении этого метода содержит строку, представляющую имя типа извлекаемого ресурса. Этот параметр передается неинициализированным.</param>
        <param name="resourceData">Когда этот метод возвращает значение, оно содержит массив байтов, являющийся двоичным представлением извлеченного типа. Этот параметр передается неинициализированным.</param>
        <summary>Получает имя типа и данные именованного ресурса из открытого файла ресурсов или потока.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader.GetResourceData%2A> Метод получает значение именованного ресурса в виде массива байтов. Обычно он используется, когда <xref:System.Collections.IDictionaryEnumerator.Value%2A> свойство вызывает исключение при попытке получить значение ресурса.  
  
 `resourceType`Строка, представляющая тип данных ресурса. Может принимать любое из следующих значений:  
  
-   Строковое представление `ResourceTypeCode` элемента перечисления, которое указывает тип данных ресурса. `ResourceTypeCode`— Это частное перечисление, используемое. указывает, что для хранения одного из 19 распространенных типов данных используется специальный двоичный формат. К ним относятся .NET Framework примитивные типы данных<xref:System.Boolean>( <xref:System.Byte> <xref:System.Char>,, <xref:System.Decimal>, <xref:System.Double>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.Single>, , <xref:System.SByte>  , <xref:System.UInt16>  <xref:System.String>, <xref:System.UInt32>, ) <xref:System.UInt64> , а также , <xref:System.DateTime>  и <xref:System.TimeSpan> , кроме того `ResourceTypeCode`  , перечисление включает значения, приведенные в следующей таблице.  
  
    |Значение Ресаурцетипекоде|Описание|  
    |----------------------------|-----------------|  
    |`ResourceTypeCode.ByteArray`|Данные представляют собой массив байтов. Этот тип данных обычно вызывает <xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.Byte%5B%5D%29?displayProperty=nameWithType> метод.|  
    |`ResourceTypeCode.Null`|Данные являются пустой ссылкой. Этот тип данных обычно вызывает <xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.Object%29?displayProperty=nameWithType> метод с объектом, значение которого равно. `null`|  
    |`ResourceTypeCode.Stream`|Данные хранятся в потоке. Этот тип данных обычно вызывает <xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.IO.Stream%29?displayProperty=nameWithType> метод или. <xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.IO.Stream%2CSystem.Boolean%29?displayProperty=nameWithType>|  
  
     Если не было повреждено, его обычно можно преобразовать из массива байтов обратно в исходное значение, <xref:System.BitConverter> вызвав метод или  <xref:System.IO.BinaryReader> . `resourceData`  
  
-   Строка, содержащая полное имя типа, сериализованные данные которого присваиваются `resourceData` аргументу (например, `System.String`). Кроме того, для типов, которые не являются частью библиотеки классов .NET Framework, строка включает имя, версию, язык и региональные параметры, а также открытый ключ сборки, содержащей тип. Например, следующая строка указывает, что сериализованные данные представляют экземпляр `Person` типа `Extensions` в пространстве имен, который находится в версии 1,0 сборки с именем Utility, которая не имеет открытого ключа и не имеет назначенного языка и региональных параметров.  
  
     `Extensions.Person, Utility, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null`  
  
     Если не было повреждено и что исходный тип доступен, `resourceData` можно преобразовать массив байтов обратно в исходное значение путем преобразования массива байтов в <xref:System.IO.Stream> объект и передачи потока в `resourceData` <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter.Deserialize%2A?displayProperty=nameWithType>метод.  
  
-   Строка, используемая для описания типа данных в <xref:System.Resources.ResourceWriter.AddResourceData%2A?displayProperty=nameWithType> вызове метода.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceName" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="resourceName" /> — не существует.</exception>
        <exception cref="T:System.BadImageFormatException">Недопустимый тип параметра <paramref name="resourceName" />.</exception>
        <exception cref="T:System.FormatException">Извлеченные данные ресурсов повреждены.</exception>
        <exception cref="T:System.InvalidOperationException">Текущий объект <see cref="T:System.Resources.ResourceReader" /> не инициализирован (скорее всего, потому что он закрыт).</exception>
        <altmember cref="M:System.Resources.ResourceWriter.AddResourceData(System.String,System.String,System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает перечислитель для данного объекта <see cref="T:System.Resources.ResourceReader" />.</summary>
        <returns>Перечислитель для данного объекта <see cref="T:System.Resources.ResourceReader" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader.System%23Collections%23IEnumerable%23GetEnumerator%2A?displayProperty=nameWithType>является явной реализацией интерфейса. Он может использоваться, только если экземпляр <xref:System.Resources.ResourceReader> приведен к типу интерфейса <xref:System.Collections.IEnumerable>. Рекомендуемый подход к перечислению ресурсов в Resources-файле заключается в вызове <xref:System.Collections.IEnumerator.MoveNext%2A> метода <xref:System.Collections.IDictionaryEnumerator> объекта, возвращаемого <xref:System.Resources.ResourceReader.GetEnumerator%2A?displayProperty=nameWithType> методом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Средство чтения уже закрыто, поэтому доступ невозможен.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает ресурсы, используемые объектом <see cref="T:System.Resources.ResourceReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Вызов Dispose позволяет перераспределить ресурсы, используемые в <xref:System.Resources.ResourceReader> , для других целей. Дополнительные сведения об удалении см. в разделе [Очистка неуправляемых ресурсов](~/docs/standard/garbage-collection/unmanaged.md).

## Examples  
В следующем примере кода выполняется перемещение ресурсов файла и выводятся все найденные пары "ключ-значение". Затем в коде используется метод сеидиспосабле. Dispose для завершения работы <xref:System.Resources.ResourceReader> и освобождения всех используемых ресурсов.

```vb
Imports System
Imports System.Resources
Imports System.Collections

Public Class ReadResources

    Public Shared Sub Main(args() As String)
        ' Create a resource reader for items.resources 
        ' and get an enumerator to iterate through the file. 
        Dim reader As IResourceReader = New ResourceReader("items.resources")
        Dim en As IDictionaryEnumerator = reader.GetEnumerator()

        ' Iterate through the file, printing the key and value pairs. 
        While en.MoveNext()
            Console.WriteLine()
            Console.WriteLine("Name: {0}", en.Key)
            Console.WriteLine("Value: {0}", en.Value)
        End While 

        ' Clean up all resources associated with the reader. 
        ' Calling Dispose is equivalent to calling Close.
        reader.Dispose()
    End Sub 

End Class
```

```csharp
using System;
using System.Resources;
using System.Collections;

public class ReadResources 
{
    public static void Main(string[] args) 
    {
        // Create a resource reader for items.resources 
        // and get an enumerator to iterate through the file.
        IResourceReader reader = new ResourceReader("items.resources");
        IDictionaryEnumerator en = reader.GetEnumerator();

        // Iterate through the file, printing the key/value pairs. 
        while (en.MoveNext()) 
        {
            Console.WriteLine();
            Console.WriteLine("Name: {0}", en.Key);
            Console.WriteLine("Value: {0}", en.Value);
        }

        // Clean up all resources associated with the reader. 
        // Calling Dispose is equivalent to calling Close.
        reader.Dispose();
    }
}
```

```cpp
using namespace System;
using namespace System::Resources;
using namespace System::Collections;
int main()
{
   array<String^>^args = Environment::GetCommandLineArgs();

   // Create a resource reader for items.resources 
   // and get an enumerator to iterate through the file.
   IResourceReader^ reader = gcnew ResourceReader( "items.resources" );
   IDictionaryEnumerator^ en = reader->GetEnumerator();

   // Iterate through the file, printing the key/value pairs. 
   while ( en->MoveNext() )
   {
      Console::WriteLine();
      Console::WriteLine( "Name: {0}", en->Key );
      Console::WriteLine( "Value: {0}", en->Value );
   }

   // Clean up all resources associated with the reader. 
   // Calling the destructor is equivalent to calling Close.
   reader->~IResourceReader();
}
```

]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
