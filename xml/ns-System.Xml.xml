<Namespace Name="System.Xml">
  <Metadata><Meta Name="ms.openlocfilehash" Value="4942d7cc887561db8ff5a6a69b7a87b6a1bca638" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70633996" /></Metadata><Docs>
    <summary>Пространство имен <see cref="N:System.Xml" /> предоставляет основанную на стандартах поддержку обработки XML.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="std"></a>   
## <a name="supported-standards"></a>Поддерживаемые стандарты  
 <xref:System.Xml> Пространство имен поддерживает следующие стандарты:  
  
- [XML 1,0, включая поддержку DTD](https://www.w3.org/TR/2006/REC-xml-20060816/)  
  
- [Пространства имен XML](https://www.w3.org/TR/REC-xml-names/), как на уровне потока, так и в модели DOM  
  
- [XML-схемы](https://www.w3.org/2001/XMLSchema)  
  
- [Выражения XPath](https://www.w3.org/TR/xpath)  
  
- [Преобразования XSLT](https://www.w3.org/TR/xslt)  
  
- [Базовая модель DOM уровня 1](https://www.w3.org/TR/REC-DOM-Level-1/)  
  
- [Ядро DOM уровня 2](https://www.w3.org/TR/DOM-Level-2/)  
  
 В разделе [различия спецификаций W3C](#diff) приведены два варианта, в которых классы XML отличаются от рекомендаций консорциума W3C.  
  
<a name="related"></a>   
## <a name="related-namespaces"></a>Связанные пространства имен  
 .NET Framework также предоставляет другие пространства имен для операций, связанных с XML. Список, описания и ссылки см. на веб-странице [пространства имен System. XML](https://msdn.microsoft.com/library/gg145036.aspx) .  
  
<a name="async"></a>   
## <a name="processing-xml-asynchronously"></a>Асинхронная обработка XML  
 Классы <xref:System.Xml.XmlReader?displayProperty=nameWithType> и <xref:System.Xml.XmlWriter?displayProperty=nameWithType>  включают ряд асинхронных методов, основанных на. Эти методы могут быть идентифицированы строкой Async в конце их имен. С помощью этих методов можно написать асинхронный код, аналогичный синхронному коду, и можно легко перенести существующий синхронный код в асинхронный код.  
  
-   Используйте асинхронные методы в приложениях, где возникает значительная задержка сетевого потока. Избегайте использования асинхронных API-интерфейсов для потоков памяти или локальных файловых потоков операций чтения и записи. Входной поток <xref:System.Xml.XmlTextReader>, и <xref:System.Xml.XmlTextWriter> должен также поддерживать асинхронные операции. В противном случае потоки по-прежнему будут блокироваться операциями ввода-вывода.  
  
-   Не рекомендуется смешивать синхронные и асинхронные вызовы функций, так как вы можете забыть использовать `await` ключевое слово или использовать синхронный API, где требуется асинхронный интерфейс.  
  
-   Не устанавливайте флаг <xref:System.Xml.XmlReaderSettings.Async%2A?displayProperty=nameWithType> <xref:System.Xml.XmlWriterSettings.Async%2A?displayProperty=nameWithType> или, если вы не планируете использовать асинхронный метод. `true`  
  
-   Если вы забыли указать `await` ключевое слово при вызове асинхронного метода, результаты будут недетерминированными: вы можете получить ожидаемый результат или исключение.  
  
-   Когда объект считывает большой текстовый узел, он может кэшировать только частичное текстовое значение и вернуть текстовый узел, поэтому извлечение <xref:System.Xml.XmlReader.Value%2A?displayProperty=nameWithType> свойства может быть заблокировано операцией ввода-вывода. <xref:System.Xml.XmlReader> Используйте метод, чтобы получить текстовое значение в асинхронном режиме, или <xref:System.Xml.XmlReader.ReadValueChunkAsync%2A?displayProperty=nameWithType> используйте метод для чтения большого текстового блока в блоках. <xref:System.Xml.XmlReader.GetValueAsync%2A?displayProperty=nameWithType>  
  
-   При использовании <xref:System.Xml.XmlWriter> объекта <xref:System.Xml.XmlWriter.FlushAsync%2A?displayProperty=nameWithType> вызовите метод перед вызовом <xref:System.Xml.XmlWriter.Close%2A?displayProperty=nameWithType> , чтобы избежать блокировки операции ввода-вывода.  
  
<a name="diff"></a>   
## <a name="differences-from-the-w3c-specs"></a>Отличия спецификаций W3C  
 В двух случаях, в которых задействованы ограничения для компонентов схемы группы <xref:System.Xml> моделей, пространство имен отличается от рекомендаций консорциума W3C.  
  
 **Согласованность в объявлениях элементов:**  
  
 В некоторых случаях, когда используются группы подстановок, <xref:System.Xml> реализация не удовлетворяет "ограничению компонента схемы: объявлений элементов", который описан в разделе [ограничения для компонентов схемы группы моделей](https://go.microsoft.com/fwlink/?LinkId=137029) . спецификации W3C.  
  
 Например, следующая схема включает элементы с одинаковыми именами, но разными типами в одной и той же модели содержимого, и используются группы подстановок. Это может вызвать ошибку, но <xref:System.Xml> компилирует и проверяет схему без ошибок.  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>   
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified">  
  
   <xs:element name="e1" type="t1"/>  
   <xs:complexType name="t1"/>  
  
   <xs:element name="e2" type="t2" substitutionGroup="e1"/>  
      <xs:complexType name="t2">  
         <xs:complexContent>  
            <xs:extension base="t1">  
         </xs:extension>  
      </xs:complexContent>  
   </xs:complexType>  
  
   <xs:complexType name="t3">  
      <xs:sequence>  
         <xs:element ref="e1"/>  
         <xs:element name="e2" type="xs:int"/>  
      </xs:sequence>  
   </xs:complexType>  
</xs:schema>  
```  
  
 В этой схеме тип `t3` содержит последовательность элементов. По причине подстановки ссылка из последовательности на элемент `e1` может привести к образованию либо элемента `e1` типа `t1`, либо элемента `e2` типа `t2`. В последнем случае получится последовательность из двух `e2` элементов, где один имеет тип `t2` , а другой — тип `xs:int`.  
  
 **Однозначное соотнесение примитивов:**  
  
 В следующих случаях <xref:System.Xml> реализация не удовлетворяет параметру "ограничение компонента схемы: уникальное соотнесение примитивов", которое описано в разделе [ограничения для компонентов схемы группы моделей](https://go.microsoft.com/fwlink/?LinkId=137029) W3C Spec.  
  
-   Один из элементов в группе ссылается на другой элемент.  
  
-   Элемент, на который указывает ссылка, является головным элементом группы подстановки.  
  
-   Группа подстановок содержит элемент, имя которого совпадает с именем одного из элементов в группе.  
  
-   Не исправлена кратность элемента, ссылающегося на элемент head группы подстановки, и элемент с тем же именем, что и элемент группы подстановки (minOccurs < maxOccurs).  
  
-   Определение элемента, который ссылается на группу подстановки, предшествует определению элемента с тем же именем, что и элемент группы подстановки.  
  
 Например, в нижеприведенной схеме модель содержимого неоднозначна и может привести к возникновению ошибки компиляции, но <xref:System.Xml> компилирует схему без ошибок.  
  
```xml  
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified">  
  
  <xs:element name="e1" type="xs:int"/>  
  <xs:element name="e2" type="xs:int" substitutionGroup="e1"/>  
  
  <xs:complexType name="t3">  
    <xs:sequence>  
      <xs:element ref="e1" minOccurs="0" maxOccurs="1"/>  
      <xs:element name="e2" type="xs:int" minOccurs="0" maxOccurs="1"/>  
    </xs:sequence>  
  </xs:complexType>  
  
  <xs:element name="e3" type="t3"/>  
</xs:schema>  
```  
  
 При попытке проверить следующий XML на соответствие приведенной выше схеме проверка завершится со следующим сообщением: "элемент E3 имеет недопустимый дочерний элемент" E2 ". и <xref:System.Xml.Schema.XmlSchemaValidationException> будет создано исключение.  
  
```xml  
<e3>  
  <e2>1</e2>  
  <e2>2</e2>  
</e3>  
```  
  
 Чтобы обойти эту проблему, можно переключить объявления элементов в XSD-документе. Например:  
  
```xml  
<xs:sequence>  
  <xs:element ref="e1" minOccurs="0" maxOccurs="1"/>  
  <xs:element name="e2" type="xs:int" minOccurs="0" maxOccurs="1"/>  
</xs:sequence>  
```  
  
 становится  
  
```xml  
<xs:sequence>  
  <xs:element name="e2" type="xs:int" minOccurs="0" maxOccurs="1"/>  
  <xs:element ref="e1" minOccurs="0" maxOccurs="1"/>  
</xs:sequence>  
```  
  
 Вот еще один пример того же выпуска:  
  
```xml  
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified">  
   <xs:element name="e1" type="xs:string"/>  
   <xs:element name="e2" type="xs:string" substitutionGroup="e1"/>  
  
   <xs:complexType name="t3">  
      <xs:sequence>  
         <xs:element ref="e1" minOccurs="0" maxOccurs="1"/>  
         <xs:element name="e2" type="xs:int" minOccurs="0" maxOccurs="1"/>  
      </xs:sequence>  
   </xs:complexType>  
   <xs:element name="e3" type="t3"/>  
</xs:schema>  
```  
  
 При попытке проверить следующий XML на соответствие приведенной выше схеме произойдет сбой проверки со следующим исключением: "необработанное исключение: System. XML. Schema. XmlSchemaValidationException: элемент El" E2 недопустим — значение "ABC" недопустимо. в соответствии с типом `'http://www.w3.org/2001/XMLSchema:int'` данных-строка "ABC" не является допустимым значением Int32 ".
  
```xml  
<e3><e2>abc</e2></e3>  
```  
  
<a name="security"></a>   
## <a name="security-considerations"></a>Замечания по безопасности  
 Типы и члены в <xref:System.Xml> пространстве имен основываются на [системе безопасности .NET](~/docs/standard/security/index.md). В следующих разделах рассматриваются вопросы безопасности, связанные с технологиями XML.
  
 Также обратите внимание, что при <xref:System.Xml> использовании типов и членов, если XML содержит данные, потенциально влияющие на конфиденциальность, необходимо реализовать приложение таким образом, чтобы оно соблюдает конфиденциальность конечных пользователей.
  
 **Внешний доступ**  
  
 Несколько XML-технологий позволяют получать в ходе обработки другие документы. Например, определение типа документа (DTD) может находиться в документе, для которого выполняется синтаксический анализ. DTD может также находиться во внешнем документе, на который ссылается анализируемый документ. Язык XSD и технологии XSLT также позволяют включать сведения из других файлов. Эти внешние ресурсы могут представлять некоторые проблемы безопасности. Например, необходимо убедиться, что приложение извлекает файлы только с надежных сайтов и что извлекаемый файл не содержит вредоносных данных.  
  
 <xref:System.Xml.XmlUrlResolver> Класс используется для загрузки XML-документов и для разрешения внешних ресурсов, таких как сущности, DTD или схемы, а также для импорта или включения директив.  
  
 Этот класс можно переопределить и указать <xref:System.Xml.XmlResolver> используемый объект. Использовать класс <xref:System.Xml.XmlSecureResolver> рекомендуется, если вам необходимо открыть ресурс, которым вы не управляете или к которому нет доверия. Класс <xref:System.Xml.XmlSecureResolver> упаковывает объект <xref:System.Xml.XmlResolver> и позволяет ограничить ресурсы, доступные для базового объекта <xref:System.Xml.XmlResolver>.  
  
 **Отказ в обслуживании**  
  
 Следующие сценарии считаются менее уязвимыми для атак типа «отказ в обслуживании», так как классы <xref:System.Xml> обеспечивают средства защиты от таких атак.  
  
-   Синтаксический анализ текстовых XML-данных.  
  
-   Анализ двоичных XML-данных, если двоичные XML-данные были созданы Microsoft SQL Server.  
  
-   Запись XML-документов и фрагментов из источников данных в файловую систему, потоки, <xref:System.IO.TextWriter> или <xref:System.Text.StringBuilder>.  
  
-   Загрузка документов в объект DOM, если используется объект <xref:System.Xml.XmlReader>, а свойство <xref:System.Xml.XmlReaderSettings.DtdProcessing%2A?displayProperty=nameWithType> имеет значение <xref:System.Xml.DtdProcessing.Prohibit?displayProperty=nameWithType>.  
  
-   Навигация по объекту DOM.  
  
 Приведенные ниже сценарии использовать не рекомендуются, если есть угроза атак типа «отказ в обслуживании» или при работе в ненадежной среде.  
  
-   Обработка DTD.  
  
-   Обработка схем. Сюда относится добавление в коллекцию схем схемы без доверия, компиляция схемы без доверия и проверка с использованием схемы без доверия.  
  
-   Обработка XSLT.  
  
-   Синтаксический анализ произвольного потока предоставленных пользователем двоичных XML-данных.  
  
-   DOM-операции, например запросы, изменение, перемещение поддеревьев между документами и сохранение объектов DOM.  
  
 Если вы беспокоитесь о проблемах отказа в обслуживании или при работе с ненадежными источниками, не включайте обработку DTD. По умолчанию этот параметр отключен <xref:System.Xml.XmlReader> для объектов <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> , создаваемых методом.  
  
> [!NOTE]
>  Класс <xref:System.Xml.XmlTextReader> по умолчанию разрешает обработку DTD. Чтобы отключить эту функцию, воспользуйтесь свойством <xref:System.Xml.XmlTextReader.DtdProcessing%2A?displayProperty=nameWithType>.  
  
 Если обработка DTD включена, можно использовать <xref:System.Xml.XmlSecureResolver> класс для ограничения ресурсов <xref:System.Xml.XmlReader> , к которым может получить доступ. Можно также спроектировать приложение таким образом, чтобы обработка XML была ограничена памятью и временем. Например, можно настроить ограничения времени ожидания в приложении ASP.NET.  
  
 **Вопросы обработки**  
  
 XML-документы могут содержать ссылки на другие файлы, поэтому трудно определить, сколько вычислительных ресурсов потребуется для синтаксического анализа XML-документа. Например, XML-документы могут содержать DTD. Если DTD содержит сущности или сложные модели содержимого, то для синтаксического анализа документа может потребоваться слишком много времени.  
  
 При использовании <xref:System.Xml.XmlReader> можно ограничить размер документа, который может быть подвергнут синтаксическому анализу, задав свойство <xref:System.Xml.XmlReaderSettings.MaxCharactersInDocument%2A?displayProperty=nameWithType>. Можно ограничить число символов, появляющихся в результате раскрытия сущностей, задав свойство <xref:System.Xml.XmlReaderSettings.MaxCharactersFromEntities%2A?displayProperty=nameWithType>. Примеры настройки этих свойств см. в соответствующих разделах справки.  
  
 Технологии XSD и XSLT имеют дополнительные возможности, которые могут влиять на производительность при обработке. Например, можно построить схему XML, для обработки которой даже при сравнительно небольшом размере документа потребуется значительное время. Кроме того, можно внедрять блоки скриптов в таблицу стилей XSLT. Оба варианта представляют потенциальную угрозу безопасности для вашего приложения.  
  
 При создании приложения, использующего <xref:System.Xml.Xsl.XslCompiledTransform> класс, следует учитывать следующие элементы и их последствия.  
  
-   Скрипты XSLT отключены по умолчанию. Скрипты XSLT следует включать только при необходимости в поддержке скриптов и при работе в полностью доверенной среде.  
  
-   Функция XSLT `document()` отключена по умолчанию. Если функция `document()` включена, ограничьте ресурсы, к которым можно получить доступ путем передачи объекта <xref:System.Xml.XmlSecureResolver> методу <xref:System.Xml.Xsl.XslCompiledTransform.Transform%2A?displayProperty=nameWithType>.  
  
-   Объекты расширения по умолчанию включены. Если методу <xref:System.Xml.Xsl.XsltArgumentList> передается объект <xref:System.Xml.Xsl.XslCompiledTransform.Transform%2A?displayProperty=nameWithType>, содержащий объекты расширения, то используются объекты расширения.  
  
-   Таблицы стилей XSLT могут содержать ссылки на другие файлы и внедренные блоки скриптов. Этим может воспользоваться злонамеренный пользователь: он может передать такие данные или таблицы стилей, которые при выполнении будут задействовать все доступные ресурсы компьютера.  
  
-   Приложения XSLT, работающие в среде со смешанным доверием, могут привести к подмене таблицы стилей. Например, злонамеренный пользователь может загрузить объект с вредоносной таблицей стилей и передать ее другому пользователю, который впоследствии вызовет метод <xref:System.Xml.Xsl.XslCompiledTransform.Transform%2A?displayProperty=nameWithType> и выполнит преобразование.  
  
 Чтобы избежать этих проблем безопасности, не следует включатьскрипты или функцию `document()`, если таблица стилей поступает не из надежного источника, а также не следует принимать объекты <xref:System.Xml.Xsl.XslCompiledTransform>, таблицы стилей XSLT или исходные XML-данные из ненадежных источников.  
  
 **Обработка исключений**  
  
 Исключения, вызываемые компонентами нижнего уровня, могут раскрывать сведения о пути, которые не должны предоставляться приложению. Приложения должны перехватывать исключения и обрабатывать их соответствующим образом.  
  
 ]]></format>
    </remarks>
    <altmember cref="N:System.Xml.Xsl" />
    <altmember cref="N:System.Xml.Schema" />
    <altmember cref="N:System.Xml.Linq" />
    <related type="Article" href="~/docs/standard/data/xml/index.md">XML-документы и данные</related>
  </Docs>
</Namespace>