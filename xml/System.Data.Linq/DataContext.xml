<Type Name="DataContext" FullName="System.Data.Linq.DataContext">
  <Metadata><Meta Name="ms.openlocfilehash" Value="4dec371eab23b9b51981b3e008c438d68e467356" /><Meta Name="ms.sourcegitcommit" Value="0084afad1b3b1cb2c8ad2c142ae3597d08bad4a7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="10/31/2019" /><Meta Name="ms.locfileid" Value="73347093" /></Metadata><TypeSignature Language="C#" Value="public class DataContext : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DataContext extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Data.Linq.DataContext" />
  <TypeSignature Language="VB.NET" Value="Public Class DataContext&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataContext : IDisposable" />
  <TypeSignature Language="F#" Value="type DataContext = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Linq</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Представляет основную точку входа для платформы LINQ to SQL.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Linq.DataContext> является источником всех сущностей, сопоставленных с подключением к базе данных. Он отслеживает изменения, внесенные во все извлеченные сущности, и поддерживает "кэш идентификаторов", гарантирующий, что сущности, полученные более одного раза, представляются с помощью одного и того же экземпляра объекта.  
  
 Как правило, экземпляр <xref:System.Data.Linq.DataContext> предназначен для последней "единицы работы", однако приложение определяет этот термин. <xref:System.Data.Linq.DataContext> является легковесной и не требует больших затрат на создание. Типичное [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] приложение создает экземпляры <xref:System.Data.Linq.DataContext> в области метода или как член кратковременных классов, представляющих логический набор связанных операций с базами данных.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Data.Linq.DataContext" />. Используемая строка подключения может представлять собой строку подключения ADO.NET. Кроме того, можно задать имя файла в файле SQL Server Express или SQL Server Compact.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContext (System.Data.IDbConnection connection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.IDbConnection connection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connection As IDbConnection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::Data::IDbConnection ^ connection);" />
      <MemberSignature Language="F#" Value="new System.Data.Linq.DataContext : System.Data.IDbConnection -&gt; System.Data.Linq.DataContext" Usage="new System.Data.Linq.DataContext connection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connection" Type="System.Data.IDbConnection" />
      </Parameters>
      <Docs>
        <param name="connection">Подключение, используемое [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Data.Linq.DataContext" />, ссылаясь на подключение, используемое [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Linq.DataContext> открывает и закрывает подключение к базе данных при необходимости, если вы предоставляете закрытое соединение или строку подключения. В общем случае не следует вызывать `Dispose` на <xref:System.Data.Linq.DataContext>. Если вы предложит открытое соединение, <xref:System.Data.Linq.DataContext> не закроет его. Поэтому не создавайте экземпляр <xref:System.Data.Linq.DataContext> с открытым соединением, если нет веских причин для этого. В <xref:System.Transactions> транзакции <xref:System.Data.Linq.DataContext> не открывает или не закрывает соединение во избежание продвижения.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContext (System.Data.IDbConnection connection, System.Data.Linq.Mapping.MappingSource mapping);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.IDbConnection connection, class System.Data.Linq.Mapping.MappingSource mapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection,System.Data.Linq.Mapping.MappingSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connection As IDbConnection, mapping As MappingSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::Data::IDbConnection ^ connection, System::Data::Linq::Mapping::MappingSource ^ mapping);" />
      <MemberSignature Language="F#" Value="new System.Data.Linq.DataContext : System.Data.IDbConnection * System.Data.Linq.Mapping.MappingSource -&gt; System.Data.Linq.DataContext" Usage="new System.Data.Linq.DataContext (connection, mapping)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connection" Type="System.Data.IDbConnection" />
        <Parameter Name="mapping" Type="System.Data.Linq.Mapping.MappingSource" />
      </Parameters>
      <Docs>
        <param name="connection">Соединение, используемое платформой .NET Framework.</param>
        <param name="mapping">Источник сопоставления.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Data.Linq.DataContext" />, ссылаясь на подключение и источник сопоставления.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContext (string fileOrServerOrConnection, System.Data.Linq.Mapping.MappingSource mapping);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileOrServerOrConnection, class System.Data.Linq.Mapping.MappingSource mapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.String,System.Data.Linq.Mapping.MappingSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileOrServerOrConnection As String, mapping As MappingSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::String ^ fileOrServerOrConnection, System::Data::Linq::Mapping::MappingSource ^ mapping);" />
      <MemberSignature Language="F#" Value="new System.Data.Linq.DataContext : string * System.Data.Linq.Mapping.MappingSource -&gt; System.Data.Linq.DataContext" Usage="new System.Data.Linq.DataContext (fileOrServerOrConnection, mapping)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileOrServerOrConnection" Type="System.String" />
        <Parameter Name="mapping" Type="System.Data.Linq.Mapping.MappingSource" />
      </Parameters>
      <Docs>
        <param name="fileOrServerOrConnection">Этот аргумент может принимать любое из следующих значений: 
Имя файла, где находится база данных SQL Server Express.  
  
Имя сервера, где находится база данных. В этом случае поставщик использует для пользователя базу данных по умолчанию.  
  
Полная строка подключения. [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] просто передает строку поставщику без изменений.</param>
        <param name="mapping">Источник сопоставления.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Data.Linq.DataContext" />, ссылаясь на источник файлов и источник сопоставления.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContext (string fileOrServerOrConnection);" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileOrServerOrConnection) cil managed" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileOrServerOrConnection As String)" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::String ^ fileOrServerOrConnection);" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="new System.Data.Linq.DataContext : string -&gt; System.Data.Linq.DataContext" Usage="new System.Data.Linq.DataContext fileOrServerOrConnection" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C#" Value="public DataContext (string connectionString);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string connectionString) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connectionString As String)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::String ^ connectionString);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="new System.Data.Linq.DataContext : string -&gt; System.Data.Linq.DataContext" Usage="new System.Data.Linq.DataContext connectionString" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileOrServerOrConnection" Type="System.String" Index="0" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="connectionString" Type="System.String" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileOrServerOrConnection">Этот аргумент может принимать любое из следующих значений. Имя файла, где находится база данных SQL Server Express.

Имя сервера, где находится база данных. В этом случае поставщик использует для пользователя базу данных по умолчанию.  
  
Полная строка подключения. LINQ to SQL просто передает строку поставщику без изменений.</param>
        <param name="connectionString">Этот аргумент может принимать любое из следующих значений. Имя файла, где находится база данных SQL Server Express.

Имя сервера, где находится база данных. В этом случае поставщик использует для пользователя базу данных по умолчанию.  
  
Полная строка подключения. LINQ to SQL просто передает строку поставщику без изменений.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Data.Linq.DataContext" />, ссылаясь на источник файла.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ChangeConflicts">
      <MemberSignature Language="C#" Value="public System.Data.Linq.ChangeConflictCollection ChangeConflicts { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Linq.ChangeConflictCollection ChangeConflicts" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.ChangeConflicts" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChangeConflicts As ChangeConflictCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Linq::ChangeConflictCollection ^ ChangeConflicts { System::Data::Linq::ChangeConflictCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ChangeConflicts : System.Data.Linq.ChangeConflictCollection" Usage="System.Data.Linq.DataContext.ChangeConflicts" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.ChangeConflictCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает коллекцию объектов, ставшую причиной конфликта параллелизма, когда был вызван метод <see cref="M:System.Data.Linq.DataContext.SubmitChanges" />.</summary>
        <value>Коллекция объектов, которая вызывала конфликты параллелизма.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующем примере показано, как можно выполнить итерацию коллекции для получения сведений о конфликтах.  
  
   
  
## Examples  
 [!code-csharp[System.Data.Linq.ObjectChangeConflict#1](~/samples/snippets/csharp/VS_Snippets_Data/system.data.linq.objectchangeconflict/cs/program.cs#1)]
 [!code-vb[System.Data.Linq.ObjectChangeConflict#1](~/samples/snippets/visualbasic/VS_Snippets_Data/system.data.linq.objectchangeconflict/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandTimeout">
      <MemberSignature Language="C#" Value="public int CommandTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CommandTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.CommandTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property CommandTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CommandTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CommandTimeout : int with get, set" Usage="System.Data.Linq.DataContext.CommandTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, которое увеличивает время ожидания для запросов (в секундах), для которых в противном случае время ожидания истекло бы в течение времени ожидания по умолчанию.</summary>
        <value>Целочисленное значение, увеличивающее время ожидания (в секундах) для запросов, которые в противном случае истечения времени ожидания по умолчанию.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство возвращает или задает время ожидания команды (в секундах), используемое для выполнения созданных команд (`IDbCommands`). Для получения дополнительной информации см. <xref:System.Data.IDbCommand.CommandTimeout%2A>.  
  
 Если это свойство не задано, для выполнения команды запроса используется значение по умолчанию <xref:System.Data.IDbCommand.CommandTimeout%2A>. Это значение по умолчанию задается поставщиком хранилища. Обратите внимание, что некоторые поставщики могут создавать исключения, если для этого значения задано ненулевое значение.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbConnection Connection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbConnection Connection" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.Connection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connection As DbConnection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbConnection ^ Connection { System::Data::Common::DbConnection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Connection : System.Data.Common.DbConnection" Usage="System.Data.Linq.DataContext.Connection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbConnection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает подключение, используемое платформой.</summary>
        <value>Соединение, используемое платформой.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство можно использовать для взаимодействия с реляционным кодом ADO.NET.  
  
 Возвращенное соединение будет закрыто, если пользователь явно не открыл его.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDatabase">
      <MemberSignature Language="C#" Value="public void CreateDatabase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateDatabase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.CreateDatabase" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateDatabase ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateDatabase();" />
      <MemberSignature Language="F#" Value="member this.CreateDatabase : unit -&gt; unit" Usage="dataContext.CreateDatabase " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает базу данных на сервере.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Имя базы данных формируется с помощью следующего алгоритма:  
  
1. Если база данных определена в строке подключения, используется ее имя.  
1. Если имеется атрибут <xref:System.Data.Linq.Mapping.DatabaseAttribute>, его свойство <xref:System.Data.Linq.Mapping.DatabaseAttribute.Name%2A> используется в качестве имени базы данных.  
1. Если в строке соединения отсутствует тег базы данных и используется строго типизированный <xref:System.Data.Linq.DataContext>, то создается база данных с тем же именем, что и у <xref:System.Data.Linq.DataContext> наследуемого класса.  
1. Если используется слабо типизированный <xref:System.Data.Linq.DataContext>, возникает исключение.  
1. Если <xref:System.Data.Linq.DataContext> создан с помощью имени файла, то создается база данных, соответствующая этому имени файла.  
     
  
## Examples  
 В следующем коде показано, как настроить временную базу данных, а затем удалить ее.  
  
 [!code-csharp[System.Data.Linq.DataContext#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Data.Linq.DataContext/cs/Program.cs#1)]
 [!code-vb[System.Data.Linq.DataContext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Data.Linq.DataContext/vb/Module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/fb7f23c4-4572-4c38-9898-a287807d070c">Практическое руководство. Динамическое создание базы данных (LINQ to SQL)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/4ed76327-54a7-414b-82a9-7579bfcec04b">Сопоставление типов SQL-CLR (LINQ to SQL)</related>
      </Docs>
    </Member>
    <Member MemberName="CreateMethodCallQuery&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="protected internal System.Linq.IQueryable&lt;TResult&gt; CreateMethodCallQuery&lt;TResult&gt; (object instance, System.Reflection.MethodInfo methodInfo, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Linq.IQueryable`1&lt;!!TResult&gt; CreateMethodCallQuery&lt;TResult&gt;(object instance, class System.Reflection.MethodInfo methodInfo, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.CreateMethodCallQuery``1(System.Object,System.Reflection.MethodInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Linq::IQueryable&lt;TResult&gt; ^ CreateMethodCallQuery(System::Object ^ instance, System::Reflection::MethodInfo ^ methodInfo, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.CreateMethodCallQuery : obj * System.Reflection.MethodInfo * obj[] -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="dataContext.CreateMethodCallQuery (instance, methodInfo, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
        <Parameter Name="methodInfo" Type="System.Reflection.MethodInfo" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.5">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">Тип элементов в возвращаемой коллекции.</typeparam>
        <param name="instance">Экземпляр вызова метода (текущий объект).</param>
        <param name="methodInfo">Атрибут <see cref="T:System.Reflection.MethodInfo" /> который определяет метод .NET, соответствующий методу базы данных.</param>
        <param name="parameters">Массив параметров для передачи команде.</param>
        <summary>Выполняет табличную функцию базы данных, связанную с указанным методом .NET.</summary>
        <returns>Коллекция результирующих значений, возвращаемых запросом базы данных.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Data.Linq.DataContext.CreateMethodCallQuery%2A> используется в автоматически создаваемом коде и выступает в качестве прокси-сервера для функций базы данных.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DatabaseExists">
      <MemberSignature Language="C#" Value="public bool DatabaseExists ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DatabaseExists() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.DatabaseExists" />
      <MemberSignature Language="VB.NET" Value="Public Function DatabaseExists () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DatabaseExists();" />
      <MemberSignature Language="F#" Value="member this.DatabaseExists : unit -&gt; bool" Usage="dataContext.DatabaseExists " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Определяет, можно ли открыть связанную базу данных.</summary>
        <returns>Значение <see langword="true" />, если указанную базу данных можно открыть; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует соединение в свойстве <xref:System.Data.Linq.DataContext.Connection%2A>, чтобы попытаться открыть связанную базу данных.  
  
   
  
## Examples  
 В следующем примере этот метод используется для определения того, существует ли уже база данных.  
  
 [!code-csharp[System.Data.Linq.DataContext#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Data.Linq.DataContext/cs/Program.cs#1)]
 [!code-vb[System.Data.Linq.DataContext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Data.Linq.DataContext/vb/Module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferredLoadingEnabled">
      <MemberSignature Language="C#" Value="public bool DeferredLoadingEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DeferredLoadingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.DeferredLoadingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property DeferredLoadingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DeferredLoadingEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DeferredLoadingEnabled : bool with get, set" Usage="System.Data.Linq.DataContext.DeferredLoadingEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, следует ли загружать с задержкой связи "один к одному" или "один ко многим".</summary>
        <value><see langword="true" />, если отложенная загрузка включена; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда код обращается к одной из этих связей, возвращается значение null, если связь является "один к одному", и возвращается пустая коллекция, если она является "один ко многим". Связи по-прежнему можно заполнить, задав свойство <xref:System.Data.Linq.DataContext.LoadOptions%2A>.  
  
 Основным сценарием для этого свойства является возможность извлечения части объектной модели и ее отправки (например, веб-службе).  
  
> [!NOTE]
>  Если это свойство имеет значение `false` после выполнения запроса, возникает исключение. Дополнительные сведения см. в разделе **Допустимые режимы** ниже.  
  
## <a name="valid-modes"></a>Допустимые режимы  
 Для отложенной загрузки требуется отслеживание объектов. Допустимы только следующие три режима:  
  
-   <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> = `false`. <xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> игнорируется и выводится `false`. Это поведение соответствует <xref:System.Data.Linq.DataContext>, доступному только для чтения.  
  
-   <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> = `true`. <xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> = `false`. Эта ситуация соответствует <xref:System.Data.Linq.DataContext>, которая позволяет пользователям загружать граф объектов с помощью директив <xref:System.Data.Linq.DataLoadOptions.LoadWith%2A>, но не включает отложенную загрузку.  
  
-   Для обоих свойств задано значение `true`. Это значение по умолчанию.  
  
 Флаги не могут быть изменены после выполнения запроса. Любое изменение после выполнения первого запроса, использующего этот <xref:System.Data.Linq.DataContext>, вызывает исключение.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteDatabase">
      <MemberSignature Language="C#" Value="public void DeleteDatabase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteDatabase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.DeleteDatabase" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteDatabase ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteDatabase();" />
      <MemberSignature Language="F#" Value="member this.DeleteDatabase : unit -&gt; unit" Usage="dataContext.DeleteDatabase " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет связанную базу данных.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует соединение в свойстве <xref:System.Data.Linq.DataContext.Connection%2A> для задания удаляемой базы данных.  
  
   
  
## Examples  
 В следующем примере показано, как удалить базу данных, которая была временно создана.  
  
 [!code-csharp[System.Data.Linq.DataContext#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Data.Linq.DataContext/cs/Program.cs#1)]
 [!code-vb[System.Data.Linq.DataContext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Data.Linq.DataContext/vb/Module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.Linq.DataContext.Dispose" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Освобождение ресурсов, используемых классом <see cref="T:System.Data.Linq.DataContext" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="dataContext.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Data.Linq.DataContext" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="dataContext.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Значение <see langword="true" /> позволяет освободить как управляемые, так и неуправляемые ресурсы; значение <see langword="false" /> освобождает только неуправляемые ресурсы.</param>
        <summary>Освобождает неуправляемые ресурсы, используемые классом <see cref="T:System.Data.Linq.DataContext" /> (при необходимости освобождает и управляемые ресурсы).</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteCommand">
      <MemberSignature Language="C#" Value="public int ExecuteCommand (string command, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteCommand(string command, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteCommand (command As String, ParamArray parameters As Object()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteCommand(System::String ^ command, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteCommand : string * obj[] -&gt; int" Usage="dataContext.ExecuteCommand (command, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.5">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="command">Выполняемая команда SQL.</param>
        <param name="parameters">Массив параметров для передачи команде. Обратите внимание на следующее поведение. 
Если количество объектов в массиве меньше, чем наибольшее число команд, определенных в командной строке, создается исключение.  
  
Если массив содержит объекты, на которые нет ссылок в командной строке, исключение не создается.  
  
Если значение одного из параметров равно NULL, оно преобразуется в значение <see langword="DBNull.Value" />.</param>
        <summary>Выполняет команды SQL непосредственно в базе данных.</summary>
        <returns>Количество строк, измененных выполненной командой.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод является сквозным механизмом для случаев, когда [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] не обеспечивает адекватное предоставление для конкретного сценария.  
  
 Синтаксис команды практически совпадает с синтаксисом, используемым для создания `DataCommand`ADO.NET. Единственное отличие заключается в том, как задаются параметры. В частности, можно указать параметры, заключив их в фигурные скобки ({...}) и перечисляя их, начиная с 0. Параметр связан с одинаковым пронумерованным объектом в массиве параметров.  
  
 `ExecuteQuery` и `ExecuteCommand` позволяют указать переменное число аргументов для подстановки параметров. Например, можно указать параметры при вызове ExecuteQuery\<TResult >:  
  
```  
db.ExecuteQuery<Customer>("select * from dbo.Customers where City = {0}", "London");  
```  
  
 Другой пример:  
  
```  
db.ExecuteCommand("UPDATE Products SET QuantityPerUnit = {0} WHERE ProductID = {1}", "24 boxes", 5);  
```  
  
 В следующем примере показано, как открыть соединение и передать команду SQL `UPDATE` в ядро SQL.  
  
   
  
## Examples  
 [!code-csharp[DLinqCommunicatingWithDatabase#3](~/samples/snippets/csharp/VS_Snippets_Data/DLinqCommunicatingWithDatabase/cs/Program.cs#3)]
 [!code-vb[DLinqCommunicatingWithDatabase#3](~/samples/snippets/visualbasic/VS_Snippets_Data/DLinqCommunicatingWithDatabase/vb/Module1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteDynamicDelete">
      <MemberSignature Language="C#" Value="protected internal void ExecuteDynamicDelete (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void ExecuteDynamicDelete(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteDynamicDelete(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub ExecuteDynamicDelete (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void ExecuteDynamicDelete(System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.ExecuteDynamicDelete : obj -&gt; unit" Usage="dataContext.ExecuteDynamicDelete entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Сущность, которая будет удалена.</param>
        <summary>Выполняет внутренние методы переопределения удаления для повторного делегирования в [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] задачи создания и выполнения динамического SQL для операций удаления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 См. раздел <xref:System.Data.Linq.DataContext.ExecuteDynamicInsert%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteDynamicInsert">
      <MemberSignature Language="C#" Value="protected internal void ExecuteDynamicInsert (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void ExecuteDynamicInsert(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteDynamicInsert(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub ExecuteDynamicInsert (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void ExecuteDynamicInsert(System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.ExecuteDynamicInsert : obj -&gt; unit" Usage="dataContext.ExecuteDynamicInsert entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Сущность, которая будет вставлена.</param>
        <summary>Выполняет внутренние методы переопределения вставки для повторного делегирования в [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] задачи создания и выполнения динамического SQL для операций вставки.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обратите внимание на следующие моменты.  
  
-   Так как метод имеет защищенный модификатор, его использование требует подкласса <xref:System.Data.Linq.DataContext>.  
  
-   Исключение возникает, если эта операция не вызывается в операции <xref:System.Data.Linq.DataContext.SubmitChanges%2A>. Он не предназначен для вызова в качестве изолированной операции вне области действия операции <xref:System.Data.Linq.DataContext.SubmitChanges%2A>. <xref:System.Data.Linq.DataContext.SubmitChanges%2A> сам вызывает переопределяющие методы, если они реализованы, а предыдущие методы предназначены для вызова в методах переопределения.  
  
-   Разработчик обязан передавать правильную сущность. Реализация проверяет, что переданная сущность будет отслеживанием. Однако разработчик обязан поддерживать заказ или передавать одну и ту же сущность два раза.  
  
-   Разработчик обязан вызывать правильный динамический API. Например, в методе переопределения `Update` может быть вызван только метод <xref:System.Data.Linq.DataContext.ExecuteDynamicUpdate%2A>. [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] не обнаруживает или не проверяет, соответствует ли вызванный динамический метод применимой операции. Результаты не определены, если вызывается неприменимый метод (например, вызывается <xref:System.Data.Linq.DataContext.ExecuteDynamicDelete%2A> для обновляемого объекта).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteDynamicUpdate">
      <MemberSignature Language="C#" Value="protected internal void ExecuteDynamicUpdate (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void ExecuteDynamicUpdate(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteDynamicUpdate(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub ExecuteDynamicUpdate (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void ExecuteDynamicUpdate(System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.ExecuteDynamicUpdate : obj -&gt; unit" Usage="dataContext.ExecuteDynamicUpdate entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Сущность, которая будет обновлена.</param>
        <summary>Выполняет внутренние методы переопределения обновления для повторного делегирования в [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] задачи создания и выполнения динамического SQL для операций обновления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 См. раздел <xref:System.Data.Linq.DataContext.ExecuteDynamicInsert%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteMethodCall">
      <MemberSignature Language="C#" Value="protected internal System.Data.Linq.IExecuteResult ExecuteMethodCall (object instance, System.Reflection.MethodInfo methodInfo, params object[] parameters);" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Data.Linq.IExecuteResult ExecuteMethodCall(object instance, class System.Reflection.MethodInfo methodInfo, object[] parameters) cil managed" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteMethodCall(System.Object,System.Reflection.MethodInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::Data::Linq::IExecuteResult ^ ExecuteMethodCall(System::Object ^ instance, System::Reflection::MethodInfo ^ methodInfo, ... cli::array &lt;System::Object ^&gt; ^ parameters);" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="member this.ExecuteMethodCall : obj * System.Reflection.MethodInfo * obj[] -&gt; System.Data.Linq.IExecuteResult" Usage="dataContext.ExecuteMethodCall (instance, methodInfo, parameters)" />
      <MemberSignature Language="C#" Value="protected System.Data.Linq.IExecuteResult ExecuteMethodCall (object instance, System.Reflection.MethodInfo methodInfo, params object[] parameters);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Data.Linq.IExecuteResult ExecuteMethodCall(object instance, class System.Reflection.MethodInfo methodInfo, object[] parameters) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Data::Linq::IExecuteResult ^ ExecuteMethodCall(System::Object ^ instance, System::Reflection::MethodInfo ^ methodInfo, ... cli::array &lt;System::Object ^&gt; ^ parameters);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.IExecuteResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
        <Parameter Name="methodInfo" Type="System.Reflection.MethodInfo" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.5">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Экземпляр вызова метода (текущий объект).</param>
        <param name="methodInfo">Определяет метод .NET, соответствующий методу базы данных.</param>
        <param name="parameters">Массив параметров для передачи команде.</param>
        <summary>Выполняет хранимую процедуру базы данных или скалярную функцию, связанную с указанным методом .NET.</summary>
        <returns>Результат (возвращаемое значение и выходные параметры) выполнения указанного метода.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Data.Linq.DataContext.ExecuteMethodCall%2A> используется в автоматически создаваемом коде и выступает в качестве прокси-сервера для функций базы данных.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteQuery">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerable ExecuteQuery (Type elementType, string query, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.IEnumerable ExecuteQuery(class System.Type elementType, string query, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteQuery (elementType As Type, query As String, ParamArray parameters As Object()) As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::IEnumerable ^ ExecuteQuery(Type ^ elementType, System::String ^ query, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteQuery : Type * string * obj[] -&gt; System.Collections.IEnumerable" Usage="dataContext.ExecuteQuery (elementType, query, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="query" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.5">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">Тип <see cref="T:System.Collections.Generic.IEnumerable`1" />, который должен быть возвращен.  
  
Алгоритм сопоставления столбцов в результате запроса с полями или свойствами в объекте работает, как показано далее. 
Если поле или свойство сопоставляется с определенным именем столбца, это имя столбца ожидается в наборе результатов.  
  
Если поле или свойство не сопоставляется, столбец с тем же именем, что и поле или свойство, ожидается в наборе результатов.  
  
Сначала в сравнении выполняется поиск совпадения с учетом регистра. Если это совпадение не найдено, следующий поиск выполняется для совпадений без учета регистра.  
  
Запрос должен возвращать все отслеженные поля и свойства объекта (кроме тех, загрузка которых отложена), если выполняются все следующие условия. 
 <c>T</c> является сущностью, явно отслеживаемой <see cref="T:System.Data.Linq.DataContext" />.  
  
 Свойство <see cref="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" /> имеет значение <see langword="true" />.  
  
Сущность имеет первичный ключ.  
  
В противном случае возникает исключение.</param>
        <param name="query">Запрос SQL для выполнения.</param>
        <param name="parameters">Массив параметров для передачи команде. Обратите внимание на следующее поведение. 
Если количество объектов в массиве меньше, чем наибольшее число команд, определенных в командной строке, создается исключение.  
  
Если массив содержит объекты, на которые нет ссылок в командной строке, исключение не создается.  
  
Если значение параметра равно <see langword="null" />, он преобразовывается в <see langword="DBNull.Value" />.</param>
        <summary>Выполняет SQL-запросы непосредственно в базе данных.</summary>
        <returns>Коллекция объектов <see cref="T:System.Collections.Generic.IEnumerable`1" />, возвращаемых запросом.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteQuery&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;TResult&gt; ExecuteQuery&lt;TResult&gt; (string query, params object[] parameters);" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; ExecuteQuery&lt;TResult&gt;(string query, object[] parameters) cil managed" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteQuery(Of TResult) (query As String, ParamArray parameters As Object()) As IEnumerable(Of TResult)" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ ExecuteQuery(System::String ^ query, ... cli::array &lt;System::Object ^&gt; ^ parameters);" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="member this.ExecuteQuery : string * obj[] -&gt; seq&lt;'Result&gt;" Usage="dataContext.ExecuteQuery (query, parameters)" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;TResult&gt; ExecuteQuery&lt;TResult&gt; (string query, params object[] parameters) where TResult : new();" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; ExecuteQuery&lt;.ctor TResult&gt;(string query, object[] parameters) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteQuery(Of TResult As New) (query As String, ParamArray parameters As Object()) As IEnumerable(Of TResult)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; where TResult : gcnew() System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ ExecuteQuery(System::String ^ query, ... cli::array &lt;System::Object ^&gt; ^ parameters);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.ExecuteQuery : string * obj[] -&gt; seq&lt;'Result (requires 'Result : (new : unit -&gt; 'Result))&gt; (requires 'Result : (new : unit -&gt; 'Result))" Usage="dataContext.ExecuteQuery (query, parameters)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="query" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.5">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">Тип элементов в возвращаемой коллекции.</typeparam>
        <param name="query">Запрос SQL для выполнения.</param>
        <param name="parameters">Массив параметров для передачи команде. Обратите внимание на следующее поведение. 
Если количество объектов в массиве меньше, чем наибольшее число команд, определенных в командной строке, создается исключение.  
  
Если массив содержит объекты, на которые нет ссылок в командной строке, исключение не создается.  
  
Если значение параметра равно NULL, он преобразуется в <see langword="DBNull.Value" />.</param>
        <summary>Выполняет запросы SQL непосредственно в базе данных и возвращает объекты.</summary>
        <returns>Коллекция объектов, возвращенных запросом.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод является сквозным механизмом для случаев, когда [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] не предоставляется для конкретного сценария.  
  
 Алгоритм сопоставления столбцов в результате запроса с полями и свойствами в объекте работает следующим образом:  
  
-   Если поле или свойство сопоставляется с определенным именем столбца, это имя столбца ожидается в наборе результатов.  
  
-   Если поле или свойство не сопоставляется, столбец с тем же именем, что и поле или свойство, ожидается в наборе результатов.  
  
-   Сравнение выполняется путем первого поиска совпадения с учетом регистра. Если такое соответствие не найдено, последующий поиск выполняется для совпадений без учета регистра.  
  
-   Запрос должен возвращать все отводимые поля и свойства объекта (за исключением отложенной загрузки), если выполняются все следующие условия.  
  
    -   Если `<T>` является сущностью, явно отслеживающей <xref:System.Data.Linq.DataContext>.  
  
    -   Обжекттраккинженаблед имеет значение true.  
  
    -   Сущность имеет первичный ключ.  
  
     В противном случае возникает исключение.  
  
-   Во всех остальных случаях запрос может получить только подмножество отслеживаний полей и свойств объекта.  
  
 В следующем C# фрагменте кода показан один из способов использования этого метода:  
  
```  
var customers = db.ExecuteQuery<Customer>(@"SELECT CustomerID, CompanyName, ContactName, ContactTitle,   
   Address, City, Region, PostalCode, Country, Phone, Fax  
   FROM   dbo.Customers  
   WHERE  City = {0}", "London");  
  
foreach (Customer c in customers)  
   Console.WriteLine(c.ContactName);  
```  
  
 В Visual Basic  
  
```  
Dim customers = db.ExecuteQuery(Of Customer)("SELECT CustomerID, _    CompanyName, ContactName, ContactTitle, _  
   Address, City, Region, PostalCode, Country, Phone, Fax _  
   FROM dbo.Customers _  
WHERE City = {0}", "London")  
  
For Each c As Customer In customers  
    Console.WriteLine(c.ContactName)  
Next  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChangeSet">
      <MemberSignature Language="C#" Value="public System.Data.Linq.ChangeSet GetChangeSet ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Linq.ChangeSet GetChangeSet() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetChangeSet" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChangeSet () As ChangeSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Linq::ChangeSet ^ GetChangeSet();" />
      <MemberSignature Language="F#" Value="member this.GetChangeSet : unit -&gt; System.Data.Linq.ChangeSet" Usage="dataContext.GetChangeSet " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.ChangeSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает измененные объекты, отслеживаемые <see cref="T:System.Data.Linq.DataContext" />.</summary>
        <returns>Набор объектов возвращается как три коллекции, доступные только для чтения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обратите внимание на следующие моменты.  
  
-   <xref:System.Data.Linq.DataContext.GetChangeSet%2A> могут иметь побочные эффекты, такие как вывод операций вставки и удаления, которые обычно выполняются во время <xref:System.Data.Linq.DataContext.SubmitChanges%2A>. Например, объекты, используемые в следующих операциях, могут создавать соответствующие выводимые операции в следующем списке:  
  
    -   <xref:System.Data.Linq.EntitySet%601.Add%2A> <xref:System.Data.Linq.Table%601.InsertOnSubmit%2A>.  
  
    -   <xref:System.Data.Linq.EntityRef%601> присвоение значения NULL (возможно, из-за <xref:System.Data.Linq.EntitySet%601.Remove%2A> <xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A>.  
  
-   Набор не может быть упорядочен согласно ограничениям внешнего ключа.  
  
-   Значения, сформированные базой данных (например, значения первичного и внешнего ключей, метки времени и т. д.), недоступны. Такие сведения требуют выполнения команды базы данных и, возможно, распространения извлеченных данных (например, внешнего ключа из первичного ключа).  
  
-   Набор измененных объектов вычисляются во время вызова. Последующие вызовы <xref:System.Data.Linq.DataContext.SubmitChanges%2A> могут создать другой набор при внесении дополнительных изменений.  
  
 Выходные данные, если не были внесены изменения, выглядят следующим образом:  
  
 `{Added: 0, Removed: 0, Modified: 0}`  
  
   
  
## Examples  
 [!code-csharp[DLinqDebuggingSupport#2](~/samples/snippets/csharp/VS_Snippets_Data/DLinqDebuggingSupport/cs/Program.cs#2)]
 [!code-vb[DLinqDebuggingSupport#2](~/samples/snippets/visualbasic/VS_Snippets_Data/DLinqDebuggingSupport/vb/Module1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCommand">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbCommand GetCommand (System.Linq.IQueryable query);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Common.DbCommand GetCommand(class System.Linq.IQueryable query) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetCommand(System.Linq.IQueryable)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCommand (query As IQueryable) As DbCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Common::DbCommand ^ GetCommand(System::Linq::IQueryable ^ query);" />
      <MemberSignature Language="F#" Value="member this.GetCommand : System.Linq.IQueryable -&gt; System.Data.Common.DbCommand" Usage="dataContext.GetCommand query" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbCommand</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="System.Linq.IQueryable" />
      </Parameters>
      <Docs>
        <param name="query">Запрос, сведения о команде SQL которого должны быть извлечены.</param>
        <summary>Возвращает сведения о командах SQL, созданных [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)].</summary>
        <returns>Запрошенный объект данных команды.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод является только методом получения и не влияет на состояние <xref:System.Data.Linq.DataContext>.  
  
 Обратите внимание на следующие моменты.  
  
-   Аргумент должен иметь значение, отличное от NULL. В противном случае создается исключение аргумента со значением NULL.  
  
-   Обычные исключения преобразования запросов, возникающие во время выполнения запроса [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] применяются для запроса, который не может быть преобразован.  
  
-   Возвращается только первая команда запроса. В частности, дополнительные команды, используемые для безотлагательной загрузки (<xref:System.Data.Linq.DataLoadOptions.LoadWith%2A>), не включаются.  
  
-   <xref:System.Data.Linq.DataContext> не следит за действиями, выполняемыми пользователем с помощью команды. Например, результаты выполнения возвращаемой команды не отправляются и не влияют на состояние <xref:System.Data.Linq.DataContext>.  
  
   
  
## Examples  
 [!code-csharp[DLinqDebuggingSupport#3](~/samples/snippets/csharp/VS_Snippets_Data/DLinqDebuggingSupport/cs/Program.cs#3)]
 [!code-vb[DLinqDebuggingSupport#3](~/samples/snippets/visualbasic/VS_Snippets_Data/DLinqDebuggingSupport/vb/Module1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIDbCommand">
      <MemberSignature Language="C#" Value="public System.Data.IDbCommand GetIDbCommand (System.Linq.IQueryable query);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.IDbCommand GetIDbCommand(class System.Linq.IQueryable query) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetIDbCommand(System.Linq.IQueryable)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetIDbCommand (query As IQueryable) As IDbCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::IDbCommand ^ GetIDbCommand(System::Linq::IQueryable ^ query);" />
      <MemberSignature Language="F#" Value="member this.GetIDbCommand : System.Linq.IQueryable -&gt; System.Data.IDbCommand" Usage="dataContext.GetIDbCommand query" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDbCommand</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="System.Linq.IQueryable" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="query">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTable">
      <MemberSignature Language="C#" Value="public System.Data.Linq.ITable GetTable (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Linq.ITable GetTable(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetTable(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Linq::ITable ^ GetTable(Type ^ type);" />
      <MemberSignature Language="F#" Value="member this.GetTable : Type -&gt; System.Data.Linq.ITable" Usage="dataContext.GetTable type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.ITable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Тип возвращаемых объектов.</param>
        <summary>Возвращает коллекцию объектов определенного типа, где тип определяется параметром <paramref name="type" />.</summary>
        <returns>Коллекция объектов, определенных параметром <paramref name="type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это слабо типизированная версия <xref:System.Data.Linq.DataContext.GetTable%2A>. Важно иметь слабо типизированную версию, так как это относительно распространенная практика динамического создания запросов. Заставить приложение использовать отражение для вызова правильного универсального метода было бы неудобно.  
  
 Если для определенного типа нет коллекции, создается исключение.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTable&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Linq.Table&lt;TEntity&gt; GetTable&lt;TEntity&gt; () where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Linq.Table`1&lt;!!TEntity&gt; GetTable&lt;class TEntity&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetTable``1" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTable(Of TEntity As Class) () As Table(Of TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; where TEntity : class System::Data::Linq::Table&lt;TEntity&gt; ^ GetTable();" />
      <MemberSignature Language="F#" Value="member this.GetTable : unit -&gt; System.Data.Linq.Table&lt;'Entity (requires 'Entity : null)&gt; (requires 'Entity : null)" Usage="dataContext.GetTable " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.Table&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="TEntity">Тип возвращаемых объектов.</typeparam>
        <summary>Возвращает коллекцию объектов определенного типа, где тип определяется параметром <paramref name="TEntity" />.</summary>
        <returns>Коллекция объектов, определенных параметром <paramref name="TEntity" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод является главной точкой входа для запросов. При создании строго типизированного <xref:System.Data.Linq.DataContext> новые создаваемые свойства инкапсулируют вызовы этого метода. Например, создается свойство `Customers`, которое возвращает `GetTable<Customer>`.  
  
 Если для определенного типа нет коллекции, создается исключение.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadOptions">
      <MemberSignature Language="C#" Value="public System.Data.Linq.DataLoadOptions LoadOptions { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Linq.DataLoadOptions LoadOptions" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.LoadOptions" />
      <MemberSignature Language="VB.NET" Value="Public Property LoadOptions As DataLoadOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Linq::DataLoadOptions ^ LoadOptions { System::Data::Linq::DataLoadOptions ^ get(); void set(System::Data::Linq::DataLoadOptions ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LoadOptions : System.Data.Linq.DataLoadOptions with get, set" Usage="System.Data.Linq.DataContext.LoadOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.DataLoadOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает объект <see cref="T:System.Data.Linq.DataLoadOptions" />, связанный с данным объектом <see cref="T:System.Data.Linq.DataContext" />.</summary>
        <value>Параметры загрузки предварительной выборки для связанных данных.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство получает или задает параметры, используемые для определения поведения предварительной выборки для членов с отложенной загрузкой и членства связанных коллекций.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public System.IO.TextWriter Log { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.TextWriter Log" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.Log" />
      <MemberSignature Language="VB.NET" Value="Public Property Log As TextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::TextWriter ^ Log { System::IO::TextWriter ^ get(); void set(System::IO::TextWriter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Log : System.IO.TextWriter with get, set" Usage="System.Data.Linq.DataContext.Log" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает назначение для записи команды или запроса SQL.</summary>
        <value><see cref="T:System.IO.TextReader" />, используемый для записи команды.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Присвойте этому свойству значение `null`, чтобы отключить ведение журнала команд.  
  
   
  
## Examples  
 В следующем примере сформированный SQL отображается в окне консоли перед отображением результатов запроса.  
  
 [!code-csharp[System.Data.Linq.DataContext#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Data.Linq.DataContext/cs/Program.cs#2)]
 [!code-vb[System.Data.Linq.DataContext#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Data.Linq.DataContext/vb/Module1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mapping">
      <MemberSignature Language="C#" Value="public System.Data.Linq.Mapping.MetaModel Mapping { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Linq.Mapping.MetaModel Mapping" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.Mapping" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Mapping As MetaModel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Linq::Mapping::MetaModel ^ Mapping { System::Data::Linq::Mapping::MetaModel ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Mapping : System.Data.Linq.Mapping.MetaModel" Usage="System.Data.Linq.DataContext.Mapping" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.Mapping.MetaModel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает <see cref="T:System.Data.Linq.Mapping.MetaModel" />, на котором основано сопоставление.</summary>
        <value>Сопоставление между базой данных и объектами домена.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ObjectTrackingEnabled">
      <MemberSignature Language="C#" Value="public bool ObjectTrackingEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ObjectTrackingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property ObjectTrackingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ObjectTrackingEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ObjectTrackingEnabled : bool with get, set" Usage="System.Data.Linq.DataContext.ObjectTrackingEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, включено ли отслеживание объекта.</summary>
        <value><see langword="true" />, включено ли отслеживание объектов; в противном случае <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Установка этого свойства в `false` повышает производительность во время получения, так как меньше элементов для трассировки.  
  
 Создается исключение:  
  
-   Если свойство имеет значение `false` после выполнения запроса.  
  
     Дополнительные сведения см. в разделе допустимые режимы в <xref:System.Data.Linq.DataContext>.  
  
-   Если свойство имеет значение `false` и вызывается <xref:System.Data.Linq.DataContext.SubmitChanges%2A>.  
  
 Если <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> `false`, <xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> игнорируется и рассматривается как `false`. В этом случае <xref:System.Data.Linq.DataContext> доступен только для чтения.  
  
 Если <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> `true`, <xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> `false`. В этом случае <xref:System.Data.Linq.DataContext> позволяет загрузить граф объектов с помощью директив <xref:System.Data.Linq.DataLoadOptions.LoadWith%2A>, но не включает отложенную загрузку.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryCacheEnabled">
      <MemberSignature Language="C#" Value="public bool QueryCacheEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool QueryCacheEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.QueryCacheEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property QueryCacheEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool QueryCacheEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.QueryCacheEnabled : bool with get, set" Usage="System.Data.Linq.DataContext.QueryCacheEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Refresh">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Обновляет состояние объекта, используя данные в базе данных.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод полезен после ошибки оптимистичного параллелизма, чтобы перевести элементы в состояние для другой попытки. Он обновляет состояние примитивных полей и свойств объектов.  
  
> [!NOTE]
>  Если объект находится на стороне « *многие* » связи «один ко многим», внешний ключ для объекта будет установлен, а указатель объекта для другой стороны связи будет установлен в новое значение.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Linq.RefreshMode mode, System.Collections.IEnumerable entities);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Linq.RefreshMode mode, class System.Collections.IEnumerable entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh (mode As RefreshMode, entities As IEnumerable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Linq::RefreshMode mode, System::Collections::IEnumerable ^ entities);" />
      <MemberSignature Language="F#" Value="member this.Refresh : System.Data.Linq.RefreshMode * System.Collections.IEnumerable -&gt; unit" Usage="dataContext.Refresh (mode, entities)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Data.Linq.RefreshMode" />
        <Parameter Name="entities" Type="System.Collections.IEnumerable" />
      </Parameters>
      <Docs>
        <param name="mode">Значение, указывающее, как обрабатываются конфликты оптимистичного параллелизма.</param>
        <param name="entities">Коллекция сущностей, которые должны быть обновлены.</param>
        <summary>Обновляет коллекцию объектов сущности согласно указанному режиму.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Linq.RefreshMode mode, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Linq.RefreshMode mode, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh (mode As RefreshMode, entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Linq::RefreshMode mode, System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.Refresh : System.Data.Linq.RefreshMode * obj -&gt; unit" Usage="dataContext.Refresh (mode, entity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Data.Linq.RefreshMode" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="mode">Значение, указывающее, как обрабатываются конфликты оптимистичного параллелизма.</param>
        <param name="entity">Обновляемый объект.</param>
        <summary>Обновляет объект сущности согласно указанному режиму.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Linq.RefreshMode mode, params object[] entities);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Linq.RefreshMode mode, object[] entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh (mode As RefreshMode, ParamArray entities As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Linq::RefreshMode mode, ... cli::array &lt;System::Object ^&gt; ^ entities);" />
      <MemberSignature Language="F#" Value="member this.Refresh : System.Data.Linq.RefreshMode * obj[] -&gt; unit" Usage="dataContext.Refresh (mode, entities)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Data.Linq.RefreshMode" />
        <Parameter Name="entities" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.5">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="mode">Значение, указывающее, как обрабатываются конфликты оптимистичного параллелизма.</param>
        <param name="entities">Обновляемый массив объектов сущности.</param>
        <summary>Обновляет массив объектов сущности согласно указанному режиму.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubmitChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Вычисляет набор измененных объектов, которые следует вставить, обновить или удалить, и выполняет соответствующие команды для внесения изменений в базу данных.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если для операций вставки, обновления или удаления имеются методы переопределения, <xref:System.Data.Linq.DataContext.SubmitChanges%2A> выполняет эти методы вместо команд [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] по умолчанию.  
  
 <xref:System.Data.Linq.DataContext.SubmitChanges%2A> запускает транзакцию и будет выполнять откат в случае возникновения исключения во время выполнения <xref:System.Data.Linq.DataContext.SubmitChanges%2A>. Однако это не приводит к откату изменений в памяти или их отслеживанию <xref:System.Data.Linq.DataContext>; Эти изменения потребуется откатить вручную. Можно начать с нового экземпляра <xref:System.Data.Linq.DataContext>, если изменения в памяти должны быть отменены.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubmitChanges">
      <MemberSignature Language="C#" Value="public void SubmitChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SubmitChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.SubmitChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub SubmitChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SubmitChanges();" />
      <MemberSignature Language="F#" Value="member this.SubmitChanges : unit -&gt; unit" Usage="dataContext.SubmitChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вычисляет набор измененных объектов, которые следует вставить, обновить или удалить, и выполняет соответствующие команды для внесения изменений в базу данных.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если для операций вставки, обновления или удаления имеются методы переопределения, <xref:System.Data.Linq.DataContext.SubmitChanges%2A> выполняет эти методы вместо команд [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] по умолчанию.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SubmitChanges">
      <MemberSignature Language="C#" Value="public virtual void SubmitChanges (System.Data.Linq.ConflictMode failureMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SubmitChanges(valuetype System.Data.Linq.ConflictMode failureMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.SubmitChanges(System.Data.Linq.ConflictMode)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SubmitChanges (failureMode As ConflictMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SubmitChanges(System::Data::Linq::ConflictMode failureMode);" />
      <MemberSignature Language="F#" Value="abstract member SubmitChanges : System.Data.Linq.ConflictMode -&gt; unit&#xA;override this.SubmitChanges : System.Data.Linq.ConflictMode -&gt; unit" Usage="dataContext.SubmitChanges failureMode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="failureMode" Type="System.Data.Linq.ConflictMode" />
      </Parameters>
      <Docs>
        <param name="failureMode">Действие, выполняемое в случае сбоя отправки. Ниже приведены допустимые аргументы. 
 <see cref="F:System.Data.Linq.ConflictMode.FailOnFirstConflict" /><see cref="F:System.Data.Linq.ConflictMode.ContinueOnConflict" /></param>
        <summary>Отправляет изменения, которые были внесены в извлеченные объекты для основной базы данных, и указывает действие, которое следует выполнить, если не удастся осуществить передачу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Режим сбоя по умолчанию — <xref:System.Data.Linq.ConflictMode.FailOnFirstConflict>.  
  
   
  
## Examples  
 [!code-csharp[System.Data.Linq.ConflictModeEnumeration#1](~/samples/snippets/csharp/VS_Snippets_Data/system.data.linq.conflictmodeenumeration/cs/program.cs#1)]
 [!code-vb[System.Data.Linq.ConflictModeEnumeration#1](~/samples/snippets/visualbasic/VS_Snippets_Data/system.data.linq.conflictmodeenumeration/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transaction">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbTransaction Transaction { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbTransaction Transaction" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.Transaction" />
      <MemberSignature Language="VB.NET" Value="Public Property Transaction As DbTransaction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbTransaction ^ Transaction { System::Data::Common::DbTransaction ^ get(); void set(System::Data::Common::DbTransaction ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Transaction : System.Data.Common.DbTransaction with get, set" Usage="System.Data.Linq.DataContext.Transaction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbTransaction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает локальную транзакцию для использования [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] для доступа к базе данных.</summary>
        <value>Объект транзакции, используемый <see cref="T:System.Data.Linq.DataContext" /> при выполнении запросов и команд.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Основной сценарий для этого свойства — это взаимодействие с реляционным [!INCLUDE[vstecado](~/includes/vstecado-md.md)]ным кодом. Например, это свойство можно использовать при написании собственных методов `Create`/`Update`/`Delete` для установки свойства `Transaction` объекта ADO `Command`.  
  
 Обратите внимание на следующее условия:  
  
-   Если это свойство не было задано явно, метод получения возвращает значение null.  
  
-   Если код выполняется в контексте <xref:System.Transactions.Transaction>, задание этого свойства приводит к возникновению исключения.  
  
-   Если это свойство задано и открыто новое <xref:System.Transactions.Transaction>, то при выполнении запроса или обновления выдается исключение.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Translate">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Преобразовывает существующий <see cref="T:System.Data.IDataReader" /> в объекты.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждая строка в <xref:System.Data.IDataReader> преобразуется в объект в <xref:System.Collections.Generic.IEnumerable%601>.  
  
```  
public IEnumerable<T> Translate<T>(IDataReader reader) {}  
```  
  
 Описание. Этот метод используется для преобразования существующего <xref:System.Data.Common.DbDataReader> в объекты. Каждая строка в <xref:System.Data.Common.DbDataReader> преобразуется в объект в <xref:System.Collections.Generic.IEnumerable%601>.  
  
 **Универсальные параметры:**  
  
 `T`см. в разделе <xref:System.Data.Linq.DataContext.ExecuteQuery%2A>.  
  
 **Вход**  
  
 `Query`: см. описание команды в разделе <xref:System.Data.Linq.DataContext.ExecuteCommand%2A>.  
  
 `Parameters`: см. Описание параметров в разделе <xref:System.Data.Linq.DataContext.ExecuteCommand%2A>.  
  
 **Тип возвращаемого значения:**  
  
 <xref:System.Collections.Generic.IEnumerable%601>: Коллекция объектов, возвращаемых преобразованием.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Translate">
      <MemberSignature Language="C#" Value="public System.Data.Linq.IMultipleResults Translate (System.Data.Common.DbDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Linq.IMultipleResults Translate(class System.Data.Common.DbDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Translate(System.Data.Common.DbDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function Translate (reader As DbDataReader) As IMultipleResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Linq::IMultipleResults ^ Translate(System::Data::Common::DbDataReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.Translate : System.Data.Common.DbDataReader -&gt; System.Data.Linq.IMultipleResults" Usage="dataContext.Translate reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.IMultipleResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
      </Parameters>
      <Docs>
        <param name="reader">Преобразуемая структура <see cref="T:System.Data.IDataReader" />.</param>
        <summary>Преобразовывает существующий <see cref="T:System.Data.Common.DbDataReader" /> в объекты.</summary>
        <returns>Список объектов, возвращаемых преобразованием.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Translate">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerable Translate (Type elementType, System.Data.Common.DbDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.IEnumerable Translate(class System.Type elementType, class System.Data.Common.DbDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Translate(System.Type,System.Data.Common.DbDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function Translate (elementType As Type, reader As DbDataReader) As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::IEnumerable ^ Translate(Type ^ elementType, System::Data::Common::DbDataReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.Translate : Type * System.Data.Common.DbDataReader -&gt; System.Collections.IEnumerable" Usage="dataContext.Translate (elementType, reader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
      </Parameters>
      <Docs>
        <param name="elementType">Тип <see cref="T:System.Collections.Generic.IEnumerable`1" />, который должен быть возвращен.  
  
Алгоритм сопоставления столбцов в результате с полями и свойствами в объекте работает таким образом: 
Если поле или свойство сопоставляется с определенным именем столбца, это имя столбца ожидается в наборе результатов.  
  
Если поле или свойство не сопоставляется, столбец с тем же именем, что и поле или свойство, ожидается в наборе результатов.  
  
Сначала в сравнении выполняется поиск совпадения с учетом регистра. Если это совпадение не найдено, следующий поиск выполняется для совпадений без учета регистра.  
  
Запрос должен возвращать все отслеженные поля и свойства объекта (кроме тех, загрузка которых отложена), если выполняются все следующие условия. 
 <c>T</c> является сущностью, явно отслеживаемой <see cref="T:System.Data.Linq.DataContext" />.  
  
 Свойство <see cref="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" /> имеет значение <see langword="true" />.  
  
Сущность имеет первичный ключ.  
  
В противном случае возникает исключение.</param>
        <param name="reader">Преобразуемая структура <see cref="T:System.Data.IDataReader" />.</param>
        <summary>Преобразовывает существующий <see cref="T:System.Data.Common.DbDataReader" /> в объекты.</summary>
        <returns>Список объектов, возвращаемых преобразованием.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Translate&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;TResult&gt; Translate&lt;TResult&gt; (System.Data.Common.DbDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Translate&lt;TResult&gt;(class System.Data.Common.DbDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Translate``1(System.Data.Common.DbDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function Translate(Of TResult) (reader As DbDataReader) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ Translate(System::Data::Common::DbDataReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.Translate : System.Data.Common.DbDataReader -&gt; seq&lt;'Result&gt;" Usage="dataContext.Translate reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Тип <see cref="T:System.Collections.Generic.IEnumerable`1" />, который должен быть возвращен.</typeparam>
        <param name="reader">Преобразуемая структура <see cref="T:System.Data.IDataReader" />.</param>
        <summary>Преобразовывает существующий <see cref="T:System.Data.Common.DbDataReader" /> в объекты.</summary>
        <returns>Коллекция объектов, возвращаемых преобразованием.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
